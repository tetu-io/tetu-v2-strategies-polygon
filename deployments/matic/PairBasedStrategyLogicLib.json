{
  "address": "0xE8dfB7074F4E14b7eDD1E08C03Fa6079c9E091b5",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "int24",
          "name": "tick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickRange",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickSpacing",
          "type": "int24"
        }
      ],
      "name": "calcTickRange",
      "outputs": [
        {
          "internalType": "int24",
          "name": "lowerTick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick",
          "type": "int24"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x1b785105e5b16a4da767fb5226e6bd9a4c9c16e1b656b994bb66e112740e245b",
  "receipt": {
    "to": null,
    "from": "0xF1dCce3a6c321176C62b71c091E3165CC9C3816E",
    "contractAddress": "0xE8dfB7074F4E14b7eDD1E08C03Fa6079c9E091b5",
    "transactionIndex": 88,
    "gasUsed": "2198228",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000040000000000000000000000080000000080000000004000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004200000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000100000",
    "blockHash": "0xa97df3e4ef402f1da0e358d07c6ffe190625299916fd55704801effc740afa40",
    "transactionHash": "0x1b785105e5b16a4da767fb5226e6bd9a4c9c16e1b656b994bb66e112740e245b",
    "logs": [
      {
        "transactionIndex": 88,
        "blockNumber": 52238137,
        "transactionHash": "0x1b785105e5b16a4da767fb5226e6bd9a4c9c16e1b656b994bb66e112740e245b",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000f1dcce3a6c321176c62b71c091e3165cc9c3816e",
          "0x00000000000000000000000090b11143a0cb64e067402307bc7f2276dcec8250"
        ],
        "data": "0x000000000000000000000000000000000000000000000000000bb6ea429cec00000000000000000000000000000000000000000000000001808920c5074ac2ed0000000000000000000000000000000000000000000000676ef480848769dfef000000000000000000000000000000000000000000000001807d69dac4add6ed0000000000000000000000000000000000000000000000676f00376eca06cbef",
        "logIndex": 326,
        "blockHash": "0xa97df3e4ef402f1da0e358d07c6ffe190625299916fd55704801effc740afa40"
      }
    ],
    "blockNumber": 52238137,
    "cumulativeGasUsed": "13139217",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 12,
  "solcInputHash": "da1a131c81810b0ec86f8a1b7470ae1a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"int24\",\"name\":\"tick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickRange\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickSpacing\",\"type\":\"int24\"}],\"name\":\"calcTickRange\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"_beforeDeposit(ITetuConverter,uint256,address,address,uint256,mapping(address => uint256) storage)\":{\"params\":{\"amount_\":\"Amount of tokenA\",\"liquidationThresholds\":\"Dust-thresholds for the tokens A and B\",\"prop0\":\"Required proportion of underlying, > 0. Proportion of not-underlying is calculates as 1e18 - {prop0}\",\"tokenA\":\"Underlying\",\"tokenB\":\"Not-underlying\"},\"returns\":{\"tokenAmounts\":\"Amounts of token A and B to be deposited, [A, B]\"}},\"getDefaultState(PairBasedStrategyLogicLib.PairState storage)\":{\"returns\":{\"addr\":\"[tokenA, tokenB, pool, profitHolder]\",\"boolValues\":\"[isStablePool, depositorSwapTokens]\",\"nums\":\"[totalLiquidity, fuse-status-tokenA, withdrawDone, 4 thresholds of token A, lastRebalanceNoSwap, 5 reserved values]\",\"tickData\":\"[tickSpacing, lowerTick, upperTick, rebalanceTickRange]\"}},\"needStrategyRebalance(PairBasedStrategyLogicLib.PairState storage,ITetuConverter,int24,uint256)\":{\"returns\":{\"needRebalance\":\"A boolean indicating if {rebalanceNoSwaps} should be called\"}},\"quoteWithdrawByAgg(PairBasedStrategyLogicLib.PairState storage,bytes,uint256[],address,ITetuConverter,mapping(address => uint256) storage)\":{\"params\":{\"amounts_\":\"Amounts of [underlying, not-underlying] that will be received from the pool before withdrawing\"}},\"setInitialDepositorValues(PairBasedStrategyLogicLib.PairState storage,address[4],int24[4],bool,uint256[4])\":{\"params\":{\"addr\":\"[pool, asset, pool.token0(), pool.token1()]        asset: Underlying asset of the depositor.\",\"fuseThresholds\":\"Fuse thresholds for tokens (stable pool only)\",\"pairState\":\"Depositor storage state struct to be initialized\",\"tickData\":\"[tickSpacing, lowerTick, upperTick, rebalanceTickRange]\"}},\"withdrawByAggStep(address[5],uint256[4],bytes,bytes,address[2],mapping(address => uint256) storage)\":{\"params\":{\"addr_\":\"[tokenToSwap, aggregator, controller, converter, splitter]\",\"tokens\":\"[underlying, not-underlying] (values been read from pairBase)\",\"values_\":\"[amountToSwap_, profitToCover, oldTotalAssets, not used here]\"},\"returns\":{\"completed\":\"All debts were closed, leftovers were swapped to proper proportions\",\"tokenAmounts\":\"Amounts to be deposited to pool. If {tokenAmounts} contains zero amount return empty array.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"_beforeDeposit(ITetuConverter,uint256,address,address,uint256,mapping(address => uint256) storage)\":{\"notice\":\"Prepare array of amounts ready to deposit, borrow missed amounts\"},\"getDefaultState(PairBasedStrategyLogicLib.PairState storage)\":{\"notice\":\"Returns the current state of the contract\"},\"needStrategyRebalance(PairBasedStrategyLogicLib.PairState storage,ITetuConverter,int24,uint256)\":{\"notice\":\"Determine if the strategy needs to be rebalanced.\"},\"quoteWithdrawByAgg(PairBasedStrategyLogicLib.PairState storage,bytes,uint256[],address,ITetuConverter,mapping(address => uint256) storage)\":{\"notice\":\"Get info about a swap required by next call of {withdrawByAggStep} within the given plan\"},\"setInitialDepositorValues(PairBasedStrategyLogicLib.PairState storage,address[4],int24[4],bool,uint256[4])\":{\"notice\":\"Set the initial values to PairState instance\"},\"withdrawByAggStep(address[5],uint256[4],bytes,bytes,address[2],mapping(address => uint256) storage)\":{\"notice\":\"Calculate amounts to be deposited to pool, calculate loss, fix profitToCover\"}},\"notice\":\"Library for the UniV3-like strategies with two tokens in the pool\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/pair/PairBasedStrategyLogicLib.sol\":\"PairBasedStrategyLogicLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IControllable {\\n\\n  function isController(address _contract) external view returns (bool);\\n\\n  function isGovernance(address _contract) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0xc2ef11f0141e7e1a5df255be2e1552044deed377349cb886908f3f10ded57fa8\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IController {\\n\\n  // --- DEPENDENCY ADDRESSES\\n  function governance() external view returns (address);\\n\\n  function voter() external view returns (address);\\n\\n  function liquidator() external view returns (address);\\n\\n  function forwarder() external view returns (address);\\n\\n  function investFund() external view returns (address);\\n\\n  function veDistributor() external view returns (address);\\n\\n  function platformVoter() external view returns (address);\\n\\n  // --- VAULTS\\n\\n  function vaults(uint id) external view returns (address);\\n\\n  function vaultsList() external view returns (address[] memory);\\n\\n  function vaultsListLength() external view returns (uint);\\n\\n  function isValidVault(address _vault) external view returns (bool);\\n\\n  // --- restrictions\\n\\n  function isOperator(address _adr) external view returns (bool);\\n\\n\\n}\\n\",\"keccak256\":\"0x86716b8a4775605c31b8bb9f90f8f4a18b709ff4435182f3a148803368060a8c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x5f43ed533d0fc4dc2f8f081d2c4b77960f3e908d5f7359096b385e5673f1ba0c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n     */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n     */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n     */\\n  function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x953f20efa64081a325109a0e03602b889d2819c2b51c1e1fb21a062feeda74f3\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x9f69f84d864c2a84de9321871aa52f6f70d14afe46badbcd37c0d4f22af75e7b\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IForwarder {\\n\\n  function tetu() external view returns (address);\\n  function tetuThreshold() external view returns (uint);\\n\\n  function tokenPerDestinationLength(address destination) external view returns (uint);\\n\\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\\n\\n  function amountPerDestination(address token, address destination) external view returns (uint amount);\\n\\n  function registerIncome(\\n    address[] memory tokens,\\n    uint[] memory amounts,\\n    address vault,\\n    bool isDistribute\\n  ) external;\\n\\n  function distributeAll(address destination) external;\\n\\n  function distribute(address token) external;\\n\\n  function setInvestFundRatio(uint value) external;\\n\\n  function setGaugesRatio(uint value) external;\\n\\n}\\n\",\"keccak256\":\"0x687c497fc034e8d64bca403bac1bf4cd7bd1f107df414c2657325c1b3ab92822\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ISplitter {\\n\\n  function init(address controller_, address _asset, address _vault) external;\\n\\n  // *************** ACTIONS **************\\n\\n  function withdrawAllToVault() external;\\n\\n  function withdrawToVault(uint256 amount) external;\\n\\n  function coverPossibleStrategyLoss(uint earned, uint lost) external;\\n\\n  function doHardWork() external;\\n\\n  function investAll() external;\\n\\n  // **************** VIEWS ***************\\n\\n  function asset() external view returns (address);\\n\\n  function vault() external view returns (address);\\n\\n  function totalAssets() external view returns (uint256);\\n\\n  function isHardWorking() external view returns (bool);\\n\\n  function strategies(uint i) external view returns (address);\\n\\n  function strategiesLength() external view returns (uint);\\n\\n  function HARDWORK_DELAY() external view returns (uint);\\n\\n  function lastHardWorks(address strategy) external view returns (uint);\\n\\n  function pausedStrategies(address strategy) external view returns (bool);\\n\\n  function pauseInvesting(address strategy) external;\\n\\n  function continueInvesting(address strategy, uint apr) external;\\n\\n  function rebalance(uint percent, uint lossTolerance) external;\\n\\n  function getStrategyCapacity(address strategy) external view returns (uint capacity);\\n\\n}\\n\",\"keccak256\":\"0x266c43734e3da96d9e5dcdd0f19c6dbd58fdc377c9cd361cb12da3e309fbb4ec\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IStrategyV2 {\\n\\n  function NAME() external view returns (string memory);\\n\\n  function strategySpecificName() external view returns (string memory);\\n\\n  function PLATFORM() external view returns (string memory);\\n\\n  function STRATEGY_VERSION() external view returns (string memory);\\n\\n  function asset() external view returns (address);\\n\\n  function splitter() external view returns (address);\\n\\n  function compoundRatio() external view returns (uint);\\n\\n  function totalAssets() external view returns (uint);\\n\\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\\n  function isReadyToHardWork() external view returns (bool);\\n\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawAllToSplitter() external returns (uint strategyLoss);\\n\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawToSplitter(uint amount) external returns (uint strategyLoss);\\n\\n  /// @notice Stakes everything the strategy holds into the reward pool.\\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\\n  ///                                       It can be false if we know exactly, that the amount is already actual.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function investAll(\\n    uint amount_,\\n    bool updateTotalAssetsBeforeInvest_\\n  ) external returns (\\n    uint strategyLoss\\n  );\\n\\n  function doHardWork() external returns (uint earned, uint lost);\\n\\n  function setCompoundRatio(uint value) external;\\n\\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\\n  ///         0 means no deposit is allowed at this moment\\n  function capacity() external view returns (uint);\\n\\n  /// @notice {performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\\n  function performanceReceiver() external view returns (address);\\n\\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\\n  /// @dev use FEE_DENOMINATOR\\n  function performanceFee() external view returns (uint);\\n}\\n\",\"keccak256\":\"0xc7dac6097df7310b510f1027ef9c1bd3ccd6a202ca69582f68233ee798f7c312\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IStrategyV2.sol\\\";\\n\\ninterface IStrategyV3 is IStrategyV2 {\\n  struct BaseState {\\n    /// @dev Underlying asset\\n    address asset;\\n\\n    /// @dev Linked splitter\\n    address splitter;\\n\\n    /// @notice {performanceFee}% of total profit is sent to {performanceReceiver} before compounding\\n    /// @dev governance by default\\n    address performanceReceiver;\\n\\n    /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\\n    /// @dev {DEFAULT_PERFORMANCE_FEE} by default, FEE_DENOMINATOR is used\\n    uint performanceFee;\\n\\n    /// @notice Ratio to split performance fee on toPerf + toInsurance, [0..100_000]\\n    ///         100_000 - send full amount toPerf, 0 - send full amount toInsurance.\\n    uint performanceFeeRatio;\\n\\n    /// @dev Percent of profit for autocompound inside this strategy.\\n    uint compoundRatio;\\n\\n    /// @dev Represent specific name for this strategy. Should include short strategy name and used assets. Uniq across the vault.\\n    string strategySpecificName;\\n  }\\n}\\n\",\"keccak256\":\"0xe8a0179a82c40ba0c372486c5ebcc7df6431216c8c0d91cc408fb8f881e72f70\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface ITetuLiquidator {\\n\\n  struct PoolData {\\n    address pool;\\n    address swapper;\\n    address tokenIn;\\n    address tokenOut;\\n  }\\n\\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\\n\\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\\n\\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\\n\\n  function buildRoute(\\n    address tokenIn,\\n    address tokenOut\\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\\n\\n  function liquidate(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n  function liquidateWithRoute(\\n    PoolData[] memory route,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n\\n}\\n\",\"keccak256\":\"0xd5fe6f3ab750cc2d23f573597db5607c701e74c39e13c20c07a921a26c6d5012\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IVaultInsurance.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISplitter.sol\\\";\\n\\ninterface ITetuVaultV2 {\\n\\n  function splitter() external view returns (ISplitter);\\n\\n  function insurance() external view returns (IVaultInsurance);\\n\\n  function depositFee() external view returns (uint);\\n\\n  function withdrawFee() external view returns (uint);\\n\\n  function init(\\n    address controller_,\\n    IERC20 _asset,\\n    string memory _name,\\n    string memory _symbol,\\n    address _gauge,\\n    uint _buffer\\n  ) external;\\n\\n  function setSplitter(address _splitter) external;\\n\\n  function coverLoss(uint amount) external;\\n\\n  function initInsurance(IVaultInsurance _insurance) external;\\n\\n}\\n\",\"keccak256\":\"0x9e77a10b32a52f826d28d17c420f776fd289e5e4f925ec87f7177a1ce224a412\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IVaultInsurance {\\n\\n  function init(address _vault, address _asset) external;\\n\\n  function vault() external view returns (address);\\n\\n  function asset() external view returns (address);\\n\\n  function transferToVault(uint amount) external;\\n\\n}\\n\",\"keccak256\":\"0x6461572763b1f6decec1dee9d2ffe8ca152369bdc68255ec083cb3da3ce507a1\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        // only check isContract if the call was successful and the return data is empty\\n        // otherwise we already know that it was a contract\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n    // Look for revert reason and bubble it up if present\\n    if (returndata.length > 0) {\\n      // The easiest way to bubble the revert reason is using memory via assembly\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xcc7eeaafd4384e04ff39e0c01f0a6794736c34cad529751b8abd7b088ecc2e83\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n  enum Rounding {\\n    Down, // Toward negative infinity\\n    Up, // Toward infinity\\n    Zero // Toward zero\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b - 1) / b can overflow on addition, so we distribute.\\n    return a == 0 ? 0 : (a - 1) / b + 1;\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n  unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly {\\n      let mm := mulmod(x, y, not(0))\\n      prod0 := mul(x, y)\\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n      return prod0 / denominator;\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly {\\n    // Compute remainder using mulmod.\\n      remainder := mulmod(x, y, denominator)\\n\\n    // Subtract 256 bit number from 512 bit number.\\n      prod1 := sub(prod1, gt(remainder, prod0))\\n      prod0 := sub(prod0, remainder)\\n    }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n    // See https://cs.stackexchange.com/q/138556/92363.\\n\\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\\n    uint256 twos = denominator & (~denominator + 1);\\n    assembly {\\n    // Divide denominator by twos.\\n      denominator := div(denominator, twos)\\n\\n    // Divide [prod1 prod0] by twos.\\n      prod0 := div(prod0, twos)\\n\\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n      twos := add(div(sub(0, twos), twos), 1)\\n    }\\n\\n    // Shift in bits from prod1 into prod0.\\n    prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n    uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n    // in modular arithmetic, doubling the correct bits in each step.\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n    result = prod0 * inverse;\\n    return result;\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator,\\n    Rounding rounding\\n  ) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n  unchecked {\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    return min(result, a / result);\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = sqrt(a);\\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 128;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 64;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 32;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 16;\\n    }\\n    if (value >> 8 > 0) {\\n      value >>= 8;\\n      result += 8;\\n    }\\n    if (value >> 4 > 0) {\\n      value >>= 4;\\n      result += 4;\\n    }\\n    if (value >> 2 > 0) {\\n      value >>= 2;\\n      result += 2;\\n    }\\n    if (value >> 1 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log2(value);\\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >= 10**64) {\\n      value /= 10**64;\\n      result += 64;\\n    }\\n    if (value >= 10**32) {\\n      value /= 10**32;\\n      result += 32;\\n    }\\n    if (value >= 10**16) {\\n      value /= 10**16;\\n      result += 16;\\n    }\\n    if (value >= 10**8) {\\n      value /= 10**8;\\n      result += 8;\\n    }\\n    if (value >= 10**4) {\\n      value /= 10**4;\\n      result += 4;\\n    }\\n    if (value >= 10**2) {\\n      value /= 10**2;\\n      result += 2;\\n    }\\n    if (value >= 10**1) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log10(value);\\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 16;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 8;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 4;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 2;\\n    }\\n    if (value >> 8 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log256(value);\\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n  }\\n  }\\n}\\n\",\"keccak256\":\"0x2c5be0f4a60126b08e20f40586958ec1b76a27b69406c4b0db19e9dc6f771cfc\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n  unchecked {\\n    uint256 oldAllowance = token.allowance(address(this), spender);\\n    require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n    uint256 newAllowance = oldAllowance - value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n  }\\n\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x2378ee07b24e40c75781b27b2aa0812769c0000964e2d2501e3d234d3285dd18\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/SafeERC20.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\n\\nlibrary StrategyLib {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Denominator for fee calculation.\\n  uint internal constant FEE_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        EVENTS\\n  // *************************************************************\\n\\n  event CompoundRatioChanged(uint oldValue, uint newValue);\\n  event StrategySpecificNameChanged(string name);\\n  event EmergencyExit(address sender, uint amount);\\n  event ManualClaim(address sender);\\n  event InvestAll(uint balance);\\n  event WithdrawAllToSplitter(uint amount);\\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\\n\\n  // *************************************************************\\n  //                        ERRORS\\n  // *************************************************************\\n\\n  string internal constant DENIED = \\\"SB: Denied\\\";\\n  string internal constant TOO_HIGH = \\\"SB: Too high\\\";\\n  string internal constant WRONG_VALUE = \\\"SB: Wrong value\\\";\\n  /// @dev Denominator for compound ratio\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        CHECKS AND EMITS\\n  // *************************************************************\\n\\n  function _checkCompoundRatioChanged(address controller, uint oldValue, uint newValue) external {\\n    onlyPlatformVoter(controller);\\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\\n    emit CompoundRatioChanged(oldValue, newValue);\\n  }\\n\\n  function _checkStrategySpecificNameChanged(address controller, string calldata newName) external {\\n    onlyOperators(controller);\\n    emit StrategySpecificNameChanged(newName);\\n  }\\n\\n  function _checkManualClaim(address controller) external {\\n    onlyOperators(controller);\\n    emit ManualClaim(msg.sender);\\n  }\\n\\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\\n    onlySplitter(splitter);\\n    assetBalance = IERC20(asset).balanceOf(address(this));\\n    emit InvestAll(assetBalance);\\n  }\\n\\n  // *************************************************************\\n  //                     RESTRICTIONS\\n  // *************************************************************\\n\\n  /// @dev Restrict access only for operators\\n  function onlyOperators(address controller) public view {\\n    require(IController(controller).isOperator(msg.sender), DENIED);\\n  }\\n\\n  /// @dev Restrict access only for governance\\n  function onlyGovernance(address controller) public view {\\n    require(IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for platform voter\\n  function onlyPlatformVoter(address controller) public view {\\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for splitter\\n  function onlySplitter(address splitter) public view {\\n    require(splitter == msg.sender, DENIED);\\n  }\\n\\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_) external view {\\n    onlyGovernance(controller);\\n    require(fee_ <= 100_000, TOO_HIGH);\\n    require(receiver_ != address(0), WRONG_VALUE);\\n  }\\n\\n  // *************************************************************\\n  //                       HELPERS\\n  // *************************************************************\\n\\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\\n  ///         Revert if the amount is different from expected too much (high price impact)\\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\\n  /// @param assetPrice Price of the asset, decimals 18\\n  /// @return balance Current asset balance of the strategy\\n  function checkWithdrawImpact(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) public view returns (uint balance) {\\n    balance = IERC20(_asset).balanceOf(address(this));\\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\\n\\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\\n    }\\n  }\\n\\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\\n    onlyOperators(controller);\\n\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    IERC20(asset).safeTransfer(splitter, balance);\\n    emit EmergencyExit(msg.sender, balance);\\n  }\\n\\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\\n    onlySplitter(splitter);\\n    return IERC20(asset).balanceOf(address(this));\\n  }\\n\\n  function _withdrawAllToSplitterPostActions(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) external {\\n    uint balance = checkWithdrawImpact(\\n      _asset,\\n      balanceBefore,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n\\n    if (balance != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, balance);\\n    }\\n    emit WithdrawAllToSplitter(balance);\\n  }\\n\\n  function _withdrawToSplitterPostActions(\\n    uint amount,\\n    uint balance,\\n    address _asset,\\n    address _splitter\\n  ) external {\\n    uint amountAdjusted = Math.min(amount, balance);\\n    if (amountAdjusted != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\\n    }\\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\\n  }\\n}\\n\",\"keccak256\":\"0xa89e85b9acaeb5238c11c864167c152d0c33cf800fa3bb447e0629ed6fbff67c\",\"license\":\"BUSL-1.1\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib2.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/SafeERC20.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\nimport \\\"../interfaces/IStrategyV3.sol\\\";\\n\\nlibrary StrategyLib2 {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Denominator for fee calculation.\\n  uint internal constant FEE_DENOMINATOR = 100_000;\\n  /// @notice 10% of total profit is sent to {performanceReceiver} before compounding\\n  uint internal constant DEFAULT_PERFORMANCE_FEE = 10_000;\\n  address internal constant DEFAULT_PERF_FEE_RECEIVER = 0x9Cc199D4353b5FB3e6C8EEBC99f5139e0d8eA06b;\\n  /// @dev Denominator for compound ratio\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        ERRORS\\n  // *************************************************************\\n\\n  string internal constant DENIED = \\\"SB: Denied\\\";\\n  string internal constant TOO_HIGH = \\\"SB: Too high\\\";\\n  string internal constant WRONG_VALUE = \\\"SB: Wrong value\\\";\\n\\n  // *************************************************************\\n  //                        EVENTS\\n  // *************************************************************\\n\\n  event CompoundRatioChanged(uint oldValue, uint newValue);\\n  event StrategySpecificNameChanged(string name);\\n  event EmergencyExit(address sender, uint amount);\\n  event ManualClaim(address sender);\\n  event InvestAll(uint balance);\\n  event WithdrawAllToSplitter(uint amount);\\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\\n  event PerformanceFeeChanged(uint fee, address receiver, uint ratio);\\n\\n  // *************************************************************\\n  //                        CHECKS AND EMITS\\n  // *************************************************************\\n\\n  function _checkManualClaim(address controller) external {\\n    onlyOperators(controller);\\n    emit ManualClaim(msg.sender);\\n  }\\n\\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\\n    onlySplitter(splitter);\\n    assetBalance = IERC20(asset).balanceOf(address(this));\\n    emit InvestAll(assetBalance);\\n  }\\n\\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_, uint ratio_) internal {\\n    onlyGovernance(controller);\\n    require(fee_ <= FEE_DENOMINATOR, TOO_HIGH);\\n    require(receiver_ != address(0), WRONG_VALUE);\\n    require(ratio_ <= FEE_DENOMINATOR, TOO_HIGH);\\n    emit PerformanceFeeChanged(fee_, receiver_, ratio_);\\n  }\\n\\n  // *************************************************************\\n  //                        SETTERS\\n  // *************************************************************\\n\\n  function _changeCompoundRatio(IStrategyV3.BaseState storage baseState, address controller, uint newValue) external {\\n    onlyPlatformVoterOrGov(controller);\\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\\n\\n    uint oldValue = baseState.compoundRatio;\\n    baseState.compoundRatio = newValue;\\n\\n    emit CompoundRatioChanged(oldValue, newValue);\\n  }\\n\\n  function _changeStrategySpecificName(IStrategyV3.BaseState storage baseState, string calldata newName) external {\\n    baseState.strategySpecificName = newName;\\n    emit StrategySpecificNameChanged(newName);\\n  }\\n\\n  // *************************************************************\\n  //                     RESTRICTIONS\\n  // *************************************************************\\n\\n  /// @dev Restrict access only for operators\\n  function onlyOperators(address controller) public view {\\n    require(IController(controller).isOperator(msg.sender), DENIED);\\n  }\\n\\n  /// @dev Restrict access only for governance\\n  function onlyGovernance(address controller) public view {\\n    require(IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for platform voter\\n  function onlyPlatformVoterOrGov(address controller) public view {\\n    require(IController(controller).platformVoter() == msg.sender || IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for splitter\\n  function onlySplitter(address splitter) public view {\\n    require(splitter == msg.sender, DENIED);\\n  }\\n\\n  // *************************************************************\\n  //                       HELPERS\\n  // *************************************************************\\n\\n  function init(\\n    IStrategyV3.BaseState storage baseState,\\n    address controller_,\\n    address splitter_\\n  ) external {\\n    baseState.asset = ISplitter(splitter_).asset();\\n    baseState.splitter = splitter_;\\n    baseState.performanceReceiver = DEFAULT_PERF_FEE_RECEIVER;\\n    baseState.performanceFee = DEFAULT_PERFORMANCE_FEE;\\n\\n    require(IControllable(splitter_).isController(controller_), WRONG_VALUE);\\n  }\\n\\n  function setupPerformanceFee(IStrategyV3.BaseState storage baseState, uint fee_, address receiver_, uint ratio_, address controller_) external {\\n    _checkSetupPerformanceFee(controller_, fee_, receiver_, ratio_);\\n    baseState.performanceFee = fee_;\\n    baseState.performanceReceiver = receiver_;\\n    baseState.performanceFeeRatio = ratio_;\\n  }\\n\\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\\n  ///         Revert if the amount is different from expected too much (high price impact)\\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\\n  /// @param assetPrice Price of the asset, decimals 18\\n  /// @return balance Current asset balance of the strategy\\n  function checkWithdrawImpact(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) public view returns (uint balance) {\\n    balance = IERC20(_asset).balanceOf(address(this));\\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\\n\\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\\n    }\\n  }\\n\\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\\n    onlyOperators(controller);\\n\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    IERC20(asset).safeTransfer(splitter, balance);\\n    emit EmergencyExit(msg.sender, balance);\\n  }\\n\\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\\n    onlySplitter(splitter);\\n    return IERC20(asset).balanceOf(address(this));\\n  }\\n\\n  function _withdrawAllToSplitterPostActions(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) external {\\n    uint balance = checkWithdrawImpact(\\n      _asset,\\n      balanceBefore,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n\\n    if (balance != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, balance);\\n    }\\n    emit WithdrawAllToSplitter(balance);\\n  }\\n\\n  function _withdrawToSplitterPostActions(\\n    uint amount,\\n    uint balance,\\n    address _asset,\\n    address _splitter\\n  ) external {\\n    uint amountAdjusted = Math.min(amount, balance);\\n    if (amountAdjusted != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\\n    }\\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\\n  }\\n}\\n\",\"keccak256\":\"0x63704dba8a701606a0100190d2e46e4c7599571d0b21467b9cd8f87468a7947b\",\"license\":\"BUSL-1.1\"},\"@tetu_io/tetu-converter/contracts/interfaces/IBookkeeper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IBookkeeper {\\n  /// @notice Register a new loan\\n  /// @dev This function can be called by a pool adapter only\\n  /// @param collateralAmount Amount of supplied collateral for the new loan\\n  /// @param borrowedAmount Borrowed amount provided for the given {collateralAmount}\\n  function onBorrow(uint collateralAmount, uint borrowedAmount) external;\\n\\n  /// @notice Register loan payment\\n  /// @dev This function can be called by a pool adapter only\\n  /// @param withdrawnCollateral Amount of collateral received by the user during the repaying.\\n  /// @param paidAmount Amount paid by the user during the repaying.\\n  function onRepay(uint withdrawnCollateral, uint paidAmount) external;\\n\\n\\n  /// @notice Save checkpoint for all pool adapters of the given {user_}\\n  /// @return deltaGains Total amount of gains for the {tokens_} by all pool adapter\\n  /// @return deltaLosses Total amount of losses for the {tokens_} by all pool adapter\\n  function checkpoint(address[] memory tokens_) external returns (\\n    uint[] memory deltaGains,\\n    uint[] memory deltaLosses\\n  );\\n\\n  /// @notice Calculate deltas that user would receive if he creates a checkpoint at the moment\\n  /// @return deltaGains Total amount of gains for the {tokens_} by all pool adapter\\n  /// @return deltaLosses Total amount of losses for the {tokens_} by all pool adapter\\n  function previewCheckpoint(address user, address[] memory tokens_) external view returns (\\n    uint[] memory deltaGains,\\n    uint[] memory deltaLosses\\n  );\\n\\n  /// @notice Calculate total amount of gains and looses in underlying by all pool adapters of the signer\\n  ///         for the current period, start new period.\\n  /// @param underlying_ Asset in which we calculate gains and loss. Assume that it's either collateral or borrow asset.\\n  /// @return gains Total amount of gains (supply-profit) of the {user_} by all user's pool adapters\\n  /// @return losses Total amount of losses (paid increases to debt) of the {user_} by all user's pool adapters\\n  function startPeriod(address underlying_) external returns (\\n    uint gains,\\n    uint losses\\n  );\\n\\n  /// @notice Calculate total amount of gains and looses in underlying by all pool adapters of the {user_}\\n  ///         for the current period, DON'T start new period.\\n  /// @param underlying_ Asset in which we calculate gains and loss. Assume that it's either collateral or borrow asset.\\n  /// @return gains Total amount of gains (supply-profit) of the {user_} by all user's pool adapters\\n  /// @return losses Total amount of losses (paid increases to debt) of the {user_} by all user's pool adapters\\n  function previewPeriod(address underlying_, address user_) external view returns (uint gains, uint losses);\\n}\",\"keccak256\":\"0x98b7887d604ebcfaf28038c456c6c6893ce10f55b821f4c7c002dbc8055ea388\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/// @notice Keep and provide addresses of all application contracts\\ninterface IConverterController {\\n  function governance() external view returns (address);\\n\\n  // ********************* Health factor explanation  ****************\\n  // For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\\n  // For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\\n  // We set min-health-factor = 1.1, target-health-factor = 1.3\\n  // For collateral 100 we will borrow 100/1.3 = 76.92\\n  //\\n  // Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\\n  // Collateral * LT    85         65.45\\n  // Borrow value       65.38      65.38         but borrow value is the same as before\\n  // Health factor      1.3        1.001         liquidation almost happens here (!)\\n  //\\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\\n  // and the borrow value won't change at the same time, the liquidation happens at that point.\\n  // Min health factor marks the point at which a rebalancing must be made asap.\\n  // *****************************************************************\\n\\n  //#region ----------------------------------------------------- Configuration\\n\\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\\n  function minHealthFactor2() external view returns (uint16);\\n  function setMinHealthFactor2(uint16 value_) external;\\n\\n  /// @notice target health factor with decimals 2\\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\\n  ///      or additional borrow and restore the health factor to the given target value\\n  function targetHealthFactor2() external view returns (uint16);\\n  function setTargetHealthFactor2(uint16 value_) external;\\n\\n  /// @notice max allowed health factor with decimals 2\\n  /// @dev For future versions, currently max health factor is not used\\n  function maxHealthFactor2() external view returns (uint16);\\n  /// @dev For future versions, currently max health factor is not used\\n  function setMaxHealthFactor2(uint16 value_) external;\\n\\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\\n  function blocksPerDay() external view returns (uint);\\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\\n  /// @notice Check if it's time to call updateBlocksPerDay()\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\\n  /// @notice Recalculate blocksPerDay value\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function updateBlocksPerDay(uint periodInSeconds_) external;\\n\\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\\n  function paused() external view returns (bool);\\n\\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\\n  function isWhitelisted(address user_) external view returns (bool);\\n\\n  /// @notice The size of the gap by which the debt should be increased upon repayment\\n  ///         Such gaps are required by AAVE pool adapters to workaround dust tokens problem\\n  ///         and be able to make full repayment.\\n  /// @dev Debt gap is applied as following: toPay = debt * (DEBT_GAP_DENOMINATOR + debtGap) / DEBT_GAP_DENOMINATOR\\n  function debtGap() external view returns (uint);\\n\\n  /// @notice Allow to rebalance exist debts during burrow, see SCB-708\\n  ///         If the user already has a debt(s) for the given pair of collateral-borrow assets,\\n  ///         new borrow is made using exist pool adapter(s). Exist debt is rebalanced during the borrowing\\n  ///         in both directions, but the rebalancing is asymmetrically limited by thresholds\\n  ///         THRESHOLD_REBALANCE_XXX, see BorrowManager.\\n  function rebalanceOnBorrowEnabled() external view returns (bool);\\n\\n  //#endregion ----------------------------------------------------- Configuration\\n  //#region ----------------------------------------------------- Core application contracts\\n\\n  function tetuConverter() external view returns (address);\\n  function borrowManager() external view returns (address);\\n  function debtMonitor() external view returns (address);\\n  function tetuLiquidator() external view returns (address);\\n  function swapManager() external view returns (address);\\n  function priceOracle() external view returns (address);\\n  function bookkeeper() external view returns (address);\\n  //#endregion ----------------------------------------------------- Core application contracts\\n\\n  //#region ----------------------------------------------------- External contracts\\n  /// @notice A keeper to control health and efficiency of the borrows\\n  function keeper() external view returns (address);\\n  /// @notice Controller of tetu-contracts-v2, that is allowed to update proxy contracts\\n  function proxyUpdater() external view returns (address);\\n  //#endregion ----------------------------------------------------- External contracts\\n}\\n\",\"keccak256\":\"0xff68dab4badf9543c9a0ae5a1314106f0a5b804e8b6669fbea6e2655eb3c741f\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterControllerProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IConverterControllerProvider {\\n  function controller() external view returns (address);\\n}\\n\",\"keccak256\":\"0x71dce61809acb75f9078290e90033ffe816a51f18b7cb296d161e278c36eec86\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IPriceOracle {\\n  /// @notice Return asset price in USD, decimals 18\\n  function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb11e653eb4d6d7c41f29ee1e3e498253cfa8df1aec3ff31ab527009b79bdb705\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IConverterControllerProvider.sol\\\";\\n\\n/// @notice Main contract of the TetuConverter application\\n/// @dev Borrower (strategy) makes all operations via this contract only.\\ninterface ITetuConverter is IConverterControllerProvider {\\n\\n  /// @notice Find possible borrow strategies and provide \\\"cost of money\\\" as interest for the period for each strategy\\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converters Array of available converters ordered in ascending order of APR.\\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\\n  ///                    This address should be passed to borrow-function during conversion.\\n  ///                    The length of array is always equal to the count of available lending platforms.\\n  ///                    Last items in array can contain zero addresses (it means they are not used)\\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\\n  /// @return amountToBorrowsOut Amounts that should be borrowed\\n  ///                            This amount is not zero if corresponded converter is not zero.\\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\\n  function findBorrowStrategies(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external view returns (\\n    address[] memory converters,\\n    uint[] memory collateralAmountsOut,\\n    uint[] memory amountToBorrowsOut,\\n    int[] memory aprs18\\n  );\\n\\n  /// @notice Find best swap strategy and provide \\\"cost of money\\\" as interest for the period\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findSwapStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_\\n  ) external returns (\\n    address converter,\\n    uint sourceAmountOut,\\n    uint targetAmountOut,\\n    int apr18\\n  );\\n\\n  /// @notice Find best conversion strategy (swap or borrow) and provide \\\"cost of money\\\" as interest for the period.\\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findConversionStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external returns (\\n    address converter,\\n    uint collateralAmountOut,\\n    uint amountToBorrowOut,\\n    int apr18\\n  );\\n\\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\\n  ///         Target amount will be transferred to {receiver_}.\\n  ///         Exist debts can be rebalanced fully or partially if {rebalanceOnBorrowEnabled} is ON\\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\\n  ///      Only whitelisted users are allowed to make borrows\\n  /// @param converter_ A converter received from findBestConversionStrategy.\\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\\n  ///                          This amount must be approved to TetuConverter before the call.\\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\\n  /// @param receiver_ A receiver of borrowed amount\\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\\n  function borrow(\\n    address converter_,\\n    address collateralAsset_,\\n    uint collateralAmount_,\\n    address borrowAsset_,\\n    uint amountToBorrow_,\\n    address receiver_\\n  ) external returns (\\n    uint borrowedAmountOut\\n  );\\n\\n  /// @notice Full or partial repay of the borrow\\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        A user should transfer {amountToRepay_} to TetuConverter before calling repay().\\n  ///        You can know exact total amount of debt using {getStatusCurrent}.\\n  ///        if the amount exceed total amount of the debt:\\n  ///           - the debt will be fully repaid\\n  ///           - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\\n  ///        This amount should be calculated with taking into account possible debt gap,\\n  ///        You should call getDebtAmountCurrent(debtGap = true) to get this amount.\\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\\n  ///         If TetuConverter is not able to make the swap, it reverts\\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\\n  ///                                 This amount is returned back to the collateralReceiver_\\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\\n  function repay(\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_,\\n    address receiver_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint returnedBorrowAmountOut,\\n    uint swappedLeftoverCollateralOut,\\n    uint swappedLeftoverBorrowOut\\n  );\\n\\n  /// @notice Estimate result amount after making full or partial repay\\n  /// @dev It works in exactly same way as repay() but don't make actual repay\\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\\n  /// @param user_ user whose amount-to-repay will be calculated\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        This amount should be calculated without possible debt gap.\\n  ///        In this way it's differ from {repay}\\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\\n  /// @return swappedAmountOut A part of {collateralAmountOut} that were received by direct swap\\n  function quoteRepay(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint swappedAmountOut\\n  );\\n\\n  /// @notice Update status in all opened positions\\n  ///         After this call getDebtAmount will be able to return exact amount to repay\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountCurrent(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountStored(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external view returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\\n  /// @param user_ user whose debts will be returned\\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\\n  ///                                           even if all borrowed amount will be returned.\\n  ///                                           If this amount is not 0, you ask to get too much collateral.\\n  function estimateRepay(\\n    address user_,\\n    address collateralAsset_,\\n    uint collateralAmountRequired_,\\n    address borrowAsset_\\n  ) external view returns (\\n    uint borrowAssetAmount,\\n    uint unobtainableCollateralAssetAmount\\n  );\\n\\n  /// @notice Transfer all reward tokens to {receiver_}\\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\\n  function claimRewards(address receiver_) external returns (\\n    address[] memory rewardTokensOut,\\n    uint[] memory amountsOut\\n  );\\n\\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\\n  ///                      It should be transferred on balance of the TetuConverter before the function call\\n  /// @param receiver_ Result amount will be sent to this address\\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\\n  function safeLiquidate(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    address receiver_,\\n    uint priceImpactToleranceSource_,\\n    uint priceImpactToleranceTarget_\\n  ) external returns (\\n    uint amountOut\\n  );\\n\\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\\n  function isConversionValid(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    uint amountOut_,\\n    uint priceImpactTolerance_\\n  ) external view returns (bool);\\n\\n  /// @notice Close given borrow and return collateral back to the user, governance only\\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\\n  /// @param poolAdapter_ The pool adapter that represents the borrow\\n  /// @param closePosition Close position after repay\\n  ///        Usually it should be true, because the function always tries to repay all debt\\n  ///        false can be used if user doesn't have enough amount to pay full debt\\n  ///              and we are trying to pay \\\"as much as possible\\\"\\n  /// @return collateralAmountOut Amount of collateral returned to the user\\n  /// @return repaidAmountOut Amount of borrow asset paid to the lending platform\\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\\n    uint collateralAmountOut,\\n    uint repaidAmountOut\\n  );\\n\\n  /// @notice Get active borrows of the user with given collateral/borrowToken\\n  /// @dev Simple access to IDebtMonitor.getPositions\\n  /// @return poolAdaptersOut The instances of IPoolAdapter\\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external view returns (\\n    address[] memory poolAdaptersOut\\n  );\\n\\n  /// @notice Save token from TC-balance to {receiver}\\n  /// @dev Normally TetuConverter doesn't have any tokens on balance, they can appear there accidentally only\\n  function salvage(address receiver, address token, uint amount) external;\\n}\\n\",\"keccak256\":\"0x87ac3099e1254509929511509c207ecee9a665a3b43d7ee5b98e2ab0d639416d\",\"license\":\"MIT\"},\"contracts/interfaces/IConverterStrategyBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\n\\r\\n/// @notice Allow to share declaration of ConverterStrategyBaseState with libraries\\r\\ninterface IConverterStrategyBase {\\r\\n  struct ConverterStrategyBaseState {\\r\\n    /// @dev Amount of underlying assets invested to the pool.\\r\\n    uint investedAssets;\\r\\n\\r\\n    /// @dev Linked Tetu Converter\\r\\n    ITetuConverter converter;\\r\\n\\r\\n    /// @notice Percent of asset amount that can be not invested, it's allowed to just keep it on balance\\r\\n    ///         decimals = {DENOMINATOR}\\r\\n    /// @dev We need this threshold to avoid numerous conversions of small amounts\\r\\n    uint reinvestThresholdPercent;\\r\\n\\r\\n    /// @notice Current debt to the insurance.\\r\\n    ///         It's increased when insurance covers any losses related to swapping and borrow-debts-paying.\\r\\n    ///         It's not changed when insurance covers losses/receives profit that appeared after price changing.\\r\\n    ///         The strategy covers this debt on each hardwork using the profit (rewards, fees)\\r\\n    int debtToInsurance;\\r\\n\\r\\n    /// @notice reserve space for future needs\\r\\n    uint[50-1] __gap;\\r\\n  }\\r\\n}\",\"keccak256\":\"0x0be4f2ba25d955dfa6c9f821ecb466c3ae78f025ad2a85d83d11e22d850047ea\",\"license\":\"MIT\"},\"contracts/interfaces/IPoolProportionsProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IPoolProportionsProvider {\\r\\n  /// @notice Calculate proportions of [underlying, not-underlying] required by the internal pool of the strategy\\r\\n  /// @return Proportion of the not-underlying [0...1e18]\\r\\n  function getPropNotUnderlying18() external view returns (uint);\\r\\n}\\r\\n\",\"keccak256\":\"0x6722552632531ac63c23ddc5a3a104647a3e4a0d4c417ab9051c47ed49bc826c\",\"license\":\"MIT\"},\"contracts/libs/AppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @notice List of all errors generated by the application\\r\\n///         Each error should have unique code TS-XXX and descriptive comment\\r\\nlibrary AppErrors {\\r\\n  /// @notice Provided address should be not zero\\r\\n  string public constant ZERO_ADDRESS = \\\"TS-1 zero address\\\";\\r\\n\\r\\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\\r\\n  string public constant UNISWAP_PAIR_NOT_FOUND = \\\"TS-2 pair not found\\\";\\r\\n\\r\\n  /// @notice Lengths not matched\\r\\n  string public constant WRONG_LENGTHS = \\\"TS-4 wrong lengths\\\";\\r\\n\\r\\n  /// @notice Unexpected zero balance\\r\\n  string public constant ZERO_BALANCE = \\\"TS-5 zero balance\\\";\\r\\n\\r\\n  string public constant ITEM_NOT_FOUND = \\\"TS-6 not found\\\";\\r\\n\\r\\n  string public constant NOT_ENOUGH_BALANCE = \\\"TS-7 not enough balance\\\";\\r\\n\\r\\n  /// @notice Price oracle returns zero price\\r\\n  string public constant ZERO_PRICE = \\\"TS-8 zero price\\\";\\r\\n\\r\\n  string public constant WRONG_VALUE = \\\"TS-9 wrong value\\\";\\r\\n\\r\\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\\r\\n  string public constant ZERO_AMOUNT_BORROWED = \\\"TS-10 zero borrowed amount\\\";\\r\\n\\r\\n  string public constant WITHDRAW_TOO_MUCH = \\\"TS-11 try to withdraw too much\\\";\\r\\n\\r\\n  string public constant UNKNOWN_ENTRY_KIND = \\\"TS-12 unknown entry kind\\\";\\r\\n\\r\\n  string public constant ONLY_TETU_CONVERTER = \\\"TS-13 only TetuConverter\\\";\\r\\n\\r\\n  string public constant WRONG_ASSET = \\\"TS-14 wrong asset\\\";\\r\\n\\r\\n  string public constant NO_LIQUIDATION_ROUTE = \\\"TS-15 No liquidation route\\\";\\r\\n\\r\\n  string public constant PRICE_IMPACT = \\\"TS-16 price impact\\\";\\r\\n\\r\\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\\r\\n  string public constant REPAY_MAKES_SWAP = \\\"TS-17 can not convert back\\\";\\r\\n\\r\\n  string public constant NO_INVESTMENTS = \\\"TS-18 no investments\\\";\\r\\n\\r\\n  string public constant INCORRECT_LENGTHS = \\\"TS-19 lengths\\\";\\r\\n\\r\\n  /// @notice We expect increasing of the balance, but it was decreased\\r\\n  string public constant BALANCE_DECREASE = \\\"TS-20 balance decrease\\\";\\r\\n\\r\\n  /// @notice Prices changed and invested assets amount was increased on S, value of S is too high\\r\\n  string public constant EARNED_AMOUNT_TOO_HIGH = \\\"TS-21 earned too high\\\";\\r\\n\\r\\n  string public constant GOVERNANCE_ONLY = \\\"TS-22 governance only\\\";\\r\\n\\r\\n  string public constant ZERO_VALUE = \\\"TS-24 zero value\\\";\\r\\n\\r\\n  string public constant INCORRECT_SWAP_BY_AGG_PARAM = \\\"TS-25 swap by agg\\\";\\r\\n\\r\\n  string public constant OVER_COLLATERAL_DETECTED = \\\"TS-27 over-collateral\\\";\\r\\n\\r\\n  string public constant NOT_IMPLEMENTED = \\\"TS-28 not implemented\\\";\\r\\n\\r\\n  /// @notice You are not allowed to make direct debt if a NOT-DUST reverse debt exists and visa verse.\\r\\n  string public constant OPPOSITE_DEBT_EXISTS = \\\"TS-29 opposite debt exists\\\";\\r\\n\\r\\n  string public constant INVALID_VALUE = \\\"TS-30 invalid value\\\";\\r\\n\\r\\n  string public constant TOO_HIGH = \\\"TS-32 too high value\\\";\\r\\n\\r\\n  /// @notice BorrowLib has recursive call, sub-calls are not allowed\\r\\n  ///         This error can happen if allowed proportion is too small, i.e. 0.0004 : (1-0.0004)\\r\\n  ///         Such situation can happen if amount to swap is almost equal to the amount of the token in the current tick,\\r\\n  ///         so swap will move us close to the border between ticks.\\r\\n  ///         It was decided, that it's ok to have revert in that case\\r\\n  ///         We can change this behavior by changing BorrowLib.rebalanceRepayBorrow implementation:\\r\\n  ///             if amount-to-repay passed to _repayDebt is too small to be used,\\r\\n  ///             we should increase it min amount required to make repay successfully (amount must be > threshold)\\r\\n  ///         Previously it was error NOT_ALLOWED = \\\"TS23: not allowed\\\", see issues SCB-777, SCB-818\\r\\n  string public constant TOO_DEEP_RECURSION_BORROW_LIB = \\\"TS-33 too deep recursion\\\";\\r\\n}\\r\\n\",\"keccak256\":\"0x1400c631697434c991de2bfadcac7a0164a87be41a2cb683ed7f4fc75798d3e8\",\"license\":\"BUSL-1.1\"},\"contracts/libs/AppLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\\\";\\r\\n\\r\\n/// @notice Common internal utils\\r\\nlibrary AppLib {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  /// @notice 1% gap to cover possible liquidation inefficiency\\r\\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\\r\\n  uint internal constant GAP_CONVERSION = 1_000;\\r\\n  /// @dev Absolute value for any token\\r\\n  uint internal constant DEFAULT_LIQUIDATION_THRESHOLD = 100_000;\\r\\n  uint internal constant DENOMINATOR = 100_000;\\r\\n\\r\\n  /// @notice Any amount less than the following is dust\\r\\n  uint public constant DUST_AMOUNT_TOKENS = 100;\\r\\n\\r\\n  /// @notice Unchecked increment for for-cycles\\r\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\r\\n    unchecked {\\r\\n      return i + 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\r\\n  /// @dev Should NOT be used for third-party pools\\r\\n  function approveIfNeeded(address token, uint amount, address spender) internal {\\r\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\r\\n      IERC20(token).safeApprove(spender, 0);\\r\\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\\r\\n      IERC20(token).safeApprove(spender, 2 ** 255);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function balance(address token) internal view returns (uint) {\\r\\n    return IERC20(token).balanceOf(address(this));\\r\\n  }\\r\\n\\r\\n  /// @return prices Asset prices in USD, decimals 18\\r\\n  /// @return decs 10**decimals\\r\\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs\\r\\n  ) {\\r\\n    prices = new uint[](len);\\r\\n    decs = new uint[](len);\\r\\n    {\\r\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\\r\\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\\r\\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\\r\\n    uint len = tokens_.length;\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (tokens_[i] == asset_) {\\r\\n        return i;\\r\\n      }\\r\\n    }\\r\\n    return type(uint).max;\\r\\n  }\\r\\n\\r\\n  function _getLiquidator(address controller_) internal view returns (ITetuLiquidator) {\\r\\n    return ITetuLiquidator(IController(controller_).liquidator());\\r\\n  }\\r\\n\\r\\n  function _getPriceOracle(ITetuConverter converter_) internal view returns (IPriceOracle) {\\r\\n    return IPriceOracle(IConverterController(converter_.controller()).priceOracle());\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate liquidation threshold, use default value if the threshold is not set\\r\\n  ///         It's allowed to set any not-zero threshold, it this case default value is not used\\r\\n  /// @dev This function should be applied to the threshold at the moment of the reading its value from the storage.\\r\\n  ///      So, if we pass {mapping(address => uint) storage liquidationThresholds}, the threshold can be zero\\r\\n  ///      bug if we pass {uint liquidationThreshold} to a function, the threshold should be not zero\\r\\n  function _getLiquidationThreshold(uint threshold) internal pure returns (uint) {\\r\\n    return threshold == 0\\r\\n      ? AppLib.DEFAULT_LIQUIDATION_THRESHOLD\\r\\n      : threshold;\\r\\n  }\\r\\n\\r\\n  /// @notice Return a-b OR zero if a < b\\r\\n  function sub0(uint a, uint b) internal pure returns (uint) {\\r\\n    return a > b ? a - b : 0;\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x9ed14dbb815e8db52864ff1002f877e3b496c9dcb2ac1dccc220c510da203022\",\"license\":\"BUSL-1.1\"},\"contracts/libs/BorrowLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"../strategies/ConverterStrategyBaseLib.sol\\\";\\r\\n\\r\\n/// @notice Library to make new borrow, extend/reduce exist borrows and repay to keep proper assets proportions\\r\\n/// @dev Swap through liquidator is still allowed to be able to get required profitToCover, but this amount is small\\r\\nlibrary BorrowLib {\\r\\n  /// @notice prop0 + prop1\\r\\n  uint constant public SUM_PROPORTIONS = 1e18;\\r\\n\\r\\n  /// @notice Function {_rebalanceAssets} cannot be called recursively more than twice.\\r\\n  /// Normally one call is enough.\\r\\n  /// Firstly repay(requiredAmount0) is called below. There are two possible results:\\r\\n  /// 1) requiredCost0 <= cost0\\r\\n  /// 2) v.directDebt == 0\\r\\n  /// There is SCB-818: there are two debts (big and small), on the first cycle we get amount less than expected\\r\\n  /// because of debt gap. So, we need second cycle.\\r\\n  uint constant public MAX_DEEP_RECURSION = 2;\\r\\n\\r\\n  //region -------------------------------------------------- Data types\\r\\n  struct PricesDecs {\\r\\n    /// @notice Asset prices in USD, decimals 18\\r\\n    uint[] prices;\\r\\n    /// @notice decs 10**decimals\\r\\n    uint[] decs;\\r\\n  }\\r\\n\\r\\n  struct ConverterLiquidator {\\r\\n    ITetuConverter converter;\\r\\n    ITetuLiquidator liquidator;\\r\\n  }\\r\\n\\r\\n  struct RebalanceAssetsLocal {\\r\\n    // ------- constant values\\r\\n    address asset0;\\r\\n    address asset1;\\r\\n    /// @notice Proportion of {asset0}, > 0; proportion of {asset1} is SUM_PROPORTIONS - prop0\\r\\n    uint prop0;\\r\\n    /// @notice Min allowed amount of {asset0}-collateral, 0 - use default min value\\r\\n    uint threshold0;\\r\\n    /// @ntoice Min allowed amount of {asset1}-collateral, 0 - use default min value\\r\\n    uint threshold1;\\r\\n\\r\\n    PricesDecs pd;\\r\\n    // ------- refreshable values\\r\\n\\r\\n    // @notice Current balance of {asset0}\\r\\n    uint amount0;\\r\\n    // @notice Current balance of {asset1}\\r\\n    uint amount1;\\r\\n\\r\\n    /// @notice Borrowed amount of not-underlying\\r\\n    uint directDebt;\\r\\n    /// @notice Borrowed amount of underlying\\r\\n    uint reverseDebt;\\r\\n\\r\\n    uint addition0;\\r\\n  }\\r\\n\\r\\n  /// @notice Params required to borrow {assetB} under {assetA}\\r\\n  struct RebalanceAssetsCore {\\r\\n    ConverterLiquidator converterLiquidator;\\r\\n    address assetA;\\r\\n    address assetB;\\r\\n    uint propA;\\r\\n    uint propB;\\r\\n    /// @notice {assetA} to {assetB} ratio; {amountB} * {alpha} => {amountA}, decimals 18\\r\\n    uint alpha18;\\r\\n    /// @notice Min allowed amount of {assetA}-collateral, 0 - use default min value\\r\\n    uint thresholdA;\\r\\n\\r\\n    uint addonA;\\r\\n    uint addonB;\\r\\n\\r\\n    /// @notice Index of {assetA} in {prices} and {decs}\\r\\n    uint indexA;\\r\\n    /// @notice Index of {assetB} in {prices} and {decs}\\r\\n    uint indexB;\\r\\n  }\\r\\n\\r\\n  struct OpenPosition2Local {\\r\\n    uint collateral;\\r\\n    uint toBorrow;\\r\\n    uint cc;\\r\\n    uint cb;\\r\\n    uint c0;\\r\\n    uint cb2;\\r\\n    uint ca0;\\r\\n    uint gamma18;\\r\\n    uint pa2;\\r\\n    uint pb2;\\r\\n    bytes entryData;\\r\\n    uint alpha18;\\r\\n  }\\r\\n\\r\\n  struct MakeBorrowToDepositLocal {\\r\\n    uint[] prices;\\r\\n    uint[] decs;\\r\\n    uint cost0;\\r\\n    uint cost1;\\r\\n    uint prop1;\\r\\n    bytes entryData;\\r\\n  }\\r\\n  //endregion -------------------------------------------------- Data types\\r\\n\\r\\n  //region -------------------------------------------------- External functions\\r\\n  /// @notice Set balances of {asset0} and {asset1} in proportions {prop0}:{prop1} using borrow/repay (no swaps)\\r\\n  /// @param prop0 Proportion of {asset0}, > 0. Proportion of {asset1} is calculates as 1e18 - prop0\\r\\n  /// @param threshold0 Min allowed amount of {asset0}-collateral, 0 - use default min value\\r\\n  /// @param threshold1 Min allowed amount of {asset1}-collateral, 0 - use default min value\\r\\n  /// @param addition0 Additional amount A0 of {asset0}.\\r\\n  ///                  Balance0 = A0 + B0\\r\\n  ///                  We need following balances in results: B0 : Balance1 === {proportion}:{100_000-proportion}\\r\\n  function rebalanceAssets(\\r\\n    ITetuConverter converter_,\\r\\n    ITetuLiquidator liquidator_,\\r\\n    address asset0,\\r\\n    address asset1,\\r\\n    uint prop0,\\r\\n    uint threshold0,\\r\\n    uint threshold1,\\r\\n    uint addition0\\r\\n  ) external {\\r\\n    // pool always have TWO assets, it's not allowed ot have only one asset\\r\\n    // so, we assume that the proportions are in the range (0...1e18)\\r\\n    require(prop0 != 0, AppErrors.ZERO_VALUE);\\r\\n    require(prop0 < SUM_PROPORTIONS, AppErrors.TOO_HIGH);\\r\\n\\r\\n    RebalanceAssetsLocal memory v;\\r\\n    v.asset0 = asset0;\\r\\n    v.asset1 = asset1;\\r\\n    v.prop0 = prop0;\\r\\n    v.threshold0 = threshold0;\\r\\n    v.threshold1 = threshold1;\\r\\n    v.addition0 = addition0;\\r\\n\\r\\n    IPriceOracle priceOracle = AppLib._getPriceOracle(converter_);\\r\\n    address[] memory tokens = new address[](2);\\r\\n    tokens[0] = asset0;\\r\\n    tokens[1] = asset1;\\r\\n    (v.pd.prices, v.pd.decs) = AppLib._getPricesAndDecs(priceOracle, tokens, 2);\\r\\n\\r\\n    _refreshRebalance(v, ConverterLiquidator(converter_, liquidator_), MAX_DEEP_RECURSION);\\r\\n  }\\r\\n\\r\\n  /// @notice Convert {amount_} of underlying to two amounts: A0 (underlying) and A1 (not-underlying)\\r\\n  ///         Result proportions of A0 and A1 should match to {prop0} : 1e18-{prop0}\\r\\n  ///         The function is able to make new borrowing and/or close exist debts.\\r\\n  /// @param amount_ Amount of underlying that is going to be deposited\\r\\n  ///                We assume here, that current balance >= the {amount_}\\r\\n  /// @param tokens_ [Underlying, not underlying]\\r\\n  /// @param thresholds_ Thresholds for the given {tokens_}. Debts with amount-to-repay < threshold are ignored.\\r\\n  /// @param prop0 Required proportion of underlying, > 0. Proportion of not-underlying is calculates as 1e18 - {prop0}\\r\\n  /// @return tokenAmounts Result amounts [A0 (underlying), A1 (not-underlying)]\\r\\n  function prepareToDeposit(\\r\\n    ITetuConverter converter_,\\r\\n    uint amount_,\\r\\n    address[2] memory tokens_,\\r\\n    uint[2] memory thresholds_,\\r\\n    uint prop0\\r\\n  ) external returns (\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    uint[2] memory amountsToDeposit;\\r\\n    uint[2] memory balances = [\\r\\n      AppLib.sub0(AppLib.balance(tokens_[0]), amount_), // We assume here, that current balance >= the {amount_}\\r\\n      AppLib.balance(tokens_[1])\\r\\n    ];\\r\\n\\r\\n    // we assume here, that either direct OR reverse debts (amount > threshold) are possible but not both at the same time\\r\\n    (uint debtReverse, ) = converter_.getDebtAmountCurrent(address(this), tokens_[1], tokens_[0], true);\\r\\n    if (debtReverse > thresholds_[0]) {\\r\\n      // case 1: reverse debt exists\\r\\n      // case 1.1: amount to deposit exceeds exist debt.\\r\\n      //    Close the debt completely and than make either new direct OR reverse debt\\r\\n      // case 1.2: amount to deposit is less than the exist debt.\\r\\n      //    Close the debt partially and make new reverse debt\\r\\n      uint amountToRepay = amount_ > debtReverse ? debtReverse : amount_;\\r\\n      ConverterStrategyBaseLib.closePosition(converter_, tokens_[1], tokens_[0], amountToRepay);\\r\\n      amountsToDeposit = [\\r\\n        AppLib.sub0(AppLib.balance(tokens_[0]), balances[0]),\\r\\n        AppLib.sub0(AppLib.balance(tokens_[1]), balances[1])\\r\\n      ];\\r\\n    } else {\\r\\n      // case 2: no debts OR direct debt exists\\r\\n      amountsToDeposit = [amount_, 0];\\r\\n    }\\r\\n\\r\\n    _makeBorrowToDeposit(converter_, amountsToDeposit, tokens_, thresholds_, prop0);\\r\\n\\r\\n    tokenAmounts = new uint[](2);\\r\\n    tokenAmounts[0] = AppLib.sub0(AppLib.balance(tokens_[0]), balances[0]);\\r\\n    tokenAmounts[1] = AppLib.sub0(AppLib.balance(tokens_[1]), balances[1]);\\r\\n  }\\r\\n  //endregion -------------------------------------------------- External functions\\r\\n\\r\\n  //region -------------------------------------------------- Implementation of prepareToDeposit\\r\\n  /// @notice Make a direct or reverse borrow to make amounts_ fit to the given proportions.\\r\\n  /// If one of available amounts is zero, we just need to make a borrow using second amount as amountIn.\\r\\n  /// Otherwise, we need to calculate amountIn at first.\\r\\n  /// @dev The purpose is to get the amounts in proper proportions: A:B = prop0:prop1.\\r\\n  /// Suppose, amounts_[1] is not enough:\\r\\n  ///   [A1, B1] => [A2 + A3, B1], A2:B1 = prop0:prop1, A3 is amountIn for new borrow.\\r\\n  /// Suppose, amounts_[0] is not enough:\\r\\n  ///   [A1, B1] => [A1, B2 + B3], A1:B2 = prop0:prop1, B3 is amountIn for new borrow.\\r\\n  /// @param amounts_ Available amounts\\r\\n  /// @param tokens_ [Underlying, not underlying]\\r\\n  /// @param thresholds_ Thresholds for the given {tokens_}. Debts with amount-to-repay < threshold are ignored.\\r\\n  /// @param prop0 Required proportion of underlying, > 0. Proportion of not-underlying is calculates as 1e18 - {prop0}\\r\\n  function _makeBorrowToDeposit(\\r\\n    ITetuConverter converter_,\\r\\n    uint[2] memory amounts_,\\r\\n    address[2] memory tokens_,\\r\\n    uint[2] memory thresholds_,\\r\\n    uint prop0\\r\\n  ) internal {\\r\\n    MakeBorrowToDepositLocal memory v;\\r\\n\\r\\n    {\\r\\n      IPriceOracle priceOracle = AppLib._getPriceOracle(converter_);\\r\\n      address[] memory tokens = new address[](2);\\r\\n      tokens[0] = tokens_[0];\\r\\n      tokens[1] = tokens_[1];\\r\\n      (v.prices, v.decs) = AppLib._getPricesAndDecs(priceOracle, tokens, 2);\\r\\n    }\\r\\n\\r\\n    v.cost0 = amounts_[0] * v.prices[0] / v.decs[0];\\r\\n    v.cost1 = amounts_[1] * v.prices[1] / v.decs[1];\\r\\n    // we need: cost0/cost1 = prop0/prop1, and so cost0 * prop1 = cost1 * prop0\\r\\n    v.prop1 = SUM_PROPORTIONS - prop0;\\r\\n\\r\\n    if (v.cost0 * v.prop1 > v.cost1 * prop0) {\\r\\n      // we need to make direct borrow\\r\\n      uint cost0for1 = v.cost1 * prop0 / v.prop1; // a part of cost0 that is matched to cost1\\r\\n      uint amountIn = (v.cost0 - cost0for1) * v.decs[0] / v.prices[0];\\r\\n\\r\\n      AppLib.approveIfNeeded(tokens_[0], amountIn, address(converter_));\\r\\n      v.entryData = abi.encode(1, prop0, v.prop1); // ENTRY_KIND_EXACT_PROPORTION_1\\r\\n      ConverterStrategyBaseLib.openPosition(converter_, v.entryData, tokens_[0], tokens_[1], amountIn, thresholds_[0]);\\r\\n    } else if (v.cost0 * v.prop1 < v.cost1 * prop0) {\\r\\n      // we need to make reverse borrow\\r\\n      uint cost1for0 = v.cost0 * v.prop1 / prop0; // a part of cost1 that is matched to cost0\\r\\n      uint amountIn = (v.cost1 - cost1for0) * v.decs[1] / v.prices[1];\\r\\n\\r\\n      AppLib.approveIfNeeded(tokens_[1], amountIn, address(converter_));\\r\\n      v.entryData = abi.encode(1, v.prop1, prop0); // ENTRY_KIND_EXACT_PROPORTION_1\\r\\n      ConverterStrategyBaseLib.openPosition(converter_, v.entryData, tokens_[1], tokens_[0], amountIn, thresholds_[1]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  //endregion -------------------------------------------------- Implementation of prepareToDeposit\\r\\n\\r\\n  //region -------------------------------------------------- Internal helper functions\\r\\n\\r\\n  /// @notice refresh state in {v} and call _rebalanceAssets()\\r\\n  function _refreshRebalance(\\r\\n    RebalanceAssetsLocal memory v,\\r\\n    ConverterLiquidator memory converterLiquidator,\\r\\n    uint repayAllowed\\r\\n  ) internal {\\r\\n    v.amount0 = IERC20(v.asset0).balanceOf(address(this));\\r\\n    v.amount1 = IERC20(v.asset1).balanceOf(address(this));\\r\\n\\r\\n    (v.directDebt, ) = converterLiquidator.converter.getDebtAmountCurrent(address(this), v.asset0, v.asset1, true);\\r\\n    (v.reverseDebt, ) = converterLiquidator.converter.getDebtAmountCurrent(address(this), v.asset1, v.asset0, true);\\r\\n\\r\\n    _rebalanceAssets(v, converterLiquidator, repayAllowed);\\r\\n  }\\r\\n\\r\\n  /// @param repayAllowed Protection against recursion\\r\\n  ///                     Assets can be rebalanced in two ways:\\r\\n  ///                     1) openPosition\\r\\n  ///                     2) repay + openPosition\\r\\n  ///                     Only one repay is allowed.\\r\\n  function _rebalanceAssets(\\r\\n    RebalanceAssetsLocal memory v,\\r\\n    ConverterLiquidator memory converterLiquidator,\\r\\n    uint repayAllowed\\r\\n  ) internal {\\r\\n    uint cost0 = v.amount0 * v.pd.prices[0] / v.pd.decs[0];\\r\\n    uint cost1 = v.amount1 * v.pd.prices[1] / v.pd.decs[1];\\r\\n    uint costAddition0 = v.addition0 * v.pd.prices[0] / v.pd.decs[0];\\r\\n\\r\\n    if (cost0 + cost1 > costAddition0) {\\r\\n      uint totalCost = cost0 + cost1 - costAddition0;\\r\\n\\r\\n      uint requiredCost0 = totalCost * v.prop0 / SUM_PROPORTIONS + costAddition0;\\r\\n      uint requiredCost1 = totalCost * (SUM_PROPORTIONS - v.prop0) / SUM_PROPORTIONS;\\r\\n\\r\\n      if (requiredCost0 > cost0) {\\r\\n        // we need to increase amount of asset 0 and decrease amount of asset 1, so we need to borrow asset 0 (reverse)\\r\\n        RebalanceAssetsCore memory c10 = RebalanceAssetsCore({\\r\\n          converterLiquidator: converterLiquidator,\\r\\n          assetA: v.asset1,\\r\\n          assetB: v.asset0,\\r\\n          propA: SUM_PROPORTIONS - v.prop0,\\r\\n          propB: v.prop0,\\r\\n          alpha18: 1e18 * v.pd.prices[0] * v.pd.decs[1] / v.pd.prices[1] / v.pd.decs[0],\\r\\n          thresholdA: v.threshold1,\\r\\n          addonA: 0,\\r\\n          addonB: v.addition0,\\r\\n          indexA: 1,\\r\\n          indexB: 0\\r\\n        });\\r\\n\\r\\n        if (v.directDebt >= AppLib.DUST_AMOUNT_TOKENS) {\\r\\n          require(repayAllowed != 0, AppErrors.TOO_DEEP_RECURSION_BORROW_LIB);\\r\\n\\r\\n          // repay of v.asset1 is required\\r\\n          uint requiredAmount0 = (requiredCost0 - cost0) * v.pd.decs[0] / v.pd.prices[0];\\r\\n          rebalanceRepayBorrow(v, c10, requiredAmount0, v.directDebt, repayAllowed);\\r\\n        } else {\\r\\n          // new (or additional) borrow of asset 0 under asset 1 is required\\r\\n          openPosition(c10, v.pd, v.amount1, v.amount0);\\r\\n        }\\r\\n      } else if (requiredCost0 < cost0) {\\r\\n        RebalanceAssetsCore memory c01 = RebalanceAssetsCore({\\r\\n          converterLiquidator: converterLiquidator,\\r\\n          assetA: v.asset0,\\r\\n          assetB: v.asset1,\\r\\n          propA: v.prop0,\\r\\n          propB: SUM_PROPORTIONS - v.prop0,\\r\\n          alpha18: 1e18 * v.pd.prices[1] * v.pd.decs[0] / v.pd.prices[0] / v.pd.decs[1],\\r\\n          thresholdA: v.threshold0,\\r\\n          addonA: v.addition0,\\r\\n          addonB: 0,\\r\\n          indexA: 0,\\r\\n          indexB: 1\\r\\n        });\\r\\n        // we need to decrease amount of asset 0 and increase amount of asset 1, so we need to borrow asset 1 (direct)\\r\\n        if (v.reverseDebt >= AppLib.DUST_AMOUNT_TOKENS) {\\r\\n          require(repayAllowed != 0, AppErrors.TOO_DEEP_RECURSION_BORROW_LIB);\\r\\n\\r\\n          // repay of v.asset0 is required\\r\\n          // requiredCost0 < cost0 => requiredCost1 > cost1\\r\\n          uint requiredAmount1 = (requiredCost1 - cost1) * v.pd.decs[1] / v.pd.prices[1];\\r\\n          rebalanceRepayBorrow(v, c01, requiredAmount1, v.reverseDebt, repayAllowed);\\r\\n        } else {\\r\\n          // new or additional borrow of asset 1 under asset 0 is required\\r\\n          openPosition(c01, v.pd, v.amount0, v.amount1);\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      // if costAddition0 exceeds cost0 + cost1, all amounts should be converted to asset 0\\r\\n      // for simplicity, we don't make any swaps or borrows (amount addition0 is assumed to be small)\\r\\n      // and just leave balances as is\\r\\n      // as result, profit-to-cover will be reduced from costAddition0 to v.amount0\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Repay {amountDebtA} fully or partially to get at least {requiredAmountB} of collateral\\r\\n  ///         then try to rebalance once more\\r\\n  /// @param requiredAmountB Amount of collateral that we need to receive after repay\\r\\n  /// @param amountDebtA Total amount that is required to pay to close the debt\\r\\n  function rebalanceRepayBorrow(\\r\\n    RebalanceAssetsLocal memory v,\\r\\n    RebalanceAssetsCore memory c,\\r\\n    uint requiredAmountB,\\r\\n    uint amountDebtA,\\r\\n    uint repayAllowed\\r\\n  ) internal {\\r\\n    // repayAllowed cannot be zero here because of requires in _rebalanceAssets, but it's safer to check it once more\\r\\n    require(repayAllowed != 0, AppErrors.TOO_DEEP_RECURSION_BORROW_LIB);\\r\\n\\r\\n    // we need to get {requiredAmountB}\\r\\n    // we don't know exact amount to repay\\r\\n    // but we are sure that amount {requiredAmountB ===> requiredAmountA} would be more than required\\r\\n    uint capRequiredAmountA = requiredAmountB * c.alpha18 / 1e18;\\r\\n    uint amountToRepay = Math.min(capRequiredAmountA, amountDebtA);\\r\\n    if (amountToRepay >= AppLib.DUST_AMOUNT_TOKENS) {\\r\\n      ConverterStrategyBaseLib._repayDebt(c.converterLiquidator.converter, c.assetB, c.assetA, amountToRepay);\\r\\n      _refreshRebalance(v, c.converterLiquidator, repayAllowed - 1);\\r\\n    } // else the assets are already in proper proportions\\r\\n  }\\r\\n\\r\\n  //endregion -------------------------------------------------- Internal helper functions\\r\\n\\r\\n  //region -------------------------------------------------- Open position\\r\\n  /// @notice borrow asset B under asset A. Result balances should be A0 + A1, B0 + B1\\r\\n  ///         Where (A1 : B1) == (propA : propB), A0 and B0 are equal to {c.addonA} and {c.addonB}\\r\\n  /// @param balanceA_ Current balance of the collateral\\r\\n  /// @param balanceB_ Current balance of the borrow asset\\r\\n  function openPosition(\\r\\n    RebalanceAssetsCore memory c,\\r\\n    PricesDecs memory pd,\\r\\n    uint balanceA_,\\r\\n    uint balanceB_\\r\\n  ) internal returns (\\r\\n    uint collateralAmountOut,\\r\\n    uint borrowedAmountOut\\r\\n  ) {\\r\\n    // if there are two not-zero addons, the caller should reduce balances before the call\\r\\n    require(c.addonA == 0 || c.addonB == 0, AppErrors.INVALID_VALUE);\\r\\n\\r\\n    // we are going to borrow B under A\\r\\n    if (c.addonB != 0) {\\r\\n      // B is underlying, so we are going to borrow underlying\\r\\n      if (balanceB_ >= c.addonB) {\\r\\n        // simple case - we already have required addon on the balance. Just keep it unused\\r\\n        return _openPosition(c, balanceA_, balanceB_ - c.addonB);\\r\\n      } else {\\r\\n        // we need to get 1) (c.addonB + balanceB_) amount, so we will have required c.addonB\\r\\n        //                2) leftovers of A and B should be allocated in required proportions\\r\\n        // it's too hard to calculate correctly required to borrow amount in this case without changing TetuConverter\\r\\n        // but we can assume here, that amount (c.addonB - balanceB_) is pretty small (it's profitToCover)\\r\\n        // so, we can swap this required amount through liquidator at first\\r\\n        // then use _openPosition to re-allocated rest amounts to proper proportions\\r\\n        (uint decA,) = _makeLittleSwap(c, pd, balanceA_, c.addonB - balanceB_);\\r\\n        return _openPosition(c, balanceA_ - decA, balanceB_);\\r\\n      }\\r\\n    } else if (c.addonA != 0) {\\r\\n      // A is underlying, we need to put aside c.addonA and allocate leftovers in right proportions.\\r\\n      // we are going to borrow B under asset A, so the case (balanceA_ < c.addonA) is not valid here\\r\\n      require(balanceA_ >= c.addonA, AppErrors.NOT_ENOUGH_BALANCE);\\r\\n      return _openPosition(c, balanceA_ - c.addonA, balanceB_);\\r\\n    } else {\\r\\n      // simple logic, no addons\\r\\n      return _openPosition(c, balanceA_, balanceB_);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice borrow asset B under asset A, result balances should have proportions: (propA : propB)\\r\\n  function _openPosition(RebalanceAssetsCore memory c, uint balanceA_, uint balanceB_) internal returns (\\r\\n    uint collateralAmountOut,\\r\\n    uint borrowedAmountOut\\r\\n  ) {\\r\\n    uint untouchedAmountA;\\r\\n    bytes memory entryData = abi.encode(1, c.propA, c.propB);\\r\\n\\r\\n    if (balanceB_ != 0) {\\r\\n      // we are going to use {balanceA_} as collateral\\r\\n      // but there is some amount on {balanceB_}, so we need to keep corresponded part of {balanceA_} untouched\\r\\n      untouchedAmountA = balanceB_ * c.alpha18 * c.propA / c.propB / 1e18;\\r\\n\\r\\n      // we are going to borrow B under A, so balance A must be greater then balance B\\r\\n      // otherwise the function is called incorrectly - probably we need to borrow A under B\\r\\n      require(untouchedAmountA <= balanceA_, AppErrors.WRONG_VALUE);\\r\\n    }\\r\\n\\r\\n    AppLib.approveIfNeeded(c.assetA, balanceA_ - untouchedAmountA, address(c.converterLiquidator.converter));\\r\\n\\r\\n    return ConverterStrategyBaseLib.openPosition(\\r\\n      c.converterLiquidator.converter,\\r\\n      entryData,\\r\\n      c.assetA,\\r\\n      c.assetB,\\r\\n      balanceA_ - untouchedAmountA,\\r\\n      c.thresholdA\\r\\n    );\\r\\n  }\\r\\n\\r\\n  //endregion -------------------------------------------------- Open position\\r\\n\\r\\n  //region -------------------------------------------------- Little swap\\r\\n  /// @notice Swap min amount of A to get {requiredAmountB}\\r\\n  /// @return spentAmountIn how much the balance A has decreased\\r\\n  /// @return receivedAmountOut how much the balance B has increased\\r\\n  function _makeLittleSwap(\\r\\n    RebalanceAssetsCore memory c,\\r\\n    PricesDecs memory pd,\\r\\n    uint balanceA_,\\r\\n    uint requiredAmountB\\r\\n  ) internal returns (\\r\\n    uint spentAmountIn,\\r\\n    uint receivedAmountOut\\r\\n  ) {\\r\\n    uint amountInA = requiredAmountB * pd.prices[c.indexB] * pd.decs[c.indexA] / pd.prices[c.indexA] / pd.decs[c.indexB];\\r\\n    // we can have some loss because of slippage\\r\\n    // so, let's increase input amount a bit\\r\\n    amountInA = amountInA * (100_000 + ConverterStrategyBaseLib._ASSET_LIQUIDATION_SLIPPAGE) / 100_000;\\r\\n\\r\\n    // in practice the addition is required to pay ProfitToCover\\r\\n    // we assume, that total addition amount is small enough, much smaller then the total balance\\r\\n    // otherwise something is wrong: we are going to pay ProfitToCover, but we don't have enough amount on the balances.\\r\\n    require(balanceA_ > amountInA, AppErrors.NOT_ENOUGH_BALANCE);\\r\\n\\r\\n    (spentAmountIn, receivedAmountOut) = ConverterStrategyBaseLib.liquidate(\\r\\n      c.converterLiquidator.converter,\\r\\n      c.converterLiquidator.liquidator,\\r\\n      c.assetA,\\r\\n      c.assetB,\\r\\n      amountInA,\\r\\n      ConverterStrategyBaseLib._ASSET_LIQUIDATION_SLIPPAGE,\\r\\n      c.thresholdA,\\r\\n      false\\r\\n    );\\r\\n  }\\r\\n\\r\\n  //endregion -------------------------------------------------- Little swap\\r\\n\\r\\n}\\r\\n\",\"keccak256\":\"0x5a94be3da8739c31b91b0e4c6ca7860e96d052ef2d1975b63983e33eed33a8a8\",\"license\":\"BUSL-1.1\"},\"contracts/libs/ConverterEntryKinds.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\\r\\nlibrary ConverterEntryKinds {\\r\\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\\r\\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\\r\\n\\r\\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\\r\\n  ///         C2 should be used as collateral to make a borrow B.\\r\\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\\r\\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\\r\\n\\r\\n  /// @notice Borrow given amount using min possible collateral\\r\\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\\r\\n\\r\\n  /// @notice Decode entryData, extract first uint - entry kind\\r\\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\\r\\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\\r\\n    if (entryData_.length == 0) {\\r\\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\\r\\n    }\\r\\n    return abi.decode(entryData_, (uint));\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x4f4332c8be1be5fd85fef7c06795fc19957b35a4f2e3735fdd89c0906ddc923b\",\"license\":\"BUSL-1.1\"},\"contracts/libs/IterationPlanLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"./AppErrors.sol\\\";\\r\\nimport \\\"./AppLib.sol\\\";\\r\\n\\r\\n/// @notice Support of withdraw iteration plans\\r\\nlibrary IterationPlanLib {\\r\\n\\r\\n//region ------------------------------------------------ Constants\\r\\n  /// @notice Swap collateral asset to get required amount-to-repay, then repay and get more collateral back.\\r\\n  ///         It tries to minimizes count of repay-operations.\\r\\n  ///         If there are no debts, swap leftovers to get required proportions of the asset.\\r\\n  ///         This mode is intended i.e. for \\\"withdraw all\\\"\\r\\n  ///         (uint256, uint256) - (entry kind, propNotUnderlying18)\\r\\n  /// propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n  ///                     The assets should be swapped to get following result proportions:\\r\\n  ///                     not-underlying : underlying === propNotUnderlying18 : (1e18 - propNotUnderlying18)\\r\\n  ///                     Pass type(uint).max to read proportions from the pool.\\r\\n  uint constant public PLAN_SWAP_REPAY = 0;\\r\\n\\r\\n  /// @notice Repay available amount-to-repay, swap all or part of collateral to borrowed-asset, make one repay if needed.\\r\\n  ///         Swap + second repay tries to make asset balances to proportions required by the pool.\\r\\n  ///         Proportions are read from pool through IPoolProportionsProvider(this) and re-read after swapping.\\r\\n  ///         This mode is intended i.e. for rebalancing debts using single iteration.\\r\\n  ///         (uint256, uint256, uint256) - (entry kind, propNotUnderlying18, required-amount-to-reduce-the-debt)\\r\\n  /// propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n  ///                     The assets should be swapped to get following result proportions:\\r\\n  ///                     not-underlying : underlying === propNotUnderlying18 : (1e18 - propNotUnderlying18)\\r\\n  ///                     Pass type(uint).max to read proportions from the pool.\\r\\n  uint constant public PLAN_REPAY_SWAP_REPAY = 1;\\r\\n\\r\\n  /// @notice Swap leftovers to required proportions, don't repay any debts\\r\\n  ///         (uint256, uint256) - (entry kind, propNotUnderlying18)\\r\\n  /// propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n  ///                     The assets should be swapped to get following result proportions:\\r\\n  ///                     not-underlying : underlying === propNotUnderlying18 : (1e18 - propNotUnderlying18)\\r\\n  ///                     Pass type(uint).max to read proportions from the pool.\\r\\n  uint constant public PLAN_SWAP_ONLY = 2;\\r\\n//endregion ------------------------------------------------ Constants\\r\\n\\r\\n//region ------------------------------------------------ Data types\\r\\n  /// @notice Set of parameters required to liquidation through aggregators\\r\\n  struct SwapRepayPlanParams {\\r\\n    ITetuConverter converter;\\r\\n    ITetuLiquidator liquidator;\\r\\n\\r\\n    /// @notice Assets used by depositor stored as following way: [underlying, not-underlying]\\r\\n    address[] tokens;\\r\\n\\r\\n    /// @notice Liquidation thresholds for the {tokens}\\r\\n    uint[] liquidationThresholds;\\r\\n\\r\\n    /// @notice Cost of $1 in terms of the assets, decimals 18\\r\\n    uint[] prices;\\r\\n    /// @notice 10**decimal for the assets\\r\\n    uint[] decs;\\r\\n\\r\\n    /// @notice Amounts that will be received on balance before execution of the plan.\\r\\n    uint[] balanceAdditions;\\r\\n\\r\\n    /// @notice Plan kind extracted from entry data, see {IterationPlanKinds}\\r\\n    uint planKind;\\r\\n\\r\\n    /// @notice Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n    ///         The leftovers should be swapped to get following result proportions of the assets:\\r\\n    ///         not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\r\\n    uint propNotUnderlying18;\\r\\n\\r\\n    /// @notice proportions should be taken from the pool and re-read from the pool after each swap\\r\\n    bool usePoolProportions;\\r\\n\\r\\n    /// @notice \\\"required-amount-to-reduce-debt\\\" in the case of REPAY-SWAP-REPAY, zero in other cases\\r\\n    uint entryDataParam;\\r\\n  }\\r\\n\\r\\n  struct GetIterationPlanLocal {\\r\\n    /// @notice Underlying balance\\r\\n    uint assetBalance;\\r\\n    /// @notice Not-underlying balance\\r\\n    uint tokenBalance;\\r\\n\\r\\n    uint totalDebt;\\r\\n    uint totalCollateral;\\r\\n\\r\\n    uint debtReverse;\\r\\n    uint collateralReverse;\\r\\n\\r\\n    address asset;\\r\\n    address token;\\r\\n\\r\\n    bool swapLeftoversNeeded;\\r\\n  }\\r\\n\\r\\n  struct EstimateSwapAmountForRepaySwapRepayLocal {\\r\\n    uint x;\\r\\n    uint y;\\r\\n    uint bA1;\\r\\n    uint bB1;\\r\\n    uint alpha;\\r\\n    uint swapRatio;\\r\\n    uint aB3;\\r\\n    uint cA1;\\r\\n    uint cB1;\\r\\n    uint aA2;\\r\\n    uint aB2;\\r\\n  }\\r\\n//endregion ------------------------------------------------ Data types\\r\\n\\r\\n  /// @notice Decode entryData, extract first uint - entry kind\\r\\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\\r\\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\\r\\n    if (entryData_.length == 0) {\\r\\n      return PLAN_SWAP_REPAY;\\r\\n    }\\r\\n    return abi.decode(entryData_, (uint));\\r\\n  }\\r\\n\\r\\n//region ------------------------------------------------ Build plan\\r\\n  /// @notice Build plan to make single iteration of withdraw according to the selected plan\\r\\n  ///         The goal is to withdraw {requestedAmount} and receive {asset}:{token} in proper proportions on the balance\\r\\n  /// @param converterLiquidator [TetuConverter, TetuLiquidator]\\r\\n  /// @param tokens List of the pool tokens. One of them is underlying and one of then is not-underlying\\r\\n  ///               that we are going to withdraw\\r\\n  /// @param liquidationThresholds Liquidation thresholds for the {tokens}. If amount is less then the threshold,\\r\\n  ///                              we cannot swap it.\\r\\n  /// @param prices Prices of the {tokens}, decimals 18, [$/token]\\r\\n  /// @param decs 10**decimal for each token of the {tokens}\\r\\n  /// @param balanceAdditions Amounts that will be added to the current balances of the {tokens}\\r\\n  ///                         to the moment of the plan execution\\r\\n  /// @param packedData Several values packed to fixed-size array (to reduce number of params)\\r\\n  ///    0: usePoolProportions: 1 - read proportions from the pool through IPoolProportionsProvider(this)\\r\\n  ///    1: planKind: selected plan, one of PLAN_XXX\\r\\n  ///    2: propNotUnderlying18: value of not-underlying proportion [0..1e18] if usePoolProportions == 0\\r\\n  ///    3: requestedBalance: total amount that should be withdrawn, it can be type(uint).max\\r\\n  ///    4: indexAsset: index of the underlying in {tokens} array\\r\\n  ///    5: indexToken: index of the token in {tokens} array. We are going to withdraw the token and convert it to the asset\\r\\n  ///    6: entryDataParam: required-amount-to-reduce-debt in REPAY-SWAP-REPAY case; zero in other cases\\r\\n  function buildIterationPlan(\\r\\n    address[2] memory converterLiquidator,\\r\\n    address[] memory tokens,\\r\\n    uint[] memory liquidationThresholds,\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs,\\r\\n    uint[] memory balanceAdditions,\\r\\n    uint[7] memory packedData\\r\\n  ) external returns (\\r\\n    uint indexToSwapPlus1,\\r\\n    uint amountToSwap,\\r\\n    uint indexToRepayPlus1\\r\\n  ) {\\r\\n    return _buildIterationPlan(\\r\\n      SwapRepayPlanParams({\\r\\n        converter: ITetuConverter(converterLiquidator[0]),\\r\\n        liquidator: ITetuLiquidator(converterLiquidator[1]),\\r\\n        tokens: tokens,\\r\\n        liquidationThresholds: liquidationThresholds,\\r\\n        prices: prices,\\r\\n        decs: decs,\\r\\n        balanceAdditions: balanceAdditions,\\r\\n        planKind: packedData[1],\\r\\n        propNotUnderlying18: packedData[2],\\r\\n        usePoolProportions: packedData[0] != 0,\\r\\n        entryDataParam: packedData[6]\\r\\n      }),\\r\\n      packedData[3],\\r\\n      packedData[4],\\r\\n      packedData[5]\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Generate plan for next withdraw iteration. We can do only one swap per iteration.\\r\\n  ///         In general, we cam make 1) single swap (direct or reverse) and 2) repay\\r\\n  ///         Swap is required to get required repay-amount OR to swap leftovers on final iteration.\\r\\n  /// @param requestedBalance Amount of underlying that we need to have on balance after executing the plan.\\r\\n  /// @param indexAsset Index of the underlying in {p.tokens} array\\r\\n  /// @param indexToken Index of the not-underlying in {p.tokens} array\\r\\n  /// @return indexToSwapPlus1 1-based index of the token to be swapped; 0 means swap is not required.\\r\\n  /// @return amountToSwap Amount to be swapped. 0 - no swap\\r\\n  /// @return indexToRepayPlus1 1-based index of the token that should be used to repay borrow in converter.\\r\\n  ///                            0 - no repay is required - it means that this is a last step with swapping leftovers.\\r\\n  function _buildIterationPlan(\\r\\n    SwapRepayPlanParams memory p,\\r\\n    uint requestedBalance,\\r\\n    uint indexAsset,\\r\\n    uint indexToken\\r\\n  ) internal returns (\\r\\n    uint indexToSwapPlus1,\\r\\n    uint amountToSwap,\\r\\n    uint indexToRepayPlus1\\r\\n  ) {\\r\\n    GetIterationPlanLocal memory v;\\r\\n    v.asset = p.tokens[indexAsset];\\r\\n    v.token = p.tokens[indexToken];\\r\\n\\r\\n    v.assetBalance = IERC20(v.asset).balanceOf(address(this)) + p.balanceAdditions[indexAsset];\\r\\n    v.tokenBalance = IERC20(p.tokens[indexToken]).balanceOf(address(this)) + p.balanceAdditions[indexToken];\\r\\n\\r\\n    if (p.planKind == IterationPlanLib.PLAN_SWAP_ONLY) {\\r\\n      v.swapLeftoversNeeded = true;\\r\\n    } else {\\r\\n      uint requestedAmount = requestedBalance == type(uint).max\\r\\n        ? type(uint).max\\r\\n        : AppLib.sub0(requestedBalance, v.assetBalance);\\r\\n\\r\\n      if (requestedAmount < p.liquidationThresholds[indexAsset]) {\\r\\n        // we don't need to repay any debts anymore, but we should swap leftovers\\r\\n        v.swapLeftoversNeeded = true;\\r\\n      } else {\\r\\n        // we need to increase balance on the following amount: requestedAmount - v.balance;\\r\\n        // we can have two possible borrows:\\r\\n        // 1) direct (p.tokens[INDEX_ASSET] => tokens[i]) and 2) reverse (tokens[i] => p.tokens[INDEX_ASSET])\\r\\n        // normally we can have only one of them, not both..\\r\\n        // but better to take into account possibility to have two debts simultaneously\\r\\n\\r\\n        // reverse debt\\r\\n        (v.debtReverse, v.collateralReverse) = p.converter.getDebtAmountCurrent(address(this), v.token, v.asset, true);\\r\\n        if (v.debtReverse < AppLib.DUST_AMOUNT_TOKENS) { // there is reverse debt or the reverse debt is dust debt\\r\\n          // direct debt\\r\\n          (v.totalDebt, v.totalCollateral) = p.converter.getDebtAmountCurrent(address(this), v.asset, v.token, true);\\r\\n\\r\\n          if (v.totalDebt < AppLib.DUST_AMOUNT_TOKENS) { // there is direct debt or the direct debt is dust debt\\r\\n            // This is final iteration - we need to swap leftovers and get amounts on balance in proper proportions.\\r\\n            // The leftovers should be swapped to get following result proportions of the assets:\\r\\n            //      underlying : not-underlying === 1e18 - propNotUnderlying18 : propNotUnderlying18\\r\\n            v.swapLeftoversNeeded = true;\\r\\n          } else {\\r\\n            // repay direct debt\\r\\n            if (p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY) {\\r\\n              (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanRepaySwapRepay(\\r\\n                p,\\r\\n                [v.assetBalance, v.tokenBalance],\\r\\n                [indexAsset, indexToken],\\r\\n                p.propNotUnderlying18,\\r\\n                [v.totalCollateral, v.totalDebt],\\r\\n                p.entryDataParam\\r\\n              );\\r\\n            } else {\\r\\n              (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanForSellAndRepay(\\r\\n                requestedAmount,\\r\\n                p,\\r\\n                v.totalCollateral,\\r\\n                v.totalDebt,\\r\\n                indexAsset,\\r\\n                indexToken,\\r\\n                v.assetBalance,\\r\\n                v.tokenBalance\\r\\n              );\\r\\n            }\\r\\n          }\\r\\n        } else {\\r\\n          // repay reverse debt\\r\\n          if (p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY) {\\r\\n            (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanRepaySwapRepay(\\r\\n              p,\\r\\n              [v.tokenBalance, v.assetBalance],\\r\\n              [indexToken, indexAsset],\\r\\n              1e18 - p.propNotUnderlying18,\\r\\n              [v.collateralReverse, v.debtReverse],\\r\\n              p.entryDataParam\\r\\n            );\\r\\n          } else {\\r\\n            (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanForSellAndRepay(\\r\\n              requestedAmount == type(uint).max\\r\\n                ? type(uint).max\\r\\n                : requestedAmount * p.prices[indexAsset] * p.decs[indexToken] / p.prices[indexToken] / p.decs[indexAsset],\\r\\n              p,\\r\\n              v.collateralReverse,\\r\\n              v.debtReverse,\\r\\n              indexToken,\\r\\n              indexAsset,\\r\\n              v.tokenBalance,\\r\\n              v.assetBalance\\r\\n            );\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (v.swapLeftoversNeeded) {\\r\\n      (indexToSwapPlus1, amountToSwap) = _buildPlanForLeftovers(p, v.assetBalance, v.tokenBalance, indexAsset, indexToken, p.propNotUnderlying18);\\r\\n    }\\r\\n\\r\\n    return (indexToSwapPlus1, amountToSwap, indexToRepayPlus1);\\r\\n  }\\r\\n\\r\\n  /// @notice Repay B, get collateral A, then swap A => B, [make one more repay B] => get A:B in required proportions\\r\\n  /// @param balancesAB [balanceA, balanceB]\\r\\n  /// @param idxAB [indexA, indexB]\\r\\n  /// @param totalAB [totalCollateralA, totalBorrowB]\\r\\n  /// @param requiredAmountToReduceDebt If not zero: we are going to make repay-swap-repay to reduce total\\r\\n  ///        debt on the given amount. So, if possible it worth to make swap in such a way as to reduce\\r\\n  ///        the amount of debt by the given amount.\\r\\n  function _buildPlanRepaySwapRepay(\\r\\n    SwapRepayPlanParams memory p,\\r\\n    uint[2] memory balancesAB,\\r\\n    uint[2] memory idxAB,\\r\\n    uint propB,\\r\\n    uint[2] memory totalAB,\\r\\n    uint requiredAmountToReduceDebt\\r\\n  ) internal returns (\\r\\n    uint indexToSwapPlus1,\\r\\n    uint amountToSwap,\\r\\n    uint indexToRepayPlus1\\r\\n  ) {\\r\\n    // use all available tokenB to repay debt and receive as much as possible tokenA\\r\\n    uint amountToRepay = Math.min(balancesAB[1], totalAB[1]);\\r\\n\\r\\n    uint collateralAmount;\\r\\n    if (amountToRepay >= AppLib.DUST_AMOUNT_TOKENS) {\\r\\n      uint swappedAmountOut;\\r\\n      //\\r\\n      (collateralAmount, swappedAmountOut) = p.converter.quoteRepay(address(this), p.tokens[idxAB[0]], p.tokens[idxAB[1]], amountToRepay);\\r\\n      if (collateralAmount > swappedAmountOut) { // SCB-789\\r\\n        collateralAmount -= swappedAmountOut;\\r\\n      }\\r\\n    } else {\\r\\n      amountToRepay = 0;\\r\\n    }\\r\\n\\r\\n    // swap A to B: full or partial\\r\\n    // SCB-876: swap B to A are also possible here\\r\\n    bool swapB;\\r\\n    (amountToSwap, swapB) = estimateSwapAmountForRepaySwapRepay(\\r\\n      p,\\r\\n      [balancesAB[0], balancesAB[1]],\\r\\n      [idxAB[0], idxAB[1]],\\r\\n      propB,\\r\\n      totalAB[0],\\r\\n      totalAB[1],\\r\\n      collateralAmount,\\r\\n      amountToRepay\\r\\n    );\\r\\n\\r\\n    if (swapB) {\\r\\n      // edge case: swap B => A; for simplicity, we don't take into account requiredAmountToReduceDebt\\r\\n      return (idxAB[1] + 1, amountToSwap, idxAB[1] + 1);\\r\\n    } else {\\r\\n      // swap A => B\\r\\n      if (requiredAmountToReduceDebt != 0) {\\r\\n        // probably it worth to increase amount to swap?\\r\\n        uint requiredAmountToSwap = requiredAmountToReduceDebt * p.prices[idxAB[1]] * p.decs[idxAB[0]] / p.prices[idxAB[0]] / p.decs[idxAB[1]];\\r\\n        amountToSwap = Math.max(amountToSwap, requiredAmountToSwap);\\r\\n        amountToSwap = Math.min(amountToSwap, balancesAB[0] + collateralAmount);\\r\\n      }\\r\\n\\r\\n      return (idxAB[0] + 1, amountToSwap, idxAB[1] + 1);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Estimate swap amount for iteration \\\"repay-swap-repay\\\"\\r\\n  ///         The iteration should give us amounts of assets in required proportions.\\r\\n  ///         There are two cases here: full swap and partial swap. Second repay is not required if the swap is partial.\\r\\n  /// @param collateralA Estimated value of collateral A received after repay balanceB\\r\\n  /// @return amountToSwap Amount to be swapped\\r\\n  /// @return swapB False: swap A => B; True: swap B => A\\r\\n  function estimateSwapAmountForRepaySwapRepay(\\r\\n    SwapRepayPlanParams memory p,\\r\\n    uint[2] memory balancesAB,\\r\\n    uint[2] memory indicesAB,\\r\\n    uint propB,\\r\\n    uint totalCollateralA,\\r\\n    uint totalBorrowB,\\r\\n    uint collateralA,\\r\\n    uint amountToRepayB\\r\\n  ) internal pure returns(uint amountToSwap, bool swapB) {\\r\\n    // N - number of the state\\r\\n    // bAN, bBN - balances of A and B; aAN, aBN - amounts of A and B; cAN, cBN - collateral/borrow amounts of A/B\\r\\n    // alpha ~ cAN/cBN - estimated ratio of collateral/borrow\\r\\n    // s = swap ratio, aA is swapped to aB, so aA = s * aB\\r\\n    // g = split ratio, bA1 is divided on two parts: bA1 * gamma, bA1 * (1 - gamma). First part is swapped.\\r\\n    // X = proportion of A, Y = proportion of B\\r\\n\\r\\n    // Formulas\\r\\n    // aB3 = (x * bB2 - y * bA2) / (alpha * y + x)\\r\\n    // gamma = (y * bA1 - x * bB1) / (bA1 * (x * s + y))\\r\\n\\r\\n    // There are following stages:\\r\\n    // 0. init (we have at least not zero amount of B and not zero debt of B)\\r\\n    // 1. repay 1 (repay all available amount of B OR all available debt)\\r\\n    // 2. swap (swap A fully or partially to B)\\r\\n    // 3. repay 2 (optional: we need this stage if full swap produces amount of B that is <= available debt)\\r\\n    // 4. final (we have assets in right proportion on the balance)\\r\\n    EstimateSwapAmountForRepaySwapRepayLocal memory v;\\r\\n    v.x = 1e18 - propB;\\r\\n    v.y = propB;\\r\\n// 1. repay 1\\r\\n    // convert amounts A, amounts B to cost A, cost B in USD\\r\\n    v.bA1 = (balancesAB[0] + collateralA) * p.prices[indicesAB[0]] / p.decs[indicesAB[0]];\\r\\n    v.bB1 = (balancesAB[1] - amountToRepayB) * p.prices[indicesAB[1]] / p.decs[indicesAB[1]];\\r\\n    v.cB1 = (totalBorrowB - amountToRepayB) * p.prices[indicesAB[1]] / p.decs[indicesAB[1]];\\r\\n    v.alpha = 1e18 * totalCollateralA * p.prices[indicesAB[0]] * p.decs[indicesAB[1]]\\r\\n      / p.decs[indicesAB[0]] / p.prices[indicesAB[1]] / totalBorrowB; // (!) approx estimation\\r\\n\\r\\n// 2. full swap\\r\\n    v.aA2 = v.bA1;\\r\\n    v.swapRatio = 1e18; // we assume swap ratio 1:1\\r\\n\\r\\n// 3. repay 2\\r\\n    // aB3 = (x * bB2 - Y * bA2) / (alpha * y + x)\\r\\n    v.aB3 = (\\r\\n      v.x * (v.bB1 + v.aA2 * v.swapRatio / 1e18)    // bB2 = v.bB1 + v.aA2 * v.s / 1e18\\r\\n      - v.y * (v.bA1 - v.aA2)                       // bA2 = v.bA1 - v.aA2;\\r\\n    ) / (v.y * v.alpha / 1e18 + v.x);\\r\\n\\r\\n    if (v.aB3 > v.cB1) {\\r\\n      if (v.y * v.bA1 >= v.x * v.bB1) {\\r\\n        // there is not enough debt to make second repay\\r\\n        // we need to make partial swap and receive assets in right proportions in result\\r\\n        // v.gamma = 1e18 * (v.y * v.bA1 - v.x * v.bB1) / (v.bA1 * (v.x * v.s / 1e18 + v.y));\\r\\n        v.aA2 = (v.y * v.bA1 - v.x * v.bB1) / (v.x * v.swapRatio / 1e18 + v.y);\\r\\n      } else {\\r\\n        // scb-867: edge case, we need to make swap B => A\\r\\n        v.aB2 = (v.x * v.bB1 - v.y * v.bA1) / (v.x * v.swapRatio / 1e18 + v.y) /* * 1e18 / v.swapRatio */ ;\\r\\n        swapB = true;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return swapB\\r\\n      ? (v.aB2 * p.decs[indicesAB[1]] / p.prices[indicesAB[1]], true) // edge case: swap B => A\\r\\n      : (v.aA2 * p.decs[indicesAB[0]] / p.prices[indicesAB[0]], false); // normal case: swap A => B\\r\\n  }\\r\\n\\r\\n  /// @notice Prepare a plan to swap leftovers to required proportion\\r\\n  /// @param balanceA Balance of token A, i.e. underlying\\r\\n  /// @param balanceB Balance of token B, i.e. not-underlying\\r\\n  /// @param indexA Index of the token A, i.e. underlying, in {p.prices} and {p.decs}\\r\\n  /// @param indexB Index of the token B, i.e. not-underlying, in {p.prices} and {p.decs}\\r\\n  /// @param propB Required proportion of TokenB [0..1e18]. Proportion of token A is (1e18-propB)\\r\\n  /// @return indexTokenToSwapPlus1 Index of the token to be swapped. 0 - no swap is required\\r\\n  /// @return amountToSwap Amount to be swapped. 0 - no swap is required\\r\\n  function _buildPlanForLeftovers(\\r\\n    SwapRepayPlanParams memory p,\\r\\n    uint balanceA,\\r\\n    uint balanceB,\\r\\n    uint indexA,\\r\\n    uint indexB,\\r\\n    uint propB\\r\\n  ) internal pure returns (\\r\\n    uint indexTokenToSwapPlus1,\\r\\n    uint amountToSwap\\r\\n  ) {\\r\\n    (uint targetA, uint targetB) = _getTargetAmounts(p.prices, p.decs, balanceA, balanceB, propB, indexA, indexB);\\r\\n    if (balanceA < targetA) {\\r\\n      // we need to swap not-underlying to underlying\\r\\n      if (balanceB - targetB > p.liquidationThresholds[indexB]) {\\r\\n        amountToSwap = balanceB - targetB;\\r\\n        indexTokenToSwapPlus1 = indexB + 1;\\r\\n      }\\r\\n    } else {\\r\\n      // we need to swap underlying to not-underlying\\r\\n      if (balanceA - targetA > p.liquidationThresholds[indexA]) {\\r\\n        amountToSwap = balanceA - targetA;\\r\\n        indexTokenToSwapPlus1 = indexA + 1;\\r\\n      }\\r\\n    }\\r\\n    return (indexTokenToSwapPlus1, amountToSwap);\\r\\n  }\\r\\n\\r\\n  /// @notice Prepare a plan to swap some amount of collateral to get required repay-amount and make repaying\\r\\n  ///         1) Sell collateral-asset to get missed amount-to-repay 2) make repay and get more collateral back\\r\\n  /// @param requestedAmount We need to increase balance (of collateral asset) on this amount.\\r\\n  /// @param totalCollateral Total amount of collateral used in the borrow\\r\\n  /// @param totalDebt Total amount of debt that should be repaid to receive {totalCollateral}\\r\\n  /// @param indexCollateral Index of collateral asset in {p.prices}, {p.decs}\\r\\n  /// @param indexBorrow Index of borrow asset in {p.prices}, {p.decs}\\r\\n  /// @param balanceCollateral Current balance of the collateral asset\\r\\n  /// @param balanceBorrow Current balance of the borrowed asset\\r\\n  /// @param indexTokenToSwapPlus1 1-based index of the token to be swapped. Swap of amount of collateral asset can be required\\r\\n  ///                              to receive missed amount-to-repay. 0 - no swap is required\\r\\n  /// @param amountToSwap Amount to be swapped. 0 - no swap is required\\r\\n  /// @param indexRepayTokenPlus1 1-based index of the token to be repaied. 0 - no repaying is required\\r\\n  function _buildPlanForSellAndRepay(\\r\\n    uint requestedAmount,\\r\\n    SwapRepayPlanParams memory p,\\r\\n    uint totalCollateral,\\r\\n    uint totalDebt,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrow,\\r\\n    uint balanceCollateral,\\r\\n    uint balanceBorrow\\r\\n  ) internal pure returns (\\r\\n    uint indexTokenToSwapPlus1,\\r\\n    uint amountToSwap,\\r\\n    uint indexRepayTokenPlus1\\r\\n  ) {\\r\\n    // what amount of collateral we should sell to get required amount-to-pay to pay the debt\\r\\n    uint toSell = _getAmountToSell(\\r\\n      requestedAmount,\\r\\n      totalDebt,\\r\\n      totalCollateral,\\r\\n      p.prices,\\r\\n      p.decs,\\r\\n      indexCollateral,\\r\\n      indexBorrow,\\r\\n      balanceBorrow\\r\\n    );\\r\\n\\r\\n    // convert {toSell} amount of underlying to token\\r\\n    if (toSell != 0 && balanceCollateral != 0) {\\r\\n      toSell = Math.min(toSell, balanceCollateral);\\r\\n      uint threshold = p.liquidationThresholds[indexCollateral];\\r\\n      if (toSell > threshold) {\\r\\n        amountToSwap = toSell;\\r\\n        indexTokenToSwapPlus1 = indexCollateral + 1;\\r\\n      } else {\\r\\n        // we need to sell amount less than the threshold, it's not allowed\\r\\n        // but it's dangerous to just ignore the selling because there is a chance to have error 35\\r\\n        // (There is a debt $3.29, we make repay $3.27 => error 35)\\r\\n        // it would be safer to sell a bit more amount if it's possible\\r\\n        if (balanceCollateral >= threshold + 1) {\\r\\n          amountToSwap = threshold + 1;\\r\\n          indexTokenToSwapPlus1 = indexCollateral + 1;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return (indexTokenToSwapPlus1, amountToSwap, indexBorrow + 1);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate what balances of underlying and not-underlying we need to fit {propNotUnderlying18}\\r\\n  /// @param prices Prices of underlying and not underlying\\r\\n  /// @param decs 10**decimals for underlying and not underlying\\r\\n  /// @param assetBalance Current balance of underlying\\r\\n  /// @param tokenBalance Current balance of not-underlying\\r\\n  /// @param propNotUnderlying18 Required proportion of not-underlying [0..1e18]\\r\\n  ///                            Proportion of underlying would be (1e18 - propNotUnderlying18)\\r\\n  /// @param targetAssets What result balance of underlying is required to fit to required proportions\\r\\n  /// @param targetTokens What result balance of not-underlying is required to fit to required proportions\\r\\n  function _getTargetAmounts(\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs,\\r\\n    uint assetBalance,\\r\\n    uint tokenBalance,\\r\\n    uint propNotUnderlying18,\\r\\n    uint indexAsset,\\r\\n    uint indexToken\\r\\n  ) internal pure returns (\\r\\n    uint targetAssets,\\r\\n    uint targetTokens\\r\\n  ) {\\r\\n    uint costAssets = assetBalance * prices[indexAsset] / decs[indexAsset];\\r\\n    uint costTokens = tokenBalance * prices[indexToken] / decs[indexToken];\\r\\n    targetTokens = propNotUnderlying18 == 0\\r\\n      ? 0\\r\\n      : ((costAssets + costTokens) * propNotUnderlying18 / 1e18);\\r\\n    targetAssets = ((costAssets + costTokens) - targetTokens) * decs[indexAsset] / prices[indexAsset];\\r\\n    targetTokens = targetTokens * decs[indexToken] / prices[indexToken];\\r\\n  }\\r\\n\\r\\n  /// @notice What amount of collateral should be sold to pay the debt and receive {requestedAmount}\\r\\n  /// @dev It doesn't allow to sell more than the amount of total debt in the borrow\\r\\n  /// @param requestedAmount We need to increase balance (of collateral asset) on this amount\\r\\n  /// @param totalDebt Total debt of the borrow in terms of borrow asset\\r\\n  /// @param totalCollateral Total collateral of the borrow in terms of collateral asset\\r\\n  /// @param prices Cost of $1 in terms of the asset, decimals 18\\r\\n  /// @param decs 10**decimals for each asset\\r\\n  /// @param indexCollateral Index of the collateral asset in {prices} and {decs}\\r\\n  /// @param indexBorrowAsset Index of the borrow asset in {prices} and {decs}\\r\\n  /// @param balanceBorrowAsset Available balance of the borrow asset, it will be used to cover the debt\\r\\n  /// @return amountOut Amount of collateral-asset that should be sold\\r\\n  function _getAmountToSell(\\r\\n    uint requestedAmount,\\r\\n    uint totalDebt,\\r\\n    uint totalCollateral,\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrowAsset,\\r\\n    uint balanceBorrowAsset\\r\\n  ) internal pure returns (\\r\\n    uint amountOut\\r\\n  ) {\\r\\n    if (totalDebt != 0) {\\r\\n      if (balanceBorrowAsset != 0) {\\r\\n        // there is some borrow asset on balance\\r\\n        // it will be used to cover the debt\\r\\n        // let's reduce the size of totalDebt/Collateral to exclude balanceBorrowAsset\\r\\n        uint sub = Math.min(balanceBorrowAsset, totalDebt);\\r\\n        totalCollateral -= totalCollateral * sub / totalDebt;\\r\\n        totalDebt -= sub;\\r\\n      }\\r\\n\\r\\n      // for definiteness: usdc - collateral asset, dai - borrow asset\\r\\n      // Pc = price of the USDC, Pb = price of the DAI, alpha = Pc / Pb [DAI / USDC]\\r\\n      // S [USDC] - amount to sell, R [DAI] = alpha * S - amount to repay\\r\\n      // After repaying R we get: alpha * S * C / R\\r\\n      // Balance should be increased on: requestedAmount = alpha * S * C / R - S\\r\\n      // So, we should sell: S = requestedAmount / (alpha * C / R - 1))\\r\\n      // We can lost some amount on liquidation of S => R, so we need to use some gap = {GAP_AMOUNT_TO_SELL}\\r\\n      // Same formula: S * h = S + requestedAmount, where h = health factor => s = requestedAmount / (h - 1)\\r\\n      // h = alpha * C / R\\r\\n      uint alpha18 = prices[indexCollateral] * decs[indexBorrowAsset] * 1e18\\r\\n        / prices[indexBorrowAsset] / decs[indexCollateral];\\r\\n\\r\\n      // if totalCollateral is zero (liquidation happens) we will have zero amount (the debt shouldn't be paid)\\r\\n      amountOut = totalDebt != 0 && alpha18 * totalCollateral / totalDebt > 1e18\\r\\n        ? Math.min(requestedAmount, totalCollateral) * 1e18 / (alpha18 * totalCollateral / totalDebt - 1e18)\\r\\n        : 0;\\r\\n\\r\\n      if (amountOut != 0) {\\r\\n        // we shouldn't try to sell amount greater than amount of totalDebt in terms of collateral asset\\r\\n        // but we always asks +1% because liquidation results can be different a bit from expected\\r\\n        amountOut = (AppLib.GAP_CONVERSION + AppLib.DENOMINATOR) * Math.min(amountOut, totalDebt * 1e18 / alpha18) / AppLib.DENOMINATOR;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return amountOut;\\r\\n  }\\r\\n//endregion ------------------------------------------------ Build plan\\r\\n}\\r\\n\",\"keccak256\":\"0xbe94b0f9bfed116a0dd0fe1c212203b58d40d9a81416116d63fd07669f708596\",\"license\":\"BUSL-1.1\"},\"contracts/libs/TokenAmountsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./AppErrors.sol\\\";\\r\\n\\r\\n/// @title Library for clearing / joining token addresses & amounts arrays\\r\\n/// @author bogdoslav\\r\\nlibrary TokenAmountsLib {\\r\\n  /// @notice Version of the contract\\r\\n  /// @dev Should be incremented when contract changed\\r\\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \\\"1.0.1\\\";\\r\\n\\r\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\r\\n    unchecked {\\r\\n      return i + 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function filterZeroAmounts(\\r\\n    address[] memory tokens,\\r\\n    uint[] memory amounts\\r\\n  ) internal pure returns (\\r\\n    address[] memory t,\\r\\n    uint[] memory a\\r\\n  ) {\\r\\n    require(tokens.length == amounts.length, AppErrors.INCORRECT_LENGTHS);\\r\\n    uint len2 = 0;\\r\\n    uint len = tokens.length;\\r\\n    for (uint i = 0; i < len; i++) {\\r\\n      if (amounts[i] != 0) len2++;\\r\\n    }\\r\\n\\r\\n    t = new address[](len2);\\r\\n    a = new uint[](len2);\\r\\n\\r\\n    uint j = 0;\\r\\n    for (uint i = 0; i < len; i++) {\\r\\n      uint amount = amounts[i];\\r\\n      if (amount != 0) {\\r\\n        t[j] = tokens[i];\\r\\n        a[j] = amount;\\r\\n        j++;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\\r\\n  function combineArrays(\\r\\n    address[] memory tokens0,\\r\\n    uint[] memory amounts0,\\r\\n    address[] memory tokens1,\\r\\n    uint[] memory amounts1,\\r\\n    address[] memory tokens2,\\r\\n    uint[] memory amounts2\\r\\n  ) internal pure returns (\\r\\n    address[] memory allTokens,\\r\\n    uint[] memory allAmounts\\r\\n  ) {\\r\\n    uint[] memory lens = new uint[](3);\\r\\n    lens[0] = tokens0.length;\\r\\n    lens[1] = tokens1.length;\\r\\n    lens[2] = tokens2.length;\\r\\n\\r\\n    require(\\r\\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\\r\\n      AppErrors.INCORRECT_LENGTHS\\r\\n    );\\r\\n\\r\\n    uint maxLength = lens[0] + lens[1] + lens[2];\\r\\n    address[] memory tokensOut = new address[](maxLength);\\r\\n    uint[] memory amountsOut = new uint[](maxLength);\\r\\n    uint unitedLength;\\r\\n\\r\\n    for (uint step; step < 3; ++step) {\\r\\n      uint[] memory amounts = step == 0\\r\\n        ? amounts0\\r\\n        : (step == 1\\r\\n          ? amounts1\\r\\n          : amounts2);\\r\\n      address[] memory tokens = step == 0\\r\\n        ? tokens0\\r\\n        : (step == 1\\r\\n          ? tokens1\\r\\n          : tokens2);\\r\\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\\r\\n        uint amount1 = amounts[i1];\\r\\n        address token1 = tokens[i1];\\r\\n        bool united = false;\\r\\n\\r\\n        for (uint i = 0; i < unitedLength; i++) {\\r\\n          if (token1 == tokensOut[i]) {\\r\\n            amountsOut[i] += amount1;\\r\\n            united = true;\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n\\r\\n        if (!united) {\\r\\n          tokensOut[unitedLength] = token1;\\r\\n          amountsOut[unitedLength] = amount1;\\r\\n          unitedLength++;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // copy united tokens to result array\\r\\n    allTokens = new address[](unitedLength);\\r\\n    allAmounts = new uint[](unitedLength);\\r\\n    for (uint i; i < unitedLength; i++) {\\r\\n      allTokens[i] = tokensOut[i];\\r\\n      allAmounts[i] = amountsOut[i];\\r\\n    }\\r\\n\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0xb3adb8a53441362b47b3bf5c0c7181f7c1652de7dde3df4fb765e8484447d074\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/ConverterStrategyBaseLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib2.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"../libs/AppErrors.sol\\\";\\r\\nimport \\\"../libs/AppLib.sol\\\";\\r\\nimport \\\"../libs/TokenAmountsLib.sol\\\";\\r\\nimport \\\"../libs/ConverterEntryKinds.sol\\\";\\r\\nimport \\\"../libs/IterationPlanLib.sol\\\";\\r\\nimport \\\"../interfaces/IConverterStrategyBase.sol\\\";\\r\\n\\r\\nlibrary ConverterStrategyBaseLib {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n//region--------------------------------------------------- Data types\\r\\n\\r\\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\\r\\n  struct RecycleLocalParams {\\r\\n    /// @notice Compound amount + Performance amount\\r\\n    uint amountCP;\\r\\n    /// @notice Amount to compound\\r\\n    uint amountC;\\r\\n    /// @notice Amount to send to performance and insurance\\r\\n    uint amountP;\\r\\n    /// @notice Amount to forwarder + amount to compound\\r\\n    uint amountFC;\\r\\n    address rewardToken;\\r\\n    uint len;\\r\\n    uint receivedAmountOut;\\r\\n  }\\r\\n\\r\\n  struct OpenPositionLocal {\\r\\n    uint entryKind;\\r\\n    address[] converters;\\r\\n    uint[] collateralsRequired;\\r\\n    uint[] amountsToBorrow;\\r\\n    uint collateral;\\r\\n    uint amountToBorrow;\\r\\n  }\\r\\n\\r\\n  struct OpenPositionEntryKind1Local {\\r\\n    address[] converters;\\r\\n    uint[] collateralsRequired;\\r\\n    uint[] amountsToBorrow;\\r\\n    uint collateral;\\r\\n    uint amountToBorrow;\\r\\n    uint c1;\\r\\n    uint c3;\\r\\n    uint alpha;\\r\\n  }\\r\\n\\r\\n  struct SwapToGetAmountLocal {\\r\\n    uint len;\\r\\n    uint[] prices;\\r\\n    uint[] decs;\\r\\n  }\\r\\n\\r\\n  struct ConvertAfterWithdrawLocal {\\r\\n    address asset;\\r\\n    uint spent;\\r\\n    uint received;\\r\\n    uint balance;\\r\\n    uint balanceBefore;\\r\\n    uint len;\\r\\n  }\\r\\n\\r\\n  struct SwapToGivenAmountInputParams {\\r\\n    ITetuConverter converter;\\r\\n    ITetuLiquidator liquidator;\\r\\n    uint targetAmount;\\r\\n    address[] tokens;\\r\\n    uint[] amounts;\\r\\n    /// @notice liquidationThresholds for the {tokens}\\r\\n    uint[] liquidationThresholds;\\r\\n    uint indexTargetAsset;\\r\\n    address underlying;\\r\\n    /// @notice Allow to swap more then required (i.e. 1_000 => +1%)\\r\\n    ///         to avoid additional swap if the swap return amount a bit less than we expected\\r\\n    uint overswap;\\r\\n  }\\r\\n\\r\\n  struct SwapToGivenAmountLocal {\\r\\n    uint len;\\r\\n    uint[] availableAmounts;\\r\\n    uint i;\\r\\n  }\\r\\n\\r\\n  struct CloseDebtsForRequiredAmountLocal {\\r\\n    address asset;\\r\\n    uint balanceAsset;\\r\\n    uint balanceToken;\\r\\n\\r\\n    uint newBalanceAsset;\\r\\n    uint newBalanceToken;\\r\\n\\r\\n    uint idxToSwap1;\\r\\n    uint amountToSwap;\\r\\n    uint idxToRepay1;\\r\\n\\r\\n    /// @notice Cost of $1 in terms of the assets, decimals 18\\r\\n    uint[] prices;\\r\\n    /// @notice 10**decimal for the assets\\r\\n    uint[] decs;\\r\\n\\r\\n    /// @notice Amounts that will be received on balance before execution of the plan.\\r\\n    uint[] balanceAdditions;\\r\\n\\r\\n    /// @notice Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n    ///         The leftovers should be swapped to get following result proportions of the assets:\\r\\n    ///         not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\r\\n    uint propNotUnderlying18;\\r\\n\\r\\n    /// @notice proportions should be taken from the pool and re-read from the pool after each swap\\r\\n    bool usePoolProportions;\\r\\n\\r\\n    bool exitLoop;\\r\\n  }\\r\\n\\r\\n  struct DataSetLocal {\\r\\n    ITetuConverter converter;\\r\\n    ITetuLiquidator liquidator;\\r\\n    /// @notice Tokens received from {_depositorPoolAssets}\\r\\n    address[] tokens;\\r\\n    /// @notice Index of the main asset in {tokens}\\r\\n    uint indexAsset;\\r\\n    /// @notice Length of {tokens}\\r\\n    uint len;\\r\\n  }\\r\\n\\r\\n  struct RecycleLocal {\\r\\n    address asset;\\r\\n    uint compoundRatio;\\r\\n    uint performanceFee;\\r\\n    uint toPerf;\\r\\n    uint toInsurance;\\r\\n    uint[] amountsToForward;\\r\\n    uint[] thresholds;\\r\\n    int debtToInsuranceCurrent;\\r\\n    int debtToInsuranceUpdated;\\r\\n    address splitter;\\r\\n  }\\r\\n\\r\\n  /// @notice Input params for _recycle\\r\\n  struct RecycleParams {\\r\\n    ITetuConverter converter;\\r\\n    ITetuLiquidator liquidator;\\r\\n    address splitter;\\r\\n\\r\\n    /// @notice Underlying asset\\r\\n    address asset;\\r\\n    /// @notice Compound ration in the range [0...COMPOUND_DENOMINATOR]\\r\\n    uint compoundRatio;\\r\\n    /// @notice tokens received from {_depositorPoolAssets}\\r\\n    address[] tokens;\\r\\n    /// @notice Liquidation thresholds for rewards tokens\\r\\n    uint[] thresholds;\\r\\n    /// @notice Full list of reward tokens received from tetuConverter and depositor\\r\\n    address[] rewardTokens;\\r\\n    /// @notice Amounts of {rewardTokens_}; we assume, there are no zero amounts here\\r\\n    uint[] rewardAmounts;\\r\\n    /// @notice Performance fee in the range [0...FEE_DENOMINATOR]\\r\\n    uint performanceFee;\\r\\n    /// @notice Current debt to the insurance [in underlying]\\r\\n    int debtToInsurance;\\r\\n    /// @notice Liquidation threshold for the {asset}\\r\\n    uint assetThreshold;\\r\\n  }\\r\\n//endregion--------------------------------------------------- Data types\\r\\n\\r\\n//region--------------------------------------------------- Constants\\r\\n\\r\\n  /// @notice approx one month for average block time 2 sec\\r\\n  uint internal constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\\r\\n  uint internal constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\\r\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\r\\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\\r\\n  uint internal constant PRICE_IMPACT_TOLERANCE = 300;\\r\\n  /// @notice borrow/collateral amount cannot be less than given number of tokens\\r\\n  uint internal constant DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD = 10;\\r\\n  /// @notice Allow to swap more then required (i.e. 1_000 => +1%) inside {swapToGivenAmount}\\r\\n  ///         to avoid additional swap if the swap will return amount a bit less than we expected\\r\\n  uint internal constant OVERSWAP = PRICE_IMPACT_TOLERANCE + _ASSET_LIQUIDATION_SLIPPAGE;\\r\\n  /// @notice During SWAP-REPAY cycle we can receive requested amount after SWAP, so, following REPAY will be skipped.\\r\\n  ///         But we should prevent situation \\\"zero balance, not zero debts\\\".\\r\\n  ///         So, it worth to request amount higher (on the given gap) than it's really requested.\\r\\n  uint internal constant REQUESTED_BALANCE_GAP = 5_000; // 5%\\r\\n//endregion--------------------------------------------------- Constants\\r\\n\\r\\n//region--------------------------------------------------- Events\\r\\n  /// @notice A borrow was made\\r\\n  event OpenPosition(\\r\\n    address converter,\\r\\n    address collateralAsset,\\r\\n    uint collateralAmount,\\r\\n    address borrowAsset,\\r\\n    uint borrowedAmount,\\r\\n    address recepient\\r\\n  );\\r\\n\\r\\n  /// @notice Some borrow(s) was/were repaid\\r\\n  event ClosePosition(\\r\\n    address collateralAsset,\\r\\n    address borrowAsset,\\r\\n    uint amountRepay,\\r\\n    address recepient,\\r\\n    uint returnedAssetAmountOut,\\r\\n    uint returnedBorrowAmountOut\\r\\n  );\\r\\n\\r\\n  /// @notice A liquidation was made\\r\\n  event Liquidation(\\r\\n    address tokenIn,\\r\\n    address tokenOut,\\r\\n    uint amountIn,\\r\\n    uint spentAmountIn,\\r\\n    uint receivedAmountOut\\r\\n  );\\r\\n\\r\\n  event ReturnAssetToConverter(address asset, uint amount);\\r\\n\\r\\n  /// @notice Recycle was made\\r\\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\\r\\n  /// @param amountsToForward Amounts to be sent to forwarder\\r\\n  event Recycle(\\r\\n    address[] rewardTokens,\\r\\n    uint[] amountsToForward,\\r\\n    uint toPerf,\\r\\n    uint toInsurance\\r\\n  );\\r\\n\\r\\n  /// @notice Debt to insurance was paid by rewards\\r\\n  /// @param debtToInsuranceBefore Initial amount of debts to the insurance, in underlying\\r\\n  /// @param debtToInsuranceBefore Final amount of debts to the insurance, in underlying\\r\\n  event OnPayDebtToInsurance(\\r\\n    int debtToInsuranceBefore,\\r\\n    int debtToInsuraneAfter\\r\\n  );\\r\\n\\r\\n  /// @notice Debt to insurance was paid by a reward token\\r\\n  /// @param debtToCover Initial amount of debt that should be covered, in underlying\\r\\n  /// @param debtLeftovers Final amount of debt that should be covered, in underlying\\r\\n  /// It can be negative if we paid more than required\\r\\n  event OnCoverDebtToInsurance(\\r\\n    address rewardToken,\\r\\n    uint rewardAmount,\\r\\n    uint debtToCover,\\r\\n    int debtLeftovers\\r\\n  );\\r\\n//endregion---------------------------------------------------  Events\\r\\n\\r\\n//region--------------------------------------------------- Borrow and close positions\\r\\n\\r\\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\\r\\n  ///         Max possible collateral should be approved before calling of this function.\\r\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\r\\n  ///                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\r\\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\\r\\n  /// @param amountIn_ Meaning depends on {entryData_}.\\r\\n  function openPosition(\\r\\n    ITetuConverter tetuConverter_,\\r\\n    bytes memory entryData_,\\r\\n    address collateralAsset_,\\r\\n    address borrowAsset_,\\r\\n    uint amountIn_,\\r\\n    uint thresholdAmountIn_\\r\\n  ) external returns (\\r\\n    uint collateralAmountOut,\\r\\n    uint borrowedAmountOut\\r\\n  ) {\\r\\n    return _openPosition(tetuConverter_, entryData_, collateralAsset_, borrowAsset_, amountIn_, thresholdAmountIn_);\\r\\n  }\\r\\n\\r\\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\\r\\n  ///         Max possible collateral should be approved before calling of this function.\\r\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\r\\n  ///                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\r\\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\\r\\n  /// @param amountIn_ Meaning depends on {entryData_}.\\r\\n  /// @param thresholdAmountIn_ Min value of amountIn allowed for the second and subsequent conversions.\\r\\n  ///        0 - use default min value\\r\\n  ///        If amountIn becomes too low, no additional borrows are possible, so\\r\\n  ///        the rest amountIn is just added to collateral/borrow amount of previous conversion.\\r\\n  function _openPosition(\\r\\n    ITetuConverter tetuConverter_,\\r\\n    bytes memory entryData_,\\r\\n    address collateralAsset_,\\r\\n    address borrowAsset_,\\r\\n    uint amountIn_,\\r\\n    uint thresholdAmountIn_\\r\\n  ) internal returns (\\r\\n    uint collateralAmountOut,\\r\\n    uint borrowedAmountOut\\r\\n  ) {\\r\\n    if (thresholdAmountIn_ == 0) {\\r\\n      // zero threshold is not allowed because round-issues are possible, see openPosition.dust test\\r\\n      // we assume here, that it's useless to borrow amount using collateral/borrow amount\\r\\n      // less than given number of tokens (event for BTC)\\r\\n      thresholdAmountIn_ = DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD;\\r\\n    }\\r\\n    if (amountIn_ <= thresholdAmountIn_) {\\r\\n      return (0, 0);\\r\\n    }\\r\\n\\r\\n    OpenPositionLocal memory vars;\\r\\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\\r\\n    vars.entryKind = ConverterEntryKinds.getEntryKind(entryData_);\\r\\n    if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\\r\\n      return openPositionEntryKind1(\\r\\n        tetuConverter_,\\r\\n        entryData_,\\r\\n        collateralAsset_,\\r\\n        borrowAsset_,\\r\\n        amountIn_,\\r\\n        thresholdAmountIn_\\r\\n      );\\r\\n    } else {\\r\\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\\r\\n        entryData_,\\r\\n        collateralAsset_,\\r\\n        amountIn_,\\r\\n        borrowAsset_,\\r\\n        _LOAN_PERIOD_IN_BLOCKS\\r\\n      );\\r\\n\\r\\n      uint len = vars.converters.length;\\r\\n      if (len > 0) {\\r\\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\\r\\n          vars.collateral;\\r\\n          vars.amountToBorrow;\\r\\n          if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\\r\\n            // we have exact amount of total collateral amount\\r\\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\\r\\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\\r\\n              ? amountIn_\\r\\n              : vars.collateralsRequired[i];\\r\\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\\r\\n              ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\\r\\n              : vars.amountsToBorrow[i];\\r\\n            amountIn_ -= vars.collateral;\\r\\n          } else {\\r\\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\\r\\n            // we have exact amount of total amount-to-borrow\\r\\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\\r\\n              ? amountIn_\\r\\n              : vars.amountsToBorrow[i];\\r\\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\\r\\n              ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\\r\\n              : vars.collateralsRequired[i];\\r\\n            amountIn_ -= vars.amountToBorrow;\\r\\n          }\\r\\n\\r\\n          if (amountIn_ < thresholdAmountIn_ && amountIn_ != 0) {\\r\\n            // dust amount is left, just leave it unused\\r\\n            // we cannot add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\\r\\n            amountIn_ = 0;\\r\\n          }\\r\\n\\r\\n          if (vars.amountToBorrow != 0) {\\r\\n            borrowedAmountOut += tetuConverter_.borrow(\\r\\n              vars.converters[i],\\r\\n              collateralAsset_,\\r\\n              vars.collateral,\\r\\n              borrowAsset_,\\r\\n              vars.amountToBorrow,\\r\\n              address(this)\\r\\n            );\\r\\n            collateralAmountOut += vars.collateral;\\r\\n            emit OpenPosition(\\r\\n              vars.converters[i],\\r\\n              collateralAsset_,\\r\\n              vars.collateral,\\r\\n              borrowAsset_,\\r\\n              vars.amountToBorrow,\\r\\n              address(this)\\r\\n            );\\r\\n          }\\r\\n\\r\\n          if (amountIn_ == 0) break;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      return (collateralAmountOut, borrowedAmountOut);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Open position using entry kind 1 - split provided amount on two parts according provided proportions\\r\\n  /// @param amountIn_ Amount of collateral to be divided on parts. We assume {amountIn_} > 0\\r\\n  /// @param collateralThreshold_ Min allowed collateral amount to be used for new borrow, > 0\\r\\n  /// @return collateralAmountOut Total collateral used to borrow {borrowedAmountOut}\\r\\n  /// @return borrowedAmountOut Total borrowed amount\\r\\n  function openPositionEntryKind1(\\r\\n    ITetuConverter tetuConverter_,\\r\\n    bytes memory entryData_,\\r\\n    address collateralAsset_,\\r\\n    address borrowAsset_,\\r\\n    uint amountIn_,\\r\\n    uint collateralThreshold_\\r\\n  ) internal returns (\\r\\n    uint collateralAmountOut,\\r\\n    uint borrowedAmountOut\\r\\n  ) {\\r\\n    OpenPositionEntryKind1Local memory vars;\\r\\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\\r\\n      entryData_,\\r\\n      collateralAsset_,\\r\\n      amountIn_,\\r\\n      borrowAsset_,\\r\\n      _LOAN_PERIOD_IN_BLOCKS\\r\\n    );\\r\\n\\r\\n    uint len = vars.converters.length;\\r\\n    if (len > 0) {\\r\\n      // we should split amountIn on two amounts with proportions x:y\\r\\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\\r\\n      // calculate prices conversion ratio using price oracle, decimals 18\\r\\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\\r\\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\\r\\n\\r\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\\r\\n        // and give us required proportions in result\\r\\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\\r\\n        // C1 is collateral amount left untouched (x)\\r\\n        // C2 is collateral amount converted to B2 (y)\\r\\n        // but if lending platform doesn't have enough liquidity\\r\\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\\r\\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\\r\\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\\r\\n        vars.c1 = x * vars.c3 / y;\\r\\n\\r\\n        // we doesn't calculate an intermediate ratio cR/(cR+c1) to avoid lost of precision\\r\\n        if ((vars.collateralsRequired[i] + vars.c1) > amountIn_) {\\r\\n          vars.collateral = vars.collateralsRequired[i] * amountIn_ / (vars.collateralsRequired[i] + vars.c1);\\r\\n          vars.amountToBorrow = vars.amountsToBorrow[i] * amountIn_ / (vars.collateralsRequired[i] + vars.c1);\\r\\n        } else {\\r\\n          vars.collateral = vars.collateralsRequired[i];\\r\\n          vars.amountToBorrow = vars.amountsToBorrow[i];\\r\\n        }\\r\\n\\r\\n        // skip any attempts to borrow zero amount or use too little collateral\\r\\n        if (vars.collateral < collateralThreshold_ || vars.amountToBorrow == 0) {\\r\\n          if (vars.collateralsRequired[i] + vars.c1 + collateralThreshold_ > amountIn_) {\\r\\n            // The lending platform has enough resources to make the borrow but amount of the borrow is too low\\r\\n            // Skip the borrow, leave leftover of collateral untouched\\r\\n            break;\\r\\n          } else {\\r\\n            // The lending platform doesn't have enough resources to make the borrow.\\r\\n            // We should try to make borrow on the next platform (if any)\\r\\n            continue;\\r\\n          }\\r\\n        }\\r\\n\\r\\n        require(\\r\\n          tetuConverter_.borrow(\\r\\n            vars.converters[i],\\r\\n            collateralAsset_,\\r\\n            vars.collateral,\\r\\n            borrowAsset_,\\r\\n            vars.amountToBorrow,\\r\\n            address(this)\\r\\n          ) == vars.amountToBorrow,\\r\\n          StrategyLib2.WRONG_VALUE\\r\\n        );\\r\\n        emit OpenPosition(\\r\\n          vars.converters[i],\\r\\n          collateralAsset_,\\r\\n          vars.collateral,\\r\\n          borrowAsset_,\\r\\n          vars.amountToBorrow,\\r\\n          address(this)\\r\\n        );\\r\\n\\r\\n        borrowedAmountOut += vars.amountToBorrow;\\r\\n        collateralAmountOut += vars.collateral;\\r\\n\\r\\n        // calculate amount to be borrowed in the next converter\\r\\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\\r\\n        vars.c1 = x * vars.c3 / y;\\r\\n        amountIn_ = (amountIn_ > vars.c1 + vars.collateral)\\r\\n          ? amountIn_ - (vars.c1 + vars.collateral)\\r\\n          : 0;\\r\\n\\r\\n        // protection against dust amounts, see \\\"openPosition.dust\\\", just leave dust amount unused\\r\\n        // we CAN NOT add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\\r\\n        // we assume here, that collateralThreshold_ != 0, so check amountIn_ != 0 is not required\\r\\n        if (amountIn_ < collateralThreshold_) break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return (collateralAmountOut, borrowedAmountOut);\\r\\n  }\\r\\n\\r\\n  /// @notice Get ratio18 = collateral / borrow\\r\\n  function _getCollateralToBorrowRatio(\\r\\n    ITetuConverter converter_,\\r\\n    address collateralAsset_,\\r\\n    address borrowAsset_\\r\\n  ) internal view returns (uint){\\r\\n    IPriceOracle priceOracle = AppLib._getPriceOracle(converter_);\\r\\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\\r\\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\\r\\n    return 1e18 * priceBorrow * 10 ** IERC20Metadata(collateralAsset_).decimals()\\r\\n    / priceCollateral / 10 ** IERC20Metadata(borrowAsset_).decimals();\\r\\n  }\\r\\n\\r\\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\\r\\n  ///         It doesn't repay more than the actual amount of the debt, so it can use less amount than {amountToRepay}\\r\\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\\r\\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\\r\\n  /// @return repaidAmountOut Amount that was actually repaid\\r\\n  function _closePosition(\\r\\n    ITetuConverter converter_,\\r\\n    address collateralAsset,\\r\\n    address borrowAsset,\\r\\n    uint amountToRepay\\r\\n  ) internal returns (\\r\\n    uint returnedAssetAmountOut,\\r\\n    uint repaidAmountOut\\r\\n  ) {\\r\\n\\r\\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\\r\\n\\r\\n    // We shouldn't try to pay more than we actually need to repay\\r\\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\\r\\n    // Let's limit amountToRepay by needToRepay-amount\\r\\n    (uint needToRepay,) = converter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\\r\\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\\r\\n\\r\\n    return _closePositionExact(converter_, collateralAsset, borrowAsset, amountRepay, balanceBefore);\\r\\n  }\\r\\n\\r\\n  /// @notice Close the given position, pay {amountRepay} exactly and ensure that all amount was accepted,\\r\\n  /// @param amountRepay Amount to repay in terms of {borrowAsset}\\r\\n  /// @param balanceBorrowAsset Current balance of the borrow asset\\r\\n  /// @return collateralOut Amount of collateral received back after repaying\\r\\n  /// @return repaidAmountOut Amount that was actually repaid\\r\\n  function _closePositionExact(\\r\\n    ITetuConverter converter_,\\r\\n    address collateralAsset,\\r\\n    address borrowAsset,\\r\\n    uint amountRepay,\\r\\n    uint balanceBorrowAsset\\r\\n  ) internal returns (\\r\\n    uint collateralOut,\\r\\n    uint repaidAmountOut\\r\\n  ) {\\r\\n    if (amountRepay >= AppLib.DUST_AMOUNT_TOKENS) {\\r\\n      // Make full/partial repayment\\r\\n      IERC20(borrowAsset).safeTransfer(address(converter_), amountRepay);\\r\\n\\r\\n      uint notUsedAmount;\\r\\n      (collateralOut, notUsedAmount,,) = converter_.repay(collateralAsset, borrowAsset, amountRepay, address(this));\\r\\n\\r\\n      emit ClosePosition(collateralAsset, borrowAsset, amountRepay, address(this), collateralOut, notUsedAmount);\\r\\n      uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\\r\\n\\r\\n      // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (debt-gap)\\r\\n      repaidAmountOut = balanceBorrowAsset > balanceAfter\\r\\n        ? balanceBorrowAsset - balanceAfter\\r\\n        : 0;\\r\\n      require(notUsedAmount == 0, StrategyLib2.WRONG_VALUE);\\r\\n    }\\r\\n\\r\\n    return (collateralOut, repaidAmountOut);\\r\\n  }\\r\\n\\r\\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\\r\\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\\r\\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\\r\\n  /// @return repaidAmountOut Amount that was actually repaid\\r\\n  function closePosition(\\r\\n    ITetuConverter tetuConverter_,\\r\\n    address collateralAsset,\\r\\n    address borrowAsset,\\r\\n    uint amountToRepay\\r\\n  ) external returns (\\r\\n    uint returnedAssetAmountOut,\\r\\n    uint repaidAmountOut\\r\\n  ) {\\r\\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\\r\\n  }\\r\\n//endregion--------------------------------------------------- Borrow and close positions\\r\\n\\r\\n//region--------------------------------------------------- Liquidation\\r\\n\\r\\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\\r\\n  /// @param liquidationThresholdForTokenIn_ Liquidation threshold for {amountIn_}\\r\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\r\\n  /// @return spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\\r\\n  /// @return receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\\r\\n  function liquidate(\\r\\n    ITetuConverter converter,\\r\\n    ITetuLiquidator liquidator_,\\r\\n    address tokenIn_,\\r\\n    address tokenOut_,\\r\\n    uint amountIn_,\\r\\n    uint slippage_,\\r\\n    uint liquidationThresholdForTokenIn_,\\r\\n    bool skipValidation\\r\\n  ) external returns (\\r\\n    uint spentAmountIn,\\r\\n    uint receivedAmountOut\\r\\n  ) {\\r\\n    return _liquidate(converter, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdForTokenIn_, skipValidation);\\r\\n  }\\r\\n\\r\\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\\r\\n  /// @param liquidationThresholdForTokenIn_ Liquidation threshold for {amountIn_}\\r\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\r\\n  /// @return spentAmountIn Amount of {tokenIn} has been consumed by the liquidator (== 0 | amountIn_)\\r\\n  /// @return receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\\r\\n  function _liquidate(\\r\\n    ITetuConverter converter_,\\r\\n    ITetuLiquidator liquidator_,\\r\\n    address tokenIn_,\\r\\n    address tokenOut_,\\r\\n    uint amountIn_,\\r\\n    uint slippage_,\\r\\n    uint liquidationThresholdForTokenIn_,\\r\\n    bool skipValidation\\r\\n  ) internal returns (\\r\\n    uint spentAmountIn,\\r\\n    uint receivedAmountOut\\r\\n  ) {\\r\\n    // we check amountIn by threshold, not amountOut\\r\\n    // because {_closePositionsToGetAmount} is implemented in {get plan, make action}-way\\r\\n    // {_closePositionsToGetAmount} can be used with swap by aggregators, where amountOut cannot be calculate\\r\\n    // at the moment of plan building. So, for uniformity, only amountIn is checked everywhere\\r\\n\\r\\n    if (amountIn_ <= liquidationThresholdForTokenIn_) {\\r\\n      return (0, 0);\\r\\n    }\\r\\n\\r\\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\\r\\n\\r\\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\\r\\n\\r\\n    // if the expected value is higher than threshold distribute to destinations\\r\\n    return (amountIn_, _liquidateWithRoute(converter_, route, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, skipValidation));\\r\\n  }\\r\\n\\r\\n  /// @notice Make liquidation using given route and check correctness using TetuConverter's price oracle\\r\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\r\\n  function _liquidateWithRoute(\\r\\n    ITetuConverter converter_,\\r\\n    ITetuLiquidator.PoolData[] memory route,\\r\\n    ITetuLiquidator liquidator_,\\r\\n    address tokenIn_,\\r\\n    address tokenOut_,\\r\\n    uint amountIn_,\\r\\n    uint slippage_,\\r\\n    bool skipValidation\\r\\n  ) internal returns (\\r\\n    uint receivedAmountOut\\r\\n  ) {\\r\\n    // we need to approve each time, liquidator address can be changed in controller\\r\\n    AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\\r\\n\\r\\n    uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\\r\\n    liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\\r\\n    uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\\r\\n\\r\\n    require(balanceAfter > balanceBefore, AppErrors.BALANCE_DECREASE);\\r\\n    receivedAmountOut = balanceAfter - balanceBefore;\\r\\n\\r\\n    // Oracle in TetuConverter \\\"knows\\\" only limited number of the assets\\r\\n    // It may not know prices for reward assets, so for rewards this validation should be skipped to avoid TC-4 error\\r\\n    require(skipValidation || converter_.isConversionValid(tokenIn_, amountIn_, tokenOut_, receivedAmountOut, slippage_), AppErrors.PRICE_IMPACT);\\r\\n    emit Liquidation(tokenIn_, tokenOut_, amountIn_, amountIn_, receivedAmountOut);\\r\\n  }\\r\\n//endregion--------------------------------------------------- Liquidation\\r\\n\\r\\n//region--------------------------------------------------- Recycle rewards\\r\\n\\r\\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\\r\\n  /// We have two kinds of rewards:\\r\\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\\r\\n  /// 2) any other rewards\\r\\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\\r\\n  ///   Compound-part of Rewards-2 can be liquidated\\r\\n  ///   Compound part of Rewards-1 should be just left on the balance\\r\\n  ///   Performance amounts should be liquidate, result underlying should be sent to performance receiver and insurance.\\r\\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\\r\\n  /// @dev {_recycle} is implemented as separate (inline) function to simplify unit testing\\r\\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\\r\\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\\r\\n  /// @return paidDebtToInsurance Earned amount spent on debt-to-insurance payment\\r\\n  /// @return amountPerf Performance fee in terms of underlying\\r\\n  function recycle(\\r\\n    IStrategyV3.BaseState storage baseState,\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    address[] memory tokens,\\r\\n    address controller,\\r\\n    mapping(address => uint) storage liquidationThresholds,\\r\\n    address[] memory rewardTokens_,\\r\\n    uint[] memory rewardAmounts_\\r\\n  ) external returns (uint paidDebtToInsurance, uint amountPerf) {\\r\\n    RecycleLocal memory v;\\r\\n    v.asset = baseState.asset;\\r\\n    v.compoundRatio = baseState.compoundRatio;\\r\\n    v.performanceFee = baseState.performanceFee;\\r\\n    v.thresholds = _getLiquidationThresholds(liquidationThresholds, rewardTokens_, rewardTokens_.length);\\r\\n    v.debtToInsuranceCurrent = csbs.debtToInsurance;\\r\\n    v.splitter = baseState.splitter;\\r\\n\\r\\n    (v.amountsToForward, amountPerf, v.debtToInsuranceUpdated) = _recycle(RecycleParams({\\r\\n      converter: csbs.converter,\\r\\n      liquidator: AppLib._getLiquidator(controller),\\r\\n      asset: v.asset,\\r\\n      compoundRatio: v.compoundRatio,\\r\\n      tokens: tokens,\\r\\n      thresholds: v.thresholds,\\r\\n      rewardTokens: rewardTokens_,\\r\\n      rewardAmounts: rewardAmounts_,\\r\\n      performanceFee: v.performanceFee,\\r\\n      debtToInsurance: v.debtToInsuranceCurrent,\\r\\n      splitter: v.splitter,\\r\\n      assetThreshold: AppLib._getLiquidationThreshold(liquidationThresholds[v.asset])\\r\\n    }));\\r\\n\\r\\n    if (v.debtToInsuranceCurrent != v.debtToInsuranceUpdated) {\\r\\n      csbs.debtToInsurance = v.debtToInsuranceUpdated;\\r\\n      emit OnPayDebtToInsurance(v.debtToInsuranceCurrent, v.debtToInsuranceUpdated);\\r\\n      paidDebtToInsurance = v.debtToInsuranceCurrent - v.debtToInsuranceUpdated > 0\\r\\n        ? uint(v.debtToInsuranceCurrent - v.debtToInsuranceUpdated)\\r\\n        : 0;\\r\\n    }\\r\\n\\r\\n    // send performance-part of the underlying to the performance receiver and insurance\\r\\n    (v.toPerf, v.toInsurance) = _sendPerformanceFee(\\r\\n      v.asset,\\r\\n      amountPerf,\\r\\n      v.splitter,\\r\\n      baseState.performanceReceiver,\\r\\n      baseState.performanceFeeRatio\\r\\n    );\\r\\n\\r\\n    // override rewardTokens_, v.amountsToForward by the values actually sent to the forwarder\\r\\n    (rewardTokens_, v.amountsToForward) = _sendTokensToForwarder(controller, v.splitter, rewardTokens_, v.amountsToForward, v.thresholds);\\r\\n\\r\\n    emit Recycle(rewardTokens_, v.amountsToForward, v.toPerf, v.toInsurance);\\r\\n    return (paidDebtToInsurance, amountPerf);\\r\\n  }\\r\\n\\r\\n  /// @notice Send {amount_} of {asset_} to {receiver_} and insurance\\r\\n  /// @param asset_ Underlying asset\\r\\n  /// @param amount_ Amount of underlying asset to be sent to performance+insurance\\r\\n  /// @param receiver_ Performance receiver\\r\\n  /// @param ratio [0..100_000], 100_000 - send full amount to perf, 0 - send full amount to the insurance.\\r\\n  function _sendPerformanceFee(address asset_, uint amount_, address splitter, address receiver_, uint ratio) internal returns (\\r\\n    uint toPerf,\\r\\n    uint toInsurance\\r\\n  ) {\\r\\n    // read inside lib for reduce contract space in the main contract\\r\\n    address insurance = address(ITetuVaultV2(ISplitter(splitter).vault()).insurance());\\r\\n\\r\\n    toPerf = amount_ * ratio / AppLib.DENOMINATOR;\\r\\n    toInsurance = amount_ - toPerf;\\r\\n\\r\\n    if (toPerf != 0) {\\r\\n      IERC20(asset_).safeTransfer(receiver_, toPerf);\\r\\n    }\\r\\n    if (toInsurance != 0) {\\r\\n      IERC20(asset_).safeTransfer(insurance, toInsurance);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Send {amounts_} to forwarder, skip amounts < thresholds (see SCB-812)\\r\\n  /// @return tokensOut Tokens sent to the forwarder\\r\\n  /// @return amountsOut Amounts sent to the forwarder\\r\\n  function _sendTokensToForwarder(\\r\\n    address controller_,\\r\\n    address splitter_,\\r\\n    address[] memory tokens_,\\r\\n    uint[] memory amounts_,\\r\\n    uint[] memory thresholds_\\r\\n  ) internal returns (\\r\\n    address[] memory tokensOut,\\r\\n    uint[] memory amountsOut\\r\\n  ) {\\r\\n    uint len = tokens_.length;\\r\\n    IForwarder forwarder = IForwarder(IController(controller_).forwarder());\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (thresholds_[i] > amounts_[i]) {\\r\\n        amounts_[i] = 0; // it will be excluded in filterZeroAmounts() below\\r\\n      } else {\\r\\n        AppLib.approveIfNeeded(tokens_[i], amounts_[i], address(forwarder));\\r\\n      }\\r\\n    }\\r\\n\\r\\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokens_, amounts_);\\r\\n    if (tokensOut.length != 0) {\\r\\n      forwarder.registerIncome(tokensOut, amountsOut, ISplitter(splitter_).vault(), true);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Recycle the amounts: split each amount on tree parts: performance+insurance (P), forwarder (F), compound (C)\\r\\n  ///         Liquidate P+C, send F to the forwarder.\\r\\n  /// We have two kinds of rewards:\\r\\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\\r\\n  /// 2) any other rewards\\r\\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\\r\\n  ///   Compound-part of Rewards-2 can be liquidated\\r\\n  ///   Compound part of Rewards-1 should be just left on the balance\\r\\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\\r\\n  ///   Performance amounts are liquidated, result amount of underlying is returned in {amountToPerformanceAndInsurance}\\r\\n  /// @return amountsToForward Amounts of {rewardTokens} to be sent to forwarder, zero amounts are allowed here\\r\\n  /// @return amountToPerformanceAndInsurance Amount of underlying to be sent to performance receiver and insurance\\r\\n  /// @return debtToInsuranceOut Remain debt to the insurance [in underlying]\\r\\n  function _recycle(RecycleParams memory p) internal returns (\\r\\n    uint[] memory amountsToForward,\\r\\n    uint amountToPerformanceAndInsurance,\\r\\n    int debtToInsuranceOut\\r\\n  ) {\\r\\n    RecycleLocalParams memory v;\\r\\n\\r\\n    v.len = p.rewardTokens.length;\\r\\n    require(v.len == p.rewardAmounts.length, AppErrors.WRONG_LENGTHS);\\r\\n\\r\\n    amountsToForward = new uint[](v.len);\\r\\n\\r\\n    // rewardAmounts => P + F + C, where P - performance + insurance, F - forwarder, C - compound\\r\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\r\\n      // if we have a debt-to-insurance we should firstly cover the debt using all available rewards\\r\\n      // and only then we can use leftovers of the rewards for other needs\\r\\n      if (p.debtToInsurance > int(p.assetThreshold)) {\\r\\n        (p.rewardAmounts[i], p.debtToInsurance) = _coverDebtToInsuranceFromRewards(p, i, uint(p.debtToInsurance));\\r\\n        if (p.rewardAmounts[i] < p.thresholds[i]) continue;\\r\\n      }\\r\\n\\r\\n      v.amountFC = p.rewardAmounts[i] * (COMPOUND_DENOMINATOR - p.performanceFee) / COMPOUND_DENOMINATOR;\\r\\n      v.amountC = v.amountFC * p.compoundRatio / COMPOUND_DENOMINATOR;\\r\\n      v.amountP = p.rewardAmounts[i] - v.amountFC;\\r\\n      v.rewardToken = p.rewardTokens[i];\\r\\n      v.amountCP = v.amountC + v.amountP;\\r\\n\\r\\n      if (v.amountCP > 0) {\\r\\n        if (AppLib.getAssetIndex(p.tokens, v.rewardToken) != type(uint).max) {\\r\\n          if (v.rewardToken == p.asset) {\\r\\n            // This is underlying, liquidation of compound part is not allowed; just keep on the balance, should be handled later\\r\\n            amountToPerformanceAndInsurance += v.amountP;\\r\\n          } else {\\r\\n            // This is secondary asset, Liquidation of compound part is not allowed, we should liquidate performance part only\\r\\n            // If the performance amount is too small, liquidation will not happen and we will just keep that dust tokens on balance forever\\r\\n            (, v.receivedAmountOut) = _liquidate(\\r\\n              p.converter,\\r\\n              p.liquidator,\\r\\n              v.rewardToken,\\r\\n              p.asset,\\r\\n              v.amountP,\\r\\n              _REWARD_LIQUIDATION_SLIPPAGE,\\r\\n              p.thresholds[i],\\r\\n              false // use conversion validation for these rewards\\r\\n            );\\r\\n            amountToPerformanceAndInsurance += v.receivedAmountOut;\\r\\n          }\\r\\n        } else {\\r\\n          // If amount is too small, the liquidation won't be allowed and we will just keep that dust tokens on balance forever\\r\\n          // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\\r\\n          // We assume here, that {token} cannot be equal to {_asset}\\r\\n          // because the {_asset} is always included to the list of depositor's assets\\r\\n          (, v.receivedAmountOut) = _liquidate(\\r\\n            p.converter,\\r\\n            p.liquidator,\\r\\n            v.rewardToken,\\r\\n            p.asset,\\r\\n            v.amountCP,\\r\\n            _REWARD_LIQUIDATION_SLIPPAGE,\\r\\n            p.thresholds[i],\\r\\n            true // skip conversion validation for rewards because we can have arbitrary assets here\\r\\n          );\\r\\n          amountToPerformanceAndInsurance += v.receivedAmountOut * (p.rewardAmounts[i] - v.amountFC) / v.amountCP;\\r\\n        }\\r\\n      }\\r\\n      amountsToForward[i] = v.amountFC - v.amountC;\\r\\n    }\\r\\n\\r\\n    return (amountsToForward, amountToPerformanceAndInsurance, p.debtToInsurance);\\r\\n  }\\r\\n\\r\\n  /// @notice Try to cover {p.debtToInsurance} using available rewards of {p.rewardTokens[index]}\\r\\n  /// @param index Index of the reward token in {p.rewardTokens}\\r\\n  /// @param debtAmount Debt to insurance that should be covered by the reward tokens\\r\\n  /// @return rewardsLeftovers Amount of unused reward tokens (it can be used for other needs)\\r\\n  /// @return debtToInsuranceOut New value of the debt to the insurance\\r\\n  function _coverDebtToInsuranceFromRewards(RecycleParams memory p, uint index, uint debtAmount) internal returns (\\r\\n    uint rewardsLeftovers,\\r\\n    int debtToInsuranceOut\\r\\n  ) {\\r\\n    uint spentAmount;\\r\\n    uint amountToSend;\\r\\n\\r\\n    if (p.asset == p.rewardTokens[index]) {\\r\\n      // assume p.debtToInsurance > 0 here\\r\\n      spentAmount = Math.min(debtAmount, p.rewardAmounts[index]);\\r\\n      amountToSend = spentAmount;\\r\\n    } else {\\r\\n      // estimate amount of underlying that we can receive for the available amount of the reward tokens\\r\\n      uint amountAsset = p.rewardAmounts[index] > p.assetThreshold\\r\\n        ? p.liquidator.getPrice(p.rewardTokens[index], p.asset, p.rewardAmounts[index])\\r\\n        : 0;\\r\\n      uint amountIn;\\r\\n\\r\\n      if (amountAsset > debtAmount + p.assetThreshold) {\\r\\n        // pay a part of the rewards to cover the debt completely\\r\\n        amountIn = p.rewardAmounts[index] * debtAmount / amountAsset;\\r\\n      } else {\\r\\n        // pay all available rewards to cover a part of the debt\\r\\n        amountIn = p.rewardAmounts[index];\\r\\n      }\\r\\n\\r\\n      (spentAmount, amountToSend) = _liquidate(\\r\\n        p.converter,\\r\\n        p.liquidator,\\r\\n        p.rewardTokens[index],\\r\\n        p.asset,\\r\\n        amountIn,\\r\\n        _REWARD_LIQUIDATION_SLIPPAGE,\\r\\n        p.thresholds[index],\\r\\n        true // skip conversion validation for rewards because we can have arbitrary assets here\\r\\n      );\\r\\n    }\\r\\n\\r\\n    IERC20(p.asset).safeTransfer(address(ITetuVaultV2(ISplitter(p.splitter).vault()).insurance()), amountToSend);\\r\\n\\r\\n    rewardsLeftovers = AppLib.sub0(p.rewardAmounts[index], spentAmount);\\r\\n    debtToInsuranceOut = int(debtAmount) - int(amountToSend);\\r\\n\\r\\n    emit OnCoverDebtToInsurance(p.rewardTokens[index], spentAmount, debtAmount, debtToInsuranceOut);\\r\\n  }\\r\\n//endregion----------------------------------------------- Recycle rewards\\r\\n\\r\\n//region--------------------------------------------------- Before deposit\\r\\n  /// @notice Default implementation of ConverterStrategyBase.beforeDeposit\\r\\n  /// @param amount_ Amount of underlying to be deposited\\r\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\r\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\r\\n  /// @param weights_ Depositor pool weights\\r\\n  /// @param totalWeight_ Sum of {weights_}\\r\\n  function beforeDeposit(\\r\\n    ITetuConverter converter_,\\r\\n    uint amount_,\\r\\n    address[] memory tokens_,\\r\\n    uint indexAsset_,\\r\\n    uint[] memory weights_,\\r\\n    uint totalWeight_,\\r\\n    mapping(address => uint) storage liquidationThresholds\\r\\n  ) external returns (\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    // temporary save collateral to tokensAmounts\\r\\n    tokenAmounts = _getCollaterals(amount_, tokens_, weights_, totalWeight_, indexAsset_, AppLib._getPriceOracle(converter_));\\r\\n\\r\\n    // make borrow and save amounts of tokens available for deposit to tokenAmounts, zero result amounts are possible\\r\\n    tokenAmounts = _getTokenAmounts(\\r\\n      converter_,\\r\\n      tokens_,\\r\\n      indexAsset_,\\r\\n      tokenAmounts,\\r\\n      AppLib._getLiquidationThreshold(liquidationThresholds[tokens_[indexAsset_]])\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice For each {token_} calculate a part of {amount_} to be used as collateral according to the weights.\\r\\n  ///         I.e. we have 300 USDC, we need to split it on 100 USDC, 100 USDT, 100 DAI\\r\\n  ///         USDC is main asset, USDT and DAI should be borrowed. We check amounts of USDT and DAI on the balance\\r\\n  ///         and return collaterals reduced on that amounts. For main asset, we return full amount always (100 USDC).\\r\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\r\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\r\\n  /// @return tokenAmountsOut Length of the array is equal to the length of {tokens_}\\r\\n  function _getCollaterals(\\r\\n    uint amount_,\\r\\n    address[] memory tokens_,\\r\\n    uint[] memory weights_,\\r\\n    uint totalWeight_,\\r\\n    uint indexAsset_,\\r\\n    IPriceOracle priceOracle\\r\\n  ) internal view returns (\\r\\n    uint[] memory tokenAmountsOut\\r\\n  ) {\\r\\n    uint len = tokens_.length;\\r\\n    tokenAmountsOut = new uint[](len);\\r\\n\\r\\n    // get token prices and decimals\\r\\n    (uint[] memory prices, uint[] memory decs) = AppLib._getPricesAndDecs(priceOracle, tokens_, len);\\r\\n\\r\\n    // split the amount on tokens proportionally to the weights\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      uint amountAssetForToken = amount_ * weights_[i] / totalWeight_;\\r\\n\\r\\n      if (i == indexAsset_) {\\r\\n        tokenAmountsOut[i] = amountAssetForToken;\\r\\n      } else {\\r\\n        // if we have some tokens on balance then we need to use only a part of the collateral\\r\\n        uint tokenAmountToBeBorrowed = amountAssetForToken\\r\\n          * prices[indexAsset_]\\r\\n          * decs[i]\\r\\n          / prices[i]\\r\\n          / decs[indexAsset_];\\r\\n\\r\\n        uint tokenBalance = IERC20(tokens_[i]).balanceOf(address(this));\\r\\n        if (tokenBalance < tokenAmountToBeBorrowed) {\\r\\n          tokenAmountsOut[i] = amountAssetForToken * (tokenAmountToBeBorrowed - tokenBalance) / tokenAmountToBeBorrowed;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Make borrow and return amounts of {tokens} available to deposit\\r\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\r\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\r\\n  /// @param collaterals_ Amounts of main asset that can be used as collateral to borrow {tokens_}\\r\\n  /// @param thresholdAsset_ Value of liquidation threshold for the main (collateral) asset\\r\\n  /// @return tokenAmountsOut Amounts of {tokens}  available to deposit\\r\\n  function _getTokenAmounts(\\r\\n    ITetuConverter converter_,\\r\\n    address[] memory tokens_,\\r\\n    uint indexAsset_,\\r\\n    uint[] memory collaterals_,\\r\\n    uint thresholdAsset_\\r\\n  ) internal returns (\\r\\n    uint[] memory tokenAmountsOut\\r\\n  ) {\\r\\n    // content of tokenAmounts will be modified in place\\r\\n    uint len = tokens_.length;\\r\\n    tokenAmountsOut = new uint[](len);\\r\\n    address asset = tokens_[indexAsset_];\\r\\n\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (i != indexAsset_) {\\r\\n        address token = tokens_[i];\\r\\n        if (collaterals_[i] != 0) {\\r\\n          AppLib.approveIfNeeded(asset, collaterals_[i], address(converter_));\\r\\n          _openPosition(\\r\\n            converter_,\\r\\n            \\\"\\\", // entry kind = 0: fixed collateral amount, max possible borrow amount\\r\\n            asset,\\r\\n            token,\\r\\n            collaterals_[i],\\r\\n            thresholdAsset_\\r\\n          );\\r\\n\\r\\n          // zero borrowed amount is possible here (conversion is not available)\\r\\n          // if it's not suitable for depositor, the depositor should check zero amount in other places\\r\\n        }\\r\\n        tokenAmountsOut[i] = IERC20(token).balanceOf(address(this));\\r\\n      }\\r\\n    }\\r\\n\\r\\n    tokenAmountsOut[indexAsset_] = Math.min(\\r\\n      collaterals_[indexAsset_],\\r\\n      IERC20(asset).balanceOf(address(this))\\r\\n    );\\r\\n  }\\r\\n//endregion--------------------------------------------------- Before deposit\\r\\n\\r\\n//region--------------------------------------------------- Make requested amount\\r\\n\\r\\n  /// @notice Convert {amountsToConvert_} to the given {asset}\\r\\n  ///         Swap leftovers (if any) to the given asset.\\r\\n  ///         If result amount is less than expected, try to close any other available debts (1 repay per block only)\\r\\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\\r\\n  /// @param indexAsset_ Index of the given {asset} in {tokens}\\r\\n  /// @param requestedBalance Total amount of the given asset that we need to have on balance at the end.\\r\\n  ///                         Max uint means attempt to withdraw all possible amount.\\r\\n  /// @return expectedBalance Expected asset balance after all swaps and repays\\r\\n  function makeRequestedAmount(\\r\\n    address[] memory tokens_,\\r\\n    uint indexAsset_,\\r\\n    ITetuConverter converter_,\\r\\n    ITetuLiquidator liquidator_,\\r\\n    uint requestedBalance,\\r\\n    mapping(address => uint) storage liquidationThresholds_\\r\\n  ) external returns (uint expectedBalance) {\\r\\n    DataSetLocal memory v = DataSetLocal({\\r\\n      len: tokens_.length,\\r\\n      converter: converter_,\\r\\n      tokens: tokens_,\\r\\n      indexAsset: indexAsset_,\\r\\n      liquidator: liquidator_\\r\\n    });\\r\\n    uint[] memory _liquidationThresholds = _getLiquidationThresholds(liquidationThresholds_, v.tokens, v.len);\\r\\n    expectedBalance = _closePositionsToGetAmount(v, _liquidationThresholds, requestedBalance);\\r\\n  }\\r\\n  //endregion-------------------------------------------- Make requested amount\\r\\n\\r\\n//region ------------------------------------------------ Close position\\r\\n  /// @notice Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\\r\\n  /// @dev We assume here that this function is called before closing any positions in the current block\\r\\n  /// @param liquidationThresholds Min allowed amounts-out for liquidations\\r\\n  /// @param requestedBalance Total amount of the given asset that we need to have on balance at the end.\\r\\n  ///                         Max uint means attempt to withdraw all possible amount.\\r\\n  /// @return expectedBalance Expected asset balance after all swaps and repays\\r\\n  function closePositionsToGetAmount(\\r\\n    ITetuConverter converter_,\\r\\n    ITetuLiquidator liquidator,\\r\\n    uint indexAsset,\\r\\n    mapping(address => uint) storage liquidationThresholds,\\r\\n    uint requestedBalance,\\r\\n    address[] memory tokens\\r\\n  ) external returns (\\r\\n    uint expectedBalance\\r\\n  ) {\\r\\n    uint len = tokens.length;\\r\\n    return _closePositionsToGetAmount(\\r\\n      DataSetLocal({\\r\\n        len: len,\\r\\n        converter: converter_,\\r\\n        tokens: tokens,\\r\\n        indexAsset: indexAsset,\\r\\n        liquidator: liquidator\\r\\n      }),\\r\\n      _getLiquidationThresholds(liquidationThresholds, tokens, len),\\r\\n      requestedBalance\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\\r\\n  /// @dev Implements {IterationPlanLib.PLAN_SWAP_REPAY} only\\r\\n  ///      Note: AAVE3 allows to make two repays in a single block, see Aave3SingleBlockTest in TetuConverter\\r\\n  ///      but it doesn't allow to make borrow and repay in a single block.\\r\\n  /// @param liquidationThresholds_ Min allowed amounts-out for liquidations\\r\\n  /// @param requestedBalance Total amount of the given asset that we need to have on balance at the end.\\r\\n  ///                         Max uint means attempt to withdraw all possible amount.\\r\\n  /// @return expectedBalance Expected asset balance after all swaps and repays\\r\\n  function _closePositionsToGetAmount(\\r\\n    DataSetLocal memory d_,\\r\\n    uint[] memory liquidationThresholds_,\\r\\n    uint requestedBalance\\r\\n  ) internal returns (\\r\\n    uint expectedBalance\\r\\n  ) {\\r\\n    if (requestedBalance != 0) {\\r\\n      //let's get a bit more amount on balance to prevent situation \\\"zero balance, not-zero debts\\\"\\r\\n      requestedBalance = applyRequestedBalanceGap(requestedBalance);\\r\\n      CloseDebtsForRequiredAmountLocal memory v;\\r\\n      v.asset = d_.tokens[d_.indexAsset];\\r\\n\\r\\n      // v.planKind = IterationPlanLib.PLAN_SWAP_REPAY; // PLAN_SWAP_REPAY == 0, so we don't need this line\\r\\n      v.balanceAdditions = new uint[](d_.len);\\r\\n      expectedBalance = IERC20(v.asset).balanceOf(address(this));\\r\\n\\r\\n      (v.prices, v.decs) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(d_.converter), d_.tokens, d_.len);\\r\\n\\r\\n      for (uint i; i < d_.len; i = AppLib.uncheckedInc(i)) {\\r\\n        if (i == d_.indexAsset) continue;\\r\\n\\r\\n        v.balanceAsset = IERC20(v.asset).balanceOf(address(this));\\r\\n        v.balanceToken = IERC20(d_.tokens[i]).balanceOf(address(this));\\r\\n\\r\\n        // Make one or several iterations. Do single swap and single repaying (both are optional) on each iteration.\\r\\n        // Calculate expectedAmount of received underlying. Swap leftovers at the end even if requestedAmount is 0 at that moment.\\r\\n        do {\\r\\n          // generate iteration plan: [swap], [repay]\\r\\n          (v.idxToSwap1, v.amountToSwap, v.idxToRepay1) = IterationPlanLib.buildIterationPlan(\\r\\n            [address(d_.converter), address(d_.liquidator)],\\r\\n            d_.tokens,\\r\\n            liquidationThresholds_,\\r\\n            v.prices,\\r\\n            v.decs,\\r\\n            v.balanceAdditions,\\r\\n            [0, IterationPlanLib.PLAN_SWAP_REPAY, 0, requestedBalance, d_.indexAsset, i, 0]\\r\\n          );\\r\\n          if (v.idxToSwap1 == 0 && v.idxToRepay1 == 0) break;\\r\\n\\r\\n          // make swap if necessary\\r\\n          uint spentAmountIn;\\r\\n          if (v.idxToSwap1 != 0) {\\r\\n            uint indexIn = v.idxToSwap1 - 1;\\r\\n            uint indexOut = indexIn == d_.indexAsset ? i : d_.indexAsset;\\r\\n            (spentAmountIn,) = _liquidate(\\r\\n              d_.converter,\\r\\n              d_.liquidator,\\r\\n              d_.tokens[indexIn],\\r\\n              d_.tokens[indexOut],\\r\\n              v.amountToSwap,\\r\\n              _ASSET_LIQUIDATION_SLIPPAGE,\\r\\n              liquidationThresholds_[indexIn],\\r\\n              false\\r\\n            );\\r\\n\\r\\n            if (indexIn == d_.indexAsset) {\\r\\n              expectedBalance = AppLib.sub0(expectedBalance, spentAmountIn);\\r\\n            } else if (indexOut == d_.indexAsset) {\\r\\n              expectedBalance += spentAmountIn * v.prices[i] * v.decs[d_.indexAsset] / v.prices[d_.indexAsset] / v.decs[i];\\r\\n\\r\\n              // if we already received enough amount on balance, we can avoid additional actions\\r\\n              // to avoid high gas consumption in the cases like SCB-787\\r\\n              uint balanceAsset = IERC20(v.asset).balanceOf(address(this));\\r\\n              if (balanceAsset + liquidationThresholds_[d_.indexAsset] > requestedBalance) {\\r\\n                v.balanceAsset = balanceAsset;\\r\\n                break;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n\\r\\n          // repay a debt if necessary\\r\\n          if (v.idxToRepay1 != 0) {\\r\\n            uint indexBorrow = v.idxToRepay1 - 1;\\r\\n            uint indexCollateral = indexBorrow == d_.indexAsset ? i : d_.indexAsset;\\r\\n            uint amountToRepay = IERC20(d_.tokens[indexBorrow]).balanceOf(address(this));\\r\\n\\r\\n            (uint expectedAmountOut, uint repaidAmountOut, uint amountSendToRepay) = _repayDebt(\\r\\n              d_.converter,\\r\\n              d_.tokens[indexCollateral],\\r\\n              d_.tokens[indexBorrow],\\r\\n              amountToRepay\\r\\n            );\\r\\n\\r\\n            if (indexBorrow == d_.indexAsset) {\\r\\n              expectedBalance = expectedBalance > amountSendToRepay\\r\\n                ? expectedBalance - amountSendToRepay\\r\\n                : 0;\\r\\n            } else if (indexCollateral == d_.indexAsset) {\\r\\n              require(expectedAmountOut >= spentAmountIn, AppErrors.BALANCE_DECREASE);\\r\\n              if (repaidAmountOut < amountSendToRepay) {\\r\\n                // SCB-779: expectedAmountOut was estimated for amountToRepay, but we have paid repaidAmountOut only\\r\\n                expectedBalance += expectedAmountOut * repaidAmountOut / amountSendToRepay;\\r\\n              } else {\\r\\n                expectedBalance += expectedAmountOut;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n\\r\\n          // update balances\\r\\n          v.newBalanceAsset = IERC20(v.asset).balanceOf(address(this));\\r\\n          v.newBalanceToken = IERC20(d_.tokens[i]).balanceOf(address(this));\\r\\n\\r\\n          v.exitLoop = (v.balanceAsset == v.newBalanceAsset && v.balanceToken == v.newBalanceToken);\\r\\n          v.balanceAsset = v.newBalanceAsset;\\r\\n          v.balanceToken = v.newBalanceToken;\\r\\n        } while (!v.exitLoop);\\r\\n\\r\\n        if (v.balanceAsset + liquidationThresholds_[d_.indexAsset] > requestedBalance) break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return expectedBalance;\\r\\n  }\\r\\n//endregion ------------------------------------------------ Close position\\r\\n\\r\\n//region ------------------------------------------------ Repay debts\\r\\n  /// @notice Repay {amountIn} and get collateral in return, calculate expected amount\\r\\n  ///         Take into account possible debt-gap and the fact that the amount of debt may be less than {amountIn}\\r\\n  /// @param amountToRepay Max available amount of borrow asset that we can repay\\r\\n  /// @return expectedAmountOut Estimated amount of main asset that should be added to balance = collateral - {toSell}\\r\\n  /// @return repaidAmountOut Actually paid amount\\r\\n  /// @return amountSendToRepay Amount send to repay\\r\\n  function _repayDebt(\\r\\n    ITetuConverter converter,\\r\\n    address collateralAsset,\\r\\n    address borrowAsset,\\r\\n    uint amountToRepay\\r\\n  ) internal returns (\\r\\n    uint expectedAmountOut,\\r\\n    uint repaidAmountOut,\\r\\n    uint amountSendToRepay\\r\\n  ) {\\r\\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\\r\\n\\r\\n    // get amount of debt with debt-gap\\r\\n    (uint needToRepay,) = converter.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\\r\\n    amountSendToRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\\r\\n\\r\\n    // get expected amount without debt-gap\\r\\n    uint swappedAmountOut;\\r\\n    (expectedAmountOut, swappedAmountOut) = converter.quoteRepay(address(this), collateralAsset, borrowAsset, amountSendToRepay);\\r\\n\\r\\n    if (expectedAmountOut > swappedAmountOut) {\\r\\n      // SCB-789 Following situation is possible\\r\\n      //    needToRepay = 100, needToRepayExact = 90 (debt gap is 10)\\r\\n      //    1) amountRepay = 80\\r\\n      //       expectedAmountOut is calculated for 80, no problems\\r\\n      //    2) amountRepay = 99,\\r\\n      //       expectedAmountOut is calculated for 90 + 9 (90 - repay, 9 - direct swap)\\r\\n      //       expectedAmountOut must be reduced on 9 here (!)\\r\\n      expectedAmountOut -= swappedAmountOut;\\r\\n    }\\r\\n\\r\\n    // close the debt\\r\\n    (, repaidAmountOut) = _closePositionExact(converter, collateralAsset, borrowAsset, amountSendToRepay, balanceBefore);\\r\\n\\r\\n    return (expectedAmountOut, repaidAmountOut, amountSendToRepay);\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Repay debts\\r\\n\\r\\n//region------------------------------------------------ Other helpers\\r\\n\\r\\n  /// @return liquidationThresholdsOut Liquidation thresholds of the {tokens_}, result values > 0\\r\\n  function _getLiquidationThresholds(\\r\\n    mapping(address => uint) storage liquidationThresholds,\\r\\n    address[] memory tokens_,\\r\\n    uint len\\r\\n  ) internal view returns (\\r\\n    uint[] memory liquidationThresholdsOut\\r\\n  ) {\\r\\n    liquidationThresholdsOut = new uint[](len);\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      liquidationThresholdsOut[i] = AppLib._getLiquidationThreshold(liquidationThresholds[tokens_[i]]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function applyRequestedBalanceGap(uint amount_) internal pure returns (uint) {\\r\\n    return amount_ == type(uint).max\\r\\n      ? amount_\\r\\n      : amount_ * (COMPOUND_DENOMINATOR + REQUESTED_BALANCE_GAP) / COMPOUND_DENOMINATOR;\\r\\n  }\\r\\n//endregion--------------------------------------------- Other helpers\\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0x8dd1596a48aeabdaef121d613050c7731576aece3782a3c3042b33be3be7a13e\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/ConverterStrategyBaseLib2.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV3.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IBookkeeper.sol\\\";\\r\\nimport \\\"../libs/AppErrors.sol\\\";\\r\\nimport \\\"../libs/AppLib.sol\\\";\\r\\nimport \\\"../libs/TokenAmountsLib.sol\\\";\\r\\nimport \\\"../libs/ConverterEntryKinds.sol\\\";\\r\\nimport \\\"../interfaces/IConverterStrategyBase.sol\\\";\\r\\n\\r\\n/// @notice Continuation of ConverterStrategyBaseLib (workaround for size limits)\\r\\nlibrary ConverterStrategyBaseLib2 {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n//region --------------------------------------- Data types\\r\\n  struct CalcInvestedAssetsLocal {\\r\\n    uint len;\\r\\n    uint[] debts;\\r\\n    address asset;\\r\\n    address token;\\r\\n  }\\r\\n//endregion --------------------------------------- Data types\\r\\n\\r\\n//region --------------------------------------- CONSTANTS\\r\\n  uint internal constant DENOMINATOR = 100_000;\\r\\n\\r\\n  /// @dev 0.5% of max loss for strategy TVL\\r\\n  /// @notice Same value as StrategySplitterV2.HARDWORK_LOSS_TOLERANCE\\r\\n  uint public constant HARDWORK_LOSS_TOLERANCE = 500;\\r\\n\\r\\n  /// @dev 0.5% of max profit for strategy TVL\\r\\n  /// @notice Limit max amount of profit that can be send to insurance after price changing\\r\\n  uint public constant PRICE_CHANGE_PROFIT_TOLERANCE = HARDWORK_LOSS_TOLERANCE;\\r\\n\\r\\n//endregion --------------------------------------- CONSTANTS\\r\\n\\r\\n//region----------------------------------------- EVENTS\\r\\n  event LiquidationThresholdChanged(address token, uint amount);\\r\\n  event ReinvestThresholdPercentChanged(uint amount);\\r\\n  event SendToInsurance(uint sentAmount, uint unsentAmount);\\r\\n\\r\\n  /// @notice Increase to debts between new and previous checkpoints.\\r\\n  /// @param tokens List of possible collateral/borrow assets. One of the is underlying.\\r\\n  /// @param deltaGains Amounts by which the debt has reduced (supply profit) [sync with {tokens}]\\r\\n  /// @param deltaLosses Amounts by which the debt has increased (increase of amount-to-pay) [sync with {tokens}]\\r\\n  /// @param prices Prices of the {tokens}\\r\\n  /// @param increaseToDebt Total amount of increasing of the debt to the insurance in underlying\\r\\n  event OnIncreaseDebtToInsurance(\\r\\n    address[] tokens,\\r\\n    uint[] deltaGains,\\r\\n    uint[] deltaLosses,\\r\\n    uint[] prices,\\r\\n    int increaseToDebt\\r\\n  );\\r\\n\\r\\n  /// @param debtToInsuranceBefore Value of the debt to insurance before fix price change\\r\\n  /// @param debtToInsuranceAfter New value of the debt to insurance\\r\\n  /// @param increaseToDebt Amount on which debt to insurance was increased.\\r\\n  /// Actual value {debtToInsuranceAfter}-{debtToInsuranceBefore} can be less than increaseToDebt\\r\\n  /// because some amount can be left uncovered.\\r\\n  event FixPriceChanges(\\r\\n    uint investedAssetsBefore,\\r\\n    uint investedAssetsOut,\\r\\n    int debtToInsuranceBefore,\\r\\n    int debtToInsuranceAfter,\\r\\n    int increaseToDebt\\r\\n  );\\r\\n\\r\\n  /// @param lossToCover Amount of loss that should be covered (it fits to allowed limits, no revert)\\r\\n  /// @param debtToInsuranceInc The amount by which the debt to insurance increases\\r\\n  /// @param amountCovered Actually covered amount of loss. If amountCovered < lossToCover => the insurance is not enough\\r\\n  /// @param lossUncovered Amount of uncovered losses (not enough insurance)\\r\\n  event OnCoverLoss(\\r\\n    uint lossToCover,\\r\\n    int debtToInsuranceInc,\\r\\n    uint amountCovered,\\r\\n    uint lossUncovered\\r\\n  );\\r\\n\\r\\n  /// @notice Value of {debtToInsurance} was increased on {increaseToDebt} inside fix-price-change\\r\\n  /// in the case when invested-asset amounts were increased.\\r\\n  /// @dev See comments in {_coverLossAfterPriceChanging}: actual profit-to-cover amount can be less than {increaseToDebt}\\r\\n  /// @param debtToInsuranceBefore Value of debtToInsurance before fix-price-change\\r\\n  /// @param increaseToDebt Value on which {debtToInsuranceBefore} was incremented\\r\\n  event ChangeDebtToInsuranceOnProfit(\\r\\n    int debtToInsuranceBefore,\\r\\n    int increaseToDebt\\r\\n  );\\r\\n\\r\\n  /// @notice Amount {lossCovered}+{lossUncovered} should be covered, but it's too high and will produce revert\\r\\n  /// on the splitter side. So, only {lossCovered} can be covered, {lossUncovered} are not covered\\r\\n  event UncoveredLoss(uint lossCovered, uint lossUncovered, uint investedAssetsBefore, uint investedAssetsAfter);\\r\\n\\r\\n  /// @notice Register amounts received for supplying collaterals and amount paid for the debts\\r\\n  /// @param gains Amount received by all pool adapters for the provided collateral, in underlying\\r\\n  /// @param losses Amount paid by all pool adapters for the debts, in underlying\\r\\n  event BorrowResults(uint gains, uint losses);\\r\\n\\r\\n  /// @notice An amount (earned - earnedByPrice) is earned on withdraw and sent to the insurance\\r\\n  /// @dev We assume that earned > earnedByPrice, but it's better to save raw values\\r\\n  event OnEarningOnWithdraw(uint earned, uint earnedByPrice);\\r\\n\\r\\n//endregion----------------------------------------- EVENTS\\r\\n\\r\\n//region----------------------------------------- MAIN LOGIC\\r\\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\\r\\n  function getAvailableBalances(\\r\\n    address[] memory tokens_,\\r\\n    uint indexAsset\\r\\n  ) external view returns (uint[] memory) {\\r\\n    uint len = tokens_.length;\\r\\n    uint[] memory amountsToConvert = new uint[](len);\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (i == indexAsset) continue;\\r\\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this));\\r\\n    }\\r\\n    return amountsToConvert;\\r\\n  }\\r\\n\\r\\n\\r\\n  /// @notice Calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\\r\\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\\r\\n  ///         User needs to withdraw {targetAmount_} in some asset.\\r\\n  ///         There are three kinds of available liquidity:\\r\\n  ///         1) liquidity in the pool - {depositorLiquidity_}\\r\\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\\r\\n  ///         3) Liquidity locked in the debts.\\r\\n  /// @param targetAmount Required amount of main asset to be withdrawn from the strategy; type(uint).max - withdraw all\\r\\n  /// @param quoteAmounts Results of _depositorQuoteExit(depositorLiquidity)\\r\\n  /// @return resultAmount Amount of liquidity that should be withdrawn from the pool, cannot exceed depositorLiquidity\\r\\n  function getLiquidityAmount(\\r\\n    uint targetAmount,\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset,\\r\\n    ITetuConverter converter,\\r\\n    uint[] memory quoteAmounts,\\r\\n    uint depositorLiquidity,\\r\\n    uint indexUnderlying\\r\\n  ) external view returns (\\r\\n    uint resultAmount\\r\\n  ) {\\r\\n    // total amount of assetsInPool recalculated to the underlying\\r\\n    // we need to calculate this value in the case of partial withdraw only\\r\\n    // so we assume below that it is equal to 0 if full withdraw is required\\r\\n    uint totalUnderlying;\\r\\n\\r\\n    if (targetAmount != type(uint).max) {\\r\\n      // reduce targetAmount_ on the amounts of not-underlying assets available on the balance\\r\\n      uint len = tokens.length;\\r\\n      (uint[] memory prices, uint[] memory decs) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(converter), tokens, len);\\r\\n\\r\\n      // calculate total amount of assets invested to the pool\\r\\n      for (uint i; i < tokens.length; i = AppLib.uncheckedInc(i)) {\\r\\n        totalUnderlying += (indexAsset == i)\\r\\n          ? quoteAmounts[i]\\r\\n          : quoteAmounts[i] * prices[i] * decs[indexUnderlying] / prices[indexUnderlying] / decs[i];\\r\\n      }\\r\\n\\r\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n        // assume here that the targetAmount_ is already reduced on available balance of the target asset\\r\\n        if (indexAsset == i) continue;\\r\\n\\r\\n        uint tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\\r\\n        if (tokenBalance != 0) {\\r\\n          uint tokenBalanceInAsset = tokenBalance * prices[i] * decs[indexAsset] / prices[indexAsset] / decs[i];\\r\\n\\r\\n          targetAmount = targetAmount > tokenBalanceInAsset\\r\\n            ? targetAmount - tokenBalanceInAsset\\r\\n            : 0;\\r\\n\\r\\n          uint tokenBalanceInUnderlying = indexUnderlying == indexAsset\\r\\n            ? tokenBalanceInAsset\\r\\n            : tokenBalance * prices[i] * decs[indexUnderlying] / prices[indexUnderlying] / decs[i];\\r\\n\\r\\n          totalUnderlying = totalUnderlying > tokenBalanceInUnderlying\\r\\n            ? totalUnderlying - tokenBalanceInUnderlying\\r\\n            : 0;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (indexAsset != indexUnderlying) {\\r\\n        // convert targetAmount_ to underlying\\r\\n        targetAmount =  targetAmount * prices[indexAsset] * decs[indexUnderlying] / prices[indexUnderlying] / decs[indexAsset];\\r\\n      }\\r\\n    }\\r\\n\\r\\n    uint liquidityRatioOut = totalUnderlying == 0\\r\\n      ? 1e18\\r\\n      : ((targetAmount == 0)\\r\\n        ? 0\\r\\n        : 1e18 * 101 * targetAmount / totalUnderlying / 100 // a part of amount that we are going to withdraw + 1% on top\\r\\n      );\\r\\n\\r\\n    resultAmount = liquidityRatioOut == 0\\r\\n      ? 0\\r\\n      : Math.min(liquidityRatioOut * depositorLiquidity / 1e18, depositorLiquidity);\\r\\n  }\\r\\n\\r\\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\\r\\n  /// @dev The post-processing is rewards conversion to the main asset\\r\\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\\r\\n  /// @param rewardTokens_ List of rewards claimed from the internal pool\\r\\n  /// @param rewardTokens_ Amounts of rewards claimed from the internal pool\\r\\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\\r\\n  /// @param amountsOut Amounts of available rewards\\r\\n  function claimConverterRewards(\\r\\n    ITetuConverter converter_,\\r\\n    address[] memory tokens_,\\r\\n    address[] memory rewardTokens_,\\r\\n    uint[] memory rewardAmounts_,\\r\\n    uint[] memory balancesBefore\\r\\n  ) external returns (\\r\\n    address[] memory tokensOut,\\r\\n    uint[] memory amountsOut\\r\\n  ) {\\r\\n    // Rewards from TetuConverter\\r\\n    (address[] memory tokensTC, uint[] memory amountsTC) = converter_.claimRewards(address(this));\\r\\n\\r\\n    // Join arrays and recycle tokens\\r\\n    (tokensOut, amountsOut) = TokenAmountsLib.combineArrays(\\r\\n      rewardTokens_, rewardAmounts_,\\r\\n      tokensTC, amountsTC,\\r\\n      // by default, depositor assets have zero amounts here\\r\\n      tokens_, new uint[](tokens_.length)\\r\\n    );\\r\\n\\r\\n    // set fresh balances for depositor tokens\\r\\n    uint len = tokensOut.length;\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      for (uint j; j < tokens_.length; j = AppLib.uncheckedInc(j)) {\\r\\n        if (tokensOut[i] == tokens_[j]) {\\r\\n          amountsOut[i] = IERC20(tokens_[j]).balanceOf(address(this)) - balancesBefore[j];\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // filter zero amounts out\\r\\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\\r\\n  }\\r\\n\\r\\n  /// @notice Get price of {tokenB} in term of {tokenA} with 18 decimals\\r\\n  function getOracleAssetsPrice(ITetuConverter converter, address tokenA, address tokenB) external view returns (\\r\\n    uint price\\r\\n  ) {\\r\\n    IPriceOracle oracle = AppLib._getPriceOracle(converter);\\r\\n    uint priceA = oracle.getAssetPrice(tokenA);\\r\\n    uint priceB = oracle.getAssetPrice(tokenB);\\r\\n    price = priceA > 0 ? 1e18 * priceB / priceA : type(uint).max;\\r\\n  }\\r\\n\\r\\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\\r\\n    return AppLib._getPriceOracle(converter).getAssetPrice(token);\\r\\n  }\\r\\n\\r\\n  /// @notice Try to find zero amount\\r\\n  /// @return True if {amounts_} array contains zero amount\\r\\n  function findZeroAmount(uint[] memory amounts_) internal pure returns (bool) {\\r\\n    uint len = amounts_.length;\\r\\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (amounts_[i] == 0) return true;\\r\\n    }\\r\\n    return false;\\r\\n  }\\r\\n//endregion ----------------------------------------- MAIN LOGIC\\r\\n\\r\\n//region -------------------------------------------- Cover loss, send profit to insurance\\r\\n  /// @notice Send given {amount} of {asset} (== underlying) to the insurance\\r\\n  /// @param totalAssets_ Total strategy balance = balance of underlying + current invested assets amount\\r\\n  /// @param balance Current balance of the underlying\\r\\n  /// @return sentAmount Amount of underlying sent to the insurance\\r\\n  /// @return unsentAmount Missed part of the {amount} that were not sent to the insurance\\r\\n  function sendToInsurance(address asset, uint amount, address splitter, uint totalAssets_, uint balance) external returns (\\r\\n    uint sentAmount,\\r\\n    uint unsentAmount\\r\\n  ) {\\r\\n    return _sendToInsurance(asset, amount, splitter, totalAssets_, balance);\\r\\n  }\\r\\n\\r\\n  function _sendToInsurance(address asset, uint amount, address splitter, uint totalAssets_, uint balance) internal returns (\\r\\n    uint sentAmount,\\r\\n    uint unsentAmount\\r\\n  ) {\\r\\n    uint amountToSend = Math.min(amount, balance);\\r\\n    if (amountToSend != 0) {\\r\\n      // max amount that can be send to insurance is limited by PRICE_CHANGE_PROFIT_TOLERANCE\\r\\n\\r\\n      // Amount limitation should be implemented in the same way as in StrategySplitterV2._coverLoss\\r\\n      // Revert or cut amount in both cases\\r\\n\\r\\n      require(totalAssets_ != 0, AppErrors.ZERO_BALANCE);\\r\\n      amountToSend = Math.min(amountToSend, PRICE_CHANGE_PROFIT_TOLERANCE * totalAssets_ / 100_000);\\r\\n      //require(amountToSend <= PRICE_CHANGE_PROFIT_TOLERANCE * strategyBalance / 100_000, AppErrors.EARNED_AMOUNT_TOO_HIGH);\\r\\n\\r\\n      IERC20(asset).safeTransfer(address(ITetuVaultV2(ISplitter(splitter).vault()).insurance()), amountToSend);\\r\\n    }\\r\\n\\r\\n    sentAmount = amountToSend;\\r\\n    unsentAmount = amount > amountToSend\\r\\n      ? amount - amountToSend\\r\\n      : 0;\\r\\n\\r\\n    emit SendToInsurance(sentAmount, unsentAmount);\\r\\n  }\\r\\n\\r\\n  function _registerIncome(uint assetBefore, uint assetAfter) internal pure returns (uint earned, uint lost) {\\r\\n    if (assetAfter > assetBefore) {\\r\\n      earned = assetAfter - assetBefore;\\r\\n    } else {\\r\\n      lost = assetBefore - assetAfter;\\r\\n    }\\r\\n    return (earned, lost);\\r\\n  }\\r\\n\\r\\n  /// @notice Send ProfitToCover to insurance - code fragment of the requirePayAmountBack()\\r\\n  ///         moved here to reduce size of requirePayAmountBack()\\r\\n  /// @param theAsset_ The asset passed from Converter\\r\\n  /// @param balanceTheAsset_ Current balance of {theAsset_}\\r\\n  /// @param investedAssets_ Value of investedAssets after call fixPriceChange()\\r\\n  /// @param earnedByPrices_ ProfitToCover received from fixPriceChange()\\r\\n  /// @return balanceTheAssetOut Final balance of {theAsset_} (after sending profit-to-cover to the insurance)\\r\\n  function sendProfitGetAssetBalance(\\r\\n    address theAsset_,\\r\\n    uint balanceTheAsset_,\\r\\n    uint investedAssets_,\\r\\n    uint earnedByPrices_,\\r\\n    IStrategyV3.BaseState storage baseState_\\r\\n  ) external returns (\\r\\n    uint balanceTheAssetOut\\r\\n  ) {\\r\\n    balanceTheAssetOut = balanceTheAsset_;\\r\\n    if (earnedByPrices_ != 0) {\\r\\n      address underlying = baseState_.asset;\\r\\n      uint balanceUnderlying = theAsset_ == underlying\\r\\n        ? balanceTheAsset_\\r\\n        : AppLib.balance(underlying);\\r\\n\\r\\n      _sendToInsurance(underlying, earnedByPrices_, baseState_.splitter, investedAssets_ + balanceUnderlying, balanceUnderlying);\\r\\n\\r\\n      if (theAsset_ == underlying) {\\r\\n        balanceTheAssetOut = AppLib.balance(theAsset_);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n//endregion -------------------------------------------- Cover loss, send profit to insurance\\r\\n\\r\\n//region ---------------------------------------- Setters\\r\\n  function checkReinvestThresholdPercentChanged(address controller, uint percent_) external {\\r\\n    StrategyLib.onlyOperators(controller);\\r\\n    require(percent_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\\r\\n    emit ReinvestThresholdPercentChanged(percent_);\\r\\n  }\\r\\n\\r\\n  function checkLiquidationThresholdChanged(address controller, address token, uint amount) external {\\r\\n    StrategyLib.onlyOperators(controller);\\r\\n    emit LiquidationThresholdChanged(token, amount);\\r\\n  }\\r\\n//endregion ---------------------------------------- Setters\\r\\n\\r\\n//region ---------------------------------------- Withdraw helpers\\r\\n  /// @notice Get amount of assets that we expect to receive after withdrawing\\r\\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\\r\\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\\r\\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\\r\\n  ///                  one of assets must be {asset_}\\r\\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\\r\\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\\r\\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\\r\\n  function getExpectedWithdrawnAmounts(\\r\\n    uint[] memory reserves_,\\r\\n    uint liquidityAmount_,\\r\\n    uint totalSupply_\\r\\n  ) internal pure returns (\\r\\n    uint[] memory withdrawnAmountsOut\\r\\n  ) {\\r\\n    uint ratio = totalSupply_ == 0\\r\\n      ? 0\\r\\n      : (liquidityAmount_ >= totalSupply_\\r\\n        ? 1e18\\r\\n        : 1e18 * liquidityAmount_ / totalSupply_\\r\\n      );\\r\\n\\r\\n    uint len = reserves_.length;\\r\\n    withdrawnAmountsOut = new uint[](len);\\r\\n\\r\\n    if (ratio != 0) {\\r\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate expected amount of the main asset after withdrawing\\r\\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\\r\\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\\r\\n  /// @return amountsOut Expected amounts of the main asset received after conversion withdrawnAmounts+amountsToConvert\\r\\n  function getExpectedAmountMainAsset(\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset,\\r\\n    ITetuConverter converter,\\r\\n    uint[] memory withdrawnAmounts_,\\r\\n    uint[] memory amountsToConvert_\\r\\n  ) internal returns (\\r\\n    uint[] memory amountsOut\\r\\n  ) {\\r\\n    uint len = tokens.length;\\r\\n    amountsOut = new uint[](len);\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (i == indexAsset) {\\r\\n        amountsOut[i] = withdrawnAmounts_[i];\\r\\n      } else {\\r\\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\\r\\n        if (amount != 0) {\\r\\n          (amountsOut[i],) = converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return amountsOut;\\r\\n  }\\r\\n\\r\\n  /// @notice Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\\r\\n  /// @param amountsToConvert Amounts of {tokens} to be converted, they are located on the balance before withdraw\\r\\n  /// @param withdrawnAmounts Amounts of {tokens} that were withdrew from the pool\\r\\n  function postWithdrawActions(\\r\\n    ITetuConverter converter,\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset,\\r\\n\\r\\n    uint[] memory reservesBeforeWithdraw,\\r\\n    uint liquidityAmountWithdrew,\\r\\n    uint totalSupplyBeforeWithdraw,\\r\\n\\r\\n    uint[] memory amountsToConvert,\\r\\n    uint[] memory withdrawnAmounts\\r\\n  ) external returns (\\r\\n    uint[] memory expectedMainAssetAmounts,\\r\\n    uint[] memory _amountsToConvert\\r\\n  ) {\\r\\n    // estimate expected amount of assets to be withdrawn\\r\\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\\r\\n      reservesBeforeWithdraw,\\r\\n      liquidityAmountWithdrew,\\r\\n      totalSupplyBeforeWithdraw\\r\\n    );\\r\\n\\r\\n    // from received amounts after withdraw calculate how much we receive from converter for them in terms of the underlying asset\\r\\n    expectedMainAssetAmounts = getExpectedAmountMainAsset(\\r\\n      tokens,\\r\\n      indexAsset,\\r\\n      converter,\\r\\n      expectedWithdrawAmounts,\\r\\n      amountsToConvert\\r\\n    );\\r\\n\\r\\n    uint len = tokens.length;\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      amountsToConvert[i] += withdrawnAmounts[i];\\r\\n    }\\r\\n\\r\\n    return (expectedMainAssetAmounts, amountsToConvert);\\r\\n  }\\r\\n\\r\\n  /// @notice return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\\r\\n  function postWithdrawActionsEmpty(\\r\\n    ITetuConverter converter,\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset,\\r\\n    uint[] memory amountsToConvert_\\r\\n  ) external returns (\\r\\n    uint[] memory expectedAmountsMainAsset\\r\\n  ) {\\r\\n    expectedAmountsMainAsset = getExpectedAmountMainAsset(\\r\\n      tokens,\\r\\n      indexAsset,\\r\\n      converter,\\r\\n      // there are no withdrawn amounts\\r\\n      new uint[](tokens.length), // array with all zero values\\r\\n      amountsToConvert_\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate amount earned after withdraw. Withdraw cannot produce income, so we send all\\r\\n  ///         earned amount to insurance. Also we send to the insurance earned-by-prices-amount here.\\r\\n  /// @dev Amount for the insurance is sent from the balance, so the sending doesn't change invested assets.\\r\\n  /// @param asset Underlying\\r\\n  /// @param investedAssets_ Invested assets amount at the moment of withdrawing start\\r\\n  /// @param balanceBefore Balance of the underlying at the moment of withdrawing start\\r\\n  /// @param earnedByPrices_ Amount of underlying earned because of price changes, it should be send to the insurance.\\r\\n  /// @param updatedInvestedAssets_ Invested assets amount after withdrawing\\r\\n  /// @return amountSentToInsurance Total amount sent to the insurance in result.\\r\\n  function calculateIncomeAfterWithdraw(\\r\\n    address splitter,\\r\\n    address asset,\\r\\n    uint investedAssets_,\\r\\n    uint balanceBefore,\\r\\n    uint earnedByPrices_,\\r\\n    uint updatedInvestedAssets_\\r\\n  ) external returns (uint amountSentToInsurance, uint strategyLoss) {\\r\\n    uint balanceAfterWithdraw = AppLib.balance(asset);\\r\\n\\r\\n    // we need to compensate difference if during withdraw we lost some assets\\r\\n    // also we should send earned amounts to the insurance\\r\\n    // it's too dangerous to earn money on withdraw, we can move share price\\r\\n    // in the case of \\\"withdraw almost all\\\" share price can be changed significantly\\r\\n    // so, it's safer to transfer earned amount to the insurance\\r\\n    // earned can exceeds earnedByPrices_\\r\\n    // but if earned < earnedByPrices_ it means that we compensate a part of losses from earned-by-prices.\\r\\n    uint earned;\\r\\n    (earned, strategyLoss) = _registerIncome(\\r\\n      AppLib.sub0(investedAssets_ + balanceBefore, earnedByPrices_),\\r\\n      updatedInvestedAssets_ + balanceAfterWithdraw\\r\\n    );\\r\\n\\r\\n    if (earned != earnedByPrices_) {\\r\\n      emit OnEarningOnWithdraw(earned, earnedByPrices_);\\r\\n    }\\r\\n\\r\\n    if (earned != 0) {\\r\\n      (amountSentToInsurance,) = _sendToInsurance(\\r\\n        asset,\\r\\n        earned,\\r\\n        splitter,\\r\\n        investedAssets_ + balanceBefore,\\r\\n        balanceAfterWithdraw\\r\\n      );\\r\\n    }\\r\\n\\r\\n    return (amountSentToInsurance, strategyLoss);\\r\\n  }\\r\\n//endregion ------------------------------------- Withdraw helpers\\r\\n\\r\\n//region---------------------------------------- calcInvestedAssets\\r\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\r\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\r\\n  /// @param indexAsset Index of the underlying (main asset) in {tokens}\\r\\n  /// @param makeCheckpoint_ True - call IBookkeeper.checkpoint in the converter\\r\\n  /// @return amountOut Invested asset amount under control (in terms of underlying)\\r\\n  /// @return prices Asset prices in USD, decimals 18\\r\\n  /// @return decs 10**decimals\\r\\n  function calcInvestedAssets(\\r\\n    address[] memory tokens,\\r\\n    uint[] memory depositorQuoteExitAmountsOut,\\r\\n    uint indexAsset,\\r\\n    ITetuConverter converter_,\\r\\n    bool makeCheckpoint_\\r\\n  ) external returns (\\r\\n    uint amountOut,\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs\\r\\n  ) {\\r\\n    return _calcInvestedAssets(tokens, depositorQuoteExitAmountsOut, indexAsset, converter_, makeCheckpoint_);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\r\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\r\\n  /// @param indexAsset Index of the underlying (main asset) in {tokens}\\r\\n  /// @param makeCheckpoint_ True - call IBookkeeper.checkpoint in the converter\\r\\n  /// @return amountOut Invested asset amount under control (in terms of underlying)\\r\\n  /// @return prices Asset prices in USD, decimals 18\\r\\n  /// @return decs 10**decimals\\r\\n  function _calcInvestedAssets(\\r\\n    address[] memory tokens,\\r\\n    uint[] memory depositorQuoteExitAmountsOut,\\r\\n    uint indexAsset,\\r\\n    ITetuConverter converter_,\\r\\n    bool makeCheckpoint_\\r\\n  ) internal returns (\\r\\n    uint amountOut,\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs\\r\\n  ) {\\r\\n    CalcInvestedAssetsLocal memory v;\\r\\n    v.len = tokens.length;\\r\\n    v.asset = tokens[indexAsset];\\r\\n\\r\\n    // calculate prices, decimals\\r\\n    (prices, decs) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(converter_), tokens, v.len);\\r\\n\\r\\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\\r\\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\\r\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (i == indexAsset) {\\r\\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\\r\\n        amountOut += depositorQuoteExitAmountsOut[i];\\r\\n      } else {\\r\\n        v.token = tokens[i];\\r\\n        // possible reverse debt: collateralAsset = tokens[i], borrowAsset = underlying\\r\\n        // investedAssets is calculated using exact debts, debt-gaps are not taken into account\\r\\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(address(this), v.token, v.asset, false);\\r\\n        if (amountOut < toPay) {\\r\\n          setDebt(v, indexAsset, toPay);\\r\\n        } else {\\r\\n          amountOut -= toPay;\\r\\n        }\\r\\n\\r\\n        // available amount to repay\\r\\n        uint toRepay = collateral + IERC20(v.token).balanceOf(address(this)) + depositorQuoteExitAmountsOut[i];\\r\\n\\r\\n        // direct debt: collateralAsset = underlying, borrowAsset = tokens[i]\\r\\n        // investedAssets is calculated using exact debts, debt-gaps are not taken into account\\r\\n        (toPay, collateral) = converter_.getDebtAmountCurrent(address(this), v.asset, v.token, false);\\r\\n        amountOut += collateral;\\r\\n\\r\\n        if (toRepay >= toPay) {\\r\\n          amountOut += (toRepay - toPay) * prices[i] * decs[indexAsset] / prices[indexAsset] / decs[i];\\r\\n        } else {\\r\\n          // there is not enough amount to pay the debt\\r\\n          // let's register a debt and try to resolve it later below\\r\\n          setDebt(v, i, toPay - toRepay);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    if (v.debts.length == v.len) {\\r\\n      // we assume here, that it would be always profitable to save collateral\\r\\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\\r\\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\\r\\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\r\\n        if (v.debts[i] == 0) continue;\\r\\n\\r\\n        // estimatedAssets should be reduced on the debt-value\\r\\n        // this estimation is approx and do not count price impact on the liquidation\\r\\n        // we will able to count the real output only after withdraw process\\r\\n        uint debtInAsset = v.debts[i] * prices[i] * decs[indexAsset] / prices[indexAsset] / decs[i];\\r\\n        if (debtInAsset > amountOut) {\\r\\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\\r\\n          amountOut = 0;\\r\\n        } else {\\r\\n          amountOut -= debtInAsset;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (makeCheckpoint_) {\\r\\n      _callCheckpoint(tokens, converter_);\\r\\n    }\\r\\n\\r\\n    return (amountOut, prices, decs);\\r\\n  }\\r\\n\\r\\n  /// @notice Make new checkpoint in converter's bookkeeper\\r\\n  /// As results, a next call of checkpoint will return amount of increases to debts (\\\"deltas\\\")\\r\\n  /// since current moment up to the moment of the next call (we need such deltas in _fixPriceChanges only)\\r\\n  function _callCheckpoint(address[] memory tokens, ITetuConverter converter_) internal returns (\\r\\n    uint[] memory deltaGains,\\r\\n    uint[] memory deltaLosses\\r\\n  ) {\\r\\n    IBookkeeper a = IBookkeeper(IConverterController(converter_.controller()).bookkeeper());\\r\\n    return a.checkpoint(tokens);\\r\\n  }\\r\\n\\r\\n  /// @notice Lazy initialization of v.debts, add {value} to {v.debts[index]}\\r\\n  function setDebt(CalcInvestedAssetsLocal memory v, uint index, uint value) pure internal {\\r\\n    if (v.debts.length == 0) {\\r\\n      // lazy initialization\\r\\n      v.debts = new uint[](v.len);\\r\\n    }\\r\\n\\r\\n    // to pay the following amount we need to swap some other asset at first\\r\\n    v.debts[index] += value;\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate the token amounts for deposit and amount of loss (as old-total-asset - new-total-asset)\\r\\n  /// @param liquidationThresholdsAB [liquidityThreshold of token A, liquidityThreshold of tokenB]\\r\\n  /// @return loss New total assets - old total assets\\r\\n  /// @return tokenAmounts Balances of the token A and token B.\\r\\n  ///                     If any balance is zero it's not possible to enter to the pool, so return empty array (len 0)\\r\\n  function getTokenAmountsPair(\\r\\n    ITetuConverter converter,\\r\\n    uint totalAssets,\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint[2] calldata liquidationThresholdsAB\\r\\n  ) external returns (\\r\\n    uint loss,\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    tokenAmounts = new uint[](2);\\r\\n    tokenAmounts[0] = AppLib.balance(tokenA);\\r\\n    tokenAmounts[1] = AppLib.balance(tokenB);\\r\\n\\r\\n    address[] memory tokens = new address[](2);\\r\\n    tokens[0] = tokenA;\\r\\n    tokens[1] = tokenB;\\r\\n\\r\\n    uint[] memory amounts = new uint[](2);\\r\\n    amounts[0] = tokenAmounts[0];\\r\\n\\r\\n    (uint newTotalAssets,,) = _calcInvestedAssets(tokens, amounts, 0, converter, true);\\r\\n    return (\\r\\n      newTotalAssets < totalAssets\\r\\n        ? totalAssets - newTotalAssets\\r\\n        : 0,\\r\\n      (tokenAmounts[0] < liquidationThresholdsAB[0] || tokenAmounts[1] < liquidationThresholdsAB[1])\\r\\n        ? new uint[](0)\\r\\n        : tokenAmounts\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Swap can give us more amount out than expected, so we will receive increasing of share price.\\r\\n  ///         To prevent it, we need to send exceeded amount to insurance,\\r\\n  ///         but it's too expensive to make such transfer at the end of withdrawAggByStep.\\r\\n  ///         So, we postpone sending the profit until the next call of fixPriceChange\\r\\n  ///         by manually setting investedAssets equal to the oldTotalAssets\\r\\n  /// @dev If profitToCover was sent only partly, we will postpone sending of remain amount up to the next call\\r\\n  ///      of fixPriceChange in same manner\\r\\n  /// @param oldTotalAssets Total asset at the moment after last call of fixPriceChange,\\r\\n  ///                       decreased on the value of profitToCover.\\r\\n  function fixTooHighInvestedAssets(\\r\\n    address asset_,\\r\\n    uint oldTotalAssets,\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs_\\r\\n  ) external {\\r\\n    uint balance = IERC20(asset_).balanceOf(address(this));\\r\\n    uint newTotalAssets = csbs_.investedAssets + balance;\\r\\n\\r\\n    if (oldTotalAssets < newTotalAssets) {\\r\\n      // total asset was increased (i.e. because of too profitable swaps)\\r\\n      // this increment will increase share price\\r\\n      // we should send added amount to insurance to avoid share price change\\r\\n      // anyway, it's too expensive to do it here\\r\\n      // so, we postpone sending the profit until the next call of fixPriceChange\\r\\n      if (oldTotalAssets > balance) {\\r\\n        csbs_.investedAssets = oldTotalAssets - balance;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n//endregion------------------------------------- calcInvestedAssets\\r\\n\\r\\n//region ------------------------------------------------------- Bookkeeper logic\\r\\n  /// @notice Make checkpoint (it's writable function) and calculate total cost of the deltas in terms of the {asset}\\r\\n  /// @param tokens Full list of tokens that can be used as collateral/borrow asset by the current strategy\\r\\n  /// @param indexAsset Index of the underlying in {tokens}\\r\\n  /// @return increaseToDebt Total increase-to-debt since previous checkpoint [in underlying]\\r\\n  function _getIncreaseToDebt(\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset,\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs,\\r\\n    ITetuConverter converter\\r\\n  ) internal returns (\\r\\n    int increaseToDebt\\r\\n  ) {\\r\\n    IBookkeeper a = IBookkeeper(IConverterController(converter.controller()).bookkeeper());\\r\\n    (uint[] memory deltaGains, uint[] memory deltaLosses) = a.checkpoint(tokens);\\r\\n\\r\\n    uint len = tokens.length;\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (i == indexAsset) {\\r\\n        increaseToDebt -= int(deltaGains[i]);\\r\\n        increaseToDebt += int(deltaLosses[i]);\\r\\n      } else {\\r\\n        increaseToDebt += (int(deltaLosses[i]) - int(deltaGains[i]))\\r\\n          * int(prices[i]) * int(decs[indexAsset]) / int(prices[indexAsset]) / int(decs[i]);\\r\\n      }\\r\\n    }\\r\\n    emit OnIncreaseDebtToInsurance(tokens, deltaGains, deltaLosses, prices, increaseToDebt);\\r\\n\\r\\n    return increaseToDebt;\\r\\n  }\\r\\n\\r\\n  /// @notice Register income and cover possible loss after price changing, emit FixPriceChanges\\r\\n  /// @param investedAssetsBefore Currently stored value of _csbs.investedAssets\\r\\n  /// @param investedAssetsAfter Actual value of invested assets calculated at the current moment\\r\\n  /// @param increaseToDebt The amount by which the total loan debts increased for the selected period\\r\\n  /// @return earned Amount earned because of price changing\\r\\n  function _coverLossAfterPriceChanging(\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    uint investedAssetsBefore,\\r\\n    uint investedAssetsAfter,\\r\\n    int increaseToDebt,\\r\\n    IStrategyV3.BaseState storage baseState\\r\\n  ) internal returns (uint earned) {\\r\\n    int debtToInsurance0 = csbs.debtToInsurance;\\r\\n    if (investedAssetsAfter > investedAssetsBefore) {\\r\\n      earned = investedAssetsAfter - investedAssetsBefore;\\r\\n      if (increaseToDebt != 0) {\\r\\n        // Earned amount will be send to the insurance later.\\r\\n        // Probably it can be reduced by same limitations as {lost} amount below\\r\\n        // and so, it will be necessary to decrease increaseToDebt proportionally.\\r\\n        // For simplicity, we increase debtToInsurance on full increaseToDebt always\\r\\n        // in assumption, that such profits are always low.\\r\\n        csbs.debtToInsurance += increaseToDebt;\\r\\n        emit ChangeDebtToInsuranceOnProfit(debtToInsurance0, increaseToDebt);\\r\\n      }\\r\\n    } else {\\r\\n      uint lost = investedAssetsBefore - investedAssetsAfter;\\r\\n      if (lost != 0) {\\r\\n        uint totalAsset = investedAssetsAfter + IERC20(baseState.asset).balanceOf(address(this));\\r\\n        (uint lossToCover, uint lossUncovered) = _getSafeLossToCover(lost, totalAsset);\\r\\n\\r\\n        if (lossUncovered != 0) {\\r\\n          // we need to cover lost-amount, but this amount is too high and will produce revert in the splitter\\r\\n          // so, we will cover only part of {lost} and leave other part uncovered.\\r\\n          emit UncoveredLoss(lossToCover, lossUncovered, investedAssetsBefore, investedAssetsAfter);\\r\\n        }\\r\\n\\r\\n        // if we compensate lost only partially, we reduce both amounts \\\"from prices\\\" and \\\"from debts\\\" proportionally\\r\\n        _coverLossAndCheckResults(csbs, baseState.splitter, lossToCover, increaseToDebt * int(lossToCover) / int(lost));\\r\\n\\r\\n      }\\r\\n    }\\r\\n\\r\\n    emit FixPriceChanges(\\r\\n      investedAssetsBefore,\\r\\n      investedAssetsAfter,\\r\\n      debtToInsurance0,\\r\\n      csbs.debtToInsurance,\\r\\n      increaseToDebt\\r\\n    );\\r\\n    return earned;\\r\\n  }\\r\\n\\r\\n  /// @notice Call coverPossibleStrategyLoss, covered loss will be sent to vault.\\r\\n  ///         If the loss were covered only partially, emit {NotEnoughInsurance}\\r\\n  function coverLossAndCheckResults(\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    address splitter,\\r\\n    uint lossToCover\\r\\n  ) external {\\r\\n    _coverLossAndCheckResults(csbs, splitter, lossToCover, int(lossToCover));\\r\\n  }\\r\\n\\r\\n  /// @notice Call coverPossibleStrategyLoss, covered loss will be sent to vault.\\r\\n  function _coverLossAndCheckResults(\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    address splitter,\\r\\n    uint lossToCover,\\r\\n    int debtToInsuranceInc\\r\\n  ) internal {\\r\\n    address asset = ISplitter(splitter).asset();\\r\\n    address vault = ISplitter(splitter).vault();\\r\\n\\r\\n    uint balanceBefore = IERC20(asset).balanceOf(vault);\\r\\n    ISplitter(splitter).coverPossibleStrategyLoss(0, lossToCover);\\r\\n    uint balanceAfter = IERC20(asset).balanceOf(vault);\\r\\n\\r\\n    uint delta = AppLib.sub0(balanceAfter, balanceBefore);\\r\\n    uint uncovered = AppLib.sub0(lossToCover, delta);\\r\\n    debtToInsuranceInc = lossToCover == 0\\r\\n      ? int(0)\\r\\n      : debtToInsuranceInc * int(lossToCover - uncovered) / int(lossToCover);\\r\\n\\r\\n    if (debtToInsuranceInc != 0) {\\r\\n      csbs.debtToInsurance += debtToInsuranceInc;\\r\\n    }\\r\\n\\r\\n    // we don't add uncovered amount to the debts to the insurance\\r\\n    emit OnCoverLoss(lossToCover, debtToInsuranceInc, delta, uncovered);\\r\\n  }\\r\\n\\r\\n  /// @notice Cut loss-value to safe value that doesn't produce revert inside splitter\\r\\n  function _getSafeLossToCover(uint loss, uint totalAssets_) internal pure returns (\\r\\n    uint lossToCover,\\r\\n    uint lossUncovered\\r\\n  ) {\\r\\n    // see StrategySplitterV2._declareStrategyIncomeAndCoverLoss, _coverLoss implementations\\r\\n    lossToCover = Math.min(loss, ConverterStrategyBaseLib2.HARDWORK_LOSS_TOLERANCE * totalAssets_ / 100_000);\\r\\n    lossUncovered = AppLib.sub0(loss, lossToCover);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate profit/loss happened because of price changing.\\r\\n  /// Try to cover the loss, send the profit to the insurance.\\r\\n  /// Increment debt to insurance on amount of increase of the debts.\\r\\n  /// @param amountsInPool Amount of tokens that can be received from the pool after withdrawing all liquidity.\\r\\n  /// The order of tokens is same as in the {tokens}\\r\\n  /// @param tokens Result of {_depositorPoolAssets}\\r\\n  /// @param indexAsset Index of the underlying in {tokens}\\r\\n  /// @return investedAssetsOut Updated value of {csbs.investedAssets}\\r\\n  /// @return earnedOut Profit that was received because of price changes. It should be sent back to insurance.\\r\\n  function fixPriceChanges(\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    IStrategyV3.BaseState storage baseState,\\r\\n    uint[] memory amountsInPool,\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset\\r\\n  ) external returns (\\r\\n    uint investedAssetsOut,\\r\\n    uint earnedOut\\r\\n  ) {\\r\\n    ITetuConverter converter = csbs.converter;\\r\\n    uint investedAssetsBefore = csbs.investedAssets;\\r\\n\\r\\n    uint[] memory prices;\\r\\n    uint[] memory decs;\\r\\n\\r\\n    (investedAssetsOut, prices, decs) = _calcInvestedAssets(tokens, amountsInPool, indexAsset, converter, false);\\r\\n    csbs.investedAssets = investedAssetsOut;\\r\\n\\r\\n    int increaseToDebt = _getIncreaseToDebt(tokens, indexAsset, prices, decs, converter);\\r\\n    earnedOut = _coverLossAfterPriceChanging(csbs, investedAssetsBefore, investedAssetsOut, increaseToDebt, baseState);\\r\\n  }\\r\\n\\r\\n  /// @notice Register amounts received for supplying collaterals and amount paid for the debts\\r\\n  ///         for the current period (a new period is started after each hardwork operation)\\r\\n  function registerBorrowResults(ITetuConverter converter, address asset) external {\\r\\n    IBookkeeper a = IBookkeeper(IConverterController(converter.controller()).bookkeeper());\\r\\n    (uint gains, uint losses) = a.startPeriod(asset);\\r\\n    if (gains != 0 && losses != 0) {\\r\\n      emit BorrowResults(gains, losses);\\r\\n    }\\r\\n  }\\r\\n//endregion ------------------------------------------------------- Bookkeeper logic\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0xbf108a509285156685b75ae591c421fc9b514e6011fd95f30ec4bfa13dd9f1d5\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/pair/PairBasedStrategyLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\r\\nimport \\\"../ConverterStrategyBaseLib.sol\\\";\\r\\nimport \\\"../../interfaces/IPoolProportionsProvider.sol\\\";\\r\\nimport \\\"../../libs/BorrowLib.sol\\\";\\r\\n\\r\\n/// @notice Library for the UniV3-like strategies with two tokens in the pool\\r\\n/// @dev The library contains quoteWithdrawStep/withdrawStep-related logic\\r\\nlibrary PairBasedStrategyLib {\\r\\n  //region ------------------------------------------------ Constants\\r\\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\\r\\n  /// @notice In all functions below array {token} contains underlying at the first position\\r\\n  uint internal constant IDX_ASSET = 0;\\r\\n  /// @notice In all functions below array {token} contains not-underlying at the second position\\r\\n  uint internal constant IDX_TOKEN = 1;\\r\\n\\r\\n  uint internal constant IDX_SWAP_1 = 0;\\r\\n  uint internal constant IDX_REPAY_1 = 1;\\r\\n  uint internal constant IDX_SWAP_2 = 2;\\r\\n  uint internal constant IDX_REPAY_2 = 3;\\r\\n\\r\\n  /// @notice A gap to reduce AmountToSwap calculated inside quoteWithdrawByAgg, [0...100_000]\\r\\n  uint public constant GAP_AMOUNT_TO_SWAP = 100;\\r\\n\\r\\n  /// @notice Enter to the pool at the end of withdrawByAggStep\\r\\n  uint public constant ENTRY_TO_POOL_IS_ALLOWED = 1;\\r\\n  /// @notice Enter to the pool at the end of withdrawByAggStep only if full withdrawing has been completed\\r\\n  uint public constant ENTRY_TO_POOL_IS_ALLOWED_IF_COMPLETED = 2;\\r\\n\\r\\n  /// @notice Fuse thresholds are set as array: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\\r\\n  ///         If the price falls below LOWER_LIMIT_ON the fuse is turned ON\\r\\n  ///         When the prices raises back and reaches LOWER_LIMIT_OFF, the fuse is turned OFF\\r\\n  ///         In the same way, if the price raises above UPPER_LIMIT_ON the fuse is turned ON\\r\\n  ///         When the prices falls back and reaches UPPER_LIMIT_OFF, the fuse is turned OFF\\r\\n  ///\\r\\n  ///         Example: [0.9, 0.92, 1.08, 1.1]\\r\\n  ///         Price falls below 0.9 - fuse is ON. Price rises back up to 0.92 - fuse is OFF.\\r\\n  ///         Price raises more and reaches 1.1 - fuse is ON again. Price falls back and reaches 1.08 - fuse OFF again.\\r\\n  uint public constant FUSE_IDX_LOWER_LIMIT_ON = 0;\\r\\n  uint public constant FUSE_IDX_LOWER_LIMIT_OFF = 1;\\r\\n  uint public constant FUSE_IDX_UPPER_LIMIT_ON = 2;\\r\\n  uint public constant FUSE_IDX_UPPER_LIMIT_OFF = 3;\\r\\n\\r\\n  uint public constant IDX_ADDR_DEFAULT_STATE_TOKEN_A = 0;\\r\\n  uint public constant IDX_ADDR_DEFAULT_STATE_TOKEN_B = 1;\\r\\n  uint public constant IDX_ADDR_DEFAULT_STATE_POOL = 2;\\r\\n  uint public constant IDX_ADDR_DEFAULT_STATE_PROFIT_HOLDER = 3;\\r\\n\\r\\n  uint public constant IDX_TICK_DEFAULT_STATE_TICK_SPACING = 0;\\r\\n  uint public constant IDX_TICK_DEFAULT_STATE_LOWER_TICK = 1;\\r\\n  uint public constant IDX_TICK_DEFAULT_STATE_UPPER_TICK = 2;\\r\\n  uint public constant IDX_TICK_DEFAULT_STATE_REBALANCE_TICK_RANGE = 3;\\r\\n\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_TOTAL_LIQUIDITY = 0;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_FUSE_STATUS = 1;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_RESERVED_0 = 2;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_WITHDRAW_DONE = 3;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_0 = 4;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_1 = 5;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_2 = 6;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_3 = 7;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_RESERVED_1 = 8;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_RESERVED_2 = 9;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_RESERVED_3 = 10;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_RESERVED_4 = 11;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_LAST_REBALANCE_NO_SWAP = 12;\\r\\n\\r\\n  uint public constant IDX_BOOL_VALUES_DEFAULT_STATE_IS_STABLE_POOL = 0;\\r\\n  uint public constant IDX_BOOL_VALUES_DEFAULT_STATE_DEPOSITOR_SWAP_TOKENS = 1;\\r\\n\\r\\n  /// @notice 1inch router V5 (Polygon, Base)\\r\\n  address internal constant ONEINCH = 0x1111111254EEB25477B68fb85Ed929f73A960582;\\r\\n  /// @notice OpenOceanExchangeProxy (Polygon and many other chains)\\r\\n  /// @dev See https://docs.openocean.finance/dev/contracts-of-chains\\r\\n  address internal constant OPENOCEAN = 0x6352a56caadC4F1E25CD6c75970Fa768A3304e64;\\r\\n  /// @notice OpenOceanExchangeProxy (zkEVM)\\r\\n  /// @dev See https://docs.openocean.finance/dev/contracts-of-chains\\r\\n  address internal constant OPENOCEAN_ZKEVM = 0x6dd434082EAB5Cd134B33719ec1FF05fE985B97b;\\r\\n\\r\\n  string public constant UNKNOWN_SWAP_ROUTER = \\\"PBS-1 Unknown router\\\";\\r\\n  string public constant INCORRECT_TICK_RANGE = \\\"PBS-3 Incorrect tickRange\\\";\\r\\n  string public constant INCORRECT_REBALANCE_TICK_RANGE = \\\"PBS-4 Incorrect rebalanceTickRange\\\";\\r\\n  string public constant INCORRECT_ASSET = \\\"PBS-5 Incorrect asset\\\";\\r\\n\\r\\n  //endregion ------------------------------------------------ Constants\\r\\n\\r\\n  //region ------------------------------------------------ Data types\\r\\n  /// @notice The fuse is triggered when the price rises above or falls below the limit 1.\\r\\n  ///         If the fuse was triggered, all assets are withdrawn from the pool on the strategy balance.\\r\\n  ///         Then all debts should be closed and all assets should be converted to underlying.\\r\\n  ///         The fuse is turned off automatically when the price falls below or rises above the limit 2\\r\\n  ///         and all assets are deposited back to the pool.\\r\\n  enum FuseStatus {\\r\\n    /// @notice Fuse is not used at all\\r\\n    FUSE_DISABLED_0,\\r\\n    /// @notice Fuse is not triggered, assets are deposited to the pool\\r\\n    FUSE_OFF_1,\\r\\n    /// @notice Fuse was triggered by lower limit, assets was withdrawn from the pool, but active debts can exist\\r\\n    FUSE_ON_LOWER_LIMIT_2,\\r\\n    /// @notice Fuse was triggered by upper limit, assets was withdrawn from the pool, but active debts can exist\\r\\n    FUSE_ON_UPPER_LIMIT_3\\r\\n  }\\r\\n\\r\\n  struct SwapByAggParams {\\r\\n    bool useLiquidator;\\r\\n    address tokenToSwap;\\r\\n    /// @notice Aggregator to make swap\\r\\n    ///         It is 0 if useLiquidator is true\\r\\n    ///         It can be equal to address of liquidator if we use liquidator as aggregator (in tests)\\r\\n    address aggregator;\\r\\n    uint amountToSwap;\\r\\n    /// @notice Swap-data prepared off-chain (route, amounts, etc). 0 - use liquidator to make swap\\r\\n    bytes swapData;\\r\\n  }\\r\\n\\r\\n  struct GetAmountToRepay2Local {\\r\\n    uint x;\\r\\n    uint y;\\r\\n    uint c0;\\r\\n    uint b0;\\r\\n    uint alpha;\\r\\n    int b;\\r\\n  }\\r\\n\\r\\n  struct FuseStateParams {\\r\\n    FuseStatus status;\\r\\n    /// @notice Price thresholds [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\\r\\n    /// @dev see PairBasedStrategyLib.FUSE_IDX_XXX\\r\\n    uint[4] thresholds;\\r\\n\\r\\n    /// @notice reserve space for future needs\\r\\n    uint[4] __gap;\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Data types\\r\\n\\r\\n  //region ------------------------------------------------ Events\\r\\n  event FuseStatusChanged(uint fuseStatus);\\r\\n  event NewFuseThresholds(uint[4] newFuseThresholds);\\r\\n  event SwapByAgg(\\r\\n    uint amountToSwap,\\r\\n    uint amountIn,\\r\\n    uint amountOut,\\r\\n    uint expectedAmountOut,\\r\\n    address aggregator,\\r\\n    address assetIn,\\r\\n    address assetOut\\r\\n  );\\r\\n  //endregion ------------------------------------------------ Events\\r\\n\\r\\n  //region ------------------------------------------------ External withdraw functions\\r\\n\\r\\n  /// @notice Get info for the swap that will be made on the next call of {withdrawStep}\\r\\n  /// @param converterLiquidator_ [TetuConverter, TetuLiquidator]\\r\\n  /// @param tokens Tokens used by depositor (length == 2: underlying and not-underlying)\\r\\n  /// @param liquidationThresholds Liquidation thresholds for the {tokens}\\r\\n  /// @param entryDataValues [propNotUnderlying18, entryDataParam]\\r\\n  ///     propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n  ///                           The leftovers should be swapped to get following result proportions of the assets:\\r\\n  ///                           not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\r\\n  ///                            Value type(uint).max means that the proportions should be read from the pool.\\r\\n  ///     entryDataParam It contains \\\"required-amount-to-reduce-debt\\\" in REPAY-SWAP-REPAY case\\r\\n  /// @param amountsFromPool Amounts of {tokens} that will be received from the pool before calling withdraw\\r\\n  /// @return tokenToSwap Address of the token that will be swapped on the next swap. 0 - no swap\\r\\n  /// @return amountToSwap Amount that will be swapped on the next swap. 0 - no swap\\r\\n  ///                      This amount is NOT reduced on {GAP_AMOUNT_TO_SWAP}, it should be reduced after the call if necessary.\\r\\n  function quoteWithdrawStep(\\r\\n    address[2] memory converterLiquidator_,\\r\\n    address[] memory tokens,\\r\\n    uint[] memory liquidationThresholds,\\r\\n    uint[] memory amountsFromPool,\\r\\n    uint planKind,\\r\\n    uint[2] memory entryDataValues\\r\\n  ) external returns (\\r\\n    address tokenToSwap,\\r\\n    uint amountToSwap\\r\\n  ){\\r\\n    (uint[] memory prices,\\r\\n      uint[] memory decs\\r\\n    ) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(ITetuConverter(converterLiquidator_[0])), tokens, 2);\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p = IterationPlanLib.SwapRepayPlanParams({\\r\\n      converter: ITetuConverter(converterLiquidator_[0]),\\r\\n      liquidator: ITetuLiquidator(converterLiquidator_[1]),\\r\\n      tokens: tokens,\\r\\n      liquidationThresholds: liquidationThresholds,\\r\\n      propNotUnderlying18: entryDataValues[0] == type(uint).max\\r\\n        ? IPoolProportionsProvider(address(this)).getPropNotUnderlying18()\\r\\n        : entryDataValues[0],\\r\\n      prices: prices,\\r\\n      decs: decs,\\r\\n      balanceAdditions: amountsFromPool,\\r\\n      planKind: planKind,\\r\\n      usePoolProportions: entryDataValues[0] == type(uint).max,\\r\\n      entryDataParam: entryDataValues[1]\\r\\n    });\\r\\n    return _quoteWithdrawStep(p);\\r\\n  }\\r\\n\\r\\n  /// @notice Make withdraw step with 0 or 1 swap only. The step can make one of the following actions:\\r\\n  ///         1) repay direct debt 2) repay reverse debt 3) final swap leftovers of not-underlying asset\\r\\n  /// @param converterLiquidator_ [TetuConverter, TetuLiquidator]\\r\\n  /// @param tokens Tokens used by depositor (length == 2: underlying and not-underlying)\\r\\n  /// @param liquidationThresholds Liquidation thresholds for the {tokens}\\r\\n  /// @param tokenToSwap_ Address of the token that will be swapped on the next swap. 0 - no swap\\r\\n  /// @param amountToSwap_ Amount that will be swapped on the next swap. 0 - no swap\\r\\n  /// @param aggregator_ Aggregator that should be used for the next swap. 0 - no swap\\r\\n  /// @param swapData_ Swap data to be passed to the aggregator on the next swap.\\r\\n  ///                  Swap data contains swap-route, amount and all other required info for the swap.\\r\\n  ///                  Swap data should be prepared on-chain on the base of data received by {quoteWithdrawStep}\\r\\n  /// @param useLiquidator_ Use liquidator instead of aggregator.\\r\\n  ///                       Aggregator swaps amount reduced on {GAP_AMOUNT_TO_SWAP}.\\r\\n  ///                       Liquidator doesn't use {GAP_AMOUNT_TO_SWAP}.\\r\\n  ///                       It's allowed to pass liquidator address in {aggregator_} and set {useLiquidator_} to false -\\r\\n  ///                       the liquidator will be used in same way as aggregator in this case.\\r\\n  /// @param planKind One of IterationPlanLib.PLAN_XXX\\r\\n  /// @param entryDataValues [propNotUnderlying18, entryDataParam]\\r\\n  ///     propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n  ///                           The leftovers should be swapped to get following result proportions of the assets:\\r\\n  ///                           not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\r\\n  ///     entryDataParam It contains \\\"required-amount-to-reduce-debt\\\" in REPAY-SWAP-REPAY case\\r\\n  /// @return completed All debts were closed, leftovers were swapped to the required proportions\\r\\n  function withdrawStep(\\r\\n    address[2] memory converterLiquidator_,\\r\\n    address[] memory tokens,\\r\\n    uint[] memory liquidationThresholds,\\r\\n    address tokenToSwap_,\\r\\n    uint amountToSwap_,\\r\\n    address aggregator_,\\r\\n    bytes memory swapData_,\\r\\n    bool useLiquidator_,\\r\\n    uint planKind,\\r\\n    uint[2] memory entryDataValues\\r\\n  ) external returns (\\r\\n    bool completed\\r\\n  ){\\r\\n    (uint[] memory prices,\\r\\n      uint[] memory decs\\r\\n    ) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(ITetuConverter(converterLiquidator_[0])), tokens, 2);\\r\\n\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p = IterationPlanLib.SwapRepayPlanParams({\\r\\n      converter: ITetuConverter(converterLiquidator_[0]),\\r\\n      liquidator: ITetuLiquidator(converterLiquidator_[1]),\\r\\n      tokens: tokens,\\r\\n      liquidationThresholds: liquidationThresholds,\\r\\n      propNotUnderlying18: entryDataValues[0] == type(uint).max\\r\\n        ? IPoolProportionsProvider(address(this)).getPropNotUnderlying18()\\r\\n        : entryDataValues[0],\\r\\n      prices: prices,\\r\\n      decs: decs,\\r\\n      balanceAdditions: new uint[](2), // 2 = tokens.length\\r\\n      planKind: planKind,\\r\\n      usePoolProportions: entryDataValues[0] == type(uint).max,\\r\\n      entryDataParam: entryDataValues[1]\\r\\n    });\\r\\n    SwapByAggParams memory aggParams = SwapByAggParams({\\r\\n      tokenToSwap: tokenToSwap_,\\r\\n      amountToSwap: amountToSwap_,\\r\\n      useLiquidator: useLiquidator_,\\r\\n      aggregator: aggregator_,\\r\\n      swapData: swapData_\\r\\n    });\\r\\n    return _withdrawStep(p, aggParams);\\r\\n  }\\r\\n  //endregion ------------------------------------------------ External withdraw functions\\r\\n\\r\\n  //region ------------------------------------------------ Fuse functions\\r\\n  function setFuseStatus(FuseStateParams storage fuse, FuseStatus status) external {\\r\\n    fuse.status = status;\\r\\n    emit FuseStatusChanged(uint(status));\\r\\n  }\\r\\n\\r\\n  function setFuseThresholds(FuseStateParams storage state, uint[4] memory values) external {\\r\\n    require(\\r\\n      (values[FUSE_IDX_LOWER_LIMIT_ON] == 0 && values[FUSE_IDX_LOWER_LIMIT_OFF] == 0)\\r\\n      || (values[FUSE_IDX_LOWER_LIMIT_ON] <= values[FUSE_IDX_LOWER_LIMIT_OFF]),\\r\\n      AppErrors.INVALID_VALUE\\r\\n    );\\r\\n    require(\\r\\n      (values[FUSE_IDX_UPPER_LIMIT_ON] == 0 && values[FUSE_IDX_UPPER_LIMIT_OFF] == 0)\\r\\n      || (values[FUSE_IDX_UPPER_LIMIT_ON] >= values[FUSE_IDX_UPPER_LIMIT_OFF]),\\r\\n      AppErrors.INVALID_VALUE\\r\\n    );\\r\\n    if (values[FUSE_IDX_LOWER_LIMIT_ON] != 0 && values[FUSE_IDX_UPPER_LIMIT_ON] != 0) {\\r\\n      require(\\r\\n        values[FUSE_IDX_UPPER_LIMIT_ON] > values[FUSE_IDX_LOWER_LIMIT_ON],\\r\\n        AppErrors.INVALID_VALUE\\r\\n      );\\r\\n    }\\r\\n    state.thresholds = values;\\r\\n    emit NewFuseThresholds(values);\\r\\n  }\\r\\n\\r\\n  function isFuseTriggeredOn(PairBasedStrategyLib.FuseStatus fuseStatus) internal pure returns (bool) {\\r\\n    return uint(fuseStatus) > uint(PairBasedStrategyLib.FuseStatus.FUSE_OFF_1);\\r\\n  }\\r\\n\\r\\n  /// @notice Check if the fuse should be turned ON/OFF\\r\\n  /// @param price Current price in the oracle\\r\\n  /// @param poolPrice Current price in the pool\\r\\n  /// @return needToChange A boolean indicating if the fuse status should be changed\\r\\n  /// @return status Exist fuse status or new fuse status (if needToChange is true)\\r\\n  function needChangeFuseStatus(FuseStateParams memory fuse, uint price, uint poolPrice) internal pure returns (\\r\\n    bool needToChange,\\r\\n    FuseStatus status\\r\\n  ) {\\r\\n    if (fuse.status != FuseStatus.FUSE_DISABLED_0) {\\r\\n      if (fuse.status == FuseStatus.FUSE_OFF_1) {\\r\\n        // currently fuse is OFF\\r\\n        if (price <= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_ON] || poolPrice <= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_ON]) {\\r\\n          needToChange = true;\\r\\n          status = FuseStatus.FUSE_ON_LOWER_LIMIT_2;\\r\\n        } else if (price >= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_ON] || poolPrice >= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_ON]) {\\r\\n          needToChange = true;\\r\\n          status = FuseStatus.FUSE_ON_UPPER_LIMIT_3;\\r\\n        }\\r\\n      } else {\\r\\n        if (fuse.status == FuseStatus.FUSE_ON_LOWER_LIMIT_2) {\\r\\n          // currently fuse is triggered ON by lower limit\\r\\n          if (price >= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_OFF] && poolPrice >= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_OFF]) {\\r\\n            needToChange = true;\\r\\n            if (price >= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_ON] || poolPrice >= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_ON]) {\\r\\n              status = FuseStatus.FUSE_ON_UPPER_LIMIT_3;\\r\\n            } else {\\r\\n              status = FuseStatus.FUSE_OFF_1;\\r\\n            }\\r\\n          }\\r\\n        } else {\\r\\n          // currently fuse is triggered ON by upper limit\\r\\n          if (price <= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_OFF] && poolPrice <= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_OFF]) {\\r\\n            needToChange = true;\\r\\n            if (price <= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_OFF] || poolPrice <= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_OFF]) {\\r\\n              status = FuseStatus.FUSE_ON_LOWER_LIMIT_2;\\r\\n            } else {\\r\\n              status = FuseStatus.FUSE_OFF_1;\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return (needToChange, needToChange ? status : fuse.status);\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Fuse functions\\r\\n\\r\\n  //region ------------------------------------------------ Internal helper functions\\r\\n  /// @notice Quote amount of the next swap if any.\\r\\n  ///         Swaps are required if direct-borrow exists OR reverse-borrow exists or not underlying leftovers exist\\r\\n  ///         Function returns info for first swap only.\\r\\n  /// @return tokenToSwap What token should be swapped. Zero address if no swap is required\\r\\n  /// @return amountToSwap Amount to swap. Zero if no swap is required.\\r\\n  function _quoteWithdrawStep(IterationPlanLib.SwapRepayPlanParams memory p) internal returns (\\r\\n    address tokenToSwap,\\r\\n    uint amountToSwap\\r\\n  ) {\\r\\n    uint indexTokenToSwapPlus1;\\r\\n    (indexTokenToSwapPlus1, amountToSwap,) = IterationPlanLib.buildIterationPlan(\\r\\n      [address(p.converter), address(p.liquidator)],\\r\\n      p.tokens,\\r\\n      p.liquidationThresholds,\\r\\n      p.prices,\\r\\n      p.decs,\\r\\n      p.balanceAdditions,\\r\\n      [\\r\\n        p.usePoolProportions ? 1 : 0,\\r\\n        p.planKind,\\r\\n        p.propNotUnderlying18,\\r\\n        type(uint).max,\\r\\n        IDX_ASSET,\\r\\n        IDX_TOKEN,\\r\\n        p.entryDataParam\\r\\n      ]\\r\\n    );\\r\\n    if (indexTokenToSwapPlus1 != 0) {\\r\\n      tokenToSwap = p.tokens[indexTokenToSwapPlus1 - 1];\\r\\n    }\\r\\n    return (tokenToSwap, amountToSwap);\\r\\n  }\\r\\n\\r\\n  /// @notice Make one iteration of withdraw. Each iteration can make 0 or 1 swap only\\r\\n  ///         We can make only 1 of the following 3 operations per single call:\\r\\n  ///         1) repay direct debt 2) repay reverse debt 3) swap leftovers to underlying\\r\\n  function _withdrawStep(IterationPlanLib.SwapRepayPlanParams memory p, SwapByAggParams memory aggParams) internal returns (\\r\\n    bool completed\\r\\n  ) {\\r\\n    (uint idxToSwap1, uint amountToSwap, uint idxToRepay1) = IterationPlanLib.buildIterationPlan(\\r\\n      [address(p.converter), address(p.liquidator)],\\r\\n      p.tokens,\\r\\n      p.liquidationThresholds,\\r\\n      p.prices,\\r\\n      p.decs,\\r\\n      p.balanceAdditions,\\r\\n      [\\r\\n        p.usePoolProportions ? 1 : 0,\\r\\n        p.planKind,\\r\\n        p.propNotUnderlying18,\\r\\n        type(uint).max,\\r\\n        IDX_ASSET,\\r\\n        IDX_TOKEN,\\r\\n        p.entryDataParam\\r\\n      ]\\r\\n    );\\r\\n\\r\\n    bool[4] memory actions = [\\r\\n      p.planKind == IterationPlanLib.PLAN_SWAP_ONLY || p.planKind == IterationPlanLib.PLAN_SWAP_REPAY, // swap 1\\r\\n      p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY || p.planKind == IterationPlanLib.PLAN_SWAP_REPAY, // repay 1\\r\\n      p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY, // swap 2\\r\\n      p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY // repay 2\\r\\n      ];\\r\\n\\r\\n    if (idxToSwap1 != 0 && actions[IDX_SWAP_1]) {\\r\\n      (, p.propNotUnderlying18) = _swap(p, aggParams, idxToSwap1 - 1, idxToSwap1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, amountToSwap);\\r\\n    }\\r\\n\\r\\n    if (idxToRepay1 != 0 && actions[IDX_REPAY_1]) {\\r\\n      ConverterStrategyBaseLib._repayDebt(\\r\\n        p.converter,\\r\\n        p.tokens[idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET],\\r\\n        p.tokens[idxToRepay1 - 1],\\r\\n        IERC20(p.tokens[idxToRepay1 - 1]).balanceOf(address(this))\\r\\n      );\\r\\n    }\\r\\n\\r\\n    if (idxToSwap1 != 0) {\\r\\n      if (actions[IDX_SWAP_2]) {\\r\\n        (, p.propNotUnderlying18) = _swap(p, aggParams, idxToSwap1 - 1, idxToSwap1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, amountToSwap);\\r\\n\\r\\n        if (actions[IDX_REPAY_2] && idxToRepay1 != 0) {\\r\\n          // see calculations inside estimateSwapAmountForRepaySwapRepay\\r\\n          // There are two possibilities here:\\r\\n          // 1) All collateral asset available on balance was swapped. We need additional repay to get assets in right proportions\\r\\n          // 2) Only part of collateral asset was swapped, so assets are already in right proportions. Repay 2 is not needed\\r\\n          (uint amountToRepay2, bool borrowInsteadRepay) = _getAmountToRepay2(\\r\\n            p,\\r\\n            idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET,\\r\\n            idxToRepay1 - 1\\r\\n          );\\r\\n\\r\\n          if (borrowInsteadRepay) {\\r\\n            _borrowToProportions(p, idxToRepay1 - 1, idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, true);\\r\\n\\r\\n          } else if (amountToRepay2 > p.liquidationThresholds[idxToRepay1 - 1]) {\\r\\n            _secondRepay(p, idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, idxToRepay1 - 1, amountToRepay2, type(uint).max);\\r\\n          }\\r\\n        }\\r\\n      } else {\\r\\n        // leftovers were swapped, there are no debts anymore\\r\\n        // the swap can change pool proportions, so probably it's necessary to make additional borrow here\\r\\n        if (\\r\\n          idxToRepay1 == 0 // there are no debts anymore\\r\\n          && p.usePoolProportions  // we use proportions from the pool\\r\\n          && p.propNotUnderlying18 != 0 && p.propNotUnderlying18 != 1e18 // BorrowLib doesn't allow prop=0\\r\\n        ) {\\r\\n          _fixLeftoversProportions(p);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Withdraw is completed on last iteration (no debts, swapping leftovers)\\r\\n    return idxToRepay1 == 0;\\r\\n  }\\r\\n\\r\\n  /// @notice Make final repay in the scheme REPAY-SWAP-REPAY\\r\\n  ///         Depending on condition the final repay can be made several times or additional borrow can be made\\r\\n  /// @param amountToRepay Amount of {indexBorrow} asset that should be repaid\\r\\n  /// @param needToRepayPrev Amount-to-repay on previous call of the {_secondRepay}\\r\\n  ///                        This amount should decrease on each step of recursion.\\r\\n  ///                        if it doesn't decrease repay is not successfull and it's useless to continue to call repays\\r\\n  ///                        It can happen if liquidationThreshold has incorrect value (i.t. it's too low or zero)\\r\\n  function _secondRepay(\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrow,\\r\\n    uint amountToRepay,\\r\\n    uint needToRepayPrev\\r\\n  ) internal {\\r\\n    // we need to know repaidAmount\\r\\n    // we cannot relay on the value returned by _repayDebt because of SCB-710, we need to check balances\\r\\n    uint balanceBefore = IERC20(p.tokens[indexBorrow]).balanceOf(address(this));\\r\\n    ConverterStrategyBaseLib._repayDebt(p.converter, p.tokens[indexCollateral], p.tokens[indexBorrow], amountToRepay);\\r\\n    uint balanceAfter = IERC20(p.tokens[indexBorrow]).balanceOf(address(this));\\r\\n\\r\\n    uint repaidAmount = balanceBefore > balanceAfter\\r\\n      ? balanceBefore - balanceAfter\\r\\n      : 0;\\r\\n\\r\\n    if (repaidAmount < amountToRepay && amountToRepay - repaidAmount > p.liquidationThresholds[indexBorrow]) {\\r\\n      // repaidAmount is less than expected\\r\\n      // we need to make additional borrow OR probably make one more repay\\r\\n      // repaidAmount can be less amountToRepay2 even if there is still opened debt, see SCB-777\\r\\n      (uint needToRepay,) = p.converter.getDebtAmountStored(address(this), p.tokens[indexCollateral], p.tokens[indexBorrow], true);\\r\\n      if (\\r\\n        needToRepay > p.liquidationThresholds[indexBorrow]\\r\\n        && needToRepay < needToRepayPrev // amount of debt was reduced on prev iteration of recursion\\r\\n      ) {\\r\\n        // more repays are required\\r\\n        _secondRepay(p, indexCollateral, indexBorrow, amountToRepay - repaidAmount, needToRepay);\\r\\n      } else {\\r\\n        _borrowToProportions(p, indexBorrow, indexCollateral, false);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Set balances to right proportions using borrow\\r\\n  ///         (it can be necessary if propNotUnderlying18 was changed after swap)\\r\\n  function _fixLeftoversProportions(IterationPlanLib.SwapRepayPlanParams memory p) internal {\\r\\n    uint balanceAsset = IERC20(p.tokens[IDX_ASSET]).balanceOf(address(this));\\r\\n    uint balanceToken = IERC20(p.tokens[IDX_TOKEN]).balanceOf(address(this));\\r\\n    (uint targetAssets,\\r\\n      uint targetTokens\\r\\n    ) = IterationPlanLib._getTargetAmounts(p.prices, p.decs, balanceAsset, balanceToken, p.propNotUnderlying18, IDX_ASSET, IDX_TOKEN);\\r\\n\\r\\n    if (balanceAsset > targetAssets) {\\r\\n      if (balanceAsset - targetAssets > p.liquidationThresholds[IDX_ASSET]) {\\r\\n        _borrowToProportions(p, IDX_ASSET, IDX_TOKEN, balanceAsset, balanceToken, true);\\r\\n      }\\r\\n    } else if (balanceToken > targetTokens) {\\r\\n      if (balanceToken - targetTokens > p.liquidationThresholds[IDX_ASSET]) {\\r\\n        _borrowToProportions(p, IDX_TOKEN, IDX_ASSET, balanceToken, balanceAsset, true);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice borrow borrow-asset under collateral-asset, result balances should match to propNotUnderlying18\\r\\n  function _borrowToProportions(\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrow,\\r\\n    bool checkOppositDebtDoesntExist\\r\\n  ) internal {\\r\\n    _borrowToProportions(\\r\\n      p,\\r\\n      indexCollateral,\\r\\n      indexBorrow,\\r\\n      IERC20(p.tokens[indexCollateral]).balanceOf(address(this)),\\r\\n      IERC20(p.tokens[indexBorrow]).balanceOf(address(this)),\\r\\n      checkOppositDebtDoesntExist\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice borrow borrow-asset under collateral-asset, result balances should match to propNotUnderlying18\\r\\n  function _borrowToProportions(\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrow,\\r\\n    uint balanceCollateral,\\r\\n    uint balanceBorrow,\\r\\n    bool checkOppositDebtDoesntExist\\r\\n  ) internal {\\r\\n    // we are going to change direction of the borrow\\r\\n    // let's ensure that there is no debt in opposite direction\\r\\n    if (checkOppositDebtDoesntExist) {\\r\\n      (uint needToRepay,) = p.converter.getDebtAmountStored(address(this), p.tokens[indexBorrow], p.tokens[indexCollateral], false);\\r\\n      require(needToRepay < AppLib.DUST_AMOUNT_TOKENS, AppErrors.OPPOSITE_DEBT_EXISTS);\\r\\n    }\\r\\n\\r\\n    BorrowLib.RebalanceAssetsCore memory cac = BorrowLib.RebalanceAssetsCore({\\r\\n      converterLiquidator: BorrowLib.ConverterLiquidator(p.converter, p.liquidator),\\r\\n      assetA: p.tokens[indexCollateral],\\r\\n      assetB: p.tokens[indexBorrow],\\r\\n      propA: indexCollateral == IDX_ASSET ? 1e18 - p.propNotUnderlying18 : p.propNotUnderlying18,\\r\\n      propB: indexCollateral == IDX_ASSET ? p.propNotUnderlying18 : 1e18 - p.propNotUnderlying18,\\r\\n    // {assetA} to {assetB} ratio; {amountB} * {alpha} => {amountA}, decimals 18\\r\\n      alpha18: 1e18 * p.prices[indexBorrow] * p.decs[indexCollateral] / p.prices[indexCollateral] / p.decs[indexBorrow],\\r\\n      thresholdA: p.liquidationThresholds[indexCollateral],\\r\\n      addonA: 0,\\r\\n      addonB: 0,\\r\\n      indexA: indexCollateral,\\r\\n      indexB: indexBorrow\\r\\n    });\\r\\n\\r\\n    BorrowLib.openPosition(\\r\\n      cac,\\r\\n      BorrowLib.PricesDecs({\\r\\n        prices: p.prices,\\r\\n        decs: p.decs\\r\\n      }),\\r\\n      balanceCollateral,\\r\\n      balanceBorrow\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate amount that should be repaid to get right proportions of assets on balance\\r\\n  ///         Analyse only single borrow-direction: indexCollateral => indexBorrow\\r\\n  /// @return amountToRepay Amount that should be repaid\\r\\n  /// @return borrowInsteadRepay true if repay is not necessary at all and borrow is required instead\\r\\n  ///                            if we need both repay and borrow then false is returned\\r\\n  function _getAmountToRepay2(\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrow\\r\\n  ) internal view returns (\\r\\n    uint amountToRepay,\\r\\n    bool borrowInsteadRepay\\r\\n  ) {\\r\\n    GetAmountToRepay2Local memory v;\\r\\n    v.c0 = IERC20(p.tokens[indexCollateral]).balanceOf(address(this)) * p.prices[indexCollateral] / p.decs[indexCollateral];\\r\\n    v.b0 = IERC20(p.tokens[indexBorrow]).balanceOf(address(this)) * p.prices[indexBorrow] / p.decs[indexBorrow];\\r\\n\\r\\n    v.x = indexCollateral == IDX_ASSET ? 1e18 - p.propNotUnderlying18 : p.propNotUnderlying18;\\r\\n    v.y = indexCollateral == IDX_ASSET ? p.propNotUnderlying18 : 1e18 - p.propNotUnderlying18;\\r\\n    v.alpha = p.prices[indexCollateral] * p.decs[indexBorrow] * 1e18 / p.prices[indexBorrow] / p.decs[indexCollateral];\\r\\n\\r\\n    (uint needToRepay, uint collateralAmountOut) = p.converter.getDebtAmountStored(\\r\\n      address(this),\\r\\n      p.tokens[indexCollateral],\\r\\n      p.tokens[indexBorrow],\\r\\n      true\\r\\n    );\\r\\n\\r\\n    if (needToRepay == 0) {\\r\\n      // check if we need to make reverse borrow to fit to proportions: borrow collateral-asset under borrow-asset\\r\\n      uint targetCollateral = (v.c0 + v.b0) * v.x / (v.x + v.y);\\r\\n      borrowInsteadRepay = targetCollateral > v.c0\\r\\n        && targetCollateral - v.c0\\r\\n        > (p.liquidationThresholds[indexCollateral] * p.prices[indexCollateral] / p.decs[indexCollateral]);\\r\\n    } else {\\r\\n      // initial balances: c0, b0\\r\\n      // we are going to repay amount b and receive (betta * b, b), where betta ~ alpha * totalCollateral / totalBorrow\\r\\n      // we should have x/y = (c0 + betta * b) / (b0 - b)\\r\\n      // so b = (x * b0 - y * c0) / (betta * y + x)\\r\\n      v.b = (int(v.x * v.b0) - int(v.y * v.c0)) / (int(v.y * v.alpha * collateralAmountOut / needToRepay / 1e18) + int(v.x));\\r\\n      if (v.b > 0) {\\r\\n        amountToRepay = uint(v.b);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return (amountToRepay * p.decs[indexBorrow] / p.prices[indexBorrow], borrowInsteadRepay);\\r\\n  }\\r\\n\\r\\n  /// @notice Swap {aggParams.amountToSwap} using either liquidator or aggregator\\r\\n  /// @dev You can use liquidator as aggregator, so aggregator's logic will be used for the liquidator\\r\\n  /// @param amountIn Calculated amount to be swapped. It can be different from {aggParams.amountToSwap} a bit,\\r\\n  ///                 but aggregators require exact value {aggParams.amountToSwap}, so amountIn is not used with agg.\\r\\n  function _swap(\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\r\\n    SwapByAggParams memory aggParams,\\r\\n    uint indexIn,\\r\\n    uint indexOut,\\r\\n    uint amountIn\\r\\n  ) internal returns (\\r\\n    uint spentAmountIn,\\r\\n    uint updatedPropNotUnderlying18\\r\\n  ) {\\r\\n    // liquidator and aggregator have different logic here:\\r\\n    // - liquidator uses amountIn to swap\\r\\n    // - Aggregator uses amountToSwap for which a route was built off-chain before the call of the swap()\\r\\n    // It's allowed to use aggregator == liquidator, so in this way liquidator will use aggregator's logic (for tests)\\r\\n\\r\\n    if (!aggParams.useLiquidator) {\\r\\n      // aggregator requires exact input amount - aggParams.amountToSwap\\r\\n      // actual amount can be a bit different because the quote function was called in different block\\r\\n      amountIn = aggParams.amountToSwap;\\r\\n    }\\r\\n    address aggregator = aggParams.useLiquidator\\r\\n      ? address(p.liquidator)\\r\\n      : aggParams.aggregator;\\r\\n\\r\\n    require(amountIn <= IERC20(p.tokens[indexIn]).balanceOf(address(this)), AppErrors.NOT_ENOUGH_BALANCE);\\r\\n    // let's ensure that \\\"next swap\\\" is made using correct token\\r\\n    require(aggParams.tokenToSwap == p.tokens[indexIn], AppErrors.INCORRECT_SWAP_BY_AGG_PARAM);\\r\\n\\r\\n    if (amountIn > p.liquidationThresholds[indexIn]) {\\r\\n      AppLib.approveIfNeeded(p.tokens[indexIn], amountIn, aggregator);\\r\\n\\r\\n      uint balanceTokenOutBefore = AppLib.balance(p.tokens[indexOut]);\\r\\n\\r\\n      if (aggParams.useLiquidator) {\\r\\n\\r\\n        (spentAmountIn,) = ConverterStrategyBaseLib._liquidate(\\r\\n          p.converter,\\r\\n          ITetuLiquidator(aggregator),\\r\\n          p.tokens[indexIn],\\r\\n          p.tokens[indexOut],\\r\\n          amountIn,\\r\\n          _ASSET_LIQUIDATION_SLIPPAGE,\\r\\n          p.liquidationThresholds[indexIn],\\r\\n          true\\r\\n        );\\r\\n      } else {\\r\\n        if (aggregator != address(p.liquidator)) {\\r\\n          _checkSwapRouter(aggregator);\\r\\n        }\\r\\n\\r\\n        (bool success, bytes memory result) = aggregator.call(aggParams.swapData);\\r\\n        require(success, string(result));\\r\\n\\r\\n        spentAmountIn = amountIn;\\r\\n      }\\r\\n\\r\\n      require(\\r\\n        p.converter.isConversionValid(\\r\\n          p.tokens[indexIn],\\r\\n          amountIn,\\r\\n          p.tokens[indexOut],\\r\\n          AppLib.balance(p.tokens[indexOut]) - balanceTokenOutBefore,\\r\\n          _ASSET_LIQUIDATION_SLIPPAGE\\r\\n        ), AppErrors.PRICE_IMPACT);\\r\\n\\r\\n      emit SwapByAgg(\\r\\n        aggParams.amountToSwap,\\r\\n        amountIn,\\r\\n        AppLib.balance(p.tokens[indexOut]) - balanceTokenOutBefore,\\r\\n        amountIn * p.prices[indexIn] * p.decs[indexOut] / p.prices[indexOut] / p.decs[indexIn],\\r\\n        aggregator,\\r\\n        p.tokens[indexIn],\\r\\n        p.tokens[indexOut]\\r\\n      );\\r\\n    }\\r\\n\\r\\n    return (\\r\\n      spentAmountIn,\\r\\n    // p.propNotUnderlying18 contains original proportions that were valid before the swap\\r\\n    // after swap() we need to re-read new values from the pool\\r\\n      p.usePoolProportions\\r\\n        ? IPoolProportionsProvider(address(this)).getPropNotUnderlying18()\\r\\n        : p.propNotUnderlying18\\r\\n    );\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Internal helper functions\\r\\n\\r\\n  //region ----------------------------------------- Utils\\r\\n  function getPoolPriceAdjustment(uint poolPriceDecimals) external pure returns (uint adjustment) {\\r\\n    // we assume that decimals never higher than 18\\r\\n    adjustment = poolPriceDecimals < 18 ? 10 ** (18 - poolPriceDecimals) : 1;\\r\\n  }\\r\\n\\r\\n  function _checkSwapRouter(address router) internal pure {\\r\\n    require(router == ONEINCH || router == OPENOCEAN || router == OPENOCEAN_ZKEVM, UNKNOWN_SWAP_ROUTER);\\r\\n  }\\r\\n\\r\\n  /// @notice Extract propNotUnderlying18 from {planEntryData} of the given {planKind}\\r\\n  function _extractProp(uint planKind, bytes memory planEntryData) internal pure returns (\\r\\n    uint propNotUnderlying18,\\r\\n    uint entryDataParamValue\\r\\n  ) {\\r\\n    if (planKind == IterationPlanLib.PLAN_SWAP_REPAY || planKind == IterationPlanLib.PLAN_SWAP_ONLY) {\\r\\n      (, propNotUnderlying18) = abi.decode(planEntryData, (uint, uint));\\r\\n      require(propNotUnderlying18 <= 1e18 || propNotUnderlying18 == type(uint).max, AppErrors.INVALID_VALUE); // 0 is allowed\\r\\n    } else {\\r\\n      require(planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY, AppErrors.WRONG_VALUE);\\r\\n      // save \\\"required-amount-to-reduce-debt\\\" to entryDataParamValue\\r\\n      (, propNotUnderlying18, entryDataParamValue) = abi.decode(planEntryData, (uint, uint, uint));\\r\\n      require(propNotUnderlying18 <= 1e18 || propNotUnderlying18 == type(uint).max, AppErrors.INVALID_VALUE); // 0 is allowed\\r\\n    }\\r\\n    return (propNotUnderlying18, entryDataParamValue);\\r\\n  }\\r\\n  //endregion ------------------------------------------ Utils\\r\\n}\\r\\n\",\"keccak256\":\"0x5bdbb11c9584ac19547eed43ef3ffa0e8f33f728fd4019f5948b5853c51d570a\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/pair/PairBasedStrategyLogicLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"../ConverterStrategyBaseLib.sol\\\";\\r\\nimport \\\"./PairBasedStrategyLib.sol\\\";\\r\\nimport \\\"../ConverterStrategyBaseLib2.sol\\\";\\r\\n\\r\\n/// @notice Library for the UniV3-like strategies with two tokens in the pool\\r\\nlibrary PairBasedStrategyLogicLib {\\r\\n  //region ------------------------------------------------------- Data types\\r\\n  /// @notice Local variables required inside withdrawByAggStep and quoteWithdrawByAgg\\r\\n  struct WithdrawLocal {\\r\\n    /// @notice [underlying, not-underlying]\\r\\n    address[] tokens;\\r\\n    address controller;\\r\\n    /// @notice liquidationThresholds for the {tokens}, greater or equal to {DEFAULT_LIQUIDATION_THRESHOLD}\\r\\n    uint[] liquidationThresholds;\\r\\n    uint planKind;\\r\\n    uint propNotUnderlying18;\\r\\n    uint entryDataParam;\\r\\n  }\\r\\n\\r\\n  /// @notice Common part of all XXXXConverterStrategyLogicLib.State\\r\\n  struct PairState {\\r\\n    address pool;\\r\\n    address strategyProfitHolder;\\r\\n    /// @notice This is underlying\\r\\n    address tokenA;\\r\\n    /// @notice This is not underlying\\r\\n    address tokenB;\\r\\n\\r\\n    bool isStablePool;\\r\\n    /// @notice Tokens are swapped in the pool (pool.tokenB is underlying, pool.tokenA is not-underlying)\\r\\n    bool depositorSwapTokens;\\r\\n\\r\\n    int24 tickSpacing;\\r\\n    int24 lowerTick;\\r\\n    int24 upperTick;\\r\\n    int24 rebalanceTickRange;\\r\\n    uint128 totalLiquidity;\\r\\n\\r\\n    /// @notice Fuse for tokens\\r\\n    PairBasedStrategyLib.FuseStateParams fuseAB;\\r\\n\\r\\n    /// @notice 1 means that the fuse was triggered ON and then all debts were closed\\r\\n    ///         and assets were converter to underlying using withdrawStepByAgg.\\r\\n    ///         This flag is automatically cleared to 0 if fuse is triggered OFF.\\r\\n    uint withdrawDone;\\r\\n\\r\\n    /// @notice Timestamp of last call of rebalanceNoSwaps() or zero if withdrawByAggStep() was called last\\r\\n    uint lastRebalanceNoSwap;\\r\\n\\r\\n    /// @notice reserve space for future needs\\r\\n    uint[50 - 17] __gap;\\r\\n  }\\r\\n\\r\\n  struct RebalanceNoSwapsLocal {\\r\\n    address tokenA;\\r\\n    address tokenB;\\r\\n    bool depositorSwapTokens;\\r\\n    int24 newLowerTick;\\r\\n    int24 newUpperTick;\\r\\n    uint prop0;\\r\\n    uint prop1;\\r\\n  }\\r\\n\\r\\n  struct WithdrawByAggStepLocal {\\r\\n    PairBasedStrategyLogicLib.WithdrawLocal w;\\r\\n    address tokenToSwap;\\r\\n    address aggregator;\\r\\n    address controller;\\r\\n    address converter;\\r\\n    address splitter;\\r\\n    uint amountToSwap;\\r\\n    uint profitToCover;\\r\\n    uint oldTotalAssets;\\r\\n    uint entryToPool;\\r\\n  }\\r\\n  //endregion ------------------------------------------------------- Data types\\r\\n\\r\\n  //region ------------------------------------------------------- Events\\r\\n  //endregion ------------------------------------------------------- Events\\r\\n\\r\\n  //region ------------------------------------------------------- Helpers\\r\\n  /// @notice Prepare array of amounts ready to deposit, borrow missed amounts\\r\\n  /// @param amount_ Amount of tokenA\\r\\n  /// @param tokenA Underlying\\r\\n  /// @param tokenB Not-underlying\\r\\n  /// @param prop0 Required proportion of underlying, > 0. Proportion of not-underlying is calculates as 1e18 - {prop0}\\r\\n  /// @param liquidationThresholds Dust-thresholds for the tokens A and B\\r\\n  /// @return tokenAmounts Amounts of token A and B to be deposited, [A, B]\\r\\n  function _beforeDeposit(\\r\\n    ITetuConverter tetuConverter_,\\r\\n    uint amount_,\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint prop0,\\r\\n    mapping(address => uint) storage liquidationThresholds\\r\\n  ) external returns (\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    return BorrowLib.prepareToDeposit(\\r\\n      tetuConverter_,\\r\\n      amount_,\\r\\n      [tokenA, tokenB],\\r\\n      [\\r\\n        AppLib._getLiquidationThreshold(liquidationThresholds[tokenA]),\\r\\n        AppLib._getLiquidationThreshold(liquidationThresholds[tokenB])\\r\\n      ],\\r\\n      prop0\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Initialize {dest} in place. Underlying is always first in {dest.tokens}.\\r\\n  /// @param tokens_ [underlying, not-underlying]\\r\\n  function initWithdrawLocal(\\r\\n    WithdrawLocal memory dest,\\r\\n    address[2] memory tokens_,\\r\\n    mapping(address => uint) storage liquidationThresholds,\\r\\n    bytes memory planEntryData,\\r\\n    address controller\\r\\n  ) internal view { // it's internal because it initializes {dest}\\r\\n    dest.controller = controller;\\r\\n    StrategyLib2.onlyOperators(dest.controller);\\r\\n\\r\\n    dest.planKind = IterationPlanLib.getEntryKind(planEntryData);\\r\\n    (dest.propNotUnderlying18, dest.entryDataParam)  = PairBasedStrategyLib._extractProp(dest.planKind, planEntryData);\\r\\n\\r\\n    dest.tokens = new address[](2);\\r\\n    (dest.tokens[0], dest.tokens[1]) = (tokens_[0], tokens_[1]);\\r\\n\\r\\n    dest.liquidationThresholds = new uint[](2);\\r\\n    dest.liquidationThresholds[0] = AppLib._getLiquidationThreshold(liquidationThresholds[dest.tokens[0]]);\\r\\n    dest.liquidationThresholds[1] = AppLib._getLiquidationThreshold(liquidationThresholds[dest.tokens[1]]);\\r\\n  }\\r\\n\\r\\n  function calcTickRange(int24 tick, int24 tickRange, int24 tickSpacing) public pure returns (\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick\\r\\n  ) {\\r\\n    if (tick < 0 && tick / tickSpacing * tickSpacing != tick) {\\r\\n      lowerTick = ((tick - tickRange) / tickSpacing - 1) * tickSpacing;\\r\\n    } else {\\r\\n      lowerTick = (tick - tickRange) / tickSpacing * tickSpacing;\\r\\n    }\\r\\n    upperTick = tickRange == 0 ? lowerTick + tickSpacing : lowerTick + tickRange * 2;\\r\\n  }\\r\\n  //endregion ------------------------------------------------------- Helpers\\r\\n\\r\\n  //region ------------------------------------------------------- PairState-helpers\\r\\n  /// @notice Set the initial values to PairState instance\\r\\n  /// @param pairState Depositor storage state struct to be initialized\\r\\n  /// @param addr [pool, asset, pool.token0(), pool.token1()]\\r\\n  ///        asset: Underlying asset of the depositor.\\r\\n  /// @param tickData [tickSpacing, lowerTick, upperTick, rebalanceTickRange]\\r\\n  /// @param fuseThresholds Fuse thresholds for tokens (stable pool only)\\r\\n  function setInitialDepositorValues(\\r\\n    PairState storage pairState,\\r\\n    address[4] calldata addr,\\r\\n    int24[4] calldata tickData,\\r\\n    bool isStablePool_,\\r\\n    uint[4] calldata fuseThresholds\\r\\n  ) external {\\r\\n    pairState.pool = addr[0];\\r\\n    address asset = addr[1];\\r\\n    address token0 = addr[2];\\r\\n    address token1 = addr[3];\\r\\n\\r\\n    pairState.tickSpacing = tickData[0];\\r\\n    pairState.lowerTick = tickData[1];\\r\\n    pairState.upperTick = tickData[2];\\r\\n    pairState.rebalanceTickRange = tickData[3];\\r\\n\\r\\n    require(asset == token0 || asset == token1, PairBasedStrategyLib.INCORRECT_ASSET);\\r\\n    if (asset == token0) {\\r\\n      pairState.tokenA = token0;\\r\\n      pairState.tokenB = token1;\\r\\n      pairState.depositorSwapTokens = false;\\r\\n    } else {\\r\\n      pairState.tokenA = token1;\\r\\n      pairState.tokenB = token0;\\r\\n      pairState.depositorSwapTokens = true;\\r\\n    }\\r\\n\\r\\n    if (isStablePool_) {\\r\\n      /// for stable pools fuse can be enabled\\r\\n      pairState.isStablePool = true;\\r\\n      PairBasedStrategyLib.setFuseStatus(pairState.fuseAB, PairBasedStrategyLib.FuseStatus.FUSE_OFF_1);\\r\\n      PairBasedStrategyLib.setFuseThresholds(pairState.fuseAB, fuseThresholds);\\r\\n    }\\r\\n\\r\\n    // totalLiquidity is 0, no need to initialize\\r\\n    // withdrawDone is 0, no need to initialize\\r\\n  }\\r\\n\\r\\n  function updateFuseStatus(\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    bool fuseStatusChangedAB,\\r\\n    PairBasedStrategyLib.FuseStatus fuseStatusAB\\r\\n  ) external {\\r\\n    bool updated;\\r\\n    if (fuseStatusChangedAB) {\\r\\n      PairBasedStrategyLib.setFuseStatus(pairState.fuseAB, fuseStatusAB);\\r\\n      updated = true;\\r\\n    }\\r\\n\\r\\n    if (updated) {\\r\\n      // if fuse is triggered ON, full-withdraw is required\\r\\n      // if fuse is triggered OFF, the assets will be deposited back to pool\\r\\n      // in both cases withdrawDone should be reset\\r\\n      pairState.withdrawDone = 0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the current state of the contract\\r\\n  /// @return addr [tokenA, tokenB, pool, profitHolder]\\r\\n  /// @return tickData [tickSpacing, lowerTick, upperTick, rebalanceTickRange]\\r\\n  /// @return nums [totalLiquidity, fuse-status-tokenA, withdrawDone, 4 thresholds of token A, lastRebalanceNoSwap, 5 reserved values]\\r\\n  /// @return boolValues [isStablePool, depositorSwapTokens]\\r\\n  function getDefaultState(PairBasedStrategyLogicLib.PairState storage pairState) external view returns (\\r\\n    address[] memory addr,\\r\\n    int24[] memory tickData,\\r\\n    uint[] memory nums,\\r\\n    bool[] memory boolValues\\r\\n  ) {\\r\\n    addr = new address[](4);\\r\\n    tickData = new int24[](4);\\r\\n    nums = new uint[](13);\\r\\n    boolValues = new bool[](2);\\r\\n\\r\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_TOKEN_A] = pairState.tokenA;\\r\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_TOKEN_B] = pairState.tokenB;\\r\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_POOL] = pairState.pool;\\r\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_PROFIT_HOLDER] = pairState.strategyProfitHolder;\\r\\n\\r\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_TICK_SPACING] = pairState.tickSpacing;\\r\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_LOWER_TICK] = pairState.lowerTick;\\r\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_UPPER_TICK] = pairState.upperTick;\\r\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_REBALANCE_TICK_RANGE] = pairState.rebalanceTickRange;\\r\\n\\r\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_TOTAL_LIQUIDITY] = uint(pairState.totalLiquidity);\\r\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_FUSE_STATUS] = uint(pairState.fuseAB.status);\\r\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_WITHDRAW_DONE] = pairState.withdrawDone;\\r\\n    for (uint i = 0; i < 4; ++i) {\\r\\n      nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_THRESHOLD_0 + i] = pairState.fuseAB.thresholds[i];\\r\\n    }\\r\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_LAST_REBALANCE_NO_SWAP] = pairState.lastRebalanceNoSwap;\\r\\n\\r\\n    boolValues[PairBasedStrategyLib.IDX_BOOL_VALUES_DEFAULT_STATE_IS_STABLE_POOL] = pairState.isStablePool;\\r\\n    boolValues[PairBasedStrategyLib.IDX_BOOL_VALUES_DEFAULT_STATE_DEPOSITOR_SWAP_TOKENS] = pairState.depositorSwapTokens;\\r\\n  }\\r\\n\\r\\n  /// @notice Get info about a swap required by next call of {withdrawByAggStep} within the given plan\\r\\n  /// @param amounts_ Amounts of [underlying, not-underlying] that will be received from the pool before withdrawing\\r\\n  function quoteWithdrawByAgg(\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    bytes memory planEntryData,\\r\\n    uint[] memory amounts_,\\r\\n    address controller_,\\r\\n    ITetuConverter converter_,\\r\\n    mapping(address => uint) storage liquidationThresholds\\r\\n  ) external returns (\\r\\n    address tokenToSwap,\\r\\n    uint amountToSwap\\r\\n  ) {\\r\\n    // check operator-only, initialize w\\r\\n    WithdrawLocal memory w;\\r\\n    initWithdrawLocal(\\r\\n      w,\\r\\n      [pairState.tokenA, pairState.tokenB],\\r\\n      liquidationThresholds,\\r\\n      planEntryData,\\r\\n      controller_\\r\\n    );\\r\\n\\r\\n    (tokenToSwap, amountToSwap) = PairBasedStrategyLib.quoteWithdrawStep(\\r\\n      [address(converter_), address(AppLib._getLiquidator(w.controller))],\\r\\n      w.tokens,\\r\\n      w.liquidationThresholds,\\r\\n      amounts_,\\r\\n      w.planKind,\\r\\n      [w.propNotUnderlying18, w.entryDataParam]\\r\\n    );\\r\\n\\r\\n    if (amountToSwap != 0) {\\r\\n      // withdrawByAggStep will execute REPAY1 - SWAP - REPAY2\\r\\n      // but quoteWithdrawByAgg and withdrawByAggStep are executed in different blocks\\r\\n      // so, REPAY1 can return less collateral than quoteWithdrawByAgg expected\\r\\n      // As result, we can have less amount on balance than required amountToSwap\\r\\n      // So, we need to reduce amountToSwap on small gap amount\\r\\n      amountToSwap -= amountToSwap * PairBasedStrategyLib.GAP_AMOUNT_TO_SWAP / 100_000;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate amounts to be deposited to pool, calculate loss, fix profitToCover\\r\\n  /// @param addr_ [tokenToSwap, aggregator, controller, converter, splitter]\\r\\n  /// @param values_ [amountToSwap_, profitToCover, oldTotalAssets, not used here]\\r\\n  /// @param tokens [underlying, not-underlying] (values been read from pairBase)\\r\\n  /// @return completed All debts were closed, leftovers were swapped to proper proportions\\r\\n  /// @return tokenAmounts Amounts to be deposited to pool. If {tokenAmounts} contains zero amount return empty array.\\r\\n  function withdrawByAggStep(\\r\\n    address[5] calldata addr_,\\r\\n    uint[4] calldata values_,\\r\\n    bytes memory swapData,\\r\\n    bytes memory planEntryData,\\r\\n    address[2] memory tokens,\\r\\n    mapping(address => uint) storage liquidationThresholds\\r\\n  ) external returns (\\r\\n    bool completed,\\r\\n    uint[] memory tokenAmounts,\\r\\n    uint loss\\r\\n  ) {\\r\\n    WithdrawByAggStepLocal memory v;\\r\\n\\r\\n    v.tokenToSwap = addr_[0];\\r\\n    v.aggregator = addr_[1];\\r\\n    v.controller = addr_[2];\\r\\n    v.converter = addr_[3];\\r\\n    v.splitter = addr_[4];\\r\\n\\r\\n    v.amountToSwap = values_[0];\\r\\n    v.profitToCover = values_[1];\\r\\n    v.oldTotalAssets = values_[2];\\r\\n\\r\\n    // initialize v\\r\\n    PairBasedStrategyLogicLib.initWithdrawLocal(v.w, tokens, liquidationThresholds, planEntryData, v.controller);\\r\\n\\r\\n    // make withdraw iteration according to the selected plan\\r\\n    completed = PairBasedStrategyLib.withdrawStep(\\r\\n      [v.converter, address(AppLib._getLiquidator(v.w.controller))],\\r\\n      v.w.tokens,\\r\\n      v.w.liquidationThresholds,\\r\\n      v.tokenToSwap,\\r\\n      v.amountToSwap,\\r\\n      v.aggregator,\\r\\n      swapData,\\r\\n      v.aggregator == address(0),\\r\\n      v.w.planKind,\\r\\n      [v.w.propNotUnderlying18, v.w.entryDataParam]\\r\\n    );\\r\\n\\r\\n    // fix loss / profitToCover\\r\\n    if (v.profitToCover != 0) {\\r\\n      ConverterStrategyBaseLib2.sendToInsurance(\\r\\n        v.w.tokens[0],\\r\\n        v.profitToCover,\\r\\n        v.splitter,\\r\\n        v.oldTotalAssets,\\r\\n        IERC20(v.w.tokens[0]).balanceOf(address(this))\\r\\n      );\\r\\n    }\\r\\n\\r\\n    (loss, tokenAmounts) = ConverterStrategyBaseLib2.getTokenAmountsPair(\\r\\n      ITetuConverter(v.converter),\\r\\n      v.oldTotalAssets,\\r\\n      v.w.tokens[0],\\r\\n      v.w.tokens[1],\\r\\n      [v.w.liquidationThresholds[0], v.w.liquidationThresholds[1]]\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Rebalance asset to proportions {propTokenA}:{1e18-propTokenA}, fix profitToCover\\r\\n  /// @param propTokenA Proportion of {tokenA}, > 0. Proportion of {tokenB} is calculates as 1e18 - prop0\\r\\n  /// @param liquidationThresholdsAB [liquidityThreshold of token A, liquidityThreshold of tokenB]\\r\\n  function _rebalanceNoSwaps(\\r\\n    address[2] calldata converterLiquidator,\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    uint profitToCover,\\r\\n    uint totalAssets,\\r\\n    address splitter,\\r\\n    uint[2] calldata liquidationThresholdsAB,\\r\\n    uint propTokenA\\r\\n  ) internal {\\r\\n    address tokenA = pairState.tokenA;\\r\\n    address tokenB = pairState.tokenB;\\r\\n\\r\\n    BorrowLib.rebalanceAssets(\\r\\n      ITetuConverter(converterLiquidator[0]),\\r\\n      ITetuLiquidator(converterLiquidator[1]),\\r\\n      tokenA,\\r\\n      tokenB,\\r\\n      propTokenA,\\r\\n      liquidationThresholdsAB[0], // liquidityThreshold of token A\\r\\n      liquidationThresholdsAB[1], // liquidityThreshold of token B\\r\\n      profitToCover\\r\\n    );\\r\\n\\r\\n    // we assume here, that rebalanceAssets provides profitToCover on balance and set leftovers to right proportions\\r\\n    if (profitToCover != 0) {\\r\\n      ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets, IERC20(tokenA).balanceOf(address(this)));\\r\\n    }\\r\\n  }\\r\\n  //endregion ------------------------------------------------------- PairState-helpers\\r\\n\\r\\n  //region ------------------------------------------------------- needStrategyRebalance\\r\\n  /// @notice Determine if the strategy needs to be rebalanced.\\r\\n  /// @return needRebalance A boolean indicating if {rebalanceNoSwaps} should be called\\r\\n  function needStrategyRebalance(\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    ITetuConverter converter_,\\r\\n    int24 tick,\\r\\n    uint poolPrice\\r\\n  ) external view returns (\\r\\n    bool needRebalance,\\r\\n    bool fuseStatusChangedAB,\\r\\n    PairBasedStrategyLib.FuseStatus fuseStatusAB\\r\\n  ) {\\r\\n    if (pairState.isStablePool) {\\r\\n      uint price = ConverterStrategyBaseLib2.getOracleAssetsPrice(\\r\\n        converter_,\\r\\n        pairState.tokenA,\\r\\n        pairState.tokenB\\r\\n      );\\r\\n      (fuseStatusChangedAB, fuseStatusAB) = PairBasedStrategyLib.needChangeFuseStatus(pairState.fuseAB, price, poolPrice);\\r\\n      needRebalance = fuseStatusChangedAB\\r\\n        || (\\r\\n          !PairBasedStrategyLib.isFuseTriggeredOn(fuseStatusAB)\\r\\n          && _needPoolRebalance(pairState, tick)\\r\\n        );\\r\\n    } else {\\r\\n      needRebalance = _needPoolRebalance(pairState, tick);\\r\\n    }\\r\\n\\r\\n    return (needRebalance, fuseStatusChangedAB, fuseStatusAB); // hide warning\\r\\n  }\\r\\n\\r\\n  /// @notice Determine if the pool needs to be rebalanced.\\r\\n  /// @return A boolean indicating if the pool needs to be rebalanced.\\r\\n  function _needPoolRebalance(\\r\\n    int24 tick,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    int24 tickSpacing,\\r\\n    int24 rebalanceTickRange\\r\\n  ) internal pure returns (bool) {\\r\\n    if (upperTick - lowerTick == tickSpacing) {\\r\\n      return tick < lowerTick || tick >= upperTick;\\r\\n    } else {\\r\\n      int24 halfRange = (upperTick - lowerTick) / 2;\\r\\n      int24 oldMedianTick = lowerTick + halfRange;\\r\\n      return (tick > oldMedianTick)\\r\\n        ? tick - oldMedianTick >= rebalanceTickRange\\r\\n        : oldMedianTick - tick > rebalanceTickRange;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _needPoolRebalance(PairBasedStrategyLogicLib.PairState storage pairState, int24 tick) internal view returns (bool) {\\r\\n    return _needPoolRebalance(\\r\\n      tick,\\r\\n      pairState.lowerTick,\\r\\n      pairState.upperTick,\\r\\n      pairState.tickSpacing,\\r\\n      pairState.rebalanceTickRange\\r\\n    );\\r\\n  }\\r\\n  //endregion ------------------------------------------------------- needStrategyRebalance\\r\\n}\\r\\n\",\"keccak256\":\"0xa1de412c47d5ef698afdb1fe0afe130a9b66dae28ef90aaec4349ca482f24863\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x6126cb61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100925760003560e01c80636e81b629116100655780636e81b62914610150578063b8b4a44914610173578063bd13c52914610193578063cd8e20e7146101c257600080fd5b80631c2040d5146100975780634aa00915146100cd57806350d2e0ba146100ef57806351265e891461012e575b600080fd5b8180156100a357600080fd5b506100b76100b2366004611a86565b6101ef565b6040516100c49190611b26565b60405180910390f35b8180156100d957600080fd5b506100ed6100e8366004611b47565b61031c565b005b8180156100fb57600080fd5b5061010f61010a366004611c91565b6103a9565b604080516001600160a01b0390931683526020830191909152016100c4565b61014161013c366004611d95565b610504565b6040516100c493929190611e13565b61016361015e366004611e39565b6106ba565b6040516100c49493929190611e8b565b81801561017f57600080fd5b506100ed61018e366004611f44565b610a7d565b81801561019f57600080fd5b506101b36101ae366004611faa565b610dc8565b6040516100c49392919061209b565b6101d56101d03660046120c6565b611293565b60408051600293840b81529190920b6020820152016100c4565b606073158Da3ec4771bC05F4898BBF53141cB773754E7C634b4bd6f7888860405180604001604052808a6001600160a01b03166001600160a01b03168152602001896001600160a01b03166001600160a01b0316815250604051806040016040528061027e8960008e6001600160a01b03166001600160a01b0316815260200190815260200160002054611358565b81526001600160a01b038b16600090815260208a81526040909120549101906102a690611358565b815250886040518663ffffffff1660e01b81526004016102ca959493929190612158565b600060405180830381865af41580156102e7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261030f91908101906121ff565b90505b9695505050505050565b60008215610395576040516335ffd9a360e11b815273626aB57b826869B8AE32D32487E0AB6405625bb390636bffb346906103609060058801908690600401612234565b60006040518083038186803b15801561037857600080fd5b505af415801561038c573d6000803e3d6000fd5b50505050600190505b80156103a3576000600e8501555b50505050565b6000806103b46119c4565b6040805180820190915260028a01546001600160a01b03908116825260038b01541660208201526103e9908290868b8a611371565b73626aB57b826869B8AE32D32487E0AB6405625bb36314ad109e6040518060400160405280886001600160a01b03166001600160a01b031681526020016104338560200151611557565b6001600160a01b0316905283516040808601516060870151825180840184526080890151815260a0890151602082015292516001600160e01b031960e088901b1681526104879594938f9291600401612248565b6040805180830381865af41580156104a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104c791906122b2565b909350915081156104f857620186a06104e16064846122f6565b6104eb9190612323565b6104f59083612337565b91505b50965096945050505050565b60008060008660030160149054906101000a900460ff16156106a35760028701546003880154604051637fd6c0a160e01b81526001600160a01b03808a16600483015292831660248201529116604482015260009073c1Ed5dD095C703421F623F416b88bbf57a1E101290637fd6c0a190606401602060405180830381865af4158015610595573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105b9919061234a565b604080516060810190915260058a01805492935061067492829060ff1660038111156105e7576105e7611ddb565b60038111156105f8576105f8611ddb565b815260408051608081019182905260209092019190600184019060049082845b81548152602001906001019080831161061857505050918352505060408051608081019182905260209092019190600584019060049082845b8154815260200190600101908083116106515750505050508152505082876115bb565b9093509150828061069b575061068982611733565b15801561069b575061069b8887611750565b9350506106b0565b6106ad8786611750565b92505b9450945094915050565b60408051600480825260a082019092526060918291829182919060208201608080368337505060408051600480825260a08201909252929650905060208201608080368337505060408051600d8082526101c082019092529295509050602082016101a0803683375050604080516002808252606082018352939550929150602083019080368337505050600286015485519192506001600160a01b031690859060009061076a5761076a612363565b6001600160a01b039283166020918202929092010152600386015485519116908590600190811061079d5761079d612363565b6001600160a01b03928316602091820292909201015285548551911690859060029081106107cd576107cd612363565b6001600160a01b039283166020918202929092010152600186015485519116908590600390811061080057610800612363565b60200260200101906001600160a01b031690816001600160a01b0316815250508460030160169054906101000a900460020b8360008151811061084557610845612363565b600292830b602091820292909201015260038601548451600160c81b90910490910b908490600190811061087b5761087b612363565b600292830b602091820292909201015260038601548451600160e01b909104820b91859181106108ad576108ad612363565b600292830b602091820292909201015260048601548451910b90849060039081106108da576108da612363565b602002602001019060020b908160020b815250508460040160039054906101000a90046001600160801b03166001600160801b03168260008151811061092257610922612363565b6020908102919091010152600585015460ff16600381111561094657610946611ddb565b8260018151811061095957610959612363565b60200260200101818152505084600e01548260038151811061097d5761097d612363565b60200260200101818152505060005b60048110156109e3576006860181600481106109aa576109aa612363565b0154836109b8836004612379565b815181106109c8576109c8612363565b60209081029190910101526109dc8161238c565b905061098c565b5084600f015482600c815181106109fc576109fc612363565b6020026020010181815250508460030160149054906101000a900460ff1681600081518110610a2d57610a2d612363565b6020026020010190151590811515815250508460030160159054906101000a900460ff1681600181518110610a6457610a64612363565b6020026020010190151590811515815250509193509193565b610a8a60208501856123a5565b85546001600160a01b0319166001600160a01b03919091161785556000610ab760408601602087016123a5565b90506000610acb60608701604088016123a5565b90506000610adf60808801606089016123a5565b9050610aee60208701876123c2565b60038901805462ffffff92909216600160b01b0262ffffff60b01b19909216919091179055610b2360408701602088016123c2565b60038901805462ffffff92909216600160c81b0262ffffff60c81b19909216919091179055610b5860608701604088016123c2565b60038901805462ffffff92909216600160e01b0262ffffff60e01b19909216919091179055610b8d60808701606088016123c2565b60048901805462ffffff191662ffffff929092169190911790556001600160a01b038281169084161480610bd25750806001600160a01b0316836001600160a01b0316145b60405180604001604052806015815260200174141094cb4d48125b98dbdc9c9958dd08185cdcd95d605a1b81525090610c275760405162461bcd60e51b8152600401610c1e9190612423565b60405180910390fd5b50816001600160a01b0316836001600160a01b031603610c84576002880180546001600160a01b038085166001600160a01b031990921691909117909155600389018054600161ff0160a01b031916918316919091179055610cc9565b6002880180546001600160a01b038084166001600160a01b031990921691909117909155600389018054600161ff0160a01b03191691841691909117600160a81b1790555b8415610dbe5760038801805460ff60a01b1916600160a01b1790556040516335ffd9a360e11b815273626aB57b826869B8AE32D32487E0AB6405625bb390636bffb34690610d219060058c0190600190600401612234565b60006040518083038186803b158015610d3957600080fd5b505af4158015610d4d573d6000803e3d6000fd5b5050604051630593c4c960e01b815273626aB57b826869B8AE32D32487E0AB6405625bb39250630593c4c99150610d8d9060058c01908890600401612436565b60006040518083038186803b158015610da557600080fd5b505af4158015610db9573d6000803e3d6000fd5b505050505b5050505050505050565b600060606000610dd6611a03565b610de360208b018b6123a5565b6001600160a01b03166020820152896001602002016020810190610e0791906123a5565b6001600160a01b03166040820152896002602002016020810190610e2b91906123a5565b6001600160a01b03166060820152896003602002016020810190610e4f91906123a5565b6001600160a01b03166080820152896004602002016020810190610e7391906123a5565b6001600160a01b031660a0820152883560c0820152602089013560e0820152604089013561010082015280516060820151610eb49190889088908b90611371565b73626aB57b826869B8AE32D32487E0AB6405625bb3637545be26604051806040016040528084608001516001600160a01b03166001600160a01b03168152602001610f06856000015160200151611557565b6001600160a01b03166001600160a01b031681525083600001516000015184600001516040015185602001518660c0015187604001518f60006001600160a01b03168a604001516001600160a01b0316148a600001516060015160405180604001604052808d600001516080015181526020018d6000015160a001518152506040518b63ffffffff1660e01b8152600401610faa9a9998979695949392919061244c565b602060405180830381865af4158015610fc7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610feb91906124e3565b93508060e0015160001461115857805151805173c1Ed5dD095C703421F623F416b88bbf57a1E10129163890ffb849160009061102957611029612363565b60200260200101518360e001518460a0015185610100015186600001516000015160008151811061105c5761105c612363565b60209081029190910101516040516370a0823160e01b81523060048201526001600160a01b03909116906370a0823190602401602060405180830381865afa1580156110ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110d0919061234a565b6040516001600160e01b031960e088901b1681526001600160a01b03958616600482015260248101949094529390911660448301526064820152608481019190915260a4016040805180830381865af4158015611131573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111559190612500565b50505b73c1Ed5dD095C703421F623F416b88bbf57a1E101263ac2a37d6826080015183610100015184600001516000015160008151811061119857611198612363565b60200260200101518560000151600001516001815181106111bb576111bb612363565b602002602001015160405180604001604052808860000151604001516000815181106111e9576111e9612363565b6020026020010151815260200188600001516040015160018151811061121157611211612363565b60200260200101518152506040518663ffffffff1660e01b815260040161123c959493929190612524565b600060405180830381865af4158015611259573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526112819190810190612558565b949b949a509850929650505050505050565b60008060008560020b1280156112c45750600285900b836112b4818861259f565b6112be91906125d9565b60020b14155b156112fc57826001816112d78789612600565b6112e1919061259f565b6112eb9190612600565b6112f591906125d9565b915061131f565b82806113088688612600565b611312919061259f565b61131c91906125d9565b91505b8360020b600014611344576113358460026125d9565b61133f9083612625565b61134e565b61134e8383612625565b9050935093915050565b60008115611366578161136b565b620186a05b92915050565b6001600160a01b0381166020860181905260405163124fdbb760e21b815260048101919091527306c875daA1Dc2E27dd7381EB3b6be4F99553a6099063493f6edc9060240160006040518083038186803b1580156113ce57600080fd5b505af41580156113e2573d6000803e3d6000fd5b505050506113ef82611791565b6060860181905261140090836117b8565b60a0870152608086015260408051600280825260608201835290916020830190803683375050508086528451602086015182519192909160009061144657611446612363565b60200260200101876000015160018151811061146457611464612363565b6001600160a01b0393841660209182029290920101529116905260408051600280825260608201909252908160200160208202803683375050506040860152845180516114ed9185916000919082906114bf576114bf612363565b60200260200101516001600160a01b03166001600160a01b0316815260200190815260200160002054611358565b856040015160008151811061150457611504612363565b60200260200101818152505061152d83600087600001516001815181106114bf576114bf612363565b856040015160018151811061154457611544612363565b6020026020010181815250505050505050565b6000816001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611597573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061136b919061264a565b60008080855160038111156115d2576115d2611ddb565b14611718576001855160038111156115ec576115ec611ddb565b0361164c576020850151518411158061160a57506020850151518311155b1561161b5750600190506002611718565b6020850151604001518410158061163a57506020850151604001518310155b1561164757506001905060035b611718565b60028551600381111561166157611661611ddb565b036116c15760208581015101518410801590611684575060208581015101518310155b156116475760208501516040015160019250841015806116ac57506020850151604001518310155b156116b957506003611718565b506001611718565b60208501516060015184118015906116e157506020850151606001518311155b156117185760208581015101516001925084111580611707575060208581015101518311155b1561171457506002611718565b5060015b8182611725578551611727565b815b91509150935093915050565b6000600182600381111561174957611749611ddb565b1192915050565b6003820154600483015460009161178a918491600160c81b8104600290810b92600160e01b8304820b92600160b01b9004820b910b61191a565b9392505050565b600081516000036117a457506000919050565b8180602001905181019061136b919061234a565b6000808315806117c85750600284145b1561184c57828060200190518101906117e19190612500565b925050670de0b6b3a7640000821115806117fc575060001982145b6040518060400160405280601381526020017254532d333020696e76616c69642076616c756560681b815250906118465760405162461bcd60e51b8152600401610c1e9190612423565b50611913565b60408051808201909152601081526f54532d392077726f6e672076616c756560801b6020820152600185146118945760405162461bcd60e51b8152600401610c1e9190612423565b50828060200190518101906118a99190612667565b909350915050670de0b6b3a7640000821115806118c7575060001982145b6040518060400160405280601381526020017254532d333020696e76616c69642076616c756560681b815250906119115760405162461bcd60e51b8152600401610c1e9190612423565b505b9250929050565b6000600283900b61192b8686612600565b60020b03611954578460020b8660020b128061194d57508360020b8660020b12155b90506119bb565b600060026119628787612600565b61196c919061259f565b9050600061197a8288612625565b90508060020b8860020b136119a157600284900b6119988983612600565b60020b136119b6565b600284900b6119b0828a612600565b60020b12155b925050505b95945050505050565b6040518060c001604052806060815260200160006001600160a01b03168152602001606081526020016000815260200160008152602001600081525090565b604051806101400160405280611a176119c4565b815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e0820181905261010082018190526101209091015290565b6001600160a01b0381168114611a7357600080fd5b50565b8035611a8181611a5e565b919050565b60008060008060008060c08789031215611a9f57600080fd5b8635611aaa81611a5e565b9550602087013594506040870135611ac181611a5e565b93506060870135611ad181611a5e565b9598949750929560808101359460a0909101359350915050565b600081518084526020808501945080840160005b83811015611b1b57815187529582019590820190600101611aff565b509495945050505050565b60208152600061178a6020830184611aeb565b8015158114611a7357600080fd5b600080600060608486031215611b5c57600080fd5b833592506020840135611b6e81611b39565b9150604084013560048110611b8257600080fd5b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715611bc657611bc6611b8d565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715611bf557611bf5611b8d565b604052919050565b600082601f830112611c0e57600080fd5b813567ffffffffffffffff811115611c2857611c28611b8d565b611c3b601f8201601f1916602001611bcc565b818152846020838601011115611c5057600080fd5b816020850160208301376000918101602001919091529392505050565b600067ffffffffffffffff821115611c8757611c87611b8d565b5060051b60200190565b60008060008060008060c08789031215611caa57600080fd5b8635955060208088013567ffffffffffffffff80821115611cca57600080fd5b611cd68b838c01611bfd565b975060408a0135915080821115611cec57600080fd5b508801601f81018a13611cfe57600080fd5b8035611d11611d0c82611c6d565b611bcc565b81815260059190911b8201830190838101908c831115611d3057600080fd5b928401925b82841015611d4e57833582529284019290840190611d35565b8098505050505050611d6260608801611a76565b9250611d7060808801611a76565b915060a087013590509295509295509295565b8035600281900b8114611a8157600080fd5b60008060008060808587031215611dab57600080fd5b843593506020850135611dbd81611a5e565b9250611dcb60408601611d83565b9396929550929360600135925050565b634e487b7160e01b600052602160045260246000fd5b60048110611e0f57634e487b7160e01b600052602160045260246000fd5b9052565b8315158152821515602082015260608101611e316040830184611df1565b949350505050565b600060208284031215611e4b57600080fd5b5035919050565b600081518084526020808501945080840160005b83811015611b1b5781516001600160a01b031687529582019590820190600101611e66565b608081526000611e9e6080830187611e52565b82810360208481019190915286518083528782019282019060005b81811015611ed857845160020b83529383019391830191600101611eb9565b50508481036040860152611eec8188611aeb565b858103606087015286518082528388019450908301915060005b81811015611f24578451151583529383019391830191600101611f06565b50909998505050505050505050565b806080810183101561136b57600080fd5b60008060008060006101c08688031215611f5d57600080fd5b85359450611f6e8760208801611f33565b9350611f7d8760a08801611f33565b9250610120860135611f8e81611b39565b9150611f9e876101408801611f33565b90509295509295909350565b6000806000806000806101c08789031215611fc457600080fd5b60a0870188811115611fd557600080fd5b879650611fe28982611f33565b95505061012087013567ffffffffffffffff8082111561200157600080fd5b61200d8a838b01611bfd565b955061014089013591508082111561202457600080fd5b5061203189828a01611bfd565b9350508761017f88011261204457600080fd5b61204c611ba3565b806101a089018a81111561205f57600080fd5b6101608a015b8181101561208657803561207881611a5e565b845260209384019301612065565b50819450803593505050509295509295509295565b83151581526060602082015260006120b66060830185611aeb565b9050826040830152949350505050565b6000806000606084860312156120db57600080fd5b6120e484611d83565b92506120f260208501611d83565b915061210060408501611d83565b90509250925092565b8060005b60028110156103a35781516001600160a01b031684526020938401939091019060010161210d565b8060005b60028110156103a3578151845260209384019390910190600101612139565b6001600160a01b03861681526020810185905260e0810161217c6040830186612109565b6121896080830185612135565b8260c08301529695505050505050565b600082601f8301126121aa57600080fd5b815160206121ba611d0c83611c6d565b82815260059290921b840181019181810190868411156121d957600080fd5b8286015b848110156121f457805183529183019183016121dd565b509695505050505050565b60006020828403121561221157600080fd5b815167ffffffffffffffff81111561222857600080fd5b611e3184828501612199565b8281526040810161178a6020830184611df1565b6000610100612257838a612109565b80604084015261226981840189611e52565b9050828103606084015261227d8188611aeb565b905082810360808401526122918187611aeb565b9150508360a08301526122a760c0830184612135565b979650505050505050565b600080604083850312156122c557600080fd5b82516122d081611a5e565b6020939093015192949293505050565b634e487b7160e01b600052601160045260246000fd5b808202811582820484141761136b5761136b6122e0565b634e487b7160e01b600052601260045260246000fd5b6000826123325761233261230d565b500490565b8181038181111561136b5761136b6122e0565b60006020828403121561235c57600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b8082018082111561136b5761136b6122e0565b60006001820161239e5761239e6122e0565b5060010190565b6000602082840312156123b757600080fd5b813561178a81611a5e565b6000602082840312156123d457600080fd5b61178a82611d83565b6000815180845260005b81811015612403576020818501810151868301820152016123e7565b506000602082860101526020601f19601f83011685010191505092915050565b60208152600061178a60208301846123dd565b82815260a0810160808360208401379392505050565b600061018061245b838e612109565b80604084015261246d8184018d611e52565b90508281036060840152612481818c611aeb565b6001600160a01b038b8116608086015260a085018b9052891660c085015283810360e085015290506124b381886123dd565b915050841515610100830152836101208301526124d4610140830184612135565b9b9a5050505050505050505050565b6000602082840312156124f557600080fd5b815161178a81611b39565b6000806040838503121561251357600080fd5b505080516020909101519092909150565b6001600160a01b0386811682526020820186905284811660408301528316606082015260c081016103126080830184612135565b6000806040838503121561256b57600080fd5b82519150602083015167ffffffffffffffff81111561258957600080fd5b61259585828601612199565b9150509250929050565b60008160020b8360020b806125b6576125b661230d565b627fffff198214600019821416156125d0576125d06122e0565b90059392505050565b60008260020b8260020b028060020b91508082146125f9576125f96122e0565b5092915050565b600282810b9082900b03627fffff198112627fffff8213171561136b5761136b6122e0565b600281810b9083900b01627fffff8113627fffff198212171561136b5761136b6122e0565b60006020828403121561265c57600080fd5b815161178a81611a5e565b60008060006060848603121561267c57600080fd5b835192506020840151915060408401519050925092509256fea2646970667358221220aa5b22fa323aced4edee678c6bf4038b3de3ae72f46cd27489feb7ff65bf689d64736f6c63430008110033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100925760003560e01c80636e81b629116100655780636e81b62914610150578063b8b4a44914610173578063bd13c52914610193578063cd8e20e7146101c257600080fd5b80631c2040d5146100975780634aa00915146100cd57806350d2e0ba146100ef57806351265e891461012e575b600080fd5b8180156100a357600080fd5b506100b76100b2366004611a86565b6101ef565b6040516100c49190611b26565b60405180910390f35b8180156100d957600080fd5b506100ed6100e8366004611b47565b61031c565b005b8180156100fb57600080fd5b5061010f61010a366004611c91565b6103a9565b604080516001600160a01b0390931683526020830191909152016100c4565b61014161013c366004611d95565b610504565b6040516100c493929190611e13565b61016361015e366004611e39565b6106ba565b6040516100c49493929190611e8b565b81801561017f57600080fd5b506100ed61018e366004611f44565b610a7d565b81801561019f57600080fd5b506101b36101ae366004611faa565b610dc8565b6040516100c49392919061209b565b6101d56101d03660046120c6565b611293565b60408051600293840b81529190920b6020820152016100c4565b606073__$295fb458e6648e6381ea46363bb426e5e7$__634b4bd6f7888860405180604001604052808a6001600160a01b03166001600160a01b03168152602001896001600160a01b03166001600160a01b0316815250604051806040016040528061027e8960008e6001600160a01b03166001600160a01b0316815260200190815260200160002054611358565b81526001600160a01b038b16600090815260208a81526040909120549101906102a690611358565b815250886040518663ffffffff1660e01b81526004016102ca959493929190612158565b600060405180830381865af41580156102e7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261030f91908101906121ff565b90505b9695505050505050565b60008215610395576040516335ffd9a360e11b815273__$79fe6ec7a3db45dafbed12dca1c6dad764$__90636bffb346906103609060058801908690600401612234565b60006040518083038186803b15801561037857600080fd5b505af415801561038c573d6000803e3d6000fd5b50505050600190505b80156103a3576000600e8501555b50505050565b6000806103b46119c4565b6040805180820190915260028a01546001600160a01b03908116825260038b01541660208201526103e9908290868b8a611371565b73__$79fe6ec7a3db45dafbed12dca1c6dad764$__6314ad109e6040518060400160405280886001600160a01b03166001600160a01b031681526020016104338560200151611557565b6001600160a01b0316905283516040808601516060870151825180840184526080890151815260a0890151602082015292516001600160e01b031960e088901b1681526104879594938f9291600401612248565b6040805180830381865af41580156104a3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104c791906122b2565b909350915081156104f857620186a06104e16064846122f6565b6104eb9190612323565b6104f59083612337565b91505b50965096945050505050565b60008060008660030160149054906101000a900460ff16156106a35760028701546003880154604051637fd6c0a160e01b81526001600160a01b03808a16600483015292831660248201529116604482015260009073__$8f1afe7577f9ab973017c74eca19b86f3c$__90637fd6c0a190606401602060405180830381865af4158015610595573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105b9919061234a565b604080516060810190915260058a01805492935061067492829060ff1660038111156105e7576105e7611ddb565b60038111156105f8576105f8611ddb565b815260408051608081019182905260209092019190600184019060049082845b81548152602001906001019080831161061857505050918352505060408051608081019182905260209092019190600584019060049082845b8154815260200190600101908083116106515750505050508152505082876115bb565b9093509150828061069b575061068982611733565b15801561069b575061069b8887611750565b9350506106b0565b6106ad8786611750565b92505b9450945094915050565b60408051600480825260a082019092526060918291829182919060208201608080368337505060408051600480825260a08201909252929650905060208201608080368337505060408051600d8082526101c082019092529295509050602082016101a0803683375050604080516002808252606082018352939550929150602083019080368337505050600286015485519192506001600160a01b031690859060009061076a5761076a612363565b6001600160a01b039283166020918202929092010152600386015485519116908590600190811061079d5761079d612363565b6001600160a01b03928316602091820292909201015285548551911690859060029081106107cd576107cd612363565b6001600160a01b039283166020918202929092010152600186015485519116908590600390811061080057610800612363565b60200260200101906001600160a01b031690816001600160a01b0316815250508460030160169054906101000a900460020b8360008151811061084557610845612363565b600292830b602091820292909201015260038601548451600160c81b90910490910b908490600190811061087b5761087b612363565b600292830b602091820292909201015260038601548451600160e01b909104820b91859181106108ad576108ad612363565b600292830b602091820292909201015260048601548451910b90849060039081106108da576108da612363565b602002602001019060020b908160020b815250508460040160039054906101000a90046001600160801b03166001600160801b03168260008151811061092257610922612363565b6020908102919091010152600585015460ff16600381111561094657610946611ddb565b8260018151811061095957610959612363565b60200260200101818152505084600e01548260038151811061097d5761097d612363565b60200260200101818152505060005b60048110156109e3576006860181600481106109aa576109aa612363565b0154836109b8836004612379565b815181106109c8576109c8612363565b60209081029190910101526109dc8161238c565b905061098c565b5084600f015482600c815181106109fc576109fc612363565b6020026020010181815250508460030160149054906101000a900460ff1681600081518110610a2d57610a2d612363565b6020026020010190151590811515815250508460030160159054906101000a900460ff1681600181518110610a6457610a64612363565b6020026020010190151590811515815250509193509193565b610a8a60208501856123a5565b85546001600160a01b0319166001600160a01b03919091161785556000610ab760408601602087016123a5565b90506000610acb60608701604088016123a5565b90506000610adf60808801606089016123a5565b9050610aee60208701876123c2565b60038901805462ffffff92909216600160b01b0262ffffff60b01b19909216919091179055610b2360408701602088016123c2565b60038901805462ffffff92909216600160c81b0262ffffff60c81b19909216919091179055610b5860608701604088016123c2565b60038901805462ffffff92909216600160e01b0262ffffff60e01b19909216919091179055610b8d60808701606088016123c2565b60048901805462ffffff191662ffffff929092169190911790556001600160a01b038281169084161480610bd25750806001600160a01b0316836001600160a01b0316145b60405180604001604052806015815260200174141094cb4d48125b98dbdc9c9958dd08185cdcd95d605a1b81525090610c275760405162461bcd60e51b8152600401610c1e9190612423565b60405180910390fd5b50816001600160a01b0316836001600160a01b031603610c84576002880180546001600160a01b038085166001600160a01b031990921691909117909155600389018054600161ff0160a01b031916918316919091179055610cc9565b6002880180546001600160a01b038084166001600160a01b031990921691909117909155600389018054600161ff0160a01b03191691841691909117600160a81b1790555b8415610dbe5760038801805460ff60a01b1916600160a01b1790556040516335ffd9a360e11b815273__$79fe6ec7a3db45dafbed12dca1c6dad764$__90636bffb34690610d219060058c0190600190600401612234565b60006040518083038186803b158015610d3957600080fd5b505af4158015610d4d573d6000803e3d6000fd5b5050604051630593c4c960e01b815273__$79fe6ec7a3db45dafbed12dca1c6dad764$__9250630593c4c99150610d8d9060058c01908890600401612436565b60006040518083038186803b158015610da557600080fd5b505af4158015610db9573d6000803e3d6000fd5b505050505b5050505050505050565b600060606000610dd6611a03565b610de360208b018b6123a5565b6001600160a01b03166020820152896001602002016020810190610e0791906123a5565b6001600160a01b03166040820152896002602002016020810190610e2b91906123a5565b6001600160a01b03166060820152896003602002016020810190610e4f91906123a5565b6001600160a01b03166080820152896004602002016020810190610e7391906123a5565b6001600160a01b031660a0820152883560c0820152602089013560e0820152604089013561010082015280516060820151610eb49190889088908b90611371565b73__$79fe6ec7a3db45dafbed12dca1c6dad764$__637545be26604051806040016040528084608001516001600160a01b03166001600160a01b03168152602001610f06856000015160200151611557565b6001600160a01b03166001600160a01b031681525083600001516000015184600001516040015185602001518660c0015187604001518f60006001600160a01b03168a604001516001600160a01b0316148a600001516060015160405180604001604052808d600001516080015181526020018d6000015160a001518152506040518b63ffffffff1660e01b8152600401610faa9a9998979695949392919061244c565b602060405180830381865af4158015610fc7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610feb91906124e3565b93508060e0015160001461115857805151805173__$8f1afe7577f9ab973017c74eca19b86f3c$__9163890ffb849160009061102957611029612363565b60200260200101518360e001518460a0015185610100015186600001516000015160008151811061105c5761105c612363565b60209081029190910101516040516370a0823160e01b81523060048201526001600160a01b03909116906370a0823190602401602060405180830381865afa1580156110ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110d0919061234a565b6040516001600160e01b031960e088901b1681526001600160a01b03958616600482015260248101949094529390911660448301526064820152608481019190915260a4016040805180830381865af4158015611131573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111559190612500565b50505b73__$8f1afe7577f9ab973017c74eca19b86f3c$__63ac2a37d6826080015183610100015184600001516000015160008151811061119857611198612363565b60200260200101518560000151600001516001815181106111bb576111bb612363565b602002602001015160405180604001604052808860000151604001516000815181106111e9576111e9612363565b6020026020010151815260200188600001516040015160018151811061121157611211612363565b60200260200101518152506040518663ffffffff1660e01b815260040161123c959493929190612524565b600060405180830381865af4158015611259573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526112819190810190612558565b949b949a509850929650505050505050565b60008060008560020b1280156112c45750600285900b836112b4818861259f565b6112be91906125d9565b60020b14155b156112fc57826001816112d78789612600565b6112e1919061259f565b6112eb9190612600565b6112f591906125d9565b915061131f565b82806113088688612600565b611312919061259f565b61131c91906125d9565b91505b8360020b600014611344576113358460026125d9565b61133f9083612625565b61134e565b61134e8383612625565b9050935093915050565b60008115611366578161136b565b620186a05b92915050565b6001600160a01b0381166020860181905260405163124fdbb760e21b8152600481019190915273__$7dde4232fad0cb3c495beb9e735b7d0c63$__9063493f6edc9060240160006040518083038186803b1580156113ce57600080fd5b505af41580156113e2573d6000803e3d6000fd5b505050506113ef82611791565b6060860181905261140090836117b8565b60a0870152608086015260408051600280825260608201835290916020830190803683375050508086528451602086015182519192909160009061144657611446612363565b60200260200101876000015160018151811061146457611464612363565b6001600160a01b0393841660209182029290920101529116905260408051600280825260608201909252908160200160208202803683375050506040860152845180516114ed9185916000919082906114bf576114bf612363565b60200260200101516001600160a01b03166001600160a01b0316815260200190815260200160002054611358565b856040015160008151811061150457611504612363565b60200260200101818152505061152d83600087600001516001815181106114bf576114bf612363565b856040015160018151811061154457611544612363565b6020026020010181815250505050505050565b6000816001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611597573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061136b919061264a565b60008080855160038111156115d2576115d2611ddb565b14611718576001855160038111156115ec576115ec611ddb565b0361164c576020850151518411158061160a57506020850151518311155b1561161b5750600190506002611718565b6020850151604001518410158061163a57506020850151604001518310155b1561164757506001905060035b611718565b60028551600381111561166157611661611ddb565b036116c15760208581015101518410801590611684575060208581015101518310155b156116475760208501516040015160019250841015806116ac57506020850151604001518310155b156116b957506003611718565b506001611718565b60208501516060015184118015906116e157506020850151606001518311155b156117185760208581015101516001925084111580611707575060208581015101518311155b1561171457506002611718565b5060015b8182611725578551611727565b815b91509150935093915050565b6000600182600381111561174957611749611ddb565b1192915050565b6003820154600483015460009161178a918491600160c81b8104600290810b92600160e01b8304820b92600160b01b9004820b910b61191a565b9392505050565b600081516000036117a457506000919050565b8180602001905181019061136b919061234a565b6000808315806117c85750600284145b1561184c57828060200190518101906117e19190612500565b925050670de0b6b3a7640000821115806117fc575060001982145b6040518060400160405280601381526020017254532d333020696e76616c69642076616c756560681b815250906118465760405162461bcd60e51b8152600401610c1e9190612423565b50611913565b60408051808201909152601081526f54532d392077726f6e672076616c756560801b6020820152600185146118945760405162461bcd60e51b8152600401610c1e9190612423565b50828060200190518101906118a99190612667565b909350915050670de0b6b3a7640000821115806118c7575060001982145b6040518060400160405280601381526020017254532d333020696e76616c69642076616c756560681b815250906119115760405162461bcd60e51b8152600401610c1e9190612423565b505b9250929050565b6000600283900b61192b8686612600565b60020b03611954578460020b8660020b128061194d57508360020b8660020b12155b90506119bb565b600060026119628787612600565b61196c919061259f565b9050600061197a8288612625565b90508060020b8860020b136119a157600284900b6119988983612600565b60020b136119b6565b600284900b6119b0828a612600565b60020b12155b925050505b95945050505050565b6040518060c001604052806060815260200160006001600160a01b03168152602001606081526020016000815260200160008152602001600081525090565b604051806101400160405280611a176119c4565b815260006020820181905260408201819052606082018190526080820181905260a0820181905260c0820181905260e0820181905261010082018190526101209091015290565b6001600160a01b0381168114611a7357600080fd5b50565b8035611a8181611a5e565b919050565b60008060008060008060c08789031215611a9f57600080fd5b8635611aaa81611a5e565b9550602087013594506040870135611ac181611a5e565b93506060870135611ad181611a5e565b9598949750929560808101359460a0909101359350915050565b600081518084526020808501945080840160005b83811015611b1b57815187529582019590820190600101611aff565b509495945050505050565b60208152600061178a6020830184611aeb565b8015158114611a7357600080fd5b600080600060608486031215611b5c57600080fd5b833592506020840135611b6e81611b39565b9150604084013560048110611b8257600080fd5b809150509250925092565b634e487b7160e01b600052604160045260246000fd5b6040805190810167ffffffffffffffff81118282101715611bc657611bc6611b8d565b60405290565b604051601f8201601f1916810167ffffffffffffffff81118282101715611bf557611bf5611b8d565b604052919050565b600082601f830112611c0e57600080fd5b813567ffffffffffffffff811115611c2857611c28611b8d565b611c3b601f8201601f1916602001611bcc565b818152846020838601011115611c5057600080fd5b816020850160208301376000918101602001919091529392505050565b600067ffffffffffffffff821115611c8757611c87611b8d565b5060051b60200190565b60008060008060008060c08789031215611caa57600080fd5b8635955060208088013567ffffffffffffffff80821115611cca57600080fd5b611cd68b838c01611bfd565b975060408a0135915080821115611cec57600080fd5b508801601f81018a13611cfe57600080fd5b8035611d11611d0c82611c6d565b611bcc565b81815260059190911b8201830190838101908c831115611d3057600080fd5b928401925b82841015611d4e57833582529284019290840190611d35565b8098505050505050611d6260608801611a76565b9250611d7060808801611a76565b915060a087013590509295509295509295565b8035600281900b8114611a8157600080fd5b60008060008060808587031215611dab57600080fd5b843593506020850135611dbd81611a5e565b9250611dcb60408601611d83565b9396929550929360600135925050565b634e487b7160e01b600052602160045260246000fd5b60048110611e0f57634e487b7160e01b600052602160045260246000fd5b9052565b8315158152821515602082015260608101611e316040830184611df1565b949350505050565b600060208284031215611e4b57600080fd5b5035919050565b600081518084526020808501945080840160005b83811015611b1b5781516001600160a01b031687529582019590820190600101611e66565b608081526000611e9e6080830187611e52565b82810360208481019190915286518083528782019282019060005b81811015611ed857845160020b83529383019391830191600101611eb9565b50508481036040860152611eec8188611aeb565b858103606087015286518082528388019450908301915060005b81811015611f24578451151583529383019391830191600101611f06565b50909998505050505050505050565b806080810183101561136b57600080fd5b60008060008060006101c08688031215611f5d57600080fd5b85359450611f6e8760208801611f33565b9350611f7d8760a08801611f33565b9250610120860135611f8e81611b39565b9150611f9e876101408801611f33565b90509295509295909350565b6000806000806000806101c08789031215611fc457600080fd5b60a0870188811115611fd557600080fd5b879650611fe28982611f33565b95505061012087013567ffffffffffffffff8082111561200157600080fd5b61200d8a838b01611bfd565b955061014089013591508082111561202457600080fd5b5061203189828a01611bfd565b9350508761017f88011261204457600080fd5b61204c611ba3565b806101a089018a81111561205f57600080fd5b6101608a015b8181101561208657803561207881611a5e565b845260209384019301612065565b50819450803593505050509295509295509295565b83151581526060602082015260006120b66060830185611aeb565b9050826040830152949350505050565b6000806000606084860312156120db57600080fd5b6120e484611d83565b92506120f260208501611d83565b915061210060408501611d83565b90509250925092565b8060005b60028110156103a35781516001600160a01b031684526020938401939091019060010161210d565b8060005b60028110156103a3578151845260209384019390910190600101612139565b6001600160a01b03861681526020810185905260e0810161217c6040830186612109565b6121896080830185612135565b8260c08301529695505050505050565b600082601f8301126121aa57600080fd5b815160206121ba611d0c83611c6d565b82815260059290921b840181019181810190868411156121d957600080fd5b8286015b848110156121f457805183529183019183016121dd565b509695505050505050565b60006020828403121561221157600080fd5b815167ffffffffffffffff81111561222857600080fd5b611e3184828501612199565b8281526040810161178a6020830184611df1565b6000610100612257838a612109565b80604084015261226981840189611e52565b9050828103606084015261227d8188611aeb565b905082810360808401526122918187611aeb565b9150508360a08301526122a760c0830184612135565b979650505050505050565b600080604083850312156122c557600080fd5b82516122d081611a5e565b6020939093015192949293505050565b634e487b7160e01b600052601160045260246000fd5b808202811582820484141761136b5761136b6122e0565b634e487b7160e01b600052601260045260246000fd5b6000826123325761233261230d565b500490565b8181038181111561136b5761136b6122e0565b60006020828403121561235c57600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b8082018082111561136b5761136b6122e0565b60006001820161239e5761239e6122e0565b5060010190565b6000602082840312156123b757600080fd5b813561178a81611a5e565b6000602082840312156123d457600080fd5b61178a82611d83565b6000815180845260005b81811015612403576020818501810151868301820152016123e7565b506000602082860101526020601f19601f83011685010191505092915050565b60208152600061178a60208301846123dd565b82815260a0810160808360208401379392505050565b600061018061245b838e612109565b80604084015261246d8184018d611e52565b90508281036060840152612481818c611aeb565b6001600160a01b038b8116608086015260a085018b9052891660c085015283810360e085015290506124b381886123dd565b915050841515610100830152836101208301526124d4610140830184612135565b9b9a5050505050505050505050565b6000602082840312156124f557600080fd5b815161178a81611b39565b6000806040838503121561251357600080fd5b505080516020909101519092909150565b6001600160a01b0386811682526020820186905284811660408301528316606082015260c081016103126080830184612135565b6000806040838503121561256b57600080fd5b82519150602083015167ffffffffffffffff81111561258957600080fd5b61259585828601612199565b9150509250929050565b60008160020b8360020b806125b6576125b661230d565b627fffff198214600019821416156125d0576125d06122e0565b90059392505050565b60008260020b8260020b028060020b91508082146125f9576125f96122e0565b5092915050565b600282810b9082900b03627fffff198112627fffff8213171561136b5761136b6122e0565b600281810b9083900b01627fffff8113627fffff198212171561136b5761136b6122e0565b60006020828403121561265c57600080fd5b815161178a81611a5e565b60008060006060848603121561267c57600080fd5b835192506020840151915060408401519050925092509256fea2646970667358221220aa5b22fa323aced4edee678c6bf4038b3de3ae72f46cd27489feb7ff65bf689d64736f6c63430008110033",
  "libraries": {
    "BorrowLib": "0x158Da3ec4771bC05F4898BBF53141cB773754E7C",
    "ConverterStrategyBaseLib2": "0xc1Ed5dD095C703421F623F416b88bbf57a1E1012",
    "PairBasedStrategyLib": "0x626aB57b826869B8AE32D32487E0AB6405625bb3",
    "StrategyLib2": "0x06c875daA1Dc2E27dd7381EB3b6be4F99553a609"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "_beforeDeposit(ITetuConverter,uint256,address,address,uint256,mapping(address => uint256) storage)": {
        "params": {
          "amount_": "Amount of tokenA",
          "liquidationThresholds": "Dust-thresholds for the tokens A and B",
          "prop0": "Required proportion of underlying, > 0. Proportion of not-underlying is calculates as 1e18 - {prop0}",
          "tokenA": "Underlying",
          "tokenB": "Not-underlying"
        },
        "returns": {
          "tokenAmounts": "Amounts of token A and B to be deposited, [A, B]"
        }
      },
      "getDefaultState(PairBasedStrategyLogicLib.PairState storage)": {
        "returns": {
          "addr": "[tokenA, tokenB, pool, profitHolder]",
          "boolValues": "[isStablePool, depositorSwapTokens]",
          "nums": "[totalLiquidity, fuse-status-tokenA, withdrawDone, 4 thresholds of token A, lastRebalanceNoSwap, 5 reserved values]",
          "tickData": "[tickSpacing, lowerTick, upperTick, rebalanceTickRange]"
        }
      },
      "needStrategyRebalance(PairBasedStrategyLogicLib.PairState storage,ITetuConverter,int24,uint256)": {
        "returns": {
          "needRebalance": "A boolean indicating if {rebalanceNoSwaps} should be called"
        }
      },
      "quoteWithdrawByAgg(PairBasedStrategyLogicLib.PairState storage,bytes,uint256[],address,ITetuConverter,mapping(address => uint256) storage)": {
        "params": {
          "amounts_": "Amounts of [underlying, not-underlying] that will be received from the pool before withdrawing"
        }
      },
      "setInitialDepositorValues(PairBasedStrategyLogicLib.PairState storage,address[4],int24[4],bool,uint256[4])": {
        "params": {
          "addr": "[pool, asset, pool.token0(), pool.token1()]        asset: Underlying asset of the depositor.",
          "fuseThresholds": "Fuse thresholds for tokens (stable pool only)",
          "pairState": "Depositor storage state struct to be initialized",
          "tickData": "[tickSpacing, lowerTick, upperTick, rebalanceTickRange]"
        }
      },
      "withdrawByAggStep(address[5],uint256[4],bytes,bytes,address[2],mapping(address => uint256) storage)": {
        "params": {
          "addr_": "[tokenToSwap, aggregator, controller, converter, splitter]",
          "tokens": "[underlying, not-underlying] (values been read from pairBase)",
          "values_": "[amountToSwap_, profitToCover, oldTotalAssets, not used here]"
        },
        "returns": {
          "completed": "All debts were closed, leftovers were swapped to proper proportions",
          "tokenAmounts": "Amounts to be deposited to pool. If {tokenAmounts} contains zero amount return empty array."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "_beforeDeposit(ITetuConverter,uint256,address,address,uint256,mapping(address => uint256) storage)": {
        "notice": "Prepare array of amounts ready to deposit, borrow missed amounts"
      },
      "getDefaultState(PairBasedStrategyLogicLib.PairState storage)": {
        "notice": "Returns the current state of the contract"
      },
      "needStrategyRebalance(PairBasedStrategyLogicLib.PairState storage,ITetuConverter,int24,uint256)": {
        "notice": "Determine if the strategy needs to be rebalanced."
      },
      "quoteWithdrawByAgg(PairBasedStrategyLogicLib.PairState storage,bytes,uint256[],address,ITetuConverter,mapping(address => uint256) storage)": {
        "notice": "Get info about a swap required by next call of {withdrawByAggStep} within the given plan"
      },
      "setInitialDepositorValues(PairBasedStrategyLogicLib.PairState storage,address[4],int24[4],bool,uint256[4])": {
        "notice": "Set the initial values to PairState instance"
      },
      "withdrawByAggStep(address[5],uint256[4],bytes,bytes,address[2],mapping(address => uint256) storage)": {
        "notice": "Calculate amounts to be deposited to pool, calculate loss, fix profitToCover"
      }
    },
    "notice": "Library for the UniV3-like strategies with two tokens in the pool",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}