{
  "address": "0x4b85477DB323cb8D650e6179A4d002b09720952c",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        },
        {
          "internalType": "int24",
          "name": "lowerTick_",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick_",
          "type": "int24"
        },
        {
          "internalType": "uint256",
          "name": "amount0Desired_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1Desired_",
          "type": "uint256"
        }
      ],
      "name": "addLiquidityPreview",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount0Consumed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1Consumed",
          "type": "uint256"
        },
        {
          "internalType": "uint128",
          "name": "liquidityOut",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtRatioX96",
          "type": "uint160"
        },
        {
          "internalType": "int24",
          "name": "lowerTick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick",
          "type": "int24"
        },
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "name": "getAmountsForLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IAlgebraPool",
          "name": "pool",
          "type": "IAlgebraPool"
        },
        {
          "internalType": "contract INonfungiblePositionManager",
          "name": "nft",
          "type": "INonfungiblePositionManager"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getFees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "fee0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "fee1",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtRatioX96",
          "type": "uint160"
        },
        {
          "internalType": "int24",
          "name": "lowerTick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick",
          "type": "int24"
        },
        {
          "internalType": "uint256",
          "name": "amount0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1",
          "type": "uint256"
        }
      ],
      "name": "getLiquidityForAmounts",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "a",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "b",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "denominator",
          "type": "uint256"
        }
      ],
      "name": "mulDiv",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "result",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tickSpacing",
      "outputs": [
        {
          "internalType": "int24",
          "name": "",
          "type": "int24"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x277fd2b908768d6dfa376a29d8549a55d09df8878800300a57d539e234bf490f",
  "receipt": {
    "to": null,
    "from": "0xF1dCce3a6c321176C62b71c091E3165CC9C3816E",
    "contractAddress": "0x4b85477DB323cb8D650e6179A4d002b09720952c",
    "transactionIndex": 105,
    "gasUsed": "1509202",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000040000000000000000000000080000000080000000004000040000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004200000000000000000001000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000100000",
    "blockHash": "0x670f35a8681aed9a198a13d9986d442f515ce7a6c0cabc6af48afcd1c71d27f8",
    "transactionHash": "0x277fd2b908768d6dfa376a29d8549a55d09df8878800300a57d539e234bf490f",
    "logs": [
      {
        "transactionIndex": 105,
        "blockNumber": 52237336,
        "transactionHash": "0x277fd2b908768d6dfa376a29d8549a55d09df8878800300a57d539e234bf490f",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000f1dcce3a6c321176c62b71c091e3165cc9c3816e",
          "0x00000000000000000000000090b11143a0cb64e067402307bc7f2276dcec8250"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000080aeab5a80e000000000000000000000000000000000000000000000000018b6c21d80e86810000000000000000000000000000000000000000000000006650cf01991c3b9f450000000000000000000000000000000000000000000000018b6416ed58de730000000000000000000000000000000000000000000000006650d70c83d1e3ad45",
        "logIndex": 503,
        "blockHash": "0x670f35a8681aed9a198a13d9986d442f515ce7a6c0cabc6af48afcd1c71d27f8"
      }
    ],
    "blockNumber": 52237336,
    "cumulativeGasUsed": "21315629",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 6,
  "solcInputHash": "da1a131c81810b0ec86f8a1b7470ae1a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"lowerTick_\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick_\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"amount0Desired_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Desired_\",\"type\":\"uint256\"}],\"name\":\"addLiquidityPreview\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Consumed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Consumed\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"liquidityOut\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtRatioX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"name\":\"getAmountsForLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAlgebraPool\",\"name\":\"pool\",\"type\":\"IAlgebraPool\"},{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"nft\",\"type\":\"INonfungiblePositionManager\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtRatioX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"getLiquidityForAmounts\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tickSpacing\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getPrice(address,address)\":{\"returns\":{\"_0\":\"price with decimals of paired token\"}},\"mulDiv(uint256,uint256,uint256)\":{\"details\":\"Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\",\"params\":{\"a\":\"The multiplicand\",\"b\":\"The multiplier\",\"denominator\":\"The divisor\"},\"returns\":{\"result\":\"The 256-bit result\"}}},\"stateVariables\":{\"MAX_SQRT_RATIO\":{\"details\":\"The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\"},\"MAX_TICK\":{\"details\":\"The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\"},\"MIN_SQRT_RATIO\":{\"details\":\"The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\"},\"MIN_TICK\":{\"details\":\"The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAmountsForLiquidity(uint160,int24,int24,uint128)\":{\"notice\":\"Computes the token0 and token1 value for a given amount of liquidity, the current pool prices and the prices at the tick boundaries\"},\"getLiquidityForAmounts(uint160,int24,int24,uint256,uint256)\":{\"notice\":\"Computes the maximum amount of liquidity received for a given amount of token0, token1, the current pool prices and the prices at the tick boundaries\"},\"getPrice(address,address)\":{\"notice\":\"Calculates price in pool\"},\"mulDiv(uint256,uint256,uint256)\":{\"notice\":\"Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/algebra/AlgebraLib.sol\":\"AlgebraLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x5f43ed533d0fc4dc2f8f081d2c4b77960f3e908d5f7359096b385e5673f1ba0c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n     */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n     */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n     */\\n  function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x953f20efa64081a325109a0e03602b889d2819c2b51c1e1fb21a062feeda74f3\",\"license\":\"MIT\"},\"contracts/integrations/algebra/AlgebraFeeConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n// coefficients for sigmoids: \\u03b1 / (1 + e^( (\\u03b2-x) / \\u03b3))\\r\\n// alpha1 + alpha2 + baseFee must be <= type(uint16).max\\r\\nstruct AlgebraFeeConfiguration {\\r\\n  uint16 alpha1; // max value of the first sigmoid\\r\\n  uint16 alpha2; // max value of the second sigmoid\\r\\n  uint32 beta1; // shift along the x-axis for the first sigmoid\\r\\n  uint32 beta2; // shift along the x-axis for the second sigmoid\\r\\n  uint16 gamma1; // horizontal stretch factor for the first sigmoid\\r\\n  uint16 gamma2; // horizontal stretch factor for the second sigmoid\\r\\n  uint16 baseFee; // minimum possible fee\\r\\n}\\r\\n\",\"keccak256\":\"0x49cf3f76051c467d50c8640e4be6bf4491469149714d8ab3fda54c7b3dd10c59\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IAlgebraEternalFarming.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IncentiveKey.sol\\\";\\r\\n\\r\\ninterface IAlgebraEternalFarming {\\r\\n    /// @notice reward amounts can be outdated, actual amounts could be obtained via static call of `collectRewards` in FarmingCenter\\r\\n    function getRewardInfo(\\r\\n        IncentiveKey memory key,\\r\\n        uint256 tokenId\\r\\n    ) external view returns (uint256 reward, uint256 bonusReward);\\r\\n}\",\"keccak256\":\"0x48f100e8fed01242ec72231b385b82fd1146929630dc73532b21a5a46f841ada\",\"license\":\"MIT\"},\"contracts/integrations/algebra/IAlgebraPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nimport './pool/IAlgebraPoolImmutables.sol';\\r\\nimport './pool/IAlgebraPoolState.sol';\\r\\nimport './pool/IAlgebraPoolDerivedState.sol';\\r\\nimport './pool/IAlgebraPoolActions.sol';\\r\\nimport './pool/IAlgebraPoolPermissionedActions.sol';\\r\\nimport './pool/IAlgebraPoolEvents.sol';\\r\\n\\r\\n/**\\r\\n * @title The interface for a Algebra Pool\\r\\n * @dev The pool interface is broken up into many smaller pieces.\\r\\n * Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\n */\\r\\ninterface IAlgebraPool is\\r\\nIAlgebraPoolImmutables,\\r\\nIAlgebraPoolState,\\r\\nIAlgebraPoolDerivedState,\\r\\nIAlgebraPoolActions,\\r\\nIAlgebraPoolPermissionedActions,\\r\\nIAlgebraPoolEvents\\r\\n{\\r\\n  // used only for combining interfaces\\r\\n}\\r\\n\",\"keccak256\":\"0xf55d012b8f05dacd31f6a275e5cdb57c231e4ea79dac4010a0a81d38942d04f3\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IDataStorageOperator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport './AlgebraFeeConfiguration.sol';\\r\\n\\r\\n/// @title The interface for the DataStorageOperator\\r\\n/// @dev This contract stores timepoints and calculates adaptive fee and statistical averages\\r\\ninterface IDataStorageOperator {\\r\\n  /// @notice Emitted when the fee configuration is changed\\r\\n  /// @param feeConfig The structure with dynamic fee parameters\\r\\n  /// @dev See the AdaptiveFee library for more details\\r\\n  event FeeConfiguration(AlgebraFeeConfiguration feeConfig);\\r\\n\\r\\n  /// @notice Returns data belonging to a certain timepoint\\r\\n  /// @param index The index of timepoint in the array\\r\\n  /// @dev There is more convenient function to fetch a timepoint: getTimepoints(). Which requires not an index but seconds\\r\\n  /// @return initialized Whether the timepoint has been initialized and the values are safe to use\\r\\n  /// @return blockTimestamp The timestamp of the timepoint\\r\\n  /// @return tickCumulative The tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp\\r\\n  /// @return volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp\\r\\n  /// @return tick The tick at blockTimestamp\\r\\n  /// @return averageTick Time-weighted average tick\\r\\n  /// @return windowStartIndex Index of closest timepoint >= WINDOW seconds ago\\r\\n  function timepoints(\\r\\n    uint256 index\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      bool initialized,\\r\\n      uint32 blockTimestamp,\\r\\n      int56 tickCumulative,\\r\\n      uint88 volatilityCumulative,\\r\\n      int24 tick,\\r\\n      int24 averageTick,\\r\\n      uint16 windowStartIndex\\r\\n    );\\r\\n\\r\\n  /// @notice Initialize the dataStorage array by writing the first slot. Called once for the lifecycle of the timepoints array\\r\\n  /// @param time The time of the dataStorage initialization, via block.timestamp truncated to uint32\\r\\n  /// @param tick Initial tick\\r\\n  function initialize(uint32 time, int24 tick) external;\\r\\n\\r\\n  /// @dev Reverts if a timepoint at or before the desired timepoint timestamp does not exist.\\r\\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\\r\\n  /// If called with a timestamp falling between two timepoints, returns the counterfactual accumulator values\\r\\n  /// at exactly the timestamp between the two timepoints.\\r\\n  /// @param time The current block timestamp\\r\\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return a timepoint\\r\\n  /// @param tick The current tick\\r\\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\\r\\n  /// @return tickCumulative The cumulative tick since the pool was first initialized, as of `secondsAgo`\\r\\n  /// @return volatilityCumulative The cumulative volatility value since the pool was first initialized, as of `secondsAgo`\\r\\n  function getSingleTimepoint(\\r\\n    uint32 time,\\r\\n    uint32 secondsAgo,\\r\\n    int24 tick,\\r\\n    uint16 index\\r\\n  ) external view returns (int56 tickCumulative, uint112 volatilityCumulative);\\r\\n\\r\\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\\r\\n  /// @dev Reverts if `secondsAgos` > oldest timepoint\\r\\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return a timepoint\\r\\n  /// @return tickCumulatives The cumulative tick since the pool was first initialized, as of each `secondsAgo`\\r\\n  /// @return volatilityCumulatives The cumulative volatility values since the pool was first initialized, as of each `secondsAgo`\\r\\n  function getTimepoints(uint32[] memory secondsAgos) external view returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives);\\r\\n\\r\\n  /// @notice Writes a dataStorage timepoint to the array\\r\\n  /// @dev Writable at most once per block. Index represents the most recently written element. index must be tracked externally.\\r\\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\\r\\n  /// @param blockTimestamp The timestamp of the new timepoint\\r\\n  /// @param tick The active tick at the time of the new timepoint\\r\\n  /// @return indexUpdated The new index of the most recently written element in the dataStorage array\\r\\n  /// @return newFee The fee in hundredths of a bip, i.e. 1e-6\\r\\n  function write(uint16 index, uint32 blockTimestamp, int24 tick) external returns (uint16 indexUpdated, uint16 newFee);\\r\\n\\r\\n  /// @notice Changes fee configuration for the pool\\r\\n  function changeFeeConfiguration(AlgebraFeeConfiguration calldata feeConfig) external;\\r\\n\\r\\n  /// @notice Fills uninitialized timepoints with nonzero value\\r\\n  /// @dev Can be used to reduce the gas cost of future swaps\\r\\n  /// @param startIndex The start index, must be not initialized\\r\\n  /// @param amount of slots to fill, startIndex + amount must be <= type(uint16).max\\r\\n  function prepayTimepointsStorageSlots(uint16 startIndex, uint16 amount) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x758fd0079dd315ce0c5ac9ee1b6bee96ea377b471a22367f6bae10c2b0011713\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IFarmingCenter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IAlgebraEternalFarming.sol\\\";\\r\\nimport \\\"./IncentiveKey.sol\\\";\\r\\nimport \\\"./INonfungiblePositionManager.sol\\\";\\r\\n\\r\\ninterface IFarmingCenter {\\r\\n    /// @notice Returns information about a deposited NFT\\r\\n    /// @param tokenId The ID of the deposit (and token) that is being transferred\\r\\n    /// @return L2TokenId The nft layer2 id,\\r\\n    /// numberOfFarms The number of farms,\\r\\n    /// inLimitFarming The parameter showing if the token is in the limit farm,\\r\\n    /// owner The owner of deposit\\r\\n    function deposits(uint256 tokenId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n        uint256 L2TokenId,\\r\\n        uint32 numberOfFarms,\\r\\n        bool inLimitFarming,\\r\\n        address owner\\r\\n    );\\r\\n\\r\\n    /// @notice Enters in incentive (time-limited or eternal farming) with NFT-position token\\r\\n    /// @dev token must be deposited in FarmingCenter\\r\\n    /// @param key The incentive event key\\r\\n    /// @param tokenId The id of position NFT\\r\\n    /// @param tokensLocked Amount of tokens to lock for liquidity multiplier (if tiers are used)\\r\\n    /// @param isLimit Is incentive time-limited or eternal\\r\\n    function enterFarming(\\r\\n        IncentiveKey memory key,\\r\\n        uint256 tokenId,\\r\\n        uint256 tokensLocked,\\r\\n        bool isLimit\\r\\n    ) external;\\r\\n\\r\\n    function eternalFarming() external view returns (IAlgebraEternalFarming);\\r\\n\\r\\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\\r\\n    /// @dev \\\"proxies\\\" to NonfungiblePositionManager\\r\\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\\r\\n    /// recipient The account that should receive the tokens,\\r\\n    /// amount0Max The maximum amount of token0 to collect,\\r\\n    /// amount1Max The maximum amount of token1 to collect\\r\\n    /// @return amount0 The amount of fees collected in token0\\r\\n    /// @return amount1 The amount of fees collected in token1\\r\\n    function collect(INonfungiblePositionManager.CollectParams calldata params)\\r\\n    external\\r\\n    returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    /// @notice Used to collect reward from eternal farming. Then reward can be claimed.\\r\\n    /// @param key The incentive event key\\r\\n    /// @param tokenId The id of position NFT\\r\\n    /// @return reward The amount of collected reward\\r\\n    /// @return bonusReward The amount of collected  bonus reward\\r\\n    function collectRewards(IncentiveKey memory key, uint256 tokenId)\\r\\n    external\\r\\n    returns (uint256 reward, uint256 bonusReward);\\r\\n\\r\\n    /// @notice Used to claim and send rewards from farming(s)\\r\\n    /// @dev can be used via static call to get current rewards for user\\r\\n    /// @param rewardToken The token that is a reward\\r\\n    /// @param to The address to be rewarded\\r\\n    /// @param amountRequestedIncentive Amount to claim in incentive (limit) farming\\r\\n    /// @param amountRequestedEternal Amount to claim in eternal farming\\r\\n    /// @return reward The summary amount of claimed rewards\\r\\n    function claimReward(\\r\\n        address rewardToken,\\r\\n        address to,\\r\\n        uint256 amountRequestedIncentive,\\r\\n        uint256 amountRequestedEternal\\r\\n    ) external returns (uint256 reward);\\r\\n\\r\\n    /// @notice Exits from incentive (time-limited or eternal farming) with NFT-position token\\r\\n    /// @param key The incentive event key\\r\\n    /// @param tokenId The id of position NFT\\r\\n    /// @param isLimit Is incentive time-limited or eternal\\r\\n    function exitFarming(\\r\\n        IncentiveKey memory key,\\r\\n        uint256 tokenId,\\r\\n        bool isLimit\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Withdraw Algebra NFT-position token\\r\\n    /// @dev can be used via static call to get current rewards for user\\r\\n    /// @param tokenId The id of position NFT\\r\\n    /// @param to New owner of position NFT\\r\\n    /// @param data The additional data for NonfungiblePositionManager\\r\\n    function withdrawToken(\\r\\n        uint256 tokenId,\\r\\n        address to,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n}\",\"keccak256\":\"0x63723e96d5493b985517506518f62d55619e05a86ce1c03bf2d5e8d4811337ba\",\"license\":\"MIT\"},\"contracts/integrations/algebra/INonfungiblePositionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface INonfungiblePositionManager {\\r\\n    struct MintParams {\\r\\n        address token0;\\r\\n        address token1;\\r\\n        int24 tickLower;\\r\\n        int24 tickUpper;\\r\\n        uint amount0Desired;\\r\\n        uint amount1Desired;\\r\\n        uint amount0Min;\\r\\n        uint amount1Min;\\r\\n        address recipient;\\r\\n        uint deadline;\\r\\n    }\\r\\n\\r\\n    function mint(\\r\\n        MintParams calldata params\\r\\n    ) external payable returns (uint tokenId, uint128 liquidity, uint amount0, uint amount1);\\r\\n\\r\\n    struct IncreaseLiquidityParams {\\r\\n        uint256 tokenId;\\r\\n        uint256 amount0Desired;\\r\\n        uint256 amount1Desired;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n        uint128 liquidity,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1\\r\\n    );\\r\\n\\r\\n    struct DecreaseLiquidityParams {\\r\\n        uint tokenId;\\r\\n        uint128 liquidity;\\r\\n        uint amount0Min;\\r\\n        uint amount1Min;\\r\\n        uint deadline;\\r\\n    }\\r\\n\\r\\n    function decreaseLiquidity(\\r\\n        DecreaseLiquidityParams calldata params\\r\\n    ) external payable returns (uint amount0, uint amount1);\\r\\n\\r\\n    struct CollectParams {\\r\\n        uint tokenId;\\r\\n        address recipient;\\r\\n        uint128 amount0Max;\\r\\n        uint128 amount1Max;\\r\\n    }\\r\\n\\r\\n    function collect(CollectParams calldata params) external payable returns (uint amount0, uint amount1);\\r\\n\\r\\n    function burn(uint tokenId) external payable;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function positions(uint256 tokenId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n        uint96 nonce,\\r\\n        address operator,\\r\\n        address token0,\\r\\n        address token1,\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 liquidity,\\r\\n        uint256 feeGrowthInside0LastX128,\\r\\n        uint256 feeGrowthInside1LastX128,\\r\\n        uint128 tokensOwed0,\\r\\n        uint128 tokensOwed1\\r\\n    );\\r\\n}\",\"keccak256\":\"0x605540fd12c6e7645d7015b0f3303a375a848d028f28ab911d74de6c006e9140\",\"license\":\"MIT\"},\"contracts/integrations/algebra/IncentiveKey.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nstruct IncentiveKey {\\r\\n    address rewardToken;\\r\\n    address bonusRewardToken;\\r\\n    address pool;\\r\\n    uint256 startTime;\\r\\n    uint256 endTime;\\r\\n}\",\"keccak256\":\"0x6aa9017a64134f0ffe6b17049b8811c768641c9daf122ded2ecfcf338d13d7d7\",\"license\":\"MIT\"},\"contracts/integrations/algebra/pool/IAlgebraPoolActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title Permissionless pool actions\\r\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\ninterface IAlgebraPoolActions {\\r\\n  /**\\r\\n   * @notice Sets the initial price for the pool\\r\\n   * @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\r\\n   * @param price the initial sqrt price of the pool as a Q64.96\\r\\n   */\\r\\n  function initialize(uint160 price) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Adds liquidity for the given recipient/bottomTick/topTick position\\r\\n   * @dev The caller of this method receives a callback in the form of IAlgebraMintCallback# AlgebraMintCallback\\r\\n   * in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\r\\n   * on bottomTick, topTick, the amount of liquidity, and the current price.\\r\\n   * @param sender The address which will receive potential surplus of paid tokens\\r\\n   * @param recipient The address for which the liquidity will be created\\r\\n   * @param bottomTick The lower tick of the position in which to add liquidity\\r\\n   * @param topTick The upper tick of the position in which to add liquidity\\r\\n   * @param amount The desired amount of liquidity to mint\\r\\n   * @param data Any data that should be passed through to the callback\\r\\n   * @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\r\\n   * @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\r\\n   * @return liquidityActual The actual minted amount of liquidity\\r\\n   */\\r\\n  function mint(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    int24 bottomTick,\\r\\n    int24 topTick,\\r\\n    uint128 amount,\\r\\n    bytes calldata data\\r\\n  )\\r\\n  external\\r\\n  returns (\\r\\n    uint256 amount0,\\r\\n    uint256 amount1,\\r\\n    uint128 liquidityActual\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Collects tokens owed to a position\\r\\n   * @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\r\\n   * Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\r\\n   * amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\r\\n   * actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\r\\n   * @param recipient The address which should receive the fees collected\\r\\n   * @param bottomTick The lower tick of the position for which to collect fees\\r\\n   * @param topTick The upper tick of the position for which to collect fees\\r\\n   * @param amount0Requested How much token0 should be withdrawn from the fees owed\\r\\n   * @param amount1Requested How much token1 should be withdrawn from the fees owed\\r\\n   * @return amount0 The amount of fees collected in token0\\r\\n   * @return amount1 The amount of fees collected in token1\\r\\n   */\\r\\n  function collect(\\r\\n    address recipient,\\r\\n    int24 bottomTick,\\r\\n    int24 topTick,\\r\\n    uint128 amount0Requested,\\r\\n    uint128 amount1Requested\\r\\n  ) external returns (uint128 amount0, uint128 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\r\\n   * @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\r\\n   * @dev Fees must be collected separately via a call to #collect\\r\\n   * @param bottomTick The lower tick of the position for which to burn liquidity\\r\\n   * @param topTick The upper tick of the position for which to burn liquidity\\r\\n   * @param amount How much liquidity to burn\\r\\n   * @return amount0 The amount of token0 sent to the recipient\\r\\n   * @return amount1 The amount of token1 sent to the recipient\\r\\n   */\\r\\n  function burn(\\r\\n    int24 bottomTick,\\r\\n    int24 topTick,\\r\\n    uint128 amount\\r\\n  ) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Swap token0 for token1, or token1 for token0\\r\\n   * @dev The caller of this method receives a callback in the form of IAlgebraSwapCallback# AlgebraSwapCallback\\r\\n   * @param recipient The address to receive the output of the swap\\r\\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\\r\\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\r\\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\r\\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\\r\\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\\r\\n   * SwapRouter#SwapCallbackData\\r\\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\r\\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\r\\n   */\\r\\n  function swap(\\r\\n    address recipient,\\r\\n    bool zeroToOne,\\r\\n    int256 amountSpecified,\\r\\n    uint160 limitSqrtPrice,\\r\\n    bytes calldata data\\r\\n  ) external returns (int256 amount0, int256 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Swap token0 for token1, or token1 for token0 (tokens that have fee on transfer)\\r\\n   * @dev The caller of this method receives a callback in the form of I AlgebraSwapCallback# AlgebraSwapCallback\\r\\n   * @param sender The address called this function (Comes from the Router)\\r\\n   * @param recipient The address to receive the output of the swap\\r\\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\\r\\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\r\\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\r\\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\\r\\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\\r\\n   * SwapRouter#SwapCallbackData\\r\\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\r\\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\r\\n   */\\r\\n  function swapSupportingFeeOnInputTokens(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    bool zeroToOne,\\r\\n    int256 amountSpecified,\\r\\n    uint160 limitSqrtPrice,\\r\\n    bytes calldata data\\r\\n  ) external returns (int256 amount0, int256 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\r\\n   * @dev The caller of this method receives a callback in the form of IAlgebraFlashCallback# AlgebraFlashCallback\\r\\n   * @dev All excess tokens paid in the callback are distributed to liquidity providers as an additional fee. So this method can be used\\r\\n   * to donate underlying tokens to currently in-range liquidity providers by calling with 0 amount{0,1} and sending\\r\\n   * the donation amount(s) from the callback\\r\\n   * @param recipient The address which will receive the token0 and token1 amounts\\r\\n   * @param amount0 The amount of token0 to send\\r\\n   * @param amount1 The amount of token1 to send\\r\\n   * @param data Any data to be passed through to the callback\\r\\n   */\\r\\n  function flash(\\r\\n    address recipient,\\r\\n    uint256 amount0,\\r\\n    uint256 amount1,\\r\\n    bytes calldata data\\r\\n  ) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xdab29d9ea949c29ef153b523fcd821e93eed2ec4787ed57aec4bb507ef25a1dd\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolDerivedState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/**\\r\\n * @title Pool state that is not stored\\r\\n * @notice Contains view functions to provide information about the pool that is computed rather than stored on the\\r\\n * blockchain. The functions here may have variable gas costs.\\r\\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\n */\\r\\ninterface IAlgebraPoolDerivedState {\\r\\n  /**\\r\\n   * @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\r\\n   * @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\r\\n   * the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\r\\n   * you must call it with secondsAgos = [3600, 0].\\r\\n   * @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\r\\n   * log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\r\\n   * @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\r\\n   * @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\r\\n   * @return secondsPerLiquidityCumulatives Cumulative seconds per liquidity-in-range value as of each `secondsAgos`\\r\\n   * from the current block timestamp\\r\\n   * @return volatilityCumulatives Cumulative standard deviation as of each `secondsAgos`\\r\\n   * @return volumePerAvgLiquiditys Cumulative swap volume per liquidity as of each `secondsAgos`\\r\\n   */\\r\\n  function getTimepoints(uint32[] calldata secondsAgos)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    int56[] memory tickCumulatives,\\r\\n    uint160[] memory secondsPerLiquidityCumulatives,\\r\\n    uint112[] memory volatilityCumulatives,\\r\\n    uint256[] memory volumePerAvgLiquiditys\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\\r\\n   * @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\\r\\n   * I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\\r\\n   * snapshot is taken and the second snapshot is taken.\\r\\n   * @param bottomTick The lower tick of the range\\r\\n   * @param topTick The upper tick of the range\\r\\n   * @return innerTickCumulative The snapshot of the tick accumulator for the range\\r\\n   * @return innerSecondsSpentPerLiquidity The snapshot of seconds per liquidity for the range\\r\\n   * @return innerSecondsSpent The snapshot of the number of seconds during which the price was in this range\\r\\n   */\\r\\n  function getInnerCumulatives(int24 bottomTick, int24 topTick)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    int56 innerTickCumulative,\\r\\n    uint160 innerSecondsSpentPerLiquidity,\\r\\n    uint32 innerSecondsSpent\\r\\n  );\\r\\n}\\r\\n\",\"keccak256\":\"0x5fee0d693dad3af5000fbc1274faeb53f2903c7de518d570808b8337014d17af\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolEvents.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title Events emitted by a pool\\r\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\ninterface IAlgebraPoolEvents {\\r\\n  /**\\r\\n   * @notice Emitted exactly once by a pool when #initialize is first called on the pool\\r\\n   * @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\r\\n   * @param price The initial sqrt price of the pool, as a Q64.96\\r\\n   * @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\\r\\n   */\\r\\n  event Initialize(uint160 price, int24 tick);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when liquidity is minted for a given position\\r\\n   * @param sender The address that minted the liquidity\\r\\n   * @param owner The owner of the position and recipient of any minted liquidity\\r\\n   * @param bottomTick The lower tick of the position\\r\\n   * @param topTick The upper tick of the position\\r\\n   * @param liquidityAmount The amount of liquidity minted to the position range\\r\\n   * @param amount0 How much token0 was required for the minted liquidity\\r\\n   * @param amount1 How much token1 was required for the minted liquidity\\r\\n   */\\r\\n  event Mint(\\r\\n    address sender,\\r\\n    address indexed owner,\\r\\n    int24 indexed bottomTick,\\r\\n    int24 indexed topTick,\\r\\n    uint128 liquidityAmount,\\r\\n    uint256 amount0,\\r\\n    uint256 amount1\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when fees are collected by the owner of a position\\r\\n   * @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\\r\\n   * @param owner The owner of the position for which fees are collected\\r\\n   * @param recipient The address that received fees\\r\\n   * @param bottomTick The lower tick of the position\\r\\n   * @param topTick The upper tick of the position\\r\\n   * @param amount0 The amount of token0 fees collected\\r\\n   * @param amount1 The amount of token1 fees collected\\r\\n   */\\r\\n  event Collect(address indexed owner, address recipient, int24 indexed bottomTick, int24 indexed topTick, uint128 amount0, uint128 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when a position's liquidity is removed\\r\\n   * @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\\r\\n   * @param owner The owner of the position for which liquidity is removed\\r\\n   * @param bottomTick The lower tick of the position\\r\\n   * @param topTick The upper tick of the position\\r\\n   * @param liquidityAmount The amount of liquidity to remove\\r\\n   * @param amount0 The amount of token0 withdrawn\\r\\n   * @param amount1 The amount of token1 withdrawn\\r\\n   */\\r\\n  event Burn(address indexed owner, int24 indexed bottomTick, int24 indexed topTick, uint128 liquidityAmount, uint256 amount0, uint256 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted by the pool for any swaps between token0 and token1\\r\\n   * @param sender The address that initiated the swap call, and that received the callback\\r\\n   * @param recipient The address that received the output of the swap\\r\\n   * @param amount0 The delta of the token0 balance of the pool\\r\\n   * @param amount1 The delta of the token1 balance of the pool\\r\\n   * @param price The sqrt(price) of the pool after the swap, as a Q64.96\\r\\n   * @param liquidity The liquidity of the pool after the swap\\r\\n   * @param tick The log base 1.0001 of price of the pool after the swap\\r\\n   */\\r\\n  event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 price, uint128 liquidity, int24 tick);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted by the pool for any flashes of token0/token1\\r\\n   * @param sender The address that initiated the swap call, and that received the callback\\r\\n   * @param recipient The address that received the tokens from flash\\r\\n   * @param amount0 The amount of token0 that was flashed\\r\\n   * @param amount1 The amount of token1 that was flashed\\r\\n   * @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\\r\\n   * @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\\r\\n   */\\r\\n  event Flash(address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when the community fee is changed by the pool\\r\\n   * @param communityFee0New The updated value of the token0 community fee percent\\r\\n   * @param communityFee1New The updated value of the token1 community fee percent\\r\\n   */\\r\\n  event CommunityFee(uint8 communityFee0New, uint8 communityFee1New);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when new activeIncentive is set\\r\\n   * @param virtualPoolAddress The address of a virtual pool associated with the current active incentive\\r\\n   */\\r\\n  event Incentive(address indexed virtualPoolAddress);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when the fee changes\\r\\n   * @param fee The value of the token fee\\r\\n   */\\r\\n  event Fee(uint16 fee);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when the LiquidityCooldown changes\\r\\n   * @param liquidityCooldown The value of locktime for added liquidity\\r\\n   */\\r\\n  event LiquidityCooldown(uint32 liquidityCooldown);\\r\\n}\\r\\n\",\"keccak256\":\"0x8bcfbec86863b5b57cdb0db3b9c24fb7ab496d48af8422dc05556105131fff98\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolImmutables.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nimport '../IDataStorageOperator.sol';\\r\\n\\r\\n/// @title Pool state that never changes\\r\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\ninterface IAlgebraPoolImmutables {\\r\\n  /**\\r\\n   * @notice The contract that stores all the timepoints and can perform actions with them\\r\\n   * @return The operator address\\r\\n   */\\r\\n  function dataStorageOperator() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice The contract that deployed the pool, which must adhere to the IAlgebraFactory interface\\r\\n   * @return The contract address\\r\\n   */\\r\\n  function factory() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice The first of the two tokens of the pool, sorted by address\\r\\n   * @return The token contract address\\r\\n   */\\r\\n  function token0() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice The second of the two tokens of the pool, sorted by address\\r\\n   * @return The token contract address\\r\\n   */\\r\\n  function token1() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice The pool tick spacing\\r\\n   * @dev Ticks can only be used at multiples of this value\\r\\n   * e.g.: a tickSpacing of 60 means ticks can be initialized every 60th tick, i.e., ..., -120, -60, 0, 60, 120, ...\\r\\n   * This value is an int24 to avoid casting even though it is always positive.\\r\\n   * @return The tick spacing\\r\\n   */\\r\\n  function tickSpacing() external view returns (int24);\\r\\n\\r\\n  /**\\r\\n   * @notice The maximum amount of position liquidity that can use any tick in the range\\r\\n   * @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\r\\n   * also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\r\\n   * @return The max amount of liquidity per tick\\r\\n   */\\r\\n  function maxLiquidityPerTick() external view returns (uint128);\\r\\n}\\r\\n\",\"keccak256\":\"0x9a1ad90c7909c3ae47eef7e893f720e9ac4a73fae3d49cb7b12db95865dbb848\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolPermissionedActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/**\\r\\n * @title Permissioned pool actions\\r\\n * @notice Contains pool methods that may only be called by the factory owner or tokenomics\\r\\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\n */\\r\\ninterface IAlgebraPoolPermissionedActions {\\r\\n  /**\\r\\n   * @notice Set the community's % share of the fees. Cannot exceed 25% (250)\\r\\n   * @param communityFee0 new community fee percent for token0 of the pool in thousandths (1e-3)\\r\\n   * @param communityFee1 new community fee percent for token1 of the pool in thousandths (1e-3)\\r\\n   */\\r\\n  function setCommunityFee(uint8 communityFee0, uint8 communityFee1) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Sets an active incentive\\r\\n   * @param virtualPoolAddress The address of a virtual pool associated with the incentive\\r\\n   */\\r\\n  function setIncentive(address virtualPoolAddress) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Sets new lock time for added liquidity\\r\\n   * @param newLiquidityCooldown The time in seconds\\r\\n   */\\r\\n  function setLiquidityCooldown(uint32 newLiquidityCooldown) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xaf4720ba8ac271e56d80b101b051dc4301b60f6fc8004407d9ec714131e200a1\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title Pool state that can change\\r\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\ninterface IAlgebraPoolState {\\r\\n  /**\\r\\n   * @notice The globalState structure in the pool stores many values but requires only one slot\\r\\n   * and is exposed as a single method to save gas when accessed externally.\\r\\n   * @return price The current price of the pool as a sqrt(token1/token0) Q64.96 value;\\r\\n   * Returns tick The current tick of the pool, i.e. according to the last tick transition that was run;\\r\\n   * Returns This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick\\r\\n   * boundary;\\r\\n   * Returns fee The last pool fee value in hundredths of a bip, i.e. 1e-6;\\r\\n   * Returns timepointIndex The index of the last written timepoint;\\r\\n   * Returns communityFeeToken0 The community fee percentage of the swap fee in thousandths (1e-3) for token0;\\r\\n   * Returns communityFeeToken1 The community fee percentage of the swap fee in thousandths (1e-3) for token1;\\r\\n   * Returns unlocked Whether the pool is currently locked to reentrancy;\\r\\n   */\\r\\n  function globalState()\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    uint160 price,\\r\\n    int24 tick,\\r\\n    uint16 fee,\\r\\n    uint16 timepointIndex,\\r\\n    uint8 communityFeeToken0,\\r\\n    uint8 communityFeeToken1,\\r\\n    bool unlocked\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\r\\n   * @dev This value can overflow the uint256\\r\\n   */\\r\\n  function totalFeeGrowth0Token() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\r\\n   * @dev This value can overflow the uint256\\r\\n   */\\r\\n  function totalFeeGrowth1Token() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @notice The currently in range liquidity available to the pool\\r\\n   * @dev This value has no relationship to the total liquidity across all ticks.\\r\\n   * Returned value cannot exceed type(uint128).max\\r\\n   */\\r\\n  function liquidity() external view returns (uint128);\\r\\n\\r\\n  /**\\r\\n   * @notice Look up information about a specific tick in the pool\\r\\n   * @dev This is a public structure, so the `return` natspec tags are omitted.\\r\\n   * @param tick The tick to look up\\r\\n   * @return liquidityTotal the total amount of position liquidity that uses the pool either as tick lower or\\r\\n   * tick upper;\\r\\n   * Returns liquidityDelta how much liquidity changes when the pool price crosses the tick;\\r\\n   * Returns outerFeeGrowth0Token the fee growth on the other side of the tick from the current tick in token0;\\r\\n   * Returns outerFeeGrowth1Token the fee growth on the other side of the tick from the current tick in token1;\\r\\n   * Returns outerTickCumulative the cumulative tick value on the other side of the tick from the current tick;\\r\\n   * Returns outerSecondsPerLiquidity the seconds spent per liquidity on the other side of the tick from the current tick;\\r\\n   * Returns outerSecondsSpent the seconds spent on the other side of the tick from the current tick;\\r\\n   * Returns initialized Set to true if the tick is initialized, i.e. liquidityTotal is greater than 0\\r\\n   * otherwise equal to false. Outside values can only be used if the tick is initialized.\\r\\n   * In addition, these values are only relative and must be used only in comparison to previous snapshots for\\r\\n   * a specific position.\\r\\n   */\\r\\n  function ticks(int24 tick)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    uint128 liquidityTotal,\\r\\n    int128 liquidityDelta,\\r\\n    uint256 outerFeeGrowth0Token,\\r\\n    uint256 outerFeeGrowth1Token,\\r\\n    int56 outerTickCumulative,\\r\\n    uint160 outerSecondsPerLiquidity,\\r\\n    uint32 outerSecondsSpent,\\r\\n    bool initialized\\r\\n  );\\r\\n\\r\\n  /** @notice Returns 256 packed tick initialized boolean values. See TickTable for more information */\\r\\n  function tickTable(int16 wordPosition) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the information about a position by the position's key\\r\\n   * @dev This is a public mapping of structures, so the `return` natspec tags are omitted.\\r\\n   * @param key The position's key is a hash of a preimage composed by the owner, bottomTick and topTick\\r\\n   * @return liquidityAmount The amount of liquidity in the position;\\r\\n   * Returns lastLiquidityAddTimestamp Timestamp of last adding of liquidity;\\r\\n   * Returns innerFeeGrowth0Token Fee growth of token0 inside the tick range as of the last mint/burn/poke;\\r\\n   * Returns innerFeeGrowth1Token Fee growth of token1 inside the tick range as of the last mint/burn/poke;\\r\\n   * Returns fees0 The computed amount of token0 owed to the position as of the last mint/burn/poke;\\r\\n   * Returns fees1 The computed amount of token1 owed to the position as of the last mint/burn/poke\\r\\n   */\\r\\n  function positions(bytes32 key)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    uint128 liquidityAmount,\\r\\n    uint32 lastLiquidityAddTimestamp,\\r\\n    uint256 innerFeeGrowth0Token,\\r\\n    uint256 innerFeeGrowth1Token,\\r\\n    uint128 fees0,\\r\\n    uint128 fees1\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Returns data about a specific timepoint index\\r\\n   * @param index The element of the timepoints array to fetch\\r\\n   * @dev You most likely want to use #getTimepoints() instead of this method to get an timepoint as of some amount of time\\r\\n   * ago, rather than at a specific index in the array.\\r\\n   * This is a public mapping of structures, so the `return` natspec tags are omitted.\\r\\n   * @return initialized whether the timepoint has been initialized and the values are safe to use;\\r\\n   * Returns blockTimestamp The timestamp of the timepoint;\\r\\n   * Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp;\\r\\n   * Returns secondsPerLiquidityCumulative the seconds per in range liquidity for the life of the pool as of the timepoint timestamp;\\r\\n   * Returns volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp;\\r\\n   * Returns averageTick Time-weighted average tick;\\r\\n   * Returns volumePerLiquidityCumulative Cumulative swap volume per liquidity for the life of the pool as of the timepoint timestamp;\\r\\n   */\\r\\n  function timepoints(uint256 index)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    bool initialized,\\r\\n    uint32 blockTimestamp,\\r\\n    int56 tickCumulative,\\r\\n    uint160 secondsPerLiquidityCumulative,\\r\\n    uint88 volatilityCumulative,\\r\\n    int24 averageTick,\\r\\n    uint144 volumePerLiquidityCumulative\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the information about active incentive\\r\\n   * @dev if there is no active incentive at the moment, virtualPool,endTimestamp,startTimestamp would be equal to 0\\r\\n   * @return virtualPool The address of a virtual pool associated with the current active incentive\\r\\n   */\\r\\n  function activeIncentive() external view returns (address virtualPool);\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the lock time for added liquidity\\r\\n   */\\r\\n  function liquidityCooldown() external view returns (uint32 cooldownInSeconds);\\r\\n}\\r\\n\",\"keccak256\":\"0x6570bab323c67435efdf1558466d3e9d3862631554cd199c8c0148afa04afa83\",\"license\":\"GPL-2.0-or-later\"},\"contracts/strategies/algebra/AlgebraLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"../../integrations/algebra/IAlgebraPool.sol\\\";\\r\\nimport \\\"../../integrations/algebra/INonfungiblePositionManager.sol\\\";\\r\\nimport \\\"../../integrations/algebra/IFarmingCenter.sol\\\";\\r\\nimport \\\"../../integrations/algebra/IncentiveKey.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\r\\n\\r\\nlibrary AlgebraLib {\\r\\n  int24 internal constant TICKSPACING = 60;\\r\\n  uint8 internal constant RESOLUTION = 96;\\r\\n  uint internal constant Q96 = 0x1000000000000000000000000;\\r\\n  uint private constant TWO_96 = 2 ** 96;\\r\\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\r\\n  uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\\r\\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\r\\n  uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\\r\\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\r\\n  int24 internal constant MIN_TICK = - 887272;\\r\\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\r\\n  int24 internal constant MAX_TICK = - MIN_TICK;\\r\\n\\r\\n  function tickSpacing() external pure returns (int24) {\\r\\n    return TICKSPACING;\\r\\n  }\\r\\n\\r\\n  function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\\r\\n    IAlgebraPool pool = IAlgebraPool(pool_);\\r\\n    (uint160 sqrtRatioX96, , , , , ,) = pool.globalState();\\r\\n    liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\\r\\n    (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\r\\n  /// pool prices and the prices at the tick boundaries\\r\\n  function getLiquidityForAmounts(\\r\\n    uint160 sqrtRatioX96,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    uint amount0,\\r\\n    uint amount1\\r\\n  ) public pure returns (uint128 liquidity) {\\r\\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\\r\\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n\\r\\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\\r\\n      liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\\r\\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\\r\\n      uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\\r\\n      uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\\r\\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\r\\n    } else {\\r\\n      liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\r\\n  /// pool prices and the prices at the tick boundaries\\r\\n  function getAmountsForLiquidity(\\r\\n    uint160 sqrtRatioX96,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    uint128 liquidity\\r\\n  ) public pure returns (uint amount0, uint amount1) {\\r\\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\\r\\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\\r\\n\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n\\r\\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\\r\\n      amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\r\\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\\r\\n      amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\\r\\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\\r\\n    } else {\\r\\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\\r\\n  /// @param a The multiplicand\\r\\n  /// @param b The multiplier\\r\\n  /// @param denominator The divisor\\r\\n  /// @return result The 256-bit result\\r\\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\r\\n  function mulDiv(\\r\\n    uint a,\\r\\n    uint b,\\r\\n    uint denominator\\r\\n  ) public pure returns (uint result) {\\r\\n    unchecked {\\r\\n      // 512-bit multiply [prod1 prod0] = a * b\\r\\n      // Compute the product mod 2**256 and mod 2**256 - 1\\r\\n      // then use the Chinese Remainder Theorem to reconstruct\\r\\n      // the 512 bit result. The result is stored in two 256\\r\\n      // variables such that product = prod1 * 2**256 + prod0\\r\\n      uint prod0;\\r\\n      // Least significant 256 bits of the product\\r\\n      uint prod1;\\r\\n      // Most significant 256 bits of the product\\r\\n      assembly {\\r\\n        let mm := mulmod(a, b, not(0))\\r\\n        prod0 := mul(a, b)\\r\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n      }\\r\\n\\r\\n      // Handle non-overflow cases, 256 by 256 division\\r\\n      if (prod1 == 0) {\\r\\n        require(denominator > 0);\\r\\n        assembly {\\r\\n          result := div(prod0, denominator)\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n\\r\\n      // Make sure the result is less than 2**256.\\r\\n      // Also prevents denominator == 0\\r\\n      require(denominator > prod1);\\r\\n\\r\\n      ///////////////////////////////////////////////\\r\\n      // 512 by 256 division.\\r\\n      ///////////////////////////////////////////////\\r\\n\\r\\n      // Make division exact by subtracting the remainder from [prod1 prod0]\\r\\n      // Compute remainder using mulmod\\r\\n      uint remainder;\\r\\n      assembly {\\r\\n        remainder := mulmod(a, b, denominator)\\r\\n      }\\r\\n      // Subtract 256 bit number from 512 bit number\\r\\n      assembly {\\r\\n        prod1 := sub(prod1, gt(remainder, prod0))\\r\\n        prod0 := sub(prod0, remainder)\\r\\n      }\\r\\n\\r\\n      // Factor powers of two out of denominator\\r\\n      // Compute largest power of two divisor of denominator.\\r\\n      // Always >= 1.\\r\\n      // EDIT for 0.8 compatibility:\\r\\n      // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\\r\\n      uint twos = denominator & (~denominator + 1);\\r\\n\\r\\n      // Divide denominator by power of two\\r\\n      assembly {\\r\\n        denominator := div(denominator, twos)\\r\\n      }\\r\\n\\r\\n      // Divide [prod1 prod0] by the factors of two\\r\\n      assembly {\\r\\n        prod0 := div(prod0, twos)\\r\\n      }\\r\\n      // Shift in bits from prod1 into prod0. For this we need\\r\\n      // to flip `twos` such that it is 2**256 / twos.\\r\\n      // If twos is zero, then it becomes one\\r\\n      assembly {\\r\\n        twos := add(div(sub(0, twos), twos), 1)\\r\\n      }\\r\\n      prod0 |= prod1 * twos;\\r\\n\\r\\n      // Invert denominator mod 2**256\\r\\n      // Now that denominator is an odd number, it has an inverse\\r\\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\r\\n      // Compute the inverse by starting with a seed that is correct\\r\\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\\r\\n      uint inv = (3 * denominator) ^ 2;\\r\\n      // Now use Newton-Raphson iteration to improve the precision.\\r\\n      // Thanks to Hensel's lifting lemma, this also works in modular\\r\\n      // arithmetic, doubling the correct bits in each step.\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**8\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**16\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**32\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**64\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**128\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**256\\r\\n\\r\\n      // Because the division is now exact we can divide by multiplying\\r\\n      // with the modular inverse of denominator. This will give us the\\r\\n      // correct result modulo 2**256. Since the precoditions guarantee\\r\\n      // that the outcome is less than 2**256, this is the final result.\\r\\n      // We don't need to compute the high bits of the result and prod1\\r\\n      // is no longer required.\\r\\n      result = prod0 * inv;\\r\\n      return result;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\\r\\n  /// @param a The multiplicand\\r\\n  /// @param b The multiplier\\r\\n  /// @param denominator The divisor\\r\\n  /// @return result The 256-bit result\\r\\n  function mulDivRoundingUp(\\r\\n    uint a,\\r\\n    uint b,\\r\\n    uint denominator\\r\\n  ) internal pure returns (uint result) {\\r\\n    result = mulDiv(a, b, denominator);\\r\\n    if (mulmod(a, b, denominator) > 0) {\\r\\n      require(result < type(uint).max);\\r\\n      result++;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates price in pool\\r\\n  /// @return price with decimals of paired token\\r\\n  function getPrice(address pool_, address tokenIn) public view returns (uint) {\\r\\n    IAlgebraPool pool = IAlgebraPool(pool_);\\r\\n    address token0 = pool.token0();\\r\\n    address token1 = pool.token1();\\r\\n\\r\\n    uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\\r\\n    uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\\r\\n    (uint160 sqrtPriceX96,,,,,,) = pool.globalState();\\r\\n\\r\\n    uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\\r\\n\\r\\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\\r\\n    uint purePrice;\\r\\n    uint precision;\\r\\n    if (tokenIn == token0) {\\r\\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\\r\\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\\r\\n      purePrice = part * part;\\r\\n    } else {\\r\\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\\r\\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\\r\\n      purePrice = part * part;\\r\\n    }\\r\\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\\r\\n  }\\r\\n\\r\\n  function getFees(IAlgebraPool pool, INonfungiblePositionManager nft, uint tokenId) public view returns (uint fee0, uint fee1) {\\r\\n    (, int24 tick, , , , ,) = pool.globalState();\\r\\n    (,,,,int24 lowerTick,int24 upperTick,uint128 liquidity,uint feeGrowthInside0Last, uint feeGrowthInside1Last, uint128 tokensOwed0, uint128 tokensOwed1) = nft.positions(tokenId);\\r\\n    fee0 = _computeFeesEarned(pool, lowerTick, upperTick, liquidity, true, feeGrowthInside0Last, tick) + uint(tokensOwed0);\\r\\n    fee1 = _computeFeesEarned(pool, lowerTick, upperTick, liquidity, false, feeGrowthInside1Last, tick) + uint(tokensOwed1);\\r\\n  }\\r\\n\\r\\n  function _computeFeesEarned(\\r\\n    IAlgebraPool pool,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    uint128 liquidity,\\r\\n    bool isZero,\\r\\n    uint feeGrowthInsideLast,\\r\\n    int24 tick\\r\\n  ) internal view returns (uint fee) {\\r\\n    uint feeGrowthOutsideLower;\\r\\n    uint feeGrowthOutsideUpper;\\r\\n    uint feeGrowthGlobal;\\r\\n    if (isZero) {\\r\\n      feeGrowthGlobal = pool.totalFeeGrowth0Token();\\r\\n      (,, feeGrowthOutsideLower,,,,,) = pool.ticks(lowerTick);\\r\\n      (,, feeGrowthOutsideUpper,,,,,) = pool.ticks(upperTick);\\r\\n    } else {\\r\\n      feeGrowthGlobal = pool.totalFeeGrowth1Token();\\r\\n      (,,, feeGrowthOutsideLower,,,,) = pool.ticks(lowerTick);\\r\\n      (,,, feeGrowthOutsideUpper,,,,) = pool.ticks(upperTick);\\r\\n    }\\r\\n\\r\\n    unchecked {\\r\\n      // calculate fee growth below\\r\\n      uint feeGrowthBelow;\\r\\n      if (tick >= lowerTick) {\\r\\n        feeGrowthBelow = feeGrowthOutsideLower;\\r\\n      } else {\\r\\n        feeGrowthBelow = feeGrowthGlobal - feeGrowthOutsideLower;\\r\\n      }\\r\\n      // calculate fee growth above\\r\\n      uint feeGrowthAbove;\\r\\n      if (tick < upperTick) {\\r\\n        feeGrowthAbove = feeGrowthOutsideUpper;\\r\\n      } else {\\r\\n        feeGrowthAbove = feeGrowthGlobal - feeGrowthOutsideUpper;\\r\\n      }\\r\\n\\r\\n      uint feeGrowthInside = feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove;\\r\\n      fee = mulDiv(\\r\\n        liquidity,\\r\\n        feeGrowthInside - feeGrowthInsideLast,\\r\\n        0x100000000000000000000000000000000\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\r\\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param amount0 The amount0 being sent in\\r\\n  /// @return liquidity The amount of returned liquidity\\r\\n  function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\\r\\n    return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\r\\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param amount1 The amount1 being sent in\\r\\n  /// @return liquidity The amount of returned liquidity\\r\\n  function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param liquidity The liquidity being valued\\r\\n  /// @return amount0 The amount0\\r\\n  function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param liquidity The liquidity being valued\\r\\n  /// @return amount1 The amount1\\r\\n  function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\\r\\n  }\\r\\n\\r\\n  function _countDigits(uint n) internal pure returns (uint) {\\r\\n    if (n == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint count = 0;\\r\\n    while (n != 0) {\\r\\n      n = n / 10;\\r\\n      ++count;\\r\\n    }\\r\\n    return count;\\r\\n  }\\r\\n\\r\\n  function _min(uint a, uint b) internal pure returns (uint) {\\r\\n    return a < b ? a : b;\\r\\n  }\\r\\n\\r\\n  function _max(uint a, uint b) internal pure returns (uint) {\\r\\n    return a > b ? a : b;\\r\\n  }\\r\\n\\r\\n  function _toUint128(uint x) private pure returns (uint128 y) {\\r\\n    require((y = uint128(x)) == x);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\\r\\n  /// @dev Throws if |tick| > max tick\\r\\n  /// @param tick The input tick for the above formula\\r\\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\r\\n  /// at the given tick\\r\\n  function _getSqrtRatioAtTick(int24 tick)\\r\\n  internal\\r\\n  pure\\r\\n  returns (uint160 sqrtPriceX96)\\r\\n  {\\r\\n    uint256 absTick =\\r\\n      tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\\r\\n\\r\\n    // EDIT: 0.8 compatibility\\r\\n    require(absTick <= uint256(int256(MAX_TICK)), \\\"T\\\");\\r\\n\\r\\n    uint256 ratio =\\r\\n      absTick & 0x1 != 0\\r\\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\\r\\n        : 0x100000000000000000000000000000000;\\r\\n    if (absTick & 0x2 != 0)\\r\\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\r\\n    if (absTick & 0x4 != 0)\\r\\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\r\\n    if (absTick & 0x8 != 0)\\r\\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\r\\n    if (absTick & 0x10 != 0)\\r\\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\r\\n    if (absTick & 0x20 != 0)\\r\\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\r\\n    if (absTick & 0x40 != 0)\\r\\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\r\\n    if (absTick & 0x80 != 0)\\r\\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\r\\n    if (absTick & 0x100 != 0)\\r\\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\r\\n    if (absTick & 0x200 != 0)\\r\\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\r\\n    if (absTick & 0x400 != 0)\\r\\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\r\\n    if (absTick & 0x800 != 0)\\r\\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\r\\n    if (absTick & 0x1000 != 0)\\r\\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\r\\n    if (absTick & 0x2000 != 0)\\r\\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\r\\n    if (absTick & 0x4000 != 0)\\r\\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\r\\n    if (absTick & 0x8000 != 0)\\r\\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\r\\n    if (absTick & 0x10000 != 0)\\r\\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\r\\n    if (absTick & 0x20000 != 0)\\r\\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\r\\n    if (absTick & 0x40000 != 0)\\r\\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\r\\n    if (absTick & 0x80000 != 0)\\r\\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\r\\n\\r\\n    if (tick > 0) ratio = type(uint256).max / ratio;\\r\\n\\r\\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\r\\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\r\\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\r\\n    sqrtPriceX96 = uint160(\\r\\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\r\\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\r\\n  /// ever return.\\r\\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\r\\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\r\\n  function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\r\\n    // second inequality must be < because the price can never reach the price at the max tick\\r\\n    require(\\r\\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\\r\\n      \\\"R\\\"\\r\\n    );\\r\\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\\r\\n\\r\\n    uint256 r = ratio;\\r\\n    uint256 msb = 0;\\r\\n\\r\\n    assembly {\\r\\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(5, gt(r, 0xFFFFFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(4, gt(r, 0xFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(3, gt(r, 0xFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(2, gt(r, 0xF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(1, gt(r, 0x3))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := gt(r, 0x1)\\r\\n      msb := or(msb, f)\\r\\n    }\\r\\n\\r\\n    if (msb >= 128) r = ratio >> (msb - 127);\\r\\n    else r = ratio << (127 - msb);\\r\\n\\r\\n    int256 log_2 = (int256(msb) - 128) << 64;\\r\\n\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(63, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(62, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(61, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(60, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(59, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(58, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(57, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(56, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(55, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(54, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(53, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(52, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(51, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(50, f))\\r\\n    }\\r\\n\\r\\n    tick = _getFinalTick(log_2, sqrtPriceX96);\\r\\n  }\\r\\n\\r\\n  function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\r\\n    // 128.128 number\\r\\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\\r\\n\\r\\n    int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\r\\n    int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\r\\n\\r\\n    tick = (tickLow == tickHi)\\r\\n      ? tickLow\\r\\n      : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow);\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x177e22910ca9ac7f1cec711cf1acc69590ec263756b1f9659734fbc0a0a1f744\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x611a5661003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100775760003560e01c80630337236a1461007c57806317c22c3c146100ac5780632a279b28146100e3578063455791781461010b578063aa9a09121461011e578063ac41865a1461013f578063d0c93a7c14610152575b600080fd5b61008f61008a3660046113fa565b610161565b6040516001600160801b0390911681526020015b60405180910390f35b6100bf6100ba3660046113fa565b61023e565b6040805193845260208401929092526001600160801b0316908201526060016100a3565b6100f66100f136600461146a565b6102e1565b604080519283526020830191909152016100a3565b6100f66101193660046114c6565b610397565b61013161012c366004611507565b6104ef565b6040519081526020016100a3565b61013161014d366004611533565b6105a3565b604051603c81526020016100a3565b60008061016d86610a4c565b9050600061017a86610a4c565b9050806001600160a01b0316826001600160a01b0316111561019857905b816001600160a01b0316886001600160a01b0316116101c3576101bc828287610e66565b9250610233565b806001600160a01b0316886001600160a01b031610156102255760006101ea898388610e66565b905060006101f9848b88610ed9565b9050806001600160801b0316826001600160801b03161061021a578061021c565b815b94505050610233565b610230828286610ed9565b92505b505095945050505050565b6000806000808890506000816001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa158015610287573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ab91906115b5565b50505050505090506102c0818a8a8a8a610161565b92506102ce818a8a866102e1565b909b909a50929850919650505050505050565b60008060006102ef86610a4c565b905060006102fc86610a4c565b9050806001600160a01b0316826001600160a01b0316111561031a57905b816001600160a01b0316886001600160a01b0316116103455761033e828287610f0f565b935061038c565b806001600160a01b0316886001600160a01b0316101561037e5761036a888287610f0f565b9350610377828987610f79565b925061038c565b610389828287610f79565b92505b505094509492505050565b6000806000856001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa1580156103da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103fe91906115b5565b505050505091505060008060008060008060008b6001600160a01b03166399fbab888c6040518263ffffffff1660e01b815260040161043f91815260200190565b61016060405180830381865afa15801561045d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610481919061164b565b9a509a509a509a509a509a509a5050505050816001600160801b03166104ad8e89898960018a8f610fc3565b6104b79190611738565b9950806001600160801b03166104d38e8989896000898f610fc3565b6104dd9190611738565b98505050505050505050935093915050565b6000808060001985870985870292508281108382030391505080600003610528576000841161051d57600080fd5b50829004905061059c565b80841161053457600080fd5b600084868809851960019081018716968790049682860381900495909211909303600082900391909104909201919091029190911760038402600290811880860282030280860282030280860282030280860282030280860282030280860290910302029150505b9392505050565b6000808390506000816001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060d919061174b565b90506000826001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561064f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610673919061174b565b90506000826001600160a01b0316866001600160a01b0316146106f757816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f29190611768565b610759565b826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610735573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107599190611768565b60ff1690506000826001600160a01b0316876001600160a01b0316146107e057826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107db9190611768565b610842565b836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561081e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108429190611768565b60ff1690506000856001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa158015610887573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ab91906115b5565b50505050505090506000601283106108c45760016108ee565b6108ee6108d285600a611867565b6108dd85600a611867565b6108e79190611889565b600161132a565b90506000610904836001600160a01b0316611340565b9050600080886001600160a01b03168c6001600160a01b03160361098c5786601d841061093257600061093d565b61093d84601d61189d565b6109479190611738565b61095290600a611867565b90506000600160601b61096e836001600160a01b0389166118b0565b6109789190611889565b905061098481806118b0565b9250506109f2565b86601d841161099c5760006109a7565b6109a7601d8561189d565b6109b19190611738565b6109bc90600a611867565b905060006001600160a01b0386166109d883600160601b6118b0565b6109e29190611889565b90506109ee81806118b0565b9250505b670de0b6b3a76400008111610a08576001610a1a565b610a1a670de0b6b3a764000082611889565b81610a258685611889565b610a2f9190611889565b610a399190611889565b9a50505050505050505050505b92915050565b60008060008360020b12610a63578260020b610a70565b8260020b610a70906118c7565b9050610a7f620d89e7196118e3565b60020b811115610ab95760405162461bcd60e51b81526020600482015260016024820152601560fa1b604482015260640160405180910390fd5b600081600116600003610ad057600160801b610ae2565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b031690506002821615610b17576080610b12826ffff97272373d413259a46990580e213a6118b0565b901c90505b6004821615610b41576080610b3c826ffff2e50f5f656932ef12357cf3c7fdcc6118b0565b901c90505b6008821615610b6b576080610b66826fffe5caca7e10e4e61c3624eaa0941cd06118b0565b901c90505b6010821615610b95576080610b90826fffcb9843d60f6159c9db58835c9266446118b0565b901c90505b6020821615610bbf576080610bba826fff973b41fa98c081472e6896dfb254c06118b0565b901c90505b6040821615610be9576080610be4826fff2ea16466c96a3843ec78b326b528616118b0565b901c90505b6080821615610c13576080610c0e826ffe5dee046a99a2a811c461f1969c30536118b0565b901c90505b610100821615610c3e576080610c39826ffcbe86c7900a88aedcffc83b479aa3a46118b0565b901c90505b610200821615610c69576080610c64826ff987a7253ac413176f2b074cf7815e546118b0565b901c90505b610400821615610c94576080610c8f826ff3392b0822b70005940c7a398e4b70f36118b0565b901c90505b610800821615610cbf576080610cba826fe7159475a2c29b7443b29c7fa6e889d96118b0565b901c90505b611000821615610cea576080610ce5826fd097f3bdfd2022b8845ad8f792aa58256118b0565b901c90505b612000821615610d15576080610d10826fa9f746462d870fdf8a65dc1f90e061e56118b0565b901c90505b614000821615610d40576080610d3b826f70d869a156d2a1b890bb3df62baf32f76118b0565b901c90505b618000821615610d6b576080610d66826f31be135f97d08fd981231505542fcfa66118b0565b901c90505b62010000821615610d97576080610d92826f09aa508b5b7a84e1c677de54f3e99bc96118b0565b901c90505b62020000821615610dc2576080610dbd826e5d6af8dedb81196699c329225ee6046118b0565b901c90505b62040000821615610dec576080610de7826d2216e584f5fa1ea926041bedfe986118b0565b901c90505b62080000821615610e14576080610e0f826b048a170391f7dc42444e8fa26118b0565b901c90505b60008460020b1315610e2f57610e2c81600019611889565b90505b610e3e64010000000082611905565b15610e4a576001610e4d565b60005b610e5e9060ff16602083901c611738565b949350505050565b6000826001600160a01b0316846001600160a01b03161115610e86579192915b6000610ea9856001600160a01b0316856001600160a01b0316600160601b6104ef565b9050610ed0610ecb8483610ebd8989611919565b6001600160a01b03166104ef565b611378565b95945050505050565b6000826001600160a01b0316846001600160a01b03161115610ef9579192915b610e5e610ecb83600160601b610ebd8888611919565b6000826001600160a01b0316846001600160a01b03161115610f2f579192915b610e5e6001610f6a600160601b600160e01b03606086901b16610f528888611919565b6001600160a01b0316876001600160a01b0316611393565b866001600160a01b0316611393565b6000826001600160a01b0316846001600160a01b03161115610f99579192915b610e5e6001600160801b038316610fb08686611919565b6001600160a01b0316600160601b611393565b600080600080861561114a578a6001600160a01b0316636378ae446040518163ffffffff1660e01b8152600401602060405180830381865afa15801561100d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110319190611940565b60405163f30dba9360e01b815260028c900b60048201529091506001600160a01b038c169063f30dba939060240161010060405180830381865afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190611959565b909192939495965090919293949550909192935090919250909150905050809350508a6001600160a01b031663f30dba938a6040518263ffffffff1660e01b81526004016110f8919060029190910b815260200190565b61010060405180830381865afa158015611116573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061113a9190611959565b509397506112c195505050505050565b8a6001600160a01b031663ecdecf426040518163ffffffff1660e01b8152600401602060405180830381865afa158015611188573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ac9190611940565b60405163f30dba9360e01b815260028c900b60048201529091506001600160a01b038c169063f30dba939060240161010060405180830381865afa1580156111f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121c9190611959565b90919293949596509091929394955090919293945090919250909150905050809350508a6001600160a01b031663f30dba938a6040518263ffffffff1660e01b8152600401611274919060029190910b815260200190565b61010060405180830381865afa158015611292573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112b69190611959565b509297505050505050505b60008a60020b8660020b126112d75750826112dc565b508281035b60008a60020b8760020b12156112f35750826112f8565b508282035b8183038190036113186001600160801b038c168a8303600160801b6104ef565b9e9d5050505050505050505050505050565b6000818311611339578161059c565b5090919050565b60008160000361135257506000919050565b60005b8215610a4657611366600a84611889565b925061137181611a07565b9050611355565b806001600160801b038116811461138e57600080fd5b919050565b60006113a08484846104ef565b9050600082806113b2576113b2611873565b848609111561059c5760001981106113c957600080fd5b80610ed081611a07565b6001600160a01b03811681146113e857600080fd5b50565b8060020b81146113e857600080fd5b600080600080600060a0868803121561141257600080fd5b853561141d816113d3565b9450602086013561142d816113eb565b9350604086013561143d816113eb565b94979396509394606081013594506080013592915050565b6001600160801b03811681146113e857600080fd5b6000806000806080858703121561148057600080fd5b843561148b816113d3565b9350602085013561149b816113eb565b925060408501356114ab816113eb565b915060608501356114bb81611455565b939692955090935050565b6000806000606084860312156114db57600080fd5b83356114e6816113d3565b925060208401356114f6816113d3565b929592945050506040919091013590565b60008060006060848603121561151c57600080fd5b505081359360208301359350604090920135919050565b6000806040838503121561154657600080fd5b8235611551816113d3565b91506020830135611561816113d3565b809150509250929050565b805161138e816113d3565b805161138e816113eb565b805161ffff8116811461138e57600080fd5b805160ff8116811461138e57600080fd5b8051801515811461138e57600080fd5b600080600080600080600060e0888a0312156115d057600080fd5b87516115db816113d3565b60208901519097506115ec816113eb565b95506115fa60408901611582565b945061160860608901611582565b935061161660808901611594565b925061162460a08901611594565b915061163260c089016115a5565b905092959891949750929550565b805161138e81611455565b60008060008060008060008060008060006101608c8e03121561166d57600080fd5b8b516bffffffffffffffffffffffff8116811461168957600080fd5b60208d0151909b5061169a816113d3565b60408d0151909a506116ab816113d3565b98506116b960608d0161156c565b97506116c760808d01611577565b96506116d560a08d01611577565b95506116e360c08d01611640565b945060e08c015193506101008c015192506117016101208d01611640565b91506117106101408d01611640565b90509295989b509295989b9093969950565b634e487b7160e01b600052601160045260246000fd5b80820180821115610a4657610a46611722565b60006020828403121561175d57600080fd5b815161059c816113d3565b60006020828403121561177a57600080fd5b61059c82611594565b600181815b808511156117be5781600019048211156117a4576117a4611722565b808516156117b157918102915b93841c9390800290611788565b509250929050565b6000826117d557506001610a46565b816117e257506000610a46565b81600181146117f857600281146118025761181e565b6001915050610a46565b60ff84111561181357611813611722565b50506001821b610a46565b5060208310610133831016604e8410600b8410161715611841575081810a610a46565b61184b8383611783565b806000190482111561185f5761185f611722565b029392505050565b600061059c83836117c6565b634e487b7160e01b600052601260045260246000fd5b60008261189857611898611873565b500490565b81810381811115610a4657610a46611722565b8082028115828204841417610a4657610a46611722565b6000600160ff1b82016118dc576118dc611722565b5060000390565b60008160020b627fffff1981036118fc576118fc611722565b60000392915050565b60008261191457611914611873565b500690565b6001600160a01b0382811682821603908082111561193957611939611722565b5092915050565b60006020828403121561195257600080fd5b5051919050565b600080600080600080600080610100898b03121561197657600080fd5b885161198181611455565b80985050602089015180600f0b811461199957600080fd5b80975050604089015195506060890151945060808901518060060b81146119bf57600080fd5b60a08a01519094506119d0816113d3565b60c08a015190935063ffffffff811681146119ea57600080fd5b91506119f860e08a016115a5565b90509295985092959890939650565b600060018201611a1957611a19611722565b506001019056fea264697066735822122055e87f3e34830689c3dcfb00b239c8eba63b1dbc85b3e9bf644e30590576919964736f6c63430008110033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100775760003560e01c80630337236a1461007c57806317c22c3c146100ac5780632a279b28146100e3578063455791781461010b578063aa9a09121461011e578063ac41865a1461013f578063d0c93a7c14610152575b600080fd5b61008f61008a3660046113fa565b610161565b6040516001600160801b0390911681526020015b60405180910390f35b6100bf6100ba3660046113fa565b61023e565b6040805193845260208401929092526001600160801b0316908201526060016100a3565b6100f66100f136600461146a565b6102e1565b604080519283526020830191909152016100a3565b6100f66101193660046114c6565b610397565b61013161012c366004611507565b6104ef565b6040519081526020016100a3565b61013161014d366004611533565b6105a3565b604051603c81526020016100a3565b60008061016d86610a4c565b9050600061017a86610a4c565b9050806001600160a01b0316826001600160a01b0316111561019857905b816001600160a01b0316886001600160a01b0316116101c3576101bc828287610e66565b9250610233565b806001600160a01b0316886001600160a01b031610156102255760006101ea898388610e66565b905060006101f9848b88610ed9565b9050806001600160801b0316826001600160801b03161061021a578061021c565b815b94505050610233565b610230828286610ed9565b92505b505095945050505050565b6000806000808890506000816001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa158015610287573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ab91906115b5565b50505050505090506102c0818a8a8a8a610161565b92506102ce818a8a866102e1565b909b909a50929850919650505050505050565b60008060006102ef86610a4c565b905060006102fc86610a4c565b9050806001600160a01b0316826001600160a01b0316111561031a57905b816001600160a01b0316886001600160a01b0316116103455761033e828287610f0f565b935061038c565b806001600160a01b0316886001600160a01b0316101561037e5761036a888287610f0f565b9350610377828987610f79565b925061038c565b610389828287610f79565b92505b505094509492505050565b6000806000856001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa1580156103da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103fe91906115b5565b505050505091505060008060008060008060008b6001600160a01b03166399fbab888c6040518263ffffffff1660e01b815260040161043f91815260200190565b61016060405180830381865afa15801561045d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610481919061164b565b9a509a509a509a509a509a509a5050505050816001600160801b03166104ad8e89898960018a8f610fc3565b6104b79190611738565b9950806001600160801b03166104d38e8989896000898f610fc3565b6104dd9190611738565b98505050505050505050935093915050565b6000808060001985870985870292508281108382030391505080600003610528576000841161051d57600080fd5b50829004905061059c565b80841161053457600080fd5b600084868809851960019081018716968790049682860381900495909211909303600082900391909104909201919091029190911760038402600290811880860282030280860282030280860282030280860282030280860282030280860290910302029150505b9392505050565b6000808390506000816001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060d919061174b565b90506000826001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561064f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610673919061174b565b90506000826001600160a01b0316866001600160a01b0316146106f757816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f29190611768565b610759565b826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610735573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107599190611768565b60ff1690506000826001600160a01b0316876001600160a01b0316146107e057826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107db9190611768565b610842565b836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561081e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108429190611768565b60ff1690506000856001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa158015610887573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ab91906115b5565b50505050505090506000601283106108c45760016108ee565b6108ee6108d285600a611867565b6108dd85600a611867565b6108e79190611889565b600161132a565b90506000610904836001600160a01b0316611340565b9050600080886001600160a01b03168c6001600160a01b03160361098c5786601d841061093257600061093d565b61093d84601d61189d565b6109479190611738565b61095290600a611867565b90506000600160601b61096e836001600160a01b0389166118b0565b6109789190611889565b905061098481806118b0565b9250506109f2565b86601d841161099c5760006109a7565b6109a7601d8561189d565b6109b19190611738565b6109bc90600a611867565b905060006001600160a01b0386166109d883600160601b6118b0565b6109e29190611889565b90506109ee81806118b0565b9250505b670de0b6b3a76400008111610a08576001610a1a565b610a1a670de0b6b3a764000082611889565b81610a258685611889565b610a2f9190611889565b610a399190611889565b9a50505050505050505050505b92915050565b60008060008360020b12610a63578260020b610a70565b8260020b610a70906118c7565b9050610a7f620d89e7196118e3565b60020b811115610ab95760405162461bcd60e51b81526020600482015260016024820152601560fa1b604482015260640160405180910390fd5b600081600116600003610ad057600160801b610ae2565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b031690506002821615610b17576080610b12826ffff97272373d413259a46990580e213a6118b0565b901c90505b6004821615610b41576080610b3c826ffff2e50f5f656932ef12357cf3c7fdcc6118b0565b901c90505b6008821615610b6b576080610b66826fffe5caca7e10e4e61c3624eaa0941cd06118b0565b901c90505b6010821615610b95576080610b90826fffcb9843d60f6159c9db58835c9266446118b0565b901c90505b6020821615610bbf576080610bba826fff973b41fa98c081472e6896dfb254c06118b0565b901c90505b6040821615610be9576080610be4826fff2ea16466c96a3843ec78b326b528616118b0565b901c90505b6080821615610c13576080610c0e826ffe5dee046a99a2a811c461f1969c30536118b0565b901c90505b610100821615610c3e576080610c39826ffcbe86c7900a88aedcffc83b479aa3a46118b0565b901c90505b610200821615610c69576080610c64826ff987a7253ac413176f2b074cf7815e546118b0565b901c90505b610400821615610c94576080610c8f826ff3392b0822b70005940c7a398e4b70f36118b0565b901c90505b610800821615610cbf576080610cba826fe7159475a2c29b7443b29c7fa6e889d96118b0565b901c90505b611000821615610cea576080610ce5826fd097f3bdfd2022b8845ad8f792aa58256118b0565b901c90505b612000821615610d15576080610d10826fa9f746462d870fdf8a65dc1f90e061e56118b0565b901c90505b614000821615610d40576080610d3b826f70d869a156d2a1b890bb3df62baf32f76118b0565b901c90505b618000821615610d6b576080610d66826f31be135f97d08fd981231505542fcfa66118b0565b901c90505b62010000821615610d97576080610d92826f09aa508b5b7a84e1c677de54f3e99bc96118b0565b901c90505b62020000821615610dc2576080610dbd826e5d6af8dedb81196699c329225ee6046118b0565b901c90505b62040000821615610dec576080610de7826d2216e584f5fa1ea926041bedfe986118b0565b901c90505b62080000821615610e14576080610e0f826b048a170391f7dc42444e8fa26118b0565b901c90505b60008460020b1315610e2f57610e2c81600019611889565b90505b610e3e64010000000082611905565b15610e4a576001610e4d565b60005b610e5e9060ff16602083901c611738565b949350505050565b6000826001600160a01b0316846001600160a01b03161115610e86579192915b6000610ea9856001600160a01b0316856001600160a01b0316600160601b6104ef565b9050610ed0610ecb8483610ebd8989611919565b6001600160a01b03166104ef565b611378565b95945050505050565b6000826001600160a01b0316846001600160a01b03161115610ef9579192915b610e5e610ecb83600160601b610ebd8888611919565b6000826001600160a01b0316846001600160a01b03161115610f2f579192915b610e5e6001610f6a600160601b600160e01b03606086901b16610f528888611919565b6001600160a01b0316876001600160a01b0316611393565b866001600160a01b0316611393565b6000826001600160a01b0316846001600160a01b03161115610f99579192915b610e5e6001600160801b038316610fb08686611919565b6001600160a01b0316600160601b611393565b600080600080861561114a578a6001600160a01b0316636378ae446040518163ffffffff1660e01b8152600401602060405180830381865afa15801561100d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110319190611940565b60405163f30dba9360e01b815260028c900b60048201529091506001600160a01b038c169063f30dba939060240161010060405180830381865afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190611959565b909192939495965090919293949550909192935090919250909150905050809350508a6001600160a01b031663f30dba938a6040518263ffffffff1660e01b81526004016110f8919060029190910b815260200190565b61010060405180830381865afa158015611116573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061113a9190611959565b509397506112c195505050505050565b8a6001600160a01b031663ecdecf426040518163ffffffff1660e01b8152600401602060405180830381865afa158015611188573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ac9190611940565b60405163f30dba9360e01b815260028c900b60048201529091506001600160a01b038c169063f30dba939060240161010060405180830381865afa1580156111f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121c9190611959565b90919293949596509091929394955090919293945090919250909150905050809350508a6001600160a01b031663f30dba938a6040518263ffffffff1660e01b8152600401611274919060029190910b815260200190565b61010060405180830381865afa158015611292573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112b69190611959565b509297505050505050505b60008a60020b8660020b126112d75750826112dc565b508281035b60008a60020b8760020b12156112f35750826112f8565b508282035b8183038190036113186001600160801b038c168a8303600160801b6104ef565b9e9d5050505050505050505050505050565b6000818311611339578161059c565b5090919050565b60008160000361135257506000919050565b60005b8215610a4657611366600a84611889565b925061137181611a07565b9050611355565b806001600160801b038116811461138e57600080fd5b919050565b60006113a08484846104ef565b9050600082806113b2576113b2611873565b848609111561059c5760001981106113c957600080fd5b80610ed081611a07565b6001600160a01b03811681146113e857600080fd5b50565b8060020b81146113e857600080fd5b600080600080600060a0868803121561141257600080fd5b853561141d816113d3565b9450602086013561142d816113eb565b9350604086013561143d816113eb565b94979396509394606081013594506080013592915050565b6001600160801b03811681146113e857600080fd5b6000806000806080858703121561148057600080fd5b843561148b816113d3565b9350602085013561149b816113eb565b925060408501356114ab816113eb565b915060608501356114bb81611455565b939692955090935050565b6000806000606084860312156114db57600080fd5b83356114e6816113d3565b925060208401356114f6816113d3565b929592945050506040919091013590565b60008060006060848603121561151c57600080fd5b505081359360208301359350604090920135919050565b6000806040838503121561154657600080fd5b8235611551816113d3565b91506020830135611561816113d3565b809150509250929050565b805161138e816113d3565b805161138e816113eb565b805161ffff8116811461138e57600080fd5b805160ff8116811461138e57600080fd5b8051801515811461138e57600080fd5b600080600080600080600060e0888a0312156115d057600080fd5b87516115db816113d3565b60208901519097506115ec816113eb565b95506115fa60408901611582565b945061160860608901611582565b935061161660808901611594565b925061162460a08901611594565b915061163260c089016115a5565b905092959891949750929550565b805161138e81611455565b60008060008060008060008060008060006101608c8e03121561166d57600080fd5b8b516bffffffffffffffffffffffff8116811461168957600080fd5b60208d0151909b5061169a816113d3565b60408d0151909a506116ab816113d3565b98506116b960608d0161156c565b97506116c760808d01611577565b96506116d560a08d01611577565b95506116e360c08d01611640565b945060e08c015193506101008c015192506117016101208d01611640565b91506117106101408d01611640565b90509295989b509295989b9093969950565b634e487b7160e01b600052601160045260246000fd5b80820180821115610a4657610a46611722565b60006020828403121561175d57600080fd5b815161059c816113d3565b60006020828403121561177a57600080fd5b61059c82611594565b600181815b808511156117be5781600019048211156117a4576117a4611722565b808516156117b157918102915b93841c9390800290611788565b509250929050565b6000826117d557506001610a46565b816117e257506000610a46565b81600181146117f857600281146118025761181e565b6001915050610a46565b60ff84111561181357611813611722565b50506001821b610a46565b5060208310610133831016604e8410600b8410161715611841575081810a610a46565b61184b8383611783565b806000190482111561185f5761185f611722565b029392505050565b600061059c83836117c6565b634e487b7160e01b600052601260045260246000fd5b60008261189857611898611873565b500490565b81810381811115610a4657610a46611722565b8082028115828204841417610a4657610a46611722565b6000600160ff1b82016118dc576118dc611722565b5060000390565b60008160020b627fffff1981036118fc576118fc611722565b60000392915050565b60008261191457611914611873565b500690565b6001600160a01b0382811682821603908082111561193957611939611722565b5092915050565b60006020828403121561195257600080fd5b5051919050565b600080600080600080600080610100898b03121561197657600080fd5b885161198181611455565b80985050602089015180600f0b811461199957600080fd5b80975050604089015195506060890151945060808901518060060b81146119bf57600080fd5b60a08a01519094506119d0816113d3565b60c08a015190935063ffffffff811681146119ea57600080fd5b91506119f860e08a016115a5565b90509295985092959890939650565b600060018201611a1957611a19611722565b506001019056fea264697066735822122055e87f3e34830689c3dcfb00b239c8eba63b1dbc85b3e9bf644e30590576919964736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getPrice(address,address)": {
        "returns": {
          "_0": "price with decimals of paired token"
        }
      },
      "mulDiv(uint256,uint256,uint256)": {
        "details": "Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv",
        "params": {
          "a": "The multiplicand",
          "b": "The multiplier",
          "denominator": "The divisor"
        },
        "returns": {
          "result": "The 256-bit result"
        }
      }
    },
    "stateVariables": {
      "MAX_SQRT_RATIO": {
        "details": "The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)"
      },
      "MAX_TICK": {
        "details": "The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128"
      },
      "MIN_SQRT_RATIO": {
        "details": "The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)"
      },
      "MIN_TICK": {
        "details": "The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getAmountsForLiquidity(uint160,int24,int24,uint128)": {
        "notice": "Computes the token0 and token1 value for a given amount of liquidity, the current pool prices and the prices at the tick boundaries"
      },
      "getLiquidityForAmounts(uint160,int24,int24,uint256,uint256)": {
        "notice": "Computes the maximum amount of liquidity received for a given amount of token0, token1, the current pool prices and the prices at the tick boundaries"
      },
      "getPrice(address,address)": {
        "notice": "Calculates price in pool"
      },
      "mulDiv(uint256,uint256,uint256)": {
        "notice": "Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}