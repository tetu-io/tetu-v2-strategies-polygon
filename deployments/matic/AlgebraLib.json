{
  "address": "0xF553b1372610a3415BA5C2937d8F4c45fe6EB509",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        },
        {
          "internalType": "int24",
          "name": "lowerTick_",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick_",
          "type": "int24"
        },
        {
          "internalType": "uint256",
          "name": "amount0Desired_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1Desired_",
          "type": "uint256"
        }
      ],
      "name": "addLiquidityPreview",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount0Consumed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1Consumed",
          "type": "uint256"
        },
        {
          "internalType": "uint128",
          "name": "liquidityOut",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtRatioX96",
          "type": "uint160"
        },
        {
          "internalType": "int24",
          "name": "lowerTick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick",
          "type": "int24"
        },
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "name": "getAmountsForLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IAlgebraPool",
          "name": "pool",
          "type": "IAlgebraPool"
        },
        {
          "internalType": "contract INonfungiblePositionManager",
          "name": "nft",
          "type": "INonfungiblePositionManager"
        },
        {
          "internalType": "uint256",
          "name": "tokenId",
          "type": "uint256"
        }
      ],
      "name": "getFees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "fee0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "fee1",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtRatioX96",
          "type": "uint160"
        },
        {
          "internalType": "int24",
          "name": "lowerTick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick",
          "type": "int24"
        },
        {
          "internalType": "uint256",
          "name": "amount0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1",
          "type": "uint256"
        }
      ],
      "name": "getLiquidityForAmounts",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "a",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "b",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "denominator",
          "type": "uint256"
        }
      ],
      "name": "mulDiv",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "result",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "tickSpacing",
      "outputs": [
        {
          "internalType": "int24",
          "name": "",
          "type": "int24"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x15644da1afc66581435ceee38250511b841229f30b21a17a4eef4fcfca1e9e10",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0xF553b1372610a3415BA5C2937d8F4c45fe6EB509",
    "transactionIndex": 27,
    "gasUsed": "1509202",
    "logsBloom": "0x00000000000000000000000400000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000400000000000000000000000800000000000800000000100000000000000000000000000000002000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000008000000000000000100000000000000000000002000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x9a33f9633ead33e1c1c6d8f46fdb30dad9fa315355f6155b70639514e03b2c05",
    "transactionHash": "0x15644da1afc66581435ceee38250511b841229f30b21a17a4eef4fcfca1e9e10",
    "logs": [
      {
        "transactionIndex": 27,
        "blockNumber": 51034443,
        "transactionHash": "0x15644da1afc66581435ceee38250511b841229f30b21a17a4eef4fcfca1e9e10",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bbbbb8c4364ec2ce52c59d2ed3e56f307e529a94",
          "0x000000000000000000000000ec20607aa654d823dd01beb8780a44863c57ed07"
        ],
        "data": "0x000000000000000000000000000000000000000000000000010c168fa73728000000000000000000000000000000000000000000000000087ef1c174bb3bb5470000000000000000000000000000000000000000000000246576dee01d4416fd0000000000000000000000000000000000000000000000087de5aae514048d470000000000000000000000000000000000000000000000246682f56fc47b3efd",
        "logIndex": 75,
        "blockHash": "0x9a33f9633ead33e1c1c6d8f46fdb30dad9fa315355f6155b70639514e03b2c05"
      }
    ],
    "blockNumber": 51034443,
    "cumulativeGasUsed": "3642427",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 5,
  "solcInputHash": "e76158ae9a22536febb5003c96af34b3",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"lowerTick_\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick_\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"amount0Desired_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Desired_\",\"type\":\"uint256\"}],\"name\":\"addLiquidityPreview\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Consumed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Consumed\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"liquidityOut\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtRatioX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"name\":\"getAmountsForLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAlgebraPool\",\"name\":\"pool\",\"type\":\"IAlgebraPool\"},{\"internalType\":\"contract INonfungiblePositionManager\",\"name\":\"nft\",\"type\":\"INonfungiblePositionManager\"},{\"internalType\":\"uint256\",\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtRatioX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"getLiquidityForAmounts\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"tickSpacing\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getPrice(address,address)\":{\"returns\":{\"_0\":\"price with decimals of paired token\"}},\"mulDiv(uint256,uint256,uint256)\":{\"details\":\"Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\",\"params\":{\"a\":\"The multiplicand\",\"b\":\"The multiplier\",\"denominator\":\"The divisor\"},\"returns\":{\"result\":\"The 256-bit result\"}}},\"stateVariables\":{\"MAX_SQRT_RATIO\":{\"details\":\"The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\"},\"MAX_TICK\":{\"details\":\"The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\"},\"MIN_SQRT_RATIO\":{\"details\":\"The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\"},\"MIN_TICK\":{\"details\":\"The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAmountsForLiquidity(uint160,int24,int24,uint128)\":{\"notice\":\"Computes the token0 and token1 value for a given amount of liquidity, the current pool prices and the prices at the tick boundaries\"},\"getLiquidityForAmounts(uint160,int24,int24,uint256,uint256)\":{\"notice\":\"Computes the maximum amount of liquidity received for a given amount of token0, token1, the current pool prices and the prices at the tick boundaries\"},\"getPrice(address,address)\":{\"notice\":\"Calculates price in pool\"},\"mulDiv(uint256,uint256,uint256)\":{\"notice\":\"Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/algebra/AlgebraLib.sol\":\"AlgebraLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x5f43ed533d0fc4dc2f8f081d2c4b77960f3e908d5f7359096b385e5673f1ba0c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n     */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n     */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n     */\\n  function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x953f20efa64081a325109a0e03602b889d2819c2b51c1e1fb21a062feeda74f3\",\"license\":\"MIT\"},\"contracts/integrations/algebra/AlgebraFeeConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n// coefficients for sigmoids: \\u03b1 / (1 + e^( (\\u03b2-x) / \\u03b3))\\n// alpha1 + alpha2 + baseFee must be <= type(uint16).max\\nstruct AlgebraFeeConfiguration {\\n  uint16 alpha1; // max value of the first sigmoid\\n  uint16 alpha2; // max value of the second sigmoid\\n  uint32 beta1; // shift along the x-axis for the first sigmoid\\n  uint32 beta2; // shift along the x-axis for the second sigmoid\\n  uint16 gamma1; // horizontal stretch factor for the first sigmoid\\n  uint16 gamma2; // horizontal stretch factor for the second sigmoid\\n  uint16 baseFee; // minimum possible fee\\n}\\n\",\"keccak256\":\"0x23bd41ba765c4f24dfecb3d60a6e69acfeac24f5692883e1af97bcdec8f8dfba\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IAlgebraEternalFarming.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IncentiveKey.sol\\\";\\n\\ninterface IAlgebraEternalFarming {\\n    /// @notice reward amounts can be outdated, actual amounts could be obtained via static call of `collectRewards` in FarmingCenter\\n    function getRewardInfo(\\n        IncentiveKey memory key,\\n        uint256 tokenId\\n    ) external view returns (uint256 reward, uint256 bonusReward);\\n}\",\"keccak256\":\"0xb4c25093c3cce483e49aed2dfcbcac7d241b04fb213fe92c692794b43a58f548\",\"license\":\"MIT\"},\"contracts/integrations/algebra/IAlgebraPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport './pool/IAlgebraPoolImmutables.sol';\\nimport './pool/IAlgebraPoolState.sol';\\nimport './pool/IAlgebraPoolDerivedState.sol';\\nimport './pool/IAlgebraPoolActions.sol';\\nimport './pool/IAlgebraPoolPermissionedActions.sol';\\nimport './pool/IAlgebraPoolEvents.sol';\\n\\n/**\\n * @title The interface for a Algebra Pool\\n * @dev The pool interface is broken up into many smaller pieces.\\n * Credit to Uniswap Labs under GPL-2.0-or-later license:\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\n */\\ninterface IAlgebraPool is\\nIAlgebraPoolImmutables,\\nIAlgebraPoolState,\\nIAlgebraPoolDerivedState,\\nIAlgebraPoolActions,\\nIAlgebraPoolPermissionedActions,\\nIAlgebraPoolEvents\\n{\\n  // used only for combining interfaces\\n}\\n\",\"keccak256\":\"0x1bc40e5f4b042df8aeeeafb2383b2565c39408d1b0cb28d63916dcf4d7883353\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IDataStorageOperator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\npragma abicoder v2;\\n\\nimport './AlgebraFeeConfiguration.sol';\\n\\n/// @title The interface for the DataStorageOperator\\n/// @dev This contract stores timepoints and calculates adaptive fee and statistical averages\\ninterface IDataStorageOperator {\\n  /// @notice Emitted when the fee configuration is changed\\n  /// @param feeConfig The structure with dynamic fee parameters\\n  /// @dev See the AdaptiveFee library for more details\\n  event FeeConfiguration(AlgebraFeeConfiguration feeConfig);\\n\\n  /// @notice Returns data belonging to a certain timepoint\\n  /// @param index The index of timepoint in the array\\n  /// @dev There is more convenient function to fetch a timepoint: getTimepoints(). Which requires not an index but seconds\\n  /// @return initialized Whether the timepoint has been initialized and the values are safe to use\\n  /// @return blockTimestamp The timestamp of the timepoint\\n  /// @return tickCumulative The tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp\\n  /// @return volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp\\n  /// @return tick The tick at blockTimestamp\\n  /// @return averageTick Time-weighted average tick\\n  /// @return windowStartIndex Index of closest timepoint >= WINDOW seconds ago\\n  function timepoints(\\n    uint256 index\\n  )\\n    external\\n    view\\n    returns (\\n      bool initialized,\\n      uint32 blockTimestamp,\\n      int56 tickCumulative,\\n      uint88 volatilityCumulative,\\n      int24 tick,\\n      int24 averageTick,\\n      uint16 windowStartIndex\\n    );\\n\\n  /// @notice Initialize the dataStorage array by writing the first slot. Called once for the lifecycle of the timepoints array\\n  /// @param time The time of the dataStorage initialization, via block.timestamp truncated to uint32\\n  /// @param tick Initial tick\\n  function initialize(uint32 time, int24 tick) external;\\n\\n  /// @dev Reverts if a timepoint at or before the desired timepoint timestamp does not exist.\\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\\n  /// If called with a timestamp falling between two timepoints, returns the counterfactual accumulator values\\n  /// at exactly the timestamp between the two timepoints.\\n  /// @param time The current block timestamp\\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return a timepoint\\n  /// @param tick The current tick\\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\\n  /// @return tickCumulative The cumulative tick since the pool was first initialized, as of `secondsAgo`\\n  /// @return volatilityCumulative The cumulative volatility value since the pool was first initialized, as of `secondsAgo`\\n  function getSingleTimepoint(\\n    uint32 time,\\n    uint32 secondsAgo,\\n    int24 tick,\\n    uint16 index\\n  ) external view returns (int56 tickCumulative, uint112 volatilityCumulative);\\n\\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\\n  /// @dev Reverts if `secondsAgos` > oldest timepoint\\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return a timepoint\\n  /// @return tickCumulatives The cumulative tick since the pool was first initialized, as of each `secondsAgo`\\n  /// @return volatilityCumulatives The cumulative volatility values since the pool was first initialized, as of each `secondsAgo`\\n  function getTimepoints(uint32[] memory secondsAgos) external view returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives);\\n\\n  /// @notice Writes a dataStorage timepoint to the array\\n  /// @dev Writable at most once per block. Index represents the most recently written element. index must be tracked externally.\\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\\n  /// @param blockTimestamp The timestamp of the new timepoint\\n  /// @param tick The active tick at the time of the new timepoint\\n  /// @return indexUpdated The new index of the most recently written element in the dataStorage array\\n  /// @return newFee The fee in hundredths of a bip, i.e. 1e-6\\n  function write(uint16 index, uint32 blockTimestamp, int24 tick) external returns (uint16 indexUpdated, uint16 newFee);\\n\\n  /// @notice Changes fee configuration for the pool\\n  function changeFeeConfiguration(AlgebraFeeConfiguration calldata feeConfig) external;\\n\\n  /// @notice Fills uninitialized timepoints with nonzero value\\n  /// @dev Can be used to reduce the gas cost of future swaps\\n  /// @param startIndex The start index, must be not initialized\\n  /// @param amount of slots to fill, startIndex + amount must be <= type(uint16).max\\n  function prepayTimepointsStorageSlots(uint16 startIndex, uint16 amount) external;\\n}\\n\",\"keccak256\":\"0x8f658d88ce259f0806d992a1174e8163b0fb3e5d592c01befaa8426316ca39fd\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IFarmingCenter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IAlgebraEternalFarming.sol\\\";\\nimport \\\"./IncentiveKey.sol\\\";\\nimport \\\"./INonfungiblePositionManager.sol\\\";\\n\\ninterface IFarmingCenter {\\n    /// @notice Returns information about a deposited NFT\\n    /// @param tokenId The ID of the deposit (and token) that is being transferred\\n    /// @return L2TokenId The nft layer2 id,\\n    /// numberOfFarms The number of farms,\\n    /// inLimitFarming The parameter showing if the token is in the limit farm,\\n    /// owner The owner of deposit\\n    function deposits(uint256 tokenId)\\n    external\\n    view\\n    returns (\\n        uint256 L2TokenId,\\n        uint32 numberOfFarms,\\n        bool inLimitFarming,\\n        address owner\\n    );\\n\\n    /// @notice Enters in incentive (time-limited or eternal farming) with NFT-position token\\n    /// @dev token must be deposited in FarmingCenter\\n    /// @param key The incentive event key\\n    /// @param tokenId The id of position NFT\\n    /// @param tokensLocked Amount of tokens to lock for liquidity multiplier (if tiers are used)\\n    /// @param isLimit Is incentive time-limited or eternal\\n    function enterFarming(\\n        IncentiveKey memory key,\\n        uint256 tokenId,\\n        uint256 tokensLocked,\\n        bool isLimit\\n    ) external;\\n\\n    function eternalFarming() external view returns (IAlgebraEternalFarming);\\n\\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\\n    /// @dev \\\"proxies\\\" to NonfungiblePositionManager\\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\\n    /// recipient The account that should receive the tokens,\\n    /// amount0Max The maximum amount of token0 to collect,\\n    /// amount1Max The maximum amount of token1 to collect\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(INonfungiblePositionManager.CollectParams calldata params)\\n    external\\n    returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Used to collect reward from eternal farming. Then reward can be claimed.\\n    /// @param key The incentive event key\\n    /// @param tokenId The id of position NFT\\n    /// @return reward The amount of collected reward\\n    /// @return bonusReward The amount of collected  bonus reward\\n    function collectRewards(IncentiveKey memory key, uint256 tokenId)\\n    external\\n    returns (uint256 reward, uint256 bonusReward);\\n\\n    /// @notice Used to claim and send rewards from farming(s)\\n    /// @dev can be used via static call to get current rewards for user\\n    /// @param rewardToken The token that is a reward\\n    /// @param to The address to be rewarded\\n    /// @param amountRequestedIncentive Amount to claim in incentive (limit) farming\\n    /// @param amountRequestedEternal Amount to claim in eternal farming\\n    /// @return reward The summary amount of claimed rewards\\n    function claimReward(\\n        address rewardToken,\\n        address to,\\n        uint256 amountRequestedIncentive,\\n        uint256 amountRequestedEternal\\n    ) external returns (uint256 reward);\\n\\n    /// @notice Exits from incentive (time-limited or eternal farming) with NFT-position token\\n    /// @param key The incentive event key\\n    /// @param tokenId The id of position NFT\\n    /// @param isLimit Is incentive time-limited or eternal\\n    function exitFarming(\\n        IncentiveKey memory key,\\n        uint256 tokenId,\\n        bool isLimit\\n    ) external;\\n\\n    /// @notice Withdraw Algebra NFT-position token\\n    /// @dev can be used via static call to get current rewards for user\\n    /// @param tokenId The id of position NFT\\n    /// @param to New owner of position NFT\\n    /// @param data The additional data for NonfungiblePositionManager\\n    function withdrawToken(\\n        uint256 tokenId,\\n        address to,\\n        bytes memory data\\n    ) external;\\n}\",\"keccak256\":\"0xcbe2301d25bbf917a27d4afc001b9f31b3bedf8fb1dc3be043e9d4e7b80b51aa\",\"license\":\"MIT\"},\"contracts/integrations/algebra/INonfungiblePositionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface INonfungiblePositionManager {\\n    struct MintParams {\\n        address token0;\\n        address token1;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint amount0Desired;\\n        uint amount1Desired;\\n        uint amount0Min;\\n        uint amount1Min;\\n        address recipient;\\n        uint deadline;\\n    }\\n\\n    function mint(\\n        MintParams calldata params\\n    ) external payable returns (uint tokenId, uint128 liquidity, uint amount0, uint amount1);\\n\\n    struct IncreaseLiquidityParams {\\n        uint256 tokenId;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        uint256 deadline;\\n    }\\n\\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\\n    external\\n    payable\\n    returns (\\n        uint128 liquidity,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    struct DecreaseLiquidityParams {\\n        uint tokenId;\\n        uint128 liquidity;\\n        uint amount0Min;\\n        uint amount1Min;\\n        uint deadline;\\n    }\\n\\n    function decreaseLiquidity(\\n        DecreaseLiquidityParams calldata params\\n    ) external payable returns (uint amount0, uint amount1);\\n\\n    struct CollectParams {\\n        uint tokenId;\\n        address recipient;\\n        uint128 amount0Max;\\n        uint128 amount1Max;\\n    }\\n\\n    function collect(CollectParams calldata params) external payable returns (uint amount0, uint amount1);\\n\\n    function burn(uint tokenId) external payable;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function positions(uint256 tokenId)\\n    external\\n    view\\n    returns (\\n        uint96 nonce,\\n        address operator,\\n        address token0,\\n        address token1,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 liquidity,\\n        uint256 feeGrowthInside0LastX128,\\n        uint256 feeGrowthInside1LastX128,\\n        uint128 tokensOwed0,\\n        uint128 tokensOwed1\\n    );\\n}\",\"keccak256\":\"0xc1ba265df609d9d2eeb14d4bd0dd9e1e8e9f0c11e5d47111ddf53d185578a391\",\"license\":\"MIT\"},\"contracts/integrations/algebra/IncentiveKey.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nstruct IncentiveKey {\\n    address rewardToken;\\n    address bonusRewardToken;\\n    address pool;\\n    uint256 startTime;\\n    uint256 endTime;\\n}\",\"keccak256\":\"0xbb5a5b0587571aaaf4ba6576228128a81a1be6cae32ba93357b0b992885c5aa5\",\"license\":\"MIT\"},\"contracts/integrations/algebra/pool/IAlgebraPoolActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Permissionless pool actions\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\ninterface IAlgebraPoolActions {\\n  /**\\n   * @notice Sets the initial price for the pool\\n   * @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\n   * @param price the initial sqrt price of the pool as a Q64.96\\n   */\\n  function initialize(uint160 price) external;\\n\\n  /**\\n   * @notice Adds liquidity for the given recipient/bottomTick/topTick position\\n   * @dev The caller of this method receives a callback in the form of IAlgebraMintCallback# AlgebraMintCallback\\n   * in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\n   * on bottomTick, topTick, the amount of liquidity, and the current price.\\n   * @param sender The address which will receive potential surplus of paid tokens\\n   * @param recipient The address for which the liquidity will be created\\n   * @param bottomTick The lower tick of the position in which to add liquidity\\n   * @param topTick The upper tick of the position in which to add liquidity\\n   * @param amount The desired amount of liquidity to mint\\n   * @param data Any data that should be passed through to the callback\\n   * @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n   * @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n   * @return liquidityActual The actual minted amount of liquidity\\n   */\\n  function mint(\\n    address sender,\\n    address recipient,\\n    int24 bottomTick,\\n    int24 topTick,\\n    uint128 amount,\\n    bytes calldata data\\n  )\\n  external\\n  returns (\\n    uint256 amount0,\\n    uint256 amount1,\\n    uint128 liquidityActual\\n  );\\n\\n  /**\\n   * @notice Collects tokens owed to a position\\n   * @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\n   * Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\n   * amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\n   * actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\n   * @param recipient The address which should receive the fees collected\\n   * @param bottomTick The lower tick of the position for which to collect fees\\n   * @param topTick The upper tick of the position for which to collect fees\\n   * @param amount0Requested How much token0 should be withdrawn from the fees owed\\n   * @param amount1Requested How much token1 should be withdrawn from the fees owed\\n   * @return amount0 The amount of fees collected in token0\\n   * @return amount1 The amount of fees collected in token1\\n   */\\n  function collect(\\n    address recipient,\\n    int24 bottomTick,\\n    int24 topTick,\\n    uint128 amount0Requested,\\n    uint128 amount1Requested\\n  ) external returns (uint128 amount0, uint128 amount1);\\n\\n  /**\\n   * @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\n   * @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\n   * @dev Fees must be collected separately via a call to #collect\\n   * @param bottomTick The lower tick of the position for which to burn liquidity\\n   * @param topTick The upper tick of the position for which to burn liquidity\\n   * @param amount How much liquidity to burn\\n   * @return amount0 The amount of token0 sent to the recipient\\n   * @return amount1 The amount of token1 sent to the recipient\\n   */\\n  function burn(\\n    int24 bottomTick,\\n    int24 topTick,\\n    uint128 amount\\n  ) external returns (uint256 amount0, uint256 amount1);\\n\\n  /**\\n   * @notice Swap token0 for token1, or token1 for token0\\n   * @dev The caller of this method receives a callback in the form of IAlgebraSwapCallback# AlgebraSwapCallback\\n   * @param recipient The address to receive the output of the swap\\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\\n   * SwapRouter#SwapCallbackData\\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n   */\\n  function swap(\\n    address recipient,\\n    bool zeroToOne,\\n    int256 amountSpecified,\\n    uint160 limitSqrtPrice,\\n    bytes calldata data\\n  ) external returns (int256 amount0, int256 amount1);\\n\\n  /**\\n   * @notice Swap token0 for token1, or token1 for token0 (tokens that have fee on transfer)\\n   * @dev The caller of this method receives a callback in the form of I AlgebraSwapCallback# AlgebraSwapCallback\\n   * @param sender The address called this function (Comes from the Router)\\n   * @param recipient The address to receive the output of the swap\\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\\n   * SwapRouter#SwapCallbackData\\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n   */\\n  function swapSupportingFeeOnInputTokens(\\n    address sender,\\n    address recipient,\\n    bool zeroToOne,\\n    int256 amountSpecified,\\n    uint160 limitSqrtPrice,\\n    bytes calldata data\\n  ) external returns (int256 amount0, int256 amount1);\\n\\n  /**\\n   * @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\n   * @dev The caller of this method receives a callback in the form of IAlgebraFlashCallback# AlgebraFlashCallback\\n   * @dev All excess tokens paid in the callback are distributed to liquidity providers as an additional fee. So this method can be used\\n   * to donate underlying tokens to currently in-range liquidity providers by calling with 0 amount{0,1} and sending\\n   * the donation amount(s) from the callback\\n   * @param recipient The address which will receive the token0 and token1 amounts\\n   * @param amount0 The amount of token0 to send\\n   * @param amount1 The amount of token1 to send\\n   * @param data Any data to be passed through to the callback\\n   */\\n  function flash(\\n    address recipient,\\n    uint256 amount0,\\n    uint256 amount1,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0x75c099718641859b8434da326721229718c4bc48b8b8b416c0556781cab1fd27\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolDerivedState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/**\\n * @title Pool state that is not stored\\n * @notice Contains view functions to provide information about the pool that is computed rather than stored on the\\n * blockchain. The functions here may have variable gas costs.\\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\n */\\ninterface IAlgebraPoolDerivedState {\\n  /**\\n   * @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\n   * @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\n   * the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\n   * you must call it with secondsAgos = [3600, 0].\\n   * @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\n   * log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\n   * @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\n   * @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\n   * @return secondsPerLiquidityCumulatives Cumulative seconds per liquidity-in-range value as of each `secondsAgos`\\n   * from the current block timestamp\\n   * @return volatilityCumulatives Cumulative standard deviation as of each `secondsAgos`\\n   * @return volumePerAvgLiquiditys Cumulative swap volume per liquidity as of each `secondsAgos`\\n   */\\n  function getTimepoints(uint32[] calldata secondsAgos)\\n  external\\n  view\\n  returns (\\n    int56[] memory tickCumulatives,\\n    uint160[] memory secondsPerLiquidityCumulatives,\\n    uint112[] memory volatilityCumulatives,\\n    uint256[] memory volumePerAvgLiquiditys\\n  );\\n\\n  /**\\n   * @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\\n   * @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\\n   * I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\\n   * snapshot is taken and the second snapshot is taken.\\n   * @param bottomTick The lower tick of the range\\n   * @param topTick The upper tick of the range\\n   * @return innerTickCumulative The snapshot of the tick accumulator for the range\\n   * @return innerSecondsSpentPerLiquidity The snapshot of seconds per liquidity for the range\\n   * @return innerSecondsSpent The snapshot of the number of seconds during which the price was in this range\\n   */\\n  function getInnerCumulatives(int24 bottomTick, int24 topTick)\\n  external\\n  view\\n  returns (\\n    int56 innerTickCumulative,\\n    uint160 innerSecondsSpentPerLiquidity,\\n    uint32 innerSecondsSpent\\n  );\\n}\\n\",\"keccak256\":\"0x76c81bd9ee28e501b7f7d54e329c61bd3013128b17aa25c3a62414dc62719754\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolEvents.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Events emitted by a pool\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\ninterface IAlgebraPoolEvents {\\n  /**\\n   * @notice Emitted exactly once by a pool when #initialize is first called on the pool\\n   * @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\n   * @param price The initial sqrt price of the pool, as a Q64.96\\n   * @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\\n   */\\n  event Initialize(uint160 price, int24 tick);\\n\\n  /**\\n   * @notice Emitted when liquidity is minted for a given position\\n   * @param sender The address that minted the liquidity\\n   * @param owner The owner of the position and recipient of any minted liquidity\\n   * @param bottomTick The lower tick of the position\\n   * @param topTick The upper tick of the position\\n   * @param liquidityAmount The amount of liquidity minted to the position range\\n   * @param amount0 How much token0 was required for the minted liquidity\\n   * @param amount1 How much token1 was required for the minted liquidity\\n   */\\n  event Mint(\\n    address sender,\\n    address indexed owner,\\n    int24 indexed bottomTick,\\n    int24 indexed topTick,\\n    uint128 liquidityAmount,\\n    uint256 amount0,\\n    uint256 amount1\\n  );\\n\\n  /**\\n   * @notice Emitted when fees are collected by the owner of a position\\n   * @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\\n   * @param owner The owner of the position for which fees are collected\\n   * @param recipient The address that received fees\\n   * @param bottomTick The lower tick of the position\\n   * @param topTick The upper tick of the position\\n   * @param amount0 The amount of token0 fees collected\\n   * @param amount1 The amount of token1 fees collected\\n   */\\n  event Collect(address indexed owner, address recipient, int24 indexed bottomTick, int24 indexed topTick, uint128 amount0, uint128 amount1);\\n\\n  /**\\n   * @notice Emitted when a position's liquidity is removed\\n   * @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\\n   * @param owner The owner of the position for which liquidity is removed\\n   * @param bottomTick The lower tick of the position\\n   * @param topTick The upper tick of the position\\n   * @param liquidityAmount The amount of liquidity to remove\\n   * @param amount0 The amount of token0 withdrawn\\n   * @param amount1 The amount of token1 withdrawn\\n   */\\n  event Burn(address indexed owner, int24 indexed bottomTick, int24 indexed topTick, uint128 liquidityAmount, uint256 amount0, uint256 amount1);\\n\\n  /**\\n   * @notice Emitted by the pool for any swaps between token0 and token1\\n   * @param sender The address that initiated the swap call, and that received the callback\\n   * @param recipient The address that received the output of the swap\\n   * @param amount0 The delta of the token0 balance of the pool\\n   * @param amount1 The delta of the token1 balance of the pool\\n   * @param price The sqrt(price) of the pool after the swap, as a Q64.96\\n   * @param liquidity The liquidity of the pool after the swap\\n   * @param tick The log base 1.0001 of price of the pool after the swap\\n   */\\n  event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 price, uint128 liquidity, int24 tick);\\n\\n  /**\\n   * @notice Emitted by the pool for any flashes of token0/token1\\n   * @param sender The address that initiated the swap call, and that received the callback\\n   * @param recipient The address that received the tokens from flash\\n   * @param amount0 The amount of token0 that was flashed\\n   * @param amount1 The amount of token1 that was flashed\\n   * @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\\n   * @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\\n   */\\n  event Flash(address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1);\\n\\n  /**\\n   * @notice Emitted when the community fee is changed by the pool\\n   * @param communityFee0New The updated value of the token0 community fee percent\\n   * @param communityFee1New The updated value of the token1 community fee percent\\n   */\\n  event CommunityFee(uint8 communityFee0New, uint8 communityFee1New);\\n\\n  /**\\n   * @notice Emitted when new activeIncentive is set\\n   * @param virtualPoolAddress The address of a virtual pool associated with the current active incentive\\n   */\\n  event Incentive(address indexed virtualPoolAddress);\\n\\n  /**\\n   * @notice Emitted when the fee changes\\n   * @param fee The value of the token fee\\n   */\\n  event Fee(uint16 fee);\\n\\n  /**\\n   * @notice Emitted when the LiquidityCooldown changes\\n   * @param liquidityCooldown The value of locktime for added liquidity\\n   */\\n  event LiquidityCooldown(uint32 liquidityCooldown);\\n}\\n\",\"keccak256\":\"0xba47f5fe784ed90a37ad97fbefede84e692b75a15d29d1ce8dc6bc5886f3e68e\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolImmutables.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport '../IDataStorageOperator.sol';\\n\\n/// @title Pool state that never changes\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\ninterface IAlgebraPoolImmutables {\\n  /**\\n   * @notice The contract that stores all the timepoints and can perform actions with them\\n   * @return The operator address\\n   */\\n  function dataStorageOperator() external view returns (address);\\n\\n  /**\\n   * @notice The contract that deployed the pool, which must adhere to the IAlgebraFactory interface\\n   * @return The contract address\\n   */\\n  function factory() external view returns (address);\\n\\n  /**\\n   * @notice The first of the two tokens of the pool, sorted by address\\n   * @return The token contract address\\n   */\\n  function token0() external view returns (address);\\n\\n  /**\\n   * @notice The second of the two tokens of the pool, sorted by address\\n   * @return The token contract address\\n   */\\n  function token1() external view returns (address);\\n\\n  /**\\n   * @notice The pool tick spacing\\n   * @dev Ticks can only be used at multiples of this value\\n   * e.g.: a tickSpacing of 60 means ticks can be initialized every 60th tick, i.e., ..., -120, -60, 0, 60, 120, ...\\n   * This value is an int24 to avoid casting even though it is always positive.\\n   * @return The tick spacing\\n   */\\n  function tickSpacing() external view returns (int24);\\n\\n  /**\\n   * @notice The maximum amount of position liquidity that can use any tick in the range\\n   * @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\n   * also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n   * @return The max amount of liquidity per tick\\n   */\\n  function maxLiquidityPerTick() external view returns (uint128);\\n}\\n\",\"keccak256\":\"0x5cee007433243fd525dcd9113b52f67cd29128424e82bc682a38c97b45ec814e\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolPermissionedActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/**\\n * @title Permissioned pool actions\\n * @notice Contains pool methods that may only be called by the factory owner or tokenomics\\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\n */\\ninterface IAlgebraPoolPermissionedActions {\\n  /**\\n   * @notice Set the community's % share of the fees. Cannot exceed 25% (250)\\n   * @param communityFee0 new community fee percent for token0 of the pool in thousandths (1e-3)\\n   * @param communityFee1 new community fee percent for token1 of the pool in thousandths (1e-3)\\n   */\\n  function setCommunityFee(uint8 communityFee0, uint8 communityFee1) external;\\n\\n  /**\\n   * @notice Sets an active incentive\\n   * @param virtualPoolAddress The address of a virtual pool associated with the incentive\\n   */\\n  function setIncentive(address virtualPoolAddress) external;\\n\\n  /**\\n   * @notice Sets new lock time for added liquidity\\n   * @param newLiquidityCooldown The time in seconds\\n   */\\n  function setLiquidityCooldown(uint32 newLiquidityCooldown) external;\\n}\\n\",\"keccak256\":\"0xc37a8b1f3e3742b79f17eac08cd191981f59ace5096aa1123803ddb081d30024\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that can change\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\ninterface IAlgebraPoolState {\\n  /**\\n   * @notice The globalState structure in the pool stores many values but requires only one slot\\n   * and is exposed as a single method to save gas when accessed externally.\\n   * @return price The current price of the pool as a sqrt(token1/token0) Q64.96 value;\\n   * Returns tick The current tick of the pool, i.e. according to the last tick transition that was run;\\n   * Returns This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick\\n   * boundary;\\n   * Returns fee The last pool fee value in hundredths of a bip, i.e. 1e-6;\\n   * Returns timepointIndex The index of the last written timepoint;\\n   * Returns communityFeeToken0 The community fee percentage of the swap fee in thousandths (1e-3) for token0;\\n   * Returns communityFeeToken1 The community fee percentage of the swap fee in thousandths (1e-3) for token1;\\n   * Returns unlocked Whether the pool is currently locked to reentrancy;\\n   */\\n  function globalState()\\n  external\\n  view\\n  returns (\\n    uint160 price,\\n    int24 tick,\\n    uint16 fee,\\n    uint16 timepointIndex,\\n    uint8 communityFeeToken0,\\n    uint8 communityFeeToken1,\\n    bool unlocked\\n  );\\n\\n  /**\\n   * @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n   * @dev This value can overflow the uint256\\n   */\\n  function totalFeeGrowth0Token() external view returns (uint256);\\n\\n  /**\\n   * @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n   * @dev This value can overflow the uint256\\n   */\\n  function totalFeeGrowth1Token() external view returns (uint256);\\n\\n  /**\\n   * @notice The currently in range liquidity available to the pool\\n   * @dev This value has no relationship to the total liquidity across all ticks.\\n   * Returned value cannot exceed type(uint128).max\\n   */\\n  function liquidity() external view returns (uint128);\\n\\n  /**\\n   * @notice Look up information about a specific tick in the pool\\n   * @dev This is a public structure, so the `return` natspec tags are omitted.\\n   * @param tick The tick to look up\\n   * @return liquidityTotal the total amount of position liquidity that uses the pool either as tick lower or\\n   * tick upper;\\n   * Returns liquidityDelta how much liquidity changes when the pool price crosses the tick;\\n   * Returns outerFeeGrowth0Token the fee growth on the other side of the tick from the current tick in token0;\\n   * Returns outerFeeGrowth1Token the fee growth on the other side of the tick from the current tick in token1;\\n   * Returns outerTickCumulative the cumulative tick value on the other side of the tick from the current tick;\\n   * Returns outerSecondsPerLiquidity the seconds spent per liquidity on the other side of the tick from the current tick;\\n   * Returns outerSecondsSpent the seconds spent on the other side of the tick from the current tick;\\n   * Returns initialized Set to true if the tick is initialized, i.e. liquidityTotal is greater than 0\\n   * otherwise equal to false. Outside values can only be used if the tick is initialized.\\n   * In addition, these values are only relative and must be used only in comparison to previous snapshots for\\n   * a specific position.\\n   */\\n  function ticks(int24 tick)\\n  external\\n  view\\n  returns (\\n    uint128 liquidityTotal,\\n    int128 liquidityDelta,\\n    uint256 outerFeeGrowth0Token,\\n    uint256 outerFeeGrowth1Token,\\n    int56 outerTickCumulative,\\n    uint160 outerSecondsPerLiquidity,\\n    uint32 outerSecondsSpent,\\n    bool initialized\\n  );\\n\\n  /** @notice Returns 256 packed tick initialized boolean values. See TickTable for more information */\\n  function tickTable(int16 wordPosition) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the information about a position by the position's key\\n   * @dev This is a public mapping of structures, so the `return` natspec tags are omitted.\\n   * @param key The position's key is a hash of a preimage composed by the owner, bottomTick and topTick\\n   * @return liquidityAmount The amount of liquidity in the position;\\n   * Returns lastLiquidityAddTimestamp Timestamp of last adding of liquidity;\\n   * Returns innerFeeGrowth0Token Fee growth of token0 inside the tick range as of the last mint/burn/poke;\\n   * Returns innerFeeGrowth1Token Fee growth of token1 inside the tick range as of the last mint/burn/poke;\\n   * Returns fees0 The computed amount of token0 owed to the position as of the last mint/burn/poke;\\n   * Returns fees1 The computed amount of token1 owed to the position as of the last mint/burn/poke\\n   */\\n  function positions(bytes32 key)\\n  external\\n  view\\n  returns (\\n    uint128 liquidityAmount,\\n    uint32 lastLiquidityAddTimestamp,\\n    uint256 innerFeeGrowth0Token,\\n    uint256 innerFeeGrowth1Token,\\n    uint128 fees0,\\n    uint128 fees1\\n  );\\n\\n  /**\\n   * @notice Returns data about a specific timepoint index\\n   * @param index The element of the timepoints array to fetch\\n   * @dev You most likely want to use #getTimepoints() instead of this method to get an timepoint as of some amount of time\\n   * ago, rather than at a specific index in the array.\\n   * This is a public mapping of structures, so the `return` natspec tags are omitted.\\n   * @return initialized whether the timepoint has been initialized and the values are safe to use;\\n   * Returns blockTimestamp The timestamp of the timepoint;\\n   * Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp;\\n   * Returns secondsPerLiquidityCumulative the seconds per in range liquidity for the life of the pool as of the timepoint timestamp;\\n   * Returns volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp;\\n   * Returns averageTick Time-weighted average tick;\\n   * Returns volumePerLiquidityCumulative Cumulative swap volume per liquidity for the life of the pool as of the timepoint timestamp;\\n   */\\n  function timepoints(uint256 index)\\n  external\\n  view\\n  returns (\\n    bool initialized,\\n    uint32 blockTimestamp,\\n    int56 tickCumulative,\\n    uint160 secondsPerLiquidityCumulative,\\n    uint88 volatilityCumulative,\\n    int24 averageTick,\\n    uint144 volumePerLiquidityCumulative\\n  );\\n\\n  /**\\n   * @notice Returns the information about active incentive\\n   * @dev if there is no active incentive at the moment, virtualPool,endTimestamp,startTimestamp would be equal to 0\\n   * @return virtualPool The address of a virtual pool associated with the current active incentive\\n   */\\n  function activeIncentive() external view returns (address virtualPool);\\n\\n  /**\\n   * @notice Returns the lock time for added liquidity\\n   */\\n  function liquidityCooldown() external view returns (uint32 cooldownInSeconds);\\n}\\n\",\"keccak256\":\"0x2b1226fe9dd67d0759555d8ae8887b3120254f078ec5e0911ded034e594061e3\",\"license\":\"GPL-2.0-or-later\"},\"contracts/strategies/algebra/AlgebraLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"../../integrations/algebra/IAlgebraPool.sol\\\";\\nimport \\\"../../integrations/algebra/INonfungiblePositionManager.sol\\\";\\nimport \\\"../../integrations/algebra/IFarmingCenter.sol\\\";\\nimport \\\"../../integrations/algebra/IncentiveKey.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\n\\nlibrary AlgebraLib {\\n  int24 internal constant TICKSPACING = 60;\\n  uint8 internal constant RESOLUTION = 96;\\n  uint internal constant Q96 = 0x1000000000000000000000000;\\n  uint private constant TWO_96 = 2 ** 96;\\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n  uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n  uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n  int24 internal constant MIN_TICK = - 887272;\\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n  int24 internal constant MAX_TICK = - MIN_TICK;\\n\\n  function tickSpacing() external pure returns (int24) {\\n    return TICKSPACING;\\n  }\\n\\n  function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\\n    IAlgebraPool pool = IAlgebraPool(pool_);\\n    (uint160 sqrtRatioX96, , , , , ,) = pool.globalState();\\n    liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\\n    (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\\n  }\\n\\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\n  /// pool prices and the prices at the tick boundaries\\n  function getLiquidityForAmounts(\\n    uint160 sqrtRatioX96,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    uint amount0,\\n    uint amount1\\n  ) public pure returns (uint128 liquidity) {\\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n\\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\\n      liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n      uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\\n      uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\n    } else {\\n      liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\\n    }\\n  }\\n\\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\n  /// pool prices and the prices at the tick boundaries\\n  function getAmountsForLiquidity(\\n    uint160 sqrtRatioX96,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    uint128 liquidity\\n  ) public pure returns (uint amount0, uint amount1) {\\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\\n\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n\\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\\n      amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n      amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\\n    } else {\\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n    }\\n  }\\n\\n  /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\\n  /// @param a The multiplicand\\n  /// @param b The multiplier\\n  /// @param denominator The divisor\\n  /// @return result The 256-bit result\\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n  function mulDiv(\\n    uint a,\\n    uint b,\\n    uint denominator\\n  ) public pure returns (uint result) {\\n    unchecked {\\n      // 512-bit multiply [prod1 prod0] = a * b\\n      // Compute the product mod 2**256 and mod 2**256 - 1\\n      // then use the Chinese Remainder Theorem to reconstruct\\n      // the 512 bit result. The result is stored in two 256\\n      // variables such that product = prod1 * 2**256 + prod0\\n      uint prod0;\\n      // Least significant 256 bits of the product\\n      uint prod1;\\n      // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(a, b, not(0))\\n        prod0 := mul(a, b)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n      // Handle non-overflow cases, 256 by 256 division\\n      if (prod1 == 0) {\\n        require(denominator > 0);\\n        assembly {\\n          result := div(prod0, denominator)\\n        }\\n        return result;\\n      }\\n\\n      // Make sure the result is less than 2**256.\\n      // Also prevents denominator == 0\\n      require(denominator > prod1);\\n\\n      ///////////////////////////////////////////////\\n      // 512 by 256 division.\\n      ///////////////////////////////////////////////\\n\\n      // Make division exact by subtracting the remainder from [prod1 prod0]\\n      // Compute remainder using mulmod\\n      uint remainder;\\n      assembly {\\n        remainder := mulmod(a, b, denominator)\\n      }\\n      // Subtract 256 bit number from 512 bit number\\n      assembly {\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n      // Factor powers of two out of denominator\\n      // Compute largest power of two divisor of denominator.\\n      // Always >= 1.\\n      // EDIT for 0.8 compatibility:\\n      // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\\n      uint twos = denominator & (~denominator + 1);\\n\\n      // Divide denominator by power of two\\n      assembly {\\n        denominator := div(denominator, twos)\\n      }\\n\\n      // Divide [prod1 prod0] by the factors of two\\n      assembly {\\n        prod0 := div(prod0, twos)\\n      }\\n      // Shift in bits from prod1 into prod0. For this we need\\n      // to flip `twos` such that it is 2**256 / twos.\\n      // If twos is zero, then it becomes one\\n      assembly {\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n      prod0 |= prod1 * twos;\\n\\n      // Invert denominator mod 2**256\\n      // Now that denominator is an odd number, it has an inverse\\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n      // Compute the inverse by starting with a seed that is correct\\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n      uint inv = (3 * denominator) ^ 2;\\n      // Now use Newton-Raphson iteration to improve the precision.\\n      // Thanks to Hensel's lifting lemma, this also works in modular\\n      // arithmetic, doubling the correct bits in each step.\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**8\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**16\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**32\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**64\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**128\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**256\\n\\n      // Because the division is now exact we can divide by multiplying\\n      // with the modular inverse of denominator. This will give us the\\n      // correct result modulo 2**256. Since the precoditions guarantee\\n      // that the outcome is less than 2**256, this is the final result.\\n      // We don't need to compute the high bits of the result and prod1\\n      // is no longer required.\\n      result = prod0 * inv;\\n      return result;\\n    }\\n  }\\n\\n  /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\\n  /// @param a The multiplicand\\n  /// @param b The multiplier\\n  /// @param denominator The divisor\\n  /// @return result The 256-bit result\\n  function mulDivRoundingUp(\\n    uint a,\\n    uint b,\\n    uint denominator\\n  ) internal pure returns (uint result) {\\n    result = mulDiv(a, b, denominator);\\n    if (mulmod(a, b, denominator) > 0) {\\n      require(result < type(uint).max);\\n      result++;\\n    }\\n  }\\n\\n  /// @notice Calculates price in pool\\n  /// @return price with decimals of paired token\\n  function getPrice(address pool_, address tokenIn) public view returns (uint) {\\n    IAlgebraPool pool = IAlgebraPool(pool_);\\n    address token0 = pool.token0();\\n    address token1 = pool.token1();\\n\\n    uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\\n    uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\\n    (uint160 sqrtPriceX96,,,,,,) = pool.globalState();\\n\\n    uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\\n\\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\\n    uint purePrice;\\n    uint precision;\\n    if (tokenIn == token0) {\\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\\n      purePrice = part * part;\\n    } else {\\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\\n      purePrice = part * part;\\n    }\\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\\n  }\\n\\n  function getFees(IAlgebraPool pool, INonfungiblePositionManager nft, uint tokenId) public view returns (uint fee0, uint fee1) {\\n    (, int24 tick, , , , ,) = pool.globalState();\\n    (,,,,int24 lowerTick,int24 upperTick,uint128 liquidity,uint feeGrowthInside0Last, uint feeGrowthInside1Last, uint128 tokensOwed0, uint128 tokensOwed1) = nft.positions(tokenId);\\n    fee0 = _computeFeesEarned(pool, lowerTick, upperTick, liquidity, true, feeGrowthInside0Last, tick) + uint(tokensOwed0);\\n    fee1 = _computeFeesEarned(pool, lowerTick, upperTick, liquidity, false, feeGrowthInside1Last, tick) + uint(tokensOwed1);\\n  }\\n\\n  function _computeFeesEarned(\\n    IAlgebraPool pool,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    uint128 liquidity,\\n    bool isZero,\\n    uint feeGrowthInsideLast,\\n    int24 tick\\n  ) internal view returns (uint fee) {\\n    uint feeGrowthOutsideLower;\\n    uint feeGrowthOutsideUpper;\\n    uint feeGrowthGlobal;\\n    if (isZero) {\\n      feeGrowthGlobal = pool.totalFeeGrowth0Token();\\n      (,, feeGrowthOutsideLower,,,,,) = pool.ticks(lowerTick);\\n      (,, feeGrowthOutsideUpper,,,,,) = pool.ticks(upperTick);\\n    } else {\\n      feeGrowthGlobal = pool.totalFeeGrowth1Token();\\n      (,,, feeGrowthOutsideLower,,,,) = pool.ticks(lowerTick);\\n      (,,, feeGrowthOutsideUpper,,,,) = pool.ticks(upperTick);\\n    }\\n\\n    unchecked {\\n      // calculate fee growth below\\n      uint feeGrowthBelow;\\n      if (tick >= lowerTick) {\\n        feeGrowthBelow = feeGrowthOutsideLower;\\n      } else {\\n        feeGrowthBelow = feeGrowthGlobal - feeGrowthOutsideLower;\\n      }\\n      // calculate fee growth above\\n      uint feeGrowthAbove;\\n      if (tick < upperTick) {\\n        feeGrowthAbove = feeGrowthOutsideUpper;\\n      } else {\\n        feeGrowthAbove = feeGrowthGlobal - feeGrowthOutsideUpper;\\n      }\\n\\n      uint feeGrowthInside = feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove;\\n      fee = mulDiv(\\n        liquidity,\\n        feeGrowthInside - feeGrowthInsideLast,\\n        0x100000000000000000000000000000000\\n      );\\n    }\\n  }\\n\\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\\n  /// @param sqrtRatioAX96 A sqrt price\\n  /// @param sqrtRatioBX96 Another sqrt price\\n  /// @param amount0 The amount0 being sent in\\n  /// @return liquidity The amount of returned liquidity\\n  function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n    uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\\n    return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\\n  }\\n\\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\n  /// @param sqrtRatioAX96 A sqrt price\\n  /// @param sqrtRatioBX96 Another sqrt price\\n  /// @param amount1 The amount1 being sent in\\n  /// @return liquidity The amount of returned liquidity\\n  function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n    return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\\n  }\\n\\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\n  /// @param sqrtRatioAX96 A sqrt price\\n  /// @param sqrtRatioBX96 Another sqrt price\\n  /// @param liquidity The liquidity being valued\\n  /// @return amount0 The amount0\\n  function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n    return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\\n  }\\n\\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\n  /// @param sqrtRatioAX96 A sqrt price\\n  /// @param sqrtRatioBX96 Another sqrt price\\n  /// @param liquidity The liquidity being valued\\n  /// @return amount1 The amount1\\n  function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n    return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\\n  }\\n\\n  function _countDigits(uint n) internal pure returns (uint) {\\n    if (n == 0) {\\n      return 0;\\n    }\\n    uint count = 0;\\n    while (n != 0) {\\n      n = n / 10;\\n      ++count;\\n    }\\n    return count;\\n  }\\n\\n  function _min(uint a, uint b) internal pure returns (uint) {\\n    return a < b ? a : b;\\n  }\\n\\n  function _max(uint a, uint b) internal pure returns (uint) {\\n    return a > b ? a : b;\\n  }\\n\\n  function _toUint128(uint x) private pure returns (uint128 y) {\\n    require((y = uint128(x)) == x);\\n  }\\n\\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n  /// @dev Throws if |tick| > max tick\\n  /// @param tick The input tick for the above formula\\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n  /// at the given tick\\n  function _getSqrtRatioAtTick(int24 tick)\\n  internal\\n  pure\\n  returns (uint160 sqrtPriceX96)\\n  {\\n    uint256 absTick =\\n      tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\\n\\n    // EDIT: 0.8 compatibility\\n    require(absTick <= uint256(int256(MAX_TICK)), \\\"T\\\");\\n\\n    uint256 ratio =\\n      absTick & 0x1 != 0\\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\\n        : 0x100000000000000000000000000000000;\\n    if (absTick & 0x2 != 0)\\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n    if (absTick & 0x4 != 0)\\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n    if (absTick & 0x8 != 0)\\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n    if (absTick & 0x10 != 0)\\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n    if (absTick & 0x20 != 0)\\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n    if (absTick & 0x40 != 0)\\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n    if (absTick & 0x80 != 0)\\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n    if (absTick & 0x100 != 0)\\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n    if (absTick & 0x200 != 0)\\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n    if (absTick & 0x400 != 0)\\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n    if (absTick & 0x800 != 0)\\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n    if (absTick & 0x1000 != 0)\\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n    if (absTick & 0x2000 != 0)\\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n    if (absTick & 0x4000 != 0)\\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n    if (absTick & 0x8000 != 0)\\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n    if (absTick & 0x10000 != 0)\\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n    if (absTick & 0x20000 != 0)\\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n    if (absTick & 0x40000 != 0)\\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n    if (absTick & 0x80000 != 0)\\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n    if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n    sqrtPriceX96 = uint160(\\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\n    );\\n  }\\n\\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n  /// ever return.\\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n  function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n    // second inequality must be < because the price can never reach the price at the max tick\\n    require(\\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\\n      \\\"R\\\"\\n    );\\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n    uint256 r = ratio;\\n    uint256 msb = 0;\\n\\n    assembly {\\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(5, gt(r, 0xFFFFFFFF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(4, gt(r, 0xFFFF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(3, gt(r, 0xFF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(2, gt(r, 0xF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(1, gt(r, 0x3))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := gt(r, 0x1)\\n      msb := or(msb, f)\\n    }\\n\\n    if (msb >= 128) r = ratio >> (msb - 127);\\n    else r = ratio << (127 - msb);\\n\\n    int256 log_2 = (int256(msb) - 128) << 64;\\n\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(63, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(62, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(61, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(60, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(59, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(58, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(57, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(56, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(55, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(54, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(53, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(52, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(51, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(50, f))\\n    }\\n\\n    tick = _getFinalTick(log_2, sqrtPriceX96);\\n  }\\n\\n  function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n    // 128.128 number\\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\\n\\n    int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n    int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n    tick = (tickLow == tickHi)\\n      ? tickLow\\n      : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow);\\n  }\\n}\\n\",\"keccak256\":\"0x2c9546429753a89c11395c58bd544940f3b8a32bd6815a1d06ca89286dabf6e9\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x611a5661003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100775760003560e01c80630337236a1461007c57806317c22c3c146100ac5780632a279b28146100e3578063455791781461010b578063aa9a09121461011e578063ac41865a1461013f578063d0c93a7c14610152575b600080fd5b61008f61008a3660046113fa565b610161565b6040516001600160801b0390911681526020015b60405180910390f35b6100bf6100ba3660046113fa565b61023e565b6040805193845260208401929092526001600160801b0316908201526060016100a3565b6100f66100f136600461146a565b6102e1565b604080519283526020830191909152016100a3565b6100f66101193660046114c6565b610397565b61013161012c366004611507565b6104ef565b6040519081526020016100a3565b61013161014d366004611533565b6105a3565b604051603c81526020016100a3565b60008061016d86610a4c565b9050600061017a86610a4c565b9050806001600160a01b0316826001600160a01b0316111561019857905b816001600160a01b0316886001600160a01b0316116101c3576101bc828287610e66565b9250610233565b806001600160a01b0316886001600160a01b031610156102255760006101ea898388610e66565b905060006101f9848b88610ed9565b9050806001600160801b0316826001600160801b03161061021a578061021c565b815b94505050610233565b610230828286610ed9565b92505b505095945050505050565b6000806000808890506000816001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa158015610287573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ab91906115b5565b50505050505090506102c0818a8a8a8a610161565b92506102ce818a8a866102e1565b909b909a50929850919650505050505050565b60008060006102ef86610a4c565b905060006102fc86610a4c565b9050806001600160a01b0316826001600160a01b0316111561031a57905b816001600160a01b0316886001600160a01b0316116103455761033e828287610f0f565b935061038c565b806001600160a01b0316886001600160a01b0316101561037e5761036a888287610f0f565b9350610377828987610f79565b925061038c565b610389828287610f79565b92505b505094509492505050565b6000806000856001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa1580156103da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103fe91906115b5565b505050505091505060008060008060008060008b6001600160a01b03166399fbab888c6040518263ffffffff1660e01b815260040161043f91815260200190565b61016060405180830381865afa15801561045d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610481919061164b565b9a509a509a509a509a509a509a5050505050816001600160801b03166104ad8e89898960018a8f610fc3565b6104b79190611738565b9950806001600160801b03166104d38e8989896000898f610fc3565b6104dd9190611738565b98505050505050505050935093915050565b6000808060001985870985870292508281108382030391505080600003610528576000841161051d57600080fd5b50829004905061059c565b80841161053457600080fd5b600084868809851960019081018716968790049682860381900495909211909303600082900391909104909201919091029190911760038402600290811880860282030280860282030280860282030280860282030280860282030280860290910302029150505b9392505050565b6000808390506000816001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060d919061174b565b90506000826001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561064f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610673919061174b565b90506000826001600160a01b0316866001600160a01b0316146106f757816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f29190611768565b610759565b826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610735573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107599190611768565b60ff1690506000826001600160a01b0316876001600160a01b0316146107e057826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107db9190611768565b610842565b836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561081e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108429190611768565b60ff1690506000856001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa158015610887573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ab91906115b5565b50505050505090506000601283106108c45760016108ee565b6108ee6108d285600a611867565b6108dd85600a611867565b6108e79190611889565b600161132a565b90506000610904836001600160a01b0316611340565b9050600080886001600160a01b03168c6001600160a01b03160361098c5786601d841061093257600061093d565b61093d84601d61189d565b6109479190611738565b61095290600a611867565b90506000600160601b61096e836001600160a01b0389166118b0565b6109789190611889565b905061098481806118b0565b9250506109f2565b86601d841161099c5760006109a7565b6109a7601d8561189d565b6109b19190611738565b6109bc90600a611867565b905060006001600160a01b0386166109d883600160601b6118b0565b6109e29190611889565b90506109ee81806118b0565b9250505b670de0b6b3a76400008111610a08576001610a1a565b610a1a670de0b6b3a764000082611889565b81610a258685611889565b610a2f9190611889565b610a399190611889565b9a50505050505050505050505b92915050565b60008060008360020b12610a63578260020b610a70565b8260020b610a70906118c7565b9050610a7f620d89e7196118e3565b60020b811115610ab95760405162461bcd60e51b81526020600482015260016024820152601560fa1b604482015260640160405180910390fd5b600081600116600003610ad057600160801b610ae2565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b031690506002821615610b17576080610b12826ffff97272373d413259a46990580e213a6118b0565b901c90505b6004821615610b41576080610b3c826ffff2e50f5f656932ef12357cf3c7fdcc6118b0565b901c90505b6008821615610b6b576080610b66826fffe5caca7e10e4e61c3624eaa0941cd06118b0565b901c90505b6010821615610b95576080610b90826fffcb9843d60f6159c9db58835c9266446118b0565b901c90505b6020821615610bbf576080610bba826fff973b41fa98c081472e6896dfb254c06118b0565b901c90505b6040821615610be9576080610be4826fff2ea16466c96a3843ec78b326b528616118b0565b901c90505b6080821615610c13576080610c0e826ffe5dee046a99a2a811c461f1969c30536118b0565b901c90505b610100821615610c3e576080610c39826ffcbe86c7900a88aedcffc83b479aa3a46118b0565b901c90505b610200821615610c69576080610c64826ff987a7253ac413176f2b074cf7815e546118b0565b901c90505b610400821615610c94576080610c8f826ff3392b0822b70005940c7a398e4b70f36118b0565b901c90505b610800821615610cbf576080610cba826fe7159475a2c29b7443b29c7fa6e889d96118b0565b901c90505b611000821615610cea576080610ce5826fd097f3bdfd2022b8845ad8f792aa58256118b0565b901c90505b612000821615610d15576080610d10826fa9f746462d870fdf8a65dc1f90e061e56118b0565b901c90505b614000821615610d40576080610d3b826f70d869a156d2a1b890bb3df62baf32f76118b0565b901c90505b618000821615610d6b576080610d66826f31be135f97d08fd981231505542fcfa66118b0565b901c90505b62010000821615610d97576080610d92826f09aa508b5b7a84e1c677de54f3e99bc96118b0565b901c90505b62020000821615610dc2576080610dbd826e5d6af8dedb81196699c329225ee6046118b0565b901c90505b62040000821615610dec576080610de7826d2216e584f5fa1ea926041bedfe986118b0565b901c90505b62080000821615610e14576080610e0f826b048a170391f7dc42444e8fa26118b0565b901c90505b60008460020b1315610e2f57610e2c81600019611889565b90505b610e3e64010000000082611905565b15610e4a576001610e4d565b60005b610e5e9060ff16602083901c611738565b949350505050565b6000826001600160a01b0316846001600160a01b03161115610e86579192915b6000610ea9856001600160a01b0316856001600160a01b0316600160601b6104ef565b9050610ed0610ecb8483610ebd8989611919565b6001600160a01b03166104ef565b611378565b95945050505050565b6000826001600160a01b0316846001600160a01b03161115610ef9579192915b610e5e610ecb83600160601b610ebd8888611919565b6000826001600160a01b0316846001600160a01b03161115610f2f579192915b610e5e6001610f6a600160601b600160e01b03606086901b16610f528888611919565b6001600160a01b0316876001600160a01b0316611393565b866001600160a01b0316611393565b6000826001600160a01b0316846001600160a01b03161115610f99579192915b610e5e6001600160801b038316610fb08686611919565b6001600160a01b0316600160601b611393565b600080600080861561114a578a6001600160a01b0316636378ae446040518163ffffffff1660e01b8152600401602060405180830381865afa15801561100d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110319190611940565b60405163f30dba9360e01b815260028c900b60048201529091506001600160a01b038c169063f30dba939060240161010060405180830381865afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190611959565b909192939495965090919293949550909192935090919250909150905050809350508a6001600160a01b031663f30dba938a6040518263ffffffff1660e01b81526004016110f8919060029190910b815260200190565b61010060405180830381865afa158015611116573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061113a9190611959565b509397506112c195505050505050565b8a6001600160a01b031663ecdecf426040518163ffffffff1660e01b8152600401602060405180830381865afa158015611188573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ac9190611940565b60405163f30dba9360e01b815260028c900b60048201529091506001600160a01b038c169063f30dba939060240161010060405180830381865afa1580156111f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121c9190611959565b90919293949596509091929394955090919293945090919250909150905050809350508a6001600160a01b031663f30dba938a6040518263ffffffff1660e01b8152600401611274919060029190910b815260200190565b61010060405180830381865afa158015611292573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112b69190611959565b509297505050505050505b60008a60020b8660020b126112d75750826112dc565b508281035b60008a60020b8760020b12156112f35750826112f8565b508282035b8183038190036113186001600160801b038c168a8303600160801b6104ef565b9e9d5050505050505050505050505050565b6000818311611339578161059c565b5090919050565b60008160000361135257506000919050565b60005b8215610a4657611366600a84611889565b925061137181611a07565b9050611355565b806001600160801b038116811461138e57600080fd5b919050565b60006113a08484846104ef565b9050600082806113b2576113b2611873565b848609111561059c5760001981106113c957600080fd5b80610ed081611a07565b6001600160a01b03811681146113e857600080fd5b50565b8060020b81146113e857600080fd5b600080600080600060a0868803121561141257600080fd5b853561141d816113d3565b9450602086013561142d816113eb565b9350604086013561143d816113eb565b94979396509394606081013594506080013592915050565b6001600160801b03811681146113e857600080fd5b6000806000806080858703121561148057600080fd5b843561148b816113d3565b9350602085013561149b816113eb565b925060408501356114ab816113eb565b915060608501356114bb81611455565b939692955090935050565b6000806000606084860312156114db57600080fd5b83356114e6816113d3565b925060208401356114f6816113d3565b929592945050506040919091013590565b60008060006060848603121561151c57600080fd5b505081359360208301359350604090920135919050565b6000806040838503121561154657600080fd5b8235611551816113d3565b91506020830135611561816113d3565b809150509250929050565b805161138e816113d3565b805161138e816113eb565b805161ffff8116811461138e57600080fd5b805160ff8116811461138e57600080fd5b8051801515811461138e57600080fd5b600080600080600080600060e0888a0312156115d057600080fd5b87516115db816113d3565b60208901519097506115ec816113eb565b95506115fa60408901611582565b945061160860608901611582565b935061161660808901611594565b925061162460a08901611594565b915061163260c089016115a5565b905092959891949750929550565b805161138e81611455565b60008060008060008060008060008060006101608c8e03121561166d57600080fd5b8b516bffffffffffffffffffffffff8116811461168957600080fd5b60208d0151909b5061169a816113d3565b60408d0151909a506116ab816113d3565b98506116b960608d0161156c565b97506116c760808d01611577565b96506116d560a08d01611577565b95506116e360c08d01611640565b945060e08c015193506101008c015192506117016101208d01611640565b91506117106101408d01611640565b90509295989b509295989b9093969950565b634e487b7160e01b600052601160045260246000fd5b80820180821115610a4657610a46611722565b60006020828403121561175d57600080fd5b815161059c816113d3565b60006020828403121561177a57600080fd5b61059c82611594565b600181815b808511156117be5781600019048211156117a4576117a4611722565b808516156117b157918102915b93841c9390800290611788565b509250929050565b6000826117d557506001610a46565b816117e257506000610a46565b81600181146117f857600281146118025761181e565b6001915050610a46565b60ff84111561181357611813611722565b50506001821b610a46565b5060208310610133831016604e8410600b8410161715611841575081810a610a46565b61184b8383611783565b806000190482111561185f5761185f611722565b029392505050565b600061059c83836117c6565b634e487b7160e01b600052601260045260246000fd5b60008261189857611898611873565b500490565b81810381811115610a4657610a46611722565b8082028115828204841417610a4657610a46611722565b6000600160ff1b82016118dc576118dc611722565b5060000390565b60008160020b627fffff1981036118fc576118fc611722565b60000392915050565b60008261191457611914611873565b500690565b6001600160a01b0382811682821603908082111561193957611939611722565b5092915050565b60006020828403121561195257600080fd5b5051919050565b600080600080600080600080610100898b03121561197657600080fd5b885161198181611455565b80985050602089015180600f0b811461199957600080fd5b80975050604089015195506060890151945060808901518060060b81146119bf57600080fd5b60a08a01519094506119d0816113d3565b60c08a015190935063ffffffff811681146119ea57600080fd5b91506119f860e08a016115a5565b90509295985092959890939650565b600060018201611a1957611a19611722565b506001019056fea26469706673582212202d2a6abababd3e096181b445fdd2e41790e62b81727a3b3c2700712e3acd3c3d64736f6c63430008110033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100775760003560e01c80630337236a1461007c57806317c22c3c146100ac5780632a279b28146100e3578063455791781461010b578063aa9a09121461011e578063ac41865a1461013f578063d0c93a7c14610152575b600080fd5b61008f61008a3660046113fa565b610161565b6040516001600160801b0390911681526020015b60405180910390f35b6100bf6100ba3660046113fa565b61023e565b6040805193845260208401929092526001600160801b0316908201526060016100a3565b6100f66100f136600461146a565b6102e1565b604080519283526020830191909152016100a3565b6100f66101193660046114c6565b610397565b61013161012c366004611507565b6104ef565b6040519081526020016100a3565b61013161014d366004611533565b6105a3565b604051603c81526020016100a3565b60008061016d86610a4c565b9050600061017a86610a4c565b9050806001600160a01b0316826001600160a01b0316111561019857905b816001600160a01b0316886001600160a01b0316116101c3576101bc828287610e66565b9250610233565b806001600160a01b0316886001600160a01b031610156102255760006101ea898388610e66565b905060006101f9848b88610ed9565b9050806001600160801b0316826001600160801b03161061021a578061021c565b815b94505050610233565b610230828286610ed9565b92505b505095945050505050565b6000806000808890506000816001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa158015610287573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102ab91906115b5565b50505050505090506102c0818a8a8a8a610161565b92506102ce818a8a866102e1565b909b909a50929850919650505050505050565b60008060006102ef86610a4c565b905060006102fc86610a4c565b9050806001600160a01b0316826001600160a01b0316111561031a57905b816001600160a01b0316886001600160a01b0316116103455761033e828287610f0f565b935061038c565b806001600160a01b0316886001600160a01b0316101561037e5761036a888287610f0f565b9350610377828987610f79565b925061038c565b610389828287610f79565b92505b505094509492505050565b6000806000856001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa1580156103da573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103fe91906115b5565b505050505091505060008060008060008060008b6001600160a01b03166399fbab888c6040518263ffffffff1660e01b815260040161043f91815260200190565b61016060405180830381865afa15801561045d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610481919061164b565b9a509a509a509a509a509a509a5050505050816001600160801b03166104ad8e89898960018a8f610fc3565b6104b79190611738565b9950806001600160801b03166104d38e8989896000898f610fc3565b6104dd9190611738565b98505050505050505050935093915050565b6000808060001985870985870292508281108382030391505080600003610528576000841161051d57600080fd5b50829004905061059c565b80841161053457600080fd5b600084868809851960019081018716968790049682860381900495909211909303600082900391909104909201919091029190911760038402600290811880860282030280860282030280860282030280860282030280860282030280860290910302029150505b9392505050565b6000808390506000816001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061060d919061174b565b90506000826001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561064f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610673919061174b565b90506000826001600160a01b0316866001600160a01b0316146106f757816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156106ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f29190611768565b610759565b826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610735573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107599190611768565b60ff1690506000826001600160a01b0316876001600160a01b0316146107e057826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107b7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107db9190611768565b610842565b836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561081e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108429190611768565b60ff1690506000856001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa158015610887573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ab91906115b5565b50505050505090506000601283106108c45760016108ee565b6108ee6108d285600a611867565b6108dd85600a611867565b6108e79190611889565b600161132a565b90506000610904836001600160a01b0316611340565b9050600080886001600160a01b03168c6001600160a01b03160361098c5786601d841061093257600061093d565b61093d84601d61189d565b6109479190611738565b61095290600a611867565b90506000600160601b61096e836001600160a01b0389166118b0565b6109789190611889565b905061098481806118b0565b9250506109f2565b86601d841161099c5760006109a7565b6109a7601d8561189d565b6109b19190611738565b6109bc90600a611867565b905060006001600160a01b0386166109d883600160601b6118b0565b6109e29190611889565b90506109ee81806118b0565b9250505b670de0b6b3a76400008111610a08576001610a1a565b610a1a670de0b6b3a764000082611889565b81610a258685611889565b610a2f9190611889565b610a399190611889565b9a50505050505050505050505b92915050565b60008060008360020b12610a63578260020b610a70565b8260020b610a70906118c7565b9050610a7f620d89e7196118e3565b60020b811115610ab95760405162461bcd60e51b81526020600482015260016024820152601560fa1b604482015260640160405180910390fd5b600081600116600003610ad057600160801b610ae2565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b031690506002821615610b17576080610b12826ffff97272373d413259a46990580e213a6118b0565b901c90505b6004821615610b41576080610b3c826ffff2e50f5f656932ef12357cf3c7fdcc6118b0565b901c90505b6008821615610b6b576080610b66826fffe5caca7e10e4e61c3624eaa0941cd06118b0565b901c90505b6010821615610b95576080610b90826fffcb9843d60f6159c9db58835c9266446118b0565b901c90505b6020821615610bbf576080610bba826fff973b41fa98c081472e6896dfb254c06118b0565b901c90505b6040821615610be9576080610be4826fff2ea16466c96a3843ec78b326b528616118b0565b901c90505b6080821615610c13576080610c0e826ffe5dee046a99a2a811c461f1969c30536118b0565b901c90505b610100821615610c3e576080610c39826ffcbe86c7900a88aedcffc83b479aa3a46118b0565b901c90505b610200821615610c69576080610c64826ff987a7253ac413176f2b074cf7815e546118b0565b901c90505b610400821615610c94576080610c8f826ff3392b0822b70005940c7a398e4b70f36118b0565b901c90505b610800821615610cbf576080610cba826fe7159475a2c29b7443b29c7fa6e889d96118b0565b901c90505b611000821615610cea576080610ce5826fd097f3bdfd2022b8845ad8f792aa58256118b0565b901c90505b612000821615610d15576080610d10826fa9f746462d870fdf8a65dc1f90e061e56118b0565b901c90505b614000821615610d40576080610d3b826f70d869a156d2a1b890bb3df62baf32f76118b0565b901c90505b618000821615610d6b576080610d66826f31be135f97d08fd981231505542fcfa66118b0565b901c90505b62010000821615610d97576080610d92826f09aa508b5b7a84e1c677de54f3e99bc96118b0565b901c90505b62020000821615610dc2576080610dbd826e5d6af8dedb81196699c329225ee6046118b0565b901c90505b62040000821615610dec576080610de7826d2216e584f5fa1ea926041bedfe986118b0565b901c90505b62080000821615610e14576080610e0f826b048a170391f7dc42444e8fa26118b0565b901c90505b60008460020b1315610e2f57610e2c81600019611889565b90505b610e3e64010000000082611905565b15610e4a576001610e4d565b60005b610e5e9060ff16602083901c611738565b949350505050565b6000826001600160a01b0316846001600160a01b03161115610e86579192915b6000610ea9856001600160a01b0316856001600160a01b0316600160601b6104ef565b9050610ed0610ecb8483610ebd8989611919565b6001600160a01b03166104ef565b611378565b95945050505050565b6000826001600160a01b0316846001600160a01b03161115610ef9579192915b610e5e610ecb83600160601b610ebd8888611919565b6000826001600160a01b0316846001600160a01b03161115610f2f579192915b610e5e6001610f6a600160601b600160e01b03606086901b16610f528888611919565b6001600160a01b0316876001600160a01b0316611393565b866001600160a01b0316611393565b6000826001600160a01b0316846001600160a01b03161115610f99579192915b610e5e6001600160801b038316610fb08686611919565b6001600160a01b0316600160601b611393565b600080600080861561114a578a6001600160a01b0316636378ae446040518163ffffffff1660e01b8152600401602060405180830381865afa15801561100d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110319190611940565b60405163f30dba9360e01b815260028c900b60048201529091506001600160a01b038c169063f30dba939060240161010060405180830381865afa15801561107d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110a19190611959565b909192939495965090919293949550909192935090919250909150905050809350508a6001600160a01b031663f30dba938a6040518263ffffffff1660e01b81526004016110f8919060029190910b815260200190565b61010060405180830381865afa158015611116573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061113a9190611959565b509397506112c195505050505050565b8a6001600160a01b031663ecdecf426040518163ffffffff1660e01b8152600401602060405180830381865afa158015611188573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ac9190611940565b60405163f30dba9360e01b815260028c900b60048201529091506001600160a01b038c169063f30dba939060240161010060405180830381865afa1580156111f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061121c9190611959565b90919293949596509091929394955090919293945090919250909150905050809350508a6001600160a01b031663f30dba938a6040518263ffffffff1660e01b8152600401611274919060029190910b815260200190565b61010060405180830381865afa158015611292573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112b69190611959565b509297505050505050505b60008a60020b8660020b126112d75750826112dc565b508281035b60008a60020b8760020b12156112f35750826112f8565b508282035b8183038190036113186001600160801b038c168a8303600160801b6104ef565b9e9d5050505050505050505050505050565b6000818311611339578161059c565b5090919050565b60008160000361135257506000919050565b60005b8215610a4657611366600a84611889565b925061137181611a07565b9050611355565b806001600160801b038116811461138e57600080fd5b919050565b60006113a08484846104ef565b9050600082806113b2576113b2611873565b848609111561059c5760001981106113c957600080fd5b80610ed081611a07565b6001600160a01b03811681146113e857600080fd5b50565b8060020b81146113e857600080fd5b600080600080600060a0868803121561141257600080fd5b853561141d816113d3565b9450602086013561142d816113eb565b9350604086013561143d816113eb565b94979396509394606081013594506080013592915050565b6001600160801b03811681146113e857600080fd5b6000806000806080858703121561148057600080fd5b843561148b816113d3565b9350602085013561149b816113eb565b925060408501356114ab816113eb565b915060608501356114bb81611455565b939692955090935050565b6000806000606084860312156114db57600080fd5b83356114e6816113d3565b925060208401356114f6816113d3565b929592945050506040919091013590565b60008060006060848603121561151c57600080fd5b505081359360208301359350604090920135919050565b6000806040838503121561154657600080fd5b8235611551816113d3565b91506020830135611561816113d3565b809150509250929050565b805161138e816113d3565b805161138e816113eb565b805161ffff8116811461138e57600080fd5b805160ff8116811461138e57600080fd5b8051801515811461138e57600080fd5b600080600080600080600060e0888a0312156115d057600080fd5b87516115db816113d3565b60208901519097506115ec816113eb565b95506115fa60408901611582565b945061160860608901611582565b935061161660808901611594565b925061162460a08901611594565b915061163260c089016115a5565b905092959891949750929550565b805161138e81611455565b60008060008060008060008060008060006101608c8e03121561166d57600080fd5b8b516bffffffffffffffffffffffff8116811461168957600080fd5b60208d0151909b5061169a816113d3565b60408d0151909a506116ab816113d3565b98506116b960608d0161156c565b97506116c760808d01611577565b96506116d560a08d01611577565b95506116e360c08d01611640565b945060e08c015193506101008c015192506117016101208d01611640565b91506117106101408d01611640565b90509295989b509295989b9093969950565b634e487b7160e01b600052601160045260246000fd5b80820180821115610a4657610a46611722565b60006020828403121561175d57600080fd5b815161059c816113d3565b60006020828403121561177a57600080fd5b61059c82611594565b600181815b808511156117be5781600019048211156117a4576117a4611722565b808516156117b157918102915b93841c9390800290611788565b509250929050565b6000826117d557506001610a46565b816117e257506000610a46565b81600181146117f857600281146118025761181e565b6001915050610a46565b60ff84111561181357611813611722565b50506001821b610a46565b5060208310610133831016604e8410600b8410161715611841575081810a610a46565b61184b8383611783565b806000190482111561185f5761185f611722565b029392505050565b600061059c83836117c6565b634e487b7160e01b600052601260045260246000fd5b60008261189857611898611873565b500490565b81810381811115610a4657610a46611722565b8082028115828204841417610a4657610a46611722565b6000600160ff1b82016118dc576118dc611722565b5060000390565b60008160020b627fffff1981036118fc576118fc611722565b60000392915050565b60008261191457611914611873565b500690565b6001600160a01b0382811682821603908082111561193957611939611722565b5092915050565b60006020828403121561195257600080fd5b5051919050565b600080600080600080600080610100898b03121561197657600080fd5b885161198181611455565b80985050602089015180600f0b811461199957600080fd5b80975050604089015195506060890151945060808901518060060b81146119bf57600080fd5b60a08a01519094506119d0816113d3565b60c08a015190935063ffffffff811681146119ea57600080fd5b91506119f860e08a016115a5565b90509295985092959890939650565b600060018201611a1957611a19611722565b506001019056fea26469706673582212202d2a6abababd3e096181b445fdd2e41790e62b81727a3b3c2700712e3acd3c3d64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getPrice(address,address)": {
        "returns": {
          "_0": "price with decimals of paired token"
        }
      },
      "mulDiv(uint256,uint256,uint256)": {
        "details": "Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv",
        "params": {
          "a": "The multiplicand",
          "b": "The multiplier",
          "denominator": "The divisor"
        },
        "returns": {
          "result": "The 256-bit result"
        }
      }
    },
    "stateVariables": {
      "MAX_SQRT_RATIO": {
        "details": "The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)"
      },
      "MAX_TICK": {
        "details": "The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128"
      },
      "MIN_SQRT_RATIO": {
        "details": "The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)"
      },
      "MIN_TICK": {
        "details": "The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getAmountsForLiquidity(uint160,int24,int24,uint128)": {
        "notice": "Computes the token0 and token1 value for a given amount of liquidity, the current pool prices and the prices at the tick boundaries"
      },
      "getLiquidityForAmounts(uint160,int24,int24,uint256,uint256)": {
        "notice": "Computes the maximum amount of liquidity received for a given amount of token0, token1, the current pool prices and the prices at the tick boundaries"
      },
      "getPrice(address,address)": {
        "notice": "Calculates price in pool"
      },
      "mulDiv(uint256,uint256,uint256)": {
        "notice": "Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}