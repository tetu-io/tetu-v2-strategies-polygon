{
  "language": "Solidity",
  "sources": {
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IControllable {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IController {\n\n  // --- DEPENDENCY ADDRESSES\n  function governance() external view returns (address);\n\n  function voter() external view returns (address);\n\n  function liquidator() external view returns (address);\n\n  function forwarder() external view returns (address);\n\n  function investFund() external view returns (address);\n\n  function veDistributor() external view returns (address);\n\n  function platformVoter() external view returns (address);\n\n  // --- VAULTS\n\n  function vaults(uint id) external view returns (address);\n\n  function vaultsList() external view returns (address[] memory);\n\n  function vaultsListLength() external view returns (uint);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  // --- restrictions\n\n  function isOperator(address _adr) external view returns (bool);\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n     */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n     */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IForwarder {\n\n  function tokenPerDestinationLength(address destination) external view returns (uint);\n\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\n\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vault,\n    bool isDistribute\n  ) external;\n\n  function distributeAll(address destination) external;\n\n  function distribute(address token) external;\n\n  function setInvestFundRatio(uint value) external;\n\n  function setGaugesRatio(uint value) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISplitter {\n\n  function init(address controller_, address _asset, address _vault) external;\n\n  // *************** ACTIONS **************\n\n  function withdrawAllToVault() external;\n\n  function withdrawToVault(uint256 amount) external;\n\n  function doHardWork() external;\n\n  function investAll() external;\n\n  // **************** VIEWS ***************\n\n  function asset() external view returns (address);\n\n  function vault() external view returns (address);\n\n  function totalAssets() external view returns (uint256);\n\n  function isHardWorking() external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IStrategyV2 {\n\n  function NAME() external view returns (string memory);\n\n  function PLATFORM() external view returns (string memory);\n\n  function STRATEGY_VERSION() external view returns (string memory);\n\n  function asset() external view returns (address);\n\n  function splitter() external view returns (address);\n\n  function compoundRatio() external view returns (uint);\n\n  function totalAssets() external view returns (uint);\n\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\n  function isReadyToHardWork() external view returns (bool);\n\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-withdrawAllToSplitter]\n  function withdrawAllToSplitter() external returns (int totalAssetsDelta);\n\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-withdrawToSplitter]\n  function withdrawToSplitter(uint amount) external returns (int totalAssetsDelta);\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external returns (\n    int totalAssetsDelta\n  );\n\n  function doHardWork() external returns (uint earned, uint lost);\n\n  function setCompoundRatio(uint value) external;\n\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\n  ///         0 means no deposit is allowed at this moment\n  function capacity() external view returns (uint);\n\n  /// @notice {performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\n  function performanceReceiver() external view returns (address);\n\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\n  /// @dev use FEE_DENOMINATOR\n  function performanceFee() external view returns (uint);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ITetuLiquidator {\n\n  struct PoolData {\n    address pool;\n    address swapper;\n    address tokenIn;\n    address tokenOut;\n  }\n\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\n\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\n\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\n\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint slippage\n  ) external;\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint slippage\n  ) external;\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IVaultInsurance.sol\";\nimport \"./IERC20.sol\";\n\ninterface ITetuVaultV2 {\n\n  function depositFee() external view returns (uint);\n\n  function withdrawFee() external view returns (uint);\n\n  function init(\n    address controller_,\n    IERC20 _asset,\n    string memory _name,\n    string memory _symbol,\n    address _gauge,\n    uint _buffer\n  ) external;\n\n  function setSplitter(address _splitter) external;\n\n  function coverLoss(uint amount) external;\n\n  function initInsurance(IVaultInsurance _insurance) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVaultInsurance {\n\n  function init(address _vault, address _asset) external;\n\n  function vault() external view returns (address);\n\n  function asset() external view returns (address);\n\n  function transferToVault(uint amount) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/InterfaceIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for interface IDs\n/// @author bogdoslav\nlibrary InterfaceIds {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant INTERFACE_IDS_LIB_VERSION = \"1.0.0\";\n\n  /// default notation:\n  /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\n\n  /// As type({Interface}).interfaceId can be changed,\n  /// when some functions changed at the interface,\n  /// so used hardcoded interface identifiers\n\n  bytes4 public constant I_VOTER = bytes4(keccak256(\"IVoter\"));\n  bytes4 public constant I_BRIBE = bytes4(keccak256(\"IBribe\"));\n  bytes4 public constant I_GAUGE = bytes4(keccak256(\"IGauge\"));\n  bytes4 public constant I_VE_TETU = bytes4(keccak256(\"IVeTetu\"));\n  bytes4 public constant I_SPLITTER = bytes4(keccak256(\"ISplitter\"));\n  bytes4 public constant I_FORWARDER = bytes4(keccak256(\"IForwarder\"));\n  bytes4 public constant I_MULTI_POOL = bytes4(keccak256(\"IMultiPool\"));\n  bytes4 public constant I_CONTROLLER = bytes4(keccak256(\"IController\"));\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\"ITetuERC165\"));\n  bytes4 public constant I_STRATEGY_V2 = bytes4(keccak256(\"IStrategyV2\"));\n  bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\"IControllable\"));\n  bytes4 public constant I_TETU_VAULT_V2 = bytes4(keccak256(\"ITetuVaultV2\"));\n  bytes4 public constant I_PLATFORM_VOTER = bytes4(keccak256(\"IPlatformVoter\"));\n  bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\"IVeDistributor\"));\n  bytes4 public constant I_TETU_CONVERTER = bytes4(keccak256(\"ITetuConverter\"));\n  bytes4 public constant I_VAULT_INSURANCE = bytes4(keccak256(\"IVaultInsurance\"));\n  bytes4 public constant I_STRATEGY_STRICT = bytes4(keccak256(\"IStrategyStrict\"));\n  bytes4 public constant I_ERC4626 = bytes4(keccak256(\"IERC4626\"));\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  /// @dev Gets a slot array by index as uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  // ************* ARRAY SETTERS *******************\n\n  /// @dev Sets a slot array at index with address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, address value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets a slot array at index with uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, uint value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets an array length\n  function setLength(bytes32 slot, uint length) internal {\n    assembly {\n      sstore(slot, length)\n    }\n  }\n\n  /// @dev Pushes an address to the array\n  function push(bytes32 slot, address value) internal {\n    uint length = arrayLength(slot);\n    setAt(slot, length, value);\n    setLength(slot, length + 1);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n     */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n  uint8 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n     */\n  bool private _initializing;\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n  event Initialized(uint8 version);\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n      \"Initializable: contract is already initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n      emit Initialized(1);\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier reinitializer(uint8 version) {\n    require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n    emit Initialized(version);\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n  modifier onlyInitializing() {\n    require(_initializing, \"Initializable: contract is not initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Initializable: contract is initializing\");\n    if (_initialized != type(uint8).max) {\n      _initialized = type(uint8).max;\n      emit Initialized(type(uint8).max);\n    }\n  }\n\n  /**\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n  function _getInitializedVersion() internal view returns (uint8) {\n    return _initialized;\n  }\n\n  /**\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n  function _isInitializing() internal view returns (bool) {\n    return _initializing;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n     */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n     */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(x, y, not(0))\n      prod0 := mul(x, y)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n      return prod0 / denominator;\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    require(denominator > prod1, \"Math: mulDiv overflow\");\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly {\n    // Compute remainder using mulmod.\n      remainder := mulmod(x, y, denominator)\n\n    // Subtract 256 bit number from 512 bit number.\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n    // See https://cs.stackexchange.com/q/138556/92363.\n\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\n    uint256 twos = denominator & (~denominator + 1);\n    assembly {\n    // Divide denominator by twos.\n      denominator := div(denominator, twos)\n\n    // Divide [prod1 prod0] by twos.\n      prod0 := div(prod0, twos)\n\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n\n    // Shift in bits from prod1 into prod0.\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n    // four bits. That is, denominator * inv = 1 mod 2^4.\n    uint256 inverse = (3 * denominator) ^ 2;\n\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n    // in modular arithmetic, doubling the correct bits in each step.\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inverse;\n    return result;\n  }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator,\n    Rounding rounding\n  ) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n  unchecked {\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    return min(result, a / result);\n  }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = sqrt(a);\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 128;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 64;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 32;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 16;\n    }\n    if (value >> 8 > 0) {\n      value >>= 8;\n      result += 8;\n    }\n    if (value >> 4 > 0) {\n      value >>= 4;\n      result += 4;\n    }\n    if (value >> 2 > 0) {\n      value >>= 2;\n      result += 2;\n    }\n    if (value >> 1 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log2(value);\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >= 10**64) {\n      value /= 10**64;\n      result += 64;\n    }\n    if (value >= 10**32) {\n      value /= 10**32;\n      result += 32;\n    }\n    if (value >= 10**16) {\n      value /= 10**16;\n      result += 16;\n    }\n    if (value >= 10**8) {\n      value /= 10**8;\n      result += 8;\n    }\n    if (value >= 10**4) {\n      value /= 10**4;\n      result += 4;\n    }\n    if (value >= 10**2) {\n      value /= 10**2;\n      result += 2;\n    }\n    if (value >= 10**1) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log10(value);\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 16;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 8;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 4;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 2;\n    }\n    if (value >> 8 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log256(value);\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n  }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n  unchecked {\n    uint256 oldAllowance = token.allowance(address(this), spender);\n    require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n    uint256 newAllowance = oldAllowance - value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/ControllableV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/SlotsLib.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"3.0.0\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  /// @dev Prevent implementation init\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) internal onlyInitializing {\n    require(controller_ != address(0), \"Zero controller\");\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\n    require(IController(controller_).governance() != address(0), \"Zero governance\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address _value) public override view returns (bool) {\n    return _value == controller();\n  }\n\n  /// @notice Return true if given address is setup as governance in Controller\n  function isGovernance(address _value) public override view returns (bool) {\n    return IController(controller()).governance() == _value;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view returns (uint){\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view returns (address){\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return controller address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./StrategyLib.sol\";\n\n/// @title Abstract contract for base strategy functionality\n/// @author belbix\nabstract contract StrategyBaseV2 is IStrategyV2, ControllableV3 {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant STRATEGY_BASE_VERSION = \"2.1.1\";\n  /// @dev Denominator for compound ratio\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n  /// @notice 10% of total profit is sent to {performanceReceiver} before compounding\n  uint internal constant DEFAULT_PERFORMANCE_FEE = 10_000;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Linked splitter\n  address public override splitter;\n  /// @dev Percent of profit for autocompound inside this strategy.\n  uint public override compoundRatio;\n  /// @notice Balances of not-reward amounts\n  /// @dev Any amounts transferred to the strategy for investing or withdrawn back are registered here\n  ///      As result it's possible to distinct invested amounts from rewards, airdrops and other profits\n  mapping(address => uint) public baseAmounts;\n\n  /// @notice {performanceFee}% of total profit is sent to {performanceReceiver} before compounding\n  /// @dev governance by default\n  address public override performanceReceiver;\n\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\n  /// @dev {DEFAULT_PERFORMANCE_FEE} by default, FEE_DENOMINATOR is used\n  uint public override performanceFee;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event WithdrawAllToSplitter(uint amount);\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\n  event EmergencyExit(address sender, uint amount);\n  event ManualClaim(address sender);\n  event InvestAll(uint balance);\n  event DepositToPool(uint amount);\n  event WithdrawFromPool(uint amount);\n  event WithdrawAllFromPool(uint amount);\n  event Claimed(address token, uint amount);\n  event CompoundRatioChanged(uint oldValue, uint newValue);\n  /// @notice {baseAmounts} of {asset} is changed on the {amount} value\n  event UpdateBaseAmounts(address asset, int amount);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __StrategyBase_init(\n    address controller_,\n    address _splitter\n  ) internal onlyInitializing {\n    _requireInterface(_splitter, InterfaceIds.I_SPLITTER);\n    __Controllable_init(controller_);\n\n    require(IControllable(_splitter).isController(controller_), StrategyLib.WRONG_VALUE);\n\n    asset = ISplitter(_splitter).asset();\n    splitter = _splitter;\n\n    performanceReceiver = IController(controller_).governance();\n    performanceFee = DEFAULT_PERFORMANCE_FEE;\n  }\n\n  // *************************************************************\n  //                     PERFORMANCE FEE\n  // *************************************************************\n  /// @notice Set performance fee and receiver\n  function setupPerformanceFee(uint fee_, address receiver_) external {\n    StrategyLib.onlyGovernance(controller());\n    require(fee_ <= DEFAULT_PERFORMANCE_FEE, StrategyLib.TOO_HIGH);\n    require(receiver_ != address(0), StrategyLib.WRONG_VALUE);\n\n    performanceFee = fee_;\n    performanceReceiver = receiver_;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of underlying assets under control of this strategy.\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this)) + investedAssets();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_STRATEGY_V2 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                   VOTER ACTIONS\n  // *************************************************************\n\n  /// @dev PlatformVoter can change compound ratio for some strategies.\n  ///      A strategy can implement another logic for some uniq cases.\n  function setCompoundRatio(uint value) external virtual override {\n    StrategyLib.onlyPlatformVoter(controller());\n    require(value <= COMPOUND_DENOMINATOR, StrategyLib.TOO_HIGH);\n    emit CompoundRatioChanged(compoundRatio, value);\n    compoundRatio = value;\n  }\n\n  // *************************************************************\n  //                   OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev In case of any issue operator can withdraw all from pool.\n  function emergencyExit() external {\n    StrategyLib.onlyOperators(controller());\n\n    _emergencyExitFromPool();\n\n    address _asset = asset;\n    // gas saving\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    _decreaseBaseAmount(_asset, baseAmounts[_asset]);\n    // reset base amount\n    IERC20(_asset).safeTransfer(splitter, balance);\n    emit EmergencyExit(msg.sender, balance);\n  }\n\n  /// @dev Manual claim rewards.\n  function claim() external {\n    StrategyLib.onlyOperators(controller());\n\n    _claim();\n    emit ManualClaim(msg.sender);\n  }\n\n  // *************************************************************\n  //                    DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external override returns (\n    int totalAssetsDelta\n  ) {\n    StrategyLib.onlySplitter(splitter);\n\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n\n    _increaseBaseAmount(_asset, amount_, balance);\n\n    if (balance > 0) {\n      totalAssetsDelta = _depositToPool(balance, updateTotalAssetsBeforeInvest_);\n    }\n    emit InvestAll(balance);\n\n    return totalAssetsDelta;\n  }\n\n  /// @dev Withdraws all underlying assets to the vault\n  /// @return Return [totalAssets-before-withdraw - totalAssets-before-call-of-withdrawAllToSplitter]\n  function withdrawAllToSplitter() external override returns (int) {\n    address _splitter = splitter;\n    address _asset = asset;\n    StrategyLib.onlySplitter(_splitter);\n\n    uint balance = IERC20(_asset).balanceOf(address(this));\n\n    (uint investedAssetsUSD, uint assetPrice, int totalAssetsDelta) = _withdrawAllFromPool();\n\n    balance = StrategyLib.checkWithdrawImpact(\n      _asset,\n      balance,\n      investedAssetsUSD,\n      assetPrice,\n      _splitter\n    );\n\n    {\n      // we cannot withdraw more than the base amount value\n      // if any additional amount exist on the balance (i.e. airdrops)\n      // it should be processed by hardwork at first (split on compound/forwarder)\n      uint baseAmount = baseAmounts[_asset];\n      if (balance > baseAmount) {\n        balance = baseAmount;\n      }\n    }\n\n    if (balance != 0) {\n      _decreaseBaseAmount(_asset, balance);\n      IERC20(_asset).safeTransfer(_splitter, balance);\n    }\n    emit WithdrawAllToSplitter(balance);\n\n    return totalAssetsDelta;\n  }\n\n  /// @dev Withdraws some assets to the splitter\n  /// @return totalAssetsDelta =[totalAssets-before-withdraw - totalAssets-before-call-of-withdrawAllToSplitter]\n  function withdrawToSplitter(uint amount) external override returns (int totalAssetsDelta) {\n    address _splitter = splitter;\n    address _asset = asset;\n    StrategyLib.onlySplitter(_splitter);\n\n\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (amount > balance) {\n      uint investedAssetsUSD;\n      uint assetPrice;\n\n      (investedAssetsUSD, assetPrice, totalAssetsDelta) = _withdrawFromPool(amount - balance);\n      balance = StrategyLib.checkWithdrawImpact(\n        _asset,\n        balance,\n        investedAssetsUSD,\n        assetPrice,\n        _splitter\n      );\n    }\n\n    uint amountAdjusted = Math.min(amount, balance);\n    if (amountAdjusted != 0) {\n      _decreaseBaseAmount(_asset, amountAdjusted);\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\n    }\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\n\n    return totalAssetsDelta;\n  }\n\n\n  // *************************************************************\n  //                  baseAmounts modifications\n  // *************************************************************\n\n  /// @notice Decrease {baseAmounts} of the {asset} on {amount_}\n  ///         The {amount_} can be greater then total base amount value because it can includes rewards.\n  ///         We assume here, that base amounts are spent first, then rewards and any other profit-amounts\n  function _decreaseBaseAmount(address asset_, uint amount_) internal {\n    uint baseAmount = baseAmounts[asset_];\n    require(baseAmount >= amount_, StrategyLib.WRONG_VALUE);\n    baseAmounts[asset_] = baseAmount - amount_;\n    emit UpdateBaseAmounts(asset_, - int(baseAmount));\n  }\n\n  /// @notice Increase {baseAmounts} of the {asset} on {amount_}, ensure that current {assetBalance_} >= {amount_}\n  /// @param assetBalance_ Current balance of the {asset} to check if {amount_} > the balance. Pass 0 to skip the check\n  function _increaseBaseAmount(address asset_, uint amount_, uint assetBalance_) internal {\n    baseAmounts[asset_] += amount_;\n    emit UpdateBaseAmounts(asset_, int(amount_));\n    require(assetBalance_ >= amount_, StrategyLib.WRONG_VALUE);\n  }\n\n  // *************************************************************\n  //                       VIRTUAL\n  // These functions must be implemented in the strategy contract\n  // *************************************************************\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function _depositToPool(\n    uint amount,\n    bool updateTotalAssetsBeforeInvest_\n  ) internal virtual returns (\n    int totalAssetsDelta\n  );\n\n  /// @dev Withdraw given amount from the pool.\n  /// @return investedAssetsUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawFromPool(uint amount) internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  );\n\n  /// @dev Withdraw all from the pool.\n  /// @return investedAssetsUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawAllFromPool]\n  function _withdrawAllFromPool() internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  );\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  ///      Withdraw assets without impact checking.\n  function _emergencyExitFromPool() internal virtual;\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal virtual;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\n\nlibrary StrategyLib {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Denominator for fee calculation.\n  uint internal constant FEE_DENOMINATOR = 100_000;\n\n  // *************************************************************\n  //                        ERRORS\n  // *************************************************************\n\n  string internal constant DENIED = \"SB: Denied\";\n  string internal constant TOO_HIGH = \"SB: Too high\";\n  string internal constant WRONG_VALUE = \"SB: Wrong value\";\n\n  // *************************************************************\n  //                     RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Restrict access only for operators\n  function onlyOperators(address controller) external view {\n    require(IController(controller).isOperator(msg.sender), DENIED);\n  }\n\n  /// @dev Restrict access only for governance\n  function onlyGovernance(address controller) external view {\n    require(IController(controller).governance() == msg.sender, DENIED);\n  }\n\n  /// @dev Restrict access only for platform voter\n  function onlyPlatformVoter(address controller) external view {\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\n  }\n\n  /// @dev Restrict access only for splitter\n  function onlySplitter(address splitter) external view {\n    require(splitter == msg.sender, DENIED);\n  }\n\n  // *************************************************************\n  //                       HELPERS\n  // *************************************************************\n\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\n  ///         Revert if the amount is different from expected too much (high price impact)\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\n  /// @param investedAssetsUSD Expected amount in USD, decimals are same to {_asset}\n  /// @param assetPrice Price of the asset, decimals 18\n  /// @return balance Current asset balance of the strategy\n  function checkWithdrawImpact(\n    address _asset,\n    uint balanceBefore,\n    uint investedAssetsUSD,\n    uint assetPrice,\n    address _splitter\n  ) external view returns (uint balance) {\n    balance = IERC20(_asset).balanceOf(address(this));\n    if (assetPrice != 0 && investedAssetsUSD != 0) {\n\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\n      uint difference = investedAssetsUSD > withdrewUSD ? investedAssetsUSD - withdrewUSD : 0;\n\n      require(difference * FEE_DENOMINATOR / investedAssetsUSD <= priceChangeTolerance, TOO_HIGH);\n    }\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/IMockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IMockToken {\n\n  function decimals() external view returns (uint8);\n\n  function mint(address to, uint amount) external;\n\n  function burn(address from, uint amount) external;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/tools/TetuERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC165.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\n/// @author bogdoslav\nabstract contract TetuERC165 is ERC165 {\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        HELPER FUNCTIONS\n  // *************************************************************\n  /// @author bogdoslav\n\n  /// @dev Checks what interface with id is supported by contract.\n  /// @return bool. Do not throws\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\n      return isSupported;\n    } catch {\n    }\n    return false;\n  }\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\n    require(_isInterfaceSupported(contractAddress, interfaceId), \"Interface is not supported\");\n  }\n\n  /// @dev Checks what address is ERC20.\n  /// @return bool. Do not throws\n  function _isERC20(address contractAddress) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    bool totalSupplySupported;\n    try IERC20(contractAddress).totalSupply() returns (uint) {\n      totalSupplySupported = true;\n    } catch {\n    }\n\n    bool balanceSupported;\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\n      balanceSupported = true;\n    } catch {\n    }\n\n    return totalSupplySupported && balanceSupported;\n  }\n\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireERC20(address contractAddress) internal view {\n    require(_isERC20(contractAddress), \"Not ERC20\");\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\n/// @notice Keep and provide addresses of all application contracts\r\ninterface IConverterController {\r\n  function governance() external view returns (address);\r\n\r\n  /// ********************* Health factor explanation  ****************\r\n  /// For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\r\n  /// For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\r\n  /// We set min-health-factor = 1.1, target-health-factor = 1.3\r\n  /// For collateral 100 we will borrow 100/1.3 = 76.92\r\n  ///\r\n  /// Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\r\n  /// Collateral * LT    85         65.45\r\n  /// Borrow value       65.38      65.38         but borrow value is the same as before\r\n  /// Health factor      1.3        1.001         liquidation almost happens here (!)\r\n  ///\r\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\r\n  /// and the borrow value won't change at the same time, the liquidation happens at that point.\r\n  /// Min health factor marks the point at which a rebalancing must be made asap.\r\n  /// *****************************************************************\r\n\r\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\r\n  function minHealthFactor2() external view returns (uint16);\r\n  function setMinHealthFactor2(uint16 value_) external;\r\n\r\n  /// @notice target health factor with decimals 2\r\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\r\n  ///      or additional borrow and restore the health factor to the given target value\r\n  function targetHealthFactor2() external view returns (uint16);\r\n  function setTargetHealthFactor2(uint16 value_) external;\r\n\r\n  /// @notice max allowed health factor with decimals 2\r\n  /// @dev For future versions, currently max health factor is not used\r\n  function maxHealthFactor2() external view returns (uint16);\r\n  /// @dev For future versions, currently max health factor is not used\r\n  function setMaxHealthFactor2(uint16 value_) external;\r\n\r\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\r\n  function blocksPerDay() external view returns (uint);\r\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\r\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\r\n  /// @notice Check if it's time to call updateBlocksPerDay()\r\n  /// @param periodInSeconds_ Period of auto-update in seconds\r\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\r\n  /// @notice Recalculate blocksPerDay value\r\n  /// @param periodInSeconds_ Period of auto-update in seconds\r\n  function updateBlocksPerDay(uint periodInSeconds_) external;\r\n\r\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\r\n  function paused() external view returns (bool);\r\n\r\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\r\n  function isWhitelisted(address user_) external view returns (bool);\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///        Core application contracts\r\n  ///////////////////////////////////////////////////////\r\n\r\n  function tetuConverter() external view returns (address);\r\n  function borrowManager() external view returns (address);\r\n  function debtMonitor() external view returns (address);\r\n  function tetuLiquidator() external view returns (address);\r\n  function swapManager() external view returns (address);\r\n  function priceOracle() external view returns (address);\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///        External contracts\r\n  ///////////////////////////////////////////////////////\r\n  /// @notice A keeper to control health and efficiency of the borrows\r\n  function keeper() external view returns (address);\r\n\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IPriceOracle {\r\n  /// @notice Return asset price in USD, decimals 18\r\n  function getAssetPrice(address asset) external view returns (uint256);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"./IConverterController.sol\";\r\n\r\n/// @notice Main contract of the TetuConverter application\r\n/// @dev Borrower (strategy) makes all operations via this contract only.\r\ninterface ITetuConverter {\r\n\r\n  function controller() external view returns (IConverterController);\r\n\r\n  /// @notice Find possible borrow strategies and provide \"cost of money\" as interest for the period for each strategy\r\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\r\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\r\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\r\n  ///                   0 is used by default\r\n  /// @param amountIn_  The meaning depends on entryData\r\n  ///                   For entryKind=0 it's max available amount of collateral\r\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\r\n  /// @return converters Array of available converters ordered in ascending order of APR.\r\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\r\n  ///                    This address should be passed to borrow-function during conversion.\r\n  ///                    The length of array is always equal to the count of available lending platforms.\r\n  ///                    Last items in array can contain zero addresses (it means they are not used)\r\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\r\n  /// @return amountToBorrowsOut Amounts that should be borrowed\r\n  ///                            This amount is not zero if corresponded converter is not zero.\r\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\r\n  function findBorrowStrategies(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_,\r\n    uint periodInBlocks_\r\n  ) external view returns (\r\n    address[] memory converters,\r\n    uint[] memory collateralAmountsOut,\r\n    uint[] memory amountToBorrowsOut,\r\n    int[] memory aprs18\r\n  );\r\n\r\n  /// @notice Find best swap strategy and provide \"cost of money\" as interest for the period\r\n  /// @dev This is writable function with read-only behavior.\r\n  ///      It should be writable to be able to simulate real swap and get a real APR.\r\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\r\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\r\n  ///                   0 is used by default\r\n  /// @param amountIn_  The meaning depends on entryData\r\n  ///                   For entryKind=0 it's max available amount of collateral\r\n  ///                   This amount must be approved to TetuConverter before the call.\r\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\r\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\r\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\r\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\r\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\r\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\r\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\r\n  function findSwapStrategy(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_\r\n  ) external returns (\r\n    address converter,\r\n    uint sourceAmountOut,\r\n    uint targetAmountOut,\r\n    int apr18\r\n  );\r\n\r\n  /// @notice Find best conversion strategy (swap or borrow) and provide \"cost of money\" as interest for the period.\r\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\r\n  /// @dev This is writable function with read-only behavior.\r\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\r\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\r\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\r\n  ///                   0 is used by default\r\n  /// @param amountIn_  The meaning depends on entryData\r\n  ///                   For entryKind=0 it's max available amount of collateral\r\n  ///                   This amount must be approved to TetuConverter before the call.\r\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\r\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\r\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\r\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\r\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\r\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\r\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\r\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\r\n  function findConversionStrategy(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_,\r\n    uint periodInBlocks_\r\n  ) external returns (\r\n    address converter,\r\n    uint collateralAmountOut,\r\n    uint amountToBorrowOut,\r\n    int apr18\r\n  );\r\n\r\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\r\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\r\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\r\n  ///      Only whitelisted users are allowed to make borrows\r\n  /// @param converter_ A converter received from findBestConversionStrategy.\r\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\r\n  ///                          This amount must be approved to TetuConverter before the call.\r\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\r\n  /// @param receiver_ A receiver of borrowed amount\r\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\r\n  function borrow(\r\n    address converter_,\r\n    address collateralAsset_,\r\n    uint collateralAmount_,\r\n    address borrowAsset_,\r\n    uint amountToBorrow_,\r\n    address receiver_\r\n  ) external returns (\r\n    uint borrowedAmountOut\r\n  );\r\n\r\n  /// @notice Full or partial repay of the borrow\r\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\r\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\r\n  ///                       You can know exact total amount of debt using {getStatusCurrent}.\r\n  ///                       if the amount exceed total amount of the debt:\r\n  ///                       - the debt will be fully repaid\r\n  ///                       - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\r\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\r\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\r\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\r\n  ///         If TetuConverter is not able to make the swap, it reverts\r\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\r\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\r\n  ///                                 This amount is returned back to the collateralReceiver_\r\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\r\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\r\n  function repay(\r\n    address collateralAsset_,\r\n    address borrowAsset_,\r\n    uint amountToRepay_,\r\n    address receiver_\r\n  ) external returns (\r\n    uint collateralAmountOut,\r\n    uint returnedBorrowAmountOut,\r\n    uint swappedLeftoverCollateralOut,\r\n    uint swappedLeftoverBorrowOut\r\n  );\r\n\r\n  /// @notice Estimate result amount after making full or partial repay\r\n  /// @dev It works in exactly same way as repay() but don't make actual repay\r\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\r\n  /// @param user_ user whose amount-to-repay will be calculated\r\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\r\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\r\n  function quoteRepay(\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_,\r\n    uint amountToRepay_\r\n  ) external returns (\r\n    uint collateralAmountOut\r\n  );\r\n\r\n  /// @notice Update status in all opened positions\r\n  ///         and calculate exact total amount of borrowed and collateral assets\r\n  /// @param user_ user whose debts will be updated and returned\r\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\r\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\r\n  function getDebtAmountCurrent(\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_\r\n  ) external returns (\r\n    uint totalDebtAmountOut,\r\n    uint totalCollateralAmountOut\r\n  );\r\n\r\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\r\n  /// @dev Actual debt amount can be a little LESS then the amount returned by this function.\r\n  ///      I.e. AAVE's pool adapter returns (amount of debt + tiny addon ~ 1 cent)\r\n  ///      The addon is required to workaround dust-tokens problem.\r\n  ///      After repaying the remaining amount is transferred back on the balance of the caller strategy.\r\n  /// @param user_ user whose debts will be returned\r\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\r\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\r\n  function getDebtAmountStored(\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_\r\n  ) external view returns (\r\n    uint totalDebtAmountOut,\r\n    uint totalCollateralAmountOut\r\n  );\r\n\r\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\r\n  /// @param user_ user whose debts will be returned\r\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\r\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\r\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\r\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\r\n  ///                                           even if all borrowed amount will be returned.\r\n  ///                                           If this amount is not 0, you ask to get too much collateral.\r\n  function estimateRepay(\r\n    address user_,\r\n    address collateralAsset_,\r\n    uint collateralAmountRequired_,\r\n    address borrowAsset_\r\n  ) external view returns (\r\n    uint borrowAssetAmount,\r\n    uint unobtainableCollateralAssetAmount\r\n  );\r\n\r\n  /// @notice Transfer all reward tokens to {receiver_}\r\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\r\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\r\n  function claimRewards(address receiver_) external returns (\r\n    address[] memory rewardTokensOut,\r\n    uint[] memory amountsOut\r\n  );\r\n\r\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\r\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\r\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\r\n  ///                      It should be transferred on balance of the TetuConverter before the function call\r\n  /// @param receiver_ Result amount will be sent to this address\r\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\r\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\r\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\r\n  function safeLiquidate(\r\n    address assetIn_,\r\n    uint amountIn_,\r\n    address assetOut_,\r\n    address receiver_,\r\n    uint priceImpactToleranceSource_,\r\n    uint priceImpactToleranceTarget_\r\n  ) external returns (\r\n    uint amountOut\r\n  );\r\n\r\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\r\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\r\n  function isConversionValid(\r\n    address assetIn_,\r\n    uint amountIn_,\r\n    address assetOut_,\r\n    uint amountOut_,\r\n    uint priceImpactTolerance_\r\n  ) external view returns (bool);\r\n\r\n  /// @notice Close given borrow and return collateral back to the user, governance only\r\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\r\n  /// @param poolAdapter_ The pool adapter that represents the borrow\r\n  /// @param closePosition Close position after repay\r\n  ///        Usually it should be true, because the function always tries to repay all debt\r\n  ///        false can be used if user doesn't have enough amount to pay full debt\r\n  ///              and we are trying to pay \"as much as possible\"\r\n  /// @return collateralAmountOut Amount of collateral returned to the user\r\n  /// @return repaidAmountOut Amount of borrow asset repaid to the lending platform\r\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\r\n    uint collateralAmountOut,\r\n    uint repaidAmountOut\r\n  );\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/// @notice TetuConverter sends callback notifications to its user via this interface\r\ninterface ITetuConverterCallback {\r\n  /// @notice Converters calls this function if user should return some amount back.\r\n  ///         f.e. when the health factor is unhealthy and the converter needs more tokens to fix it.\r\n  ///         or when the full repay is required and converter needs to get full amount-to-repay.\r\n  /// @param asset_ Required asset (either collateral or borrow)\r\n  /// @param amount_ Required amount of the {asset_}\r\n  /// @return amountOut Exact amount that borrower has sent to balance of TetuConverter\r\n  function requirePayAmountBack(address asset_, uint amount_) external returns (uint amountOut);\r\n\r\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\r\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\r\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\r\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external;\r\n}\r\n"
    },
    "contracts/helpers/ERC20Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\n/// @title Contract with helper functions.\n/// @author bogdoslav\ncontract ERC20Helpers {\n  using SafeERC20 for IERC20;\n\n  function _balance(address token) internal view returns (uint) {\n    return IERC20(token).balanceOf(address(this));\n  }\n\n  /// @notice Should be used for third-party pools\n  function _safeApprove(address token, uint amount, address spender) internal {\n    IERC20(token).safeApprove(spender, 0);\n    IERC20(token).safeApprove(spender, amount);\n  }\n}\n"
    },
    "contracts/integrations/balancer/IBalancerBoostedAavePool.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"./IPoolSwapStructs.sol\";\n\n/// @notice Restored from Balancer Aave Boosted Pool (DAI) (bb-am-DAI) https://polygonscan.com/address/0x178E029173417b1F9C8bC16DCeC6f697bC323746\ninterface IBalancerBoostedAavePool {\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n  event PausedStateChanged(bool paused);\n  event RecoveryModeStateChanged(bool enabled);\n  event SwapFeePercentageChanged(uint256 swapFeePercentage);\n  event TargetsSet(address indexed token, uint256 lowerTarget, uint256 upperTarget);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function decimals() external view returns (uint8);\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (bool);\n\n  function disableRecoveryMode() external;\n\n  function enableRecoveryMode() external;\n\n  function getActionId(bytes4 selector) external view returns (bytes32);\n\n  function getAuthorizer() external view returns (address);\n\n  function getBptIndex() external view returns (uint256);\n\n  function getDomainSeparator() external view returns (bytes32);\n\n  function getMainIndex() external view returns (uint256);\n\n  function getMainToken() external view returns (address);\n\n  function getNextNonce(address account) external view returns (uint256);\n\n  function getOwner() external view returns (address);\n\n  function getPausedState() external view returns (\n    bool paused,\n    uint256 pauseWindowEndTime,\n    uint256 bufferPeriodEndTime\n  );\n\n  function getPoolId() external view returns (bytes32);\n\n  function getProtocolFeesCollector() external view returns (address);\n\n  function getRate() external view returns (uint256);\n\n  function getScalingFactors() external view returns (uint256[] memory);\n\n  function getSwapFeePercentage() external view returns (uint256);\n\n  function getTargets() external view returns (uint256 lowerTarget, uint256 upperTarget);\n\n  function getVault() external view returns (address);\n\n  function getVirtualSupply() external view returns (uint256);\n\n  function getWrappedIndex() external view returns (uint256);\n\n  function getWrappedToken() external view returns (address);\n\n  /**\n   * @notice Return the conversion rate between the wrapped and main tokens.\n     * @dev This is an 18-decimal fixed point value.\n     */\n  function getWrappedTokenRate() external view returns (uint256);\n\n  function inRecoveryMode() external view returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n  function initialize() external;\n\n  function name() external view returns (string memory);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function onExitPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onJoinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onSwap(\n    IPoolSwapStructs.SwapRequest memory request,\n    uint256[] memory balances,\n    uint256 indexIn,\n    uint256 indexOut\n  ) external returns (uint256);\n\n  function pause() external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function setAssetManagerPoolConfig(address token, bytes memory poolConfig) external;\n\n  function setSwapFeePercentage(uint256 swapFeePercentage) external;\n\n  function setTargets(uint256 newLowerTarget, uint256 newUpperTarget) external;\n\n  function symbol() external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  function unpause() external;\n}\n\ninterface AaveLinearPool {\n  struct ConstructorArgs {\n    address vault;\n    string name;\n    string symbol;\n    address mainToken;\n    address wrappedToken;\n    address assetManager;\n    uint256 upperTarget;\n    uint256 swapFeePercentage;\n    uint256 pauseWindowDuration;\n    uint256 bufferPeriodDuration;\n    address owner;\n  }\n}\n"
    },
    "contracts/integrations/balancer/IBalancerBoostedAaveStablePool.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"./IPoolSwapStructs.sol\";\n\n/// @notice Restored from https://polygonscan.com/address/0x48e6b98ef6329f8f0a30ebb8c7c960330d648085\ninterface IBalancerBoostedAaveStablePool {\n  event AmpUpdateStarted(\n    uint256 startValue,\n    uint256 endValue,\n    uint256 startTime,\n    uint256 endTime\n  );\n  event AmpUpdateStopped(uint256 currentValue);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n  event PausedStateChanged(bool paused);\n  event ProtocolFeePercentageCacheUpdated(\n    uint256 indexed feeType,\n    uint256 protocolFeePercentage\n  );\n  event RecoveryModeStateChanged(bool enabled);\n  event SwapFeePercentageChanged(uint256 swapFeePercentage);\n  event TokenRateCacheUpdated(uint256 indexed tokenIndex, uint256 rate);\n  event TokenRateProviderSet(\n    uint256 indexed tokenIndex,\n    address indexed provider,\n    uint256 cacheDuration\n  );\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL() external view returns (uint256);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function decimals() external view returns (uint8);\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (bool);\n\n  function disableRecoveryMode() external;\n\n  function enableRecoveryMode() external;\n\n  function getActionId(bytes4 selector) external view returns (bytes32);\n\n  /**\n   * @dev Returns the effective BPT supply.\n     *\n     * In other pools, this would be the same as `totalSupply`, but there are two key differences here:\n     *  - this pool pre-mints BPT and holds it in the Vault as a token, and as such we need to subtract the Vault's\n     *    balance to get the total \"circulating supply\". This is called the 'virtualSupply'.\n     *  - the Pool owes debt to the Protocol in the form of unminted BPT, which will be minted immediately before the\n     *    next join or exit. We need to take these into account since, even if they don't yet exist, they will\n     *    effectively be included in any Pool operation that involves BPT.\n     *\n     * In the vast majority of cases, this function should be used instead of `totalSupply()`.\n     */\n  function getActualSupply() external view returns (uint256);\n\n  function getAmplificationParameter() external view returns (\n    uint256 value,\n    bool isUpdating,\n    uint256 precision\n  );\n\n  function getAuthorizer() external view returns (address);\n\n  function getBptIndex() external view returns (uint256);\n\n  function getDomainSeparator() external view returns (bytes32);\n\n  function getLastJoinExitData() external view returns (\n    uint256 lastJoinExitAmplification,\n    uint256 lastPostJoinExitInvariant\n  );\n\n  function getMinimumBpt() external pure returns (uint256);\n\n  function getNextNonce(address account) external view returns (uint256);\n\n  function getOwner() external view returns (address);\n\n  function getPausedState() external view returns (\n    bool paused,\n    uint256 pauseWindowEndTime,\n    uint256 bufferPeriodEndTime\n  );\n\n  function getPoolId() external view returns (bytes32);\n\n  function getProtocolFeePercentageCache(uint256 feeType) external view returns (uint256);\n\n  function getProtocolFeesCollector() external view returns (address);\n\n  function getProtocolSwapFeeDelegation() external view returns (bool);\n\n  function getRate() external view returns (uint256);\n\n  function getRateProviders() external view returns (address[] memory);\n\n  function getScalingFactors() external view returns (uint256[] memory);\n\n  function getSwapFeePercentage() external view returns (uint256);\n\n  function getTokenRate(address token) external view returns (uint256);\n\n  function getTokenRateCache(address token) external view returns (\n    uint256 rate,\n    uint256 oldRate,\n    uint256 duration,\n    uint256 expires\n  );\n\n  function getVault() external view returns (address);\n\n  function inRecoveryMode() external view returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n  function isTokenExemptFromYieldProtocolFee(address token) external view returns (bool);\n\n  function name() external view returns (string memory);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function onExitPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onJoinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onSwap(\n    IPoolSwapStructs.SwapRequest memory swapRequest,\n    uint256[] memory balances,\n    uint256 indexIn,\n    uint256 indexOut\n  ) external returns (uint256);\n\n  function pause() external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function setAssetManagerPoolConfig(address token, bytes memory poolConfig) external;\n\n  function setSwapFeePercentage(uint256 swapFeePercentage) external;\n\n  function setTokenRateCacheDuration(address token, uint256 duration) external;\n\n  function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external;\n\n  function stopAmplificationParameterUpdate() external;\n\n  function symbol() external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  function unpause() external;\n\n  function updateProtocolFeePercentageCache() external;\n\n  function updateTokenRateCache(address token) external;\n}\n\ninterface ComposableStablePool {\n  struct NewPoolParams {\n    address vault;\n    address protocolFeeProvider;\n    string name;\n    string symbol;\n    address[] tokens;\n    address[] rateProviders;\n    uint256[] tokenRateCacheDurations;\n    bool[] exemptFromYieldProtocolFeeFlags;\n    uint256 amplificationParameter;\n    uint256 swapFeePercentage;\n    uint256 pauseWindowDuration;\n    uint256 bufferPeriodDuration;\n    address owner;\n  }\n}\n"
    },
    "contracts/integrations/balancer/IBalancerGauge.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IBalancerGauge {\n  function decimals() external view returns (uint256);\n\n  function version() external view returns (string memory);\n\n  function last_claim() external view returns (uint256);\n\n  function claimed_reward(address _addr, address _token) external view returns (uint256);\n\n  function claimable_reward(address _addr, address _token) external view returns (uint256);\n\n  function claimable_reward_write(address _addr, address _token) external returns (uint256);\n\n  function reward_contract() external view returns (address);\n\n  function reward_data(address _token) external view returns (\n    address token,\n    address distributor,\n    uint256 period_finish,\n    uint256 rate,\n    uint256 last_update,\n    uint256 integral\n  );\n\n  function reward_tokens(uint256 arg0) external view returns (address);\n\n  function reward_balances(address arg0) external view returns (uint256);\n\n  function rewards_receiver(address arg0) external view returns (address);\n\n  function reward_integral(address arg0) external view returns (uint256);\n\n  function reward_integral_for(address arg0, address arg1) external view returns (uint256);\n\n  function set_rewards_receiver(address _receiver) external;\n\n  function set_rewards(\n    address _reward_contract,\n    bytes32 _claim_sig,\n    address[8] memory _reward_tokens\n  ) external;\n\n  function claim_rewards() external;\n\n  function claim_rewards(address _addr) external;\n\n  function claim_rewards(address _addr, address _receiver) external;\n\n  function deposit(uint256 _value) external;\n\n  function deposit(uint256 _value, address _addr) external;\n\n  function deposit(uint256 _value, address _addr, bool _claim_rewards) external;\n\n  function withdraw(uint256 _value) external;\n\n  function withdraw(uint256 _value, bool _claim_rewards) external;\n\n  function transfer(address _to, uint256 _value) external returns (bool);\n\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address _spender, uint256 _value) external returns (bool);\n\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _value,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (bool);\n\n  function increaseAllowance(address _spender, uint256 _added_value) external returns (bool);\n\n  function decreaseAllowance(address _spender, uint256 _subtracted_value) external returns (bool);\n\n  function initialize(\n    address _lp_token,\n    address _reward_contract,\n    bytes32 _claim_sig\n  ) external;\n\n  function lp_token() external view returns (address);\n\n  function balanceOf(address arg0) external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function nonces(address arg0) external view returns (uint256);\n\n  function claim_sig() external view returns (bytes memory);\n}\n"
    },
    "contracts/integrations/balancer/IBalancerHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IBVault.sol\";\n\ninterface IBalancerHelper {\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    IBVault.ExitPoolRequest memory request\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    IBVault.JoinPoolRequest memory request\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function vault() external view returns (address);\n}\n"
    },
    "contracts/integrations/balancer/IBVault.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\n\ninterface IAsset {\n}\n\ninterface IBVault {\n  // Internal Balance\n  //\n  // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n  // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n  // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n  // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n  //\n  // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n  // operations of different kinds, with different senders and recipients, at once.\n\n  /**\n   * @dev Returns `user`'s Internal Balance for a set of tokens.\n     */\n  function getInternalBalance(address user, IERC20[] calldata tokens) external view returns (uint256[] memory);\n\n  /**\n   * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n  function manageUserBalance(UserBalanceOp[] calldata ops) external payable;\n\n  /**\n   * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n  struct UserBalanceOp {\n    UserBalanceOpKind kind;\n    IAsset asset;\n    uint256 amount;\n    address sender;\n    address payable recipient;\n  }\n\n  // There are four possible operations in `manageUserBalance`:\n  //\n  // - DEPOSIT_INTERNAL\n  // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n  // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n  // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n  // relevant for relayers).\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - WITHDRAW_INTERNAL\n  // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n  // it to the recipient as ETH.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_INTERNAL\n  // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_EXTERNAL\n  // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n  // relayers, as it lets them reuse a user's Vault allowance.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `ExternalBalanceTransfer` event.\n\n  enum UserBalanceOpKind {DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL}\n\n  /**\n   * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n  event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n  /**\n   * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n  event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n  // Pools\n  //\n  // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n  // functionality:\n  //\n  //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n  // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n  // which increase with the number of registered tokens.\n  //\n  //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n  // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n  // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n  // independent of the number of registered tokens.\n  //\n  //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n  // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n  enum PoolSpecialization {GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN}\n\n  /**\n   * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n  function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n  /**\n   * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n  event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n  /**\n   * @dev Returns a Pool's contract address and specialization setting.\n     */\n  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n  /**\n   * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n  function registerTokens(\n    bytes32 poolId,\n    IERC20[] calldata tokens,\n    address[] calldata assetManagers\n  ) external;\n\n  /**\n   * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n  event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n  /**\n   * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n  function deregisterTokens(bytes32 poolId, IERC20[] calldata tokens) external;\n\n  /**\n   * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n  event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n  /**\n   * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n  function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n  external\n  view\n  returns (\n    uint256 cash,\n    uint256 managed,\n    uint256 lastChangeBlock,\n    address assetManager\n  );\n\n  /**\n   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n  function getPoolTokens(bytes32 poolId)\n  external\n  view\n  returns (\n    IERC20[] memory tokens,\n    uint256[] memory balances,\n    uint256 lastChangeBlock\n  );\n\n  /**\n   * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     *\n     * See https://dev.balancer.fi/resources/joins-and-exits/pool-joins\n     */\n  function joinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    JoinPoolRequest calldata request\n  ) external payable;\n\n  enum JoinKind {INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT}\n\n  /// @notice WeightedPool ExitKinds\n  enum ExitKind {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT}\n  /// @notice Composable Stable V2 ExitKinds\n  enum ExitKindComposableStable {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT, EXACT_BPT_IN_FOR_ALL_TOKENS_OUT}\n\n\n  struct JoinPoolRequest {\n    IAsset[] assets;\n    uint256[] maxAmountsIn;\n    bytes userData;\n    bool fromInternalBalance;\n  }\n\n  /**\n   * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n  function exitPool(\n    bytes32 poolId,\n    address sender,\n    address payable recipient,\n    ExitPoolRequest calldata request\n  ) external;\n\n  struct ExitPoolRequest {\n    IAsset[] assets;\n    uint256[] minAmountsOut;\n    bytes userData;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n  event PoolBalanceChanged(\n    bytes32 indexed poolId,\n    address indexed liquidityProvider,\n    IERC20[] tokens,\n    int256[] deltas,\n    uint256[] protocolFeeAmounts\n  );\n\n  enum PoolBalanceChangeKind {JOIN, EXIT}\n\n  // Swaps\n  //\n  // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n  // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n  // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n  //\n  // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n  // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n  // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n  // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n  // individual swaps.\n  //\n  // There are two swap kinds:\n  //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n  // `onSwap` hook) the amount of tokens out (to send to the recipient).\n  //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n  // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n  //\n  // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n  // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n  // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n  // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n  // the final intended token.\n  //\n  // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n  // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n  // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n  // much less gas than they would otherwise.\n  //\n  // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n  // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n  // updating the Pool's internal accounting).\n  //\n  // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n  // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n  // minimum amount of tokens to receive (by passing a negative value) is specified.\n  //\n  // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n  // this point in time (e.g. if the transaction failed to be included in a block promptly).\n  //\n  // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n  // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n  // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n  // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n  //\n  // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n  enum SwapKind {GIVEN_IN, GIVEN_OUT}\n\n  /**\n   * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n  function swap(\n    SingleSwap calldata singleSwap,\n    FundManagement calldata funds,\n    uint256 limit,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  /**\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct SingleSwap {\n    bytes32 poolId;\n    SwapKind kind;\n    IAsset assetIn;\n    IAsset assetOut;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n  function batchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds,\n    int256[] calldata limits,\n    uint256 deadline\n  ) external payable returns (int256[] memory);\n\n  /**\n   * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct BatchSwapStep {\n    bytes32 poolId;\n    uint256 assetInIndex;\n    uint256 assetOutIndex;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n  event Swap(\n    bytes32 indexed poolId,\n    IERC20 indexed tokenIn,\n    IERC20 indexed tokenOut,\n    uint256 amountIn,\n    uint256 amountOut\n  );\n\n  /**\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n  struct FundManagement {\n    address sender;\n    bool fromInternalBalance;\n    address payable recipient;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n  function queryBatchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds\n  ) external returns (int256[] memory assetDeltas);\n\n  // BasePool.sol\n\n  /**\n* @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\n     *\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\n     * data, such as the protocol swap fee percentage and Pool balances.\n     *\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\n     * explicitly use eth_call instead of eth_sendTransaction.\n     */\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n\n}\n"
    },
    "contracts/integrations/balancer/IChildChainLiquidityGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\n/// @notice ChildChainLiquidityGaugeFactory, restored for 0x3b8cA519122CdD8efb272b0D3085453404B25bD0\n/// @dev See https://dev.balancer.fi/resources/vebal-and-gauges/gauges\ninterface IChildChainLiquidityGaugeFactory {\n  event RewardsOnlyGaugeCreated(\n    address indexed gauge,\n    address indexed pool,\n    address streamer\n  );\n\n  function create(address pool) external returns (address);\n\n  function getChildChainStreamerImplementation() external view returns (address);\n\n  function getGaugeImplementation() external view returns (address);\n\n  function getGaugePool(address gauge) external view returns (address);\n\n  function getGaugeStreamer(address gauge) external view returns (address);\n\n  function getPoolGauge(address pool) external view returns (address);\n\n  function getPoolStreamer(address pool) external view returns (address);\n\n  function isGaugeFromFactory(address gauge) external view returns (bool);\n\n  function isStreamerFromFactory(address streamer) external view returns (bool);\n}\n\n"
    },
    "contracts/integrations/balancer/IPoolSwapStructs.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IPoolSwapStructs {\n  struct SwapRequest {\n    uint8 kind;\n    address tokenIn;\n    address tokenOut;\n    uint256 amount;\n    bytes32 poolId;\n    uint256 lastChangeBlock;\n    address from;\n    address to;\n    bytes userData;\n  }\n}"
    },
    "contracts/integrations/uniswap/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n  /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n  /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n  /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n  function uniswapV3MintCallback(\n    uint256 amount0Owed,\n    uint256 amount1Owed,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport './IUniswapV3PoolImmutables.sol';\nimport './IUniswapV3PoolState.sol';\nimport './IUniswapV3PoolDerivedState.sol';\nimport './IUniswapV3PoolActions.sol';\nimport './IUniswapV3PoolOwnerActions.sol';\nimport './IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\nIUniswapV3PoolImmutables,\nIUniswapV3PoolState,\nIUniswapV3PoolDerivedState,\nIUniswapV3PoolActions,\nIUniswapV3PoolOwnerActions,\nIUniswapV3PoolEvents\n{}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n  /// @notice Sets the initial price for the pool\n  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n  /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n  function initialize(uint160 sqrtPriceX96) external;\n\n  /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n  /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n  /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n  /// @param recipient The address for which the liquidity will be created\n  /// @param tickLower The lower tick of the position in which to add liquidity\n  /// @param tickUpper The upper tick of the position in which to add liquidity\n  /// @param amount The amount of liquidity to mint\n  /// @param data Any data that should be passed through to the callback\n  /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount,\n    bytes calldata data\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Collects tokens owed to a position\n  /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n  /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n  /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n  /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n  /// @param recipient The address which should receive the fees collected\n  /// @param tickLower The lower tick of the position for which to collect fees\n  /// @param tickUpper The upper tick of the position for which to collect fees\n  /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n  /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n  /// @return amount0 The amount of fees collected in token0\n  /// @return amount1 The amount of fees collected in token1\n  function collect(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n\n  /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n  /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n  /// @dev Fees must be collected separately via a call to #collect\n  /// @param tickLower The lower tick of the position for which to burn liquidity\n  /// @param tickUpper The upper tick of the position for which to burn liquidity\n  /// @param amount How much liquidity to burn\n  /// @return amount0 The amount of token0 sent to the recipient\n  /// @return amount1 The amount of token1 sent to the recipient\n  function burn(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Swap token0 for token1, or token1 for token0\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n  /// @param recipient The address to receive the output of the swap\n  /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n  /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n  /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n  /// @param data Any data to be passed through to the callback\n  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n  /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n  /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n  /// @param recipient The address which will receive the token0 and token1 amounts\n  /// @param amount0 The amount of token0 to send\n  /// @param amount1 The amount of token1 to send\n  /// @param data Any data to be passed through to the callback\n  function flash(\n    address recipient,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n\n  /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n  /// you must call it with secondsAgos = [3600, 0].\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n  /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n  /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n  /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n  /// timestamp\n  function observe(uint32[] calldata secondsAgos)\n  external\n  view\n  returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n  /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n  /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n  /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n  /// snapshot is taken and the second snapshot is taken.\n  /// @param tickLower The lower tick of the range\n  /// @param tickUpper The upper tick of the range\n  /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n  /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n  /// @return secondsInside The snapshot of seconds per liquidity for the range\n  function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n  external\n  view\n  returns (\n    int56 tickCumulativeInside,\n    uint160 secondsPerLiquidityInsideX128,\n    uint32 secondsInside\n  );\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n  /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n  /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n  /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n  event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n  /// @notice Emitted when liquidity is minted for a given position\n  /// @param sender The address that minted the liquidity\n  /// @param owner The owner of the position and recipient of any minted liquidity\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity minted to the position range\n  /// @param amount0 How much token0 was required for the minted liquidity\n  /// @param amount1 How much token1 was required for the minted liquidity\n  event Mint(\n    address sender,\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted when fees are collected by the owner of a position\n  /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n  /// @param owner The owner of the position for which fees are collected\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount0 The amount of token0 fees collected\n  /// @param amount1 The amount of token1 fees collected\n  event Collect(\n    address indexed owner,\n    address recipient,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount0,\n    uint128 amount1\n  );\n\n  /// @notice Emitted when a position's liquidity is removed\n  /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n  /// @param owner The owner of the position for which liquidity is removed\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity to remove\n  /// @param amount0 The amount of token0 withdrawn\n  /// @param amount1 The amount of token1 withdrawn\n  event Burn(\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted by the pool for any swaps between token0 and token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the output of the swap\n  /// @param amount0 The delta of the token0 balance of the pool\n  /// @param amount1 The delta of the token1 balance of the pool\n  /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n  /// @param liquidity The liquidity of the pool after the swap\n  /// @param tick The log base 1.0001 of price of the pool after the swap\n  event Swap(\n    address indexed sender,\n    address indexed recipient,\n    int256 amount0,\n    int256 amount1,\n    uint160 sqrtPriceX96,\n    uint128 liquidity,\n    int24 tick\n  );\n\n  /// @notice Emitted by the pool for any flashes of token0/token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the tokens from flash\n  /// @param amount0 The amount of token0 that was flashed\n  /// @param amount1 The amount of token1 that was flashed\n  /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n  /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n  event Flash(\n    address indexed sender,\n    address indexed recipient,\n    uint256 amount0,\n    uint256 amount1,\n    uint256 paid0,\n    uint256 paid1\n  );\n\n  /// @notice Emitted by the pool for increases to the number of observations that can be stored\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n  /// just before a mint/swap/burn.\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(\n    uint16 observationCardinalityNextOld,\n    uint16 observationCardinalityNextNew\n  );\n\n  /// @notice Emitted when the protocol fee is changed by the pool\n  /// @param feeProtocol0Old The previous value of the token0 protocol fee\n  /// @param feeProtocol1Old The previous value of the token1 protocol fee\n  /// @param feeProtocol0New The updated value of the token0 protocol fee\n  /// @param feeProtocol1New The updated value of the token1 protocol fee\n  event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n  /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n  /// @param sender The address that collects the protocol fees\n  /// @param recipient The address that receives the collected protocol fees\n  /// @param amount0 The amount of token0 protocol fees that is withdrawn\n  /// @param amount0 The amount of token1 protocol fees that is withdrawn\n  event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n  /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n  /// @return The contract address\n  function factory() external view returns (address);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (address);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (address);\n\n  /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n  /// @return The fee\n  function fee() external view returns (uint24);\n\n  /// @notice The pool tick spacing\n  /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n  /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n  /// This value is an int24 to avoid casting even though it is always positive.\n  /// @return The tick spacing\n  function tickSpacing() external view returns (int24);\n\n  /// @notice The maximum amount of position liquidity that can use any tick in the range\n  /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n  /// @notice Set the denominator of the protocol's % share of the fees\n  /// @param feeProtocol0 new protocol fee for token0 of the pool\n  /// @param feeProtocol1 new protocol fee for token1 of the pool\n  function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n  /// @notice Collect the protocol fee accrued to the pool\n  /// @param recipient The address to which collected protocol fees should be sent\n  /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n  /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n  /// @return amount0 The protocol fee collected in token0\n  /// @return amount1 The protocol fee collected in token1\n  function collectProtocol(\n    address recipient,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n  /// when accessed externally.\n  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n  /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n  /// boundary.\n  /// observationIndex The index of the last oracle observation that was written,\n  /// observationCardinality The current maximum number of observations stored in the pool,\n  /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n  /// feeProtocol The protocol fee for both tokens of the pool.\n  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n  /// unlocked Whether the pool is currently locked to reentrancy\n  function slot0()\n  external\n  view\n  returns (\n    uint160 sqrtPriceX96,\n    int24 tick,\n    uint16 observationIndex,\n    uint16 observationCardinality,\n    uint16 observationCardinalityNext,\n    uint8 feeProtocol,\n    bool unlocked\n  );\n\n  /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal0X128() external view returns (uint256);\n\n  /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal1X128() external view returns (uint256);\n\n  /// @notice The amounts of token0 and token1 that are owed to the protocol\n  /// @dev Protocol fees will never exceed uint128 max in either token\n  function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n  /// @notice The currently in range liquidity available to the pool\n  /// @dev This value has no relationship to the total liquidity across all ticks\n  function liquidity() external view returns (uint128);\n\n  /// @notice Look up information about a specific tick in the pool\n  /// @param tick The tick to look up\n  /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n  /// tick upper,\n  /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n  /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n  /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n  /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n  /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n  /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n  /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n  /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n  /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n  /// a specific position.\n  function ticks(int24 tick)\n  external\n  view\n  returns (\n    uint128 liquidityGross,\n    int128 liquidityNet,\n    uint256 feeGrowthOutside0X128,\n    uint256 feeGrowthOutside1X128,\n    int56 tickCumulativeOutside,\n    uint160 secondsPerLiquidityOutsideX128,\n    uint32 secondsOutside,\n    bool initialized\n  );\n\n  /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n  function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n  /// @notice Returns the information about a position by the position's key\n  /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n  /// @return _liquidity The amount of liquidity in the position,\n  /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n  /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n  /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n  /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n  function positions(bytes32 key)\n  external\n  view\n  returns (\n    uint128 _liquidity,\n    uint256 feeGrowthInside0LastX128,\n    uint256 feeGrowthInside1LastX128,\n    uint128 tokensOwed0,\n    uint128 tokensOwed1\n  );\n\n  /// @notice Returns data about a specific observation index\n  /// @param index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return blockTimestamp The timestamp of the observation,\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\n  function observations(uint256 index)\n  external\n  view\n  returns (\n    uint32 blockTimestamp,\n    int56 tickCumulative,\n    uint160 secondsPerLiquidityCumulativeX128,\n    bool initialized\n  );\n}\n"
    },
    "contracts/libs/AppErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice List of all errors generated by the application\n///         Each error should have unique code TS-XXX and descriptive comment\nlibrary AppErrors {\n  /// @notice Provided address should be not zero\n  string public constant ZERO_ADDRESS = \"TS-1 zero address\";\n\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\n  string public constant UNISWAP_PAIR_NOT_FOUND = \"TS-2 pair not found\";\n\n  /// @notice Lengths not matched\n  string public constant WRONG_LENGTHS = \"TS-4 wrong lengths\";\n\n  /// @notice Unexpected zero balance\n  string public constant ZERO_BALANCE = \"TS-5 zero balance\";\n\n  string public constant ITEM_NOT_FOUND = \"TS-6 not found\";\n\n  string public constant NOT_ENOUGH_BALANCE = \"TS-7 not enough balance\";\n\n  /// @notice Price oracle returns zero price\n  string public constant ZERO_PRICE = \"TS-8 zero price\";\n\n  string public constant WRONG_VALUE = \"TS-9 wrong value\";\n\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\n  string public constant ZERO_AMOUNT_BORROWED = \"TS-10 zero borrowed amount\";\n\n  string public constant WITHDRAW_TOO_MUCH = \"TS-11 try to withdraw too much\";\n\n  string public constant UNKNOWN_ENTRY_KIND = \"TS-12 unknown entry kind\";\n\n  string public constant ONLY_TETU_CONVERTER = \"TS-13 only TetuConverter\";\n\n  string public constant WRONG_ASSET = \"TS-14 wrong asset\";\n\n  string public constant NO_LIQUIDATION_ROUTE = \"TS-15 No liquidation route\";\n\n  string public constant PRICE_IMPACT = \"TS-16 price impact\";\n\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\n  string public constant REPAY_MAKES_SWAP = \"TS-17 can not convert back\";\n\n  string public constant NO_INVESTMENTS = \"TS-18 no investments\";\n\n  string public constant INCORRECT_LENGTHS = \"TS-19 lengths\";\n}\n"
    },
    "contracts/libs/AppLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\n/// @notice Common internal utils\nlibrary AppLib {\n  using SafeERC20 for IERC20;\n\n  /// @notice Unchecked increment for for-cycles\n  function uncheckedInc(uint i) internal pure returns (uint) {\n  unchecked {\n    return i + 1;\n  }\n  }\n\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\n  /// @dev Should NOT be used for third-party pools\n  function approveIfNeeded(address token, uint amount, address spender) internal {\n    if (IERC20(token).allowance(address(this), spender) < amount) {\n      IERC20(token).safeApprove(spender, 0);\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\n      IERC20(token).safeApprove(spender, 2 ** 255);\n    }\n  }\n}\n"
    },
    "contracts/libs/AppPlatforms.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nlibrary AppPlatforms {\r\n  string public constant UNIV3 = \"UniswapV3\";\r\n  string public constant BALANCER = \"Balancer\";\r\n}\r\n"
    },
    "contracts/libs/ConverterEntryKinds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\nlibrary ConverterEntryKinds {\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\n\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\n  ///         C2 should be used as collateral to make a borrow B.\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\n\n  /// @notice Borrow given amount using min possible collateral\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\n\n  /// @notice Decode entryData, extract first uint - entry kind\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\n    if (entryData_.length == 0) {\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\n    }\n    return abi.decode(entryData_, (uint));\n  }\n}\n"
    },
    "contracts/libs/TokenAmountsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AppErrors.sol\";\n\n/// @title Library for clearing / joining token addresses & amounts arrays\n/// @author bogdoslav\nlibrary TokenAmountsLib {\n\n  function uncheckedInc(uint i) internal pure returns (uint) {\n  unchecked {\n    return i + 1;\n  }\n  }\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \"1.0.0\";\n\n  function filterZeroAmounts(\n    address[] memory tokens,\n    uint[] memory amounts\n  ) internal pure returns (\n    address[] memory t,\n    uint[] memory a\n  ) {\n    require(tokens.length == amounts.length, 'TAL: Arrays mismatch');\n    uint len2 = 0;\n    uint len = tokens.length;\n    for (uint i = 0; i < len; i++) {\n      if (amounts[i] != 0) len2++;\n    }\n\n    t = new address[](len2);\n    a = new uint[](len2);\n\n    uint j = 0;\n    for (uint i = 0; i < len; i++) {\n      uint amount = amounts[i];\n      if (amount != 0) {\n        t[j] = tokens[i];\n        a[j] = amount;\n        j++;\n      }\n    }\n  }\n\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\n  function combineArrays(\n    address[] memory tokens0,\n    uint[] memory amounts0,\n    address[] memory tokens1,\n    uint[] memory amounts1,\n    address[] memory tokens2,\n    uint[] memory amounts2\n  ) internal pure returns (\n    address[] memory allTokens,\n    uint[] memory allAmounts\n  ) {\n    uint[] memory lens = new uint[](3);\n    lens[0] = tokens0.length;\n    lens[1] = tokens1.length;\n    lens[2] = tokens2.length;\n\n    require(\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\n      AppErrors.INCORRECT_LENGTHS\n    );\n\n    uint maxLength = lens[0] + lens[1] + lens[2];\n    address[] memory tokensOut = new address[](maxLength);\n    uint[] memory amountsOut = new uint[](maxLength);\n    uint unitedLength;\n\n    for (uint step; step < 3; ++step) {\n      uint[] memory amounts = step == 0\n        ? amounts0\n        : (step == 1\n          ? amounts1\n          : amounts2);\n      address[] memory tokens = step == 0\n        ? tokens0\n        : (step == 1\n          ? tokens1\n          : tokens2);\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\n        uint amount1 = amounts[i1];\n        address token1 = tokens[i1];\n        bool united = false;\n\n        for (uint i = 0; i < unitedLength; i++) {\n          if (token1 == tokensOut[i]) {\n            amountsOut[i] += amount1;\n            united = true;\n            break;\n          }\n        }\n\n        if (!united) {\n          tokensOut[unitedLength] = token1;\n          amountsOut[unitedLength] = amount1;\n          unitedLength++;\n        }\n      }\n    }\n\n    // copy united tokens to result array\n    allTokens = new address[](unitedLength);\n    allAmounts = new uint[](unitedLength);\n    for (uint i; i < unitedLength; i++) {\n      allTokens[i] = tokensOut[i];\n      allAmounts[i] = amountsOut[i];\n    }\n\n  }\n}\n"
    },
    "contracts/strategies/balancer/BalancerComposableStableDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"../DepositorBase.sol\";\nimport \"./BalancerLogicLib.sol\";\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../integrations/balancer/IBalancerHelper.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAavePool.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAaveStablePool.sol\";\nimport \"../../integrations/balancer/IChildChainLiquidityGaugeFactory.sol\";\nimport \"../../integrations/balancer/IBalancerGauge.sol\";\n\n\n/// @title Depositor for Composable Stable Pool with several embedded linear pools like \"Balancer Boosted Aave USD\"\n/// @dev See https://app.balancer.fi/#/polygon/pool/0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b\n///            bb-am-DAI (DAI + amDAI) + bb-am-USDC (USDC + amUSDC) + bb-am-USDT (USDT + amUSDT)\n///      See https://docs.balancer.fi/products/balancer-pools/boosted-pools for explanation of Boosted Pools on BalanceR.\n///      Terms\n///         bb-a-USD = pool bpt\n///         bb-a-DAI, bb-a-USDC, etc = underlying bpt\nabstract contract BalancerComposableStableDepositor is DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant BALANCER_COMPOSABLE_STABLE_DEPOSITOR_VERSION = \"1.0.0\";\n\n  /// @dev https://dev.balancer.fi/references/contracts/deployment-addresses\n  IBVault internal constant BALANCER_VAULT = IBVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n  address internal constant BALANCER_HELPER = 0x239e55F427D44C3cc793f49bFB507ebe76638a2b;\n  /// @notice ChildChainLiquidityGaugeFactory allows to get gauge address by pool id\n  /// @dev see https://dev.balancer.fi/resources/vebal-and-gauges/gauges\n  address internal constant CHILD_CHAIN_LIQUIDITY_GAUGE_FACTORY = 0x3b8cA519122CdD8efb272b0D3085453404B25bD0;\n\n  /// @notice i.e. for \"Balancer Boosted Aave USD\": 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b\n  bytes32 public poolId;\n  IBalancerGauge internal _gauge;\n  address[] internal _rewardTokens;\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  function __BalancerBoostedAaveUsdDepositor_init(\n    bytes32 poolId_,\n    address[] memory rewardTokens_\n  ) internal onlyInitializing {\n    poolId = poolId_;\n\n    _gauge = IBalancerGauge(\n      IChildChainLiquidityGaugeFactory(\n        CHILD_CHAIN_LIQUIDITY_GAUGE_FACTORY\n      ).getPoolGauge(BalancerLogicLib.getPoolAddress(poolId_))\n    );\n    // infinite approve of pool-BPT to the gauge todo is it safe for the external gauge?\n    IERC20(BalancerLogicLib.getPoolAddress(poolId_)).safeApprove(address(_gauge), type(uint).max);\n\n    // we can get list of reward tokens from the gauge, but it's more cheaper to get it outside\n    _rewardTokens = rewardTokens_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    return BalancerLogicLib.depositorPoolAssets(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Returns pool weights\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\n  /// @return totalWeight Total sum of all items of {weights}\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    return BalancerLogicLib.depositorPoolWeights(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of DAI, USDC, USDT\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \"Balancer Boosted Aave USD\" we return:\n  ///                     0: balance DAI + (balance amDAI recalculated to DAI)\n  ///                     1: balance USDC + (amUSDC recalculated to USDC)\n  ///                     2: balance USDT + (amUSDT recalculated to USDT)\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reservesOut) {\n    reservesOut = BalancerLogicLib.depositorPoolReserves(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() override internal virtual view returns (uint liquidityOut) {\n    liquidityOut = _gauge.balanceOf(address(this))\n    + IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId)).balanceOf(address(this));\n  }\n\n  //// @notice Total amount of liquidity (LP tokens) in the depositor\n  function _depositorTotalSupply() override internal view returns (uint totalSupplyOut) {\n    totalSupplyOut = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId)).getActualSupply();\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  ///         i.e. for \"Balancer Boosted Aave USD\" we have DAI, USDC, USDT\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    bytes32 _poolId = poolId;\n    IBalancerBoostedAaveStablePool pool = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(_poolId));\n\n    // join to the pool, receive pool-BPTs\n    (amountsConsumedOut, liquidityOut) = BalancerLogicLib.depositorEnter(BALANCER_VAULT, _poolId, amountsDesired_);\n\n    // stake all available pool-BPTs to the gauge\n    // we can have pool-BPTs on depositor's balance after previous exit, stake them too\n    _gauge.deposit(pool.balanceOf(address(this)));\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then should make full exit\n  /// @param liquidityAmount_ Max amount to withdraw in bpt. Actual withdrawn amount will be less,\n  ///                         so it worth to add a gap to this amount, i.e. 1%\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function _depositorExit(uint liquidityAmount_) override internal virtual returns (\n    uint[] memory amountsOut\n  ) {\n    bytes32 _poolId = poolId;\n    IBalancerGauge __gauge = _gauge;\n    IBalancerBoostedAaveStablePool pool = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(_poolId));\n\n    // we need to withdraw pool-BPTs from the _gauge\n    // at first, let's try to use exist pool-BPTs on the depositor balance, probably it's enough\n    // we can have pool-BPTs on depositor's balance after previous exit, see BalancerLogicLib.depositorExit\n    uint depositorBalance = pool.balanceOf(address(this));\n    uint gaugeBalance = __gauge.balanceOf(address(this));\n\n    uint liquidityToWithdraw = liquidityAmount_ > depositorBalance\n    ? liquidityAmount_ - depositorBalance\n    : 0;\n\n    // calculate how much pool-BPTs we should withdraw from the gauge\n    if (liquidityToWithdraw > 0) {\n      if (liquidityToWithdraw > gaugeBalance) {\n        liquidityToWithdraw = gaugeBalance;\n      }\n    }\n\n    // un-stake required pool-BPTs from the gauge\n    if (liquidityToWithdraw > 0) {\n      __gauge.withdraw(liquidityToWithdraw);\n    }\n\n    // withdraw the liquidity from the pool\n    amountsOut = (liquidityAmount_ >= depositorBalance + gaugeBalance)\n    ? BalancerLogicLib.depositorExitFull(BALANCER_VAULT, _poolId)\n    : BalancerLogicLib.depositorExit(BALANCER_VAULT, _poolId, liquidityToWithdraw);\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then full exit is required\n  ///      we emulate is at normal exit + conversion of remain BPT directly to the main asset\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function _depositorQuoteExit(uint liquidityAmount_) override internal virtual returns (uint[] memory amountsOut) {\n    uint liquidity = _depositorLiquidity();\n    if (liquidity == 0) {\n      // there is no liquidity, output is zero\n      return new uint[](_depositorPoolAssets().length);\n    } else {\n      // BalancerLogicLib.depositorQuoteExit takes into account the cost of unused BPT\n      // so we don't need a special logic here for the full exit\n      return BalancerLogicLib.depositorQuoteExit(\n        BALANCER_VAULT,\n        IBalancerHelper(BALANCER_HELPER),\n        poolId,\n        liquidityAmount_\n      );\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Claim all possible rewards.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    return BalancerLogicLib.depositorClaimRewards(_gauge, _rewardTokens);\n  }\n\n  /// @dev Returns reward token addresses array.\n  function rewardTokens() external view returns (address[] memory tokens) {\n    return _rewardTokens;\n  }\n\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[16] private __gap; // TODO 16 ???\n}\n"
    },
    "contracts/strategies/balancer/BalancerComposableStableStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./BalancerComposableStableDepositor.sol\";\nimport \"../../libs/AppPlatforms.sol\";\n\n// todo make BalancerComposableStableDepositor not abstract\ncontract BalancerComposableStableStrategy is ConverterStrategyBase, BalancerComposableStableDepositor {\n  string public constant override NAME = \"Balancer Boosted Aave USD Strategy\";\n  string public constant override PLATFORM = AppPlatforms.BALANCER;\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n  bytes32 public constant POOL_ID = 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b;\n\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_\n  ) external initializer {\n    // we can take address of the reward tokens using gauge and gauge.reward_contract\n    // it worth to encode these array to avoid calculation in init\n    address[] memory rewardTokens = new address[](1);\n    rewardTokens[0] = 0x9a71012B13CA4d3D0Cdc72A177DF3ef03b0E76A3;\n\n    __BalancerBoostedAaveUsdDepositor_init(POOL_ID, rewardTokens);\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n  }\n}\n"
    },
    "contracts/strategies/balancer/BalancerLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\nimport \"../../libs/AppErrors.sol\";\nimport \"../../libs/AppLib.sol\";\nimport \"../../libs/TokenAmountsLib.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAavePool.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAaveStablePool.sol\";\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../integrations/balancer/IBalancerHelper.sol\";\nimport \"../../integrations/balancer/IBalancerGauge.sol\";\n\n/// @notice Functions of BalancerComposableStableDepositor\n/// @dev Many of functions are declared as external to reduce contract size\nlibrary BalancerLogicLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Types\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev local vars in getAmountsToDeposit to avoid stack too deep\n  struct LocalGetAmountsToDeposit {\n    /// @notice Decimals of {tokens_}, 0 for BPT\n    uint[] decimals;\n    /// @notice Length of {tokens_} array\n    uint len;\n    /// @notice amountBPT / underlyingAmount, decimals 18, 0 for BPT\n    uint[] rates;\n  }\n\n  /// @notice Local variables required inside _depositorEnter/Exit/QuoteExit, avoid stack too deep\n  struct DepositorLocal {\n    uint bptIndex;\n    uint len;\n    IERC20[] tokens;\n    uint[] balances;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Asset related utils\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate amounts of {tokens} to be deposited to POOL_ID in proportions according to the {balances}\n  /// @param amountsDesired_ Desired amounts of tokens. The order of the tokens is exactly the same as in {tokens}.\n  ///                        But the array has length 3, not 4, because there is no amount for bb-am-USD here.\n  /// @param tokens_ All bb-am-* tokens (including bb-am-USD) received through getPoolTokens\n  ///                           The order of the tokens is exactly the same as in getPoolTokens-results\n  /// @param balances_ Balances of bb-am-* pools in terms of bb-am-USD tokens (received through getPoolTokens)\n  ///                           The order of the tokens is exactly the same as in {tokens}\n  /// @param totalUnderlying_ Total amounts of underlying assets (DAI, USDC, etc) in embedded linear pools.\n  ///                         The array should have same order of tokens as {tokens_}, value for BPT token is not used\n  /// @param indexBpt_ Index of BPT token inside {balances_}, {tokens_} and {totalUnderlying_} arrays\n  /// @return amountsOut Desired amounts in proper proportions for depositing.\n  ///         The order of the tokens is exactly the same as in results of getPoolTokens, 0 for BPT\n  ///         i.e. DAI, BB-AM-USD, USDC, USDT\n  function getAmountsToDeposit(\n    uint[] memory amountsDesired_,\n    IERC20[] memory tokens_,\n    uint[] memory balances_,\n    uint[] memory totalUnderlying_,\n    uint indexBpt_\n  ) internal view returns (\n    uint[] memory amountsOut\n  ) {\n    LocalGetAmountsToDeposit memory p;\n    // check not zero balances, cache index of bbAmUSD, save 10**decimals to array\n    p.len = tokens_.length;\n    require(p.len == balances_.length, AppErrors.WRONG_LENGTHS);\n    require(p.len == amountsDesired_.length || p.len - 1 == amountsDesired_.length, AppErrors.WRONG_LENGTHS);\n\n    p.decimals = new uint[](p.len);\n    p.rates = new uint[](p.len);\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexBpt_) {\n        require(balances_[i] != 0, AppErrors.ZERO_BALANCE);\n        p.decimals[i] = 10 ** IERC20Metadata(address(tokens_[i])).decimals();\n\n        // Let's calculate a rate: amountBPT / underlyingAmount, decimals 18\n        p.rates[i] = balances_[i] * 1e18 / totalUnderlying_[i];\n      }\n    }\n\n    amountsOut = new uint[](p.len - 1);\n\n    // The balances set proportions of underlying-bpt, i.e. bb-am-DAI : bb-am-USDC : bb-am-USDT\n    // Our task is find amounts of DAI : USDC : USDT that won't change that proportions after deposit.\n    // We have arbitrary desired amounts, i.e. DAI = X, USDC = Y, USDT = Z\n    // For each token: assume that it can be used in full.\n    // If so, what amounts will have other tokens in this case according to the given proportions?\n    // i.e. DAI = X = 100.0 => USDC = 200.0, USDT = 400.0. We need: Y >= 200, Z >= 400\n    // or   USDC = Y = 100.0 => DAI = 50.0, USDT = 200.0. We need: X >= 50, Z >= 200\n    // If any amount is less then expected, the token cannot be used in full.\n    // A token with min amount can be used in full, let's try to find its index.\n    // [0 : len - 1]\n    uint i3;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (indexBpt_ == i) continue;\n\n      uint amountInBpt18 = amountsDesired_[i3] * p.rates[i];\n\n      // [0 : len]\n      uint j;\n      // [0 : len - 1]\n      uint j3;\n      for (; j < p.len; j = AppLib.uncheckedInc(j)) {\n        if (indexBpt_ == j) continue;\n\n        // alpha = balancesDAI / balancesUSDC * decimalsDAI / decimalsUSDC\n        // amountDAI = amountUSDC * alpha * rateUSDC / rateDAI\n        amountsOut[j3] = amountInBpt18 * balances_[j] / p.rates[j] * p.decimals[j] / balances_[i] / p.decimals[i];\n        if (amountsOut[j3] > amountsDesired_[j3]) break;\n        j3++;\n      }\n\n      if (j == p.len) break;\n      i3++;\n    }\n  }\n\n\n  /// @notice Calculate total amount of underlying asset for each token except BPT\n  /// @dev Amount is calculated as MainTokenAmount + WrappedTokenAmount * WrappedTokenRate, see AaveLinearPool src\n  function getTotalAssetAmounts(IBVault vault_, IERC20[] memory tokens_, uint indexBpt_) internal view returns (\n    uint[] memory amountsOut\n  ) {\n    uint len = tokens_.length;\n    amountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexBpt_) {\n        IBalancerBoostedAavePool linearPool = IBalancerBoostedAavePool(address(tokens_[i]));\n        (, uint[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\n\n        amountsOut[i] =\n        balances[linearPool.getMainIndex()]\n        + balances[linearPool.getWrappedIndex()] * linearPool.getWrappedTokenRate() / 1e18;\n      }\n    }\n  }\n\n  /// @notice Split {liquidityAmount_} by assets according to proportions of their total balances\n  /// @param liquidityAmount_ Amount to withdraw in bpt\n  /// @param balances_ Balances received from getPoolTokens\n  /// @param bptIndex_ Index of pool-pbt inside {balances_}\n  /// @return bptAmountsOut Amounts of underlying-BPT. The array doesn't include an amount for pool-bpt\n  ///         Total amount of {bptAmountsOut}-items is equal to {liquidityAmount_}\n  function getBtpAmountsOut(\n    uint liquidityAmount_,\n    uint[] memory balances_,\n    uint bptIndex_\n  ) internal pure returns (uint[] memory bptAmountsOut) {\n    // we assume here, that len >= 2\n    // we don't check it because StableMath.sol in balancer has _MIN_TOKENS = 2;\n    uint len = balances_.length;\n    bptAmountsOut = new uint[](len - 1);\n\n    // compute total balance, skip pool-bpt\n    uint totalBalances;\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex_) continue;\n      totalBalances += balances_[i];\n      // temporary save incomplete amounts to bptAmountsOut\n      bptAmountsOut[k] = liquidityAmount_ * balances_[i];\n      ++k;\n    }\n\n    // finalize computation of bptAmountsOut using known totalBalances\n    uint total;\n    for (k = 0; k < len - 1; k = AppLib.uncheckedInc(k)) {\n      if (k == len - 2) {\n        // leftovers => last item\n        bptAmountsOut[k] = total > liquidityAmount_\n        ? 0\n        : liquidityAmount_ - total;\n      } else {\n        bptAmountsOut[k] /= totalBalances;\n        total += bptAmountsOut[k];\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Depositor view logic\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of DAI, USDC, USDT\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \"Balancer Boosted Aave USD\" we return:\n  ///                     0: balance DAI + (balance amDAI recalculated to DAI)\n  ///                     1: balance USDC + (amUSDC recalculated to USDC)\n  ///                     2: balance USDT + (amUSDT recalculated to USDT)\n  function depositorPoolReserves(IBVault vault_, bytes32 poolId_) external view returns (uint[] memory reservesOut) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    uint bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n    uint len = tokens.length;\n    // exclude pool-BPT\n    reservesOut = new uint[](len - 1);\n\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex) continue;\n      IBalancerBoostedAavePool linearPool = IBalancerBoostedAavePool(address(tokens[i]));\n\n      // Each bb-am-* returns (main-token, wrapped-token, bb-am-itself), the order of tokens is arbitrary\n      // i.e. (DAI + amDAI + bb-am-DAI) or (bb-am-USDC, amUSDC, USDC)\n\n      // get balances of all tokens of bb-am-XXX token, i.e. balances of (DAI, amDAI, bb-am-DAI)\n      (, uint256[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\n      // DAI\n      uint mainIndex = linearPool.getMainIndex();\n      // amDAI\n      uint wrappedIndex = linearPool.getWrappedIndex();\n\n      reservesOut[k] = balances[mainIndex] + balances[wrappedIndex] * linearPool.getWrappedTokenRate() / 1e18;\n      ++k;\n    }\n  }\n\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\n  function depositorPoolAssets(IBVault vault_, bytes32 poolId_) external view returns (address[] memory poolAssets) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    uint bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n    uint len = tokens.length;\n\n    poolAssets = new address[](len - 1);\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex) continue;\n\n      poolAssets[k] = IBalancerBoostedAavePool(address(tokens[i])).getMainToken();\n      ++k;\n    }\n  }\n\n  /// @notice Returns pool weights\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\n  /// @return totalWeight Total sum of all items of {weights}\n  function depositorPoolWeights(IBVault vault_, bytes32 poolId_) external view returns (\n    uint[] memory weights,\n    uint totalWeight\n  ) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    // totalWeight is equal to length of output array here\n    totalWeight = tokens.length - 1;\n    weights = new uint[](totalWeight);\n    for (uint i; i < totalWeight; i = AppLib.uncheckedInc(i)) {\n      weights[i] = 1;\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Depositor enter, exit logic\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  ///         i.e. for \"Balancer Boosted Aave USD\" we have DAI, USDC, USDT\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\n  function depositorEnter(IBVault vault_, bytes32 poolId_, uint[] memory amountsDesired_) external returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    DepositorLocal memory p;\n\n    // The implementation below assumes, that getPoolTokens returns the assets in following order:\n    //    bb-am-dai, bb-am-usd, bb-am-usdc, bb-am-usdt\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n    p.bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n\n    // temporary save current liquidity\n    liquidityOut = IBalancerBoostedAaveStablePool(address(p.tokens[p.bptIndex])).balanceOf(address(this));\n\n    // Original amounts can have any values.\n    // But we need amounts in such proportions that won't move the current balances\n    {\n      uint[] memory underlying = BalancerLogicLib.getTotalAssetAmounts(vault_, p.tokens, p.bptIndex);\n      amountsConsumedOut = BalancerLogicLib.getAmountsToDeposit(amountsDesired_, p.tokens, p.balances, underlying, p.bptIndex);\n    }\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n    sender : address(this),\n    fromInternalBalance : false,\n    recipient : payable(address(this)),\n    toInternalBalance : false\n    });\n\n    // swap all tokens XX => bb-am-XX\n    // we need two arrays with same amounts: amountsToDeposit (with 0 for BB-AM-USD) and userDataAmounts (no BB-AM-USD)\n    uint[] memory amountsToDeposit = new uint[](p.len);\n    // no bpt\n    uint[] memory userDataAmounts = new uint[](p.len - 1);\n    uint k;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      amountsToDeposit[i] = BalancerLogicLib.swap(\n        vault_,\n        IBalancerBoostedAavePool(address(p.tokens[i])).getPoolId(),\n        IBalancerBoostedAavePool(address(p.tokens[i])).getMainToken(),\n        address(p.tokens[i]),\n        amountsConsumedOut[k],\n        funds\n      );\n      userDataAmounts[k] = amountsToDeposit[i];\n      AppLib.approveIfNeeded(address(p.tokens[i]), amountsToDeposit[i], address(vault_));\n      ++k;\n    }\n\n    // add liquidity to balancer\n    vault_.joinPool(\n      poolId_,\n      address(this),\n      address(this),\n      IBVault.JoinPoolRequest({\n    assets : asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\n    maxAmountsIn : amountsToDeposit,\n    userData : abi.encode(IBVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, userDataAmounts, 0),\n    fromInternalBalance : false\n    })\n    );\n\n    uint liquidityAfter = IERC20(address(p.tokens[p.bptIndex])).balanceOf(address(this));\n\n    liquidityOut = liquidityAfter > liquidityOut\n    ? liquidityAfter - liquidityOut\n    : 0;\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @param liquidityAmount_ Amount to withdraw in bpt\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorExit(IBVault vault_, bytes32 poolId_, uint liquidityAmount_) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IBalancerBoostedAaveStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n\n    require(liquidityAmount_ <= p.tokens[p.bptIndex].balanceOf(address(this)), AppErrors.NOT_ENOUGH_BALANCE);\n\n    // BalancerR can spend a bit less amount of liquidity than {liquidityAmount_}\n    // i.e. we if liquidityAmount_ = 2875841, we can have leftovers = 494 after exit\n    vault_.exitPool(\n      poolId_,\n      address(this),\n      payable(address(this)),\n      IBVault.ExitPoolRequest({\n    assets : asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\n    minAmountsOut : new uint[](p.len), // todo: no limits?\n    userData : abi.encode(\n        IBVault.ExitKindComposableStable.BPT_IN_FOR_EXACT_TOKENS_OUT,\n        BalancerLogicLib.getBtpAmountsOut(liquidityAmount_, p.balances, p.bptIndex),\n        liquidityAmount_\n      ),\n    toInternalBalance : false\n    })\n    );\n\n    // now we have amBbXXX tokens; swap them to XXX assets\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n    sender : address(this),\n    fromInternalBalance : false,\n    recipient : payable(address(this)),\n    toInternalBalance : false\n    });\n\n    amountsOut = new uint[](p.len - 1);\n    uint k;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      uint amountIn = p.tokens[i].balanceOf(address(this));\n      if (amountIn != 0) {\n        amountsOut[k] = swap(\n          vault_,\n          IBalancerBoostedAavePool(address(p.tokens[i])).getPoolId(),\n          address(p.tokens[i]),\n          IBalancerBoostedAavePool(address(p.tokens[i])).getMainToken(),\n          amountIn,\n          funds\n        );\n      }\n      ++k;\n    }\n  }\n\n  /// @notice Withdraw all available amount of LP-tokens from the pool\n  ///         BalanceR doesn't allow to withdraw exact amount, so it's allowed to leave dust amount on the balance\n  /// @dev We make at most N attempts to withdraw (not more, each attempt takes a lot of gas).\n  ///      Each attempt reduces available balance at ~1e4 times.\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///                    The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorExitFull(IBVault vault_, bytes32 poolId_) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IBalancerBoostedAaveStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n    amountsOut = new uint[](p.len - 1);\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n    sender : address(this),\n    fromInternalBalance : false,\n    recipient : payable(address(this)),\n    toInternalBalance : false\n    });\n\n    uint liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\n    if (liquidityAmount > 0) {\n      uint liquidityThreshold = 10 ** IERC20Metadata(address(p.tokens[p.bptIndex])).decimals() / 100;\n\n      // we can make at most N attempts to withdraw amounts from the balanceR pool\n      for (uint i = 0; i < 2; ++i) {\n        vault_.exitPool(\n          poolId_,\n          address(this),\n          payable(address(this)),\n          IBVault.ExitPoolRequest({\n        assets : asIAsset(p.tokens),\n        minAmountsOut : new uint[](p.len), // todo: no limits?\n        userData : abi.encode(\n            IBVault.ExitKindComposableStable.BPT_IN_FOR_EXACT_TOKENS_OUT,\n            BalancerLogicLib.getBtpAmountsOut(liquidityAmount, p.balances, p.bptIndex),\n            liquidityAmount\n          ),\n        toInternalBalance : false\n        })\n        );\n        liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\n        if (liquidityAmount < liquidityThreshold || i == 1) {\n          break;\n        }\n        (, p.balances,) = vault_.getPoolTokens(poolId_);\n      }\n\n      // now we have amBbXXX tokens; swap them to XXX assets\n      uint k;\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n        if (i == p.bptIndex) continue;\n\n        uint amountIn = p.tokens[i].balanceOf(address(this));\n        if (amountIn != 0) {\n          amountsOut[k] = swap(\n            vault_,\n            IBalancerBoostedAavePool(address(p.tokens[i])).getPoolId(),\n            address(p.tokens[i]),\n            IBalancerBoostedAavePool(address(p.tokens[i])).getMainToken(),\n            amountIn,\n            funds\n          );\n        }\n        ++k;\n      }\n    }\n\n    uint depositorBalance = p.tokens[p.bptIndex].balanceOf(address(this));\n    if (depositorBalance > 0) {\n      uint k = 0;\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n        if (i == p.bptIndex) continue;\n\n        // we assume here, that the depositorBalance is small\n        // so we can directly swap it to any single asset without changing of pool resources proportions\n        amountsOut[k] += _convertSmallBptRemainder(vault_, poolId_, p, funds, depositorBalance, i);\n        break;\n      }\n    }\n\n    return amountsOut;\n  }\n\n  /// @notice convert remained SMALL amount of bpt => am-bpt => main token of the am-bpt\n  /// @return amountOut Received amount of am-bpt's main token\n  function _convertSmallBptRemainder(\n    IBVault vault_,\n    bytes32 poolId_,\n    DepositorLocal memory p,\n    IBVault.FundManagement memory funds,\n    uint bptAmountIn_,\n    uint indexTargetAmBpt_\n  ) internal returns (uint amountOut) {\n    uint amountAmBpt = BalancerLogicLib.swap(\n      vault_,\n      poolId_,\n      address(p.tokens[p.bptIndex]),\n      address(p.tokens[indexTargetAmBpt_]),\n      bptAmountIn_,\n      funds\n    );\n    amountOut = swap(\n      vault_,\n      IBalancerBoostedAavePool(address(p.tokens[indexTargetAmBpt_])).getPoolId(),\n      address(p.tokens[indexTargetAmBpt_]),\n      IBalancerBoostedAavePool(address(p.tokens[indexTargetAmBpt_])).getMainToken(),\n      amountAmBpt,\n      funds\n    );\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorQuoteExit(\n    IBVault vault_,\n    IBalancerHelper helper_,\n    bytes32 poolId_,\n    uint liquidityAmount_\n  ) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n\n    // bpt - amount of unconverted bpt\n    // let's temporary save total amount of converted BPT there\n    (uint256 bpt, uint[] memory amountsBpt) = helper_.queryExit(\n      poolId_,\n      address(this),\n      payable(address(this)),\n      IBVault.ExitPoolRequest({\n    assets : asIAsset(p.tokens),\n    minAmountsOut : new uint[](p.len), // todo: no limits?\n    userData : abi.encode(\n        IBVault.ExitKindComposableStable.BPT_IN_FOR_EXACT_TOKENS_OUT,\n        BalancerLogicLib.getBtpAmountsOut(liquidityAmount_, p.balances, p.bptIndex),\n        liquidityAmount_\n      ),\n    toInternalBalance : false\n    })\n    );\n\n    // amount of unconverted bpt, we need to take them into account for correct calculation of investedAssets amount\n    bpt = bpt < liquidityAmount_\n    ? liquidityAmount_ - bpt\n    : 0;\n\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n    sender : address(this),\n    fromInternalBalance : false,\n    recipient : payable(address(this)),\n    toInternalBalance : false\n    });\n    IBVault.BatchSwapStep[] memory steps = new IBVault.BatchSwapStep[](p.len - 1);\n    IAsset[] memory assets = new IAsset[](2 * (p.len - 1));\n    uint k;\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      if (bpt != 0) {\n        // take into account the cost of unused BPT by directly converting them to first available amBPT\n        int[] memory deltas = _convertBptToAmBpt(vault_, poolId_, p.tokens[p.bptIndex], bpt, p.tokens[i], funds);\n        if (deltas[0] > 0) {\n          bpt = (bpt < uint(deltas[0]))\n          ? bpt - uint(deltas[0])\n          : 0;\n          amountsBpt[i] += (deltas[1] < 0)\n          ? uint(- deltas[1])\n          : 0;\n        }\n      }\n      IBalancerBoostedAavePool linearPool = IBalancerBoostedAavePool(address(p.tokens[i]));\n      steps[k].poolId = linearPool.getPoolId();\n      steps[k].assetInIndex = 2 * k + 1;\n      steps[k].assetOutIndex = 2 * k;\n      steps[k].amount = amountsBpt[i];\n\n      assets[2 * k] = IAsset(linearPool.getMainToken());\n      assets[2 * k + 1] = IAsset(address(p.tokens[i]));\n      ++k;\n    }\n\n    int[] memory assetDeltas = vault_.queryBatchSwap(IBVault.SwapKind.GIVEN_IN, steps, assets, funds);\n\n    amountsOut = new uint[](p.len - 1);\n    k = 0;\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      amountsOut[k] = assetDeltas[2 * k] < 0\n      ? uint256(- assetDeltas[2 * k])\n      : 0;\n\n      ++k;\n    }\n  }\n\n  function _convertBptToAmBpt(\n    IBVault vault_,\n    bytes32 poolId_,\n    IERC20 bptToken,\n    uint amountBpt,\n    IERC20 amBptToken,\n    IBVault.FundManagement memory funds\n  ) internal returns (\n    int[] memory assetDeltas\n  ) {\n    IAsset[] memory assets = new IAsset[](2);\n    assets[0] = IAsset(address(bptToken));\n    assets[1] = IAsset(address(amBptToken));\n\n    IBVault.BatchSwapStep[] memory steps = new IBVault.BatchSwapStep[](1);\n    steps[0].poolId = poolId_;\n    steps[0].assetInIndex = 0;\n    steps[0].assetOutIndex = 1;\n    steps[0].amount = amountBpt;\n\n    return vault_.queryBatchSwap(IBVault.SwapKind.GIVEN_IN, steps, assets, funds);\n  }\n\n  /// @notice Swap given {amountIn_} of {assetIn_} to {assetOut_} using the given BalanceR pool\n  function swap(\n    IBVault vault_,\n    bytes32 poolId_,\n    address assetIn_,\n    address assetOut_,\n    uint amountIn_,\n    IBVault.FundManagement memory funds_\n  ) internal returns (uint amountOut) {\n    uint balanceBefore = IERC20(assetOut_).balanceOf(address(this));\n\n    IERC20(assetIn_).approve(address(vault_), amountIn_);\n    vault_.swap(\n      IBVault.SingleSwap({\n    poolId : poolId_,\n    kind : IBVault.SwapKind.GIVEN_IN,\n    assetIn : IAsset(assetIn_),\n    assetOut : IAsset(assetOut_),\n    amount : amountIn_,\n    userData : bytes(\"\")\n    }),\n      funds_,\n      1,\n      block.timestamp\n    );\n\n    // we assume here, that the balance cannot be decreased\n    amountOut = IERC20(assetOut_).balanceOf(address(this)) - balanceBefore;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Rewards\n  /////////////////////////////////////////////////////////////////////\n\n  function depositorClaimRewards(IBalancerGauge gauge_, address[] memory rewardTokens_) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    uint len = rewardTokens_.length;\n\n    tokensOut = new address[](len);\n    amountsOut = new uint[](len);\n\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\n      tokensOut[i] = rewardTokens_[i];\n\n      // temporary store current reward balance\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this));\n    }\n\n    gauge_.claim_rewards();\n\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this)) - amountsOut[i];\n    }\n\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Utils\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Returns the address of a Pool's contract.\n  ///      Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\n  function getPoolAddress(bytes32 id) internal pure returns (address) {\n    // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\n    // since the logical shift already sets the upper bits to zero.\n    return address(uint160(uint(id) >> (12 * 8)));\n  }\n\n  /// @dev see balancer-labs, ERC20Helpers.sol\n  function asIAsset(IERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      assets := tokens\n    }\n  }\n}\n"
    },
    "contracts/strategies/ConverterStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\";\nimport \"./ConverterStrategyBaseLib.sol\";\nimport \"./ConverterStrategyBaseLib2.sol\";\nimport \"./DepositorBase.sol\";\n\n/////////////////////////////////////////////////////////////////////\n///                        TERMS\n///  Main asset == underlying: the asset deposited to the vault by users\n///  Secondary assets: all assets deposited to the internal pool except the main asset\n///  Base amounts: not rewards; amounts deposited to vault, amounts deposited after compound\n///                Base amounts can be converted one to another\n/////////////////////////////////////////////////////////////////////\n\n/// @title Abstract contract for base Converter strategy functionality\n/// @notice All depositor assets must be correlated (ie USDC/USDT/DAI)\n/// @author bogdoslav, dvpublic\nabstract contract ConverterStrategyBase is ITetuConverterCallback, DepositorBase, StrategyBaseV2 {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n\n  struct WithdrawUniversalLocal {\n    uint[] reserves;\n    uint totalSupply;\n    uint depositorLiquidity;\n    uint liquidityAmount;\n    uint assetPrice;\n    uint[] amountsToConvert;\n  }\n\n  struct RequirePayAmountBackLocal {\n    uint len;\n    address converter;\n    address[] tokens;\n    uint indexTheAsset;\n    uint theAssetBaseAmount;\n    uint[] withdrawnAmounts;\n    uint[] spentAmounts;\n    uint liquidity;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant CONVERTER_STRATEGY_BASE_VERSION = \"1.0.1\";\n\n  uint internal constant REINVEST_THRESHOLD_DENOMINATOR = 100_000;\n\n  /////////////////////////////////////////////////////////////////////\n  //                        VARIABLES\n  //                Keep names and ordering!\n  // Add only in the bottom and don't forget to decrease gap variable\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Amount of underlying assets invested to the pool.\n  uint internal _investedAssets;\n\n  /// @dev Linked Tetu Converter\n  ITetuConverter public converter;\n\n  /// @notice Minimum token amounts that can be liquidated\n  mapping(address => uint) public liquidationThresholds;\n\n  /// @notice Percent of asset amount that can be not invested, it's allowed to just keep it on balance\n  ///         decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\n  /// @dev We need this threshold to avoid numerous conversions of small amounts\n  uint public reinvestThresholdPercent;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        Events\n  /////////////////////////////////////////////////////////////////////\n  event LiquidationThresholdChanged(address token, uint amount);\n  event ReinvestThresholdPercentChanged(uint amount);\n  event ReturnAssetToConverter(address asset, uint amount);\n  event OnDepositorEnter(uint[] amounts, uint[] consumedAmounts);\n  event OnDepositorExit(uint liquidityAmount, uint[] withdrawnAmounts);\n  event OnDepositorEmergencyExit(uint[] withdrawnAmounts);\n\n  /// @notice Recycle was made\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\n  /// @param receivedAmounts Received amounts of the tokens\n  ///        This array has +1 item at the end: received amount of the main asset\n  /// @param spentAmounts Spent amounts of the tokens\n  /// @param amountsToForward Amounts to be sent to forwarder\n  event Recycle(\n    address[] rewardTokens,\n    uint[] receivedAmounts,\n    uint[] spentAmounts,\n    uint[] amountsToForward,\n    uint[] performanceAmounts\n  );\n\n  /////////////////////////////////////////////////////////////////////\n  //                Initialization and configuration\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __ConverterStrategyBase_init(\n    address controller_,\n    address splitter_,\n    address converter_\n  ) internal onlyInitializing {\n    __StrategyBase_init(controller_, splitter_);\n    converter = ITetuConverter(converter_);\n  }\n\n  function setLiquidationThreshold(address token, uint amount) external {\n    StrategyLib.onlyOperators(controller());\n    liquidationThresholds[token] = amount;\n    emit LiquidationThresholdChanged(token, amount);\n  }\n\n  /// @param percent_ New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\n  function setReinvestThresholdPercent(uint percent_) external {\n    StrategyLib.onlyOperators(controller());\n    require(percent_ <= REINVEST_THRESHOLD_DENOMINATOR, StrategyLib.WRONG_VALUE);\n\n    reinvestThresholdPercent = percent_;\n    emit ReinvestThresholdPercentChanged(percent_);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                     Deposit to the pool\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Amount of underlying assets converted to pool assets and invested to the pool.\n  function investedAssets() override public view virtual returns (uint) {\n    return _investedAssets;\n  }\n\n  /// @notice Deposit given amount to the pool.\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    int totalAssetsDelta\n  ){\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(updateTotalAssetsBeforeInvest_);\n    // skip deposit for small amounts\n    if (amount_ > reinvestThresholdPercent * updatedInvestedAssets / REINVEST_THRESHOLD_DENOMINATOR) {\n      (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n\n      // prepare array of amounts ready to deposit, borrow missed amounts\n      (uint[] memory amounts, uint[] memory borrowedAmounts, uint collateral) = _beforeDeposit(\n        converter,\n        amount_,\n        tokens,\n        indexAsset\n      );\n\n      // make deposit, actually consumed amounts can be different from the desired amounts\n      (uint[] memory consumedAmounts,) = _depositorEnter(amounts);\n      emit OnDepositorEnter(amounts, consumedAmounts);\n\n      // adjust base-amounts\n      _updateBaseAmounts(tokens, borrowedAmounts, consumedAmounts, indexAsset, - int(collateral));\n      // adjust _investedAssets\n      _updateInvestedAssets();\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///               Convert amounts before deposit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Prepare {tokenAmounts} to be passed to depositorEnter\n  /// @dev Override this function to customize entry kind\n  /// @param amount_ The amount of main asset that should be invested\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return tokenAmounts Amounts of depositor's assets ready to invest (this array can be passed to depositorEnter)\n  /// @return borrowedAmounts Amounts that were borrowed to prepare {tokenAmounts}\n  /// @return spentCollateral Total collateral spent to get {borrowedAmounts}\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) internal virtual returns (\n    uint[] memory tokenAmounts,\n    uint[] memory borrowedAmounts,\n    uint spentCollateral\n  ) {\n    // calculate required collaterals for each token and temporary save them to tokenAmounts\n    (uint[] memory weights, uint totalWeight) = _depositorPoolWeights();\n    // temporary save collateral to tokensAmounts\n    tokenAmounts = ConverterStrategyBaseLib.getCollaterals(\n      amount_,\n      tokens_,\n      weights,\n      totalWeight,\n      indexAsset_,\n      IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle()),\n      baseAmounts\n    );\n\n    // make borrow and save amounts of tokens available for deposit to tokenAmounts\n    (tokenAmounts, borrowedAmounts, spentCollateral) = ConverterStrategyBaseLib.getTokenAmounts(\n      tetuConverter_,\n      tokens_,\n      indexAsset_,\n      tokenAmounts,\n      liquidationThresholds[tokens_[indexAsset_]],\n      baseAmounts\n    );\n    return (tokenAmounts, borrowedAmounts, spentCollateral);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                     Withdraw from the pool\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Withdraw given amount from the pool.\n  /// @param amount Amount to be withdrawn in terms of the asset.\n  /// @return investedAssetsUSD The value that we should receive after withdrawing (in USD, decimals of the {asset})\n  /// @return assetPrice Price of the {asset} from the price oracle\n  /// @return totalAssetsDelta The {strategy} updates its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawFromPool(uint amount) override internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(true);\n\n    require(updatedInvestedAssets != 0, AppErrors.NO_INVESTMENTS);\n    (investedAssetsUSD, assetPrice) = _withdrawUniversal(amount, false, updatedInvestedAssets);\n  }\n\n  /// @notice Withdraw all from the pool.\n  /// @return investedAssetsUSD The value that we should receive after withdrawing\n  /// @return assetPrice Price of the {asset} taken from the price oracle\n  /// @return totalAssetsDelta The {strategy} updates its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawAllFromPool() override internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(true);\n\n    (investedAssetsUSD, assetPrice) = _withdrawUniversal(0, true, updatedInvestedAssets);\n  }\n\n  /// @param amount Amount to be withdrawn. 0 is ok if we withdraw all.\n  /// @param all Withdraw all\n  /// @param investedAssets_ Current amount of invested assets\n  /// @return __investedAssetsUSD The value that we should receive after withdrawing\n  /// @return __assetPrice Price of the {asset} taken from the price oracle\n  function _withdrawUniversal(uint amount, bool all, uint investedAssets_) internal returns (\n    uint __investedAssetsUSD,\n    uint __assetPrice\n  ) {\n\n    if ((all || amount != 0) && investedAssets_ != 0) {\n\n      address[] memory tokens = _depositorPoolAssets();\n      address _asset = asset;\n      uint indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, _asset);\n      ITetuConverter _converter = converter;\n\n      WithdrawUniversalLocal memory vars = WithdrawUniversalLocal({\n      reserves : _depositorPoolReserves(),\n      totalSupply : _depositorTotalSupply(),\n      depositorLiquidity : _depositorLiquidity(),\n      liquidityAmount : 0,\n      amountsToConvert : new uint[](0),\n      assetPrice : ConverterStrategyBaseLib.getAssetPriceFromConverter(_converter, _asset)\n      });\n\n      (vars.liquidityAmount, vars.amountsToConvert) = ConverterStrategyBaseLib.getLiquidityAmountRatio(\n        all ? 0 : amount,\n        baseAmounts,\n        address(this),\n        tokens,\n        indexAsset,\n        _converter,\n        investedAssets_,\n        vars.depositorLiquidity\n      );\n\n      uint[] memory withdrawnAmounts;\n      uint expectedAmountMainAsset;\n\n      if (vars.liquidityAmount != 0) {\n\n        // =============== WITHDRAW =====================\n        // make withdraw\n        withdrawnAmounts = _depositorExit(vars.liquidityAmount);\n        emit OnDepositorExit(vars.liquidityAmount, withdrawnAmounts);\n        // ==============================================\n\n        (expectedAmountMainAsset, vars.amountsToConvert) = ConverterStrategyBaseLib.postWithdrawActions(\n          vars.reserves,\n          vars.depositorLiquidity,\n          vars.liquidityAmount,\n          vars.totalSupply,\n          vars.amountsToConvert,\n          tokens,\n          indexAsset,\n          _converter,\n          _depositorLiquidity(),\n          withdrawnAmounts\n        );\n\n      } else {\n        // we don't need to withdraw any amounts from the pool, available converted amounts are enough for us\n        (withdrawnAmounts, expectedAmountMainAsset) = ConverterStrategyBaseLib.postWithdrawActionsEmpty(\n          tokens,\n          indexAsset,\n          _converter,\n          new uint[](tokens.length), // array with all zero values\n          vars.amountsToConvert\n        );\n      }\n\n      // convert amounts to main asset and update base amounts\n      (uint collateral, uint[] memory repaid) = _convertAfterWithdraw(tokens, indexAsset, vars.amountsToConvert, _converter);\n      _updateBaseAmounts(tokens, withdrawnAmounts, repaid, indexAsset, int(collateral));\n\n      // adjust _investedAssets\n      _updateInvestedAssets();\n\n      return (expectedAmountMainAsset * vars.assetPrice / 1e18, vars.assetPrice);\n    }\n    return (0, 0);\n  }\n\n  /// @notice If pool supports emergency withdraw need to call it for emergencyExit()\n  function _emergencyExitFromPool() override internal virtual {\n    uint[] memory withdrawnAmounts = _depositorEmergencyExit();\n    emit OnDepositorEmergencyExit(withdrawnAmounts);\n\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n\n    // convert amounts to main asset and update base amounts\n    (uint collateral, uint[] memory repaid) = _convertAfterWithdrawAll(tokens, indexAsset);\n    _updateBaseAmounts(tokens, withdrawnAmounts, repaid, indexAsset, int(collateral));\n\n    // adjust _investedAssets\n    _updateInvestedAssets();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///               Convert amounts after withdraw\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Convert all available amounts of {tokens_} to the main {asset}\n  /// @dev todo SCB-587\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return collateralOut Total amount of collateral returned after closing positions\n  /// @return repaidAmounts What amounts were spent in exchange of the {collateralOut}\n  function _convertAfterWithdrawAll(address[] memory tokens_, uint indexAsset_) internal returns (\n    uint collateralOut,\n    uint[] memory repaidAmounts\n  ){\n    uint[] memory amountsToConvert = ConverterStrategyBaseLib2.getAvailableBalances(tokens_, indexAsset_);\n\n    // convert amounts to the main asset\n    (collateralOut, repaidAmounts) = _convertAfterWithdraw(tokens_, indexAsset_, amountsToConvert, converter);\n  }\n\n  /// @notice Convert {amountsToConvert_} to the main {asset}\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return collateralOut Total amount of collateral returned after closing positions\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\n  function _convertAfterWithdraw(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_,\n    ITetuConverter _converter\n  ) internal returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.convertAfterWithdraw(\n      _converter,\n      ITetuLiquidator(IController(controller()).liquidator()),\n      liquidationThresholds[tokens_[indexAsset_]],\n      tokens_,\n      indexAsset_,\n      amountsToConvert_\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                 Update base amounts\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Update base amounts after withdraw\n  /// @param receivedAmounts_ Received amounts of not main-asset\n  /// @param spentAmounts_ Spent amounts of not main-asset\n  /// @param indexAsset_ Index of the asset in {tokens_} with different update logic (using {amountAsset_})\n  /// @param amountAsset_ Base amount of the asset with index indexAsset_ should be adjusted to {amountAsset_}\n  function _updateBaseAmounts(\n    address[] memory tokens_,\n    uint[] memory receivedAmounts_,\n    uint[] memory spentAmounts_,\n    uint indexAsset_,\n    int amountAsset_\n  ) internal {\n    uint len = tokens_.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      uint receivedAmount = receivedAmounts_[i];\n      uint spentAmount = spentAmounts_[i];\n      if (i == indexAsset_) {\n        if (amountAsset_ > 0) {\n          receivedAmount += uint(amountAsset_);\n        } else {\n          spentAmount += uint(- amountAsset_);\n        }\n      }\n      _updateBaseAmountsForAsset(tokens_[i], receivedAmount, spentAmount);\n    }\n  }\n\n  function _updateBaseAmountsForAsset(address asset_, uint received_, uint spent_) internal {\n    if (received_ > spent_) {\n      _increaseBaseAmount(asset_, received_ - spent_, _balance(asset_));\n    } else if (spent_ > received_) {\n      _decreaseBaseAmount(asset_, spent_ - received_);\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                 Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claim all possible rewards.\n  function _claim() override internal virtual {\n    // get rewards from the Depositor\n    (address[] memory depositorRewardTokens, uint[] memory depositorRewardAmounts) = _depositorClaimRewards();\n\n    (address[] memory rewardTokens, uint[] memory amounts) = ConverterStrategyBaseLib.prepareRewardsList(\n      converter,\n      _depositorPoolAssets(),\n      depositorRewardTokens,\n      depositorRewardAmounts,\n      baseAmounts\n    );\n\n    uint len = rewardTokens.length;\n    if (len > 0) {\n      (uint[] memory received, uint[] memory spent, uint[] memory amountsToForward) = _recycle(rewardTokens, amounts);\n\n      _updateBaseAmounts(rewardTokens, received, spent, type(uint).max, 0);\n      // max - we don't need to exclude any asset\n      // received has a length equal to rewardTokens.length + 1\n      // last item contains amount of the {asset} received after swapping\n      _updateBaseAmountsForAsset(asset, received[len], 0);\n\n      // send forwarder-part of the rewards to the forwarder\n      ConverterStrategyBaseLib2.sendTokensToForwarder(controller(), splitter, rewardTokens, amountsToForward);\n    }\n  }\n\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards divided on two parts: to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just added to baseAmounts\n  /// All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder.\n  /// @dev {_recycle} is implemented as separate (inline) function to simplify unit testing\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @return receivedAmounts Received amounts of the tokens\n  ///         This array has +1 item at the end: received amount of the main asset\n  ///                                            there was no possibility to use separate var for it, stack too deep\n  /// @return spentAmounts Spent amounts of the tokens\n  /// @return amountsToForward Amounts to be sent to forwarder\n  function _recycle(address[] memory rewardTokens_, uint[] memory rewardAmounts_) internal returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    // send performance-part of the rewards to performanceReceiver\n    (uint[] memory rewardAmounts, uint[] memory performanceAmounts) = ConverterStrategyBaseLib2.sendPerformanceFee(\n      performanceFee,\n      performanceReceiver,\n      rewardTokens_,\n      rewardAmounts_\n    );\n\n    // send other part of rewards to forwarder/compound\n    (receivedAmounts, spentAmounts, amountsToForward) = ConverterStrategyBaseLib.recycle(\n      asset,\n      compoundRatio,\n      _depositorPoolAssets(),\n      ITetuLiquidator(IController(controller()).liquidator()),\n      liquidationThresholds,\n      baseAmounts,\n      rewardTokens_,\n      rewardAmounts\n    );\n\n    emit Recycle(\n      rewardTokens_,\n      receivedAmounts,\n      spentAmounts,\n      amountsToForward,\n      performanceAmounts\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Hardwork\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice A virtual handler to make any action before hardwork\n  function _preHardWork(bool reInvest) internal virtual {}\n\n  /// @notice A virtual handler to make any action after hardwork\n  function _postHardWork() internal virtual {}\n\n  /// @notice Is strategy ready to hard work\n  function isReadyToHardWork() override external virtual view returns (bool) {\n    // check claimable amounts and compare with thresholds\n    return true;\n  }\n\n  /// @notice Do hard work\n  function doHardWork() override public returns (uint, uint) {\n    require(msg.sender == splitter, StrategyLib.DENIED);\n    return _doHardWork(true);\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  function _handleRewards() internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    uint assetBalanceBefore = _balance(asset);\n    _claim();\n    assetBalanceAfterClaim = _balance(asset);\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(assetBalanceBefore, assetBalanceAfterClaim, earned, lost);\n    return (earned, lost, assetBalanceAfterClaim);\n  }\n\n  /// @return earned Earned amount in terms of {asset}\n  /// @return lost Lost amount in terms of {asset}\n  function _doHardWork(bool reInvest) internal returns (uint earned, uint lost) {\n    uint investedAssetsBefore = _investedAssets;\n    uint investedAssetsLocal = _updateInvestedAssets();\n\n    _preHardWork(reInvest);\n\n    uint assetBalance;\n    (earned, lost, assetBalance) = _handleRewards();\n\n    // register autocompound income or possible lose if assets fluctuated\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(investedAssetsBefore, investedAssetsLocal, earned, lost);\n\n    // re-invest income\n    if (reInvest && assetBalance > reinvestThresholdPercent * investedAssetsLocal / REINVEST_THRESHOLD_DENOMINATOR) {\n      uint assetInUseBefore = investedAssetsLocal + assetBalance;\n      _depositToPool(assetBalance, false);\n\n      (earned, lost) = ConverterStrategyBaseLib.registerIncome(assetInUseBefore, _investedAssets + _balance(asset), earned, lost);\n    }\n\n    _postHardWork();\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///               InvestedAssets Calculations\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Updates cached _investedAssets to actual value\n  /// @dev Should be called after deposit / withdraw / claim; virtual - for ut\n  function _updateInvestedAssets() internal returns (uint investedAssetsOut) {\n    investedAssetsOut = _calcInvestedAssets();\n    _investedAssets = investedAssetsOut;\n  }\n\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return Invested asset amount under control (in terms of {asset})\n  function _calcInvestedAssets() internal returns (uint) {\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n    return ConverterStrategyBaseLib.calcInvestedAssets(\n      tokens,\n    // quote exit should check zero liquidity\n      _depositorQuoteExit(_depositorLiquidity()),\n      indexAsset,\n      converter,\n      baseAmounts\n    );\n  }\n\n  function calcInvestedAssets() external returns (uint) {\n    return _calcInvestedAssets();\n  }\n\n  /// @notice Update invested assets and return delta [new-investedAssets - old-investedAssets]\n  /// @param updateTotalAssetsBeforeInvest_ If false - skip update, return delta = 0\n  function _updateInvestedAssetsAndGetDelta(bool updateTotalAssetsBeforeInvest_) internal returns (\n    uint updatedInvestedAssets,\n    int totalAssetsDelta\n  ) {\n    uint __investedAssets = _investedAssets;\n\n    updatedInvestedAssets = updateTotalAssetsBeforeInvest_\n    ? _updateInvestedAssets()\n    : __investedAssets;\n\n    totalAssetsDelta = updateTotalAssetsBeforeInvest_\n    ? int(updatedInvestedAssets) - int(__investedAssets)\n    : int(0);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///               ITetuConverterCallback\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Converters asks to send some amount back.\n  /// @param theAsset_ Required asset (either collateral or borrow)\n  /// @param amount_ Required amount of the {theAsset_}\n  /// @return amountOut Amount sent to balance of TetuConverter, amountOut <= amount_\n  function requirePayAmountBack(address theAsset_, uint amount_) external override returns (uint amountOut) {\n    // todo move to library\n    RequirePayAmountBackLocal memory v;\n    v.converter = address(converter);\n    require(msg.sender == v.converter, StrategyLib.DENIED);\n\n    // detect index of the target asset\n    (v.tokens, v.indexTheAsset) = _getTokens(theAsset_);\n    require(v.indexTheAsset != type(uint).max, StrategyLib.WRONG_VALUE);\n    v.len = v.tokens.length;\n\n    // get amount of target asset available to be sent\n    v.theAssetBaseAmount = baseAmounts[theAsset_];\n\n    // follow array can be re-created below but it's safer to initialize them here\n    v.withdrawnAmounts = new uint[](v.len);\n    v.spentAmounts = new uint[](v.len);\n\n    // withdraw from the pool\n    if (v.theAssetBaseAmount < amount_) {\n      // the strategy doesn't have enough target asset on balance\n      // withdraw all from the pool but don't convert assets to underlying\n      v.liquidity = _depositorLiquidity();\n      if (v.liquidity != 0) {\n        v.withdrawnAmounts = _depositorExit(v.liquidity);\n        emit OnDepositorExit(v.liquidity, v.withdrawnAmounts);\n      }\n    }\n\n    // convert withdrawn assets to the target asset\n    if (v.theAssetBaseAmount + v.withdrawnAmounts[v.indexTheAsset] < amount_) {\n      (v.spentAmounts, v.withdrawnAmounts) = ConverterStrategyBaseLib.swapToGivenAmount(\n        amount_ - (v.theAssetBaseAmount + v.withdrawnAmounts[v.indexTheAsset]),\n        v.tokens,\n        v.indexTheAsset,\n        asset, // underlying === main asset\n        v.withdrawnAmounts,\n        ITetuConverter(v.converter),\n        ITetuLiquidator(IController(controller()).liquidator()),\n        liquidationThresholds[theAsset_],\n        ConverterStrategyBaseLib.OVERSWAP,\n        baseAmounts\n      );\n    }\n\n    // send amount to converter and update baseAmounts\n    amountOut = Math.min(v.theAssetBaseAmount + v.withdrawnAmounts[v.indexTheAsset], amount_);\n    IERC20(theAsset_).safeTransfer(v.converter, amountOut);\n    _updateBaseAmounts(v.tokens, v.withdrawnAmounts, v.spentAmounts, v.indexTheAsset, - int(amountOut));\n    // There are two cases of calling requirePayAmountBack by converter:\n    // 1) close a borrow: we will receive collateral back and amount of investedAssets almost won't change\n    // 2) rebalancing: we have real loss, it will be taken into account at next hard work\n    // So, _updateInvestedAssets() is not called here\n    emit ReturnAssetToConverter(theAsset_, amountOut);\n\n    // let's leave any leftovers un-invested, they will be reinvested at next hardwork\n  }\n\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external override {\n    uint len = assets_.length;\n    require(len == amounts_.length, AppErrors.INCORRECT_LENGTHS);\n\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\n      if (amounts_[i] != 0) {\n        _increaseBaseAmount(assets_[i], amounts_[i], _balance(assets_[i]));\n      }\n    }\n\n    // TetuConverter is able two call this function in two cases:\n    // 1) rebalancing (the health factor of some borrow is too low)\n    // 2) forcible closing of the borrow\n    // In both cases we update invested assets value here\n    // and avoid fixing any related losses in hardwork\n    _updateInvestedAssets();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                Others\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Unlimited capacity by default\n  function capacity() external virtual view returns (uint) {\n    return 2 ** 255;\n    // almost same as type(uint).max but more gas efficient\n  }\n\n  function _getTokens(address asset_) internal view returns (address[] memory tokens, uint indexAsset) {\n    tokens = _depositorPoolAssets();\n    indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, asset_);\n  }\n\n  /**\n* @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[46] private __gap;\n\n}\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppLib.sol\";\nimport \"../libs/TokenAmountsLib.sol\";\nimport \"../libs/ConverterEntryKinds.sol\";\n\nlibrary ConverterStrategyBaseLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\n  struct RecycleLocalParams {\n    uint amountToCompound;\n    uint amountToForward;\n    address rewardToken;\n    uint liquidationThresholdAsset;\n    uint len;\n    uint baseAmountIn;\n    uint totalRewardAmounts;\n    uint spentAmountIn;\n    uint receivedAmountOut;\n  }\n\n  struct OpenPositionLocal {\n    uint entryKind;\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n  }\n\n  struct OpenPositionEntryKind1Local {\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n    uint c1;\n    uint c3;\n    uint ratio;\n    uint alpha;\n  }\n\n  struct CalcInvestedAssetsLocal {\n    uint len;\n    uint[] prices;\n    uint[] decs;\n    uint[] debts;\n  }\n\n  struct ConvertAfterWithdrawLocalParams {\n    address asset;\n    uint collateral;\n    uint spentAmountIn;\n    uint receivedAmountOut;\n  }\n\n  struct SwapToGivenAmountInputParams {\n    uint targetAmount;\n    address[] tokens;\n    uint indexTargetAsset;\n    address underlying;\n    uint[] amounts;\n    ITetuConverter converter;\n    ITetuLiquidator liquidator;\n    uint liquidationThresholdForTargetAsset;\n    /// @notice Allow to swap more then required (i.e. 1_000 => +1%)\n    ///         to avoid additional swap if the swap return amount a bit less than we expected\n    uint overswap;\n  }\n\n  struct SwapToGivenAmountLocal {\n    uint len;\n    uint[] availableAmounts;\n    uint[] receivedAmounts;\n    uint i;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        Constants\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice approx one month for average block time 2 sec\n  uint internal constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\n  uint internal constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n  uint internal constant DENOMINATOR = 100_000;\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\n  uint internal constant PRICE_IMPACT_TOLERANCE = 300;\n  /// @notice borrow/collateral amount cannot be less than given number of tokens\n  uint internal constant DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD = 10;\n  /// @notice Allow to swap more then required (i.e. 1_000 => +1%) inside {swapToGivenAmount}\n  ///         to avoid additional swap if the swap will return amount a bit less than we expected\n  uint internal constant OVERSWAP = PRICE_IMPACT_TOLERANCE + _ASSET_LIQUIDATION_SLIPPAGE;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                         Events\n  /////////////////////////////////////////////////////////////////////\n  /// @notice A borrow was made\n  event OpenPosition(\n    address converter,\n    address collateralAsset,\n    uint collateralAmount,\n    address borrowAsset,\n    uint borrowedAmount,\n    address recepient\n  );\n\n  /// @notice Some borrow(s) was/were repaid\n  event ClosePosition(\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    address recepient,\n    uint returnedAssetAmountOut,\n    uint returnedBorrowAmountOut\n  );\n\n  /// @notice A liquidation was made\n  event Liquidation(\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint spentAmountIn,\n    uint receivedAmountOut\n  );\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      View functions\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Get amount of assets that we expect to receive after withdrawing\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\n  ///                  one of assets must be {asset_}\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\n  function getExpectedWithdrawnAmounts(\n    uint[] memory reserves_,\n    uint liquidityAmount_,\n    uint totalSupply_\n  ) internal pure returns (\n    uint[] memory withdrawnAmountsOut\n  ) {\n    uint ratio = totalSupply_ == 0\n      ? 0\n      : (liquidityAmount_ >= totalSupply_\n        ? 1e18\n        : 1e18 * liquidityAmount_ / totalSupply_\n    );\n    // we need brackets here for npm.run.coverage\n\n    uint len = reserves_.length;\n    withdrawnAmountsOut = new uint[](len);\n\n    if (ratio != 0) {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\n      }\n    }\n  }\n\n  /// @notice For each {token_} calculate a part of {amount_} to be used as collateral according to the weights.\n  ///         I.e. we have 300 USDC, we need to split it on 100 USDC, 100 USDT, 100 DAI\n  ///         USDC is main asset, USDT and DAI should be borrowed. We check amounts of USDT and DAI on the balance\n  ///         and return collaterals reduced on that amounts. For main asset, we return full amount always (100 USDC).\n  function getCollaterals(\n    uint amount_,\n    address[] memory tokens_,\n    uint[] memory weights_,\n    uint totalWeight_,\n    uint indexAsset_,\n    IPriceOracle priceOracle,\n    mapping(address => uint) storage baseAmounts_\n  ) external view returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    uint len = tokens_.length;\n    tokenAmountsOut = new uint[](len);\n\n    // get token prices and decimals\n    (uint[] memory prices, uint[] memory decs) = _getPricesAndDecs(priceOracle, tokens_, len);\n\n    // split the amount on tokens proportionally to the weights\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      uint amountAssetForToken = amount_ * weights_[i] / totalWeight_;\n\n      if (i == indexAsset_) {\n        tokenAmountsOut[i] = amountAssetForToken;\n      } else {\n        // if we have some tokens on balance then we need to use only a part of the collateral\n        uint tokenAmountToBeBorrowed = amountAssetForToken\n        * prices[indexAsset_]\n        * decs[i]\n        / prices[i]\n        / decs[indexAsset_];\n\n        uint tokenBalance = baseAmounts_[tokens_[i]];\n        if (tokenBalance < tokenAmountToBeBorrowed) {\n          tokenAmountsOut[i] = amountAssetForToken * (tokenAmountToBeBorrowed - tokenBalance) / tokenAmountToBeBorrowed;\n        }\n      }\n    }\n  }\n\n  /// @return prices Prices with decimals 18\n  /// @return decs 10**decimals\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\n    uint[] memory prices,\n    uint[] memory decs\n  ) {\n    prices = new uint[](len);\n    decs = new uint[](len);\n    {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\n      }\n    }\n  }\n\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\n    uint len = tokens_.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (tokens_[i] == asset_) {\n        return i;\n      }\n    }\n    return type(uint).max;\n  }\n\n  /// @notice Get a ratio to calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\n  ///         User needs to withdraw {targetAmount_} in main asset.\n  ///         There are two kinds of available liquidity:\n  ///         1) liquidity in the pool - {depositorLiquidity_}\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\n  ///         To withdraw {targetAmount_} we need\n  ///         1) Reconvert converted amounts back to main asset\n  ///         2) IF result amount is not necessary - withdraw some liquidity from the pool\n  ///            and also convert it to the main asset.\n  /// @dev This is a writable function with read-only behavior (because of the quote-call)\n  /// @param targetAmount_ Required amount of main asset to be withdrawn from the strategy\n  ///                      0 - withdraw all\n  /// @param baseAmounts_ Available balances of the converted assets\n  /// @param strategy_ Address of the strategy\n  function getLiquidityAmountRatio(\n    uint targetAmount_,\n    mapping(address => uint) storage baseAmounts_,\n    address strategy_,\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint investedAssets,\n    uint depositorLiquidity\n  ) external returns (\n    uint liquidityRatioOut,\n    uint[] memory amountsToConvertOut\n  ) {\n    bool all = targetAmount_ == 0;\n\n    uint len = tokens.length;\n    amountsToConvertOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n\n      uint baseAmount = baseAmounts_[tokens[i]];\n      if (baseAmount != 0) {\n        // let's estimate collateral that we received back after repaying baseAmount\n        uint expectedCollateral = converter.quoteRepay(\n          strategy_,\n          tokens[indexAsset],\n          tokens[i],\n          baseAmount\n        );\n\n        if (all || targetAmount_ != 0) {\n          // We always repay WHOLE available baseAmount even if it gives us much more amount then we need.\n          // We cannot repay a part of it because converter doesn't allow to know\n          // what amount should be repaid to get given amount of collateral.\n          // And it's too dangerous to assume that we can calculate this amount\n          // by reducing baseAmount proportionally to expectedCollateral/targetAmount_\n          amountsToConvertOut[i] = baseAmount;\n        }\n\n        if (targetAmount_ > expectedCollateral) {\n          targetAmount_ -= expectedCollateral;\n        } else {\n          targetAmount_ = 0;\n        }\n\n        if (investedAssets > expectedCollateral) {\n          investedAssets -= expectedCollateral;\n        } else {\n          investedAssets = 0;\n        }\n      }\n    }\n\n    require(all || investedAssets > 0, AppErrors.WITHDRAW_TOO_MUCH);\n\n    liquidityRatioOut = all\n      ? 1e18\n      : ((targetAmount_ == 0)\n        ? 0\n        : 1e18\n          * 101 // add 1% on top...\n          * targetAmount_ / investedAssets // a part of amount that we are going to withdraw\n          / 100 // .. add 1% on top\n    );\n\n    if (liquidityRatioOut != 0) {\n      // liquidityAmount temporary contains ratio...\n      liquidityRatioOut = liquidityRatioOut * depositorLiquidity / 1e18;\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Borrow and close positions\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  function openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdAmountIn_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return _openPosition(tetuConverter_, entryData_, collateralAsset_, borrowAsset_, amountIn_, thresholdAmountIn_);\n  }\n\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  /// @param thresholdAmountIn_ Min value of amountIn allowed for the second and subsequent conversions.\n  ///        0 - use default min value\n  ///        If amountIn becomes too low, no additional borrows are possible, so\n  ///        the rest amountIn is just added to collateral/borrow amount of previous conversion.\n  function _openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdAmountIn_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    if (thresholdAmountIn_ == 0) {\n      // zero threshold is not allowed because round-issues are possible, see openPosition.dust test\n      // we assume here, that it's useless to borrow amount using collateral/borrow amount\n      // less than given number of tokens (event for BTC)\n      thresholdAmountIn_ = DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD;\n    }\n    require(amountIn_ > thresholdAmountIn_, AppErrors.WRONG_VALUE);\n\n    OpenPositionLocal memory vars;\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\n    vars.entryKind = ConverterEntryKinds.getEntryKind(entryData_);\n    if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\n      return openPositionEntryKind1(\n        tetuConverter_,\n        entryData_,\n        collateralAsset_,\n        borrowAsset_,\n        amountIn_,\n        thresholdAmountIn_\n      );\n    } else {\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n        entryData_,\n        collateralAsset_,\n        amountIn_,\n        borrowAsset_,\n        _LOAN_PERIOD_IN_BLOCKS\n      );\n\n      uint len = vars.converters.length;\n      if (len > 0) {\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\n          vars.collateral;\n          vars.amountToBorrow;\n          if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\n            // we have exact amount of total collateral amount\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\n            ? amountIn_\n            : vars.collateralsRequired[i];\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\n            ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\n            : vars.amountsToBorrow[i];\n            amountIn_ -= vars.collateral;\n          } else {\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\n            // we have exact amount of total amount-to-borrow\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\n            ? amountIn_\n            : vars.amountsToBorrow[i];\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\n            ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\n            : vars.collateralsRequired[i];\n            amountIn_ -= vars.amountToBorrow;\n          }\n\n          if (amountIn_ < thresholdAmountIn_ && amountIn_ != 0) {\n            // dust amount is left, just leave it unused\n            // we cannot add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\n            amountIn_ = 0;\n          }\n\n          if (vars.amountToBorrow != 0) {\n            borrowedAmountOut += tetuConverter_.borrow(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n            collateralAmountOut += vars.collateral;\n            emit OpenPosition(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n          }\n\n          if (amountIn_ == 0) break;\n        }\n      }\n\n      return (collateralAmountOut, borrowedAmountOut);\n    }\n  }\n\n  /// @notice Open position using entry kind 1 - split provided amount on two parts according provided proportions\n  /// @param amountIn_ Amount of collateral to be divided on parts. We assume {amountIn_} > 0\n  /// @return collateralAmountOut Total collateral used to borrow {borrowedAmountOut}\n  /// @return borrowedAmountOut Total borrowed amount\n  function openPositionEntryKind1(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint collateralThreshold_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    OpenPositionEntryKind1Local memory vars;\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n      entryData_,\n      collateralAsset_,\n      amountIn_,\n      borrowAsset_,\n      _LOAN_PERIOD_IN_BLOCKS\n    );\n\n    uint len = vars.converters.length;\n    if (len > 0) {\n      // we should split amountIn on two amounts with proportions x:y\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\n      // calculate prices conversion ratio using price oracle, decimals 18\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\n\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\n        // and give us required proportions in result\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\n        // C1 is collateral amount left untouched (x)\n        // C2 is collateral amount converted to B2 (y)\n        // but if lending platform doesn't have enough liquidity\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        vars.ratio = (vars.collateralsRequired[i] + vars.c1) > amountIn_\n          ? 1e18 * amountIn_ / (vars.collateralsRequired[i] + vars.c1)\n          : 1e18;\n\n        vars.collateral = vars.collateralsRequired[i] * vars.ratio / 1e18;\n        vars.amountToBorrow = vars.amountsToBorrow[i] * vars.ratio / 1e18;\n\n        // skip any attempts to borrow zero amount or use too little collateral\n        if (vars.collateral < collateralThreshold_ || vars.amountToBorrow == 0) {\n          if (vars.collateralsRequired[i] + vars.c1 + collateralThreshold_ > amountIn_) {\n            // The lending platform has enough resources to make the borrow but amount of the borrow is too low\n            // Skip the borrow, leave leftover of collateral untouched\n            break;\n          } else {\n            // The lending platform doesn't have enough resources to make the borrow.\n            // We should try to make borrow on the next platform (if any)\n            continue;\n          }\n        }\n\n        require(\n          tetuConverter_.borrow(\n            vars.converters[i],\n            collateralAsset_,\n            vars.collateral,\n            borrowAsset_,\n            vars.amountToBorrow,\n            address(this)\n          ) == vars.amountToBorrow,\n          StrategyLib.WRONG_VALUE\n        );\n        emit OpenPosition(\n          vars.converters[i],\n          collateralAsset_,\n          vars.collateral,\n          borrowAsset_,\n          vars.amountToBorrow,\n          address(this)\n        );\n\n        borrowedAmountOut += vars.amountToBorrow;\n        collateralAmountOut += vars.collateral;\n\n        // calculate amount to be borrowed in the next converter\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        amountIn_ = (amountIn_ > vars.c1 + vars.collateral)\n          ? amountIn_ - (vars.c1 + vars.collateral)\n          : 0;\n\n        // protection against dust amounts, see \"openPosition.dust\", just leave dust amount unused\n        // we CAN NOT add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\n        if (amountIn_ < collateralThreshold_ || amountIn_ == 0) break;\n      }\n    }\n\n    return (collateralAmountOut, borrowedAmountOut);\n  }\n\n  /// @notice Get ratio18 = collateral / borrow\n  function _getCollateralToBorrowRatio(\n    ITetuConverter tetuConverter_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) internal view returns (uint){\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle());\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\n    return 1e18 * priceBorrow * 10 ** IERC20Metadata(collateralAsset_).decimals()\n    / priceCollateral / 10 ** IERC20Metadata(borrowAsset_).decimals();\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function _closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) internal returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n\n    // We shouldn't try to pay more than we actually need to repay\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\n    // Let's limit amountToRepay by needToRepay-amount\n    (uint needToRepay,) = tetuConverter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset);\n\n    uint amountRepay = amountToRepay < needToRepay\n    ? amountToRepay\n    : needToRepay;\n\n    // Make full/partial repayment\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\n    IERC20(borrowAsset).safeTransfer(address(tetuConverter_), amountRepay);\n    uint returnedBorrowAmountOut;\n\n    (returnedAssetAmountOut, returnedBorrowAmountOut,,) = tetuConverter_.repay(\n      collateralAsset,\n      borrowAsset,\n      amountRepay,\n      address(this)\n    );\n    emit ClosePosition(\n      collateralAsset,\n      borrowAsset,\n      amountRepay,\n      address(this),\n      returnedAssetAmountOut,\n      returnedBorrowAmountOut\n    );\n    uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\n\n    // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (dust tokens)\n    repaidAmountOut = balanceBefore > balanceAfter\n    ? balanceBefore - balanceAfter\n    : 0;\n\n    require(returnedBorrowAmountOut == 0, StrategyLib.WRONG_VALUE);\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                         Liquidation\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  function liquidate(\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdForTokenOut_\n  ) external returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    return _liquidate(liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdForTokenOut_);\n  }\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  function _liquidate(\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdForTokenOut_\n  ) internal returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\n\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\n\n    // calculate balance in out value for check threshold\n    uint amountOut = liquidator_.getPriceForRoute(route, amountIn_);\n\n    // if the expected value is higher than threshold distribute to destinations\n    if (amountOut > liquidationThresholdForTokenOut_) {\n      // we need to approve each time, liquidator address can be changed in controller\n      AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\n\n      uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\n\n      liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\n\n      // temporary save balance of token out after  liquidation to spentAmountIn\n      uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\n\n      // assign correct values to\n      receivedAmountOut = balanceAfter > balanceBefore\n      ? balanceAfter - balanceBefore\n      : 0;\n      spentAmountIn = amountIn_;\n\n      emit Liquidation(\n        tokenIn_,\n        tokenOut_,\n        amountIn_,\n        spentAmountIn,\n        receivedAmountOut\n      );\n    }\n\n    return (spentAmountIn, receivedAmountOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                 requirePayAmountBack\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Swap available {amounts_} of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\n  /// @param targetAmount_ Required amount of tokens[indexTheAsset_] that should be received by swap(s)\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param indexTargetAsset_ Index of target asset in tokens_ array\n  /// @param underlying_ Index of underlying\n  /// @param withdrawnAmounts_ Amounts withdrawn from the pool\n  /// @param liquidationThresholdForTargetAsset_ Liquidation thresholds for the target asset\n  /// @param overswap_ Allow to swap more then required (i.e. 1_000 => +1%)\n  ///                  to avoid additional swap if the swap return amount a bit less than we expected\n  /// @return spentAmounts Any amounts spent during the swaps\n  /// @return withdrawnAmountsOut withdrawnAmounts + any amounts received during the swaps\n  function swapToGivenAmount(\n    uint targetAmount_,\n    address[] memory tokens_,\n    uint indexTargetAsset_,\n    address underlying_,\n    uint[] memory withdrawnAmounts_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint liquidationThresholdForTargetAsset_,\n    uint overswap_,\n    mapping(address => uint) storage baseAmounts_\n  ) external returns (\n    uint[] memory spentAmounts,\n    uint[] memory withdrawnAmountsOut\n  ) {\n    SwapToGivenAmountLocal memory v;\n    v.len = tokens_.length;\n\n    spentAmounts = new uint[](v.len);\n    withdrawnAmountsOut = new uint[](v.len);\n\n    v.availableAmounts = new uint[](v.len);\n    for (; v.i < v.len; v.i = AppLib.uncheckedInc(v.i)) {\n      v.availableAmounts[v.i] = withdrawnAmounts_[v.i] + baseAmounts_[tokens_[v.i]];\n    }\n    (spentAmounts, v.receivedAmounts) = _swapToGivenAmount(\n      SwapToGivenAmountInputParams({\n        targetAmount: targetAmount_,\n        tokens: tokens_,\n        indexTargetAsset: indexTargetAsset_,\n        underlying: underlying_,\n        amounts: v.availableAmounts,\n        converter: converter_,\n        liquidator: liquidator_,\n        liquidationThresholdForTargetAsset: liquidationThresholdForTargetAsset_,\n        overswap: overswap_\n      })\n    );\n    for (v.i = 0; v.i < v.len; v.i = AppLib.uncheckedInc(v.i)) {\n      withdrawnAmountsOut[v.i] = withdrawnAmounts_[v.i] + v.receivedAmounts[v.i];\n    }\n  }\n\n  /// @notice Swap available {amounts_} of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\n  /// @return spentAmounts Any amounts spent during the swaps\n  /// @return receivedAmounts Any amounts received during the swaps\n  function _swapToGivenAmount(SwapToGivenAmountInputParams memory p) internal returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = p.tokens.length;\n    receivedAmounts = new uint[](v.len);\n    spentAmounts = new uint[](v.len);\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(p.converter.controller()).priceOracle()),\n      p.tokens,\n      v.len\n    );\n\n    // we need to swap other assets to the asset\n    // at first we should swap NOT underlying.\n    // if it would be not enough, we can swap underlying too.\n\n    // swap NOT underlying, initialize {indexUnderlying}\n    uint indexUnderlying;\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (p.underlying == p.tokens[i]) {\n        indexUnderlying = i;\n        continue;\n      }\n      if (p.indexTargetAsset == i) continue;\n\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, i);\n      spentAmounts[i] += spent;\n      receivedAmounts[p.indexTargetAsset] += received;\n\n      if (receivedAmounts[p.indexTargetAsset] >= p.targetAmount) break;\n    }\n\n    // swap underlying\n    if (receivedAmounts[p.indexTargetAsset] < p.targetAmount && p.indexTargetAsset != indexUnderlying) {\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, indexUnderlying);\n      spentAmounts[indexUnderlying] += spent;\n      receivedAmounts[p.indexTargetAsset] += received;\n    }\n  }\n\n  /// @notice Swap a part of amount of asset {tokens[indexTokenIn]} to {targetAsset} to get {targetAmount} in result\n  /// @param receivedTargetAmount Already received amount of {targetAsset} in previous swaps\n  /// @param indexTokenIn Index of the tokenIn in p.tokens\n  function _swapToGetAmount(\n    uint receivedTargetAmount,\n    SwapToGivenAmountInputParams memory p,\n    CalcInvestedAssetsLocal memory v,\n    uint indexTokenIn\n  ) internal returns (\n    uint amountSpent,\n    uint amountReceived\n  ) {\n    if (p.amounts[indexTokenIn] != 0) {\n      // we assume here, that p.targetAmount > receivedTargetAmount, see _swapToGivenAmount implementation\n\n      // calculate amount that should be swapped\n      // {overswap} allows to swap a bit more\n      // to avoid additional swaps if the swap will give us a bit less amount than expected\n      uint amountIn = (\n        (p.targetAmount - receivedTargetAmount)\n        * v.prices[p.indexTargetAsset] * v.decs[indexTokenIn]\n        / v.prices[indexTokenIn] / v.decs[p.indexTargetAsset]\n      ) * (p.overswap + DENOMINATOR) / DENOMINATOR;\n\n      (amountSpent, amountReceived) = _liquidate(\n        p.liquidator,\n        p.tokens[indexTokenIn],\n        p.tokens[p.indexTargetAsset],\n        Math.min(amountIn, p.amounts[indexTokenIn]),\n        _ASSET_LIQUIDATION_SLIPPAGE,\n        p.liquidationThresholdForTargetAsset\n      );\n    }\n\n    return (amountSpent, amountReceived);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      Recycle rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards are immediately \"recycled\".\n  /// It means, they are divided on two parts: to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just added to baseAmounts\n  /// All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder.\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @param liquidationThresholds_ Liquidation thresholds for rewards tokens\n  /// @param baseAmounts_ Base amounts for rewards tokens\n  ///                     The base amounts allow to separate just received and previously received rewards.\n  /// @return receivedAmounts Received amounts of the tokens\n  ///         This array has +1 item at the end: received amount of the main asset\n  ///                                            there was no possibility to use separate var for it, stack too deep\n  /// @return spentAmounts Spent amounts of the tokens\n  /// @return amountsToForward Amounts to be sent to forwarder\n  function recycle(\n    address asset_,\n    uint compoundRatio_,\n    address[] memory tokens_,\n    ITetuLiquidator liquidator_,\n    mapping(address => uint) storage liquidationThresholds_,\n    mapping(address => uint) storage baseAmounts_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_\n  ) external returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    (receivedAmounts, spentAmounts, amountsToForward) = _recycle(\n      asset_,\n      compoundRatio_,\n      tokens_,\n      liquidator_,\n      rewardTokens_,\n      rewardAmounts_,\n      liquidationThresholds_,\n      baseAmounts_\n    );\n  }\n\n  /// @dev Implementation of {recycle}\n  function _recycle(\n    address asset,\n    uint compoundRatio,\n    address[] memory tokens,\n    ITetuLiquidator liquidator,\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    mapping(address => uint) storage liquidationThresholds,\n    mapping(address => uint) storage baseAmounts\n  ) internal returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    RecycleLocalParams memory p;\n\n    p.len = rewardTokens.length;\n    require(p.len == rewardAmounts.length, AppErrors.WRONG_LENGTHS);\n\n    p.liquidationThresholdAsset = liquidationThresholds[asset];\n\n    amountsToForward = new uint[](p.len);\n    receivedAmounts = new uint[](p.len + 1);\n    spentAmounts = new uint[](p.len);\n\n    // split each amount on two parts: a part-to-compound and a part-to-transfer-to-the-forwarder\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      p.rewardToken = rewardTokens[i];\n      p.amountToCompound = rewardAmounts[i] * compoundRatio / COMPOUND_DENOMINATOR;\n\n      if (p.amountToCompound > 0) {\n        if (ConverterStrategyBaseLib.getAssetIndex(tokens, p.rewardToken) != type(uint).max) {\n          // The asset is in the list of depositor's assets, liquidation is not allowed\n          receivedAmounts[i] += p.amountToCompound;\n        } else {\n          p.baseAmountIn = baseAmounts[p.rewardToken];\n          // total amount that can be liquidated\n          p.totalRewardAmounts = p.amountToCompound + p.baseAmountIn;\n\n          if (p.totalRewardAmounts < liquidationThresholds[p.rewardToken]) {\n            // amount is too small, liquidation is not allowed\n            receivedAmounts[i] += p.amountToCompound;\n          } else {\n            // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\n            // We assume here, that {token} cannot be equal to {_asset}\n            // because the {_asset} is always included to the list of depositor's assets\n            (p.spentAmountIn, p.receivedAmountOut) = _liquidate(\n              liquidator,\n              p.rewardToken,\n              asset,\n              p.totalRewardAmounts,\n              _REWARD_LIQUIDATION_SLIPPAGE,\n              p.liquidationThresholdAsset\n            );\n\n            // Adjust amounts after liquidation\n            if (p.receivedAmountOut > 0) {\n              receivedAmounts[p.len] += p.receivedAmountOut;\n            }\n            if (p.spentAmountIn == 0) {\n              receivedAmounts[i] += p.amountToCompound;\n            } else {\n              require(p.spentAmountIn == p.amountToCompound + p.baseAmountIn, StrategyLib.WRONG_VALUE);\n              spentAmounts[i] += p.baseAmountIn;\n            }\n          }\n        }\n      }\n\n      p.amountToForward = rewardAmounts[i] - p.amountToCompound;\n      amountsToForward[i] = p.amountToForward;\n    }\n\n    return (receivedAmounts, spentAmounts, amountsToForward);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      calcInvestedAssets\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return amountOut Invested asset amount under control (in terms of {asset})\n  function calcInvestedAssets(\n    address[] memory tokens,\n    uint[] memory amountsOut,\n    uint indexAsset,\n    ITetuConverter converter_,\n    mapping(address => uint) storage baseAmounts\n  ) external returns (\n    uint amountOut\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = tokens.length;\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\n      tokens,\n      v.len\n    );\n\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\n        amountOut += amountsOut[i];\n      } else {\n        // available amount to repay\n        uint toRepay = baseAmounts[tokens[i]] + amountsOut[i];\n\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(address(this), tokens[indexAsset], tokens[i]);\n        amountOut += collateral;\n        if (toRepay >= toPay) {\n          amountOut += (toRepay - toPay) * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        } else {\n          // there is not enough amount to pay the debt\n          // let's register a debt and try to resolve it later below\n          if (v.debts.length == 0) {\n            // lazy initialization\n            v.debts = new uint[](v.len);\n          }\n          // to pay the following amount we need to swap some other asset at first\n          v.debts[i] = toPay - toRepay;\n        }\n      }\n    }\n\n    if (v.debts.length == v.len) {\n      // we assume here, that it would be always profitable to save collateral\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n        if (v.debts[i] == 0) continue;\n\n        // estimatedAssets should be reduced on the debt-value\n        uint debtInAsset = v.debts[i] * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        if (debtInAsset > amountOut) {\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\n          amountOut = 0;\n        } else {\n          amountOut -= debtInAsset;\n        }\n      }\n    }\n\n    return amountOut;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      getExpectedAmountMainAsset\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate expected amount of the main asset after withdrawing\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\n  /// @return amountOut Expected amount of the main asset\n  function getExpectedAmountMainAsset(\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint[] memory withdrawnAmounts_,\n    uint[] memory amountsToConvert_\n  ) internal returns (\n    uint amountOut\n  ) {\n    uint len = tokens.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        amountOut += withdrawnAmounts_[i];\n      } else {\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\n        if (amount != 0) {\n          amountOut += converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\n        }\n      }\n    }\n\n    return amountOut;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///              Reduce size of ConverterStrategyBase\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Make borrow and save amounts of tokens available for deposit to tokenAmounts\n  /// @param thresholdMainAsset_ Min allowed value of collateral in terms of main asset, 0 - use default min value\n  /// @return tokenAmountsOut Amounts available for deposit\n  /// @return borrowedAmounts Amounts borrowed for {spendCollateral}\n  /// @return spentCollateral Total collateral amount spent for borrowing\n  function getTokenAmounts(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory collaterals_,\n    uint thresholdMainAsset_,\n    mapping(address => uint) storage baseAmounts_\n  ) external returns (\n    uint[] memory tokenAmountsOut,\n    uint[] memory borrowedAmounts,\n    uint spentCollateral\n  ) {\n    // content of tokenAmounts will be modified in place\n    uint len = tokens_.length;\n    borrowedAmounts = new uint[](len);\n    tokenAmountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset_) {\n        tokenAmountsOut[i] = collaterals_[i];\n      } else {\n        if (collaterals_[i] > 0) {\n          uint collateral;\n          AppLib.approveIfNeeded(tokens_[indexAsset_], collaterals_[i], address(tetuConverter_));\n          (collateral, borrowedAmounts[i]) = _openPosition(\n            tetuConverter_,\n            \"\", // entry kind = 0: fixed collateral amount, max possible borrow amount\n            tokens_[indexAsset_],\n            tokens_[i],\n            collaterals_[i],\n            thresholdMainAsset_\n          );\n          // collateral should be equal to tokenAmounts[i] here because we use default entry kind\n          spentCollateral += collateral;\n\n          // zero amount are possible (conversion is not available) but it's not suitable for depositor\n          require(borrowedAmounts[i] != 0, AppErrors.ZERO_AMOUNT_BORROWED);\n        }\n        tokenAmountsOut[i] = baseAmounts_[tokens_[i]] + borrowedAmounts[i];\n      }\n    }\n\n    return (tokenAmountsOut, borrowedAmounts, spentCollateral);\n  }\n\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\n  /// @dev The post-processing is rewards conversion to the main asset\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens_ List of rewards claimed from the internal pool\n  /// @param rewardTokens_ Amounts of rewards claimed from the internal pool\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\n  /// @param amountsOut Amounts of available rewards\n  function prepareRewardsList(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_,\n    mapping(address => uint) storage baseAmounts_\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    // Rewards from TetuConverter\n    (address[] memory tokensTC, uint[] memory amountsTC) = tetuConverter_.claimRewards(address(this));\n\n    // Join arrays and recycle tokens\n    (tokensOut, amountsOut) = TokenAmountsLib.combineArrays(\n      rewardTokens_, rewardAmounts_,\n      tokensTC, amountsTC,\n      // by default, depositor assets have zero amounts here .. but probably they have airdrops (see below)\n      tokens_, new uint[](tokens_.length)\n    );\n\n    // Add airdrops\n    uint len = tokensOut.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      amountsOut[i] = IERC20(tokensOut[i]).balanceOf(address(this)) - baseAmounts_[tokensOut[i]];\n    }\n\n    // filter zero amounts out\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       WITHDRAW HELPERS\n  /////////////////////////////////////////////////////////////////////\n\n  function postWithdrawActions(\n    uint[] memory reserves,\n    uint depositorLiquidity,\n    uint liquidityAmount,\n    uint totalSupply,\n    uint[] memory amountsToConvert,\n\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n\n    uint _depositorLiquidityNew,\n    uint[] memory withdrawnAmounts\n  ) external returns (uint _expectedAmountMainAsset, uint[] memory _amountsToConvert){\n\n    // estimate, how many assets should be withdrawn\n    // the depositor is able to use less liquidity than it was asked\n    // (i.e. Balancer-depositor leaves some BPT unused)\n    // so, we need to fix liquidityAmount on this amount\n\n    // we assume here, that liquidity cannot increase in _depositorExit\n    uint depositorLiquidityDelta = depositorLiquidity - _depositorLiquidityNew;\n    if (liquidityAmount > depositorLiquidityDelta) {\n      liquidityAmount = depositorLiquidityDelta;\n    }\n\n    // now we can estimate expected amount of assets to be withdrawn\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\n      reserves,\n      liquidityAmount,\n      totalSupply\n    );\n\n    uint expectedAmountMainAsset = getExpectedAmountMainAsset(\n      tokens,\n      indexAsset,\n      converter,\n      expectedWithdrawAmounts,\n      amountsToConvert\n    );\n    for (uint i; i < tokens.length; i = AppLib.uncheckedInc(i)) {\n      amountsToConvert[i] += withdrawnAmounts[i];\n    }\n\n    return (expectedAmountMainAsset, amountsToConvert);\n  }\n\n  function postWithdrawActionsEmpty(\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint[] memory withdrawnAmounts_,\n    uint[] memory amountsToConvert_\n  ) external returns (uint[] memory withdrawnAmounts, uint expectedAmountMainAsset){\n    withdrawnAmounts = withdrawnAmounts_;\n    expectedAmountMainAsset = getExpectedAmountMainAsset(\n      tokens,\n      indexAsset,\n      converter,\n      withdrawnAmounts_,\n      amountsToConvert_\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      convertAfterWithdraw\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Convert {p.amountsToConvert_} to the main asset\n  /// @return collateralOut Total amount of collateral returned after closing positions\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\n  function convertAfterWithdraw(\n    ITetuConverter tetuConverter,\n    ITetuLiquidator liquidator,\n    uint liquidationThreshold,\n    address[] memory tokens,\n    uint indexAsset,\n    uint[] memory amountsToConvert\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    ConvertAfterWithdrawLocalParams memory vars;\n    vars.asset = tokens[indexAsset];\n\n    uint len = tokens.length;\n    repaidAmountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n      (vars.collateral, repaidAmountsOut[i]) = _closePosition(\n        tetuConverter,\n        vars.asset,\n        tokens[i],\n        amountsToConvert[i]\n      );\n      collateralOut += vars.collateral;\n    }\n\n    // Manually swap remain leftovers\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n      if (amountsToConvert[i] > repaidAmountsOut[i]) {\n        (vars.spentAmountIn, vars.receivedAmountOut) = _liquidate(\n          liquidator,\n          tokens[i],\n          vars.asset,\n          amountsToConvert[i] - repaidAmountsOut[i],\n          _ASSET_LIQUIDATION_SLIPPAGE,\n          liquidationThreshold\n        );\n        if (vars.receivedAmountOut != 0) {\n          collateralOut += vars.receivedAmountOut;\n        }\n        if (vars.spentAmountIn != 0) {\n          repaidAmountsOut[i] += vars.spentAmountIn;\n          require(\n            tetuConverter.isConversionValid(\n              tokens[i],\n              vars.spentAmountIn,\n              vars.asset,\n              vars.receivedAmountOut,\n              PRICE_IMPACT_TOLERANCE\n            ),\n            AppErrors.PRICE_IMPACT\n          );\n        }\n      }\n    }\n\n    return (collateralOut, repaidAmountsOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       OTHER HELPERS\n  /////////////////////////////////////////////////////////////////////\n\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\n    return IPriceOracle(IConverterController(converter.controller()).priceOracle()).getAssetPrice(token);\n  }\n\n  function registerIncome(\n    uint assetBefore,\n    uint assetAfter,\n    uint earned,\n    uint lost\n  ) internal pure returns (uint _earned, uint _lost) {\n    if (assetAfter > assetBefore) {\n      earned += assetAfter - assetBefore;\n    } else {\n      lost += assetBefore - assetAfter;\n    }\n    return (earned, lost);\n  }\n\n}\n\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppLib.sol\";\nimport \"../libs/TokenAmountsLib.sol\";\nimport \"../libs/ConverterEntryKinds.sol\";\n\n/// @notice Continuation of ConverterStrategyBaseLib (workaround for size limits)\nlibrary ConverterStrategyBaseLib2 {\n  using SafeERC20 for IERC20;\n  uint internal constant DENOMINATOR = 100_000;\n\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\n  function getAvailableBalances(\n    address[] memory tokens_,\n    uint indexAsset\n  ) external view returns (uint[] memory) {\n    uint len = tokens_.length;\n    uint[] memory amountsToConvert = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this)); // todo baseAmounts??\n    }\n    return amountsToConvert;\n  }\n  /// @notice Send {performanceFee_} of {rewardAmounts_} to {performanceReceiver}\n  /// @param performanceFee_ Max is FEE_DENOMINATOR\n  /// @return rewardAmounts = rewardAmounts_ - performanceAmounts\n  /// @return performanceAmounts Theses amounts were sent to {performanceReceiver_}\n  function sendPerformanceFee(\n    uint performanceFee_,\n    address performanceReceiver_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_\n  ) external returns (\n    uint[] memory rewardAmounts,\n    uint[] memory performanceAmounts\n  ) {\n    // we assume that performanceFee_ <= FEE_DENOMINATOR and we don't need to check it here\n    uint len = rewardAmounts_.length;\n    rewardAmounts = new uint[](len);\n    performanceAmounts = new uint[](len);\n\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\n      performanceAmounts[i] = rewardAmounts_[i] * performanceFee_ / DENOMINATOR;\n      rewardAmounts[i] = rewardAmounts_[i] - performanceAmounts[i];\n      IERC20(rewardTokens_[i]).safeTransfer(performanceReceiver_, performanceAmounts[i]);\n    }\n  }\n\n  function sendTokensToForwarder(\n    address controller_,\n    address splitter_,\n    address[] memory tokens_,\n    uint[] memory amounts_\n  ) external {\n    uint len = tokens_.length;\n    IForwarder forwarder = IForwarder(IController(controller_).forwarder());\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      AppLib.approveIfNeeded(tokens_[i], amounts_[i], address(forwarder));\n    }\n\n    forwarder.registerIncome(tokens_, amounts_, ISplitter(splitter_).vault(), true);\n  }\n}\n\n"
    },
    "contracts/strategies/DepositorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../helpers/ERC20Helpers.sol\";\n\n/// @title Abstract base Depositor contract.\n/// @notice Converter strategies should inherit xDepositor.\n/// @notice All communication with external pools should be done at inherited contract\n/// @author bogdoslav\nabstract contract DepositorBase is ERC20Helpers {\n\n  /// @notice Returns pool assets\n  function _depositorPoolAssets() internal virtual view returns (address[] memory assets);\n\n  /// @notice Returns pool token proportions\n  function _depositorPoolWeights() internal virtual view returns (uint[] memory weights, uint total);\n\n  /// @notice Returns pool token reserves\n  function _depositorPoolReserves() internal virtual view returns (uint[] memory reserves);\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() internal virtual view returns (uint);\n\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() internal view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @dev Depositor must care about tokens approval by itself.\n  function _depositorEnter(uint[] memory amountsDesired_) internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  );\n\n  /// @notice Withdraw given lp amount from the pool.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @notice Quotes output for given lp amount from the pool.\n  /// @dev Write function with read-only behavior. BalanceR's depositor requires not-view.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorQuoteExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @dev If pool supports emergency withdraw need to call it for emergencyExit()\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorEmergencyExit() internal virtual returns (uint[] memory amountsOut) {\n    return _depositorExit(_depositorLiquidity());\n  }\n\n  /// @notice Claim all possible rewards.\n  function _depositorClaimRewards() internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts\n  );\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3ConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./UniswapV3Depositor.sol\";\nimport \"./UniswapV3ConverterStrategyLogicLib.sol\";\nimport \"../../libs/AppPlatforms.sol\";\n\n/// @title Delta-neutral liquidity hedging converter fill-up/swap rebalancing strategy for UniswapV3\n/// @notice This strategy provides delta-neutral liquidity hedging for Uniswap V3 pools. It rebalances the liquidity\n///         by utilizing fill-up and swap methods depending on the range size of the liquidity provided.\n///         It also attempts to cover rebalancing losses with rewards.\n/// @author a17\ncontract UniswapV3ConverterStrategy is UniswapV3Depositor, ConverterStrategyBase {\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  string public constant override NAME = \"UniswapV3 Converter Strategy\";\n  string public constant override PLATFORM = AppPlatforms.UNIV3;\n  string public constant override STRATEGY_VERSION = \"1.1.0\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                INIT\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize the strategy with the given parameters.\n  /// @param controller_ The address of the controller.\n  /// @param splitter_ The address of the splitter.\n  /// @param converter_ The address of the converter.\n  /// @param pool_ The address of the pool.\n  /// @param tickRange_ The tick range for the liquidity position.\n  /// @param rebalanceTickRange_ The tick range for rebalancing.\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address pool_,\n    int24 tickRange_,\n    int24 rebalanceTickRange_\n  ) external initializer {\n    __UniswapV3Depositor_init(ISplitter(splitter_).asset(), pool_, tickRange_, rebalanceTickRange_);\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n    UniswapV3ConverterStrategyLogicLib.initStrategyState(state, controller_, converter_);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                OPERATOR ACTIONS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Disable fuse for the strategy.\n  function disableFuse() external {\n    StrategyLib.onlyOperators(controller());\n    state.isFuseTriggered = false;\n\n    UniswapV3ConverterStrategyLogicLib.emitDisableFuse();\n  }\n\n  /// @notice Set the fuse threshold for the strategy.\n  /// @param newFuseThreshold The new fuse threshold value.\n  function setFuseThreshold(uint newFuseThreshold) external {\n    StrategyLib.onlyOperators(controller());\n    state.fuseThreshold = newFuseThreshold;\n\n    UniswapV3ConverterStrategyLogicLib.emitNewFuseThreshold(newFuseThreshold);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   METRIC VIEWS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Check if the strategy is ready for hard work.\n  /// @return A boolean indicating if the strategy is ready for hard work.\n  function isReadyToHardWork() override external virtual view returns (bool) {\n    return UniswapV3ConverterStrategyLogicLib.isReadyToHardWork(state, converter);\n  }\n\n  /// @notice Check if the strategy needs rebalancing.\n  /// @return A boolean indicating if the strategy needs rebalancing.\n  function needRebalance() external view returns (bool) {\n    return UniswapV3ConverterStrategyLogicLib.needRebalance(\n      state.isFuseTriggered,\n      state.pool,\n      state.lowerTick,\n      state.upperTick,\n      state.tickSpacing,\n      state.rebalanceTickRange\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   REBALANCE\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev The rebalancing functionality is the core of this strategy.\n  ///      Depending on the size of the range of liquidity provided, the Fill-up or Swap method is used.\n  ///      There is also an attempt to cover rebalancing losses with rewards.\n  function rebalance() external {\n    address _controller = controller();\n    StrategyLib.onlyOperators(_controller);\n\n    /// @dev withdraw all liquidity from pool with adding calculated fees to rebalanceEarned0, rebalanceEarned1\n    _depositorEmergencyExit();\n\n    (\n    uint[] memory tokenAmounts, // _depositorEnter(tokenAmounts) if length == 2\n    bool isNeedFillup\n    ) = UniswapV3ConverterStrategyLogicLib.rebalance(\n      state,\n      converter,\n      _controller,\n      investedAssets()\n    );\n\n    if (tokenAmounts.length == 2) {\n      _depositorEnter(tokenAmounts);\n\n      //add fill-up liquidity part of fill-up is used\n      if (isNeedFillup) {\n        (state.lowerTickFillup, state.upperTickFillup, state.totalLiquidityFillup) = UniswapV3ConverterStrategyLogicLib.addFillup(\n          state.pool,\n          state.lowerTick,\n          state.upperTick,\n          state.tickSpacing,\n          state.rebalanceEarned0,\n          state.rebalanceEarned1\n        );\n      }\n    }\n\n    (\n    uint receivedA,\n    uint spentA,\n    uint receivedB,\n    uint spentB\n    ) = UniswapV3ConverterStrategyLogicLib.getUpdateInfo(state, baseAmounts);\n\n    _updateBaseAmountsForAsset(\n      state.tokenA,\n      receivedA,\n      spentA\n    );\n    _updateBaseAmountsForAsset(\n      state.tokenB,\n      receivedB,\n      spentB\n    );\n\n    //updating investedAssets based on new baseAmounts\n    _updateInvestedAssets();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   INTERNAL LOGIC\n  /////////////////////////////////////////////////////////////////////\n\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory /*tokens_*/,\n    uint /*indexAsset_*/\n  ) override internal virtual returns (\n    uint[] memory tokenAmounts,\n    uint[] memory borrowedAmounts,\n    uint spentCollateral\n  ) {\n    tokenAmounts = new uint[](2);\n    borrowedAmounts = new uint[](2);\n\n    bytes memory entryData = UniswapV3ConverterStrategyLogicLib.getEntryData(\n      state.pool,\n      state.lowerTick,\n      state.upperTick,\n      state.tickSpacing,\n      state.depositorSwapTokens\n    );\n\n    AppLib.approveIfNeeded(state.tokenA, amount_, address(tetuConverter_));\n    (spentCollateral, borrowedAmounts[1]) = ConverterStrategyBaseLib.openPosition(\n      tetuConverter_,\n      entryData,\n      state.tokenA,\n      state.tokenB,\n      amount_,\n      0\n    );\n\n    tokenAmounts[0] = amount_ - spentCollateral;\n    tokenAmounts[1] = borrowedAmounts[1];\n\n    return (tokenAmounts, borrowedAmounts, spentCollateral);\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  /// @return earned The amount of earned rewards.\n  /// @return lost The amount of lost rewards.\n  /// @return assetBalanceAfterClaim The asset balance after claiming rewards.\n  function _handleRewards() override internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    earned = UniswapV3ConverterStrategyLogicLib.calcEarned(state);\n    _claim();\n    assetBalanceAfterClaim = _balance(asset);\n    if (state.rebalanceLost > 0) {\n      lost = state.rebalanceLost;\n      state.rebalanceLost = 0;\n    }\n    return (earned, lost, assetBalanceAfterClaim);\n  }\n\n  /// @notice Withdraw given amount from the pool.\n  /// @param amount Amount to be withdrawn in terms of the asset.\n  /// @return investedAssetsUSD The value that we should receive after withdrawing (in USD, decimals of the {asset})\n  /// @return assetPrice Price of the {asset} from the price oracle\n  /// @return totalAssetsDelta The {strategy} updates its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawFromPool(uint amount) override internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(true);\n    require(updatedInvestedAssets != 0, AppErrors.NO_INVESTMENTS);\n    (investedAssetsUSD, assetPrice) = _withdrawUniversal(amount, false, updatedInvestedAssets);\n  }\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amount_ The amount to be deposited.\n  /// @param updateTotalAssetsBeforeInvest_ A boolean indicating if the total assets should be updated before investing.\n  /// @return totalAssetsDelta The change in total assets after the deposit.\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    int totalAssetsDelta\n  ) {\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(updateTotalAssetsBeforeInvest_);\n\n    // skip deposit for small amounts\n    if (amount_ > reinvestThresholdPercent * updatedInvestedAssets / REINVEST_THRESHOLD_DENOMINATOR) {\n      if (state.isFuseTriggered) {\n        uint[] memory tokenAmounts = new uint[](2);\n        tokenAmounts[0] = amount_;\n        emit OnDepositorEnter(tokenAmounts, tokenAmounts);\n        _updateBaseAmountsForAsset(state.tokenA, amount_, 0);\n      } else {\n        (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n\n        // prepare array of amounts ready to deposit, borrow missed amounts\n        (uint[] memory amounts, uint[] memory borrowedAmounts, uint collateral) = _beforeDeposit(\n          converter,\n          amount_,\n          tokens,\n          indexAsset\n        );\n\n        // make deposit, actually consumed amounts can be different from the desired amounts\n        (uint[] memory consumedAmounts,) = _depositorEnter(amounts);\n        emit OnDepositorEnter(amounts, consumedAmounts);\n\n        // adjust base-amounts\n        _updateBaseAmounts(tokens, borrowedAmounts, consumedAmounts, indexAsset, - int(collateral));\n      }\n\n      // adjust _investedAssets\n      _updateInvestedAssets();\n    }\n  }\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3ConverterStrategyLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./UniswapV3Lib.sol\";\nimport \"./UniswapV3DebtLib.sol\";\n\nlibrary UniswapV3ConverterStrategyLogicLib {\n\n  //////////////////////////////////////////\n  //            CONSTANTS\n  //////////////////////////////////////////\n\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_STABLE = 100;\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE = 500;\n  uint internal constant HARD_WORK_USD_FEE_THRESHOLD = 100;\n  uint public constant DEFAULT_FUSE_THRESHOLD = 5e15;\n\n  //////////////////////////////////////////\n  //            EVENTS\n  //////////////////////////////////////////\n\n  event FuseTriggered();\n  event Rebalanced();\n  event DisableFuse();\n  event NewFuseThreshold(uint newFuseThreshold);\n\n  //////////////////////////////////////////\n  //            STRUCTURES\n  //////////////////////////////////////////\n\n  struct State {\n    address tokenA;\n    address tokenB;\n    IUniswapV3Pool pool;\n    int24 tickSpacing;\n    bool fillUp;\n    bool isStablePool;\n    int24 lowerTick;\n    int24 upperTick;\n    int24 lowerTickFillup;\n    int24 upperTickFillup;\n    int24 rebalanceTickRange;\n    bool depositorSwapTokens;\n    uint128 totalLiquidity;\n    uint128 totalLiquidityFillup;\n    uint rebalanceEarned0;\n    uint rebalanceEarned1;\n    uint rebalanceLost;\n    bool isFuseTriggered;\n    uint fuseThreshold;\n    uint lastPrice;\n  }\n\n  struct TryCoverLossParams {\n    IUniswapV3Pool pool;\n    address tokenA;\n    address tokenB;\n    bool depositorSwapTokens;\n    uint fee0;\n    uint fee1;\n    uint oldInvestedAssets;\n  }\n\n  struct RebalanceLocalVariables {\n    int24 upperTick;\n    int24 lowerTick;\n    int24 tickSpacing;\n    IUniswapV3Pool pool;\n    address tokenA;\n    address tokenB;\n    uint lastPrice;\n    uint fuseThreshold;\n    bool depositorSwapTokens;\n    uint rebalanceEarned0;\n    uint rebalanceEarned1;\n\n    uint newRebalanceEarned0;\n    uint newRebalanceEarned1;\n    uint notCoveredLoss;\n    int24 newLowerTick;\n    int24 newUpperTick;\n\n    bool fillUp;\n    bool isStablePool;\n    uint newPrice;\n  }\n\n  //////////////////////////////////////////\n  //            HELPERS\n  //////////////////////////////////////////\n\n  function emitDisableFuse() external {\n    emit DisableFuse();\n  }\n\n  function emitNewFuseThreshold(uint value) external {\n    emit NewFuseThreshold(value);\n  }\n\n  /// @dev Gets the liquidator swap slippage based on the pool type (stable or volatile).\n  /// @param pool The IUniswapV3Pool instance.\n  /// @return The liquidator swap slippage percentage.\n  function _getLiquidatorSwapSlippage(IUniswapV3Pool pool) internal view returns (uint) {\n    return isStablePool(pool) ? LIQUIDATOR_SWAP_SLIPPAGE_STABLE : LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE;\n  }\n\n  /// @notice Get the balance of the given token held by the contract.\n  /// @param token The token address.\n  /// @return The balance of the token.\n  function _balance(address token) internal view returns (uint) {\n    return IERC20(token).balanceOf(address(this));\n  }\n\n  /// @notice Check if the given pool is a stable pool.\n  /// @param pool The Uniswap V3 pool.\n  /// @return A boolean indicating if the pool is stable.\n  function isStablePool(IUniswapV3Pool pool) public view returns (bool) {\n    return pool.fee() == 100;\n  }\n\n  /// @notice Get the token amounts held by the contract excluding earned parts.\n  /// @param state The state of the pool.\n  /// @return amountA The balance of tokenA.\n  /// @return amountB The balance of tokenB.\n  function getTokenAmounts(State storage state) external view returns (uint amountA, uint amountB) {\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    amountA = _balance(state.tokenA);\n    amountB = _balance(state.tokenB);\n\n    uint earned0 = (depositorSwapTokens ? state.rebalanceEarned1 : state.rebalanceEarned0);\n    uint earned1 = (depositorSwapTokens ? state.rebalanceEarned0 : state.rebalanceEarned1);\n\n    require(amountA >= earned0 && amountB >= earned1, \"Wrong balance\");\n    amountA -= earned0;\n    amountB -= earned1;\n  }\n\n  /// @notice Get the price ratio of the two given tokens from the oracle.\n  /// @param converter The Tetu converter.\n  /// @param tokenA The first token address.\n  /// @param tokenB The second token address.\n  /// @return The price ratio of the two tokens.\n  function getOracleAssetsPrice(ITetuConverter converter, address tokenA, address tokenB) public view returns (uint) {\n    IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n    uint priceA = oracle.getAssetPrice(tokenA);\n    uint priceB = oracle.getAssetPrice(tokenB);\n    return priceB * 1e18 / priceA;\n  }\n\n  /// @notice Check if the fuse is enabled based on the price difference and fuse threshold.\n  /// @param oldPrice The old price.\n  /// @param newPrice The new price.\n  /// @param fuseThreshold The fuse threshold.\n  /// @return A boolean indicating if the fuse is enabled.\n  function isEnableFuse(uint oldPrice, uint newPrice, uint fuseThreshold) internal pure returns (bool) {\n    return oldPrice > newPrice ? (oldPrice - newPrice) > fuseThreshold : (newPrice - oldPrice) > fuseThreshold;\n  }\n\n  /// @dev Gets the update information for the strategy, including token amounts received and spent.\n  /// @param state The State storage object.\n  /// @param baseAmounts Mapping of token addresses to their base amounts on the strategy balance (not rewards).\n  /// @return receivedA The amount of tokenA received.\n  /// @return spentA The amount of tokenA spent.\n  /// @return receivedB The amount of tokenB received.\n  /// @return spentB The amount of tokenB spent.\n  function getUpdateInfo(State storage state, mapping(address => uint) storage baseAmounts) external view returns (\n    uint receivedA,\n    uint spentA,\n    uint receivedB,\n    uint spentB\n  ){\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    //updating baseAmounts (token amounts on strategy balance which are not rewards)\n    uint balanceOfTokenABefore = baseAmounts[tokenA];\n    uint balanceOfTokenBBefore = baseAmounts[tokenB];\n    uint balanceOfTokenAAfter = _balance(tokenA) - (depositorSwapTokens ? state.rebalanceEarned1 : state.rebalanceEarned0);\n    uint balanceOfTokenBAfter = _balance(tokenB) - (depositorSwapTokens ? state.rebalanceEarned0 : state.rebalanceEarned1);\n\n    receivedA = balanceOfTokenABefore > balanceOfTokenAAfter ? 0 : balanceOfTokenAAfter - balanceOfTokenABefore;\n    spentA = balanceOfTokenABefore > balanceOfTokenAAfter ? balanceOfTokenABefore - balanceOfTokenAAfter : 0;\n    receivedB = balanceOfTokenBBefore > balanceOfTokenBAfter ? 0 : balanceOfTokenBAfter - balanceOfTokenBBefore;\n    spentB = balanceOfTokenBBefore > balanceOfTokenBAfter ? balanceOfTokenBBefore - balanceOfTokenBAfter : 0;\n  }\n\n  function initStrategyState(State storage state, address controller_, address converter) external {\n    address liquidator = IController(controller_).liquidator();\n    IERC20(state.tokenA).approve(liquidator, type(uint).max);\n    IERC20(state.tokenB).approve(liquidator, type(uint).max);\n\n    /// for ultra-wide ranges we use Swap rebalancing strategy and Fill-up for other\n    /// upperTick always greater then lowerTick\n    state.fillUp = state.upperTick - state.lowerTick >= 4 * state.tickSpacing;\n\n    if (isStablePool(state.pool)) {\n      /// for stable pools fuse can be enabled\n      state.isStablePool = true;\n      // 0.5% price change\n      state.fuseThreshold = DEFAULT_FUSE_THRESHOLD;\n      emit NewFuseThreshold(DEFAULT_FUSE_THRESHOLD);\n      state.lastPrice = getOracleAssetsPrice(ITetuConverter(converter), state.tokenA, state.tokenB);\n    }\n  }\n\n  //////////////////////////////////////////\n  //            CALCULATIONS\n  //////////////////////////////////////////\n\n  /// @notice Calculate the initial values for a Uniswap V3 pool Depositor.\n  /// @param pool The Uniswap V3 pool to get the initial values from.\n  /// @param tickRange_ The tick range for the pool.\n  /// @param rebalanceTickRange_ The rebalance tick range for the pool.\n  /// @param asset_ Underlying asset of the depositor.\n  /// @return tickSpacing The tick spacing for the pool.\n  /// @return lowerTick The lower tick value for the pool.\n  /// @return upperTick The upper tick value for the pool.\n  /// @return tokenA The address of the first token in the pool.\n  /// @return tokenB The address of the second token in the pool.\n  /// @return _depositorSwapTokens A boolean representing whether to use reverse tokens for pool.\n  function calcInitialDepositorValues(\n    IUniswapV3Pool pool,\n    int24 tickRange_,\n    int24 rebalanceTickRange_,\n    address asset_\n  ) external view returns (\n    int24 tickSpacing,\n    int24 lowerTick,\n    int24 upperTick,\n    address tokenA,\n    address tokenB,\n    bool _depositorSwapTokens\n  ) {\n    tickSpacing = UniswapV3Lib.getTickSpacing(pool.fee());\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (tickRange_ == 0) {\n      lowerTick = tick / tickSpacing * tickSpacing;\n      upperTick = lowerTick + tickSpacing;\n    } else {\n      require(tickRange_ == tickRange_ / tickSpacing * tickSpacing, 'Incorrect tickRange');\n      require(rebalanceTickRange_ == rebalanceTickRange_ / tickSpacing * tickSpacing, 'Incorrect rebalanceTickRange');\n      lowerTick = (tick - tickRange_) / tickSpacing * tickSpacing;\n      upperTick = (tick + tickRange_) / tickSpacing * tickSpacing;\n    }\n    require(asset_ == pool.token0() || asset_ == pool.token1(), 'Incorrect asset');\n    if (asset_ == pool.token0()) {\n      tokenA = pool.token0();\n      tokenB = pool.token1();\n      _depositorSwapTokens = false;\n    } else {\n      tokenA = pool.token1();\n      tokenB = pool.token0();\n      _depositorSwapTokens = true;\n    }\n  }\n\n  /// @notice Calculate the new tick range for a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool to calculate the new tick range for.\n  /// @param lowerTick The current lower tick value for the pool.\n  /// @param upperTick The current upper tick value for the pool.\n  /// @param tickSpacing The tick spacing for the pool.\n  /// @return lowerTickNew The new lower tick value for the pool.\n  /// @return upperTickNew The new upper tick value for the pool.\n  function _calcNewTickRange(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing\n  ) internal view returns (int24 lowerTickNew, int24 upperTickNew) {\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (upperTick - lowerTick == tickSpacing) {\n      lowerTickNew = tick / tickSpacing * tickSpacing;\n      upperTickNew = lowerTickNew + tickSpacing;\n    } else {\n      int24 halfRange = (upperTick - lowerTick) / 2;\n      lowerTickNew = (tick - halfRange) / tickSpacing * tickSpacing;\n      upperTickNew = (tick + halfRange) / tickSpacing * tickSpacing;\n    }\n  }\n\n  /// @dev Calculates the new fee amounts and the not covered loss, if any, after attempting to cover losses.\n  /// @param p The TryCoverLossParams instance containing required parameters.\n  /// @param collateralAmount The current collateral amount.\n  /// @return newFee0 The new fee amount for tokenA.\n  /// @return newFee1 The new fee amount for tokenB.\n  /// @return notCoveredLoss The amount of loss that could not be covered by fees.\n  function _calculateCoverLoss(\n    TryCoverLossParams memory p,\n    uint collateralAmount\n  ) internal view returns (uint newFee0, uint newFee1, uint notCoveredLoss) {\n    notCoveredLoss = 0;\n\n    newFee0 = p.fee0;\n    newFee1 = p.fee1;\n    uint feeA = p.depositorSwapTokens ? newFee1 : newFee0;\n    uint feeB = p.depositorSwapTokens ? newFee0 : newFee1;\n\n    uint newInvestedAssets = collateralAmount + _balance(p.tokenA) - feeA;\n    if (newInvestedAssets < p.oldInvestedAssets) {\n      // we have lost\n      uint lost = p.oldInvestedAssets - newInvestedAssets;\n\n      if (lost <= feeA) {\n        // feeA is enough to cover lost\n        if (p.depositorSwapTokens) {\n          newFee1 -= lost;\n        } else {\n          newFee0 -= lost;\n        }\n      } else {\n        // feeA is not enough to cover lost\n\n        if (p.depositorSwapTokens) {\n          newFee1 = 0;\n        } else {\n          newFee0 = 0;\n        }\n\n        uint feeBinTermOfA;\n        if (feeB > 0) {\n\n          feeBinTermOfA = UniswapV3Lib.getPrice(address(p.pool), p.tokenB) * feeB / 10 ** IERC20Metadata(p.tokenB).decimals();\n\n          if (feeA + feeBinTermOfA > lost) {\n            if (p.depositorSwapTokens) {\n              newFee0 = (feeA + feeBinTermOfA - lost) * UniswapV3Lib.getPrice(address(p.pool), p.tokenA) / 10 ** IERC20Metadata(p.tokenA).decimals();\n            } else {\n              newFee1 = (feeA + feeBinTermOfA - lost) * UniswapV3Lib.getPrice(address(p.pool), p.tokenA) / 10 ** IERC20Metadata(p.tokenA).decimals();\n            }\n          } else {\n            notCoveredLoss = lost - feeA - feeBinTermOfA;\n            if (p.depositorSwapTokens) {\n              newFee0 = 0;\n            } else {\n              newFee1 = 0;\n            }\n          }\n        } else {\n          notCoveredLoss = lost - feeA;\n        }\n      }\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Pool info\n  //////////////////////////////////////////\n\n  /// @notice Retrieve the reserves of a Uniswap V3 pool managed by this contract.\n  /// @param state The State storage containing the pool's information.\n  /// @return reserves An array containing the reserve amounts of the contract owned liquidity.\n  function getPoolReserves(State storage state) external view returns (uint[] memory reserves) {\n    reserves = new uint[](2);\n    (uint160 sqrtRatioX96, , , , , ,) = state.pool.slot0();\n\n    (reserves[0], reserves[1]) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTick,\n      state.upperTick,\n      state.totalLiquidity\n    );\n\n    (uint amount0CurrentFillup, uint amount1CurrentFillup) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTickFillup,\n      state.upperTickFillup,\n      state.totalLiquidityFillup\n    );\n\n    (uint fee0, uint fee1) = getFees(state);\n\n    reserves[0] += amount0CurrentFillup + fee0 + _balance(state.pool.token0());\n    reserves[1] += amount1CurrentFillup + fee1 + _balance(state.pool.token1());\n\n    if (state.depositorSwapTokens) {\n      (reserves[0], reserves[1]) = (reserves[1], reserves[0]);\n    }\n  }\n\n  /// @notice Retrieve the fees generated by a Uniswap V3 pool managed by this contract.\n  /// @param state The State storage containing the pool's information.\n  /// @return fee0 The fees generated for the first token in the pool.\n  /// @return fee1 The fees generated for the second token in the pool.\n  function getFees(State storage state) public view returns (uint fee0, uint fee1) {\n    UniswapV3Lib.PoolPosition memory position = UniswapV3Lib.PoolPosition(address(state.pool), state.lowerTick, state.upperTick, state.totalLiquidity, address(this));\n    (fee0, fee1) = UniswapV3Lib.getFees(position);\n    UniswapV3Lib.PoolPosition memory positionFillup = UniswapV3Lib.PoolPosition(address(state.pool), state.lowerTickFillup, state.upperTickFillup, state.totalLiquidityFillup, address(this));\n    (uint fee0Fillup, uint fee1Fillup) = UniswapV3Lib.getFees(positionFillup);\n    fee0 += fee0Fillup;\n    fee1 += fee1Fillup;\n  }\n\n  /// @notice Estimate the exit amounts for a given liquidity amount in a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool to quote the exit amounts for.\n  /// @param lowerTick The lower tick value for the pool.\n  /// @param upperTick The upper tick value for the pool.\n  /// @param lowerTickFillup The lower tick value for the fillup range in the pool.\n  /// @param upperTickFillup The upper tick value for the fillup range in the pool.\n  /// @param liquidity The current liquidity in the pool.\n  /// @param liquidityFillup The current liquidity in the fillup range.\n  /// @param liquidityAmountToExit The amount of liquidity to exit.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsOut An array containing the estimated exit amounts for each token in the pool.\n  function quoteExit(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 lowerTickFillup,\n    int24 upperTickFillup,\n    uint128 liquidity,\n    uint128 liquidityFillup,\n    uint128 liquidityAmountToExit,\n    bool _depositorSwapTokens\n  ) external view returns (uint[] memory amountsOut) {\n    amountsOut = new uint[](2);\n    (uint160 sqrtRatioX96, , , , , ,) = pool.slot0();\n\n    (amountsOut[0], amountsOut[1]) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      lowerTick,\n      upperTick,\n      liquidityAmountToExit\n    );\n\n    if (liquidity > 0 && liquidityFillup > 0) {\n      (uint amountOut0Fillup, uint amountOut1Fillup) = UniswapV3Lib.getAmountsForLiquidity(\n        sqrtRatioX96,\n        lowerTickFillup,\n        upperTickFillup,\n        liquidityFillup * liquidityAmountToExit / liquidity\n      );\n\n      amountsOut[0] += amountOut0Fillup;\n      amountsOut[1] += amountOut1Fillup;\n    }\n\n    if (_depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  /// @notice Determine if the pool needs to be rebalanced.\n  /// @return A boolean indicating if the pool needs to be rebalanced.\n  function needRebalance(\n    bool isFuseTriggered,\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing,\n    int24 rebalanceTickRange\n  ) public view returns (bool) {\n    if (isFuseTriggered) {\n      return false;\n    }\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (upperTick - lowerTick == tickSpacing) {\n      return tick < lowerTick || tick >= upperTick;\n    } else {\n      int24 halfRange = (upperTick - lowerTick) / 2;\n      int24 oldMedianTick = lowerTick + halfRange;\n      if (tick > oldMedianTick) {\n        return tick - oldMedianTick >= rebalanceTickRange;\n      }\n      return oldMedianTick - tick > rebalanceTickRange;\n    }\n  }\n\n  /// @notice Get entry data for a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool instance.\n  /// @param lowerTick The lower tick of the pool's main range.\n  /// @param upperTick The upper tick of the pool's main range.\n  /// @param tickSpacing The tick spacing of the pool.\n  /// @param depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return entryData A byte array containing the entry data for the pool.\n  function getEntryData(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing,\n    bool depositorSwapTokens\n  ) public view returns (bytes memory entryData) {\n    address token1 = pool.token1();\n    uint token1Price = UniswapV3Lib.getPrice(address(pool), token1);\n    (lowerTick, upperTick) = _calcNewTickRange(pool, lowerTick, upperTick, tickSpacing);\n\n    uint token1Decimals = IERC20Metadata(token1).decimals();\n\n    uint token0Desired = token1Price;\n    uint token1Desired = 10 ** token1Decimals;\n\n    // calculate proportions\n    (uint consumed0, uint consumed1,) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTick, upperTick, token0Desired, token1Desired);\n\n    if (depositorSwapTokens) {\n      entryData = abi.encode(1, consumed1 * token1Price / token1Desired, consumed0);\n    } else {\n      entryData = abi.encode(1, consumed0, consumed1 * token1Price / token1Desired);\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Joins to the pool\n  //////////////////////////////////////////\n\n  /// @notice Enter the pool and provide liquidity with desired token amounts.\n  /// @param pool The Uniswap V3 pool to provide liquidity to.\n  /// @param lowerTick The lower tick value for the pool.\n  /// @param upperTick The upper tick value for the pool.\n  /// @param amountsDesired_ An array containing the desired amounts of tokens to provide liquidity.\n  /// @param totalLiquidity The current total liquidity in the pool.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsConsumed An array containing the consumed amounts for each token in the pool.\n  /// @return liquidityOut The amount of liquidity added to the pool.\n  /// @return totalLiquidityNew The updated total liquidity after providing liquidity.\n  function enter(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    uint[] memory amountsDesired_,\n    uint128 totalLiquidity,\n    bool _depositorSwapTokens\n  ) external returns (uint[] memory amountsConsumed, uint liquidityOut, uint128 totalLiquidityNew) {\n\n    amountsConsumed = new uint[](2);\n    if (_depositorSwapTokens) {\n      (amountsDesired_[0], amountsDesired_[1]) = (amountsDesired_[1], amountsDesired_[0]);\n    }\n    uint128 newLiquidity;\n    (amountsConsumed[0], amountsConsumed[1], newLiquidity) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTick, upperTick, amountsDesired_[0], amountsDesired_[1]);\n    pool.mint(address(this), lowerTick, upperTick, newLiquidity, \"\");\n    liquidityOut = uint(newLiquidity);\n    totalLiquidityNew = totalLiquidity + newLiquidity;\n    if (_depositorSwapTokens) {\n      (amountsConsumed[0], amountsConsumed[1]) = (amountsConsumed[1], amountsConsumed[0]);\n    }\n  }\n\n  /// @notice Add liquidity to a Uniswap V3 pool in a specified tick range according fill up rules.\n  /// @param pool The Uniswap V3 pool to add liquidity to.\n  /// @param lowerTick The current lower tick value for the pool.\n  /// @param upperTick The current upper tick value for the pool.\n  /// @param tickSpacing The tick spacing for the pool.\n  /// @param fee0 The fee amount for the first token in the pool.\n  /// @param fee1 The fee amount for the second token in the pool.\n  /// @return lowerTickFillup The lower tick value for the new liquidity range.\n  /// @return upperTickFillup The upper tick value for the new liquidity range.\n  /// @return liquidityOutFillup The liquidity amount added to the new range.\n  function addFillup(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing,\n    uint fee0,\n    uint fee1\n  ) external returns (int24 lowerTickFillup, int24 upperTickFillup, uint128 liquidityOutFillup) {\n    uint balance0 = _balance(pool.token0());\n    uint balance1 = _balance(pool.token1());\n\n    require(balance0 >= fee0 && balance1 >= fee1, \"Wrong fee\");\n    balance0 -= fee0;\n    balance1 -= fee1;\n\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (balance0 > balance1 * UniswapV3Lib.getPrice(address(pool), pool.token1()) / 10 ** IERC20Metadata(pool.token1()).decimals()) {\n      // add token0 to half range\n      lowerTickFillup = tick / tickSpacing * tickSpacing + tickSpacing;\n      upperTickFillup = upperTick;\n      (,, liquidityOutFillup) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTickFillup, upperTickFillup, balance0, 0);\n      pool.mint(address(this), lowerTickFillup, upperTickFillup, liquidityOutFillup, \"\");\n    } else {\n      lowerTickFillup = lowerTick;\n      upperTickFillup = tick / tickSpacing * tickSpacing - tickSpacing;\n      (,, liquidityOutFillup) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTickFillup, upperTickFillup, 0, balance1);\n      pool.mint(address(this), lowerTickFillup, upperTickFillup, liquidityOutFillup, \"\");\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Exit from the pool\n  //////////////////////////////////////////\n\n\n  /// @notice Exit the pool and collect tokens proportional to the liquidity amount to exit.\n  /// @param pool The Uniswap V3 pool to exit from.\n  /// @param lowerTick The lower tick value for the pool.\n  /// @param upperTick The upper tick value for the pool.\n  /// @param lowerTickFillup The lower tick value for the fillup range in the pool.\n  /// @param upperTickFillup The upper tick value for the fillup range in the pool.\n  /// @param liquidity The current liquidity in the pool.\n  /// @param liquidityFillup The current liquidity in the fillup range.\n  /// @param liquidityAmountToExit The amount of liquidity to exit.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsOut An array containing the collected amounts for each token in the pool.\n  /// @return totalLiquidity The updated total liquidity after the exit.\n  /// @return totalLiquidityFillup The updated total liquidity in the fillup range after the exit.\n  function exit(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 lowerTickFillup,\n    int24 upperTickFillup,\n    uint128 liquidity,\n    uint128 liquidityFillup,\n    uint128 liquidityAmountToExit,\n    bool _depositorSwapTokens\n  ) external returns (uint[] memory amountsOut, uint128 totalLiquidity, uint128 totalLiquidityFillup) {\n    totalLiquidityFillup = 0;\n\n    amountsOut = new uint[](2);\n    (amountsOut[0], amountsOut[1]) = pool.burn(lowerTick, upperTick, liquidityAmountToExit);\n    // all fees will be collected but not returned in amountsOut\n    pool.collect(\n      address(this),\n      lowerTick,\n      upperTick,\n      type(uint128).max,\n      type(uint128).max\n    );\n\n    // remove proportional part of fillup liquidity\n    if (liquidityFillup != 0) {\n      uint128 toRemoveFillUpAmount = liquidityFillup * liquidityAmountToExit / liquidity;\n      (uint amountsOutFillup0, uint amountsOutFillup1) = pool.burn(lowerTickFillup, upperTickFillup, toRemoveFillUpAmount);\n      pool.collect(\n        address(this),\n        lowerTickFillup,\n        upperTickFillup,\n        type(uint128).max,\n        type(uint128).max\n      );\n      amountsOut[0] += amountsOutFillup0;\n      amountsOut[1] += amountsOutFillup1;\n\n      require(liquidityFillup >= toRemoveFillUpAmount, \"Wrong fillup\");\n      totalLiquidityFillup = liquidityFillup - toRemoveFillUpAmount;\n    }\n\n    require(liquidity >= liquidityAmountToExit, \"Wrong liquidity\");\n    totalLiquidity = liquidity - liquidityAmountToExit;\n\n    if (_depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Claim\n  //////////////////////////////////////////\n\n  /// @notice Claim rewards from the Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool instance.\n  /// @param lowerTick The lower tick of the pool's main range.\n  /// @param upperTick The upper tick of the pool's main range.\n  /// @param lowerTickFillup The lower tick of the pool's fill-up range.\n  /// @param upperTickFillup The upper tick of the pool's fill-up range.\n  /// @param rebalanceEarned0 The amount of token0 earned from rebalancing.\n  /// @param rebalanceEarned1 The amount of token1 earned from rebalancing.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsOut An array containing the amounts of token0 and token1 claimed as rewards.\n  function claimRewards(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 lowerTickFillup,\n    int24 upperTickFillup,\n    uint rebalanceEarned0,\n    uint rebalanceEarned1,\n    bool _depositorSwapTokens\n  ) external returns (uint[] memory amountsOut) {\n    amountsOut = new uint[](2);\n    pool.burn(lowerTick, upperTick, 0);\n    (amountsOut[0], amountsOut[1]) = pool.collect(\n      address(this),\n      lowerTick,\n      upperTick,\n      type(uint128).max,\n      type(uint128).max\n    );\n    if (lowerTickFillup != upperTickFillup) {\n      pool.burn(lowerTickFillup, upperTickFillup, 0);\n      (uint fillup0, uint fillup1) = pool.collect(\n        address(this),\n        lowerTickFillup,\n        upperTickFillup,\n        type(uint128).max,\n        type(uint128).max\n      );\n      amountsOut[0] += fillup0;\n      amountsOut[1] += fillup1;\n    }\n    amountsOut[0] += rebalanceEarned0;\n    amountsOut[1] += rebalanceEarned1;\n    if (_depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  function isReadyToHardWork(State storage state, ITetuConverter converter) external view returns (bool isReady) {\n    // check claimable amounts and compare with thresholds\n    (uint fee0, uint fee1) = getFees(state);\n    fee0 += state.rebalanceEarned0;\n    fee1 += state.rebalanceEarned1;\n\n    if (state.depositorSwapTokens) {\n      (fee0, fee1) = (fee1, fee0);\n    }\n\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n    uint priceA = oracle.getAssetPrice(tokenA);\n    uint priceB = oracle.getAssetPrice(tokenB);\n\n    uint fee0USD = fee0 * priceA / 1e18;\n    uint fee1USD = fee1 * priceB / 1e18;\n\n    return fee0USD > HARD_WORK_USD_FEE_THRESHOLD || fee1USD > HARD_WORK_USD_FEE_THRESHOLD;\n  }\n\n  //////////////////////////////////////////\n  //            Rebalance\n  //////////////////////////////////////////\n\n  /// @dev Rebalances the current position, adjusts the tick range, and attempts to cover loss with pool rewards.\n  /// @param state The State storage object.\n  /// @param converter The TetuConverter contract.\n  /// @param controller The Tetu controller address.\n  /// @param oldInvestedAssets The amount of invested assets before rebalancing.\n  /// @return tokenAmounts The token amounts for deposit (if length != 2 then do nothing).\n  /// @return isNeedFillup Indicates if fill-up is required after rebalancing.\n  function rebalance(\n    State storage state,\n    ITetuConverter converter,\n    address controller,\n    uint oldInvestedAssets\n  ) external returns (\n    uint[] memory tokenAmounts, // _depositorEnter(tokenAmounts) if length == 2\n    bool isNeedFillup\n  ) {\n    tokenAmounts = new uint[](0);\n    isNeedFillup = false;\n\n    RebalanceLocalVariables memory vars = RebalanceLocalVariables({\n    upperTick : state.upperTick,\n    lowerTick : state.lowerTick,\n    tickSpacing : state.tickSpacing,\n    pool : state.pool,\n    tokenA : state.tokenA,\n    tokenB : state.tokenB,\n    lastPrice : state.lastPrice,\n    fuseThreshold : state.fuseThreshold,\n    depositorSwapTokens : state.depositorSwapTokens,\n    rebalanceEarned0 : state.rebalanceEarned0,\n    rebalanceEarned1 : state.rebalanceEarned1,\n    // setup initial values\n    newRebalanceEarned0 : 0,\n    newRebalanceEarned1 : 0,\n    notCoveredLoss : 0,\n    newLowerTick : 0,\n    newUpperTick : 0,\n    fillUp : state.fillUp,\n    isStablePool : state.isStablePool,\n    newPrice : 0\n    });\n\n    require(needRebalance(\n        state.isFuseTriggered,\n        vars.pool,\n        vars.lowerTick,\n        vars.upperTick,\n        vars.tickSpacing,\n        state.rebalanceTickRange\n      ), \"No rebalancing needed\");\n\n    vars.newPrice = getOracleAssetsPrice(converter, vars.tokenA, vars.tokenB);\n\n    if (vars.isStablePool && isEnableFuse(vars.lastPrice, vars.newPrice, vars.fuseThreshold)) {\n      /// enabling fuse: close debt and stop providing liquidity\n      state.isFuseTriggered = true;\n      emit FuseTriggered();\n\n      UniswapV3DebtLib.closeDebt(\n        converter,\n        controller,\n        vars.pool,\n        vars.tokenA,\n        vars.tokenB,\n        vars.depositorSwapTokens,\n        vars.rebalanceEarned0,\n        vars.rebalanceEarned1,\n        _getLiquidatorSwapSlippage(vars.pool)\n      );\n\n      vars.newRebalanceEarned0 = vars.rebalanceEarned0;\n      vars.newRebalanceEarned1 = vars.rebalanceEarned1;\n      vars.newLowerTick = vars.lowerTick;\n      vars.newUpperTick = vars.upperTick;\n    } else {\n      if (vars.isStablePool) {\n        state.lastPrice = vars.newPrice;\n      }\n\n      /// rebalancing debt with passing rebalanceEarned0, rebalanceEarned1 that will remain untouched\n      UniswapV3DebtLib.rebalanceDebt(\n        converter,\n        controller,\n        vars.pool,\n        vars.tokenA,\n        vars.tokenB,\n        vars.fillUp,\n        (vars.depositorSwapTokens ? vars.rebalanceEarned1 : vars.rebalanceEarned0),\n        (vars.depositorSwapTokens ? vars.rebalanceEarned0 : vars.rebalanceEarned1),\n        getEntryData(vars.pool, vars.lowerTick, vars.upperTick, vars.tickSpacing, vars.depositorSwapTokens),\n        _getLiquidatorSwapSlippage(vars.pool)\n      );\n\n      /// trying to cover rebalance loss (IL + not hedged part of tokenB + swap cost) by pool rewards\n      (vars.newRebalanceEarned0, vars.newRebalanceEarned1, vars.notCoveredLoss) = _calculateCoverLoss(\n        TryCoverLossParams(\n          vars.pool,\n          vars.tokenA,\n          vars.tokenB,\n          vars.depositorSwapTokens,\n          vars.rebalanceEarned0,\n          vars.rebalanceEarned1,\n          oldInvestedAssets\n        ),\n        UniswapV3DebtLib.getDeptTotalCollateralAmountOut(converter, vars.tokenA, vars.tokenB)\n      );\n      state.rebalanceEarned0 = vars.newRebalanceEarned0;\n      state.rebalanceEarned1 = vars.newRebalanceEarned1;\n      if (vars.notCoveredLoss != 0) {\n        state.rebalanceLost += vars.notCoveredLoss;\n      }\n\n      // calculate and set new tick range\n      (vars.newLowerTick, vars.newUpperTick) = _calcNewTickRange(vars.pool, vars.lowerTick, vars.upperTick, vars.tickSpacing);\n      state.lowerTick = vars.newLowerTick;\n      state.upperTick = vars.newUpperTick;\n\n\n      tokenAmounts = new uint[](2);\n      tokenAmounts[0] = _balance(vars.tokenA) - (vars.depositorSwapTokens ? vars.newRebalanceEarned1 : vars.newRebalanceEarned0);\n      tokenAmounts[1] = _balance(vars.tokenB) - (vars.depositorSwapTokens ? vars.newRebalanceEarned0 : vars.newRebalanceEarned1);\n\n      if (vars.fillUp) {\n        isNeedFillup = true;\n      }\n    }\n    emit Rebalanced();\n  }\n\n  function calcEarned(State storage state) external view returns (uint) {\n    address tokenB = state.tokenB;\n\n    (uint fee0, uint fee1) = getFees(state);\n    fee0 += state.rebalanceEarned0;\n    fee1 += state.rebalanceEarned1;\n\n    if (state.depositorSwapTokens) {\n      (fee0, fee1) = (fee1, fee0);\n    }\n\n    uint feeBinTermOfA = UniswapV3Lib.getPrice(address(state.pool), tokenB) * fee1 / 10 ** IERC20Metadata(tokenB).decimals();\n\n    return fee0 + feeBinTermOfA;\n  }\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3DebtLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"../ConverterStrategyBaseLib.sol\";\r\nimport \"./UniswapV3Lib.sol\";\r\n\r\nlibrary UniswapV3DebtLib {\r\n\r\n  //////////////////////////////////////////\r\n  //            CONSTANTS\r\n  //////////////////////////////////////////\r\n\r\n  uint internal constant SELL_GAP = 100;\r\n  /// @dev should be placed local, probably will be adjusted later\r\n  uint internal constant BORROW_PERIOD_ESTIMATION = 30 days / 2;\r\n\r\n  //////////////////////////////////////////\r\n  //            STRUCTURES\r\n  //////////////////////////////////////////\r\n\r\n  struct RebalanceDebtFillUpLocalVariables {\r\n    uint debtAmount;\r\n    uint availableBalanceTokenA;\r\n    uint availableBalanceTokenB;\r\n    uint needToBorrowOrFreeFromBorrow;\r\n  }\r\n\r\n  //////////////////////////////////////////\r\n  //            MAIN LOGIC\r\n  //////////////////////////////////////////\r\n\r\n  /// @dev Returns the total collateral amount out for the given token pair.\r\n  /// @param tetuConverter The ITetuConverter instance.\r\n  /// @param tokenA The address of tokenA.\r\n  /// @param tokenB The address of tokenB.\r\n  /// @return totalCollateralAmountOut The total collateral amount out for the token pair.\r\n  function getDeptTotalCollateralAmountOut(ITetuConverter tetuConverter, address tokenA, address tokenB) internal returns (uint totalCollateralAmountOut) {\r\n    (, totalCollateralAmountOut) = tetuConverter.getDebtAmountCurrent(address(this), tokenA, tokenB);\r\n  }\r\n\r\n  /// @dev Returns the total debt amount out for the given token pair.\r\n  /// @param tetuConverter The ITetuConverter instance.\r\n  /// @param tokenA The address of tokenA.\r\n  /// @param tokenB The address of tokenB.\r\n  /// @return totalDebtAmountOut The total debt amount out for the token pair.\r\n  function getDeptTotalDebtAmountOut(ITetuConverter tetuConverter, address tokenA, address tokenB) internal returns (uint totalDebtAmountOut) {\r\n    (totalDebtAmountOut,) = tetuConverter.getDebtAmountCurrent(address(this), tokenA, tokenB);\r\n  }\r\n\r\n  /// @dev Closes the debt positions for the given token pair.\r\n  /// @param tetuConverter The ITetuConverter instance.\r\n  /// @param controller The controller address.\r\n  /// @param pool The IUniswapV3Pool instance.\r\n  /// @param tokenA The address of tokenA.\r\n  /// @param tokenB The address of tokenB.\r\n  /// @param depositorSwapTokens A boolean indicating if need to use token B instead of token A.\r\n  /// @param fee0 The fee amount for tokenA.\r\n  /// @param fee1 The fee amount for tokenB.\r\n  function closeDebt(\r\n    ITetuConverter tetuConverter,\r\n    address controller,\r\n    IUniswapV3Pool pool,\r\n    address tokenA,\r\n    address tokenB,\r\n    bool depositorSwapTokens,\r\n    uint fee0,\r\n    uint fee1,\r\n    uint liquidatorSwapSlippage\r\n  ) internal {\r\n    uint tokenAFee = depositorSwapTokens ? fee1 : fee0;\r\n    uint tokenBFee = depositorSwapTokens ? fee0 : fee1;\r\n    _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, tokenAFee, tokenBFee, liquidatorSwapSlippage);\r\n  }\r\n\r\n  /// @dev Rebalances the debt by either filling up or closing and reopening debt positions.\r\n  function rebalanceDebt(\r\n    ITetuConverter tetuConverter,\r\n    address controller,\r\n    IUniswapV3Pool pool,\r\n    address tokenA,\r\n    address tokenB,\r\n    bool fillUp,\r\n    uint tokenAFee,\r\n    uint tokenBFee,\r\n    bytes memory entryData,\r\n    uint liquidatorSwapSlippage\r\n  ) external {\r\n    if (fillUp) {\r\n      _rebalanceDebtFillup(tetuConverter, controller, pool, tokenA, tokenB, tokenAFee, tokenBFee, liquidatorSwapSlippage);\r\n    } else {\r\n      _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, tokenAFee, tokenBFee, liquidatorSwapSlippage);\r\n      _openDebt(tetuConverter, tokenA, tokenB, entryData, tokenAFee);\r\n    }\r\n  }\r\n\r\n  /// @notice Closes debt by liquidating tokens as necessary.\r\n  ///         This function helps ensure that the converter strategy maintains the appropriate balances\r\n  ///         and debt positions for token A and token B, while accounting for fees and potential price impacts.\r\n  function _closeDebt(\r\n    ITetuConverter tetuConverter,\r\n    address controller,\r\n    IUniswapV3Pool pool,\r\n    address tokenA,\r\n    address tokenB,\r\n    uint feeA,\r\n    uint feeB,\r\n    uint liquidatorSwapSlippage\r\n  ) internal {\r\n    uint debtAmount = getDeptTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\r\n\r\n    uint availableBalanceTokenA = _balance(tokenA);\r\n    uint availableBalanceTokenB = _balance(tokenB);\r\n\r\n    require(availableBalanceTokenA >= feeA && availableBalanceTokenB >= feeB, \"Wrong balance\");\r\n    availableBalanceTokenA -= feeA;\r\n    availableBalanceTokenB -= feeB;\r\n\r\n    if (availableBalanceTokenB < debtAmount) {\r\n\r\n      uint tokenBprice = UniswapV3Lib.getPrice(address(pool), tokenB);\r\n      uint needToSellTokenA = tokenBprice * (debtAmount - availableBalanceTokenB) / 10 ** IERC20Metadata(tokenB).decimals();\r\n      // add 1% gap for price impact\r\n      needToSellTokenA += needToSellTokenA / SELL_GAP;\r\n\r\n      if (needToSellTokenA < availableBalanceTokenA) {\r\n        ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, needToSellTokenA, liquidatorSwapSlippage, 0);\r\n      } else {\r\n        // very rare case, but happens on long run backtests\r\n        ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, availableBalanceTokenA, liquidatorSwapSlippage, 0);\r\n        ConverterStrategyBaseLib.closePosition(\r\n          tetuConverter,\r\n          tokenA,\r\n          tokenB,\r\n          _balance(tokenB) - feeB\r\n        );\r\n        // refresh dept amount\r\n        debtAmount = getDeptTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\r\n        if (debtAmount > 0) {\r\n          tokenBprice = UniswapV3Lib.getPrice(address(pool), tokenB);\r\n          needToSellTokenA = tokenBprice * debtAmount / 10 ** IERC20Metadata(tokenB).decimals();\r\n          needToSellTokenA += needToSellTokenA / SELL_GAP;\r\n          ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, needToSellTokenA, liquidatorSwapSlippage, 0);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (debtAmount > 0) {\r\n      ConverterStrategyBaseLib.closePosition(\r\n        tetuConverter,\r\n        tokenA,\r\n        tokenB,\r\n        debtAmount\r\n      );\r\n    }\r\n\r\n    ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenB, tokenA, _balance(tokenB) - feeB, liquidatorSwapSlippage, 0);\r\n  }\r\n\r\n  /// @dev Opens a new debt position using entry data.\r\n  /// @param tetuConverter The TetuConverter contract.\r\n  /// @param tokenA The address of token A.\r\n  /// @param tokenB The address of token B.\r\n  /// @param entryData The data required to open a position.\r\n  /// @param feeA The fee associated with token A.\r\n  function _openDebt(\r\n    ITetuConverter tetuConverter,\r\n    address tokenA,\r\n    address tokenB,\r\n    bytes memory entryData,\r\n    uint feeA\r\n  ) internal {\r\n    ConverterStrategyBaseLib.openPosition(\r\n      tetuConverter,\r\n      entryData,\r\n      tokenA,\r\n      tokenB,\r\n      _balance(tokenA) - feeA,\r\n      0\r\n    );\r\n  }\r\n\r\n  /// @dev Rebalances the debt to reach the optimal ratio between token A and token B.\r\n  function _rebalanceDebtFillup(\r\n    ITetuConverter tetuConverter,\r\n    address controller,\r\n    IUniswapV3Pool pool,\r\n    address tokenA,\r\n    address tokenB,\r\n    uint tokenAFee,\r\n    uint tokenBFee,\r\n    uint liquidatorSwapSlippage\r\n  ) internal {\r\n    RebalanceDebtFillUpLocalVariables memory vars;\r\n    vars.debtAmount = getDeptTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\r\n\r\n    vars.availableBalanceTokenA = getBalanceWithoutFees(tokenA, tokenAFee);\r\n    vars.availableBalanceTokenB = getBalanceWithoutFees(tokenB, tokenBFee);\r\n\r\n    if (vars.availableBalanceTokenB > vars.debtAmount) {\r\n      vars.needToBorrowOrFreeFromBorrow = vars.availableBalanceTokenB - vars.debtAmount;\r\n\r\n      if (_getCollateralAmountForBorrow(tetuConverter, tokenA, tokenB, vars.needToBorrowOrFreeFromBorrow) < vars.availableBalanceTokenA) {\r\n        ConverterStrategyBaseLib.openPosition(\r\n          tetuConverter,\r\n          abi.encode(2),\r\n          tokenA,\r\n          tokenB,\r\n          vars.needToBorrowOrFreeFromBorrow,\r\n          0\r\n        );\r\n      } else {\r\n        ConverterStrategyBaseLib.closePosition(\r\n          tetuConverter,\r\n          tokenA,\r\n          tokenB,\r\n          vars.debtAmount\r\n        );\r\n\r\n        vars.availableBalanceTokenB = getBalanceWithoutFees(tokenB, tokenBFee);\r\n\r\n        ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenB, tokenA, vars.availableBalanceTokenB, liquidatorSwapSlippage, 0);\r\n\r\n        vars.availableBalanceTokenA = getBalanceWithoutFees(tokenA, tokenAFee);\r\n\r\n        ConverterStrategyBaseLib.openPosition(\r\n          tetuConverter,\r\n          abi.encode(1, 1, 1),\r\n          tokenA,\r\n          tokenB,\r\n          vars.availableBalanceTokenA,\r\n          0\r\n        );\r\n      }\r\n    } else {\r\n      vars.needToBorrowOrFreeFromBorrow = vars.debtAmount - vars.availableBalanceTokenB;\r\n      if (vars.availableBalanceTokenB > vars.needToBorrowOrFreeFromBorrow) {\r\n        ConverterStrategyBaseLib.closePosition(\r\n          tetuConverter,\r\n          tokenA,\r\n          tokenB,\r\n          vars.needToBorrowOrFreeFromBorrow\r\n        );\r\n      } else {\r\n        uint needToSellTokenA = UniswapV3Lib.getPrice(address(pool), tokenB) * vars.needToBorrowOrFreeFromBorrow / 10 ** IERC20Metadata(tokenB).decimals();\r\n        // add % gap for price impact\r\n        needToSellTokenA += needToSellTokenA / SELL_GAP;\r\n        ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, needToSellTokenA, liquidatorSwapSlippage, 0);\r\n\r\n        vars.availableBalanceTokenB = getBalanceWithoutFees(tokenB, tokenBFee);\r\n\r\n        ConverterStrategyBaseLib.closePosition(\r\n          tetuConverter,\r\n          tokenA,\r\n          tokenB,\r\n          vars.debtAmount < vars.availableBalanceTokenB ? vars.debtAmount : vars.availableBalanceTokenB\r\n        );\r\n\r\n        vars.availableBalanceTokenA = getBalanceWithoutFees(tokenA, tokenAFee);\r\n\r\n        ConverterStrategyBaseLib.openPosition(\r\n          tetuConverter,\r\n          abi.encode(1, 1, 1),\r\n          tokenA,\r\n          tokenB,\r\n          vars.availableBalanceTokenA,\r\n          0\r\n        );\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Calculates the collateral amount required for borrowing a specified amount.\r\n  /// @param tetuConverter The TetuConverter contract.\r\n  /// @param tokenA The address of token A.\r\n  /// @param tokenB The address of token B.\r\n  /// @param needToBorrow The amount that needs to be borrowed.\r\n  /// @return collateralAmount The amount of collateral required for borrowing the specified amount.\r\n  function _getCollateralAmountForBorrow(\r\n    ITetuConverter tetuConverter,\r\n    address tokenA,\r\n    address tokenB,\r\n    uint needToBorrow\r\n  ) internal view returns (uint collateralAmount) {\r\n    ConverterStrategyBaseLib.OpenPositionLocal memory vars;\r\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter.findBorrowStrategies(\r\n      abi.encode(2),\r\n      tokenA,\r\n      needToBorrow,\r\n      tokenB,\r\n      BORROW_PERIOD_ESTIMATION\r\n    );\r\n\r\n    uint len = vars.converters.length;\r\n    if (len > 0) {\r\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\r\n        vars.amountToBorrow = needToBorrow < vars.amountsToBorrow[i]\r\n        ? needToBorrow\r\n        : vars.amountsToBorrow[i];\r\n        vars.collateral = needToBorrow < vars.amountsToBorrow[i]\r\n        ? vars.collateralsRequired[i] * needToBorrow / vars.amountsToBorrow[i]\r\n        : vars.collateralsRequired[i];\r\n        needToBorrow -= vars.amountToBorrow;\r\n        if (needToBorrow == 0) break;\r\n      }\r\n    }\r\n    return vars.collateral;\r\n  }\r\n\r\n  /// @notice Get the balance of the given token held by the contract.\r\n  /// @param token The token address.\r\n  /// @return The balance of the token.\r\n  function _balance(address token) internal view returns (uint) {\r\n    return IERC20(token).balanceOf(address(this));\r\n  }\r\n\r\n  /// @dev Gets the token balance without fees.\r\n  /// @param token The token address.\r\n  /// @param fee The fee amount to be subtracted from the balance.\r\n  /// @return balanceWithoutFees The token balance without the specified fee amount.\r\n  function getBalanceWithoutFees(address token, uint fee) internal view returns (uint balanceWithoutFees) {\r\n    balanceWithoutFees = _balance(token);\r\n    require(balanceWithoutFees >= fee, \"Balance lower than fee\");\r\n    balanceWithoutFees -= fee;\r\n  }\r\n\r\n}\r\n"
    },
    "contracts/strategies/uniswap/UniswapV3Depositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"../DepositorBase.sol\";\nimport \"../../integrations/uniswap/IUniswapV3MintCallback.sol\";\nimport \"./UniswapV3ConverterStrategyLogicLib.sol\";\n\n/// @title UniswapV3Depositor\n/// @dev Abstract contract that is designed to interact with Uniswap V3 pools and manage liquidity.\n///      Inherits from IUniswapV3MintCallback, DepositorBase, and Initializable.\nabstract contract UniswapV3Depositor is IUniswapV3MintCallback, DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant UNISWAPV3_DEPOSITOR_VERSION = \"1.0.1\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                VARIABLES\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev State variable to store the current state of the whole strategy\n  UniswapV3ConverterStrategyLogicLib.State internal state;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                INIT\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Initializes the contract with the provided parameters.\n  /// @param asset_ The address of the asset.\n  /// @param pool_ The address of the Uniswap V3 pool.\n  /// @param tickRange_ The tick range for the positions.\n  /// @param rebalanceTickRange_ The tick range for rebalancing.\n  function __UniswapV3Depositor_init(\n    address asset_,\n    address pool_,\n    int24 tickRange_,\n    int24 rebalanceTickRange_\n  ) internal onlyInitializing {\n    require(pool_ != address(0), AppErrors.ZERO_ADDRESS);\n    state.pool = IUniswapV3Pool(pool_);\n    state.rebalanceTickRange = rebalanceTickRange_;\n    (\n    state.tickSpacing,\n    state.lowerTick,\n    state.upperTick,\n    state.tokenA,\n    state.tokenB,\n    state.depositorSwapTokens\n    ) = UniswapV3ConverterStrategyLogicLib.calcInitialDepositorValues(\n      state.pool,\n      tickRange_,\n      rebalanceTickRange_,\n      asset_\n    );\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns the current state of the contract.\n  function getState() external view returns (\n    address tokenA,\n    address tokenB,\n    IUniswapV3Pool pool,\n    int24 tickSpacing,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 rebalanceTickRange,\n    uint128 totalLiquidity,\n    bool isFuseTriggered,\n    uint fuseThreshold,\n    uint[] memory rebalanceResults\n  ) {\n    tokenA = state.tokenA;\n    tokenB = state.tokenB;\n    pool = state.pool;\n    tickSpacing = state.tickSpacing;\n    lowerTick = state.lowerTick;\n    upperTick = state.upperTick;\n    rebalanceTickRange = state.rebalanceTickRange;\n    totalLiquidity = state.totalLiquidity;\n    isFuseTriggered = state.isFuseTriggered;\n    fuseThreshold = state.fuseThreshold;\n\n    rebalanceResults = new uint[](3);\n    rebalanceResults[0] = state.rebalanceEarned0;\n    rebalanceResults[1] = state.rebalanceEarned1;\n    rebalanceResults[2] = state.rebalanceLost;\n  }\n\n  /// @notice Returns the fees for the current state.\n  /// @return fee0 and fee1.\n  function getFees() public view returns (uint fee0, uint fee1) {\n    return UniswapV3ConverterStrategyLogicLib.getFees(state);\n  }\n\n  /// @notice Returns the pool assets.\n  /// @return poolAssets An array containing the addresses of the pool assets.\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    poolAssets = new address[](2);\n    poolAssets[0] = state.tokenA;\n    poolAssets[1] = state.tokenB;\n  }\n\n  /// @notice Returns the pool weights and the total weight.\n  /// @return weights An array containing the weights of the pool assets, and totalWeight the sum of the weights.\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    weights = new uint[](2);\n    weights[0] = 1;\n    weights[1] = 1;\n    totalWeight = 2;\n  }\n\n  /// @notice Returns the pool reserves.\n  /// @return reserves An array containing the reserves of the pool assets.\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    return UniswapV3ConverterStrategyLogicLib.getPoolReserves(state);\n  }\n\n  /// @notice Returns the current liquidity of the depositor.\n  /// @return The current liquidity of the depositor.\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return uint(state.totalLiquidity);\n  }\n\n  /// @notice Returns the total supply of the depositor.\n  /// @return In UniV3 we can not calculate the total supply of the wgole pool. Return only ourself value.\n  function _depositorTotalSupply() override internal view virtual returns (uint) {\n    return uint(state.totalLiquidity);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CALLBACK\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Callback function called by Uniswap V3 pool on mint operation.\n  /// @param amount0Owed The amount of token0 owed to the pool.\n  /// @param amount1Owed The amount of token1 owed to the pool.\n  function uniswapV3MintCallback(\n    uint amount0Owed,\n    uint amount1Owed,\n    bytes calldata /*_data*/\n  ) external override {\n    require(msg.sender == address(state.pool), \"callback caller\");\n    if (amount0Owed > 0) IERC20(state.depositorSwapTokens ? state.tokenB : state.tokenA).safeTransfer(msg.sender, amount0Owed);\n    if (amount1Owed > 0) IERC20(state.depositorSwapTokens ? state.tokenA : state.tokenB).safeTransfer(msg.sender, amount1Owed);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Handles the deposit operation.\n  function _depositorEnter(\n    uint[] memory amountsDesired_\n  ) override internal virtual returns (uint[] memory amountsConsumed, uint liquidityOut) {\n    (amountsConsumed, liquidityOut, state.totalLiquidity) = UniswapV3ConverterStrategyLogicLib.enter(state.pool, state.lowerTick, state.upperTick, amountsDesired_, state.totalLiquidity, state.depositorSwapTokens);\n  }\n\n  /// @notice Handles the withdrawal operation.\n  /// @param liquidityAmount The amount of liquidity to be withdrawn.\n  /// @return amountsOut The amounts of the tokens withdrawn.\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    (uint fee0, uint fee1) = getFees();\n    state.rebalanceEarned0 += fee0;\n    state.rebalanceEarned1 += fee1;\n    (amountsOut, state.totalLiquidity, state.totalLiquidityFillup) = UniswapV3ConverterStrategyLogicLib.exit(state.pool, state.lowerTick, state.upperTick, state.lowerTickFillup, state.upperTickFillup, state.totalLiquidity, state.totalLiquidityFillup, uint128(liquidityAmount), state.depositorSwapTokens);\n  }\n\n  /// @notice Returns the amount of tokens that would be withdrawn based on the provided liquidity amount.\n  /// @param liquidityAmount The amount of liquidity to quote the withdrawal for.\n  /// @return amountsOut The amounts of the tokens that would be withdrawn.\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    amountsOut = UniswapV3ConverterStrategyLogicLib.quoteExit(state.pool, state.lowerTick, state.upperTick, state.lowerTickFillup, state.upperTickFillup, state.totalLiquidity, state.totalLiquidityFillup, uint128(liquidityAmount), state.depositorSwapTokens);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claims all possible rewards.\n  /// @return tokensOut An array containing the addresses of the reward tokens,\n  /// @return amountsOut An array containing the amounts of the reward tokens.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    amountsOut = UniswapV3ConverterStrategyLogicLib.claimRewards(state.pool, state.lowerTick, state.upperTick, state.lowerTickFillup, state.upperTickFillup, state.rebalanceEarned0, state.rebalanceEarned1, state.depositorSwapTokens);\n    state.rebalanceEarned0 = 0;\n    state.rebalanceEarned1 = 0;\n    tokensOut = new address[](2);\n    tokensOut[0] = state.tokenA;\n    tokensOut[1] = state.tokenB;\n  }\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[49] private __gap;\n\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/uniswap/IUniswapV3Pool.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\n\n/// @title Uniswap V3 liquidity management helper\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary UniswapV3Lib {\n  uint8 internal constant RESOLUTION = 96;\n  uint internal constant Q96 = 0x1000000000000000000000000;\n  uint private constant TWO_96 = 2 ** 96;\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n  int24 internal constant MIN_TICK = - 887272;\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n  int24 internal constant MAX_TICK = - MIN_TICK;\n\n  struct PoolPosition {\n    address pool;\n    int24 lowerTick;\n    int24 upperTick;\n    uint128 liquidity;\n    address owner;\n  }\n\n  function getTickSpacing(uint24 fee) external pure returns (int24) {\n    if (fee == 10000) {\n      return 200;\n    }\n    if (fee == 3000) {\n      return 60;\n    }\n    if (fee == 500) {\n      return 10;\n    }\n    return 1;\n  }\n\n  function getFees(PoolPosition memory position) public view returns (uint fee0, uint fee1) {\n    bytes32 positionId = _getPositionId(position);\n    IUniswapV3Pool pool = IUniswapV3Pool(position.pool);\n    (, int24 tick, , , , ,) = pool.slot0();\n    (, uint feeGrowthInside0Last, uint feeGrowthInside1Last, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(positionId);\n    fee0 = _computeFeesEarned(position, true, feeGrowthInside0Last, tick) + uint(tokensOwed0);\n    fee1 = _computeFeesEarned(position, false, feeGrowthInside1Last, tick) + uint(tokensOwed1);\n  }\n\n  function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\n    IUniswapV3Pool pool = IUniswapV3Pool(pool_);\n    (uint160 sqrtRatioX96, , , , , ,) = pool.slot0();\n    liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\n    (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\n  }\n\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n  /// pool prices and the prices at the tick boundaries\n  function getLiquidityForAmounts(\n    uint160 sqrtRatioX96,\n    int24 lowerTick,\n    int24 upperTick,\n    uint amount0,\n    uint amount1\n  ) public pure returns (uint128 liquidity) {\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n      uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n    } else {\n      liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n    }\n  }\n\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n  /// pool prices and the prices at the tick boundaries\n  function getAmountsForLiquidity(\n    uint160 sqrtRatioX96,\n    int24 lowerTick,\n    int24 upperTick,\n    uint128 liquidity\n  ) public pure returns (uint amount0, uint amount1) {\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n    } else {\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    }\n  }\n\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(\n    uint a,\n    uint b,\n    uint denominator\n  ) public pure returns (uint result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = a * b\n    // Compute the product mod 2**256 and mod 2**256 - 1\n    // then use the Chinese Remainder Theorem to reconstruct\n    // the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2**256 + prod0\n    uint prod0;\n    // Least significant 256 bits of the product\n    uint prod1;\n    // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(a, b, not(0))\n      prod0 := mul(a, b)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division\n    if (prod1 == 0) {\n      require(denominator > 0);\n      assembly {\n        result := div(prod0, denominator)\n      }\n      return result;\n    }\n\n    // Make sure the result is less than 2**256.\n    // Also prevents denominator == 0\n    require(denominator > prod1);\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0]\n    // Compute remainder using mulmod\n    uint remainder;\n    assembly {\n      remainder := mulmod(a, b, denominator)\n    }\n    // Subtract 256 bit number from 512 bit number\n    assembly {\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator\n    // Compute largest power of two divisor of denominator.\n    // Always >= 1.\n    // EDIT for 0.8 compatibility:\n    // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\n    uint twos = denominator & (~denominator + 1);\n\n    // Divide denominator by power of two\n    assembly {\n      denominator := div(denominator, twos)\n    }\n\n    // Divide [prod1 prod0] by the factors of two\n    assembly {\n      prod0 := div(prod0, twos)\n    }\n    // Shift in bits from prod1 into prod0. For this we need\n    // to flip `twos` such that it is 2**256 / twos.\n    // If twos is zero, then it becomes one\n    assembly {\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2**256\n    // Now that denominator is an odd number, it has an inverse\n    // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n    // Compute the inverse by starting with a seed that is correct\n    // correct for four bits. That is, denominator * inv = 1 mod 2**4\n    uint inv = (3 * denominator) ^ 2;\n    // Now use Newton-Raphson iteration to improve the precision.\n    // Thanks to Hensel's lifting lemma, this also works in modular\n    // arithmetic, doubling the correct bits in each step.\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**8\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**16\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**32\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**64\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**128\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**256\n\n    // Because the division is now exact we can divide by multiplying\n    // with the modular inverse of denominator. This will give us the\n    // correct result modulo 2**256. Since the precoditions guarantee\n    // that the outcome is less than 2**256, this is the final result.\n    // We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inv;\n    return result;\n  }\n  }\n\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(\n    uint a,\n    uint b,\n    uint denominator\n  ) internal pure returns (uint result) {\n    result = mulDiv(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      require(result < type(uint).max);\n      result++;\n    }\n  }\n\n  /// @notice Calculates price in pool\n  function getPrice(address pool_, address tokenIn) public view returns (uint) {\n    IUniswapV3Pool pool = IUniswapV3Pool(pool_);\n    address token0 = pool.token0();\n    address token1 = pool.token1();\n\n    uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    (uint160 sqrtPriceX96,,,,,,) = pool.slot0();\n\n    uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\n\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\n    uint purePrice;\n    uint precision;\n    if (tokenIn == token0) {\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\n      purePrice = part * part;\n    } else {\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\n      purePrice = part * part;\n    }\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount0 The amount0 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\n    return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount1 The amount1 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount0 The amount0\n  function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\n  }\n\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount1 The amount1\n  function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\n  }\n\n  function _computeFeesEarned(\n    PoolPosition memory position,\n    bool isZero,\n    uint feeGrowthInsideLast,\n    int24 tick\n  ) internal view returns (uint fee) {\n    IUniswapV3Pool pool = IUniswapV3Pool(position.pool);\n    uint feeGrowthOutsideLower;\n    uint feeGrowthOutsideUpper;\n    uint feeGrowthGlobal;\n    if (isZero) {\n      feeGrowthGlobal = pool.feeGrowthGlobal0X128();\n      (,, feeGrowthOutsideLower,,,,,) = pool.ticks(position.lowerTick);\n      (,, feeGrowthOutsideUpper,,,,,) = pool.ticks(position.upperTick);\n    } else {\n      feeGrowthGlobal = pool.feeGrowthGlobal1X128();\n      (,,, feeGrowthOutsideLower,,,,) = pool.ticks(position.lowerTick);\n      (,,, feeGrowthOutsideUpper,,,,) = pool.ticks(position.upperTick);\n    }\n\n  unchecked {\n    // calculate fee growth below\n    uint feeGrowthBelow;\n    if (tick >= position.lowerTick) {\n      feeGrowthBelow = feeGrowthOutsideLower;\n    } else {\n      feeGrowthBelow = feeGrowthGlobal - feeGrowthOutsideLower;\n    }\n\n    // calculate fee growth above\n    uint feeGrowthAbove;\n    if (tick < position.upperTick) {\n      feeGrowthAbove = feeGrowthOutsideUpper;\n    } else {\n      feeGrowthAbove = feeGrowthGlobal - feeGrowthOutsideUpper;\n    }\n\n    uint feeGrowthInside =\n    feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove;\n    fee = mulDiv(\n      position.liquidity,\n      feeGrowthInside - feeGrowthInsideLast,\n      0x100000000000000000000000000000000\n    );\n  }\n  }\n\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\n  /// @dev Throws if |tick| > max tick\n  /// @param tick The input tick for the above formula\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n  /// at the given tick\n  function _getSqrtRatioAtTick(int24 tick)\n  internal\n  pure\n  returns (uint160 sqrtPriceX96)\n  {\n    uint256 absTick =\n    tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\n\n    // EDIT: 0.8 compatibility\n    require(absTick <= uint256(int256(MAX_TICK)), \"T\");\n\n    uint256 ratio =\n    absTick & 0x1 != 0\n    ? 0xfffcb933bd6fad37aa2d162d1a594001\n    : 0x100000000000000000000000000000000;\n    if (absTick & 0x2 != 0)\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n    if (absTick & 0x4 != 0)\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n    if (absTick & 0x8 != 0)\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n    if (absTick & 0x10 != 0)\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n    if (absTick & 0x20 != 0)\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n    if (absTick & 0x40 != 0)\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n    if (absTick & 0x80 != 0)\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n    if (absTick & 0x100 != 0)\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n    if (absTick & 0x200 != 0)\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n    if (absTick & 0x400 != 0)\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n    if (absTick & 0x800 != 0)\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n    if (absTick & 0x1000 != 0)\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n    if (absTick & 0x2000 != 0)\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n    if (absTick & 0x4000 != 0)\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n    if (absTick & 0x8000 != 0)\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n    if (absTick & 0x10000 != 0)\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n    if (absTick & 0x20000 != 0)\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n    if (absTick & 0x40000 != 0)\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n    if (absTick & 0x80000 != 0)\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n    if (tick > 0) ratio = type(uint256).max / ratio;\n\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n    sqrtPriceX96 = uint160(\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\n    );\n  }\n\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n  /// ever return.\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n  function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    // second inequality must be < because the price can never reach the price at the max tick\n    require(\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\n      \"R\"\n    );\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n    uint256 r = ratio;\n    uint256 msb = 0;\n\n    assembly {\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(5, gt(r, 0xFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(4, gt(r, 0xFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(3, gt(r, 0xFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(2, gt(r, 0xF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(1, gt(r, 0x3))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := gt(r, 0x1)\n      msb := or(msb, f)\n    }\n\n    if (msb >= 128) r = ratio >> (msb - 127);\n    else r = ratio << (127 - msb);\n\n    int256 log_2 = (int256(msb) - 128) << 64;\n\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(63, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(62, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(61, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(60, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(59, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(58, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(57, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(56, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(55, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(54, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(53, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(52, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(51, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(50, f))\n    }\n\n    tick = _getFinalTick(log_2, sqrtPriceX96);\n  }\n\n  function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    // 128.128 number\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\n\n    int24 tickLow =\n    int24(\n      (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\n    );\n    int24 tickHi =\n    int24(\n      (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\n    );\n\n    tick = (tickLow == tickHi)\n    ? tickLow\n    : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\n    ? tickHi\n    : tickLow);\n  }\n\n  function _getPositionId(PoolPosition memory position) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(position.owner, position.lowerTick, position.upperTick));\n  }\n\n  function _countDigits(uint n) internal pure returns (uint) {\n    if (n == 0) {\n      return 0;\n    }\n    uint count = 0;\n    while (n != 0) {\n      n = n / 10;\n      ++count;\n    }\n    return count;\n  }\n\n  function _min(uint a, uint b) internal pure returns (uint) {\n    return a < b ? a : b;\n  }\n\n  function _max(uint a, uint b) internal pure returns (uint) {\n    return a > b ? a : b;\n  }\n\n  function _toUint128(uint x) private pure returns (uint128 y) {\n    require((y = uint128(x)) == x);\n  }\n}\n"
    },
    "contracts/test/BalancerComposableStableStrategyAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/balancer/BalancerComposableStableStrategy.sol\";\n\n/// @notice Provide direct access to BalancerComposableStableStrategy internal functions\ncontract BalancerComposableStableStrategyAccess is BalancerComposableStableStrategy {\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  ///  Set up\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function setBaseAmountAccess(address token_, uint amount_) external {\n    baseAmounts[token_] = amount_;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  ///  Access to internal functions\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function _depositToPoolAccess(uint amount_, bool updateTotalAssetsBeforeInvest_) external returns (\n    int totalAssetsDelta\n  ) {\n    return _depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n  }\n\n  function _withdrawFromPoolAccess(uint amount) external returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    return _withdrawFromPool(amount);\n  }\n\n  function _withdrawAllFromPoolAccess() external returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    return _withdrawAllFromPool();\n  }\n}"
    },
    "contracts/test/MockConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../strategies/ConverterStrategyBase.sol\";\nimport \"./MockDepositor.sol\";\n\n/// @title Mock Converter Strategy with MockDepositor\n/// @author bogdoslav\ncontract MockConverterStrategy is ConverterStrategyBase, MockDepositor {\n\n  string public constant override NAME = \"mock converter strategy\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address[] memory depositorTokens_,\n    uint[] memory depositorWeights_,\n    uint[] memory depositorReserves_\n  ) external initializer {\n\n    __MockDepositor_init(\n      depositorTokens_,\n      depositorWeights_,\n      depositorReserves_\n    );\n\n    __ConverterStrategyBase_init(\n      controller_,\n      splitter_,\n      converter_\n    );\n  }\n\n\n  //////////////////////////////////////////////////////////////////////\n  ///    Provide direct access to internal functions for tests\n  //////////////////////////////////////////////////////////////////////\n  function _updateBaseAmountsAccess(\n    address[] memory tokens_,\n    uint[] memory receivedAmounts_,\n    uint[] memory spentAmounts_,\n    uint indexAsset_,\n    int amountAsset_\n  ) external {\n    return _updateBaseAmounts(tokens_, receivedAmounts_, spentAmounts_, indexAsset_, amountAsset_);\n  }\n\n  function _convertAfterWithdrawAccess(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.convertAfterWithdraw(\n      converter,\n      ITetuLiquidator(IController(controller()).liquidator()),\n      liquidationThresholds[tokens_[indexAsset_]],\n      tokens_,\n      indexAsset_,\n      amountsToConvert_\n    );\n  }\n\n  function _convertAfterWithdrawAllAccess(\n    address[] memory tokens_,\n    uint indexAsset_\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return _convertAfterWithdrawAll(tokens_, indexAsset_);\n  }\n\n  function closePositionTestAccess(address collateralAsset, address borrowAsset, uint amountToRepay) external returns (\n    uint returnedAssetAmount,\n    uint leftover\n  ) {\n    return ConverterStrategyBaseLib.closePosition(converter, collateralAsset, borrowAsset, amountToRepay);\n  }\n\n  function updateInvestedAssetsTestAccess() external {\n    _updateInvestedAssets();\n  }\n\n  function withdrawUniversalTestAccess(uint amount, bool all, uint investedAssets_) external returns (\n    uint investedAssetsUSD,\n    uint assetPrice\n  ) {\n    return _withdrawUniversal(amount, all, investedAssets_);\n  }\n\n  function _doHardWorkAccess(bool reInvest) external returns (uint earned, uint lost) {\n    return _doHardWork(reInvest);\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// _handleRewards, mocked version + accessor\n  /////////////////////////////////////////////////////////////////////////////////////\n  function _handleRewards() internal override returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    if (handleRewardsParams.initialized) {\n      //      console.log(\"_handleRewards.mocked-version is called\");\n      if (handleRewardsParams.assetBalanceChange > 0) {\n        IERC20(asset).transferFrom(\n          handleRewardsParams.providerBalanceChange,\n          address(this),\n          uint(handleRewardsParams.assetBalanceChange)\n        );\n      } else if (handleRewardsParams.assetBalanceChange < 0) {\n        IERC20(asset).transfer(\n          handleRewardsParams.providerBalanceChange,\n          uint(- handleRewardsParams.assetBalanceChange)\n        );\n      }\n      return (handleRewardsParams.earned, handleRewardsParams.lost, _balance(asset));\n    } else {\n      return super._handleRewards();\n    }\n  }\n\n  struct MockedHandleRewardsParams {\n    bool initialized;\n    uint earned;\n    uint lost;\n    int assetBalanceChange;\n    address providerBalanceChange;\n  }\n\n  MockedHandleRewardsParams private handleRewardsParams;\n\n  function setMockedHandleRewardsResults(\n    uint earned,\n    uint lost,\n    int assetBalanceChange,\n    address providerBalanceChange\n  ) external {\n    handleRewardsParams = MockedHandleRewardsParams({\n        initialized: true,\n        earned: earned,\n        lost: lost,\n        assetBalanceChange: assetBalanceChange,\n        providerBalanceChange: providerBalanceChange\n    });\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// _depositToPool mock\n  /////////////////////////////////////////////////////////////////////////////////////\n  struct MockedDepositToPoolParams {\n    bool initialized;\n    int balanceChange;\n    address providerBalanceChange;\n    int totalAssetsDelta;\n  }\n\n  MockedDepositToPoolParams internal depositToPoolParams;\n\n  function _depositToPoolAccess(uint amount_, bool updateTotalAssetsBeforeInvest_) external returns (\n    int totalAssetsDelta\n  ) {\n    return _depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n  }\n\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    int totalAssetsDelta\n  ){\n    if (depositToPoolParams.initialized) {\n      //      console.log(\"_depositToPool.mocked-version is called\");\n      if (depositToPoolParams.balanceChange > 0) {\n        IERC20(asset).transferFrom(\n          depositToPoolParams.providerBalanceChange,\n          address(this),\n          uint(depositToPoolParams.balanceChange)\n        );\n      } else if (depositToPoolParams.balanceChange < 0) {\n        IERC20(asset).transfer(\n          depositToPoolParams.providerBalanceChange,\n          uint(- depositToPoolParams.balanceChange)\n        );\n      }\n      totalAssetsDelta = depositToPoolParams.totalAssetsDelta;\n    } else {\n      totalAssetsDelta = super._depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n    }\n  }\n\n  function setMockedDepositToPool(int balanceChange, address providerBalanceChange, int totalAssetsDelta_) external {\n    depositToPoolParams = MockedDepositToPoolParams({\n    initialized : true,\n    balanceChange : balanceChange,\n    providerBalanceChange : providerBalanceChange,\n    totalAssetsDelta : totalAssetsDelta_\n    });\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// Others\n  /////////////////////////////////////////////////////////////////////////////////////\n\n  function _beforeDepositAccess(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) external returns (\n    uint[] memory tokenAmounts,\n    uint[] memory borrowedAmounts,\n    uint spentCollateral\n  ) {\n    return _beforeDeposit(\n      tetuConverter_,\n      amount_,\n      tokens_,\n      indexAsset_\n    );\n  }\n\n  function setBaseAmountAccess(address token_, uint amount_) external {\n    baseAmounts[token_] = amount_;\n  }\n\n  function _emergencyExitFromPoolAccess() external {\n    _emergencyExitFromPool();\n  }\n\n  function _prepareRewardsListAccess(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    return ConverterStrategyBaseLib.prepareRewardsList(tetuConverter_, tokens_, rewardTokens_, rewardAmounts_, baseAmounts);\n  }\n\n  function _recycleAccess(address[] memory tokens, uint[] memory amounts) external returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    return _recycle(tokens, amounts);\n  }\n}\n"
    },
    "contracts/test/MockDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/DepositorBase.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/IMockToken.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\n// import \"hardhat/console.sol\";\n\n/// @title Mock contract for base Depositor.\ncontract MockDepositor is DepositorBase, Initializable {\n\n  uint[] private _depositorReserves;\n  uint[] private _depositorWeights;\n\n  address[] private _depositorAssets;\n\n  /// @notice total amount of active LP tokens.\n  uint public totalSupply;\n  uint private depositorLiquidity;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  // @notice tokens must be MockTokens\n  function __MockDepositor_init(\n    address[] memory tokens_,\n    uint[] memory depositorWeights_,\n    uint[] memory depositorReserves_\n  ) internal onlyInitializing {\n    uint tokensLength = tokens_.length;\n    for (uint i = 0; i < tokensLength; ++i) {\n      _depositorAssets.push(tokens_[i]);\n      _depositorWeights.push(depositorWeights_[i]);\n      _depositorReserves.push(depositorReserves_[i]);\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorTotalSupply\n  /////////////////////////////////////////////////////////////////////\n  function setTotalSupply(uint totalSupply_) external {\n    totalSupply = totalSupply_;\n  }\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() override internal view returns (uint) {\n    return totalSupply;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorLiquidity\n  /////////////////////////////////////////////////////////////////////\n\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return depositorLiquidity;\n  }\n\n  function setDepositorLiquidity(uint depositorLiquidity_) external {\n    depositorLiquidity = depositorLiquidity_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Misc\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Returns pool assets\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory) {\n    //    console.log(\"_depositorPoolAssets\");\n    return _depositorAssets;\n  }\n\n  /// @dev Returns pool weights\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    //    console.log(\"_depositorPoolWeights\", _depositorWeights.length);\n    weights = _depositorWeights;\n    uint len = weights.length;\n    totalWeight = 0;\n    for (uint i; i < len; i++) {\n      totalWeight += weights[i];\n    }\n  }\n\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    reserves = _depositorReserves;\n  }\n\n  function setDepositorPoolReserves(uint[] memory depositorReserves_) external {\n    _depositorReserves = depositorReserves_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorEnter\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorEnterParams {\n    uint[] amountsDesired;\n    uint[] amountsConsumed;\n    uint liquidityOut;\n  }\n\n  DepositorEnterParams internal depositorEnterParams;\n\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  ) {\n    require(_depositorAssets.length == amountsDesired_.length);\n\n    uint len = amountsDesired_.length;\n    amountsConsumed = depositorEnterParams.amountsConsumed;\n\n    for (uint i = 0; i < len; ++i) {\n      require(amountsDesired_[i] == depositorEnterParams.amountsDesired[i], \"!depositorEnter\");\n      IMockToken token = IMockToken(_depositorAssets[i]);\n      token.burn(address(this), depositorEnterParams.amountsConsumed[i]);\n    }\n\n    liquidityOut = depositorEnterParams.liquidityOut;\n    depositorLiquidity += liquidityOut;\n  }\n\n  function setDepositorEnter(uint[] memory amountsDesired_, uint[] memory amountsConsumed_, uint liquidityOut_) external {\n    depositorEnterParams.liquidityOut = liquidityOut_;\n    depositorEnterParams.amountsDesired = amountsDesired_;\n    depositorEnterParams.amountsConsumed = amountsConsumed_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorExit\n  /////////////////////////////////////////////////////////////////////\n\n  struct DepositorExitParams {\n    uint liquidityAmount;\n    uint[] amountsOut;\n  }\n\n  DepositorExitParams internal depositorExitParams;\n\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    require(liquidityAmount == depositorExitParams.liquidityAmount, \"!depositorExit\");\n\n    uint len = _depositorAssets.length;\n    amountsOut = depositorExitParams.amountsOut;\n\n    for (uint i = 0; i < len; ++i) {\n      IMockToken token = IMockToken(_depositorAssets[i]);\n      token.mint(address(this), depositorExitParams.amountsOut[i]);\n    }\n\n    // we need to modify depositorLiquidity for tests with _updateInvestedAssets\n    if (depositorLiquidity >= liquidityAmount) {\n      depositorLiquidity -= liquidityAmount;\n    }\n  }\n\n  function setDepositorExit(uint liquidityAmount_, uint[] memory amountsOut_) external {\n    //    console.log(\"MockDepositor.setDepositorExit liquidityAmount\", liquidityAmount_);\n    depositorExitParams.liquidityAmount = liquidityAmount_;\n    depositorExitParams.amountsOut = amountsOut_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorQuoteExit\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorQuoteExitParams {\n    uint liquidityAmount;\n    uint[] amountsOut;\n  }\n  /// @notice keccak256(liquidityAmount + 1) => results\n  mapping(bytes32 => DepositorQuoteExitParams) internal depositorQuoteExitParams;\n\n  /// @dev Quotes output for given lp amount from the pool.\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual view returns (uint[] memory amountsOut) {\n    bytes32 key = keccak256(abi.encodePacked(liquidityAmount + 1));\n    DepositorQuoteExitParams memory p = depositorQuoteExitParams[key];\n    if (p.liquidityAmount == liquidityAmount) {\n      amountsOut = p.amountsOut;\n    } else {\n      //console.log(\"_depositorQuoteExit.missed liquidityAmount\", liquidityAmount);\n      revert(\"MockDepositor.!liquidityAmount\");\n    }\n\n    return amountsOut;\n  }\n\n  function setDepositorQuoteExit(uint liquidityAmount_, uint[] memory amountsOut_) external {\n    //    console.log(\"setDepositorQuoteExit, liquidityAmount_\", liquidityAmount_);\n    bytes32 key = keccak256(abi.encodePacked(liquidityAmount_ + 1));\n\n    DepositorQuoteExitParams memory p = DepositorQuoteExitParams({\n    liquidityAmount : liquidityAmount_,\n    amountsOut : amountsOut_\n    });\n\n    depositorQuoteExitParams[key] = p;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorClaimRewards\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorClaimRewardsParams {\n    address[] rewardTokens;\n    uint[] rewardAmounts;\n  }\n\n  DepositorClaimRewardsParams internal depositorClaimRewardsParams;\n\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts\n  ) {\n    uint len = depositorClaimRewardsParams.rewardTokens.length;\n    rewardTokens = depositorClaimRewardsParams.rewardTokens;\n    rewardAmounts = depositorClaimRewardsParams.rewardAmounts;\n\n    for (uint i = 0; i < len; ++i) {\n      IMockToken token = IMockToken(depositorClaimRewardsParams.rewardTokens[i]);\n      token.mint(address(this), depositorClaimRewardsParams.rewardAmounts[i]);\n    }\n    return (rewardTokens, rewardAmounts);\n  }\n\n  function setDepositorClaimRewards(address[] memory rewardTokens_, uint[] memory rewardAmounts_) external {\n    depositorClaimRewardsParams.rewardTokens = rewardTokens_;\n    depositorClaimRewardsParams.rewardAmounts = rewardAmounts_;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 150
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}