{
  "language": "Solidity",
  "sources": {
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IControllable {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IController {\n\n  // --- DEPENDENCY ADDRESSES\n  function governance() external view returns (address);\n\n  function voter() external view returns (address);\n\n  function liquidator() external view returns (address);\n\n  function forwarder() external view returns (address);\n\n  function investFund() external view returns (address);\n\n  function veDistributor() external view returns (address);\n\n  function platformVoter() external view returns (address);\n\n  // --- VAULTS\n\n  function vaults(uint id) external view returns (address);\n\n  function vaultsList() external view returns (address[] memory);\n\n  function vaultsListLength() external view returns (uint);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  // --- restrictions\n\n  function isOperator(address _adr) external view returns (bool);\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n     */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n     */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IForwarder {\n\n  function tetu() external view returns (address);\n  function tetuThreshold() external view returns (uint);\n\n  function tokenPerDestinationLength(address destination) external view returns (uint);\n\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\n\n  function amountPerDestination(address token, address destination) external view returns (uint amount);\n\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vault,\n    bool isDistribute\n  ) external;\n\n  function distributeAll(address destination) external;\n\n  function distribute(address token) external;\n\n  function setInvestFundRatio(uint value) external;\n\n  function setGaugesRatio(uint value) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISplitter {\n\n  function init(address controller_, address _asset, address _vault) external;\n\n  // *************** ACTIONS **************\n\n  function withdrawAllToVault() external;\n\n  function withdrawToVault(uint256 amount) external;\n\n  function coverPossibleStrategyLoss(uint earned, uint lost) external;\n\n  function doHardWork() external;\n\n  function investAll() external;\n\n  // **************** VIEWS ***************\n\n  function asset() external view returns (address);\n\n  function vault() external view returns (address);\n\n  function totalAssets() external view returns (uint256);\n\n  function isHardWorking() external view returns (bool);\n\n  function strategies(uint i) external view returns (address);\n\n  function strategiesLength() external view returns (uint);\n\n  function HARDWORK_DELAY() external view returns (uint);\n\n  function lastHardWorks(address strategy) external view returns (uint);\n\n  function pausedStrategies(address strategy) external view returns (bool);\n\n  function pauseInvesting(address strategy) external;\n\n  function continueInvesting(address strategy, uint apr) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IStrategyV2 {\n\n  function NAME() external view returns (string memory);\n\n  function strategySpecificName() external view returns (string memory);\n\n  function PLATFORM() external view returns (string memory);\n\n  function STRATEGY_VERSION() external view returns (string memory);\n\n  function asset() external view returns (address);\n\n  function splitter() external view returns (address);\n\n  function compoundRatio() external view returns (uint);\n\n  function totalAssets() external view returns (uint);\n\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\n  function isReadyToHardWork() external view returns (bool);\n\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawAllToSplitter() external returns (uint strategyLoss);\n\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawToSplitter(uint amount) external returns (uint strategyLoss);\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external returns (\n    uint strategyLoss\n  );\n\n  function doHardWork() external returns (uint earned, uint lost);\n\n  function setCompoundRatio(uint value) external;\n\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\n  ///         0 means no deposit is allowed at this moment\n  function capacity() external view returns (uint);\n\n  /// @notice {performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\n  function performanceReceiver() external view returns (address);\n\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\n  /// @dev use FEE_DENOMINATOR\n  function performanceFee() external view returns (uint);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ITetuLiquidator {\n\n  struct PoolData {\n    address pool;\n    address swapper;\n    address tokenIn;\n    address tokenOut;\n  }\n\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\n\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\n\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\n\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint slippage\n  ) external;\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint slippage\n  ) external;\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IVaultInsurance.sol\";\nimport \"./IERC20.sol\";\nimport \"./ISplitter.sol\";\n\ninterface ITetuVaultV2 {\n\n  function splitter() external view returns (ISplitter);\n\n  function insurance() external view returns (IVaultInsurance);\n\n  function depositFee() external view returns (uint);\n\n  function withdrawFee() external view returns (uint);\n\n  function init(\n    address controller_,\n    IERC20 _asset,\n    string memory _name,\n    string memory _symbol,\n    address _gauge,\n    uint _buffer\n  ) external;\n\n  function setSplitter(address _splitter) external;\n\n  function coverLoss(uint amount) external;\n\n  function initInsurance(IVaultInsurance _insurance) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVaultInsurance {\n\n  function init(address _vault, address _asset) external;\n\n  function vault() external view returns (address);\n\n  function asset() external view returns (address);\n\n  function transferToVault(uint amount) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/InterfaceIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for interface IDs\n/// @author bogdoslav\nlibrary InterfaceIds {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant INTERFACE_IDS_LIB_VERSION = \"1.0.0\";\n\n  /// default notation:\n  /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\n\n  /// As type({Interface}).interfaceId can be changed,\n  /// when some functions changed at the interface,\n  /// so used hardcoded interface identifiers\n\n  bytes4 public constant I_VOTER = bytes4(keccak256(\"IVoter\"));\n  bytes4 public constant I_BRIBE = bytes4(keccak256(\"IBribe\"));\n  bytes4 public constant I_GAUGE = bytes4(keccak256(\"IGauge\"));\n  bytes4 public constant I_VE_TETU = bytes4(keccak256(\"IVeTetu\"));\n  bytes4 public constant I_SPLITTER = bytes4(keccak256(\"ISplitter\"));\n  bytes4 public constant I_FORWARDER = bytes4(keccak256(\"IForwarder\"));\n  bytes4 public constant I_MULTI_POOL = bytes4(keccak256(\"IMultiPool\"));\n  bytes4 public constant I_CONTROLLER = bytes4(keccak256(\"IController\"));\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\"ITetuERC165\"));\n  bytes4 public constant I_STRATEGY_V2 = bytes4(keccak256(\"IStrategyV2\"));\n  bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\"IControllable\"));\n  bytes4 public constant I_TETU_VAULT_V2 = bytes4(keccak256(\"ITetuVaultV2\"));\n  bytes4 public constant I_PLATFORM_VOTER = bytes4(keccak256(\"IPlatformVoter\"));\n  bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\"IVeDistributor\"));\n  bytes4 public constant I_TETU_CONVERTER = bytes4(keccak256(\"ITetuConverter\"));\n  bytes4 public constant I_VAULT_INSURANCE = bytes4(keccak256(\"IVaultInsurance\"));\n  bytes4 public constant I_STRATEGY_STRICT = bytes4(keccak256(\"IStrategyStrict\"));\n  bytes4 public constant I_ERC4626 = bytes4(keccak256(\"IERC4626\"));\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  /// @dev Gets a slot array by index as uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  // ************* ARRAY SETTERS *******************\n\n  /// @dev Sets a slot array at index with address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, address value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets a slot array at index with uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, uint value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets an array length\n  function setLength(bytes32 slot, uint length) internal {\n    assembly {\n      sstore(slot, length)\n    }\n  }\n\n  /// @dev Pushes an address to the array\n  function push(bytes32 slot, address value) internal {\n    uint length = arrayLength(slot);\n    setAt(slot, length, value);\n    setLength(slot, length + 1);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n\nlibrary StringLib {\n\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n  function toString(uint value) external pure returns (string memory) {\n    return _toString(value);\n  }\n\n  function _toString(uint value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint temp = value;\n    uint digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  function toAsciiString(address x) external pure returns (string memory) {\n    return _toAsciiString(x);\n  }\n\n  function _toAsciiString(address x) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = _char(hi);\n      s[2 * i + 1] = _char(lo);\n    }\n    return string(s);\n  }\n\n  function char(bytes1 b) external pure returns (bytes1 c) {\n    return _char(b);\n  }\n\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n    else return bytes1(uint8(b) + 0x57);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n     */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n  uint8 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n     */\n  bool private _initializing;\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n  event Initialized(uint8 version);\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n      \"Initializable: contract is already initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n      emit Initialized(1);\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier reinitializer(uint8 version) {\n    require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n    emit Initialized(version);\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n  modifier onlyInitializing() {\n    require(_initializing, \"Initializable: contract is not initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Initializable: contract is initializing\");\n    if (_initialized != type(uint8).max) {\n      _initialized = type(uint8).max;\n      emit Initialized(type(uint8).max);\n    }\n  }\n\n  /**\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n  function _getInitializedVersion() internal view returns (uint8) {\n    return _initialized;\n  }\n\n  /**\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n  function _isInitializing() internal view returns (bool) {\n    return _initializing;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n     */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n     */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(x, y, not(0))\n      prod0 := mul(x, y)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n      return prod0 / denominator;\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    require(denominator > prod1, \"Math: mulDiv overflow\");\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly {\n    // Compute remainder using mulmod.\n      remainder := mulmod(x, y, denominator)\n\n    // Subtract 256 bit number from 512 bit number.\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n    // See https://cs.stackexchange.com/q/138556/92363.\n\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\n    uint256 twos = denominator & (~denominator + 1);\n    assembly {\n    // Divide denominator by twos.\n      denominator := div(denominator, twos)\n\n    // Divide [prod1 prod0] by twos.\n      prod0 := div(prod0, twos)\n\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n\n    // Shift in bits from prod1 into prod0.\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n    // four bits. That is, denominator * inv = 1 mod 2^4.\n    uint256 inverse = (3 * denominator) ^ 2;\n\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n    // in modular arithmetic, doubling the correct bits in each step.\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inverse;\n    return result;\n  }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator,\n    Rounding rounding\n  ) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n  unchecked {\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    return min(result, a / result);\n  }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = sqrt(a);\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 128;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 64;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 32;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 16;\n    }\n    if (value >> 8 > 0) {\n      value >>= 8;\n      result += 8;\n    }\n    if (value >> 4 > 0) {\n      value >>= 4;\n      result += 4;\n    }\n    if (value >> 2 > 0) {\n      value >>= 2;\n      result += 2;\n    }\n    if (value >> 1 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log2(value);\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >= 10**64) {\n      value /= 10**64;\n      result += 64;\n    }\n    if (value >= 10**32) {\n      value /= 10**32;\n      result += 32;\n    }\n    if (value >= 10**16) {\n      value /= 10**16;\n      result += 16;\n    }\n    if (value >= 10**8) {\n      value /= 10**8;\n      result += 8;\n    }\n    if (value >= 10**4) {\n      value /= 10**4;\n      result += 4;\n    }\n    if (value >= 10**2) {\n      value /= 10**2;\n      result += 2;\n    }\n    if (value >= 10**1) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log10(value);\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 16;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 8;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 4;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 2;\n    }\n    if (value >> 8 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log256(value);\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n  }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n  unchecked {\n    uint256 oldAllowance = token.allowance(address(this), spender);\n    require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n    uint256 newAllowance = oldAllowance - value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/ControllableV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/SlotsLib.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"3.0.0\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  /// @dev Prevent implementation init\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) internal onlyInitializing {\n    require(controller_ != address(0), \"Zero controller\");\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\n    require(IController(controller_).governance() != address(0), \"Zero governance\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address _value) public override view returns (bool) {\n    return _value == controller();\n  }\n\n  /// @notice Return true if given address is setup as governance in Controller\n  function isGovernance(address _value) public override view returns (bool) {\n    return IController(controller()).governance() == _value;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view returns (uint){\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view returns (address){\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return controller address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./StrategyLib.sol\";\n\n/// @title Abstract contract for base strategy functionality\n/// @author belbix\nabstract contract StrategyBaseV2 is IStrategyV2, ControllableV3 {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant STRATEGY_BASE_VERSION = \"2.3.0\";\n  /// @notice 10% of total profit is sent to {performanceReceiver} before compounding\n  uint internal constant DEFAULT_PERFORMANCE_FEE = 10_000;\n  address internal constant DEFAULT_PERF_FEE_RECEIVER = 0x9Cc199D4353b5FB3e6C8EEBC99f5139e0d8eA06b;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Linked splitter\n  address public override splitter;\n  /// @dev Percent of profit for autocompound inside this strategy.\n  uint public override compoundRatio;\n  uint private __deprecatedSlot1;\n\n  /// @notice {performanceFee}% of total profit is sent to {performanceReceiver} before compounding\n  /// @dev governance by default\n  address public override performanceReceiver;\n\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\n  /// @dev {DEFAULT_PERFORMANCE_FEE} by default, FEE_DENOMINATOR is used\n  uint public override performanceFee;\n  /// @dev Represent specific name for this strategy. Should include short strategy name and used assets. Uniq across the vault.\n  string public override strategySpecificName;\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __StrategyBase_init(\n    address controller_,\n    address _splitter\n  ) internal onlyInitializing {\n    _requireInterface(_splitter, InterfaceIds.I_SPLITTER);\n    __Controllable_init(controller_);\n\n    require(IControllable(_splitter).isController(controller_), StrategyLib.WRONG_VALUE);\n\n    asset = ISplitter(_splitter).asset();\n    splitter = _splitter;\n\n    performanceReceiver = DEFAULT_PERF_FEE_RECEIVER;\n    performanceFee = DEFAULT_PERFORMANCE_FEE;\n  }\n\n  // *************************************************************\n  //                     PERFORMANCE FEE\n  // *************************************************************\n  /// @notice Set performance fee and receiver\n  function setupPerformanceFee(uint fee_, address receiver_) external {\n    StrategyLib._checkSetupPerformanceFee(controller(), fee_, receiver_);\n    performanceFee = fee_;\n    performanceReceiver = receiver_;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of underlying assets under control of this strategy.\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this)) + investedAssets();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_STRATEGY_V2 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                   VOTER ACTIONS\n  // *************************************************************\n\n  /// @dev PlatformVoter can change compound ratio for some strategies.\n  ///      A strategy can implement another logic for some uniq cases.\n  function setCompoundRatio(uint value) external virtual override {\n    StrategyLib._checkCompoundRatioChanged(controller(), compoundRatio, value);\n    compoundRatio = value;\n  }\n\n  // *************************************************************\n  //                   OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev The name will be used for UI.\n  function setStrategySpecificName(string calldata name) external {\n    StrategyLib._checkStrategySpecificNameChanged(controller(), name);\n    strategySpecificName = name;\n  }\n\n  /// @dev In case of any issue operator can withdraw all from pool.\n  function emergencyExit() external {\n    // check inside lib call\n\n    _emergencyExitFromPool();\n    StrategyLib.sendOnEmergencyExit(controller(), asset, splitter);\n  }\n\n  /// @dev Manual claim rewards.\n  function claim() external {\n    StrategyLib._checkManualClaim(controller());\n    _claim();\n  }\n\n  // *************************************************************\n  //                    DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function investAll(\n    uint /*amount_*/,\n    bool updateTotalAssetsBeforeInvest_\n  ) external override returns (\n    uint strategyLoss\n  ) {\n    uint balance = StrategyLib._checkInvestAll(splitter, asset);\n\n    if (balance > 0) {\n      strategyLoss = _depositToPool(balance, updateTotalAssetsBeforeInvest_);\n    }\n\n    return strategyLoss;\n  }\n\n  /// @dev Withdraws all underlying assets to the vault\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawAllToSplitter() external override returns (uint strategyLoss) {\n    address _splitter = splitter;\n    address _asset = asset;\n\n    uint balance = StrategyLib._checkSplitterSenderAndGetBalance(_splitter, _asset);\n\n    (uint expectedWithdrewUSD, uint assetPrice, uint _strategyLoss) = _withdrawAllFromPool();\n\n    StrategyLib._withdrawAllToSplitterPostActions(\n      _asset,\n      balance,\n      expectedWithdrewUSD,\n      assetPrice,\n      _splitter\n    );\n    return _strategyLoss;\n  }\n\n  /// @dev Withdraws some assets to the splitter\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawToSplitter(uint amount) external override returns (uint strategyLoss) {\n    address _splitter = splitter;\n    address _asset = asset;\n\n    uint balance = StrategyLib._checkSplitterSenderAndGetBalance(_splitter, _asset);\n\n    if (amount > balance) {\n      uint expectedWithdrewUSD;\n      uint assetPrice;\n\n      (expectedWithdrewUSD, assetPrice, strategyLoss) = _withdrawFromPool(amount - balance);\n      balance = StrategyLib.checkWithdrawImpact(\n        _asset,\n        balance,\n        expectedWithdrewUSD,\n        assetPrice,\n        _splitter\n      );\n    }\n\n    StrategyLib._withdrawToSplitterPostActions(\n      amount,\n      balance,\n      _asset,\n      _splitter\n    );\n    return strategyLoss;\n  }\n\n  // *************************************************************\n  //                       VIRTUAL\n  // These functions must be implemented in the strategy contract\n  // *************************************************************\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _depositToPool(\n    uint amount,\n    bool updateTotalAssetsBeforeInvest_\n  ) internal virtual returns (\n    uint strategyLoss\n  );\n\n  /// @dev Withdraw given amount from the pool.\n  /// @return expectedWithdrewUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawFromPool(uint amount) internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  );\n\n  /// @dev Withdraw all from the pool.\n  /// @return expectedWithdrewUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawAllFromPool() internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  );\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  ///      Withdraw assets without impact checking.\n  function _emergencyExitFromPool() internal virtual;\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal virtual returns (address[] memory rewardTokens, uint[] memory amounts);\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  ///      variables without shifting down storage in the inheritance chain.\n  ///      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[43] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\n\nlibrary StrategyLib {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Denominator for fee calculation.\n  uint internal constant FEE_DENOMINATOR = 100_000;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event CompoundRatioChanged(uint oldValue, uint newValue);\n  event StrategySpecificNameChanged(string name);\n  event EmergencyExit(address sender, uint amount);\n  event ManualClaim(address sender);\n  event InvestAll(uint balance);\n  event WithdrawAllToSplitter(uint amount);\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\n\n  // *************************************************************\n  //                        ERRORS\n  // *************************************************************\n\n  string internal constant DENIED = \"SB: Denied\";\n  string internal constant TOO_HIGH = \"SB: Too high\";\n  string internal constant WRONG_VALUE = \"SB: Wrong value\";\n  /// @dev Denominator for compound ratio\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n\n  // *************************************************************\n  //                        CHECKS AND EMITS\n  // *************************************************************\n\n  function _checkCompoundRatioChanged(address controller, uint oldValue, uint newValue) external {\n    onlyPlatformVoter(controller);\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\n    emit CompoundRatioChanged(oldValue, newValue);\n  }\n\n  function _checkStrategySpecificNameChanged(address controller, string calldata newName) external {\n    onlyOperators(controller);\n    emit StrategySpecificNameChanged(newName);\n  }\n\n  function _checkManualClaim(address controller) external {\n    onlyOperators(controller);\n    emit ManualClaim(msg.sender);\n  }\n\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\n    onlySplitter(splitter);\n    assetBalance = IERC20(asset).balanceOf(address(this));\n    emit InvestAll(assetBalance);\n  }\n\n  // *************************************************************\n  //                     RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Restrict access only for operators\n  function onlyOperators(address controller) public view {\n    require(IController(controller).isOperator(msg.sender), DENIED);\n  }\n\n  /// @dev Restrict access only for governance\n  function onlyGovernance(address controller) public view {\n    require(IController(controller).governance() == msg.sender, DENIED);\n  }\n\n  /// @dev Restrict access only for platform voter\n  function onlyPlatformVoter(address controller) public view {\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\n  }\n\n  /// @dev Restrict access only for splitter\n  function onlySplitter(address splitter) public view {\n    require(splitter == msg.sender, DENIED);\n  }\n\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_) external view {\n    onlyGovernance(controller);\n    require(fee_ <= 100_000, TOO_HIGH);\n    require(receiver_ != address(0), WRONG_VALUE);\n  }\n\n  // *************************************************************\n  //                       HELPERS\n  // *************************************************************\n\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\n  ///         Revert if the amount is different from expected too much (high price impact)\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\n  /// @param assetPrice Price of the asset, decimals 18\n  /// @return balance Current asset balance of the strategy\n  function checkWithdrawImpact(\n    address _asset,\n    uint balanceBefore,\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    address _splitter\n  ) public view returns (uint balance) {\n    balance = IERC20(_asset).balanceOf(address(this));\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\n\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\n    }\n  }\n\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\n    onlyOperators(controller);\n\n    uint balance = IERC20(asset).balanceOf(address(this));\n    IERC20(asset).safeTransfer(splitter, balance);\n    emit EmergencyExit(msg.sender, balance);\n  }\n\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\n    onlySplitter(splitter);\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  function _withdrawAllToSplitterPostActions(\n    address _asset,\n    uint balanceBefore,\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    address _splitter\n  ) external {\n    uint balance = checkWithdrawImpact(\n      _asset,\n      balanceBefore,\n      expectedWithdrewUSD,\n      assetPrice,\n      _splitter\n    );\n\n    if (balance != 0) {\n      IERC20(_asset).safeTransfer(_splitter, balance);\n    }\n    emit WithdrawAllToSplitter(balance);\n  }\n\n  function _withdrawToSplitterPostActions(\n    uint amount,\n    uint balance,\n    address _asset,\n    address _splitter\n  ) external {\n    uint amountAdjusted = Math.min(amount, balance);\n    if (amountAdjusted != 0) {\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\n    }\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/IMockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IMockToken {\n\n  function decimals() external view returns (uint8);\n\n  function mint(address to, uint amount) external;\n\n  function burn(address from, uint amount) external;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/tools/TetuERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC165.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\n/// @author bogdoslav\nabstract contract TetuERC165 is ERC165 {\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        HELPER FUNCTIONS\n  // *************************************************************\n  /// @author bogdoslav\n\n  /// @dev Checks what interface with id is supported by contract.\n  /// @return bool. Do not throws\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\n      return isSupported;\n    } catch {\n    }\n    return false;\n  }\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\n    require(_isInterfaceSupported(contractAddress, interfaceId), \"Interface is not supported\");\n  }\n\n  /// @dev Checks what address is ERC20.\n  /// @return bool. Do not throws\n  function _isERC20(address contractAddress) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    bool totalSupplySupported;\n    try IERC20(contractAddress).totalSupply() returns (uint) {\n      totalSupplySupported = true;\n    } catch {\n    }\n\n    bool balanceSupported;\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\n      balanceSupported = true;\n    } catch {\n    }\n\n    return totalSupplySupported && balanceSupported;\n  }\n\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireERC20(address contractAddress) internal view {\n    require(_isERC20(contractAddress), \"Not ERC20\");\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/core/BorrowManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../libs/AppDataTypes.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppUtils.sol\";\nimport \"../openzeppelin/Clones.sol\";\nimport \"../openzeppelin/IERC20.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../openzeppelin/EnumerableMap.sol\";\nimport \"../openzeppelin/IERC20Metadata.sol\";\nimport \"../interfaces/IPlatformAdapter.sol\";\nimport \"../interfaces/IBorrowManager.sol\";\nimport \"../interfaces/IPriceOracle.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IDebtMonitor.sol\";\nimport \"../interfaces/ITetuConverter.sol\";\nimport \"../integrations/market/ICErc20.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @notice Contains list of lending pools. Allow to select most efficient pool for the given collateral/borrow pair\ncontract BorrowManager is IBorrowManager, ControllableV3 {\n  using SafeERC20 for IERC20;\n  using AppUtils for uint;\n  using Clones for address;\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using EnumerableSet for EnumerableSet.UintSet;\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\n\n  //region ----------------------------------------------------- Constants\n  string public constant BORROW_MANAGER_VERSION = \"1.0.0\";\n  /// @notice Reward APR is taken into account with given factor\n  ///         Result APR = borrow-apr - supply-apr - Factor/Denominator * rewards-APR\n  uint constant public REWARDS_FACTOR_DENOMINATOR_18 = 1e18;\n  //endregion ----------------------------------------------------- Constants\n\n  //region ----------------------------------------------------- Data types\n\n  /// @notice Pair of two assets. Asset 1 can be converted to asset 2 and vice versa.\n  /// @dev There are no restrictions for {assetLeft} and {assertRight}. Each can be smaller than the other.\n  struct AssetPair {\n    address assetLeft;\n    address assetRight;\n  }\n  //endregion ----------------------------------------------------- Data types\n\n  //region ----------------------------------------------------- Variables. Don't change names or ordering!\n\n  /// @notice Reward APR is taken into account with given factor\n  /// @dev decimals 18. The value is divided on {REWARDS_FACTOR_DENOMINATOR_18}\n  uint public rewardsFactor;\n\n  /// @notice all registered platform adapters\n  EnumerableSet.AddressSet private _platformAdapters;\n\n  /// @notice all asset pairs registered for the platform adapter\n  /// @dev PlatformAdapter : [key of asset pair]\n  mapping(address => EnumerableSet.UintSet) private _platformAdapterPairs;\n\n  /// @notice all platform adapters for which the asset pair is registered\n  /// @dev Key of pair asset => [list of platform adapters]\n  mapping(uint => EnumerableSet.AddressSet) private _pairsList;\n\n  /// @notice Key of pair asset => Asset pair\n  mapping(uint => AssetPair) private _assetPairs;\n\n  /// @notice Default health factors (HF) for assets. Default HF is used if user hasn't provided HF value, decimals 2\n  /// @dev asset => Health factor (== collateral / minimum collateral. It should be greater then MIN_HEALTH_FACTOR)\n  mapping(address => uint16) public targetHealthFactorsForAssets;\n\n  /// @notice Converter : platform adapter\n  mapping(address => address) public converterToPlatformAdapter;\n\n  /// @notice List of pool adapters ready to borrow, i.e. with not-dirty state.\n  ///         Any pool adapter with state DIRTY is removed from this list as soon as its dirty-state is detected.\n  /// @dev user => PoolAdapterKey(== keccak256(converter, collateral, borrowToken)) => address of the pool adapter\n  mapping (address => EnumerableMap.UintToAddressMap) private _poolAdapters;\n\n  /// @notice Pool adapter => (1 + index of the pool adapter in {listPoolAdapters})\n  /// @dev This list contains info for all ever created pool adapters (both for not-dirty and dirty ones).\n  mapping (address => uint) public poolAdaptersRegistered;\n\n  /// @notice List of addresses of all ever created pool adapters (both for not-dirty and dirty ones).\n  /// @dev Allow to get full list of the pool adapter and then filter it by any criteria (asset, user, state, etc)\n  address[] public listPoolAdapters;\n  //endregion ----------------------------------------------------- Variables. Don't change names or ordering!\n\n  //region ----------------------------------------------------- Events\n  event OnSetTargetHealthFactors(address[] assets, uint16[] healthFactors2);\n  event OnSetRewardsFactor(uint rewardsFactor);\n  event OnAddAssetPairs(address platformAdapter, address[] leftAssets, address[] rightAssets);\n  event OnRemoveAssetPairs(address platformAdapter, address[] leftAssets, address[] rightAssets);\n  event OnUnregisterPlatformAdapter(address platformAdapter);\n  event OnRegisterPoolAdapter(address poolAdapter, address converter, address user, address collateralAsset, address borrowAsset);\n  event OnMarkPoolAdapterAsDirty(address poolAdapter);\n  //endregion ----------------------------------------------------- Events\n\n  //region ----------------------------------------------------- Initialization\n\n  function init(address controller_, uint rewardsFactor_) external initializer {\n    __Controllable_init(controller_);\n\n    // we assume rewards amount should be downgraded in calcs coz liquidation gaps\n    require(rewardsFactor_ < REWARDS_FACTOR_DENOMINATOR_18, AppErrors.INCORRECT_VALUE);\n    rewardsFactor = rewardsFactor_;\n  }\n  //endregion ----------------------------------------------------- Initialization\n\n  //region ----------------------------------------------------- Access rights\n\n  /// @notice Ensure that msg.sender is registered pool adapter\n  function _onlyTetuConverter() internal view {\n    require(\n      msg.sender == IConverterController(controller()).tetuConverter(),\n      AppErrors.TETU_CONVERTER_ONLY\n    );\n  }\n\n  /// @notice Ensure that msg.sender is registered pool adapter\n  function _onlyGovernance() internal view {\n    require(msg.sender == IConverterController(controller()).governance(), AppErrors.GOVERNANCE_ONLY);\n  }\n  //endregion ----------------------------------------------------- Access rights\n\n  //region ----------------------------------------------------- Configuration\n\n  /// @notice Set target health factors for the assets.\n  ///         If target health factor is not assigned to the asset, target-health-factor from controller is used.\n  /// @param healthFactors2_ Health factor must be greater then 1, decimals 2\n  function setTargetHealthFactors(address[] calldata assets_, uint16[] calldata healthFactors2_) external override {\n    _onlyGovernance();\n    uint countItems = assets_.length;\n    require(countItems == healthFactors2_.length, AppErrors.WRONG_LENGTHS);\n\n    for (uint i = 0; i < countItems; i = i.uncheckedInc()) {\n      require(healthFactors2_[i] >= IConverterController(controller()).minHealthFactor2(), AppErrors.WRONG_HEALTH_FACTOR);\n      targetHealthFactorsForAssets[assets_[i]] = healthFactors2_[i];\n    }\n\n    emit OnSetTargetHealthFactors(assets_, healthFactors2_);\n  }\n\n  /// @notice Reward APR is taken into account with given factor\n  ///         Result APR = borrow-apr - supply-apr - [REWARD-FACTOR]/Denominator * rewards-APR\n  function setRewardsFactor(uint rewardsFactor_) external override {\n    _onlyGovernance();\n    require(rewardsFactor_ < REWARDS_FACTOR_DENOMINATOR_18, AppErrors.INCORRECT_VALUE);\n    rewardsFactor = rewardsFactor_;\n\n    emit OnSetRewardsFactor(rewardsFactor_);\n  }\n\n  /// @notice Register new lending platform with available pairs of assets\n  ///         OR add new pairs of assets to the exist lending platform\n  /// @param platformAdapter_ Implementation of IPlatformAdapter attached to the specified pool\n  /// @param leftAssets_  Supported pairs of assets. The pairs are set using two arrays: left and right\n  /// @param rightAssets_  Supported pairs of assets. The pairs are set using two arrays: left and right\n  function addAssetPairs(\n    address platformAdapter_,\n    address[] calldata leftAssets_,\n    address[] calldata rightAssets_\n  ) external override {\n    _onlyGovernance();\n\n    uint lenAssets = rightAssets_.length;\n    require(leftAssets_.length == lenAssets, AppErrors.WRONG_LENGTHS);\n\n    // register new platform adapter if necessary\n    _platformAdapters.add(platformAdapter_);\n\n    // register all available template pool adapters\n    address[] memory paConverters = IPlatformAdapter(platformAdapter_).converters();\n    uint lenConverters = paConverters.length;\n    for (uint i = 0; i < lenConverters; i = i.uncheckedInc()) {\n      // the relation \"platform adapter - converter\" is invariant\n      address platformAdapterForConverter = converterToPlatformAdapter[paConverters[i]];\n      if (platformAdapter_ != platformAdapterForConverter) {\n        require(platformAdapterForConverter == address(0), AppErrors.ONLY_SINGLE_PLATFORM_ADAPTER_CAN_USE_CONVERTER);\n        converterToPlatformAdapter[paConverters[i]] = platformAdapter_;\n      }\n    }\n\n    // register all provided asset pairs\n    for (uint i = 0; i < lenAssets; i = i.uncheckedInc()) {\n      uint assetPairKey = getAssetPairKey(leftAssets_[i], rightAssets_[i]);\n      if (_assetPairs[assetPairKey].assetLeft == address(0)) {\n        _assetPairs[assetPairKey] = AssetPair({\n          assetLeft: leftAssets_[i],\n          assetRight: rightAssets_[i]\n        });\n      }\n      _pairsList[assetPairKey].add(platformAdapter_);\n      _platformAdapterPairs[platformAdapter_].add(assetPairKey);\n    }\n\n    emit OnAddAssetPairs(platformAdapter_, leftAssets_, rightAssets_);\n  }\n\n  /// @notice Remove available pairs of asset from the platform adapter.\n  ///         The platform adapter will be unregistered after removing last supported pair of assets\n  function removeAssetPairs(\n    address platformAdapter_,\n    address[] calldata leftAssets_,\n    address[] calldata rightAssets_\n  ) external override {\n    _onlyGovernance();\n\n    uint lenAssets = rightAssets_.length;\n    require(leftAssets_.length == lenAssets, AppErrors.WRONG_LENGTHS);\n    require(_platformAdapters.contains(platformAdapter_), AppErrors.PLATFORM_ADAPTER_NOT_FOUND);\n    IDebtMonitor debtMonitor = IDebtMonitor(IConverterController(controller()).debtMonitor());\n\n    // unregister the asset pairs\n    for (uint i; i < lenAssets; i = i.uncheckedInc()) {\n      uint assetPairKey = getAssetPairKey(leftAssets_[i], rightAssets_[i]);\n      _pairsList[assetPairKey].remove(platformAdapter_);\n      _platformAdapterPairs[platformAdapter_].remove(assetPairKey);\n    }\n\n    // if platform adapter doesn't have any asset pairs, we unregister it\n    if (_platformAdapterPairs[platformAdapter_].length() == 0) {\n      // unregister all template pool adapters\n      address[] memory paConverters = IPlatformAdapter(platformAdapter_).converters();\n      uint lenConverters = paConverters.length;\n      for (uint i; i < lenConverters; i = i.uncheckedInc()) {\n        // If there is active pool adapter for the platform adapter, we cannot unregister the platform adapter\n        require(!debtMonitor.isConverterInUse(paConverters[i]), AppErrors.PLATFORM_ADAPTER_IS_IN_USE);\n        converterToPlatformAdapter[paConverters[i]] = address(0);\n      }\n\n      // unregister platform adapter\n      _platformAdapters.remove(platformAdapter_);\n      emit OnUnregisterPlatformAdapter(platformAdapter_);\n    }\n\n    emit OnRemoveAssetPairs(platformAdapter_, leftAssets_, rightAssets_);\n  }\n  //endregion ----------------------------------------------------- Configuration\n\n  //region ----------------------------------------------------- Find best pool for borrowing\n\n  /// @notice Find lending pool capable of providing {targetAmount} and having best normalized borrow rate\n  ///         Results are ordered in ascending order of APR, so the best available converter is first one.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                  See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  /// @param amountIn_ The meaning depends on entryData kind, see EntryKinds library for details.\n  ///         For entry kind = 0: Amount of {sourceToken} to be converted to {targetToken}\n  ///         For entry kind = 1: Available amount of {sourceToken}\n  ///         For entry kind = 2: Amount of {targetToken} that should be received after conversion\n  /// @return convertersOut Result template-pool-adapters\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\n  /// @return amountsToBorrowOut Amounts that should be borrowed\n  /// @return aprs18Out Annual Percentage Rates == (total cost - total income) / amount of collateral, decimals 18\n  function findConverter(\n    bytes memory entryData_,\n    address sourceToken_,\n    address targetToken_,\n    uint amountIn_,\n    uint periodInBlocks_\n  ) external view override returns (\n    address[] memory convertersOut,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountsToBorrowOut,\n    int[] memory aprs18Out\n  ) {\n    AppDataTypes.InputConversionParams memory params = AppDataTypes.InputConversionParams({\n    collateralAsset: sourceToken_,\n    borrowAsset: targetToken_,\n    amountIn: amountIn_,\n    countBlocks: periodInBlocks_,\n    entryData: entryData_\n    });\n    return _findConverter(params);\n  }\n\n  /// @notice Find lending pool capable of providing {targetAmount} and having best normalized borrow rate\n  ///         Results are ordered in ascending order of APR, so the best available converter is first one.\n  /// @return convertersOut Result template-pool-adapters\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\n  /// @return amountsToBorrowOut Amounts that should be borrowed\n  /// @return aprs18Out Annual Percentage Rates == (total cost - total income) / amount of collateral, decimals 18\n  function _findConverter(AppDataTypes.InputConversionParams memory p_) internal view returns (\n    address[] memory convertersOut,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountsToBorrowOut,\n    int[] memory aprs18Out\n  ) {\n    // get all platform adapters that support required pair of assets\n    EnumerableSet.AddressSet storage pas = _pairsList[getAssetPairKey(p_.collateralAsset, p_.borrowAsset)];\n\n    address[] memory converters;\n    uint[] memory collateralAmounts;\n    uint[] memory amountsToBorrow;\n    int[] memory aprs18;\n    uint countFoundItems;\n    if (pas.length() != 0) {\n      (converters, collateralAmounts, amountsToBorrow, aprs18, countFoundItems) = _findPool(\n        pas,\n        p_,\n        getTargetHealthFactor2(p_.collateralAsset)\n      );\n    }\n\n    if (countFoundItems > 0) {\n      // shrink output arrays to {countFoundItems} items and order results in ascending order of APR\n      return AppUtils.shrinkAndOrder(countFoundItems, converters, collateralAmounts, amountsToBorrow, aprs18);\n    } else {\n      return (convertersOut, collateralAmountsOut, amountsToBorrowOut, aprs18Out);\n    }\n  }\n\n  /// @notice Enumerate all pools suitable for borrowing and enough liquidity.\n  /// General explanation how max-target-amount is calculated in all pool adapters:\n  /// Health factor = HF [-], Collateral amount = C [USD]\n  /// Source amount that can be used for the collateral = SA [SA], Borrow amount = BS [USD]\n  /// Price of the source amount = PS [USD/SA] (1 [SA] = PS[USD])\n  /// Price of the target amount = PT [USD/TA] (1 [TA] = PT[USD])\n  /// Pool params: Collateral factor of the pool = PCF [-], Available cash in the pool = PTA [TA]\n  ///\n  /// C = SA * PS, BS = C / HF * PCF\n  /// Max target amount capable to be borrowed: ResultTA = BS / PT [TA].\n  /// We can use the pool only if ResultTA >= PTA >= required-target-amount\n  /// @dev We cannot make this function public because storage-param is used\n  /// @return converters All found converters without ordering.\n  ///                    The size of array is always equal to the count of available lending platforms.\n  ///                    The array is sparse, unused items are zero.\n  function _findPool(\n    EnumerableSet.AddressSet storage platformAdapters_,\n    AppDataTypes.InputConversionParams memory p_,\n    uint16 healthFactor2_\n  ) internal view returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountsToBorrowOut,\n    int[] memory aprs18,\n    uint countFoundItems\n  ) {\n    uint lenPools = platformAdapters_.length();\n\n    converters = new address[](lenPools);\n    collateralAmountsOut = new uint[](lenPools);\n    amountsToBorrowOut = new uint[](lenPools);\n    aprs18 = new int[](lenPools);\n\n    for (uint i; i < lenPools; i = i.uncheckedInc()) {\n      AppDataTypes.ConversionPlan memory plan = IPlatformAdapter(platformAdapters_.at(i)).getConversionPlan(\n        p_,\n        healthFactor2_\n      );\n\n      if (\n        plan.converter != address(0)\n        // check if we are able to supply required collateral\n        && plan.maxAmountToSupply > p_.amountIn\n      ) {\n        // combine all costs and incomes and calculate result APR. Rewards are taken with the given weight.\n        // Positive value means cost, negative - income\n        // APR = (cost - income) / collateralAmount, decimals 18, all amounts are given in terms of borrow asset.\n        int planApr18 = (\n          int(plan.borrowCost36)\n          - int(plan.supplyIncomeInBorrowAsset36)\n          - int(plan.rewardsAmountInBorrowAsset36 * rewardsFactor / REWARDS_FACTOR_DENOMINATOR_18)\n        )\n        * int(1e18)\n        / int(plan.amountCollateralInBorrowAsset36);\n\n        if (\n          // take only the pool with enough liquidity\n          plan.maxAmountToBorrow >= plan.amountToBorrow\n        ) {\n          converters[countFoundItems] = plan.converter;\n          amountsToBorrowOut[countFoundItems] = plan.amountToBorrow;\n          collateralAmountsOut[countFoundItems] = plan.collateralAmount;\n          aprs18[countFoundItems] = planApr18;\n          ++countFoundItems;\n        }\n      }\n    }\n\n    return (converters, collateralAmountsOut, amountsToBorrowOut, aprs18, countFoundItems);\n  }\n  //endregion ----------------------------------------------------- Find best pool for borrowing\n\n  //region ----------------------------------------------------- Minimal proxy creation\n\n  /// @notice Register a pool adapter for (pool, user, collateral) if the adapter wasn't created before\n  /// @param user_ Address of the caller contract who requires access to the pool adapter\n  /// @return Address of registered pool adapter\n  function registerPoolAdapter(\n    address converter_,\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) external override returns (address) {\n    _onlyTetuConverter();\n\n    uint poolAdapterKey = getPoolAdapterKey(converter_, collateralAsset_, borrowAsset_);\n    (bool found, address dest) = _poolAdapters[user_].tryGet(poolAdapterKey);\n    if (! found) {\n      // pool adapter is not yet registered\n      // create a new instance of the pool adapter using minimal proxy pattern, initialize newly created contract\n      dest = converter_.clone();\n      IPlatformAdapter(getPlatformAdapter(converter_)).initializePoolAdapter(\n        converter_,\n        dest,\n        user_,\n        collateralAsset_,\n        borrowAsset_\n      );\n\n      // register newly created pool adapter in the list of the pool adapters\n      _poolAdapters[user_].set(poolAdapterKey, dest);\n      uint index = listPoolAdapters.length;\n      poolAdaptersRegistered[dest] = index + 1;\n      listPoolAdapters.push(dest);\n\n      emit OnRegisterPoolAdapter(dest, converter_, user_, collateralAsset_, borrowAsset_);\n    }\n\n    return dest;\n  }\n\n  /// @notice Notify borrow manager that the pool adapter with the given params is \"dirty\".\n  ///         The pool adapter should be excluded from the list of ready-to-borrow pool adapters.\n  /// @dev \"Dirty\" means that a liquidation happens inside. The borrow position should be closed during health checking.\n  function markPoolAdapterAsDirty(address converter_, address user_, address collateral_, address borrowToken_) external override {\n    IConverterController _controller = IConverterController(controller()); // gas saving\n    require(\n      msg.sender == _controller.tetuConverter() || msg.sender == _controller.debtMonitor(),\n      AppErrors.ACCESS_DENIED\n    );\n    uint key = getPoolAdapterKey(converter_, collateral_, borrowToken_);\n\n    (bool found, address poolAdapter) = _poolAdapters[user_].tryGet(key);\n    require(found, AppErrors.POOL_ADAPTER_NOT_FOUND);\n\n    // Dirty pool adapter is removed from _poolAdapters, so it will never be used for new borrows\n    _poolAdapters[user_].remove(key);\n\n    emit OnMarkPoolAdapterAsDirty(poolAdapter);\n  }\n  //endregion ----------------------------------------------------- Minimal proxy creation\n\n  //region ----------------------------------------------------- Getters - pool adapters\n\n  /// @dev Returns true for NORMAL pool adapters and for active DIRTY pool adapters (=== borrow position is opened).\n  function isPoolAdapter(address poolAdapter_) external view override returns (bool) {\n    return poolAdaptersRegistered[poolAdapter_] != 0;\n  }\n\n  /// @notice Get pool adapter or 0 if the pool adapter is not registered\n  function getPoolAdapter(\n    address converter_,\n    address user_,\n    address collateral_,\n    address borrowToken_\n  ) external view override returns (address) {\n    (bool found, address dest) = _poolAdapters[user_].tryGet(getPoolAdapterKey(converter_, collateral_, borrowToken_));\n    return found ? dest : address(0);\n  }\n  //endregion ----------------------------------------------------- Getters - pool adapters\n\n  //region ----------------------------------------------------- Getters - platform adapters\n\n  /// @notice Get platformAdapter to which the converter belongs\n  function getPlatformAdapter(address converter_) public view override returns (address) {\n    address platformAdapter = converterToPlatformAdapter[converter_];\n    require(platformAdapter != address(0), AppErrors.PLATFORM_ADAPTER_NOT_FOUND);\n    return platformAdapter;\n  }\n  //endregion ----------------------------------------------------- Getters - platform adapters\n\n  //region ----------------------------------------------------- Getters - health factor\n\n  /// @notice Return target health factor with decimals 2 for the asset\n  ///         If there is no custom value for asset, target health factor from the controller should be used\n  function getTargetHealthFactor2(address asset_) public view override returns (uint16) {\n    uint16 dest = targetHealthFactorsForAssets[asset_];\n    return dest == 0\n      ? IConverterController(controller()).targetHealthFactor2()\n      : dest;\n  }\n  //endregion ----------------------------------------------------- Getters - health factor\n\n  //region ----------------------------------------------------- keccak256 keys\n\n  function getPoolAdapterKey(address converter_,\n    address collateral_,\n    address borrowToken_\n  ) public pure returns (uint){\n    return uint(keccak256(abi.encodePacked(converter_, collateral_, borrowToken_)));\n  }\n\n  function getAssetPairKey(address assetLeft_, address assetRight_) public pure returns (uint) {\n    return assetLeft_ < assetRight_\n      ? uint(keccak256(abi.encodePacked(assetLeft_, assetRight_)))\n      : uint(keccak256(abi.encodePacked(assetRight_, assetLeft_)));\n  }\n  //endregion ----------------------------------------------------- keccak256 keys\n\n  //region ----------------------------------------------------- Access to arrays\n\n  function platformAdaptersLength() public view override returns (uint) {\n    return _platformAdapters.length();\n  }\n\n  function platformAdaptersAt(uint index) public view override returns (address) {\n    return _platformAdapters.at(index);\n  }\n\n  function pairsListLength(address token1, address token2) public view returns (uint) {\n    return _pairsList[getAssetPairKey(token1, token2)].length();\n  }\n\n  function pairsListAt(address token1, address token2, uint index) public view returns (address) {\n    return _pairsList[getAssetPairKey(token1, token2)].at(index);\n  }\n\n  function platformAdapterPairsLength(address platformAdapter_) public view returns (uint) {\n    return _platformAdapterPairs[platformAdapter_].length();\n  }\n\n  function platformAdapterPairsAt(address platformAdapter_, uint index) public view returns (AssetPair memory) {\n    return _assetPairs[_platformAdapterPairs[platformAdapter_].at(index)];\n  }\n\n  function listPoolAdaptersLength() public view returns (uint) {\n    return listPoolAdapters.length;\n  }\n  //endregion ----------------------------------------------------- Access to arrays\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/core/ConverterController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../libs/AppErrors.sol\";\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../interfaces/IConverterController.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @notice Keep and provide addresses of all application contracts\ncontract ConverterController is IConverterController, ControllableV3 {\n\n  //region ------------------------------------- Constants\n  string public constant CONVERTER_CONTROLLER_VERSION = \"1.0.0\";\n  uint16 constant MIN_ALLOWED_MIN_HEALTH_FACTOR = 100;\n  /// @notice Denominator for {debtGap}\n  uint constant DEBT_GAP_DENOMINATOR = 100_000;\n  //endregion ------------------------------------- Constants\n\n  //region ------------------------------------- Variables. Don't change names or ordering!\n\n  /// @notice Controller of tetu-contracts-v2 that is allowed to update proxy contracts\n  address public override proxyUpdater;\n\n  /// @notice Allow to swap assets\n  address public override tetuLiquidator;\n\n  /// @notice Main application contract, strategy works only with it\n  address public override tetuConverter;\n\n  /// @notice Contains list of lending pools. Allow to select most efficient pool for the given collateral/borrow pair\n  address public override borrowManager;\n\n  /// @notice Contains list of opened borrows, check healths of the borrows\n  address public override debtMonitor;\n\n  /// @notice A keeper to control health of the borrows\n  address public override keeper;\n\n  /// @notice Wrapper around tetu-liquidator\n  address public override swapManager;\n\n  /// @notice Current governance. It can be changed by offer/accept scheme\n  address public override governance;\n\n  address public override priceOracle;\n\n  /// @notice New governance suggested by exist governance\n  address public pendingGovernance;\n\n  /// @notice Min allowed health factor = collateral / min allowed collateral, decimals 2\n  ///         If a health factor is below given value, we need to repay a part of borrow back\n  /// @dev Health factor < 1 produces liquidation immediately\n  uint16 public override minHealthFactor2;\n\n  /// @notice target health factor with decimals 2\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\n  ///      or additional borrow and restore the health factor to the given target value\n  uint16 public override targetHealthFactor2;\n\n  /// @notice max allowed health factor with decimals 2 (this value is not used in the current version)\n  /// @dev If a health factor is above given value, we CAN make additional borrow using exist collateral\n  uint16 public override maxHealthFactor2;\n\n  /// @notice Count of blocks per day, updatable\n  uint public override blocksPerDay;\n\n  /// @notice When blocksPerDay was updated last time\n  ///         0 - auto-update is disabled\n  uint public lastBlockNumber;\n  uint public lastBlockTimestamp;\n\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\n  bool private _paused;\n\n  /// @notice users who are allowed to make borrow using the TetuConverter\n  mapping (address => bool) public whitelist;\n\n  /// @inheritdoc IConverterController\n  uint public override debtGap;\n  //endregion ------------------------------------- Variables\n\n  //region ------------------------------------- Events\n  event OnSetBlocksPerDay(uint blocksPerDay, bool enableAutoUpdate);\n  event OnAutoUpdateBlocksPerDay(uint blocksPerDay);\n  event OnSetMinHealthFactor2(uint16 value);\n  event OnSetTargetHealthFactor2(uint16 value);\n  event OnSetMaxHealthFactor2(uint16 value);\n  event OnSetGovernance(address newGovernance);\n  event OnAcceptGovernance(address pendingGovernance);\n  event OnSetDebtGap(uint debtGap);\n  event OnSetPriceOracle(address priceOracle);\n  //endregion ------------------------------------- Events\n\n  //region ------------------------------------- Initialization\n\n  function init(\n    address proxyUpdater_,\n    address governance_,\n    address tetuConverter_,\n    address borrowManager_,\n    address debtMonitor_,\n    address keeper_,\n    address swapManager_,\n    address priceOracle_,\n    address tetuLiquidator_,\n    uint blocksPerDay_\n  // we cannot have additional parameters here because strategy will have stack too deep on coverage\n  ) external initializer {\n    require(blocksPerDay_ != 0, AppErrors.INCORRECT_VALUE);\n    require(\n      proxyUpdater_ != address(0)\n      && tetuConverter_ != address(0)\n      && borrowManager_ != address(0)\n      && debtMonitor_ != address(0)\n      && keeper_ != address(0)\n      && swapManager_ != address(0)\n      && tetuLiquidator_ != address(0)\n      && governance_ != address(0)\n      && priceOracle_ != address(0),\n      AppErrors.ZERO_ADDRESS\n    );\n\n    governance = governance_;\n    __Controllable_init(address(this));\n\n    tetuConverter = tetuConverter_;\n    borrowManager = borrowManager_;\n    debtMonitor = debtMonitor_;\n    keeper = keeper_;\n    swapManager = swapManager_;\n    priceOracle = priceOracle_;\n    proxyUpdater = proxyUpdater_;\n    tetuLiquidator = tetuLiquidator_;\n\n    // by default auto-update of blocksPerDay is disabled, it's necessary to call setBlocksPerDay to enable it\n    blocksPerDay = blocksPerDay_;\n\n    // Other params are initialized by default values to reduce number of input parameters\n    // We can always modify these values using setters\n    debtGap = 1000;\n    minHealthFactor2 = 105;\n    targetHealthFactor2 = 200;\n\n    // current version of converter doesn't use maxHealthFactor2, it's for future versions\n    // you can always change this limit using setMaxHealthFactor\n    maxHealthFactor2 = 5000;\n\n  }\n\n  function _onlyGovernance() internal view {\n    require (msg.sender == governance, AppErrors.GOVERNANCE_ONLY);\n  }\n  //endregion ------------------------------------- Initialization\n\n  //region ------------------------------------- Blocks per day\n\n  /// @notice Manually set value of blocksPerDay and enable/disable its auto-update\n  ///         If the update is enabled, the first update will happen in BLOCKS_PER_DAY_AUTO_UPDATE_PERIOD_SECS seconds\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external override {\n    require(blocksPerDay_ != 0, AppErrors.INCORRECT_VALUE);\n    _onlyGovernance();\n    blocksPerDay = blocksPerDay_;\n    if (enableAutoUpdate_) {\n      lastBlockNumber = block.number;\n      lastBlockTimestamp = block.timestamp;\n    } else {\n      lastBlockNumber = 0;\n      lastBlockTimestamp = 0;\n    }\n    emit OnSetBlocksPerDay(blocksPerDay_, enableAutoUpdate_);\n  }\n\n  /// @notice Check if blocksPerDay should be updated. The keeper should do it periodically\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view override returns (bool) {\n    return lastBlockNumber != 0 && block.timestamp - lastBlockTimestamp > periodInSeconds_;\n  }\n\n  /// @notice Calculate new value of blocksPerDay as COUNT PASSED BLOCKS / COUNT PASSED DAYS (since prev auto-update)\n  function updateBlocksPerDay(uint periodInSeconds_) external override {\n    require(msg.sender == keeper, AppErrors.KEEPER_ONLY);\n    require(lastBlockNumber != 0,\n      // && lastBlockNumber != block.number       // this check is unnecessary\n      AppErrors.INCORRECT_OPERATION               // setBlocksPerDay is called by governance\n    );                                            // but updateBlocksPerDay is called by keeper\n                                                  // so, they cannot be called in the same block\n    require(\n      periodInSeconds_ != 0\n      && lastBlockTimestamp + periodInSeconds_ <= block.timestamp,\n      AppErrors.INCORRECT_VALUE\n    );\n    // blocks-per-day = count passed blocks / count passed days\n    // count passed days = count passed seconds / count seconds per day\n    blocksPerDay = (block.number - lastBlockNumber) * (24 * 60 * 60) / (block.timestamp - lastBlockTimestamp);\n\n    lastBlockNumber = block.number;\n    lastBlockTimestamp = block.timestamp;\n\n    emit OnAutoUpdateBlocksPerDay(blocksPerDay);\n  }\n  //endregion ------------------------------------- Blocks per day\n\n  //region ------------------------------------- Setters\n\n  /// @notice min allowed health factor with decimals 2\n  function setMinHealthFactor2(uint16 value_) external override {\n    require(value_ >= MIN_ALLOWED_MIN_HEALTH_FACTOR, AppErrors.WRONG_HEALTH_FACTOR);\n    require(value_ < targetHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);\n    _onlyGovernance();\n    minHealthFactor2 = value_;\n    emit OnSetMinHealthFactor2(value_);\n  }\n\n  /// @notice target health factor with decimals 2\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\n  ///      or additional borrow and restore the health factor to the given target value\n  function setTargetHealthFactor2(uint16 value_) external override {\n    require(value_ > minHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);\n    require(value_ < maxHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);\n    _onlyGovernance();\n    targetHealthFactor2 = value_;\n    emit OnSetTargetHealthFactor2(value_);\n  }\n\n  /// @notice max allowed health factor with decimals 2\n  function setMaxHealthFactor2(uint16 value_) external override {\n    require(value_ > targetHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);\n    _onlyGovernance();\n    maxHealthFactor2 = value_;\n    emit OnSetMaxHealthFactor2(value_);\n  }\n\n  /// @notice Set up debt gap value\n  /// @dev If pool adapter's getStatus returns debtGapRequired = true\n  ///      user should reppay debt-amount * (debtGap_ + 100_000) / 100_000\n  /// @param debtGap_ Debt gap value, any value >= 0 is suitable\n  function setDebtGap(uint debtGap_) external {\n    _onlyGovernance();\n    debtGap = debtGap_;\n  }\n\n  /// @notice Set up new price oracle\n  function setPriceOracle(address priceOracle_) external {\n    _onlyGovernance();\n    require(priceOracle_ != address(0), AppErrors.ZERO_ADDRESS);\n\n    priceOracle = priceOracle_;\n    emit OnSetPriceOracle(priceOracle);\n  }\n\n  //endregion ------------------------------------- Setters\n\n  //region ------------------------------------- Governance\n\n  /// @notice Suggest to change governance\n  function setGovernance(address newGovernance_) external {\n    _onlyGovernance();\n    require(newGovernance_ != address(0), AppErrors.ZERO_ADDRESS);\n\n    pendingGovernance = newGovernance_;\n    emit OnSetGovernance(newGovernance_);\n  }\n\n  /// @notice Old governance has suggested to change governance.\n  ///         Newly suggested governance must accept the change to actually change the governance.\n  function acceptGovernance() external {\n    require(pendingGovernance == msg.sender, AppErrors.NOT_PENDING_GOVERNANCE);\n\n    governance = pendingGovernance;\n    emit OnAcceptGovernance(pendingGovernance);\n  }\n  //endregion ------------------------------------- Governance\n\n  //region ------------------------------------- Paused\n  function paused() external view override returns (bool) {\n    return _paused;\n  }\n  function setPaused(bool paused_) external {\n    _onlyGovernance();\n    _paused = paused_;\n  }\n  //endregion ------------------------------------- Paused\n\n  //region ------------------------------------- Whitelist\n  function isWhitelisted(address user_) external view override returns (bool) {\n    return whitelist[user_];\n  }\n  function setWhitelistValues(address[] memory users_, bool isWhite) external {\n    _onlyGovernance();\n    uint len = users_.length;\n    for (uint i; i < len; ++i) {\n      whitelist[users_[i]] = isWhite;\n    }\n  }\n  //endregion ------------------------------------- Whitelist\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/core/DebtMonitor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppUtils.sol\";\nimport \"../openzeppelin/IERC20Metadata.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../interfaces/IPoolAdapter.sol\";\nimport \"../interfaces/IConverterController.sol\";\nimport \"../interfaces/IDebtMonitor.sol\";\nimport \"../interfaces/IPriceOracle.sol\";\nimport \"../interfaces/IBorrowManager.sol\";\nimport \"../interfaces/ITetuConverter.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @notice Manage list of open borrow positions\ncontract DebtMonitor is IDebtMonitor, ControllableV3 {\n  using AppUtils for uint;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  struct CheckHealthFactorInputParams {\n    uint startIndex0;\n    uint maxCountToCheck;\n    uint maxCountToReturn;\n    uint healthFactorThreshold18;\n  }\n\n  //region ---------------------------------------------- Constants\n  string public constant DEBT_MONITOR_VERSION = \"1.0.0\";\n  //endregion ---------------------------------------------- Constants\n\n  //region ---------------------------------------------- Variables. Don't change names or ordering!\n  /// @notice Pool adapters with active borrow positions\n  /// @dev All these pool adapters should be enumerated during health-checking\n  address[] public positions;\n\n  /// @notice Pool adapter => block number of last call of onOpenPosition\n  mapping(address => uint) public positionLastAccess;\n\n  /// @notice List of opened positions for the given set (user, collateral, borrowToken)\n  /// @dev PoolAdapterKey(== keccak256(user, collateral, borrowToken)) => poolAdapters\n  mapping(uint => address[]) public poolAdapters;\n\n  /// @notice List of opened positions for the given user\n  /// @dev User => List of pool adapters\n  mapping(address => EnumerableSet.AddressSet) private _poolAdaptersForUser;\n\n  /// @notice Template pool adapter => list of ACTIVE pool adapters created on the base of the template\n  /// @dev We need it to prevent removing a pool from the borrow manager when the pool is in use\n  mapping(address => EnumerableSet.AddressSet) private _poolAdaptersForConverters;\n\n  //endregion ---------------------------------------------- Variables. Don't change names or ordering!\n\n  //region ---------------------------------------------- Events\n  event OnOpenPosition(address poolAdapter);\n  event OnClosePosition(address poolAdapter);\n  event OnCloseLiquidatedPosition(address poolAdapter, uint amountToPay);\n  //endregion ---------------------------------------------- Events\n\n  //region ---------------------------------------------- Initialization\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ---------------------------------------------- Initialization\n\n  //region ---------------------------------------------- Operations with positions\n\n  /// @notice Check if the pool-adapter-caller has an opened position\n  function isPositionOpened() external override view returns (bool) {\n    return positionLastAccess[msg.sender] != 0;\n  }\n\n  /// @notice Register new borrow position if it's not yet registered\n  /// @dev This function is called from a pool adapter after any borrow\n  function onOpenPosition() external override {\n    IBorrowManager borrowManager = IBorrowManager(IConverterController(controller()).borrowManager());\n    require(borrowManager.isPoolAdapter(msg.sender), AppErrors.POOL_ADAPTER_ONLY);\n\n    if (positionLastAccess[msg.sender] == 0) {\n      positionLastAccess[msg.sender] = block.number;\n      positions.push(msg.sender);\n\n      (address origin,\n      address user,\n      address collateralAsset,\n      address borrowAsset\n      ) = IPoolAdapter(msg.sender).getConfig();\n\n      poolAdapters[getPoolAdapterKey(user, collateralAsset, borrowAsset)].push(msg.sender);\n      _poolAdaptersForUser[user].add(msg.sender);\n\n      _poolAdaptersForConverters[origin].add(msg.sender);\n      emit OnOpenPosition(msg.sender);\n    }\n  }\n\n  /// @notice Unregister the borrow position if it's completely repaid\n  /// @dev This function is called from a pool adapter when the borrow is completely repaid\n  function onClosePosition() external override {\n    // This method should be called by pool adapters only\n    // we check it through positionLastAccess\n    require(\n      positionLastAccess[msg.sender] != 0,\n      AppErrors.BORROW_POSITION_IS_NOT_REGISTERED\n    );\n\n    (uint collateralAmount, uint amountToPay,,,,) = IPoolAdapter(msg.sender).getStatus();\n    require(collateralAmount == 0 && amountToPay == 0, AppErrors.ATTEMPT_TO_CLOSE_NOT_EMPTY_BORROW_POSITION);\n\n    _closePosition(msg.sender, false);\n    emit OnClosePosition(msg.sender);\n  }\n\n  /// @notice Remove the pool adapter from all lists of the opened positions\n  /// @param poolAdapter_ Pool adapter to be closed\n  /// @param markAsDirty_ Mark the pool adapter as \"dirty\" in borrow manager\n  ///                     to exclude the pool adapter from any new borrows\n  function _closePosition(address poolAdapter_, bool markAsDirty_) internal {\n    positionLastAccess[poolAdapter_] = 0;\n    AppUtils.removeItemFromArray(positions, poolAdapter_);\n    (address origin, address user, address collateralAsset, address borrowAsset) = IPoolAdapter(poolAdapter_).getConfig();\n\n    AppUtils.removeItemFromArray(poolAdapters[getPoolAdapterKey(user, collateralAsset, borrowAsset)], poolAdapter_);\n    _poolAdaptersForUser[user].remove(poolAdapter_);\n    _poolAdaptersForConverters[origin].remove(poolAdapter_);\n\n    if (markAsDirty_) {\n      IBorrowManager borrowManager = IBorrowManager(IConverterController(controller()).borrowManager());\n      // We have dropped away the pool adapter. It cannot be used any more for new borrows\n      // Mark the pool adapter as dirty in borrow manager to exclude the pool adapter from any new borrows\n      if (poolAdapter_ == borrowManager.getPoolAdapter(origin, user, collateralAsset, borrowAsset)) {\n        borrowManager.markPoolAdapterAsDirty(origin, user, collateralAsset, borrowAsset);\n      }\n    }\n  }\n\n  /// @notice Pool adapter has opened borrow, but full liquidation happens and we've lost all collateral\n  ///         Close position without paying the debt and never use the pool adapter again.\n  function closeLiquidatedPosition(address poolAdapter_) external override {\n    require(msg.sender == IConverterController(controller()).tetuConverter(), AppErrors.TETU_CONVERTER_ONLY);\n\n    (uint collateralAmount, uint amountToPay,,,,) = IPoolAdapter(poolAdapter_).getStatus();\n    require(collateralAmount == 0, AppErrors.CANNOT_CLOSE_LIVE_POSITION);\n    _closePosition(poolAdapter_, true);\n\n    emit OnCloseLiquidatedPosition(poolAdapter_, amountToPay);\n  }\n  //endregion ---------------------------------------------- Operations with positions\n\n  //region ---------------------------------------------- Detect unhealthy positions\n\n  /// @notice Enumerate {maxCountToCheck} pool adapters starting from {index0} and return unhealthy pool-adapters\n  ///         i.e. adapters with health factor below min allowed value\n  ///         It calculates two amounts: amount of borrow asset and amount of collateral asset\n  ///         To fix the health factor it's necessary to send EITHER one amount OR another one.\n  ///         There is special case: a liquidation happens inside the pool adapter.\n  ///         It means, that this is \"dirty\" pool adapter and this position must be closed and never used again.\n  ///         In this case, both amounts are zero (we need to make FULL repay)\n  /// @return nextIndexToCheck0 Index of next pool-adapter to check; 0: all pool-adapters were checked\n  /// @return outPoolAdapters List of pool adapters that should be reconverted\n  /// @return outAmountBorrowAsset What borrow-asset amount should be send to pool adapter to fix health factor\n  /// @return outAmountCollateralAsset What collateral-asset amount should be send to pool adapter to fix health factor\n  function checkHealth(\n    uint startIndex0,\n    uint maxCountToCheck,\n    uint maxCountToReturn\n  ) external view override returns (\n    uint nextIndexToCheck0,\n    address[] memory outPoolAdapters,\n    uint[] memory outAmountBorrowAsset,\n    uint[] memory outAmountCollateralAsset\n  ) {\n    return _checkHealthFactor(\n      CheckHealthFactorInputParams({\n        startIndex0: startIndex0,\n        maxCountToCheck: maxCountToCheck,\n        maxCountToReturn: maxCountToReturn,\n        healthFactorThreshold18: uint(IConverterController(controller()).minHealthFactor2()) * 10 ** (18 - 2)\n      })\n    );\n  }\n\n  function _checkHealthFactor(\n    CheckHealthFactorInputParams memory p\n  ) internal view returns (\n    uint nextIndexToCheck0,\n    address[] memory outPoolAdapters,\n    uint[] memory outAmountBorrowAsset,\n    uint[] memory outAmountCollateralAsset\n  ) {\n    IBorrowManager borrowManager = IBorrowManager(IConverterController(controller()).borrowManager());\n    uint countFoundItems = 0;\n    nextIndexToCheck0 = p.startIndex0;\n\n    outPoolAdapters = new address[](p.maxCountToReturn);\n    outAmountBorrowAsset = new uint[](p.maxCountToReturn);\n    outAmountCollateralAsset = new uint[](p.maxCountToReturn);\n\n    if (p.startIndex0 + p.maxCountToCheck > positions.length) {\n      p.maxCountToCheck = positions.length - p.startIndex0;\n    }\n\n    // enumerate all pool adapters\n    for (uint i = 0; i < p.maxCountToCheck; i = i.uncheckedInc()) {\n      nextIndexToCheck0 += 1;\n\n      // check if we need to make reconversion because the health factor is too low/high\n      IPoolAdapter pa = IPoolAdapter(positions[p.startIndex0 + i]);\n\n      (uint collateralAmount, uint amountToPay, uint healthFactor18,,,) = pa.getStatus();\n      // If full liquidation happens we will have collateralAmount = 0 and amountToPay > 0\n      // In this case the open position should be just closed (we lost all collateral)\n      // We cannot do it here because it's read-only function.\n      // We should call a IKeeperCallback in the same way as for rebalancing, but with requiredAmountCollateralAsset=0\n\n      (,,address collateralAsset,) = pa.getConfig();\n      uint healthFactorTarget18 = uint(borrowManager.getTargetHealthFactor2(collateralAsset)) * 10 ** (18 - 2);\n      if (p.healthFactorThreshold18 < healthFactorTarget18 && healthFactor18 < p.healthFactorThreshold18) {// unhealthy\n        outPoolAdapters[countFoundItems] = positions[p.startIndex0 + i];\n        // Health Factor = Collateral Factor * CollateralAmount * Price_collateral / (BorrowAmount * Price_borrow)\n        // => requiredAmountBorrowAsset = BorrowAmount * (HealthFactorCurrent/HealthFactorTarget - 1)\n        // => requiredAmountCollateralAsset = CollateralAmount * (HealthFactorTarget/HealthFactorCurrent - 1)\n        outAmountBorrowAsset[countFoundItems] = (amountToPay - amountToPay * healthFactor18 / healthFactorTarget18);\n        outAmountCollateralAsset[countFoundItems] = (collateralAmount * healthFactorTarget18 / healthFactor18 - collateralAmount);\n\n        countFoundItems += 1;\n\n        if (countFoundItems == p.maxCountToReturn) {\n          break;\n        }\n      }\n    }\n\n    if (nextIndexToCheck0 == positions.length) {\n      nextIndexToCheck0 = 0; // all items were checked\n    }\n\n    // we need to keep only found items in result array and remove others\n    return (nextIndexToCheck0,\n      countFoundItems == 0\n        ? new address[](0)\n        : AppUtils.removeLastItems(outPoolAdapters, countFoundItems),\n      countFoundItems == 0\n        ? new uint[](0)\n        : AppUtils.removeLastItems(outAmountBorrowAsset, countFoundItems),\n      countFoundItems == 0\n        ? new uint[](0)\n        : AppUtils.removeLastItems(outAmountCollateralAsset, countFoundItems)\n    );\n  }\n  //endregion ---------------------------------------------- Detect unhealthy positions\n\n  //region ---------------------------------------------- Views\n\n  /// @notice Get active borrows of the user with given collateral/borrowToken\n  /// @return poolAdaptersOut The instances of IPoolAdapter\n  function getPositions(\n    address user_,\n    address collateralToken_,\n    address borrowedToken_\n  ) external view override returns (\n    address[] memory poolAdaptersOut\n  ) {\n    address[] memory adapters = poolAdapters[getPoolAdapterKey(user_, collateralToken_, borrowedToken_)];\n    uint countAdapters = adapters.length;\n\n    poolAdaptersOut = new address[](countAdapters);\n\n    for (uint i = 0; i < countAdapters; i = i.uncheckedInc()) {\n      poolAdaptersOut[i] = adapters[i];\n    }\n\n    return poolAdaptersOut;\n  }\n\n  /// @notice Get active borrows of the given user\n  /// @return poolAdaptersOut The instances of IPoolAdapter\n  function getPositionsForUser(address user_) external view override returns (\n    address[] memory poolAdaptersOut\n  ) {\n    EnumerableSet.AddressSet storage set = _poolAdaptersForUser[user_];\n    uint countAdapters = set.length();\n\n    poolAdaptersOut = new address[](countAdapters);\n\n    for (uint i = 0; i < countAdapters; i = i.uncheckedInc()) {\n      poolAdaptersOut[i] = set.at(i);\n    }\n\n    return poolAdaptersOut;\n  }\n\n  /// @notice Return true if there is a least once active pool adapter created on the base of the {converter_}\n  function isConverterInUse(address converter_) external view override returns (bool) {\n    return _poolAdaptersForConverters[converter_].length() != 0;\n  }\n  //endregion ---------------------------------------------- Views\n\n  //region ---------------------------------------------- Utils\n  function getPoolAdapterKey(\n    address user_,\n    address collateral_,\n    address borrowToken_\n  ) public pure returns (uint){\n    return uint(keccak256(abi.encodePacked(user_, collateral_, borrowToken_)));\n  }\n  //endregion ---------------------------------------------- Utils\n\n  //region ---------------------------------------------- Access to arrays\n\n  /// @notice Get total count of pool adapters with opened positions\n  function getCountPositions() external view override returns (uint) {\n    return positions.length;\n  }\n\n  function poolAdaptersLength(\n    address user_,\n    address collateral_,\n    address borrowToken_\n  ) external view returns (uint) {\n    return poolAdapters[getPoolAdapterKey(user_, collateral_, borrowToken_)].length;\n  }\n  //endregion Access to arrays\n}"
    },
    "@tetu_io/tetu-converter/contracts/core/Keeper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppUtils.sol\";\nimport \"../interfaces/IHealthKeeperCallback.sol\";\nimport \"../interfaces/IConverterController.sol\";\nimport \"../interfaces/IDebtMonitor.sol\";\nimport \"../interfaces/IKeeperCallback.sol\";\nimport \"../integrations/gelato/IResolver.sol\";\nimport \"../integrations/gelato/IOps.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @notice Executor + Resolver for Gelato\n///         to check health of opened positions and call requireRepay for unhealthy pool adapters\n///         Same keeper is also responsible for updating block-per-day value in controller.\ncontract Keeper is IHealthKeeperCallback, IResolver, ControllableV3 {\n  using AppUtils for uint;\n\n  //region ----------------------------------------------------- Constants\n  string public constant KEEPER_VERSION = \"1.0.0\";\n  address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  /// @notice Max count of opened positions to be checked in single request\n  uint constant public MAX_COUNT_TO_CHECK = 80;\n\n  /// @notice Max count of unhealthy positions to be returned in single request\n  uint constant public MAX_COUNT_TO_RETURN = 1;\n  //endregion ----------------------------------------------------- Constants\n\n  //region ----------------------------------------------------- Variables. Don't change names or ordering!\n  address public ops;\n  address payable public gelato;\n\n  /// @notice Period of auto-update of the blocksPerDay-value in seconds\n  ///         0 - auto-update checking is disabled\n  uint public blocksPerDayAutoUpdatePeriodSec; // i.e. 2 * 7 * 24 * 60 * 60 for 2 weeks\n\n  /// @notice Start index of pool adapter for next checkHealth-request\n  ///         We store here result of previous call of IDebtMonitor.checkHealth\n  uint256 public override nextIndexToCheck0;\n  //endregion ----------------------------------------------------- Variables. Don't change names or ordering!\n\n  //region ----------------------------------------------------- Events\n  event OnFixHealth(uint nextIndexToCheck0, address[] poolAdapters, uint[] amountBorrowAsset, uint[] amountCollateralAsset);\n  //endregion ----------------------------------------------------- Events\n\n  //region ----------------------------------------------------- Initialization\n  function init(address controller_, address payable ops_, uint blocksPerDayAutoUpdatePeriodSec_) external initializer {\n    require(ops_ != address(0), AppErrors.ZERO_ADDRESS);\n\n    __Controllable_init(controller_);\n    ops = ops_;\n    gelato = IOps(ops_).gelato();\n    blocksPerDayAutoUpdatePeriodSec = blocksPerDayAutoUpdatePeriodSec_;\n  }\n\n  /// @notice Set period of auto-update of the blocksPerDay-value in seconds, 0 - auto-update checking is disabled\n  function setBlocksPerDayAutoUpdatePeriodSecs(uint periodSeconds) external {\n    require(IConverterController(controller()).governance() == msg.sender, AppErrors.GOVERNANCE_ONLY);\n\n    blocksPerDayAutoUpdatePeriodSec = periodSeconds;\n  }\n  //endregion ----------------------------------------------------- Initialization\n\n  //region ----------------------------------------------------- Read-only gelato-resolver\n\n  /// @notice Check health of opened positions starting from nth-position, where n = nextIndexToCheck0\n  /// @dev Read-only checker function called by Gelato.\n  /// @return canExecOut True if it's necessary to call rebalancing write-function\n  /// @return execPayloadOut Wrapped call of the rebalancing function (it will be called by Gelato)\n  function checker() external view override returns (\n    bool canExecOut,\n    bytes memory execPayloadOut\n  ) {\n    IConverterController _controller = IConverterController(controller());\n    IDebtMonitor debtMonitor = IDebtMonitor(_controller.debtMonitor());\n\n    // IHealthKeeperCallback is implemented inside this class\n    // but we access it through controller to be able to split checker and executor in unit tests\n    IHealthKeeperCallback keeper = IHealthKeeperCallback(_controller.keeper());\n    uint startIndex = keeper.nextIndexToCheck0();\n\n    (uint newNextIndexToCheck0,\n    address[] memory outPoolAdapters,\n    uint[] memory outAmountBorrowAsset,\n    uint[] memory outAmountCollateralAsset\n    ) = debtMonitor.checkHealth(startIndex, MAX_COUNT_TO_CHECK, MAX_COUNT_TO_RETURN);\n\n    // it's necessary to run writable fixHealth() ...\n    canExecOut =\n      // ... if there is unhealthy pool adapter\n      outPoolAdapters.length != 0\n\n      // ... if we cannot check all adapters in one pass; we've checked a one portion, now we need to check the other portions\n      || newNextIndexToCheck0 != startIndex\n\n      /// ... if it's the time to recalculate blocksPerDay value\n      || (blocksPerDayAutoUpdatePeriodSec != 0\n      && _controller.isBlocksPerDayAutoUpdateRequired(blocksPerDayAutoUpdatePeriodSec)\n    );\n\n    execPayloadOut = abi.encodeWithSelector(\n      IHealthKeeperCallback.fixHealth.selector,\n      newNextIndexToCheck0,\n      outPoolAdapters,\n      outAmountBorrowAsset,\n      outAmountCollateralAsset\n    );\n  }\n\n  //endregion ----------------------------------------------------- Read-only gelato-resolver\n\n  //region ----------------------------------------------------- Executor to fix unhealthy pool adapters\n\n  /// @notice Make rebalancing of the given unhealthy positions (a position == pool adapter)\n  ///         Call TetuConverter.requireRepay for each position\n  function fixHealth(\n    uint nextIndexToCheck0_,\n    address[] calldata poolAdapters_,\n    uint[] calldata amountBorrowAsset_,\n    uint[] calldata amountCollateralAsset_\n  ) external override {\n    require(msg.sender == ops, AppErrors.GELATO_ONLY_OPS);\n\n    IConverterController _controller = IConverterController(controller());\n\n    uint countPoolAdapters = poolAdapters_.length;\n    require(\n      countPoolAdapters == amountBorrowAsset_.length\n      && countPoolAdapters == amountCollateralAsset_.length,\n      AppErrors.WRONG_LENGTHS\n    );\n\n    nextIndexToCheck0 = nextIndexToCheck0_;\n\n    if (countPoolAdapters != 0) {\n      IKeeperCallback keeperCallback = IKeeperCallback(_controller.tetuConverter());\n      for (uint i = 0; i < countPoolAdapters; i = i.uncheckedInc()) {\n        keeperCallback.requireRepay(amountBorrowAsset_[i], amountCollateralAsset_[i], poolAdapters_[i]);\n      }\n    }\n\n    if (blocksPerDayAutoUpdatePeriodSec != 0\n      && _controller.isBlocksPerDayAutoUpdateRequired(blocksPerDayAutoUpdatePeriodSec)\n    ) {\n      _controller.updateBlocksPerDay(blocksPerDayAutoUpdatePeriodSec);\n    }\n\n    emit OnFixHealth(nextIndexToCheck0_, poolAdapters_, amountBorrowAsset_, amountCollateralAsset_);\n  }\n\n  //endregion ----------------------------------------------------- Executor to fix unhealthy pool adapters\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/core/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../libs/AppErrors.sol\";\nimport \"../interfaces/IPriceOracle.sol\";\nimport \"../integrations/aave3/IAavePriceOracle.sol\";\n\n/// @notice Trivial implementation of a price oracle as a wrapper of AAVE3 price oracle\ncontract PriceOracle is IPriceOracle {\n  IAavePriceOracle public immutable priceOracle;\n\n  constructor(address aave3priceOracle_) {\n    require(aave3priceOracle_ != address(0), AppErrors.ZERO_ADDRESS);\n    priceOracle = IAavePriceOracle(aave3priceOracle_);\n  }\n\n  /// @notice Return asset price in USD, decimals 18\n  function getAssetPrice(address asset) external view override returns (uint256) {\n    // AAVE3 price oracle returns price with decimals 1e8, we need decimals 18\n    try priceOracle.getAssetPrice(asset) returns (uint value) {\n      return value * 1e10;\n    } catch {}\n\n    return 0; // unknown asset or unknown price\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/core/SwapManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppDataTypes.sol\";\nimport \"../libs/SwapLib.sol\";\nimport \"../openzeppelin/IERC20Metadata.sol\";\nimport \"../openzeppelin/IERC20.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/ISwapManager.sol\";\nimport \"../interfaces/IConverterController.sol\";\nimport \"../interfaces/ISwapConverter.sol\";\nimport \"../interfaces/IPriceOracle.sol\";\nimport \"../interfaces/ISimulateProvider.sol\";\nimport \"../interfaces/ISwapSimulator.sol\";\nimport \"../interfaces/IRequireAmountBySwapManagerCallback.sol\";\nimport \"../integrations/tetu/ITetuLiquidator.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Contract to find the best swap and make the swap\n/// @notice Combines Manager and Converter\n/// @author bogdoslav\ncontract SwapManager is ControllableV3, ISwapManager, ISwapConverter, ISimulateProvider, ISwapSimulator {\n  using SafeERC20 for IERC20;\n\n  //region ----------------------------------------------------- Constants\n  string public constant SWAP_MANAGER_VERSION = \"1.0.0\";\n  int public constant APR_NUMERATOR = 10 ** 18;\n\n  uint public constant PRICE_IMPACT_NUMERATOR = SwapLib.PRICE_IMPACT_NUMERATOR;\n  uint public constant PRICE_IMPACT_TOLERANCE_DEFAULT = SwapLib.PRICE_IMPACT_TOLERANCE_DEFAULT;\n\n  /// @notice Optional price impact tolerance for assets. If not set, PRICE_IMPACT_TOLERANCE_DEFAULT is used.\n  ///         asset => price impact tolerance (decimals are set by PRICE_IMPACT_NUMERATOR)\n  mapping(address => uint) public priceImpactTolerances;\n  //endregion ----------------------------------------------------- Constants\n\n  //region ----------------------------------------------------- Events\n  event OnSwap(address sourceToken, uint sourceAmount, address targetToken, address receiver, uint outputAmount);\n  //endregion ----------------------------------------------------- Events\n\n  //region ----------------------------------------------------- Initialization and setup\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n\n  /// @notice Set custom price impact tolerance for the asset\n  /// @param priceImpactTolerance Set 0 to use default price impact tolerance for the {asset}.\n  ///                             Decimals = PRICE_IMPACT_NUMERATOR\n  function setPriceImpactTolerance(address asset_, uint priceImpactTolerance) external {\n    IConverterController _controller = IConverterController(controller());\n    require(msg.sender == _controller.governance(), AppErrors.GOVERNANCE_ONLY);\n    require(priceImpactTolerance <= PRICE_IMPACT_NUMERATOR, AppErrors.INCORRECT_VALUE);\n\n    priceImpactTolerances[asset_] = priceImpactTolerance;\n  }\n  //endregion ----------------------------------------------------- Initialization and setup\n\n  //region ----------------------------------------------------- Return best amount for swap\n  /// @notice Find a way to convert collateral asset to borrow asset in most efficient way\n  ///         The algo to convert source amount S1:\n  ///         - make real swap in static-call, get result max-target-amount\n  ///         - recalculate max-target-amount to source amount using prices from a PriceOracle = S2\n  ///         Result APR = 2 * (S1 - S2) / S1\n  /// @dev This is a writable function with read-only behavior\n  ///      because to simulate real swap the function should be writable.\n  /// @param sourceAmountApprover_ A contract which has approved {sourceAmount_} to TetuConverter\n  /// @param sourceAmount_ Amount in terms of {sourceToken_} to be converter to {targetToken_}\n  ///                      This amount must be approved by {sourceAmountApprover_} to TetuConverter before the call\n  /// @return converter Address of ISwapConverter\n  ///         If SwapManager cannot find a conversion way,\n  ///         it returns converter == 0 (in the same way as ITetuConverter)\n  function getConverter(\n    address sourceAmountApprover_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external override returns (\n    address converter,\n    uint maxTargetAmount\n  ) {\n    IConverterController _controller = IConverterController(controller());\n    require(msg.sender == _controller.tetuConverter(), AppErrors.TETU_CONVERTER_ONLY);\n\n    // Simulate real swap of source amount to max target amount\n    // We call SwapManager.simulateSwap() here as an external call\n    // and than revert all changes back\n    // We need additional try because !PRICE error can happen if a price impact is too high\n    try ISimulateProvider(address(this)).simulate(\n      address(this),\n      abi.encodeWithSelector(\n        ISwapSimulator.simulateSwap.selector,\n        sourceAmountApprover_,\n        sourceToken_,\n        sourceAmount_,\n        targetToken_\n      )\n    ) returns (bytes memory response) {\n      maxTargetAmount = abi.decode(response, (uint));\n    } catch {\n      // we can have i.e. !PRICE error (the price impact is too high)\n      // it means, there is no way to make the conversion with acceptable price impact\n      return (address(0), 0);\n    }\n\n    return maxTargetAmount == 0\n      ? (address(0), 0)\n      : (address(this), maxTargetAmount);\n  }\n  //endregion ----------------------------------------------------- Return best amount for swap\n\n  //region ----------------------------------------------------- ISwapConverter Implementation\n  function getConversionKind() override external pure returns (AppDataTypes.ConversionKind) {\n    return AppDataTypes.ConversionKind.SWAP_1;\n  }\n\n  /// @notice Swap {amountIn_} of {sourceToken_} to {targetToken_} and send result amount to {receiver_}\n  ///         The swapping is made using TetuLiquidator.\n  /// @return amountOut The amount that has been sent to the receiver\n  function swap(address sourceToken_, uint amountIn_, address targetToken_, address receiver_) override external returns (\n    uint amountOut\n  ) {\n    IConverterController _controller = IConverterController(controller());\n    require(msg.sender == _controller.tetuConverter(), AppErrors.TETU_CONVERTER_ONLY);\n\n    ITetuLiquidator tetuLiquidator = ITetuLiquidator(_controller.tetuLiquidator());\n    uint targetTokenBalanceBefore = IERC20(targetToken_).balanceOf(address(this));\n\n    IERC20(sourceToken_).safeApprove(address(tetuLiquidator), amountIn_);\n\n    // If price impact is too big, getConverter will return high APR\n    // So TetuConverter will select borrow, not swap.\n    // If the swap was selected anyway, it is wrong case.\n    // liquidate() will revert here and it's ok.\n\n    tetuLiquidator.liquidate(sourceToken_, targetToken_, amountIn_, _getPriceImpactTolerance(sourceToken_));\n    amountOut = IERC20(targetToken_).balanceOf(address(this)) - targetTokenBalanceBefore;\n\n    IERC20(targetToken_).safeTransfer(receiver_, amountOut);\n\n    // The result amount cannot be too different from the value calculated directly using price oracle prices\n    require(\n      SwapLib.isConversionValid(\n        IPriceOracle(_controller.priceOracle()),\n        sourceToken_,\n        amountIn_,\n        targetToken_,\n        amountOut,\n        _getPriceImpactTolerance(targetToken_)\n      ),\n      AppErrors.TOO_HIGH_PRICE_IMPACT\n    );\n    emit OnSwap(sourceToken_, amountIn_, targetToken_, receiver_, amountOut);\n  }\n\n  /// @notice Make real swap to know result amount\n  ///         but exclude any additional operations\n  ///         like \"sending the result amount to a receiver\" or \"emitting any events\".\n  /// @dev This function should be called only inside static call to know result amount.\n  /// @param sourceAmountApprover_ A contract which has approved source amount to TetuConverter\n  ///                              and called a function findSwapStrategy\n  /// @param sourceAmount_ Amount in terms of {sourceToken_} to be converter to {targetToken_}\n  /// @return amountOut Result amount in terms of {targetToken_} after conversion\n  function simulateSwap(\n    address sourceAmountApprover_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external override returns (uint) {\n    IConverterController _controller = IConverterController(controller());\n    require(msg.sender == _controller.swapManager(), AppErrors.ONLY_SWAP_MANAGER);\n\n    IRequireAmountBySwapManagerCallback(_controller.tetuConverter()).onRequireAmountBySwapManager(\n      sourceAmountApprover_,\n      sourceToken_,\n      sourceAmount_\n    );\n\n    uint targetTokenBalanceBefore = IERC20(targetToken_).balanceOf(address(this));\n\n    ITetuLiquidator tetuLiquidator = ITetuLiquidator(_controller.tetuLiquidator());\n    IERC20(sourceToken_).safeApprove(address(tetuLiquidator), sourceAmount_);\n    tetuLiquidator.liquidate(sourceToken_, targetToken_, sourceAmount_, _getPriceImpactTolerance(sourceToken_));\n    return IERC20(targetToken_).balanceOf(address(this)) - targetTokenBalanceBefore;\n  }\n\n  /// @notice Calculate APR using known {sourceToken_} and known {targetAmount_}\n  ///         as 2 * loss / sourceAmount\n  ///         loss - conversion loss, we use 2 multiplier to take into account losses for there and back conversions.\n  /// @param sourceAmount_ Source amount before conversion, in terms of {sourceToken_}\n  /// @param targetAmount_ Result of conversion. The amount is in terms of {targetToken_}\n  function getApr18(\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint targetAmount_\n  ) external view override returns (int) {\n    uint targetAmountInSourceTokens = SwapLib.convertUsingPriceOracle(\n      IPriceOracle(IConverterController(controller()).priceOracle()),\n      targetToken_,\n      targetAmount_,\n      sourceToken_\n    );\n\n    // calculate result APR\n    // we need to multiple one-way-loss on to to get loss for there-and-back conversion\n    return 2 * (int(sourceAmount_) - int(targetAmountInSourceTokens)) * APR_NUMERATOR / int(sourceAmount_);\n  }\n\n  /// @notice Return custom or default price impact tolerance for the asset\n  function getPriceImpactTolerance(address asset_) external view override returns (uint priceImpactTolerance) {\n    return _getPriceImpactTolerance(asset_);\n  }\n  //endregion ----------------------------------------------------- ISwapConverter Implementation\n\n  //region ----------------------------------------------------- View functions\n  /// @notice Return custom or default price impact tolerance for the asset\n  function _getPriceImpactTolerance(address asset_) internal view returns (uint priceImpactTolerance) {\n    priceImpactTolerance = priceImpactTolerances[asset_];\n    if (priceImpactTolerance == 0) {\n      priceImpactTolerance = PRICE_IMPACT_TOLERANCE_DEFAULT;\n    }\n  }\n  //endregion ----------------------------------------------------- View functions\n\n  //region ----------------------------------------------------- Swap simulation\n  //           Simulate real swap\n  //           using gnosis simulate() and simulateAndRevert() functions\n  //           They are slightly more efficient than try/catch approach\n  //           see SimulateTesterTest.ts\n\n  /// Source: https://github.com/gnosis/util-contracts/blob/main/contracts/storage/StorageSimulation.sol\n  ///\n  /// @dev Performs a delegetecall on a targetContract in the context of self.\n  /// Internally reverts execution to avoid side effects (making it static).\n  ///\n  /// This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\n  /// Specifically, the `returndata` after a call to this method will be:\n  /// `success:bool || response.length:uint256 || response:bytes`.\n  ///\n  /// @param targetContract Address of the contract containing the code to execute.\n  /// @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n  function simulateAndRevert(\n    address targetContract,\n    bytes memory calldataPayload\n  ) public {\n    // there are no restrictions for the msg.sender\n\n    assembly {\n      let success := delegatecall(\n      gas(),\n      targetContract,\n      add(calldataPayload, 0x20),\n      mload(calldataPayload),\n      0,\n      0\n      )\n\n      mstore(0x00, success)\n      mstore(0x20, returndatasize())\n      returndatacopy(0x40, 0, returndatasize())\n      revert(0, add(returndatasize(), 0x40))\n    }\n  }\n\n  ///  Source: https://github.com/gnosis/util-contracts/blob/main/contracts/storage/StorageAccessible.sol\n  ///  @dev Simulates a delegate call to a target contract in the context of self.\n  ///\n  ///  Internally reverts execution to avoid side effects (making it static).\n  ///  Catches revert and returns encoded result as bytes.\n  ///\n  ///  @param targetContract Address of the contract containing the code to execute.\n  ///  @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\n  function simulate(\n    address targetContract,\n    bytes calldata calldataPayload\n  ) external override returns (bytes memory response) {\n    // there are no restrictions for the msg.sender\n\n    // Suppress compiler warnings about not using parameters, while allowing\n    // parameters to keep names for documentation purposes. This does not\n    // generate code.\n    targetContract;\n    calldataPayload;\n\n    assembly {\n      let internalCalldata := mload(0x40)\n    // Store `simulateAndRevert.selector`.\n      mstore(internalCalldata, \"\\xb4\\xfa\\xba\\x09\")\n    // Abuse the fact that both this and the internal methods have the\n    // same signature, and differ only in symbol name (and therefore,\n    // selector) and copy calldata directly. This saves us approximately\n    // 250 bytes of code and 300 gas at runtime over the\n    // `abi.encodeWithSelector` builtin.\n      calldatacopy(\n      add(internalCalldata, 0x04),\n      0x04,\n      sub(calldatasize(), 0x04)\n      )\n\n    // `pop` is required here by the compiler, as top level expressions\n    // can't have return values in inline assembly. `call` typically\n    // returns a 0 or 1 value indicated whether or not it reverted, but\n    // since we know it will always revert, we can safely ignore it.\n      pop(call(\n      gas(),\n      address(),\n      0,\n      internalCalldata,\n      calldatasize(),\n      // The `simulateAndRevert` call always reverts, and instead\n      // encodes whether or not it was successful in the return data.\n      // The first 32-byte word of the return data contains the\n      // `success` value, so write it to memory address 0x00 (which is\n      // reserved Solidity scratch space and OK to use).\n      0x00,\n      0x20\n      ))\n\n\n    // Allocate and copy the response bytes, making sure to increment\n    // the free memory pointer accordingly (in case this method is\n    // called as an internal function). The remaining `returndata[0x20:]`\n    // contains the ABI encoded response bytes, so we can just write it\n    // as is to memory.\n      let responseSize := sub(returndatasize(), 0x20)\n      response := mload(0x40)\n      mstore(0x40, add(response, responseSize))\n      returndatacopy(response, 0x20, responseSize)\n\n      if iszero(mload(0x00)) {\n        revert(add(response, 0x20), mload(response))\n      }\n    }\n  }\n  //endregion ----------------------------------------------------- Swap simulation\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/core/TetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../libs/AppDataTypes.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppUtils.sol\";\nimport \"../libs/EntryKinds.sol\";\nimport \"../libs/SwapLib.sol\";\nimport \"../openzeppelin/IERC20Metadata.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/IERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/IBorrowManager.sol\";\nimport \"../interfaces/ISwapManager.sol\";\nimport \"../interfaces/ITetuConverter.sol\";\nimport \"../interfaces/IPlatformAdapter.sol\";\nimport \"../interfaces/IPoolAdapter.sol\";\nimport \"../interfaces/IConverterController.sol\";\nimport \"../interfaces/IDebtMonitor.sol\";\nimport \"../interfaces/IConverter.sol\";\nimport \"../interfaces/ISwapConverter.sol\";\nimport \"../interfaces/IKeeperCallback.sol\";\nimport \"../interfaces/ITetuConverterCallback.sol\";\nimport \"../interfaces/IRequireAmountBySwapManagerCallback.sol\";\nimport \"../interfaces/IPriceOracle.sol\";\nimport \"../integrations/tetu/ITetuLiquidator.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @notice Main application contract\ncontract TetuConverter is ControllableV3, ITetuConverter, IKeeperCallback, IRequireAmountBySwapManagerCallback, ReentrancyGuard {\n  using SafeERC20 for IERC20;\n  using AppUtils for uint;\n\n  //region ----------------------------------------------------- Constants\n  string public constant TETU_CONVERTER_VERSION = \"1.0.0\";\n  /// @notice After additional borrow result health factor should be near to target value, the difference is limited.\n  uint constant public ADDITIONAL_BORROW_DELTA_DENOMINATOR = 1;\n  uint constant internal DEBT_GAP_DENOMINATOR = 100_000;\n  /// @dev Absolute value of debt-gap-addon for any token\n  /// @notice A value of the debt gap, calculate using debt-gap percent, cannot be less than the following\n  uint internal constant MIN_DEBT_GAP_ADDON = 10;\n  //endregion ----------------------------------------------------- Constants\n\n  //region ----------------------------------------------------- Data types\n  struct RepayLocal {\n    address[] poolAdapters;\n    uint len;\n    uint debtGap;\n    IPoolAdapter pa;\n    uint totalDebtForPoolAdapter;\n    bool debtGapRequired;\n    IConverterController controller;\n  }\n\n  /// @notice Local vars for {findConversionStrategy}\n  struct FindConversionStrategyLocal {\n    address[] borrowConverters;\n    uint[] borrowSourceAmounts;\n    uint[] borrowTargetAmounts;\n    int[] borrowAprs18;\n    address swapConverter;\n    uint swapSourceAmount;\n    uint swapTargetAmount;\n    int swapApr18;\n  }\n  //endregion ----------------------------------------------------- Data types\n\n  //region ----------------------------------------------------- Events\n  event OnSwap(address signer, address converter, address sourceAsset, uint sourceAmount, address targetAsset, address receiver, uint targetAmountOut);\n  event OnBorrow(address poolAdapter, uint collateralAmount, uint amountToBorrow, address receiver, uint borrowedAmountOut);\n  event OnRepayBorrow(address poolAdapter, uint amountToRepay, address receiver, bool closePosition);\n\n  /// @notice A part of target amount cannot be repaid or swapped\n  ///         so it was just returned back to receiver as is\n  event OnRepayReturn(address asset, address receiver, uint amount);\n  event OnRequireRepayCloseLiquidatedPosition(address poolAdapter, uint statusAmountToPay);\n  event OnRequireRepayRebalancing(address poolAdapter, uint amount, bool isCollateral, uint statusAmountToPay, uint healthFactorAfterRepay18);\n  event OnClaimRewards(address poolAdapter, address rewardsToken, uint amount, address receiver);\n  event OnSafeLiquidate(address sourceToken, uint sourceAmount, address targetToken, address receiver, uint outputAmount);\n  event OnRepayTheBorrow(address poolAdapter, uint collateralOut, uint repaidAmountOut);\n  event OnSalvage(address receiver, address token, uint amount);\n  //endregion ----------------------------------------------------- Events\n\n  //region ----------------------------------------------------- Initialization\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n  //endregion ----------------------------------------------------- Initialization\n\n  //region ----------------------------------------------------- Access\n  function _getControllerWhitelistedOnly() internal view returns (IConverterController controllerOut) {\n    controllerOut = IConverterController(controller());\n    require(controllerOut.isWhitelisted(msg.sender), AppErrors.OUT_OF_WHITE_LIST);\n  }\n  function _getControllerGovernanceOnly() internal view returns (IConverterController controllerOut) {\n    controllerOut = IConverterController(controller());\n    require(msg.sender == controllerOut.governance(), AppErrors.GOVERNANCE_ONLY);\n  }\n  //endregion ----------------------------------------------------- Access\n\n  //region ----------------------------------------------------- Find best strategy for conversion\n\n  /// @inheritdoc ITetuConverter\n  function findConversionStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external override returns (\n    address converter,\n    uint collateralAmountOut,\n    uint amountToBorrowOut,\n    int apr18\n  ) {\n    require(amountIn_ != 0, AppErrors.ZERO_AMOUNT);\n    require(periodInBlocks_ != 0, AppErrors.INCORRECT_VALUE);\n\n    IConverterController _controller = _getControllerWhitelistedOnly();\n\n    FindConversionStrategyLocal memory p;\n    if (!_controller.paused()) {\n      (p.borrowConverters,\n        p.borrowSourceAmounts,\n        p.borrowTargetAmounts,\n        p.borrowAprs18\n      ) = IBorrowManager(_controller.borrowManager()).findConverter(entryData_, sourceToken_, targetToken_, amountIn_, periodInBlocks_);\n\n      (p.swapConverter,\n        p.swapSourceAmount,\n        p.swapTargetAmount,\n        p.swapApr18) = _findSwapStrategy(_controller, entryData_, sourceToken_, amountIn_, targetToken_);\n    }\n\n    if (p.borrowConverters.length == 0) {\n      return (p.swapConverter == address(0))\n        ? (address(0), uint(0), uint(0), int(0))\n        : (p.swapConverter, p.swapSourceAmount, p.swapTargetAmount, p.swapApr18);\n    } else {\n      if (p.swapConverter == address(0)) {\n        return (p.borrowConverters[0], p.borrowSourceAmounts[0], p.borrowTargetAmounts[0], p.borrowAprs18[0]);\n      } else {\n        return (p.swapApr18 > p.borrowAprs18[0])\n          ? (p.borrowConverters[0], p.borrowSourceAmounts[0], p.borrowTargetAmounts[0], p.borrowAprs18[0])\n          : (p.swapConverter, p.swapSourceAmount, p.swapTargetAmount, p.swapApr18);\n      }\n    }\n  }\n\n  /// @inheritdoc ITetuConverter\n  function findBorrowStrategies(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view override returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountToBorrowsOut,\n    int[] memory aprs18\n  ) {\n    require(amountIn_ != 0, AppErrors.ZERO_AMOUNT);\n    require(periodInBlocks_ != 0, AppErrors.INCORRECT_VALUE);\n\n    IConverterController _controller = IConverterController(controller());\n    return _controller.paused()\n      ? (converters, collateralAmountsOut, amountToBorrowsOut, aprs18) // no conversion is available\n      : IBorrowManager(_controller.borrowManager()).findConverter(entryData_, sourceToken_, targetToken_, amountIn_, periodInBlocks_);\n  }\n\n  /// @inheritdoc ITetuConverter\n  function findSwapStrategy(bytes memory entryData_, address sourceToken_, uint amountIn_, address targetToken_) external override returns (\n    address converter,\n    uint sourceAmountOut,\n    uint targetAmountOut,\n    int apr18\n  ) {\n    require(amountIn_ != 0, AppErrors.ZERO_AMOUNT);\n\n    IConverterController _controller = _getControllerWhitelistedOnly();\n    return _controller.paused()\n      ? (converter, sourceAmountOut, targetAmountOut, apr18) // no conversion is available\n      : _findSwapStrategy(_controller, entryData_, sourceToken_, amountIn_, targetToken_);\n  }\n\n  /// @notice Calculate amount to swap according to the given {entryData_} and estimate result amount of {targetToken_}\n  function _findSwapStrategy(\n    IConverterController controller_,\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_\n  ) internal returns (\n    address converter,\n    uint sourceAmountOut,\n    uint targetAmountOut,\n    int apr18\n  ) {\n    uint entryKind = EntryKinds.getEntryKind(entryData_);\n    if (entryKind == EntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\n      // Split {sourceAmount_} on two parts: C1 and C2. Swap C2 => {targetAmountOut}\n      // Result cost of {targetAmountOut} and C1 should be equal or almost equal\n      // For simplicity we assume here that swap doesn't have any lost:\n      // if S1 is swapped to S2 then costs of S1 and S2 are equal\n      sourceAmountOut = EntryKinds.getCollateralAmountToConvert(entryData_, amountIn_, 1, 1);\n    } else {\n      sourceAmountOut = amountIn_;\n    }\n\n    ISwapManager swapManager = ISwapManager(controller_.swapManager());\n    (converter, targetAmountOut) = swapManager.getConverter(msg.sender, sourceToken_, sourceAmountOut, targetToken_);\n    if (converter != address(0)) {\n      apr18 = swapManager.getApr18(sourceToken_, sourceAmountOut, targetToken_, targetAmountOut);\n    }\n\n    return (converter, sourceAmountOut, targetAmountOut, apr18);\n  }\n  //endregion ----------------------------------------------------- Find best strategy for conversion\n\n  //region ----------------------------------------------------- Make conversion, open position\n\n  /// @inheritdoc ITetuConverter\n  function borrow(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_\n  ) external override nonReentrant returns (\n    uint borrowedAmountOut\n  ) {\n    IConverterController _controller = _getControllerWhitelistedOnly();\n    require(receiver_ != address(0) && converter_ != address(0), AppErrors.ZERO_ADDRESS);\n    require(collateralAmount_ != 0 && amountToBorrow_ != 0, AppErrors.ZERO_AMOUNT);\n\n    IERC20(collateralAsset_).safeTransferFrom(msg.sender, address(this), collateralAmount_);\n    IBorrowManager borrowManager = IBorrowManager(_controller.borrowManager());\n\n    AppDataTypes.ConversionKind conversionKind = IConverter(converter_).getConversionKind();\n    if (conversionKind == AppDataTypes.ConversionKind.BORROW_2) {\n      // get exist or register new pool adapter\n      address poolAdapter = borrowManager.getPoolAdapter(converter_, msg.sender, collateralAsset_, borrowAsset_);\n\n      if (poolAdapter != address(0)) {\n        // the pool adapter can have three possible states:\n        // - healthy (normal), it's ok to make new borrow using the pool adapter\n        // - unhealthy, health factor is less 1. It means that liquidation happens and the pool adapter is not usable.\n        // - unhealthy, health factor is greater 1 but it's less min-allowed-value. It means, that rebalance wasn't made\n        (,, uint healthFactor18,,,) = IPoolAdapter(poolAdapter).getStatus();\n        if (healthFactor18 < 1e18) {\n          // the pool adapter is unhealthy, we should mark it as dirty and create new pool adapter for the borrow\n          borrowManager.markPoolAdapterAsDirty(converter_, msg.sender, collateralAsset_, borrowAsset_);\n          poolAdapter = address(0);\n        } else if (healthFactor18 <= (uint(_controller.minHealthFactor2()) * 10 ** (18 - 2))) {\n          // this is not normal situation\n          // keeper doesn't work? it's too risky to make new borrow\n          revert(AppErrors.REBALANCING_IS_REQUIRED);\n        }\n      }\n\n      // create new pool adapter if we don't have ready-to-borrow one\n      if (poolAdapter == address(0)) {\n        poolAdapter = borrowManager.registerPoolAdapter(converter_, msg.sender, collateralAsset_, borrowAsset_);\n\n        // TetuConverter doesn't keep assets on its balance, so it's safe to use infinity approve\n        IERC20(collateralAsset_).safeApprove(poolAdapter, 2 ** 255); // 2*255 is more gas-efficient than type(uint).max\n        IERC20(borrowAsset_).safeApprove(poolAdapter, 2 ** 255); // 2*255 is more gas-efficient than type(uint).max\n      }\n\n      // borrow target-amount and transfer borrowed amount to the receiver, infinity approve is assumed\n      borrowedAmountOut = IPoolAdapter(poolAdapter).borrow(collateralAmount_, amountToBorrow_, receiver_);\n      emit OnBorrow(poolAdapter, collateralAmount_, amountToBorrow_, receiver_, borrowedAmountOut);\n    } else if (conversionKind == AppDataTypes.ConversionKind.SWAP_1) {\n      require(converter_ == _controller.swapManager(), AppErrors.INCORRECT_CONVERTER_TO_SWAP);\n      borrowedAmountOut = _makeSwap(converter_, collateralAsset_, collateralAmount_, borrowAsset_, receiver_);\n    } else {\n      revert(AppErrors.UNSUPPORTED_CONVERSION_KIND);\n    }\n  }\n\n  /// @notice Transfer {sourceAmount_} to swap-converter, make swap, return result target amount\n  function _makeSwap(address swapConverter, address sourceAsset_, uint amountIn, address targetAsset_, address receiver_) internal returns (\n    uint amountOut\n  ) {\n    IERC20(sourceAsset_).safeTransfer(swapConverter, amountIn);\n    amountOut = ISwapConverter(swapConverter).swap(sourceAsset_, amountIn, targetAsset_, receiver_);\n    emit OnSwap(msg.sender, swapConverter, sourceAsset_, amountIn, targetAsset_, receiver_, amountOut);\n  }\n  //endregion ----------------------------------------------------- Make conversion, open position\n\n  //region ----------------------------------------------------- Make repay, close position\n\n  /// @inheritdoc ITetuConverter\n  function repay(address collateralAsset_, address borrowAsset_, uint amountToRepay_, address receiver_) external override nonReentrant returns (\n    uint collateralAmountOut,\n    uint returnedBorrowAmountOut,\n    uint swappedLeftoverCollateralOut,\n    uint swappedLeftoverBorrowOut\n  ) {\n    RepayLocal memory v;\n\n    v.controller = _getControllerWhitelistedOnly();\n    require(receiver_ != address(0), AppErrors.ZERO_ADDRESS);\n\n    // ensure that we have received required amount\n    require(amountToRepay_ <= IERC20(borrowAsset_).balanceOf(address(this)), AppErrors.WRONG_AMOUNT_RECEIVED);\n\n    // we will decrease amountToRepay_ in the code (to avoid creation additional variable)\n    // it shows how much is left to convert from borrow asset to collateral asset\n\n    // we need to repay exact amount using any pool adapters; simplest strategy: use first available pool adapter\n    v.poolAdapters = IDebtMonitor(v.controller.debtMonitor()).getPositions(msg.sender, collateralAsset_, borrowAsset_);\n    v.len = v.poolAdapters.length;\n    v.debtGap = v.controller.debtGap();\n\n    // at first repay debts for any opened positions, repay don't make any rebalancing here\n    for (uint i; i < v.len; i = i.uncheckedInc()) {\n      if (amountToRepay_ == 0) break;\n      v.pa = IPoolAdapter(v.poolAdapters[i]);\n      v.pa.updateStatus();\n\n      (, v.totalDebtForPoolAdapter,,,, v.debtGapRequired) = v.pa.getStatus();\n\n      if (v.debtGapRequired) {\n        // we assume here, that amountToRepay_ includes all required dept-gaps\n        v.totalDebtForPoolAdapter = getAmountWithDebtGap(v.totalDebtForPoolAdapter, v.debtGap);\n      }\n      uint amountToPayToPoolAdapter = amountToRepay_ >= v.totalDebtForPoolAdapter\n        ? v.totalDebtForPoolAdapter\n        : amountToRepay_;\n\n      // make repayment, assume infinity approve: IERC20(borrowAsset_).safeApprove(address(pa), amountToPayToPoolAdapter);\n      bool closePosition = amountToPayToPoolAdapter == v.totalDebtForPoolAdapter;\n      collateralAmountOut += v.pa.repay(amountToPayToPoolAdapter, receiver_, closePosition);\n      amountToRepay_ -= amountToPayToPoolAdapter;\n\n      emit OnRepayBorrow(address(v.pa), amountToPayToPoolAdapter, receiver_, closePosition);\n    }\n\n    // if all debts were paid but we still have some amount of borrow asset\n    // let's swap it to collateral asset and send to collateral-receiver\n    if (amountToRepay_ > 0) {\n      // getConverter requires the source amount be approved to TetuConverter, but a contract doesn't need to approve itself\n      (address converter,) = ISwapManager(v.controller.swapManager()).getConverter(address(this), borrowAsset_, amountToRepay_, collateralAsset_);\n\n      if (converter == address(0)) {\n        // there is no swap-strategy to convert remain {amountToPay} to {collateralAsset_}\n        // let's return this amount back to the {receiver_}\n        returnedBorrowAmountOut = amountToRepay_;\n        IERC20(borrowAsset_).safeTransfer(receiver_, amountToRepay_);\n        emit OnRepayReturn(borrowAsset_, receiver_, amountToRepay_);\n      } else {\n        // conversion strategy is found, let's convert all remaining {amountToPay} to {collateralAsset}\n        swappedLeftoverCollateralOut = _makeSwap(converter, borrowAsset_, amountToRepay_, collateralAsset_, receiver_);\n        swappedLeftoverBorrowOut = amountToRepay_;\n\n        collateralAmountOut += swappedLeftoverCollateralOut;\n      }\n    }\n\n    return (collateralAmountOut, returnedBorrowAmountOut, swappedLeftoverCollateralOut, swappedLeftoverBorrowOut);\n  }\n\n  /// @inheritdoc ITetuConverter\n  function quoteRepay(address user_, address collateralAsset_, address borrowAsset_, uint amountToRepay_) external override returns (\n    uint collateralAmountOut,\n    uint swappedAmountOut\n  ) {\n    IConverterController _controller = _getControllerWhitelistedOnly();\n\n    address[] memory poolAdapters = IDebtMonitor(_controller.debtMonitor()).getPositions(user_, collateralAsset_, borrowAsset_);\n    uint len = poolAdapters.length;\n    for (uint i; i < len; i = i.uncheckedInc()) {\n      if (amountToRepay_ == 0) break;\n\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\n      pa.updateStatus();\n\n      // debt-gaps are not taken into account here because getCollateralAmountToReturn doesn't take it into account\n      (, uint totalDebtForPoolAdapter,,,,) = pa.getStatus();\n\n      bool closePosition = totalDebtForPoolAdapter <= amountToRepay_;\n      uint currentAmountToRepay = closePosition ? totalDebtForPoolAdapter : amountToRepay_;\n      uint collateralAmountToReceive = pa.getCollateralAmountToReturn(currentAmountToRepay, closePosition);\n\n      amountToRepay_ -= currentAmountToRepay;\n      collateralAmountOut += collateralAmountToReceive;\n    }\n\n    if (amountToRepay_ > 0) {\n      IPriceOracle priceOracle = IPriceOracle(_controller.priceOracle());\n      uint priceBorrowAsset = priceOracle.getAssetPrice(borrowAsset_);\n      uint priceCollateralAsset = priceOracle.getAssetPrice(collateralAsset_);\n      require(priceCollateralAsset != 0 && priceBorrowAsset != 0, AppErrors.ZERO_PRICE);\n\n      swappedAmountOut = amountToRepay_\n        * 10 ** IERC20Metadata(collateralAsset_).decimals()\n        * priceBorrowAsset\n        / priceCollateralAsset\n        / 10 ** IERC20Metadata(borrowAsset_).decimals();\n    }\n\n    return (collateralAmountOut + swappedAmountOut, swappedAmountOut);\n  }\n  //endregion ----------------------------------------------------- Make repay, close position\n\n  //region ----------------------------------------------------- IKeeperCallback\n\n  /// @inheritdoc IKeeperCallback\n  function requireRepay(\n    uint requiredBorrowedAmount_,\n    uint requiredCollateralAmount_,\n    address poolAdapter_\n  ) external nonReentrant override {\n    require(IConverterController(controller()).keeper() == msg.sender, AppErrors.KEEPER_ONLY);\n    require(requiredBorrowedAmount_ != 0, AppErrors.INCORRECT_VALUE);\n\n    IPoolAdapter pa = IPoolAdapter(poolAdapter_);\n    (,address user, address collateralAsset,) = pa.getConfig();\n    pa.updateStatus();\n    (, uint amountToPay,,,,) = pa.getStatus();\n\n    if (requiredCollateralAmount_ == 0) {\n      // Full liquidation happens, we have lost all collateral amount\n      // We need to close the position as is and drop away the pool adapter without paying any debt\n      IDebtMonitor(IConverterController(controller()).debtMonitor()).closeLiquidatedPosition(address(pa));\n      emit OnRequireRepayCloseLiquidatedPosition(address(pa), amountToPay);\n    } else {\n      // rebalancing\n      // we assume here, that requiredBorrowedAmount_ should be less than amountToPay even if it includes the debt-gap\n      require(amountToPay != 0 && requiredBorrowedAmount_ < amountToPay, AppErrors.REPAY_TO_REBALANCE_NOT_ALLOWED);\n\n      // for borrowers it's much easier to return collateral asset than borrow asset\n      // so ask the borrower to send us collateral asset\n      uint balanceBefore = IERC20(collateralAsset).balanceOf(address(this));\n      ITetuConverterCallback(user).requirePayAmountBack(collateralAsset, requiredCollateralAmount_);\n      uint balanceAfter = IERC20(collateralAsset).balanceOf(address(this));\n\n      // ensure that we have received any amount .. and use it for repayment\n      // probably we've received less then expected - it's ok, just let's use as much as possible\n      // DebtMonitor will ask to make rebalancing once more if necessary\n      require(\n        balanceAfter > balanceBefore // smth is wrong\n        && balanceAfter - balanceBefore <= requiredCollateralAmount_, // we can receive less amount (partial rebalancing)\n        AppErrors.WRONG_AMOUNT_RECEIVED\n      );\n      uint amount = balanceAfter - balanceBefore;\n      // replaced by infinity approve: IERC20(collateralAsset).safeApprove(poolAdapter_, requiredAmountCollateralAsset_);\n\n      uint resultHealthFactor18 = pa.repayToRebalance(amount, true);\n      emit OnRequireRepayRebalancing(address(pa), amount, true, amountToPay, resultHealthFactor18);\n    }\n  }\n  //endregion ----------------------------------------------------- IKeeperCallback\n\n  //region ----------------------------------------------------- Close borrow forcibly by governance\n\n  /// @inheritdoc ITetuConverter\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (uint collateralAmountOut, uint repaidAmountOut) {\n    IConverterController _controller = _getControllerGovernanceOnly();\n\n    // update internal debts and get actual amount to repay\n    IPoolAdapter pa = IPoolAdapter(poolAdapter_);\n    (,address user, address collateralAsset, address borrowAsset) = pa.getConfig();\n    pa.updateStatus();\n\n    // add debt gap if necessary\n    bool debtGapRequired;\n    (collateralAmountOut, repaidAmountOut,,,, debtGapRequired) = pa.getStatus();\n    if (debtGapRequired) {\n      repaidAmountOut = getAmountWithDebtGap(repaidAmountOut, _controller.debtGap());\n    }\n    require(collateralAmountOut != 0 && repaidAmountOut != 0, AppErrors.REPAY_FAILED);\n\n    // ask the user for the amount-to-repay; use exist balance for safety, normally it should be 0\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\n    ITetuConverterCallback(user).requirePayAmountBack(borrowAsset, repaidAmountOut - balanceBefore);\n    uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\n\n    // ensure that we have received required amount fully or partially\n    if (closePosition) {\n      require(balanceAfter >= balanceBefore + repaidAmountOut, AppErrors.WRONG_AMOUNT_RECEIVED);\n    } else {\n      require(balanceAfter > balanceBefore, AppErrors.ZERO_BALANCE);\n      repaidAmountOut = balanceAfter - balanceBefore;\n    }\n\n    // make full repay and close the position\n    balanceBefore = IERC20(borrowAsset).balanceOf(user);\n    collateralAmountOut = pa.repay(repaidAmountOut, user, closePosition);\n    emit OnRepayTheBorrow(poolAdapter_, collateralAmountOut, repaidAmountOut);\n    balanceAfter = IERC20(borrowAsset).balanceOf(user);\n\n    address[] memory assets = new address[](2);\n    assets[0] = borrowAsset;\n    assets[1] = collateralAsset;\n\n    uint[] memory amounts = new uint[](2);\n    // repay is able to return small amount of borrow-asset back to the user, we should pass it to onTransferAmounts\n    amounts[0] = balanceAfter > balanceBefore ? balanceAfter - balanceBefore : 0;\n    if (amounts[0] > 0) { // exclude returned part of the debt gap from repaidAmountOut\n      repaidAmountOut = repaidAmountOut > amounts[0]\n        ? repaidAmountOut - amounts[0]\n        : 0;\n    }\n    amounts[1] = collateralAmountOut;\n    ITetuConverterCallback(user).onTransferAmounts(assets, amounts);\n\n    return (collateralAmountOut, repaidAmountOut);\n  }\n  //endregion ----------------------------------------------------- Close borrow forcibly by governance\n\n  //region ----------------------------------------------------- Get debt/repay info\n\n  /// @inheritdoc ITetuConverter\n  function getDebtAmountCurrent(address user_, address collateralAsset_, address borrowAsset_, bool useDebtGap_) external override nonReentrant returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) {\n    IConverterController _controller = _getControllerWhitelistedOnly();\n\n    address[] memory poolAdapters = IDebtMonitor(_controller.debtMonitor()).getPositions(user_, collateralAsset_, borrowAsset_);\n    uint len = poolAdapters.length;\n\n    uint debtGap = useDebtGap_ ? _controller.debtGap() : 0;\n\n    for (uint i; i < len; i = i.uncheckedInc()) {\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\n      pa.updateStatus();\n      (totalDebtAmountOut, totalCollateralAmountOut) = _addDebtAmounts(pa, totalDebtAmountOut, totalCollateralAmountOut, debtGap);\n    }\n\n    return (totalDebtAmountOut, totalCollateralAmountOut);\n  }\n\n  /// @inheritdoc ITetuConverter\n  function getDebtAmountStored(address user_, address collateralAsset_, address borrowAsset_, bool useDebtGap_) external view override returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) {\n    IConverterController _controller = IConverterController(controller());\n\n    address[] memory poolAdapters = IDebtMonitor(_controller.debtMonitor()).getPositions(user_, collateralAsset_, borrowAsset_);\n    uint len = poolAdapters.length;\n\n    uint debtGap = useDebtGap_ ? _controller.debtGap() : 0;\n\n    for (uint i; i < len; i = i.uncheckedInc()) {\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\n      (totalDebtAmountOut, totalCollateralAmountOut) = _addDebtAmounts(pa, totalDebtAmountOut, totalCollateralAmountOut, debtGap);\n    }\n\n    return (totalDebtAmountOut, totalCollateralAmountOut);\n  }\n\n  /// @notice A function to reduce contract size (shared code from getDebtAmountCurrent and getDebtAmountStored)\n  function _addDebtAmounts(IPoolAdapter pa, uint amountDebt_, uint collateralAmount_, uint debtGap) internal view returns (\n    uint debtAmountOut,\n    uint collateralAmountOut\n  ) {\n    (uint collateralAmount, uint totalDebtForPoolAdapter,,,, bool debtGapRequired) = pa.getStatus();\n    debtAmountOut = amountDebt_ + (\n      (debtGap != 0 && debtGapRequired)\n        ? getAmountWithDebtGap(totalDebtForPoolAdapter, debtGap)\n        : totalDebtForPoolAdapter\n    );\n    collateralAmountOut = collateralAmount_ + collateralAmount;\n  }\n\n\n  /// @inheritdoc ITetuConverter\n  function estimateRepay(address user_, address collateralAsset_, uint collateralAmountToRedeem_, address borrowAsset_) external view override returns (\n    uint borrowAssetAmount,\n    uint unobtainableCollateralAssetAmount\n  ) {\n    IConverterController _controller = IConverterController(controller());\n\n    address[] memory poolAdapters = IDebtMonitor(_controller.debtMonitor()).getPositions(user_, collateralAsset_, borrowAsset_);\n    uint len = poolAdapters.length;\n\n    uint collateralAmountRemained = collateralAmountToRedeem_;\n    for (uint i; i < len; i = i.uncheckedInc()) {\n      if (collateralAmountRemained == 0) break;\n\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\n      (uint collateralAmount, uint borrowedAmount,,,,bool debtGapRequired) = pa.getStatus();\n      if (debtGapRequired) {\n        borrowedAmount = getAmountWithDebtGap(borrowedAmount, _controller.debtGap());\n      }\n\n      if (collateralAmountRemained >= collateralAmount) {\n        collateralAmountRemained -= collateralAmount;\n        borrowAssetAmount += borrowedAmount;\n      } else {\n        borrowAssetAmount += borrowedAmount * collateralAmountRemained / collateralAmount;\n        collateralAmountRemained = 0;\n      }\n    }\n\n    return (borrowAssetAmount, collateralAmountRemained);\n  }\n\n  /// @inheritdoc ITetuConverter\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external view returns (\n    address[] memory poolAdaptersOut\n  ) {\n    return IDebtMonitor(IConverterController(controller()).debtMonitor()).getPositions(user_, collateralToken_, borrowedToken_);\n  }\n  //endregion ----------------------------------------------------- Get debt/repay info\n\n  //region ----------------------------------------------------- Check and claim rewards\n\n  /// @inheritdoc ITetuConverter\n  function claimRewards(address receiver_) external override nonReentrant returns (\n    address[] memory rewardTokensOut,\n    uint[] memory amountsOut\n  ) {\n    // The sender is able to claim his own rewards only, so no need to check sender\n    address[] memory poolAdapters = IDebtMonitor(IConverterController(controller()).debtMonitor()).getPositionsForUser(msg.sender);\n\n    uint len = poolAdapters.length;\n    address[] memory rewardTokens = new address[](len);\n    uint[] memory amounts = new uint[](len);\n    uint countPositions = 0;\n    for (uint i; i < len; i = i.uncheckedInc()) {\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\n      (rewardTokens[countPositions], amounts[countPositions]) = pa.claimRewards(receiver_);\n      if (amounts[countPositions] != 0) {\n        emit OnClaimRewards(address(pa), rewardTokens[countPositions], amounts[countPositions], receiver_);\n        ++countPositions;\n      }\n    }\n\n    if (countPositions != 0) {\n      rewardTokensOut = AppUtils.removeLastItems(rewardTokens, countPositions);\n      amountsOut = AppUtils.removeLastItems(amounts, countPositions);\n    }\n\n    return (rewardTokensOut, amountsOut);\n  }\n\n  /// @inheritdoc ITetuConverter\n  function salvage(address receiver, address token, uint amount) external {\n    _getControllerGovernanceOnly();\n\n    IERC20(token).safeTransfer(receiver, amount);\n    emit OnSalvage(receiver, token, amount);\n  }\n\n  //endregion ----------------------------------------------------- Check and claim rewards\n\n  //region ----------------------------------------------------- Simulate swap\n\n  /// @notice Transfer {sourceAmount_} approved by {approver_} to swap manager\n  function onRequireAmountBySwapManager(address approver_, address sourceToken_, uint sourceAmount_) external override {\n    address swapManager = IConverterController(controller()).swapManager();\n    require(swapManager == msg.sender, AppErrors.ONLY_SWAP_MANAGER);\n\n    if (approver_ == address(this)) {\n      IERC20(sourceToken_).safeTransfer(swapManager, sourceAmount_);\n    } else {\n      IERC20(sourceToken_).safeTransferFrom(approver_, swapManager, sourceAmount_);\n    }\n  }\n  //endregion ----------------------------------------------------- Simulate swap\n\n  //region ----------------------------------------------------- Liquidate with checking\n\n  /// @inheritdoc ITetuConverter\n  function safeLiquidate(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    address receiver_,\n    uint priceImpactToleranceSource_,\n    uint priceImpactToleranceTarget_\n  ) override external returns (\n    uint amountOut\n  ) {\n    IConverterController _controller = _getControllerWhitelistedOnly();\n\n    ITetuLiquidator tetuLiquidator = ITetuLiquidator(_controller.tetuLiquidator());\n    uint targetTokenBalanceBefore = IERC20(assetOut_).balanceOf(address(this));\n\n    IERC20(assetIn_).safeApprove(address(tetuLiquidator), amountIn_);\n    tetuLiquidator.liquidate(assetIn_, assetOut_, amountIn_, priceImpactToleranceSource_);\n\n    amountOut = IERC20(assetOut_).balanceOf(address(this)) - targetTokenBalanceBefore;\n    IERC20(assetOut_).safeTransfer(receiver_, amountOut);\n\n    require(  // The result amount shouldn't be too different from the value calculated directly using price oracle prices\n      SwapLib.isConversionValid(IPriceOracle(_controller.priceOracle()), assetIn_, amountIn_, assetOut_, amountOut, priceImpactToleranceTarget_),\n      AppErrors.TOO_HIGH_PRICE_IMPACT\n    );\n    emit OnSafeLiquidate(assetIn_, amountIn_, assetOut_, receiver_, amountOut);\n  }\n\n  /// @inheritdoc ITetuConverter\n  function isConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    uint priceImpactTolerance_\n  ) external override view returns (bool) {\n    return SwapLib.isConversionValid(\n      IPriceOracle(IConverterController(controller()).priceOracle()),\n      assetIn_,\n      amountIn_,\n      assetOut_,\n      amountOut_,\n      priceImpactTolerance_\n    );\n  }\n  //endregion ----------------------------------------------------- Liquidate with checking\n\n  //region ----------------------------------------------------- Utils\n  /// @notice Add {debtGap} to the {amount}\n  /// @param debtGap debt-gap percent [0..1), decimals DEBT_GAP_DENOMINATOR\n  function getAmountWithDebtGap(uint amount, uint debtGap) public pure returns (uint) {\n    // Real value of debt gap in AAVE can be very low but it's greater than zero\n    // so, even if the amount is very low, the result debt gap addon must be greater than zero\n    // we assume here, that it should be not less than MIN_DEBT_GAP_ADDON\n    return Math.max(amount * (DEBT_GAP_DENOMINATOR + debtGap) / DEBT_GAP_DENOMINATOR, amount + MIN_DEBT_GAP_ADDON);\n  }\n  //endregion ----------------------------------------------------- Utils\n}\n\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/aave3/IAavePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Restored from 0x69FA688f1Dc47d4B5d8029D5a35FB7a548310654 (events were removed)\ninterface IAavePriceOracle {\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (address);\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   **/\n  function BASE_CURRENCY() external view returns (address);\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   **/\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   **/\n  function getAssetPrice(address asset) external view returns (uint256);\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] memory assets) external view returns (uint256[] memory);\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n  function setAssetSources(address[] memory assets, address[] memory sources) external;\n  function setFallbackOracle(address fallbackOracle) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/dforce/IDForceController.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Restored from 0xcf427e1ac52a2d976b02b83f72baeb905a92e488 (Optimism; events and _xxx were removed)\n/// @dev We need sources of Controller, see https://developers.dforce.network/lend/lend-and-synth/deployed-contracts\n///      but contract 0x52eaCd19E38D501D006D2023C813d7E37F025f37 doesn't have sources on polygonscan\n///      So, the sources were taken from the Optimism (source on Ethereum are exactly the same)\ninterface IDForceController {\n  /**\n   * @notice Hook function after iToken `borrow()`\n     * Will `revert()` if any operation fails\n     * @param _iToken The iToken being borrewd\n     * @param _borrower The account which borrowed iToken\n     * @param _borrowedAmount  The amount of underlying being borrowed\n     */\n  function afterBorrow(\n    address _iToken,\n    address _borrower,\n    uint256 _borrowedAmount\n  ) external;\n\n  /**\n   * @notice Hook function after iToken `flashloan()`\n     * Will `revert()` if any operation fails\n     * @param _iToken The iToken was flashloaned\n     * @param _to The account flashloan transfer to\n     * @param _amount  The amount was flashloaned\n     */\n  function afterFlashloan(\n    address _iToken,\n    address _to,\n    uint256 _amount\n  ) external;\n\n  function afterLiquidateBorrow(\n    address _iTokenBorrowed,\n    address _iTokenCollateral,\n    address _liquidator,\n    address _borrower,\n    uint256 _repaidAmount,\n    uint256 _seizedAmount\n  ) external;\n\n  function afterMint(\n    address _iToken,\n    address _minter,\n    uint256 _mintAmount,\n    uint256 _mintedAmount\n  ) external;\n\n  function afterRedeem(\n    address _iToken,\n    address _redeemer,\n    uint256 _redeemAmount,\n    uint256 _redeemedUnderlying\n  ) external;\n\n  function afterRepayBorrow(\n    address _iToken,\n    address _payer,\n    address _borrower,\n    uint256 _repayAmount\n  ) external;\n\n  function afterSeize(\n    address _iTokenCollateral,\n    address _iTokenBorrowed,\n    address _liquidator,\n    address _borrower,\n    uint256 _seizedAmount\n  ) external;\n\n  function afterTransfer(\n    address _iToken,\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external;\n\n  /**\n   * @notice Hook function before iToken `borrow()`\n     * Checks if the account should be allowed to borrow the given iToken\n     * Will `revert()` if any check fails\n     * @param _iToken The iToken to check the borrow against\n     * @param _borrower The account which would borrow iToken\n     * @param _borrowAmount The amount of underlying to borrow\n     */\n  function beforeBorrow(\n    address _iToken,\n    address _borrower,\n    uint256 _borrowAmount\n  ) external;\n\n  function beforeFlashloan(\n    address _iToken,\n    address _to,\n    uint256 _amount\n  ) external;\n\n  function beforeLiquidateBorrow(\n    address _iTokenBorrowed,\n    address _iTokenCollateral,\n    address _liquidator,\n    address _borrower,\n    uint256 _repayAmount\n  ) external;\n\n  function beforeMint(\n    address _iToken,\n    address _minter,\n    uint256 _mintAmount\n  ) external;\n\n  function beforeRedeem(\n    address _iToken,\n    address _redeemer,\n    uint256 _redeemAmount\n  ) external;\n\n  function beforeRepayBorrow(\n    address _iToken,\n    address _payer,\n    address _borrower,\n    uint256 _repayAmount\n  ) external;\n\n  function beforeSeize(\n    address _iTokenCollateral,\n    address _iTokenBorrowed,\n    address _liquidator,\n    address _borrower,\n    uint256 _seizeAmount\n  ) external;\n\n  function beforeTransfer(\n    address _iToken,\n    address _from,\n    address _to,\n    uint256 _amount\n  ) external;\n\n  /// @notice return account equity, shortfall, collateral value, borrowed value.\n  function calcAccountEquity(address _account)\n  external\n  view\n  returns (\n    uint256 accountEquity,\n    uint256 shortfall,\n    uint256 collateralValue,\n    uint256 borrowedValue\n  );\n\n  /**\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n  function closeFactorMantissa() external view returns (uint256);\n\n  /**\n   * @notice Only expect to be called by iToken contract.\n     * @dev Add the market to the account's markets list for liquidity calculations\n     * @param _account The address of the account to modify\n     */\n  function enterMarketFromiToken(address _market, address _account) external;\n\n  /**\n   * @notice Add markets to `msg.sender`'s markets list for liquidity calculations\n     * @param _iTokens The list of addresses of the iToken markets to be entered\n     * @return _results Success indicator for whether each corresponding market was entered\n     */\n  function enterMarkets(address[] memory _iTokens) external returns (bool[] memory _results);\n\n  /**\n   * @notice Remove markets from `msg.sender`'s collaterals for liquidity calculations\n     * @param _iTokens The list of addresses of the iToken to exit\n     * @return _results Success indicators for whether each corresponding market was exited\n     */\n  function exitMarkets(address[] memory _iTokens) external returns (bool[] memory _results);\n\n  /**\n   * @notice Return all of the iTokens\n     * @return _alliTokens The list of iToken addresses\n     */\n  function getAlliTokens() external view returns (address[] memory _alliTokens);\n\n  /**\n * @notice Returns the asset list the account has borrowed\n     * @param _account The address of the account to query\n     * @return _borrowedAssets The asset list the account has borrowed\n     */\n  function getBorrowedAssets(address _account) external view returns (address[] memory _borrowedAssets);\n\n  /**\n * @notice Returns the markets list the account has entered\n     * @param _account The address of the account to query\n     * @return _accountCollaterals The markets list the account has entered\n     */\n  function getEnteredMarkets(address _account) external view returns (address[] memory _accountCollaterals);\n\n  /**\n   * @notice Returns whether the given account has borrowed the given iToken\n     * @param _account The address of the account to check\n     * @param _iToken The iToken to check against\n     * @return True if the account has borrowed the iToken, otherwise false.\n     */\n  function hasBorrowed(address _account, address _iToken) external view returns (bool);\n\n  /**\n * @notice Returns whether the given account has entered the market\n     * @param _account The address of the account to check\n     * @param _iToken The iToken to check against\n     * @return True if the account has entered the market, otherwise false.\n     */\n  function hasEnteredMarket(address _account, address _iToken) external view returns (bool);\n\n  /**\n * @notice Check whether a iToken is listed in controller\n     * @param _iToken The iToken to check for\n     * @return true if the iToken is listed otherwise false\n     */\n  function hasiToken(address _iToken) external view returns (bool);\n  function initialize() external;\n  function isController() external view returns (bool);\n\n  function liquidateCalculateSeizeTokens(\n    address _iTokenBorrowed,\n    address _iTokenCollateral,\n    uint256 _actualRepayAmount\n  ) external view returns (uint256 _seizedTokenCollateral);\n\n  function liquidationIncentiveMantissa() external view returns (uint256);\n\n  /// @notice Mapping of iTokens to corresponding markets\n  function markets(address)\n  external\n  view\n  returns (\n    uint256 collateralFactorMantissa,\n    uint256 borrowFactorMantissa,\n    uint256 borrowCapacity,\n    uint256 supplyCapacity,\n    bool mintPaused,\n    bool redeemPaused,\n    bool borrowPaused\n  );\n\n  function owner() external view returns (address);\n  function pauseGuardian() external view returns (address);\n  function pendingOwner() external view returns (address);\n\n  /**\n   * @notice Oracle to query the price of a given asset\n     */\n  function priceOracle() external view returns (address);\n  function rewardDistributor() external view returns (address);\n\n  function seizePaused() external view returns (bool);\n\n  /// @notice whether global transfer is paused\n  function transferPaused() external view returns (bool);\n\n\n\n  function _setPriceOracle(address _newOracle) external;\n\n  /// @notice Sets the borrowCapacity for a iToken\n  function _setBorrowCapacity(address _iToken, uint256 _newBorrowCapacity) external;\n  /// @notice Sets the supplyCapacity for a iToken\n  function _setSupplyCapacity(address _iToken, uint256 _newSupplyCapacity) external;\n  function _setMintPaused(address _iToken, bool _paused) external;\n  function _setRedeemPaused(address _iToken, bool _paused) external;\n  function _setBorrowPaused(address _iToken, bool _paused) external;\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/dforce/IDForcePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Sources: https://github.com/dforce-network/LendingContractsV2\ninterface IDForcePriceOracle {\n  /**\n   * @notice Get the underlying price of a iToken asset\n     * @param _iToken The iToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable.\n     */\n  function getUnderlyingPrice(address _iToken)\n  external\n  view\n  returns (uint256);\n\n  /**\n   * @notice Get the price of a underlying asset\n     * @param _iToken The iToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable and whether the price is valid.\n     */\n  function getUnderlyingPriceAndStatus(address _iToken)\n  external\n  view\n  returns (uint256, bool);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/gelato/IOps.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface IOps {\n  function gelato() external view returns (address payable);\n  function taskTreasury() external view returns (address);\n}"
    },
    "@tetu_io/tetu-converter/contracts/integrations/gelato/IResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IResolver {\n    function checker()\n        external\n        view\n        returns (bool canExec, bytes memory execPayload);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/hundred-finance/IHfComptroller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Restored from 0xB426c1b7fABEa9EA6A273E8427040568a8C7DF13 (events and (most) _xxx were removed)\n/// @dev 0xB426c1b7fABEa9EA6A273E8427040568a8C7DF13 is implementation of 0xEdBA32185BAF7fEf9A26ca567bC4A6cbe426e499\n///      see https://docs.hundred.finance/developers/protocol-contracts/polygon\ninterface IHfComptroller {\n  function accountAssets(address, uint256) external view returns (address);\n  function admin() external view returns (address);\n  function allMarkets(uint256) external view returns (address);\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function borrowAllowed(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external returns (uint256);\n\n  /// @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n  function borrowCapGuardian() external view returns (address);\n  /// @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n  /// @dev https://github.com/compound-finance/compound-protocol/blob/master/contracts/ComptrollerStorage.sol\n  function borrowCaps(address cToken) external view returns (uint256);\n  function borrowGuardianPaused(address) external view returns (bool);\n\n  /**\n   * @notice Validates borrow and reverts on rejection. May emit logs.\n     * @param cToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n  function borrowVerify(\n    address cToken,\n    address borrower,\n    uint256 borrowAmount\n  ) external;\n\n  function bprotocol(address) external view returns (address);\n  /**\n   * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n  function checkMembership(address account, address cToken) external view returns (bool);\n\n  /**\n   * @notice Claim all the comp accrued by holder in the specified markets\n     * @param holder The address to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     */\n  function claimComp(address holder, address[] memory cTokens) external;\n  function claimComp(address[] memory holders, address[] memory cTokens) external;\n  /**\n   * @notice Claim all the comp accrued by holder in all markets\n     * @param holder The address to claim COMP for\n     */\n  function claimComp(address holder) external;\n  function closeFactorMantissa() external view returns (uint256);\n  function compAccrued(address) external view returns (uint256);\n  function compBorrowState(address) external view returns (uint224 index_, uint32 block_);\n  function compBorrowerIndex(address, address) external view returns (uint256);\n  function compContributorSpeeds(address) external view returns (uint256);\n  function compInitialIndex() external view returns (uint224);\n  function compRate() external view returns (uint256);\n  function compSpeeds(address) external view returns (uint256);\n  function compSupplierIndex(address, address) external view returns (uint256);\n  function compSupplyState(address) external view returns (uint224 index, uint32 block_);\n  /**\n   * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n  function enterMarkets(address[] memory cTokens) external returns (uint256[] memory);\n  /**\n   * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n  function exitMarket(address cTokenAddress) external returns (uint256);\n\n  /**\n   * @notice Determine the current account liquidity wrt collateral requirements\n   *         Return (possible error code (semi-opaque),\n   *         account liquidity in excess of collateral requirements,\n   *         account shortfall below collateral requirements)\n   */\n  function getAccountLiquidity(address account)\n  external view returns (uint256 error, uint256 liquidity, uint256 shortfall);\n\n  /**\n   * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n  function getAllMarkets() external view returns (address[] memory);\n  /**\n   * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n  function getAssetsIn(address account) external view returns (address[] memory);\n  function getBlockNumber() external view returns (uint256);\n\n  /**\n   * @notice Return the address of the COMP token\n     * @return The address of COMP\n     */\n  function getCompAddress() external pure returns (address);\n\n  /**\n   * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint256 redeemTokens,\n    uint256 borrowAmount\n  )\n  external\n  view\n  returns (\n    uint256,\n    uint256,\n    uint256\n  );\n\n  function implementation() external view returns (address);\n  function isComptroller() external view returns (bool);\n  function lastContributorBlock(address) external view returns (uint256);\n\n  /**\n   * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  /**\n   * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n  function liquidateBorrowVerify(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint256 actualRepayAmount,\n    uint256 seizeTokens\n  ) external;\n\n  /**\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint256 actualRepayAmount\n  ) external view returns (uint256, uint256);\n\n  function liquidationIncentiveMantissa() external view returns (uint256);\n\n  /// @return isListed represents whether the comptroller recognizes this cToken\n  /// @return collateralFactorMantissa scaled by 1e18, is multiplied by a supply balance to determine how much value can be borrowed\n  /// @return isComped indicates whether or not suppliers and borrowers are distributed COMP tokens.\n  function markets(address)\n  external\n  view\n  returns (\n    bool isListed,\n    uint256 collateralFactorMantissa,\n    bool isComped\n  );\n\n  function maxAssets() external view returns (uint256);\n\n  /**\n   * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function mintAllowed(\n    address cToken,\n    address minter,\n    uint256 mintAmount\n  ) external returns (uint256);\n\n  function mintGuardianPaused(address) external view returns (bool);\n\n  /**\n   * @notice Validates mint and reverts on rejection. May emit logs.\n     * @param cToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n  function mintVerify(\n    address cToken,\n    address minter,\n    uint256 actualMintAmount,\n    uint256 mintTokens\n  ) external;\n\n  function oracle() external view returns (address);\n  function pauseGuardian() external view returns (address);\n  function pendingAdmin() external view returns (address);\n  function pendingImplementation() external view returns (address);\n\n  /**\n   * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function redeemAllowed(\n    address cToken,\n    address redeemer,\n    uint256 redeemTokens\n  ) external returns (uint256);\n\n  /**\n   * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n  function redeemVerify(\n    address cToken,\n    address redeemer,\n    uint256 redeemAmount,\n    uint256 redeemTokens\n  ) external;\n\n  /**\n   * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 repayAmount\n  ) external returns (uint256);\n\n  /**\n   * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n     * @param cToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint256 actualRepayAmount,\n    uint256 borrowerIndex\n  ) external;\n\n  /**\n   * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external returns (uint256);\n\n  function seizeGuardianPaused() external view returns (bool);\n\n  /**\n   * @notice Validates seize and reverts on rejection. May emit logs.\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint256 seizeTokens\n  ) external;\n\n  /**\n   * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function transferAllowed(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external returns (uint256);\n\n  function transferGuardianPaused() external view returns (bool);\n\n  /**\n   * @notice Validates transfer and reverts on rejection. May emit logs.\n     * @param cToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     */\n  function transferVerify(\n    address cToken,\n    address src,\n    address dst,\n    uint256 transferTokens\n  ) external;\n\n  /**\n   * @notice Calculate additional accrued COMP for a contributor since last accrual\n     * @param contributor The address to calculate contributor rewards for\n     */\n  function updateContributorRewards(address contributor) external;\n\n\n\n  function _setPriceOracle(address newOracle) external returns (uint256);\n\n  function _setMarketBorrowCaps(address[] memory cTokens, uint256[] memory newBorrowCaps) external;\n  function _setMintPaused(address cToken, bool state) external returns (bool);\n  function _setBorrowPaused(address cToken, bool state) external returns (bool);\n  function _setTransferPaused(bool state) external returns (bool);\n\n\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/hundred-finance/IHfCToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Restored from 0xbb93C7F378B9b531216f9aD7b5748be189A55807 (events and _xxx were removed)\n/// @dev 0xbb93C7F378B9b531216f9aD7b5748be189A55807 is impl of 0xE4e43864ea18d5E5211352a4B810383460aB7fcC\n///      see https://docs.hundred.finance/developers/protocol-contracts/polygon\ninterface IHfCToken {\n    /**\n     * @notice Block number that interest was last accrued at\n     */\n    function accrualBlockNumber() external view returns (uint256);\n\n    /**\n     * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n    function accrueInterest() external returns (uint256);\n\n    /**\n     * @notice Administrator for this contract\n     */\n    function admin() external view returns (address);\n\n    /**\n     * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinity)\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (uint256.max means infinity)\n     * @return Whether or not the approval succeeded\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n    function balanceOf(address owner) external view returns (uint256);\n\n    /**\n     * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    /**\n      * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    /**\n     * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    /**\n     * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n    function borrowBalanceStored(address account) external view returns (uint256);\n\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    function borrowIndex() external view returns (uint256);\n\n    /**\n     * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n    function borrowRatePerBlock() external view returns (uint256);\n\n    /**\n     * @notice Contract which oversees inter-cToken operations\n     */\n    function comptroller() external view returns (address);\n\n    /**\n         * @notice EIP-20 token decimals for this token\n     */\n    function decimals() external view returns (uint8);\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() external returns (uint256);\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() external view returns (uint256);\n\n    /**\n     * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     *         Return (possible error, token balance, borrow balance, exchange rate mantissa)\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     */\n    function getAccountSnapshot(address account)\n    external view returns (uint256 error, uint256 tokenBalance, uint256 borrowBalance, uint256 exchangeRateMantissa);\n\n    /**\n     * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n    function getCash() external view returns (uint256);\n    function implementation() external view returns (address);\n\n    function initialize(\n        address underlying_,\n        address comptroller_,\n        address interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) external;\n\n    function initialize(\n        address comptroller_,\n        address interestRateModel_,\n        uint256 initialExchangeRateMantissa_,\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) external;\n\n    /// @notice Model which tells what the current interest rate should be\n    function interestRateModel() external view returns (address);\n\n    /**\n        * @notice Indicator that this is a CToken contract (for inspection)\n     */\n    function isCToken() external view returns (bool);\n\n    /**\n     * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function liquidateBorrow(address borrower, uint256 repayAmount, address cTokenCollateral) external returns (uint256);\n\n    /**\n     * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function mint(uint256 mintAmount) external returns (uint256);\n    function name() external view returns (string memory);\n\n    /**\n        * @notice Pending administrator for this contract\n     */\n    function pendingAdmin() external view returns (address);\n\n    /**\n     * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    /**\n     * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    /**\n     * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    /**\n     * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n    function repayBorrowBehalf(address borrower, uint256 repayAmount) external returns (uint256);\n\n    /**\n     * @notice Fraction of interest currently set aside for reserves\n     */\n    function reserveFactorMantissa() external view returns (uint256);\n\n    function seize(\n        address liquidator,\n        address borrower,\n        uint256 seizeTokens\n    ) external returns (uint256);\n\n    /**\n     * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n    function supplyRatePerBlock() external view returns (uint256);\n\n    /**\n     * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n     * @param token The address of the ERC-20 token to sweep\n     */\n    function sweepToken(address token) external;\n    function symbol() external view returns (string memory);\n    /**\n     * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n    function totalBorrows() external view returns (uint256);\n\n    /**\n     * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n    function totalBorrowsCurrent() external returns (uint256);\n    /**\n         * @notice Total amount of reserves of the underlying held in this market\n     */\n    function totalReserves() external view returns (uint256);\n    /**\n        * @notice Total number of tokens in circulation\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    /**\n     * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function underlying() external view returns (address);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/hundred-finance/IHfHMatic.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Restored from 0xEbd7f3349AbA8bB15b897e03D6c1a4Ba95B55e31 hMatic, all events and most functions were removed\ninterface IHfHMatic {\n  function mint() external payable;\n  function repayBorrow() external payable;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/hundred-finance/IHfInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Restored from 0x29DDb4c4f9baAe366DbD40eff79d364e004425b0 (events were removed)\ninterface IHfInterestRateModel {\n  function baseRatePerBlock() external view returns (uint256);\n  function blocksPerYear() external view returns (uint256);\n  function getBorrowRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) external view returns (uint256);\n\n  function getSupplyRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves,\n    uint256 reserveFactorMantissa\n  ) external view returns (uint256);\n\n  function isInterestRateModel() external view returns (bool);\n  function isOwner() external view returns (bool);\n  function jumpMultiplierPerBlock() external view returns (uint256);\n  function kink() external view returns (uint256);\n  function multiplierPerBlock() external view returns (uint256);\n  function name() external view returns (string memory);\n  function owner() external view returns (address);\n  function renounceOwnership() external;\n  function transferOwnership(address newOwner) external;\n  function updateBlocksPerYear(uint256 blocksPerYear_) external;\n\n  function updateJumpRateModel(\n    uint256 baseRatePerYear,\n    uint256 multiplierPerYear,\n    uint256 jumpMultiplierPerYear,\n    uint256 kink_\n  ) external;\n\n  function utilizationRate(\n    uint256 cash,\n    uint256 borrows,\n    uint256 reserves\n  ) external pure returns (uint256);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/hundred-finance/IHfPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Restored from 0x0b510A226F4A7A66c480988704eCd5306B6f1954 (events removed)\ninterface IHfPriceOracle {\n  function ethUsdChainlinkAggregatorAddress() external view returns (address);\n\n  /**\n    * @notice Get the underlying price of a cToken asset\n      * @param cToken The cToken to get the underlying price of\n      * @return The underlying asset price mantissa (scaled by 1e18).\n      *  Zero means the price is unavailable.\n      */\n  function getUnderlyingPrice(address cToken) external view returns (uint256);\n\n  /// @notice Indicator that this is a PriceOracle contract (for inspection)\n  function isPriceOracle() external view returns (bool);\n  function owner() external view returns (address);\n  function renounceOwnership() external;\n  function setEthUsdChainlinkAggregatorAddress(address addr) external;\n\n  function setTokenConfigs(\n    address[] memory cTokenAddress,\n    address[] memory chainlinkAggregatorAddress,\n    uint256[] memory chainlinkPriceBase,\n    uint256[] memory underlyingTokenDecimals\n  ) external;\n\n  function tokenConfig(address)\n  external\n  view\n  returns (\n    address chainlinkAggregatorAddress,\n    uint256 chainlinkPriceBase,\n    uint256 underlyingTokenDecimals\n  );\n\n  function transferOwnership(address newOwner) external;\n}\n\n// THIS FILE WAS AUTOGENERATED FROM THE FOLLOWING ABI JSON:\n/*\n[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"ethUsdChainlinkAggregatorAddress_\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"cTokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"chainlinkAggregatorAddress\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"chainlinkPriceBase\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"underlyingTokenDecimals\",\"type\":\"uint256\"}],\"name\":\"TokenConfigUpdated\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ethUsdChainlinkAggregatorAddress\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract CTokenInterface\",\"name\":\"cToken\",\"type\":\"address\"}],\"name\":\"getUnderlyingPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isPriceOracle\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setEthUsdChainlinkAggregatorAddress\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"cTokenAddress\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"chainlinkAggregatorAddress\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"chainlinkPriceBase\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"underlyingTokenDecimals\",\"type\":\"uint256[]\"}],\"name\":\"setTokenConfigs\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenConfig\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"chainlinkAggregatorAddress\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"chainlinkPriceBase\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"underlyingTokenDecimals\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]\n*/\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/IWmatic.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0;\n\ninterface IWmatic {\n\n  function balanceOf(address target) external view returns (uint256);\n\n  function deposit() external payable;\n\n  function withdraw(uint256 wad) external;\n\n  function totalSupply() external view returns (uint256);\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n\n  function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/market/ICErc20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface ICErc20 {\n  function _acceptAdmin (  ) external returns ( uint );\n  function _addReserves ( uint addAmount ) external returns ( uint );\n  function _reduceReserves ( uint reduceAmount ) external returns ( uint );\n  function _setComptroller ( address newComptroller ) external returns ( uint );\n  function _setInterestRateModel ( address newInterestRateModel ) external returns ( uint );\n  function _setPendingAdmin ( address newPendingAdmin ) external returns ( uint );\n  function _setReserveFactor ( uint newReserveFactorMantissa ) external returns ( uint );\n  function accrualBlockNumber (  ) external view returns ( uint );\n  function accrueInterest (  ) external returns ( uint );\n  function admin (  ) external view returns ( address );\n  function allowance ( address owner, address spender ) external view returns ( uint );\n  function approve ( address spender, uint amount ) external returns ( bool );\n  function balanceOf ( address owner ) external view returns ( uint );\n  function balanceOfUnderlying ( address owner ) external returns ( uint );\n  function borrow ( uint borrowAmount ) external returns ( uint );\n  function borrowBalanceCurrent ( address account ) external returns ( uint );\n  function borrowBalanceStored ( address account ) external view returns ( uint );\n  function borrowIndex (  ) external view returns ( uint );\n  function borrowRatePerBlock (  ) external view returns ( uint );\n  function comptroller (  ) external view returns ( address );\n  function decimals (  ) external view returns ( uint8 );\n  function exchangeRateCurrent (  ) external returns ( uint );\n  function exchangeRateStored (  ) external view returns ( uint );\n  function getAccountSnapshot ( address account ) external view returns ( uint, uint, uint, uint );\n  function getCash (  ) external view returns ( uint );\n  function interestRateModel (  ) external view returns ( address );\n  function isCToken (  ) external view returns ( bool );\n  function liquidateBorrow ( address borrower, uint repayAmount, address cTokenCollateral ) external returns ( uint );\n  function mint ( uint mintAmount ) external returns ( uint );\n  function name (  ) external view returns ( string memory);\n  function pendingAdmin (  ) external view returns ( address );\n  function redeem ( uint redeemTokens ) external returns ( uint );\n  function redeemUnderlying ( uint redeemAmount ) external returns ( uint );\n  function repayBorrow ( uint repayAmount ) external returns ( uint );\n  function repayBorrowBehalf ( address borrower, uint repayAmount ) external returns ( uint );\n  function reserveFactorMantissa (  ) external view returns ( uint );\n  function seize ( address liquidator, address borrower, uint seizeTokens ) external returns ( uint );\n  function supplyRatePerBlock (  ) external view returns ( uint );\n  function sweepToken ( address token ) external;\n  function symbol (  ) external view returns ( string memory);\n  function totalBorrows (  ) external view returns ( uint );\n  function totalBorrowsCurrent (  ) external returns ( uint );\n  function totalReserves (  ) external view returns ( uint );\n  function totalSupply (  ) external view returns ( uint );\n  function transfer ( address dst, uint amount ) external returns ( bool );\n  function transferFrom ( address src, address dst, uint amount ) external returns ( bool );\n  function underlying (  ) external view returns ( address );\n\n  function adminFeeMantissa() external view returns (uint256);\n  function fuseFeeMantissa() external view returns (uint256);\n  function totalAdminFees() external view returns (uint256);\n  function totalFuseFees() external view returns (uint256);\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/tetu/ITetuLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ITetuLiquidator {\n\n  struct PoolData {\n    address pool;\n    address swapper;\n    address tokenIn;\n    address tokenOut;\n  }\n\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\n\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\n\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\n\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint priceImpactTolerance\n  ) external;\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint priceImpactTolerance\n  ) external;\n\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IBorrowManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../libs/AppDataTypes.sol\";\n\n/// @notice Manage list of available lending platforms\n///         Manager of pool-adapters.\n///         Pool adapter is an instance of a converter provided by the lending platform\n///         linked to one of platform's pools, address of user contract, collateral and borrow tokens.\n///         The pool adapter is real borrower of funds for AAVE, Compound and other lending protocols.\n///         Pool adapters are created using minimal-proxy pattern, see\n///         https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\ninterface IBorrowManager {\n\n  /// @notice Register a pool adapter for (pool, user, collateral) if the adapter wasn't created before\n  /// @param user_ Address of the caller contract who requires access to the pool adapter\n  /// @return Address of registered pool adapter\n  function registerPoolAdapter(address converter_, address user_, address collateral_, address borrowToken_) external returns (address);\n\n  /// @notice Get pool adapter or 0 if the pool adapter is not registered\n  function getPoolAdapter(address converter_, address user_, address collateral_, address borrowToken_) external view returns (address);\n\n  /// @dev Returns true for NORMAL pool adapters and for active DIRTY pool adapters (=== borrow position is opened).\n  function isPoolAdapter(address poolAdapter_) external view returns (bool);\n\n  /// @notice Notify borrow manager that the pool adapter with the given params is \"dirty\".\n  ///         The pool adapter should be excluded from the list of ready-to-borrow pool adapters.\n  /// @dev \"Dirty\" means that a liquidation happens inside. The borrow position should be closed during health checking.\n  function markPoolAdapterAsDirty(address converter_, address user_, address collateral_, address borrowToken_) external;\n\n  /// @notice Register new lending platform with available pairs of assets\n  ///         OR add new pairs of assets to the exist lending platform\n  /// @param platformAdapter_ Implementation of IPlatformAdapter attached to the specified pool\n  /// @param leftAssets_  Supported pairs of assets. The pairs are set using two arrays: left and right\n  /// @param rightAssets_  Supported pairs of assets. The pairs are set using two arrays: left and right\n  function addAssetPairs(address platformAdapter_, address[] calldata leftAssets_, address[] calldata rightAssets_) external;\n\n  /// @notice Remove available pairs of asset from the platform adapter.\n  ///         The platform adapter will be unregistered after removing last supported pair of assets\n  function removeAssetPairs(address platformAdapter_, address[] calldata leftAssets_, address[] calldata rightAssets_) external;\n\n  /// @notice Set target health factors for the assets.\n  ///         If target health factor is not assigned to the asset, target-health-factor from controller is used.\n  ///         See explanation of health factor value in IConverterController\n  /// @param healthFactors2_ Health factor must be greater or equal then 1, decimals 2\n  function setTargetHealthFactors(address[] calldata assets_, uint16[] calldata healthFactors2_) external;\n\n  /// @notice Return target health factor with decimals 2 for the asset\n  ///         If there is no custom value for asset, target health factor from the controller should be used\n  function getTargetHealthFactor2(address asset) external view returns (uint16);\n\n  /// @notice Reward APR is taken into account with given factor\n  ///         Result APR = borrow-apr - supply-apr - [REWARD-FACTOR]/Denominator * rewards-APR\n  function setRewardsFactor(uint rewardsFactor_) external;\n\n  /// @notice Find lending pool capable of providing {targetAmount} and having best normalized borrow rate\n  ///         Results are ordered in ascending order of APR, so the best available converter is first one.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                  See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  /// @param amountIn_ The meaning depends on entryData kind, see EntryKinds library for details.\n  ///         For entry kind = 0: Amount of {sourceToken} to be converted to {targetToken}\n  ///         For entry kind = 1: Available amount of {sourceToken}\n  ///         For entry kind = 2: Amount of {targetToken} that should be received after conversion\n  /// @return converters Result template-pool-adapters\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\n  /// @return amountsToBorrowOut Amounts that should be borrowed\n  /// @return aprs18 Annual Percentage Rates == (total cost - total income) / amount of collateral, decimals 18\n  function findConverter(\n    bytes memory entryData_,\n    address sourceToken_,\n    address targetToken_,\n    uint amountIn_,\n    uint periodInBlocks_\n  ) external view returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountsToBorrowOut,\n    int[] memory aprs18\n  );\n\n  /// @notice Get platformAdapter to which the converter belongs\n  function getPlatformAdapter(address converter_) external view returns (address);\n\n  /// @notice Count of available platform adapters\n  function platformAdaptersLength() external view returns (uint);\n\n  /// @notice Get platform adapter at the given index\n  /// @param index [0.. platformAdaptersLength)\n  function platformAdaptersAt(uint index) external view returns (address);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IControllable {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @notice tetu-contracts-v2\\IController\ninterface IController {\n\n  // --- DEPENDENCY ADDRESSES\n  function governance() external view returns (address);\n\n  function voter() external view returns (address);\n\n  function liquidator() external view returns (address);\n\n  function forwarder() external view returns (address);\n\n  function investFund() external view returns (address);\n\n  function veDistributor() external view returns (address);\n\n  function platformVoter() external view returns (address);\n\n  // --- VAULTS\n\n  function vaults(uint id) external view returns (address);\n\n  function vaultsList() external view returns (address[] memory);\n\n  function vaultsListLength() external view returns (uint);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  // --- restrictions\n\n  function isOperator(address _adr) external view returns (bool);\n\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../libs/AppDataTypes.sol\";\n\ninterface IConverter {\n  function getConversionKind() external pure returns (\n    AppDataTypes.ConversionKind\n  );\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverterControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IConverterControllerProvider.sol\";\n\ninterface IConverterControllable is IConverterControllerProvider {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isProxyUpdater(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @notice Keep and provide addresses of all application contracts\ninterface IConverterController {\n  function governance() external view returns (address);\n\n  // ********************* Health factor explanation  ****************\n  // For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\n  // For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\n  // We set min-health-factor = 1.1, target-health-factor = 1.3\n  // For collateral 100 we will borrow 100/1.3 = 76.92\n  //\n  // Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\n  // Collateral * LT    85         65.45\n  // Borrow value       65.38      65.38         but borrow value is the same as before\n  // Health factor      1.3        1.001         liquidation almost happens here (!)\n  //\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\n  // and the borrow value won't change at the same time, the liquidation happens at that point.\n  // Min health factor marks the point at which a rebalancing must be made asap.\n  // *****************************************************************\n\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\n  function minHealthFactor2() external view returns (uint16);\n  function setMinHealthFactor2(uint16 value_) external;\n\n  /// @notice target health factor with decimals 2\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\n  ///      or additional borrow and restore the health factor to the given target value\n  function targetHealthFactor2() external view returns (uint16);\n  function setTargetHealthFactor2(uint16 value_) external;\n\n  /// @notice max allowed health factor with decimals 2\n  /// @dev For future versions, currently max health factor is not used\n  function maxHealthFactor2() external view returns (uint16);\n  /// @dev For future versions, currently max health factor is not used\n  function setMaxHealthFactor2(uint16 value_) external;\n\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\n  function blocksPerDay() external view returns (uint);\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\n  /// @notice Check if it's time to call updateBlocksPerDay()\n  /// @param periodInSeconds_ Period of auto-update in seconds\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\n  /// @notice Recalculate blocksPerDay value\n  /// @param periodInSeconds_ Period of auto-update in seconds\n  function updateBlocksPerDay(uint periodInSeconds_) external;\n\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\n  function paused() external view returns (bool);\n\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\n  function isWhitelisted(address user_) external view returns (bool);\n\n  /// @notice The size of the gap by which the debt should be increased upon repayment\n  ///         Such gaps are required by AAVE pool adapters to workaround dust tokens problem\n  ///         and be able to make full repayment.\n  /// @dev Debt gap is applied as following: toPay = debt * (DEBT_GAP_DENOMINATOR + debtGap) / DEBT_GAP_DENOMINATOR\n  function debtGap() external view returns (uint);\n\n  //-----------------------------------------------------\n  //        Core application contracts\n  //-----------------------------------------------------\n\n  function tetuConverter() external view returns (address);\n  function borrowManager() external view returns (address);\n  function debtMonitor() external view returns (address);\n  function tetuLiquidator() external view returns (address);\n  function swapManager() external view returns (address);\n  function priceOracle() external view returns (address);\n\n  //-----------------------------------------------------\n  //        External contracts\n  //-----------------------------------------------------\n  /// @notice A keeper to control health and efficiency of the borrows\n  function keeper() external view returns (address);\n  /// @notice Controller of tetu-contracts-v2, that is allowed to update proxy contracts\n  function proxyUpdater() external view returns (address);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverterControllerProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IConverterControllerProvider {\n  function controller() external view returns (address);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IDebtMonitor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @notice Collects list of registered borrow-positions. Allow to check state of the collaterals.\ninterface IDebtMonitor {\n\n  /// @notice Enumerate {maxCountToCheck} pool adapters starting from {index0} and return unhealthy pool-adapters\n  ///         i.e. adapters with health factor below min allowed value\n  ///         It calculates two amounts: amount of borrow asset and amount of collateral asset\n  ///         To fix the health factor it's necessary to send EITHER one amount OR another one.\n  ///         There is special case: a liquidation happens inside the pool adapter.\n  ///         It means, that this is \"dirty\" pool adapter and this position must be closed and never used again.\n  ///         In this case, both amounts are zero (we need to make FULL repay)\n  /// @return nextIndexToCheck0 Index of next pool-adapter to check; 0: all pool-adapters were checked\n  /// @return outPoolAdapters List of pool adapters that should be reconverted\n  /// @return outAmountBorrowAsset What borrow-asset amount should be send to pool adapter to fix health factor\n  /// @return outAmountCollateralAsset What collateral-asset amount should be send to pool adapter to fix health factor\n  function checkHealth(\n    uint startIndex0,\n    uint maxCountToCheck,\n    uint maxCountToReturn\n  ) external view returns (\n    uint nextIndexToCheck0,\n    address[] memory outPoolAdapters,\n    uint[] memory outAmountBorrowAsset,\n    uint[] memory outAmountCollateralAsset\n  );\n\n  /// @notice Register new borrow position if it's not yet registered\n  /// @dev This function is called from a pool adapter after any borrow\n  function onOpenPosition() external;\n\n  /// @notice Unregister the borrow position if it's completely repaid\n  /// @dev This function is called from a pool adapter when the borrow is completely repaid\n  function onClosePosition() external;\n\n  /// @notice Check if the pool-adapter-caller has an opened position\n  function isPositionOpened() external view returns (bool);\n\n  /// @notice Pool adapter has opened borrow, but full liquidation happens and we've lost all collateral\n  ///         Close position without paying the debt and never use the pool adapter again.\n  function closeLiquidatedPosition(address poolAdapter_) external;\n\n  /// @notice Get total count of pool adapters with opened positions\n  function getCountPositions() external view returns (uint);\n\n  /// @notice Get active borrows of the user with given collateral/borrowToken\n  /// @return poolAdaptersOut The instances of IPoolAdapter\n  function getPositions (\n    address user_,\n    address collateralToken_,\n    address borrowedToken_\n  ) external view returns (\n    address[] memory poolAdaptersOut\n  );\n\n  /// @notice Get active borrows of the given user\n  /// @return poolAdaptersOut The instances of IPoolAdapter\n  function getPositionsForUser(address user_) external view returns(\n    address[] memory poolAdaptersOut\n  );\n\n  /// @notice Return true if there is a least once active pool adapter created on the base of the {converter_}\n  function isConverterInUse(address converter_) external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IHealthKeeperCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IHealthKeeperCallback {\n  function nextIndexToCheck0() external view returns (uint);\n\n  function fixHealth(\n    uint nextIndexToCheck0_,\n    address[] calldata outPoolAdapters_,\n    uint[] calldata outAmountBorrowAsset_,\n    uint[] calldata outAmountCollateralAsset_\n  ) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IKeeperCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Keeper sends notifications to TetuConverter using following interface\ninterface IKeeperCallback {\n\n  /// @notice This function is called by a keeper if there is unhealthy borrow\n  ///         The called contract should send either collateral-amount or borrowed-amount to TetuConverter\n  /// @param requiredAmountBorrowAsset_ The borrower should return given borrowed amount back to TetuConverter\n  ///                                   in order to restore health factor to target value\n  /// @param requiredAmountCollateralAsset_ The borrower should send given amount of collateral to TetuConverter\n  ///                                       in order to restore health factor to target value\n  /// @param lendingPoolAdapter_ Address of the pool adapter that has problem health factor\n  function requireRepay(\n    uint requiredAmountBorrowAsset_,\n    uint requiredAmountCollateralAsset_,\n    address lendingPoolAdapter_\n  ) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IPlatformAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../libs/AppDataTypes.sol\";\n\n/// @notice Adapter for lending platform attached to the given platform's pool.\ninterface IPlatformAdapter {\n  /// @notice Current version of contract\n  ///         There is a chance that we will register several versions of the same platform\n  ///         at the same time (only last version will be active, others will be frozen)\n  function PLATFORM_ADAPTER_VERSION() external view returns (string memory);\n\n  /// @notice Get pool data required to select best lending pool\n  /// @param healthFactor2_ Health factor (decimals 2) to be able to calculate max borrow amount\n  ///                       See IConverterController for explanation of health factors.\n  function getConversionPlan(\n    AppDataTypes.InputConversionParams memory params_,\n    uint16 healthFactor2_\n  ) external view returns (\n    AppDataTypes.ConversionPlan memory plan\n  );\n\n  /// @notice Full list of supported converters\n  function converters() external view returns (address[] memory);\n\n  function platformKind() external pure returns (AppDataTypes.LendingPlatformKinds);\n\n  /// @notice Initialize {poolAdapter_} created from {converter_} using minimal proxy pattern\n  function initializePoolAdapter(\n    address converter_,\n    address poolAdapter_,\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) external;\n\n  /// @notice True if the platform is frozen and new borrowing is not possible (at this moment)\n  function frozen() external view returns (bool);\n\n  /// @notice Set platform to frozen/unfrozen state. In frozen state any new borrowing is forbidden.\n  function setFrozen(bool frozen_) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IPoolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IConverter.sol\";\n\n/// @notice Allow to borrow given asset from the given pool using given asset as collateral.\n///         There is Template-Pool-Adapter contract for each platform (AAVE, HF, etc).\n/// @dev Terms: \"pool adapter\" is an instance of \"converter\" created using minimal-proxy-pattern\ninterface IPoolAdapter is IConverter {\n  /// @notice Update all interests, recalculate borrowed amount;\n  ///         After this call, getStatus will return exact amount-to-repay\n  function updateStatus() external;\n\n  /// @notice Supply collateral to the pool and borrow specified amount\n  /// @dev No re-balancing here; Collateral amount must be approved to the pool adapter before the call of this function\n  /// @param collateralAmount_ Amount of collateral, must be approved to the pool adapter before the call of borrow()\n  /// @param borrowAmount_ Amount that should be borrowed in result\n  /// @param receiver_ Receiver of the borrowed amount\n  /// @return borrowedAmountOut Result borrowed amount sent to the {receiver_}\n  function borrow(uint collateralAmount_, uint borrowAmount_, address receiver_) external returns (\n    uint borrowedAmountOut\n  );\n\n  /// @notice Borrow additional amount {borrowAmount_} using exist collateral and send it to {receiver_}\n  /// @dev Re-balance: too big health factor => target health factor\n  /// @return resultHealthFactor18 Result health factor after borrow\n  /// @return borrowedAmountOut Exact amount sent to the borrower\n  function borrowToRebalance(uint borrowAmount_, address receiver_) external returns (\n    uint resultHealthFactor18,\n    uint borrowedAmountOut\n  );\n\n  /// @notice Repay borrowed amount, return collateral to the user\n  /// @param amountToRepay_ Exact amount of borrow asset that should be repaid\n  ///                       The amount should be approved for the pool adapter before the call of repay()\n  /// @param closePosition_ true to pay full borrowed amount\n  /// @param receiver_ Receiver of withdrawn collateral\n  /// @return collateralAmountOut Amount of collateral asset sent to the {receiver_}\n  function repay(uint amountToRepay_, address receiver_, bool closePosition_) external returns (\n    uint collateralAmountOut\n  );\n\n  /// @notice Repay with rebalancing. Send amount of collateral/borrow asset to the pool adapter\n  ///         to recover the health factor to target state.\n  /// @dev It's not allowed to close position here (pay full debt) because no collateral will be returned.\n  /// @param amount_ Exact amount of asset that is transferred to the balance of the pool adapter.\n  ///                It can be amount of collateral asset or borrow asset depended on {isCollateral_}\n  ///                It must be stronger less then total borrow debt.\n  ///                The amount should be approved for the pool adapter before the call.\n  /// @param isCollateral_ true/false indicates that {amount_} is the amount of collateral/borrow asset\n  /// @return resultHealthFactor18 Result health factor after repay, decimals 18\n  function repayToRebalance(uint amount_, bool isCollateral_) external returns (\n    uint resultHealthFactor18\n  );\n\n  /// @return originConverter Address of original PoolAdapter contract that was cloned to make the instance of the pool adapter\n  /// @return user User of the pool adapter\n  /// @return collateralAsset Asset used as collateral by the pool adapter\n  /// @return borrowAsset Asset borrowed by the pool adapter\n  function getConfig() external view returns (\n    address originConverter,\n    address user,\n    address collateralAsset,\n    address borrowAsset\n  );\n\n  /// @notice Get current status of the borrow position\n  /// @dev It returns STORED status. To get current status it's necessary to call updateStatus\n  ///      at first to update interest and recalculate status.\n  /// @return collateralAmount Total amount of provided collateral, collateral currency\n  /// @return amountToPay Total amount of borrowed debt in [borrow asset]. 0 - for closed borrow positions.\n  /// @return healthFactor18 Current health factor, decimals 18\n  /// @return opened The position is opened (there is not empty collateral/borrow balance)\n  /// @return collateralAmountLiquidated How much collateral was liquidated\n  /// @return debtGapRequired When paying off a debt, the amount of the payment must be greater\n  ///         than the amount of the debt by a small amount (debt gap, see IConverterController.debtGap)\n  ///         getStatus returns it (same as getConfig) to exclude additional call of getConfig by the caller\n  function getStatus() external view returns (\n    uint collateralAmount,\n    uint amountToPay,\n    uint healthFactor18,\n    bool opened,\n    uint collateralAmountLiquidated,\n    bool debtGapRequired\n  );\n\n  /// @notice Check if any reward tokens exist on the balance of the pool adapter, transfer reward tokens to {receiver_}\n  /// @return rewardToken Address of the transferred reward token\n  /// @return amount Amount of the transferred reward token\n  function claimRewards(address receiver_) external returns (address rewardToken, uint amount);\n\n  /// @notice If we paid {amountToRepay_}, how much collateral would we receive?\n  function getCollateralAmountToReturn(uint amountToRepay_, bool closePosition_) external view returns (uint);\n\n//  /// @notice Compute current APR value, decimals 18\n//  /// @return Interest * 1e18, i.e. 2.25e18 means APR=2.25%\n//  function getAPR18() external view returns (int);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IPoolAdapterInitializerWithAP.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @notice Initializer for pool-adapters with AddressProvider\ninterface IPoolAdapterInitializerWithAP {\n\n  /// @param cTokenAddressProvider_ This is ICTokenAddressProvider\n  function initialize(\n    address controller_,\n    address cTokenAddressProvider_,\n    address pool_,\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    address originConverter_\n  ) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IPriceOracle {\n  /// @notice Return asset price in USD, decimals 18\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IProxyControlled {\n\n  function initProxy(address _logic) external;\n\n  function upgrade(address _newImplementation) external;\n\n  function implementation() external view returns (address);\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IRequireAmountBySwapManagerCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice TetuConverter supports this interface\n///         It's called by SwapManager inside static-call swap simulation\n///         to transfer amount approved to TetuConverter by user to SwapManager\n///         before calling swap simulation\ninterface IRequireAmountBySwapManagerCallback {\n  /// @notice Transfer {sourceAmount_} approved by {approver_} to swap manager\n  function onRequireAmountBySwapManager(address approver_, address sourceToken_, uint sourceAmount_) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ISimulateProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Provider of simulate() function\ninterface ISimulateProvider {\n  function simulate(\n    address targetContract,\n    bytes calldata calldataPayload\n  ) external returns (bytes memory response);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ISwapConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../libs/AppDataTypes.sol\";\nimport \"./IConverter.sol\";\n\ninterface ISwapConverter is IConverter {\n  function getConversionKind()\n  override external pure returns (AppDataTypes.ConversionKind);\n\n  /// @notice Swap {sourceAmount_} of {sourceToken_} to {targetToken_} and send result amount to {receiver_}\n  /// @return outputAmount The amount that has been sent to the receiver\n  function swap(\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    address receiver_\n  ) external returns (uint outputAmount);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ISwapManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../libs/AppDataTypes.sol\";\n\ninterface ISwapManager {\n\n  /// @notice Find a way to convert collateral asset to borrow asset in most efficient way\n  /// @dev This is a writable function with read-only behavior\n  ///      because to simulate real swap the function should be writable.\n  /// @param sourceAmountApprover_ A contract which has approved {sourceAmount_} to TetuConverter\n  /// @param sourceAmount_ Amount in terms of {sourceToken_} to be converter to {targetToken_}\n  /// @return converter Address of ISwapConverter\n  ///         If SwapManager cannot find a conversion way,\n  ///         it returns converter == 0 (in the same way as ITetuConverter)\n  function getConverter(\n    address sourceAmountApprover_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external returns (\n    address converter,\n    uint maxTargetAmount\n  );\n\n  /// @notice Calculate APR using known {sourceToken_} and known {targetAmount_}.\n  /// @param sourceAmount_ Source amount before conversion, in terms of {sourceToken_}\n  /// @param targetAmount_ Result of conversion. The amount is in terms of {targetToken_}\n  function getApr18(\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint targetAmount_\n  ) external view returns (int apr18);\n\n  /// @notice Return custom or default price impact tolerance for the asset\n  function getPriceImpactTolerance(address asset_) external view returns (uint priceImpactTolerance);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ISwapSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISwapSimulator {\n\n  /// @notice Make real swap to know result amount\n  ///         but exclude any additional operations\n  ///         like \"sending result amount to receiver\" or \"emitting any events\".\n  /// @dev This function should be called only inside static call to know result amount.\n  /// @param user_ A strategy which has approved source amount to TetuConverter\n  ///              and called a function findSwapStrategy\n  /// @param sourceAmount_ Amount in terms of {sourceToken_} to be converter to {targetToken_}\n  /// @return amountOut Result amount in terms of {targetToken_} after conversion\n  function simulateSwap(\n    address user_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external returns (\n    uint amountOut\n  );\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IConverterControllerProvider.sol\";\n\n/// @notice Main contract of the TetuConverter application\n/// @dev Borrower (strategy) makes all operations via this contract only.\ninterface ITetuConverter is IConverterControllerProvider {\n\n  /// @notice Find possible borrow strategies and provide \"cost of money\" as interest for the period for each strategy\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param amountIn_  The meaning depends on entryData\n  ///                   For entryKind=0 it's max available amount of collateral\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\n  /// @return converters Array of available converters ordered in ascending order of APR.\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\n  ///                    This address should be passed to borrow-function during conversion.\n  ///                    The length of array is always equal to the count of available lending platforms.\n  ///                    Last items in array can contain zero addresses (it means they are not used)\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\n  /// @return amountToBorrowsOut Amounts that should be borrowed\n  ///                            This amount is not zero if corresponded converter is not zero.\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\n  function findBorrowStrategies(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountToBorrowsOut,\n    int[] memory aprs18\n  );\n\n  /// @notice Find best swap strategy and provide \"cost of money\" as interest for the period\n  /// @dev This is writable function with read-only behavior.\n  ///      It should be writable to be able to simulate real swap and get a real APR.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param amountIn_  The meaning depends on entryData\n  ///                   For entryKind=0 it's max available amount of collateral\n  ///                   This amount must be approved to TetuConverter before the call.\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\n  function findSwapStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_\n  ) external returns (\n    address converter,\n    uint sourceAmountOut,\n    uint targetAmountOut,\n    int apr18\n  );\n\n  /// @notice Find best conversion strategy (swap or borrow) and provide \"cost of money\" as interest for the period.\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\n  /// @dev This is writable function with read-only behavior.\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param amountIn_  The meaning depends on entryData\n  ///                   For entryKind=0 it's max available amount of collateral\n  ///                   This amount must be approved to TetuConverter before the call.\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\n  function findConversionStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external returns (\n    address converter,\n    uint collateralAmountOut,\n    uint amountToBorrowOut,\n    int apr18\n  );\n\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\n  ///      Only whitelisted users are allowed to make borrows\n  /// @param converter_ A converter received from findBestConversionStrategy.\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\n  ///                          This amount must be approved to TetuConverter before the call.\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\n  /// @param receiver_ A receiver of borrowed amount\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\n  function borrow(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_\n  ) external returns (\n    uint borrowedAmountOut\n  );\n\n  /// @notice Full or partial repay of the borrow\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\n  ///        You can know exact total amount of debt using {getStatusCurrent}.\n  ///        if the amount exceed total amount of the debt:\n  ///           - the debt will be fully repaid\n  ///           - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\n  ///        This amount should be calculated with taking into account possible debt gap,\n  ///        You should call getDebtAmountCurrent(debtGap = true) to get this amount.\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\n  ///         If TetuConverter is not able to make the swap, it reverts\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\n  ///                                 This amount is returned back to the collateralReceiver_\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\n  function repay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_\n  ) external returns (\n    uint collateralAmountOut,\n    uint returnedBorrowAmountOut,\n    uint swappedLeftoverCollateralOut,\n    uint swappedLeftoverBorrowOut\n  );\n\n  /// @notice Estimate result amount after making full or partial repay\n  /// @dev It works in exactly same way as repay() but don't make actual repay\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\n  /// @param user_ user whose amount-to-repay will be calculated\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\n  ///        This amount should be calculated without possible debt gap.\n  ///        In this way it's differ from {repay}\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\n  /// @return swappedAmountOut A part of {collateralAmountOut} that were received by direct swap\n  function quoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_\n  ) external returns (\n    uint collateralAmountOut,\n    uint swappedAmountOut\n  );\n\n  /// @notice Update status in all opened positions\n  ///         After this call getDebtAmount will be able to return exact amount to repay\n  /// @param user_ user whose debts will be returned\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\n  function getDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    bool useDebtGap_\n  ) external returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  );\n\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\n  /// @param user_ user whose debts will be returned\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\n  function getDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    bool useDebtGap_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  );\n\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\n  /// @param user_ user whose debts will be returned\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\n  ///                                           even if all borrowed amount will be returned.\n  ///                                           If this amount is not 0, you ask to get too much collateral.\n  function estimateRepay(\n    address user_,\n    address collateralAsset_,\n    uint collateralAmountRequired_,\n    address borrowAsset_\n  ) external view returns (\n    uint borrowAssetAmount,\n    uint unobtainableCollateralAssetAmount\n  );\n\n  /// @notice Transfer all reward tokens to {receiver_}\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\n  function claimRewards(address receiver_) external returns (\n    address[] memory rewardTokensOut,\n    uint[] memory amountsOut\n  );\n\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\n  ///                      It should be transferred on balance of the TetuConverter before the function call\n  /// @param receiver_ Result amount will be sent to this address\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\n  function safeLiquidate(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    address receiver_,\n    uint priceImpactToleranceSource_,\n    uint priceImpactToleranceTarget_\n  ) external returns (\n    uint amountOut\n  );\n\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\n  function isConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    uint priceImpactTolerance_\n  ) external view returns (bool);\n\n  /// @notice Close given borrow and return collateral back to the user, governance only\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\n  /// @param poolAdapter_ The pool adapter that represents the borrow\n  /// @param closePosition Close position after repay\n  ///        Usually it should be true, because the function always tries to repay all debt\n  ///        false can be used if user doesn't have enough amount to pay full debt\n  ///              and we are trying to pay \"as much as possible\"\n  /// @return collateralAmountOut Amount of collateral returned to the user\n  /// @return repaidAmountOut Amount of borrow asset paid to the lending platform\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\n    uint collateralAmountOut,\n    uint repaidAmountOut\n  );\n\n  /// @notice Get active borrows of the user with given collateral/borrowToken\n  /// @dev Simple access to IDebtMonitor.getPositions\n  /// @return poolAdaptersOut The instances of IPoolAdapter\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external view returns (\n    address[] memory poolAdaptersOut\n  );\n\n  /// @notice Save token from TC-balance to {receiver}\n  /// @dev Normally TetuConverter doesn't have any tokens on balance, they can appear there accidentally only\n  function salvage(address receiver, address token, uint amount) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice TetuConverter sends callback notifications to its user via this interface\ninterface ITetuConverterCallback {\n  /// @notice Converters calls this function if user should return some amount back.\n  ///         f.e. when the health factor is unhealthy and the converter needs more tokens to fix it.\n  ///         or when the full repay is required and converter needs to get full amount-to-repay.\n  /// @param asset_ Required asset (either collateral or borrow)\n  /// @param amount_ Required amount of the {asset_}\n  /// @return amountOut Exact amount that borrower has sent to balance of TetuConverter\n  function requirePayAmountBack(address asset_, uint amount_) external returns (uint amountOut);\n\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITokenAddressProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @dev Compound comptroller doesn't allow to get underlying by cToken,\n///      so platform adapter provider provides such function\ninterface ITokenAddressProvider {\n  /// @notice Get cTokens by underlying\n  function getCTokenByUnderlying(address token1, address token2)\n  external view\n  returns (address cToken1, address cToken2);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/AppDataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary AppDataTypes {\n\n  enum LendingPlatformKinds {\n    UNKNOWN_0,\n    DFORCE_1,\n    AAVE2_2,\n    AAVE3_3,\n    HUNDRED_FINANCE_4,\n    COMPOUND3_5\n  }\n\n  enum ConversionKind {\n    UNKNOWN_0,\n    SWAP_1,\n    BORROW_2\n  }\n\n  /// @notice Input params for BorrowManager.findPool (stack is too deep problem)\n  struct InputConversionParams {\n    address collateralAsset;\n    address borrowAsset;\n\n    /// @notice Encoded entry kind and additional params if necessary (set of params depends on the kind)\n    ///         See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n    bytes entryData;\n\n    uint countBlocks;\n\n    /// @notice The meaning depends on entryData kind, see EntryKinds library for details.\n    ///         For entry kind = 0: Amount of {sourceToken} to be converted to {targetToken}\n    ///         For entry kind = 1: Available amount of {sourceToken}\n    ///         For entry kind = 2: Amount of {targetToken} that should be received after conversion\n    uint amountIn;\n  }\n\n  /// @notice Explain how a given lending pool can make specified conversion\n  struct ConversionPlan {\n    /// @notice Template adapter contract that implements required strategy.\n    address converter;\n    /// @notice Current collateral factor [0..1e18], where 1e18 is corresponded to CF=1\n    uint liquidationThreshold18;\n\n    /// @notice Amount to borrow in terms of borrow asset\n    uint amountToBorrow;\n    /// @notice Amount to be used as collateral in terms of collateral asset\n    uint collateralAmount;\n\n    /// @notice Cost for the period calculated using borrow rate in terms of borrow tokens, decimals 36\n    /// @dev It doesn't take into account supply increment and rewards\n    uint borrowCost36;\n    /// @notice Potential supply increment after borrow period recalculated to Borrow Token, decimals 36\n    uint supplyIncomeInBorrowAsset36;\n    /// @notice Potential rewards amount after borrow period in terms of Borrow Tokens, decimals 36\n    uint rewardsAmountInBorrowAsset36;\n    /// @notice Amount of collateral in terms of borrow asset, decimals 36\n    uint amountCollateralInBorrowAsset36;\n\n    /// @notice Loan-to-value, decimals = 18 (wad)\n    uint ltv18;\n    /// @notice How much borrow asset we can borrow in the pool (in borrow tokens)\n    uint maxAmountToBorrow;\n    /// @notice How much collateral asset can be supplied (in collateral tokens).\n    ///         type(uint).max - unlimited, 0 - no supply is possible\n    uint maxAmountToSupply;\n  }\n\n  struct PricesAndDecimals {\n    /// @notice Price of the collateral asset (decimals same as the decimals of {priceBorrow})\n    uint priceCollateral;\n    /// @notice Price of the borrow asset (decimals same as the decimals of {priceCollateral})\n    uint priceBorrow;\n    /// @notice 10**{decimals of the collateral asset}\n    uint rc10powDec;\n    /// @notice 10**{decimals of the borrow asset}\n    uint rb10powDec;\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/AppErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice List of all errors generated by the application\n///         Each error should have unique code TC-XXX and descriptive comment\nlibrary AppErrors {\n  /// @notice Provided address should be not zero\n  string public constant ZERO_ADDRESS = \"TC-1 zero address\";\n  /// @notice Pool adapter for the given set {converter, user, collateral, borrowToken} not found and cannot be created\n  string public constant POOL_ADAPTER_NOT_FOUND = \"TC-2 adapter not found\";\n  /// @notice Health factor is not set or it's less then min allowed value\n  string public constant WRONG_HEALTH_FACTOR = \"TC-3 wrong health factor\";\n  /// @notice Received price is zero\n  string public constant ZERO_PRICE = \"TC-4 zero price\";\n  /// @notice Given platform adapter is not found in Borrow Manager\n  string public constant PLATFORM_ADAPTER_NOT_FOUND = \"TC-6 platform adapter not found\";\n  /// @notice Only pool adapters are allowed to make such operation\n  string public constant POOL_ADAPTER_ONLY = \"TC-7 pool adapter not found\";\n  /// @notice Only TetuConverter is allowed to make such operation\n  string public constant TETU_CONVERTER_ONLY = \"TC-8 tetu converter only\";\n  /// @notice Only Governance is allowed to make such operation\n  string public constant GOVERNANCE_ONLY = \"TC-9 governance only\";\n  /// @notice Cannot close borrow position if the position has not zero collateral or borrow balance\n  string public constant ATTEMPT_TO_CLOSE_NOT_EMPTY_BORROW_POSITION = \"TC-10 position not empty\";\n  /// @notice Borrow position is not registered in DebtMonitor\n  string public constant BORROW_POSITION_IS_NOT_REGISTERED = \"TC-11 position not registered\";\n  /// @notice Passed arrays should have same length\n  string public constant WRONG_LENGTHS = \"TC-12 wrong lengths\";\n  /// @notice Pool adapter expects some amount of collateral on its balance\n  string public constant WRONG_COLLATERAL_BALANCE=\"TC-13 wrong collateral balance\";\n  /// @notice Pool adapter expects some amount of derivative tokens on its balance after borrowing\n  string public constant WRONG_DERIVATIVE_TOKENS_BALANCE=\"TC-14 wrong ctokens balance\";\n  /// @notice Pool adapter expects some amount of borrowed tokens on its balance\n  string public constant WRONG_BORROWED_BALANCE = \"TC-15 wrong borrow balance\";\n  /// @notice cToken is not found for provided underlying\n  string public constant C_TOKEN_NOT_FOUND = \"TC-16 ctoken not found\";\n  /// @notice cToken.mint failed\n  string public constant MINT_FAILED = \"TC-17 mint failed\";\n  string public constant COMPTROLLER_GET_ACCOUNT_LIQUIDITY_FAILED = \"TC-18 get account liquidity failed\";\n  string public constant COMPTROLLER_GET_ACCOUNT_LIQUIDITY_UNDERWATER = \"TC-19 get account liquidity underwater\";\n  /// @notice borrow failed\n  string public constant BORROW_FAILED = \"TC-20 borrow failed\";\n  string public constant CTOKEN_GET_ACCOUNT_SNAPSHOT_FAILED = \"TC-21 snapshot failed\";\n  string public constant CTOKEN_GET_ACCOUNT_LIQUIDITY_FAILED = \"TC-22 liquidity failed\";\n  string public constant INCORRECT_RESULT_LIQUIDITY = \"TC-23 incorrect liquidity\";\n  string public constant CLOSE_POSITION_FAILED = \"TC-24 close position failed\";\n  string public constant CONVERTER_NOT_FOUND = \"TC-25 converter not found\";\n  string public constant REDEEM_FAILED = \"TC-26 redeem failed\";\n  string public constant REPAY_FAILED = \"TC-27 repay failed\";\n  /// @notice Balance shouldn't be zero\n  string public constant ZERO_BALANCE = \"TC-28 zero balance\";\n  string public constant INCORRECT_VALUE = \"TC-29 incorrect value\";\n  /// @notice Only user can make this action\n  string public constant USER_ONLY = \"TC-30 user only\";\n  /// @notice It's not allowed to close position with a pool adapter and make re-conversion using the same adapter\n  string public constant RECONVERSION_WITH_SAME_CONVERTER_FORBIDDEN = \"TC-31 reconversion forbidden\";\n\n  /// @notice Platform adapter cannot be unregistered because there is active pool adapter (open borrow on the platform)\n  string public constant PLATFORM_ADAPTER_IS_IN_USE = \"TC-33 platform adapter is in use\";\n\n  string public constant DIVISION_BY_ZERO = \"TC-34 division by zero\";\n\n  string public constant UNSUPPORTED_CONVERSION_KIND = \"TC-35: UNKNOWN CONVERSION\";\n  string public constant SLIPPAGE_TOO_BIG = \"TC-36: SLIPPAGE TOO BIG\";\n\n  /// @notice The relation \"platform adapter - converter\" is invariant.\n  ///         It's not allowed to assign new platform adapter to the converter\n  string public constant ONLY_SINGLE_PLATFORM_ADAPTER_CAN_USE_CONVERTER = \"TC-37 one platform adapter per conv\";\n\n  /// @notice Provided health factor value is not applicable for other health factors\n  ///         Invariant: min health factor < target health factor < max health factor\n  string public constant WRONG_HEALTH_FACTOR_CONFIG = \"TC-38: wrong health factor config\";\n\n  /// @notice Health factor is not good after rebalancing\n  string public constant WRONG_REBALANCING = \"TC-39: wrong rebalancing\";\n\n  /// @notice It's not allowed to pay debt completely using repayToRebalance\n  ///         Please use ordinal repay for this purpose (it allows to receive the collateral)\n  string public constant REPAY_TO_REBALANCE_NOT_ALLOWED = \"TC-40 repay to rebalance not allowed\";\n\n  /// @notice Received amount is different from expected one\n  string public constant WRONG_AMOUNT_RECEIVED = \"TC-41 wrong amount received\";\n  /// @notice Only one of the keepers is allowed to make such operation\n  string public constant KEEPER_ONLY = \"TC-42 keeper only\";\n\n  /// @notice The amount cannot be zero\n  string public constant ZERO_AMOUNT = \"TC-43 zero amount\";\n\n  /// @notice Value of \"converter\" passed to TetuConverter.borrow is incorrect ( != SwapManager address)\n  string public constant INCORRECT_CONVERTER_TO_SWAP = \"TC-44 incorrect converter\";\n\n  string public constant BORROW_MANAGER_ONLY = \"TC-45 borrow manager only\";\n\n  /// @notice Attempt to make a borrow using unhealthy pool adapter\n  ///         This is not normal situation.\n  ///         Health factor is greater 1 but it's less then minimum allowed value.\n  ///         Keeper doesn't work?\n  string public constant REBALANCING_IS_REQUIRED = \"TC-46 rebalancing is required\";\n\n  /// @notice Position can be closed as \"liquidated\" only if there is no collateral on it\n  string public constant CANNOT_CLOSE_LIVE_POSITION = \"TC-47 cannot close live pos\";\n\n  string public constant ACCESS_DENIED = \"TC-48 access denied\";\n\n  /// @notice Value A is less then B, so we will have overflow on A - B, but it's weird situation\n  ///         If balance is decreased after a supply or increased after a deposit\n  string public constant WEIRD_OVERFLOW = \"TC-49 weird overflow\";\n\n  string public constant AMOUNT_TOO_BIG = \"TC-50 amount too big\";\n\n  string public constant NOT_PENDING_GOVERNANCE = \"TC-51 not pending gov\";\n\n  string public constant INCORRECT_OPERATION = \"TC-52 incorrect op\";\n\n  string public constant ONLY_SWAP_MANAGER = \"TC-53 swap manager only\";\n\n  string public constant TOO_HIGH_PRICE_IMPACT = \"TC-54 price impact\";\n\n  /// @notice It's not possible to make partial repayment and close the position\n  string public constant CLOSE_POSITION_PARTIAL = \"TC-55 close position not allowed\";\n  string public constant ZERO_VALUE_NOT_ALLOWED = \"TC-56 zero not allowed\";\n  string public constant OUT_OF_WHITE_LIST = \"TC-57 whitelist\";\n\n  string public constant INCORRECT_BORROW_ASSET = \"TC-58 incorrect borrow asset\";\n\n  string public constant UNSALVAGEABLE = \"TC-59: unsalvageable\";\n\n  string public constant GELATO_ONLY_OPS = \"TC-60: onlyOps\";\n  string public constant GELATO_ETH_TRANSFER_FAILED = \"TC-61: _transfer: ETH transfer failed\";\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/AppUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Common utils\nlibrary AppUtils {\n  /// @notice Convert {amount} with [sourceDecimals} to new amount with {targetDecimals}\n  function toMantissa(uint amount, uint8 sourceDecimals, uint8 targetDecimals) internal pure returns (uint) {\n    return sourceDecimals == targetDecimals\n      ? amount\n      : amount * (10 ** targetDecimals) / (10 ** sourceDecimals);\n  }\n\n  function uncheckedInc(uint i) internal pure returns (uint) {\n    unchecked {\n      return i + 1;\n    }\n  }\n\n  /// @notice Remove {itemToRemove} from {items}, move last item of {items} to the position of the removed item\n  function removeItemFromArray(address[] storage items, address itemToRemove) internal {\n    uint lenItems = items.length;\n    for (uint i = 0; i < lenItems; i = uncheckedInc(i)) {\n      if (items[i] == itemToRemove) {\n        if (i < lenItems - 1) {\n          items[i] = items[lenItems - 1];\n        }\n        items.pop();\n        break;\n      }\n    }\n  }\n\n  /// @notice Create new array with only first {countItemsToKeep_} items from {items_} array\n  /// @dev We assume, that trivial case countItemsToKeep_ == 0 is excluded, the function is not called in that case\n  function removeLastItems(address[] memory items_, uint countItemsToKeep_) internal pure returns (address[] memory) {\n    uint lenItems = items_.length;\n    if (lenItems <= countItemsToKeep_) {\n      return items_;\n    }\n\n    address[] memory dest = new address[](countItemsToKeep_);\n    for (uint i = 0; i < countItemsToKeep_; i = uncheckedInc(i)) {\n      dest[i] = items_[i];\n    }\n\n    return dest;\n  }\n\n  /// @dev We assume, that trivial case countItemsToKeep_ == 0 is excluded, the function is not called in that case\n  function removeLastItems(uint[] memory items_, uint countItemsToKeep_) internal pure returns (uint[] memory) {\n    uint lenItems = items_.length;\n    if (lenItems <= countItemsToKeep_) {\n      return items_;\n    }\n\n    uint[] memory dest = new uint[](countItemsToKeep_);\n    for (uint i = 0; i < countItemsToKeep_; i = uncheckedInc(i)) {\n      dest[i] = items_[i];\n    }\n\n    return dest;\n  }\n\n  /// @notice (amount1 - amount2) / amount1/2 < expected difference\n  function approxEqual(uint amount1, uint amount2, uint divisionMax18) internal pure returns (bool) {\n    return amount1 > amount2\n      ? (amount1 - amount2) * 1e18 / (amount2 + 1) < divisionMax18\n      : (amount2 - amount1) * 1e18 / (amount2 + 1) < divisionMax18;\n  }\n\n  /// @notice Reduce size of {aa_}, {bb_}, {cc_}, {dd_} ot {count_} if necessary\n  ///         and order all arrays in ascending order of {aa_}\n  /// @dev We assume here, that {count_} is rather small (it's a number of available lending platforms) < 10\n  function shrinkAndOrder(\n    uint count_,\n    address[] memory bb_,\n    uint[] memory cc_,\n    uint[] memory dd_,\n    int[] memory aa_\n  ) internal pure returns (\n    address[] memory bbOut,\n    uint[] memory ccOut,\n    uint[] memory ddOut,\n    int[] memory aaOut\n  ) {\n    uint[] memory indices = _sortAsc(count_, aa_);\n\n    aaOut = new int[](count_);\n    bbOut = new address[](count_);\n    ccOut = new uint[](count_);\n    ddOut = new uint[](count_);\n    for (uint i = 0; i < count_; ++i) {\n      aaOut[i] = aa_[indices[i]];\n      bbOut[i] = bb_[indices[i]];\n      ccOut[i] = cc_[indices[i]];\n      ddOut[i] = dd_[indices[i]];\n    }\n  }\n\n  /// @notice Insertion sorting algorithm for using with arrays fewer than 10 elements, isert in ascending order.\n  ///         Take into account only first {length_} items of the {items_} array\n  /// @dev Based on https://medium.com/coinmonks/sorting-in-solidity-without-comparison-4eb47e04ff0d\n  /// @return indices Ordered list of indices of the {items_}, size = {length}\n  function _sortAsc(uint length_, int[] memory items_) internal pure returns (uint[] memory indices) {\n    indices = new uint[](length_);\n    unchecked {\n      for (uint i; i < length_; ++i) {\n        indices[i] = i;\n      }\n\n      for (uint i = 1; i < length_; i++) {\n        uint key = indices[i];\n        uint j = i - 1;\n        while ((int(j) >= 0) && items_[indices[j]] > items_[key]) {\n          indices[j + 1] = indices[j];\n          j--;\n        }\n        indices[j + 1] = key;\n      }\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/EntryKinds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AppDataTypes.sol\";\nimport \"./AppErrors.sol\";\n\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\nlibrary EntryKinds {\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\n\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\n  ///         C2 should be used as collateral to make a borrow B.\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\n\n  /// @notice Borrow given amount using min possible collateral\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\n\n\n  /// @notice Decode entryData, extract first uint - entry kind\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\n    if (entryData_.length == 0) {\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\n    }\n    return abi.decode(entryData_, (uint));\n  }\n\n  /// @notice Use {collateralAmount} as a collateral to receive max available {amountToBorrowOut}\n  ///         for the given {healthFactor18} and {liquidationThreshold18}\n  /// @param collateralAmount Available collateral amount\n  /// @param healthFactor18 Required health factor, decimals 18\n  /// @param liquidationThreshold18 Liquidation threshold of the selected landing platform, decimals 18\n  /// @param priceDecimals36 True if the prices in {pd} have decimals 36 (DForce, HundredFinance)\n  ///                        In this case, we can have overloading if collateralAmount is high enough,\n  ///                        so we need a special logic to avoid it\n  function exactCollateralInForMaxBorrowOut(\n    uint collateralAmount,\n    uint healthFactor18,\n    uint liquidationThreshold18,\n    AppDataTypes.PricesAndDecimals memory pd,\n    bool priceDecimals36\n  ) internal pure returns (\n    uint amountToBorrowOut\n  ) {\n    if (priceDecimals36) {\n      amountToBorrowOut =\n        1e18 * collateralAmount / healthFactor18\n        * (liquidationThreshold18 * pd.priceCollateral / pd.priceBorrow) // avoid overloading\n        * pd.rb10powDec\n        / 1e18\n        / pd.rc10powDec;\n    } else {\n      amountToBorrowOut =\n        1e18 * collateralAmount / healthFactor18\n        * liquidationThreshold18 * pd.priceCollateral / pd.priceBorrow\n        * pd.rb10powDec\n        / 1e18\n        / pd.rc10powDec;\n    }\n  }\n\n  /// @notice Borrow given {borrowAmount} using min possible collateral\n  /// @param borrowAmount Required amount to borrow\n  /// @param healthFactor18 Required health factor, decimals 18\n  /// @param liquidationThreshold18 Liquidation threshold of the selected landing platform, decimals 18\n  /// @param priceDecimals36 True if the prices in {pd} have decimals 36 (DForce, HundredFinance)\n  ///                        In this case, we can have overloading if collateralAmount is high enough,\n  ///                        so we need a special logic to avoid it\n  function exactBorrowOutForMinCollateralIn(\n    uint borrowAmount,\n    uint healthFactor18,\n    uint liquidationThreshold18,\n    AppDataTypes.PricesAndDecimals memory pd,\n    bool priceDecimals36\n  ) internal pure returns (\n    uint amountToCollateralOut\n  ) {\n    if (priceDecimals36) {\n      amountToCollateralOut = borrowAmount\n        * pd.priceBorrow / pd.priceCollateral\n        * healthFactor18 / liquidationThreshold18\n        * pd.rc10powDec\n        / pd.rb10powDec;\n    } else {\n      amountToCollateralOut = borrowAmount\n        * healthFactor18\n        * pd.priceBorrow / (liquidationThreshold18 * pd.priceCollateral)\n        * pd.rc10powDec\n        / pd.rb10powDec;\n    }\n  }\n\n  /// @notice Split {collateralAmount} on two parts: C1 and {collateralAmountOut}.\n  ///         {collateralAmountOut} will be used as collateral to borrow {amountToBorrowOut}.\n  ///         Result cost of {amountToBorrowOut} and C1 should be equal or almost equal.\n  /// @param collateralAmount Available collateral amount, we should use less amount.\n  /// @param healthFactor18 Required health factor, decimals 18\n  /// @param liquidationThreshold18 Liquidation threshold of the selected landing platform, decimals 18\n  /// @param priceDecimals36 True if the prices in {pd} have decimals 36 (DForce, HundredFinance)\n  ///                        In this case, we can have overloading if collateralAmount is high enough,\n  ///                        so we need a special logic to avoid it\n  /// @param entryData Additional encoded data: required proportions of C1' and {amountToBorrowOut}', X:Y\n  ///                  Encoded data: (uint entryKind, uint X, uint Y)\n  ///                  X - portion of C1, Y - portion of {amountToBorrowOut}\n  ///                  2:1 means, that we will have 2 parts of source asset and 1 part of borrowed asset in result.\n  ///                  entryKind must be equal to 1 (== ENTRY_KIND_EQUAL_COLLATERAL_AND_BORROW_OUT_1)\n  function exactProportion(\n    uint collateralAmount,\n    uint healthFactor18,\n    uint liquidationThreshold18,\n    AppDataTypes.PricesAndDecimals memory pd,\n    bytes memory entryData,\n    bool priceDecimals36\n  ) internal pure returns (\n    uint collateralAmountOut,\n    uint amountToBorrowOut\n  ) {\n    collateralAmountOut = getCollateralAmountToConvert(\n      entryData,\n      collateralAmount,\n      healthFactor18,\n      liquidationThreshold18\n    );\n    amountToBorrowOut = exactCollateralInForMaxBorrowOut(\n      collateralAmountOut,\n      healthFactor18,\n      liquidationThreshold18,\n      pd,\n      priceDecimals36\n    );\n  }\n\n  /// @notice Split {sourceAmount_} on two parts: C1 and C2. Swap C2 => {targetAmountOut}\n  ///         Result cost of {targetAmountOut} and C1 should be equal or almost equal\n  function getCollateralAmountToConvert(\n    bytes memory entryData,\n    uint collateralAmount,\n    uint healthFactor18,\n    uint liquidationThreshold18\n  ) internal pure returns (\n    uint collateralAmountOut\n  ) {\n    // C = C1 + C2, HF = healthFactor18, LT = liquidationThreshold18\n    // C' = C1' + C2' where C' is C recalculated to USD\n    // C' = C * PC / DC, where PC is price_C, DC = 10**decimals_C\n    // Y*B' = X*(C' - C1')*LT/HF ~ C1` => C1' = C' * a / (1 + a), C2' = C' / (1 + a)\n    // where a = (X * LT)/(HF * Y)\n\n    (, uint x, uint y) = abi.decode(entryData, (uint, uint, uint));\n    require(x != 0 && y != 0, AppErrors.ZERO_VALUE_NOT_ALLOWED);\n\n    uint a = (x * liquidationThreshold18 * 1e18) / (healthFactor18 * y);\n    return collateralAmount * 1e18 / (1e18 + a);\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  /// @dev Gets a slot array by index as uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  // ************* ARRAY SETTERS *******************\n\n  /// @dev Sets a slot array at index with address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, address value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets a slot array at index with uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, uint value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets an array length\n  function setLength(bytes32 slot, uint length) internal {\n    assembly {\n      sstore(slot, length)\n    }\n  }\n\n  /// @dev Pushes an address to the array\n  function push(bytes32 slot, address value) internal {\n    uint length = arrayLength(slot);\n    setAt(slot, length, value);\n    setLength(slot, length + 1);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/SwapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AppErrors.sol\";\nimport \"../openzeppelin/IERC20Metadata.sol\";\nimport \"../interfaces/IPriceOracle.sol\";\n\n/// @notice Various swap-related routines\nlibrary SwapLib {\n  uint public constant PRICE_IMPACT_NUMERATOR = 100_000;\n  uint public constant PRICE_IMPACT_TOLERANCE_DEFAULT = PRICE_IMPACT_NUMERATOR * 2 / 100; // 2%\n\n\n  /// @notice Convert amount of {assetIn_} to the corresponded amount of {assetOut_} using price oracle prices\n  /// @return Result amount in terms of {assetOut_}\n  function convertUsingPriceOracle(\n    IPriceOracle priceOracle_,\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_\n  ) internal view returns (uint) {\n    uint priceOut = priceOracle_.getAssetPrice(assetOut_);\n    uint priceIn = priceOracle_.getAssetPrice(assetIn_);\n    require(priceOut != 0 && priceIn != 0, AppErrors.ZERO_PRICE);\n\n    return amountIn_\n      * 10**IERC20Metadata(assetOut_).decimals()\n      * priceIn\n      / priceOut\n      / 10**IERC20Metadata(assetIn_).decimals();\n  }\n\n  /// @notice Check if {amountOut_} is less than expected more than allowed by {priceImpactTolerance_}\n  ///         Expected amount is calculated using embedded price oracle.\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\n  function isConversionValid(\n    IPriceOracle priceOracle_,\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    uint priceImpactTolerance_\n  ) internal view returns (bool) {\n    uint priceOut = priceOracle_.getAssetPrice(assetOut_);\n    uint priceIn = priceOracle_.getAssetPrice(assetIn_);\n    require(priceOut != 0 && priceIn != 0, AppErrors.ZERO_PRICE);\n\n    uint expectedAmountOut = amountIn_\n      * 10**IERC20Metadata(assetOut_).decimals()\n      * priceIn\n      / priceOut\n      / 10**IERC20Metadata(assetIn_).decimals();\n    return amountOut_ > expectedAmountOut\n      ? true // we assume here, that higher output amount is not a problem\n      : (expectedAmountOut - amountOut_) <= expectedAmountOut * priceImpactTolerance_ / SwapLib.PRICE_IMPACT_NUMERATOR;\n  }\n}"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n *\n * _Available since v3.4._\n */\nlibrary Clones {\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        require(instance != address(0), \"ERC1167: create failed\");\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        require(instance != address(0), \"ERC1167: create2 failed\");\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity 0.8.17;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Map type with\n    // bytes32 keys and values.\n    // The Map implementation uses private functions, and user-facing\n    // implementations (such as Uint256ToAddressMap) are just wrappers around\n    // the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit\n    // in bytes32.\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n        return value;\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToBytes32Map storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        require(value != 0 || contains(map, key), errorMessage);\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(UintToUintMap storage map, uint256 key, string memory errorMessage) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key), errorMessage));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        UintToAddressMap storage map,\n        uint256 key,\n        string memory errorMessage\n    ) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        AddressToUintMap storage map,\n        address key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n    function get(\n        Bytes32ToUintMap storage map,\n        bytes32 key,\n        string memory errorMessage\n    ) internal view returns (uint256) {\n        return uint256(get(map._inner, key, errorMessage));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity 0.8.17;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.1) (proxy/utils/Initializable.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized != type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint8) {\n        return _initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _initializing;\n    }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Permit.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Compatible with tokens that require the approval to be set to\n     * 0 before setting it to a non-zero value.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/protocols/hundred-finance/HfAprLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../openzeppelin/IERC20Metadata.sol\";\nimport \"../../libs/AppErrors.sol\";\nimport \"../../libs/AppUtils.sol\";\nimport \"../../libs/AppDataTypes.sol\";\nimport \"../../integrations/hundred-finance/IHfCToken.sol\";\nimport \"../../integrations/hundred-finance/IHfInterestRateModel.sol\";\nimport \"../../integrations/hundred-finance/IHfComptroller.sol\";\nimport \"../../integrations/hundred-finance/IHfPriceOracle.sol\";\n\n/// @notice Hundred finance utils: predict borrow and supply rate in advance, calculate borrow and supply APR\n///         Borrow APR = the amount by which the debt increases per block; the amount is in terms of borrow tokens\n///         Supply APR = the amount by which the income increases per block; the amount is in terms of BORROW tokens too\nlibrary HfAprLib {\n  address internal constant WMATIC = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n  address internal constant hMATIC = address(0xEbd7f3349AbA8bB15b897e03D6c1a4Ba95B55e31);\n\n  //-----------------------------------------------------\n  //                  Data type\n  //-----------------------------------------------------\n  struct HfCore {\n    IHfCToken cTokenCollateral;\n    IHfCToken cTokenBorrow;\n    address collateralAsset;\n    address borrowAsset;\n  }\n\n  //-----------------------------------------------------\n  //                  Addresses\n  //-----------------------------------------------------\n\n  /// @notice Get core address of DForce\n  function getCore(\n    address cTokenCollateral_,\n    address cTokenBorrow_\n  ) internal view returns (HfCore memory) {\n    return HfCore({\n      cTokenCollateral: IHfCToken(cTokenCollateral_),\n      cTokenBorrow: IHfCToken(cTokenBorrow_),\n      collateralAsset: getUnderlying(cTokenCollateral_),\n      borrowAsset: getUnderlying(cTokenBorrow_)\n    });\n  }\n\n  //-----------------------------------------------------\n  //                  Estimate APR\n  //-----------------------------------------------------\n\n  /// @notice Calculate cost and incomes, take into account borrow rate and supply rate.\n  /// @return borrowCost36 Estimated borrow cost for the period, borrow tokens, decimals 36\n  /// @return supplyIncomeInBorrowAsset36 Current supply income for the period (in terms of borrow tokens), decimals 36\n  function getRawCostAndIncomes(\n    HfCore memory core,\n    uint collateralAmount_,\n    uint countBlocks_,\n    uint amountToBorrow_,\n    AppDataTypes.PricesAndDecimals memory pad_\n  ) internal view returns (\n    uint borrowCost36,\n    uint supplyIncomeInBorrowAsset36\n  ) {\n    supplyIncomeInBorrowAsset36 = getSupplyIncomeInBorrowAsset36(\n      getEstimatedSupplyRate(\n        IHfInterestRateModel(core.cTokenCollateral.interestRateModel()),\n        core.cTokenCollateral,\n        collateralAmount_\n      ),\n      countBlocks_,\n      pad_.rc10powDec,\n      pad_.priceCollateral,\n      pad_.priceBorrow,\n      collateralAmount_\n    );\n\n    // estimate borrow rate value after the borrow and calculate result APR\n    borrowCost36 = getBorrowCost36(\n      getEstimatedBorrowRate(\n        IHfInterestRateModel(core.cTokenBorrow.interestRateModel()),\n        core.cTokenBorrow,\n        amountToBorrow_\n      ),\n      amountToBorrow_,\n      countBlocks_,\n      pad_.rb10powDec\n    );\n  }\n\n  /// @notice Calculate supply income in terms of borrow asset with decimals 36\n  function getSupplyIncomeInBorrowAsset36(\n    uint supplyRatePerBlock,\n    uint countBlocks,\n    uint collateral10PowDecimals,\n    uint priceCollateral,\n    uint priceBorrow,\n    uint suppliedAmount\n  ) internal pure returns (uint) {\n    // original code:\n    //    rmul(supplyRatePerBlock * countBlocks, suppliedAmount) * priceCollateral / priceBorrow,\n    // but we need result decimals 36\n    // so, we replace rmul by ordinal mul and take into account /1e18\n    return\n      supplyRatePerBlock * countBlocks * suppliedAmount * priceCollateral / priceBorrow\n      * 1e18 // not 36 because we replaced rmul by mul\n      / collateral10PowDecimals;\n  }\n\n  /// @notice Calculate borrow cost in terms of borrow tokens with decimals 36\n  /// @dev see LendingContractsV2, Base.sol, _updateInterest\n  function getBorrowCost36(\n    uint borrowRatePerBlock,\n    uint borrowedAmount,\n    uint countBlocks,\n    uint borrow10PowDecimals\n  ) internal pure returns (uint) {\n    // simpleInterestFactor = borrowRate * blockDelta\n    // interestAccumulated = simpleInterestFactor * totalBorrows\n    // newTotalBorrows = interestAccumulated + totalBorrows\n    uint simpleInterestFactor = borrowRatePerBlock * countBlocks;\n\n    // Replace rmul(simpleInterestFactor, borrowedAmount) by ordinal mul and take into account /1e18\n    return\n      simpleInterestFactor * borrowedAmount\n      * 1e18 // not 36 because we replaced rmul by mul\n      / borrow10PowDecimals;\n  }\n\n  //-----------------------------------------------------\n  //         Estimate borrow rate\n  //-----------------------------------------------------\n\n  /// @notice Estimate value of variable borrow rate after borrowing {amountToBorrow_}\n  /// @dev repeats compound-protocol, CToken.sol, borrowRatePerBlock() impl\n  function getEstimatedBorrowRate(\n    IHfInterestRateModel interestRateModel_,\n    IHfCToken cTokenBorrow_,\n    uint amountToBorrow_\n  ) internal view returns (uint) {\n    return interestRateModel_.getBorrowRate(\n      cTokenBorrow_.getCash() - amountToBorrow_,\n      cTokenBorrow_.totalBorrows() + amountToBorrow_,\n      cTokenBorrow_.totalReserves()\n    );\n  }\n\n  //-----------------------------------------------------\n  //         Estimate supply rate\n  //-----------------------------------------------------\n\n  /// @dev repeats compound-protocol, CToken.sol, supplyRatePerBlock() impl\n  function getEstimatedSupplyRate(\n    IHfInterestRateModel interestRateModel_,\n    IHfCToken cToken_,\n    uint amountToSupply_\n  ) internal view returns(uint) {\n    return interestRateModel_.getSupplyRate(\n\n      // Cash balance of this cToken in the underlying asset\n      cToken_.getCash() + amountToSupply_,\n      cToken_.totalBorrows(),\n      cToken_.totalReserves(),\n      cToken_.reserveFactorMantissa()\n    );\n  }\n\n  //-----------------------------------------------------\n  ///                 Utils to inline\n  //-----------------------------------------------------\n  function getPrice(IHfPriceOracle priceOracle, address token) internal view returns (uint) {\n    uint price = priceOracle.getUnderlyingPrice(token);\n    require(price != 0, AppErrors.ZERO_PRICE);\n    return price;\n  }\n\n  function getUnderlying(address token) internal view returns (address) {\n    return token == hMATIC\n      ? WMATIC\n      : IHfCToken(token).underlying();\n  }\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/protocols/hundred-finance/HfPlatformAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./HfAprLib.sol\";\nimport \"../../openzeppelin/SafeERC20.sol\";\nimport \"../../openzeppelin/IERC20.sol\";\nimport \"../../openzeppelin/IERC20Metadata.sol\";\nimport \"../../libs/AppDataTypes.sol\";\nimport \"../../libs/AppErrors.sol\";\nimport \"../../libs/AppUtils.sol\";\nimport \"../../libs/EntryKinds.sol\";\nimport \"../../interfaces/IConverterController.sol\";\nimport \"../../interfaces/IPlatformAdapter.sol\";\nimport \"../../interfaces/IPoolAdapterInitializerWithAP.sol\";\nimport \"../../interfaces/ITokenAddressProvider.sol\";\nimport \"../../integrations/hundred-finance/IHfComptroller.sol\";\nimport \"../../integrations/hundred-finance/IHfCToken.sol\";\nimport \"../../integrations/hundred-finance/IHfPriceOracle.sol\";\nimport \"../../integrations/hundred-finance/IHfInterestRateModel.sol\";\n\n/// @notice Adapter to read current pools info from HundredFinance-protocol, see https://docs.hundred.finance/\ncontract HfPlatformAdapter is IPlatformAdapter, ITokenAddressProvider {\n  using SafeERC20 for IERC20;\n  using AppUtils for uint;\n\n  //-----------------------------------------------------\n  ///   Constants\n  //-----------------------------------------------------\n  string public constant override PLATFORM_ADAPTER_VERSION = \"1.0.1\";\n\n  //-----------------------------------------------------\n  ///   Data types\n  //-----------------------------------------------------\n\n  /// @notice Local vars inside getConversionPlan - to avoid stack too deep\n  struct LocalsGetConversionPlan {\n    IHfComptroller comptroller;\n    IHfPriceOracle priceOracle;\n    address cTokenCollateral;\n    address cTokenBorrow;\n    uint entryKind;\n  }\n\n  //-----------------------------------------------------\n  ///   Variables\n  //-----------------------------------------------------\n  IConverterController immutable public controller;\n  IHfComptroller immutable public comptroller;\n  /// @notice Template of pool adapter\n  address immutable public converter;\n  /// @dev Same as controller.borrowManager(); we cache it for gas optimization\n  address immutable public borrowManager;\n\n\n  /// @notice All enabled pairs underlying : cTokens. All assets usable for collateral/to borrow.\n  /// @dev There is no underlying for WMATIC, we store hMATIC:WMATIC\n  mapping(address => address) public activeAssets;\n\n  /// @notice True if the platform is frozen and new borrowing is not possible (at this moment)\n  bool public override frozen;\n\n  //-----------------------------------------------------\n  ///               Events\n  //-----------------------------------------------------\n  event OnPoolAdapterInitialized(\n    address converter,\n    address poolAdapter,\n    address user,\n    address collateralAsset,\n    address borrowAsset\n  );\n  event OnRegisterCTokens(address[] cTokens);\n\n  //-----------------------------------------------------\n  ///       Constructor and initialization\n  //-----------------------------------------------------\n\n  constructor (\n    address controller_,\n    address borrowManager_,\n    address comptroller_,\n    address templatePoolAdapter_,\n    address[] memory activeCTokens_\n  ) {\n    require(\n      comptroller_ != address(0)\n      && borrowManager_ != address(0)\n      && templatePoolAdapter_ != address(0)\n      && controller_ != address(0),\n      AppErrors.ZERO_ADDRESS\n    );\n\n    comptroller = IHfComptroller(comptroller_);\n    controller = IConverterController(controller_);\n    converter = templatePoolAdapter_;\n    borrowManager = borrowManager_;\n\n    _registerCTokens(activeCTokens_);\n  }\n\n  /// @notice Initialize {poolAdapter_} created from {converter_} using minimal proxy pattern\n  function initializePoolAdapter(\n    address converter_,\n    address poolAdapter_,\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) external override {\n    require(msg.sender == borrowManager, AppErrors.BORROW_MANAGER_ONLY);\n    require(converter == converter_, AppErrors.CONVERTER_NOT_FOUND);\n\n    // HF-pool-adapters support IPoolAdapterInitializer\n    IPoolAdapterInitializerWithAP(poolAdapter_).initialize(\n      address(controller),\n      address(this),\n      address(comptroller),\n      user_,\n      collateralAsset_,\n      borrowAsset_,\n      converter_\n    );\n    emit OnPoolAdapterInitialized(converter_, poolAdapter_, user_, collateralAsset_, borrowAsset_);\n  }\n\n  /// @notice Set platform to frozen/unfrozen state. In frozen state any new borrowing is forbidden.\n  function setFrozen(bool frozen_) external {\n    require(msg.sender == controller.governance(), AppErrors.GOVERNANCE_ONLY);\n    frozen = frozen_;\n  }\n\n  /// @notice Register new CTokens supported by the market\n  /// @dev It's possible to add CTokens only because, we can add unregister function if necessary\n  function registerCTokens(address[] memory cTokens_) external {\n    _onlyGovernance();\n    _registerCTokens(cTokens_);\n    emit OnRegisterCTokens(cTokens_);\n  }\n\n  function _registerCTokens(address[] memory cTokens_) internal {\n    uint lenCTokens = cTokens_.length;\n    for (uint i = 0; i < lenCTokens; i = i.uncheckedInc()) {\n      // Special case: there is no underlying for WMATIC, so we store hMATIC:WMATIC\n      activeAssets[HfAprLib.getUnderlying(cTokens_[i])] = cTokens_[i];\n    }\n  }\n\n  //-----------------------------------------------------\n  ///                    Access\n  //-----------------------------------------------------\n\n  /// @notice Ensure that the caller is governance\n  function _onlyGovernance() internal view {\n    require(controller.governance() == msg.sender, AppErrors.GOVERNANCE_ONLY);\n  }\n\n  //-----------------------------------------------------\n  ///                     View\n  //-----------------------------------------------------\n\n  function converters() external view override returns (address[] memory) {\n    address[] memory dest = new address[](1);\n    dest[0] = converter;\n    return dest;\n  }\n\n  function getCTokenByUnderlying(address token1_, address token2_)\n  external view override\n  returns (address cToken1, address cToken2) {\n    return (activeAssets[token1_], activeAssets[token2_]);\n  }\n\n  function platformKind() external pure returns (AppDataTypes.LendingPlatformKinds) {\n    return AppDataTypes.LendingPlatformKinds.HUNDRED_FINANCE_4;\n  }\n\n\n  //-----------------------------------------------------\n  ///       Get conversion plan\n  //-----------------------------------------------------\n\n  function getConversionPlan (\n    AppDataTypes.InputConversionParams memory p_,\n    uint16 healthFactor2_\n  ) external override view returns (\n    AppDataTypes.ConversionPlan memory plan\n  ) {\n    require(p_.collateralAsset != address(0) && p_.borrowAsset != address(0), AppErrors.ZERO_ADDRESS);\n    require(p_.amountIn != 0 && p_.countBlocks != 0, AppErrors.INCORRECT_VALUE);\n    require(healthFactor2_ >= controller.minHealthFactor2(), AppErrors.WRONG_HEALTH_FACTOR);\n\n    if (! frozen) {\n      LocalsGetConversionPlan memory vars;\n      vars.comptroller = comptroller;\n      vars.cTokenCollateral = activeAssets[p_.collateralAsset];\n      if (vars.cTokenCollateral != address(0)) {\n\n        vars.cTokenBorrow = activeAssets[p_.borrowAsset];\n        if (vars.cTokenBorrow != address(0)) {\n          //-------------------------------- LTV and liquidation threshold\n          (plan.ltv18, plan.liquidationThreshold18) = getMarketsInfo(vars.cTokenCollateral, vars.cTokenBorrow);\n          if (plan.ltv18 != 0 && plan.liquidationThreshold18 != 0) {\n            //------------------------------- Calculate maxAmountToSupply and maxAmountToBorrow\n            plan.maxAmountToBorrow = IHfCToken(vars.cTokenBorrow).getCash();\n            uint borrowCap = vars.comptroller.borrowCaps(vars.cTokenBorrow);\n            if (borrowCap != 0) {\n              uint totalBorrows = IHfCToken(vars.cTokenBorrow).totalBorrows();\n              if (totalBorrows > borrowCap) {\n                plan.maxAmountToBorrow = 0;\n              } else {\n                if (totalBorrows + plan.maxAmountToBorrow > borrowCap) {\n                  plan.maxAmountToBorrow = borrowCap - totalBorrows;\n                }\n              }\n            }\n\n            // it seems that supply is not limited in HundredFinance protocol\n            plan.maxAmountToSupply = type(uint).max; // unlimited; fix validation below after changing this value\n\n            if (/* plan.maxAmountToSupply != 0 && */ plan.maxAmountToBorrow != 0) {\n              plan.converter = converter;\n\n              //-------------------------------- Prices and health factor\n              vars.priceOracle = IHfPriceOracle(vars.comptroller.oracle());\n\n              AppDataTypes.PricesAndDecimals memory pd;\n              pd.rc10powDec = 10**IERC20Metadata(p_.collateralAsset).decimals();\n              pd.rb10powDec = 10**IERC20Metadata(p_.borrowAsset).decimals();\n              pd.priceCollateral = HfAprLib.getPrice(vars.priceOracle, vars.cTokenCollateral) * pd.rc10powDec;\n              pd.priceBorrow = HfAprLib.getPrice(vars.priceOracle, vars.cTokenBorrow) * pd.rb10powDec;\n              // ltv and liquidation threshold are exactly the same in HundredFinance\n              // so, there is no min health factor, we can directly use healthFactor2_ in calculations below\n\n              //------------------------------- Calculate collateralAmount and amountToBorrow\n              // we assume that liquidationThreshold18 == ltv18 in this protocol, so the minimum health factor is 1\n              vars.entryKind = EntryKinds.getEntryKind(p_.entryData);\n              if (vars.entryKind == EntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\n                plan.collateralAmount = p_.amountIn;\n                plan.amountToBorrow = EntryKinds.exactCollateralInForMaxBorrowOut(\n                  p_.amountIn,\n                  uint(healthFactor2_) * 10**16,\n                  plan.liquidationThreshold18,\n                  pd,\n                  true // prices have decimals 36\n                );\n              } else if (vars.entryKind == EntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\n                (plan.collateralAmount, plan.amountToBorrow) = EntryKinds.exactProportion(\n                  p_.amountIn,\n                  uint(healthFactor2_) * 10**16,\n                  plan.liquidationThreshold18,\n                  pd,\n                  p_.entryData,\n                  true // prices have decimals 36\n                );\n              } else if (vars.entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2) {\n                plan.amountToBorrow = p_.amountIn;\n                plan.collateralAmount = EntryKinds.exactBorrowOutForMinCollateralIn(\n                  p_.amountIn,\n                  uint(healthFactor2_) * 10**16,\n                  plan.liquidationThreshold18,\n                  pd,\n                  true // prices have decimals 36\n                );\n              }\n\n              //------------------------------- Validate the borrow\n              if (plan.amountToBorrow == 0 || plan.collateralAmount == 0) {\n                plan.converter = address(0);\n              } else {\n                // reduce collateral amount and borrow amount proportionally to fit available limits\n                // we don't need to check \"plan.collateralAmount > plan.maxAmountToSupply\" as in DForce\n                // because maxAmountToSupply is always equal to type(uint).max\n                if (plan.amountToBorrow > plan.maxAmountToBorrow) {\n                  plan.collateralAmount = plan.collateralAmount * plan.maxAmountToBorrow / plan.amountToBorrow;\n                  plan.amountToBorrow = plan.maxAmountToBorrow;\n                }\n\n              //------------------------------- values for APR\n                (plan.borrowCost36,\n                 plan.supplyIncomeInBorrowAsset36\n                ) = HfAprLib.getRawCostAndIncomes(\n                  HfAprLib.getCore(vars.cTokenCollateral, vars.cTokenBorrow),\n                  plan.collateralAmount,\n                  p_.countBlocks,\n                  plan.amountToBorrow,\n                  pd\n                );\n\n                plan.amountCollateralInBorrowAsset36 =\n                  plan.collateralAmount * (10**36 * pd.priceCollateral / pd.priceBorrow)\n                  / pd.rc10powDec;\n              }\n            } // else plan.maxAmountToBorrow = 0\n          } // else ltv is zero\n        } // else borrow token is not active\n      } // else collateral token is not active\n    }\n\n    if (plan.converter == address(0)) {\n      AppDataTypes.ConversionPlan memory planNotFound;\n      return planNotFound;\n    } else {\n      return plan;\n    }\n  }\n\n  //-----------------------------------------------------\n  ///  Calculate borrow rate after borrowing in advance\n  //-----------------------------------------------------\n\n  /// @notice Estimate value of variable borrow rate after borrowing {amountToBorrow_}\n  function getBorrowRateAfterBorrow(address borrowAsset_, uint amountToBorrow_) external view returns (uint) {\n    address borrowCToken = activeAssets[borrowAsset_];\n    return HfAprLib.getEstimatedBorrowRate(\n      IHfInterestRateModel(IHfCToken(borrowCToken).interestRateModel()),\n      IHfCToken(borrowCToken),\n      amountToBorrow_\n    );\n  }\n\n  //-----------------------------------------------------\n  ///                    Utils\n  //-----------------------------------------------------\n\n  /// @notice Check if the c-tokens are active and return LTV and liquidityThreshold values for the borrow\n  function getMarketsInfo(address cTokenCollateral_, address cTokenBorrow_) public view returns (\n    uint ltv18,\n    uint liquidityThreshold18\n  ) {\n    IHfComptroller comptrollerLocal = comptroller;\n    if (\n      !comptroller.borrowGuardianPaused(cTokenBorrow_) // borrowing is not paused\n      && !comptroller.mintGuardianPaused(cTokenCollateral_) // minting is not paused\n    ) {\n      (bool isListed, uint256 collateralFactorMantissa,) = comptrollerLocal.markets(cTokenBorrow_);\n      if (isListed) {\n        ltv18 = collateralFactorMantissa;\n        (isListed, collateralFactorMantissa,) = comptrollerLocal.markets(cTokenCollateral_);\n        if (isListed) {\n          liquidityThreshold18 = collateralFactorMantissa;\n        } else {\n          ltv18 = 0; // not efficient, but it's error case\n        }\n      }\n    }\n\n    return (ltv18, liquidityThreshold18);\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/protocols/hundred-finance/HfPoolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../../openzeppelin/SafeERC20.sol\";\nimport \"../../openzeppelin/IERC20.sol\";\nimport \"../../openzeppelin/Initializable.sol\";\nimport \"../../openzeppelin/IERC20Metadata.sol\";\nimport \"../../libs/AppErrors.sol\";\nimport \"../../libs/AppUtils.sol\";\nimport \"../../interfaces/IDebtMonitor.sol\";\nimport \"../../interfaces/IPoolAdapter.sol\";\nimport \"../../interfaces/IConverterController.sol\";\nimport \"../../interfaces/IPoolAdapterInitializerWithAP.sol\";\nimport \"../../interfaces/ITokenAddressProvider.sol\";\nimport \"../../integrations/hundred-finance/IHfComptroller.sol\";\nimport \"../../integrations/hundred-finance/IHfCToken.sol\";\nimport \"../../integrations/hundred-finance/IHfPriceOracle.sol\";\nimport \"../../integrations/hundred-finance/IHfHMatic.sol\";\nimport \"../../integrations/IWmatic.sol\";\n\n/// @notice Implementation of IPoolAdapter for HundredFinance-protocol, see https://docs.hundred.finance/\n/// @dev Instances of this contract are created using proxy-minimal pattern, so no constructor\ncontract HfPoolAdapter is IPoolAdapter, IPoolAdapterInitializerWithAP, Initializable {\n  using SafeERC20 for IERC20;\n\n  //-----------------------------------------------------\n  ///    Data types\n  //-----------------------------------------------------\n\n  /// @notice To avoid stack too deep\n  struct LocalRepayVars {\n    uint error;\n    uint healthFactor18;\n    address assetBorrow;\n    address assetCollateral;\n    address cTokenBorrow;\n    address cTokenCollateral;\n  }\n  //-----------------------------------------------------\n  ///    Constants and variables\n  //-----------------------------------------------------\n  address private constant WMATIC = address(0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270);\n  /// @notice Max allowed value of (sumCollateralSafe - sumBorrowPlusEffects) / liquidity, decimals 18\n  uint private constant MAX_DIVISION18 = 1e10;\n\n  address public collateralAsset;\n  address public borrowAsset;\n  address public collateralCToken;\n  address public borrowCToken;\n  address public user;\n\n  IConverterController public controller;\n  IHfComptroller private _comptroller;\n\n  /// @notice Address of original PoolAdapter contract that was cloned to make the instance of the pool adapter\n  address public originConverter;\n\n  /// @notice Total amount of all supplied and withdrawn amounts of collateral in collateral tokens\n  uint public collateralTokensBalance;\n\n  //-----------------------------------------------------\n  ///                Events\n  //-----------------------------------------------------\n  event OnInitialized(\n    address controller,\n    address cTokenAddressProvider,\n    address comptroller,\n    address user,\n    address collateralAsset,\n    address borrowAsset,\n    address originConverter\n  );\n  event OnBorrow(uint collateralAmount, uint borrowAmount, address receiver, uint resultHealthFactor18);\n  event OnBorrowToRebalance(uint borrowAmount, address receiver, uint resultHealthFactor18);\n  event OnRepay(uint amountToRepay, address receiver, bool closePosition, uint resultHealthFactor18);\n  event OnRepayToRebalance(uint amount, bool isCollateral, uint resultHealthFactor18);\n\n  //-----------------------------------------------------\n  ///                Initialization\n  //-----------------------------------------------------\n\n  function initialize(\n    address controller_,\n    address cTokenAddressProvider_,\n    address comptroller_,\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    address originConverter_\n  ) override external\n    // Borrow Manager creates a pool adapter using minimal proxy pattern, adds it the the set of known pool adapters\n    // and initializes it immediately. We should ensure only that the re-initialization is not possible\n  initializer\n  {\n    require(\n      controller_ != address(0)\n      && comptroller_ != address(0)\n      && user_ != address(0)\n      && collateralAsset_ != address(0)\n      && borrowAsset_ != address(0)\n      && cTokenAddressProvider_ != address(0)\n      && originConverter_ != address(0),\n      AppErrors.ZERO_ADDRESS\n    );\n\n    controller = IConverterController(controller_);\n    user = user_;\n    collateralAsset = collateralAsset_;\n    borrowAsset = borrowAsset_;\n    originConverter = originConverter_;\n\n    (address cTokenCollateral,\n      address cTokenBorrow\n    ) = ITokenAddressProvider(cTokenAddressProvider_).getCTokenByUnderlying(collateralAsset_, borrowAsset_);\n\n    require(cTokenCollateral != address(0), AppErrors.C_TOKEN_NOT_FOUND);\n    require(cTokenBorrow != address(0), AppErrors.C_TOKEN_NOT_FOUND);\n\n    collateralCToken = cTokenCollateral;\n    borrowCToken = cTokenBorrow;\n    _comptroller = IHfComptroller(comptroller_);\n\n    // The pool adapter doesn't keep assets on its balance, so it's safe to use infinity approve\n    // All approves replaced by infinity-approve were commented in the code below\n    IERC20(collateralAsset_).safeApprove(cTokenCollateral, 2 ** 255); // 2*255 is more gas-efficient than type(uint).max\n    IERC20(borrowAsset_).safeApprove(cTokenBorrow, 2 ** 255); // 2*255 is more gas-efficient than type(uint).max\n\n    emit OnInitialized(controller_, cTokenAddressProvider_, comptroller_, user_, collateralAsset_, borrowAsset_, originConverter_);\n  }\n\n  //-----------------------------------------------------\n  ///                 Restrictions\n  //-----------------------------------------------------\n\n  /// @notice Ensure that the caller is TetuConverter\n  function _onlyTetuConverter(IConverterController controller_) internal view {\n    require(controller_.tetuConverter() == msg.sender, AppErrors.TETU_CONVERTER_ONLY);\n  }\n\n  //-----------------------------------------------------\n  ///                 Borrow logic\n  //-----------------------------------------------------\n  function updateStatus() external override {\n    // Update borrowBalance to actual value\n    _onlyTetuConverter(controller);\n    IHfCToken(borrowCToken).borrowBalanceCurrent(address(this));\n    IHfCToken(collateralCToken).exchangeRateCurrent();\n  }\n\n  /// @notice Supply collateral to the pool and borrow specified amount\n  /// @dev No re-balancing here; Collateral amount must be approved to the pool adapter before the call of this function\n  /// @param collateralAmount_ Amount of collateral, must be approved to the pool adapter before the call of borrow()\n  /// @param borrowAmount_ Amount that should be borrowed in result\n  /// @param receiver_ Receiver of the borrowed amount\n  /// @return Result borrowed amount sent to the {receiver_}\n  function borrow(\n    uint collateralAmount_,\n    uint borrowAmount_,\n    address receiver_\n  ) external override returns (uint) {\n    IConverterController c = controller;\n    _onlyTetuConverter(c);\n\n    uint error;\n    IHfComptroller comptroller = _comptroller;\n\n    address cTokenCollateral = collateralCToken;\n    address cTokenBorrow = borrowCToken;\n    address assetCollateral = collateralAsset;\n    address assetBorrow = borrowAsset;\n\n    IERC20(assetCollateral).safeTransferFrom(msg.sender, address(this), collateralAmount_);\n\n    // enter markets (repeat entering is not a problem)\n    address[] memory markets = new address[](2);\n    markets[0] = cTokenCollateral;\n    markets[1] = cTokenBorrow;\n    comptroller.enterMarkets(markets);\n\n    // supply collateral\n    uint tokenBalanceBeforeBorrow = _supply(cTokenCollateral, assetCollateral, collateralAmount_);\n\n    // make borrow\n    {\n      uint balanceBorrowAsset0 = _getBalance(assetBorrow);\n      error = IHfCToken(cTokenBorrow).borrow(borrowAmount_);\n      require(error == 0, AppErrors.BORROW_FAILED);\n\n      // ensure that we have received required borrowed amount, send the amount to the receiver\n      if (_isMatic(assetBorrow)) {\n        IWmatic(WMATIC).deposit{value: borrowAmount_}();\n      }\n      require(\n        borrowAmount_ + balanceBorrowAsset0 == IERC20(assetBorrow).balanceOf(address(this)),\n        AppErrors.WRONG_BORROWED_BALANCE\n      );\n      IERC20(assetBorrow).safeTransfer(receiver_, borrowAmount_);\n    }\n\n    // register the borrow in DebtMonitor\n    IDebtMonitor(c.debtMonitor()).onOpenPosition();\n\n    // ensure that current health factor is greater than min allowed\n    (uint healthFactor, uint tokenBalanceAfterBorrow) = _validateHealthStatusAfterBorrow(c, comptroller, cTokenCollateral, cTokenBorrow);\n    require(tokenBalanceAfterBorrow >= tokenBalanceBeforeBorrow, AppErrors.WEIRD_OVERFLOW);\n    collateralTokensBalance += tokenBalanceAfterBorrow - tokenBalanceBeforeBorrow;\n\n    emit OnBorrow(collateralAmount_, borrowAmount_, receiver_, healthFactor);\n    return borrowAmount_;\n  }\n\n  /// @notice Supply collateral to Hundred finance market\n  /// @return Collateral token balance before supply\n  function _supply(\n    address cTokenCollateral_,\n    address assetCollateral_,\n    uint collateralAmount_\n  ) internal returns (uint) {\n    uint tokenBalanceBefore = IERC20(cTokenCollateral_).balanceOf(address(this));\n\n    // the amount is received through safeTransferFrom before calling of _supply()\n    // so we don't need following additional check:\n    //    require(tokenBalanceBefore >= collateralAmount_, AppErrors.MINT_FAILED);\n\n    if (_isMatic(assetCollateral_)) {\n      IWmatic(WMATIC).withdraw(collateralAmount_);\n      IHfHMatic(payable(cTokenCollateral_)).mint{value: collateralAmount_}();\n    } else {\n      // replaced by infinity approve: IERC20(assetCollateral_).approve(cTokenCollateral_, collateralAmount_);\n      uint error = IHfCToken(cTokenCollateral_).mint(collateralAmount_);\n      require(error == 0, AppErrors.MINT_FAILED);\n    }\n    return tokenBalanceBefore;\n  }\n\n  /// @return (Health factor, decimal 18; collateral-token-balance)\n  function _validateHealthStatusAfterBorrow(\n    IConverterController controller_,\n    IHfComptroller comptroller_,\n    address cTokenCollateral_,\n    address cTokenBorrow_\n  ) internal view returns (uint, uint) {\n    (uint tokenBalance,,\n      uint collateralBase,\n      uint borrowBase,,\n    ) = _getStatus(cTokenCollateral_, cTokenBorrow_);\n\n    (uint sumCollateralSafe, uint healthFactor18) = _getHealthFactor(\n      cTokenCollateral_,\n      collateralBase,\n      borrowBase\n    );\n\n    (uint256 dError, uint liquidity,) = comptroller_.getAccountLiquidity(address(this));\n    require(dError == 0, AppErrors.CTOKEN_GET_ACCOUNT_LIQUIDITY_FAILED);\n\n    require(\n      sumCollateralSafe > borrowBase\n      && borrowBase != 0\n      // here we should have: sumCollateralSafe - sumBorrowPlusEffects == liquidity\n      // but it seems like round-error can happen, we can check only sumCollateralSafe - sumBorrowPlusEffects ~ liquidity\n      // let's ensure that liquidity has a reasonable value\n      && AppUtils.approxEqual(liquidity + borrowBase, sumCollateralSafe, MAX_DIVISION18),\n      AppErrors.INCORRECT_RESULT_LIQUIDITY\n    );\n\n    _validateHealthFactor(controller_, healthFactor18);\n    return (healthFactor18, tokenBalance);\n  }\n\n  /// @notice Borrow additional amount {borrowAmount_} using exist collateral and send it to {receiver_}\n  /// @dev Re-balance: too big health factor => target health factor\n  /// @return resultHealthFactor18 Result health factor after borrow\n  /// @return borrowedAmountOut Exact amount sent to the borrower\n  function borrowToRebalance(\n    uint borrowAmount_,\n    address receiver_\n  ) external override returns (\n    uint resultHealthFactor18,\n    uint borrowedAmountOut\n  ) {\n    IConverterController c = controller;\n    _onlyTetuConverter(c);\n\n    uint error;\n    IHfComptroller comptroller = _comptroller;\n\n    address cTokenBorrow = borrowCToken;\n    address assetBorrow = borrowAsset;\n\n    // ensure that the position is opened\n    require(IDebtMonitor(c.debtMonitor()).isPositionOpened(), AppErrors.BORROW_POSITION_IS_NOT_REGISTERED);\n\n    // make borrow\n    uint balanceBorrowAsset0 = _getBalance(assetBorrow);\n    error = IHfCToken(cTokenBorrow).borrow(borrowAmount_);\n    require(error == 0, AppErrors.BORROW_FAILED);\n\n    // ensure that we have received required borrowed amount, send the amount to the receiver\n    if (_isMatic(assetBorrow)) {\n      IWmatic(WMATIC).deposit{value: borrowAmount_}();\n    }\n    // we assume here, that syncBalance(true) is called before the call of this function\n    require(\n      borrowAmount_ + balanceBorrowAsset0 == IERC20(assetBorrow).balanceOf(address(this)),\n      AppErrors.WRONG_BORROWED_BALANCE\n    );\n    IERC20(assetBorrow).safeTransfer(receiver_, borrowAmount_);\n\n    // ensure that current health factor is greater than min allowed\n    (resultHealthFactor18,) = _validateHealthStatusAfterBorrow(c, comptroller, collateralCToken, cTokenBorrow);\n\n    emit OnBorrowToRebalance(borrowAmount_, receiver_, resultHealthFactor18);\n    return (resultHealthFactor18, borrowAmount_);\n  }\n\n  //-----------------------------------------------------\n  ///                 Repay logic\n  //-----------------------------------------------------\n\n  /// @notice Repay borrowed amount, return collateral to the user\n  /// @param amountToRepay_ Exact amount of borrow asset that should be repaid\n  ///                       The amount should be approved for the pool adapter before the call of repay()\n  /// @param closePosition_ true to pay full borrowed amount\n  /// @param receiver_ Receiver of withdrawn collateral\n  /// @return Amount of collateral asset sent to the {receiver_}\n  function repay(\n    uint amountToRepay_,\n    address receiver_,\n    bool closePosition_\n  ) external override returns (uint) {\n    IConverterController c = controller;\n    _onlyTetuConverter(c);\n\n    LocalRepayVars memory vars;\n    vars.assetBorrow = borrowAsset;\n    vars.assetCollateral = collateralAsset;\n    vars.cTokenBorrow = borrowCToken;\n    vars.cTokenCollateral = collateralCToken;\n\n    IERC20(vars.assetBorrow).safeTransferFrom(msg.sender, address(this), amountToRepay_);\n\n    // Update borrowBalance to actual value, we must do it before calculation of collateral to withdraw\n    IHfCToken(vars.cTokenBorrow).borrowBalanceCurrent(address(this));\n    // how much collateral we are going to return\n    (uint collateralTokensToWithdraw, uint tokenBalanceBefore) = _getCollateralTokensToRedeem(\n      vars.cTokenCollateral,\n      vars.cTokenBorrow,\n      closePosition_,\n      amountToRepay_\n    );\n\n    // transfer borrow amount back to the pool\n    if (_isMatic(vars.assetBorrow)) {\n      IWmatic(WMATIC).withdraw(amountToRepay_);\n      IHfHMatic(payable(vars.cTokenBorrow)).repayBorrow{value: amountToRepay_}();\n    } else {\n      // replaced by infinity approve: IERC20(assetBorrow).approve(cTokenBorrow, amountToRepay_);\n      vars.error = IHfCToken(vars.cTokenBorrow).repayBorrow(amountToRepay_);\n      require(vars.error == 0, AppErrors.REPAY_FAILED);\n    }\n\n    // withdraw the collateral\n    uint balanceCollateralAssetBeforeRedeem = _getBalance(vars.assetCollateral);\n    vars.error = IHfCToken(vars.cTokenCollateral).redeem(collateralTokensToWithdraw);\n    require(vars.error == 0, AppErrors.REDEEM_FAILED);\n\n    // transfer collateral back to the user\n    uint balanceCollateralAssetAfterRedeem = _getBalance(vars.assetCollateral);\n    require(balanceCollateralAssetAfterRedeem >= balanceCollateralAssetBeforeRedeem, AppErrors.WEIRD_OVERFLOW);\n    uint collateralAmountToReturn = balanceCollateralAssetAfterRedeem - balanceCollateralAssetBeforeRedeem;\n    if (_isMatic(vars.assetCollateral)) {\n      IWmatic(WMATIC).deposit{value: collateralAmountToReturn}();\n    }\n    IERC20(vars.assetCollateral).safeTransfer(receiver_, collateralAmountToReturn);\n\n    // validate result status\n    (uint tokenBalanceAfter,\n      uint borrowBalance,\n      uint collateralBase,\n      uint borrowBase,,\n    ) = _getStatus(vars.cTokenCollateral, vars.cTokenBorrow);\n\n    if (tokenBalanceAfter == 0 && borrowBalance == 0) {\n      IDebtMonitor(c.debtMonitor()).onClosePosition();\n      // We don't exit the market to avoid additional gas consumption\n    } else {\n      require(!closePosition_, AppErrors.CLOSE_POSITION_FAILED);\n      (, vars.healthFactor18) = _getHealthFactor(vars.cTokenCollateral, collateralBase, borrowBase);\n      _validateHealthFactor(c, vars.healthFactor18);\n    }\n\n    require(\n      tokenBalanceBefore >= tokenBalanceAfter\n      && collateralTokensBalance >= tokenBalanceBefore - tokenBalanceAfter,\n      AppErrors.WEIRD_OVERFLOW\n    );\n    collateralTokensBalance -= tokenBalanceBefore - tokenBalanceAfter;\n\n    emit OnRepay(amountToRepay_, receiver_, closePosition_, vars.healthFactor18);\n    return collateralAmountToReturn;\n  }\n\n  /// @return Amount of collateral tokens to redeem, full balance of collateral tokens\n  function _getCollateralTokensToRedeem(\n    address cTokenCollateral_,\n    address cTokenBorrow_,\n    bool closePosition_,\n    uint amountToRepay_\n  ) internal view returns (uint, uint) {\n    (uint error, uint tokenBalance,,) = IHfCToken(cTokenCollateral_).getAccountSnapshot(address(this));\n    require(error == 0, AppErrors.CTOKEN_GET_ACCOUNT_SNAPSHOT_FAILED);\n\n    (uint error2,, uint borrowBalance,) = IHfCToken(cTokenBorrow_).getAccountSnapshot(address(this));\n    require(error2 == 0, AppErrors.CTOKEN_GET_ACCOUNT_SNAPSHOT_FAILED);\n    require(borrowBalance != 0, AppErrors.ZERO_BALANCE);\n    if (closePosition_) {\n      require(borrowBalance <= amountToRepay_, AppErrors.CLOSE_POSITION_PARTIAL);\n      return (tokenBalance, tokenBalance);\n    } else {\n      require(amountToRepay_ <= borrowBalance, AppErrors.WRONG_BORROWED_BALANCE);\n    }\n    return (tokenBalance * amountToRepay_ / borrowBalance, tokenBalance);\n  }\n\n  /// @notice Repay with rebalancing. Send amount of collateral/borrow asset to the pool adapter\n  ///         to recover the health factor to target state.\n  /// @dev It's not allowed to close position here (pay full debt) because no collateral will be returned.\n  /// @param amount_ Exact amount of asset that is transferred to the balance of the pool adapter.\n  ///                It can be amount of collateral asset or borrow asset depended on {isCollateral_}\n  ///                It must be stronger less then total borrow debt.\n  ///                The amount should be approved for the pool adapter before the call.\n  /// @param isCollateral_ true/false indicates that {amount_} is the amount of collateral/borrow asset\n  /// @return resultHealthFactor18 Result health factor after repay, decimals 18\n  function repayToRebalance(\n    uint amount_,\n    bool isCollateral_\n  ) external override returns (\n    uint resultHealthFactor18\n  ) {\n    IConverterController c = controller;\n    _onlyTetuConverter(c);\n\n    uint error;\n    address cTokenBorrow = borrowCToken;\n    address cTokenCollateral = collateralCToken;\n    uint tokenBalanceBefore;\n\n    // ensure that the position is opened\n    require(IDebtMonitor(c.debtMonitor()).isPositionOpened(), AppErrors.BORROW_POSITION_IS_NOT_REGISTERED);\n\n    if (isCollateral_) {\n      address assetCollateral = collateralAsset;\n      IERC20(assetCollateral).safeTransferFrom(msg.sender, address(this), amount_);\n      tokenBalanceBefore = _supply(cTokenCollateral, assetCollateral, amount_);\n    } else {\n      uint borrowBalance;\n      address assetBorrow = borrowAsset;\n      // ensure, that amount to repay is less then the total debt\n      (tokenBalanceBefore, borrowBalance,,,,) = _getStatus(cTokenCollateral, cTokenBorrow);\n      require(borrowBalance != 0 && amount_ < borrowBalance, AppErrors.REPAY_TO_REBALANCE_NOT_ALLOWED);\n\n      IERC20(assetBorrow).safeTransferFrom(msg.sender, address(this), amount_);\n      // the amount is received through safeTransferFrom so we don't need following additional check:\n      //    require(IERC20(assetBorrow).balanceOf(address(this)) >= amount_, AppErrors.MINT_FAILED);\n\n      // transfer borrow amount back to the pool\n      if (_isMatic(assetBorrow)) {\n        IWmatic(WMATIC).withdraw(amount_);\n        IHfHMatic(payable(cTokenBorrow)).repayBorrow{value: amount_}();\n      } else {\n        // replaced by infinity approve: IERC20(assetBorrow).approve(cTokenBorrow, amount_);\n        error = IHfCToken(cTokenBorrow).repayBorrow(amount_);\n        require(error == 0, AppErrors.REPAY_FAILED);\n      }\n    }\n\n    // validate result status\n    (uint tokenBalanceAfter,,\n      uint collateralBase,\n      uint borrowBase,,\n    ) = _getStatus(cTokenCollateral, cTokenBorrow);\n\n    (, uint healthFactor18) = _getHealthFactor(cTokenCollateral, collateralBase, borrowBase);\n    _validateHealthFactor(c, healthFactor18);\n\n    require(tokenBalanceAfter >= tokenBalanceBefore, AppErrors.WEIRD_OVERFLOW);\n    collateralTokensBalance += tokenBalanceAfter - tokenBalanceBefore;\n\n    emit OnRepayToRebalance(amount_, isCollateral_, healthFactor18);\n    return healthFactor18;\n  }\n\n  /// @notice If we paid {amountToRepay_}, how much collateral would we receive?\n  function getCollateralAmountToReturn(uint amountToRepay_, bool closePosition_) external view override returns (uint) {\n    address cTokenCollateral = collateralCToken;\n\n    (uint error,,, uint cExchangeRateMantissa) = IHfCToken(cTokenCollateral).getAccountSnapshot(address(this));\n    require(error == 0, AppErrors.CTOKEN_GET_ACCOUNT_SNAPSHOT_FAILED);\n\n    (uint tokensToReturn,) = _getCollateralTokensToRedeem(cTokenCollateral, borrowCToken, closePosition_, amountToRepay_);\n    return tokensToReturn * cExchangeRateMantissa / 10 ** 18;\n  }\n  //-----------------------------------------------------\n  ///                 Rewards\n  //-----------------------------------------------------\n  function claimRewards(address receiver_) external pure override returns (\n    address rewardToken,\n    uint amount\n  ) {\n    //nothing to do, HundredFinance doesn't have rewards on polygon anymore\n    receiver_; // hide warning\n    return (rewardToken, amount);\n  }\n\n  //-----------------------------------------------------\n  ///         View current status\n  //-----------------------------------------------------\n\n  /// @inheritdoc IPoolAdapter\n  function getConfig() external view override returns (\n    address origin,\n    address outUser,\n    address outCollateralAsset,\n    address outBorrowAsset\n  ) {\n    return (originConverter, user, collateralAsset, borrowAsset);\n  }\n\n  /// @inheritdoc IPoolAdapter\n  function getStatus() external view override returns (\n    uint collateralAmount,\n    uint amountToPay,\n    uint healthFactor18,\n    bool opened,\n    uint collateralAmountLiquidated,\n    bool debtGapRequired\n  ) {\n    address cTokenBorrow = borrowCToken;\n    address cTokenCollateral = collateralCToken;\n    (uint collateralTokens,\n      uint borrowBalance,\n      uint collateralBase,\n      uint borrowBase,\n      uint collateralPrice,\n      uint collateralAmountLiquidatedBase\n    ) = _getStatus(cTokenCollateral, cTokenBorrow);\n\n    (, healthFactor18) = _getHealthFactor(cTokenCollateral, collateralBase, borrowBase);\n\n    return (\n    // Total amount of provided collateral [collateral asset]\n      collateralBase * 10 ** 18 / collateralPrice,\n    // Total amount of borrowed debt in [borrow asset]. 0 - for closed borrow positions.\n      borrowBalance,\n    // Current health factor, decimals 18\n      healthFactor18,\n      collateralTokens != 0 || borrowBalance != 0,\n    // Amount of liquidated collateral == amount of lost\n      collateralAmountLiquidatedBase == 0\n        ? 0\n        : collateralAmountLiquidatedBase * 10 ** IERC20Metadata(collateralAsset).decimals() / 10 ** 18,\n      false\n    );\n  }\n\n  /// @return tokenBalanceOut Count of collateral tokens on balance\n  /// @return borrowBalanceOut Borrow amount [borrow asset units]\n  /// @return collateralBaseOut Total collateral in base currency\n  /// @return borrowBaseOut Total borrow amount in base currency\n  function _getStatus(address cTokenCollateral, address cTokenBorrow) internal view returns (\n    uint tokenBalanceOut,\n    uint borrowBalanceOut,\n    uint collateralBaseOut,\n    uint borrowBaseOut,\n    uint outPriceCollateral,\n    uint outCollateralAmountLiquidatedBase\n  ) {\n    // we need to repeat Comptroller.getHypotheticalAccountLiquidityInternal\n    // but for single collateral and single borrow only\n    // Collateral factor = CF, exchange rate = ER, price = P\n    // Liquidity = sumCollateral - sumBorrowPlusEffects\n    // where sumCollateral = ERMP * Collateral::TokenBalance\n    //       sumBorrowPlusEffects = Borrow::P * Borrow::BorrowBalance\n    //       ERMP = Collateral::ER * Collateral::P\n    // TokenBalance and BorrowBalance can be received through Token.getAccountSnapshot\n    // Liquidity - through Comptroller.getAccountLiquidity\n    //\n    // Health factor = (Collateral::CF * sumCollateral) / sumBorrowPlusEffects\n    //               = (Liquidity + sumBorrowPlusEffects) / sumBorrowPlusEffects\n\n    uint cExchangeRateMantissa;\n    uint error;\n\n    (error, tokenBalanceOut,, cExchangeRateMantissa) = IHfCToken(cTokenCollateral)\n    .getAccountSnapshot(address(this));\n    require(error == 0, AppErrors.CTOKEN_GET_ACCOUNT_SNAPSHOT_FAILED);\n\n    (error,, borrowBalanceOut,) = IHfCToken(cTokenBorrow).getAccountSnapshot(address(this));\n    require(error == 0, AppErrors.CTOKEN_GET_ACCOUNT_SNAPSHOT_FAILED);\n\n    IHfPriceOracle priceOracle = IHfPriceOracle(_comptroller.oracle());\n    uint priceCollateral = priceOracle.getUnderlyingPrice(cTokenCollateral);\n\n    collateralBaseOut = (priceCollateral * cExchangeRateMantissa / 10 ** 18) * tokenBalanceOut / 10 ** 18;\n    borrowBaseOut = priceOracle.getUnderlyingPrice(cTokenBorrow) * borrowBalanceOut / 10 ** 18;\n\n    {\n      uint collateralTokensBalanceLocal = collateralTokensBalance;\n      outCollateralAmountLiquidatedBase = tokenBalanceOut > collateralTokensBalanceLocal\n        ? 0\n        : (collateralTokensBalanceLocal - tokenBalanceOut) * (priceCollateral * cExchangeRateMantissa / 10 ** 18) / 10 ** 18;\n    }\n\n    return (\n      tokenBalanceOut,\n      borrowBalanceOut,\n      collateralBaseOut,\n      borrowBaseOut,\n      priceCollateral,\n      outCollateralAmountLiquidatedBase\n    );\n  }\n\n  function getConversionKind() external pure override returns (AppDataTypes.ConversionKind) {\n    return AppDataTypes.ConversionKind.BORROW_2;\n  }\n\n//  /// @notice Compute current cost of the money\n//  function getAPR18() external view override returns (int) {\n//    return int(IHfCToken(borrowCToken).borrowRatePerBlock() * controller.blocksPerDay() * 365 * 100);\n//  }\n\n  //-----------------------------------------------------\n  ///                   Utils\n  //-----------------------------------------------------\n  function _getHealthFactor(address cTokenCollateral_, uint sumCollateral_, uint sumBorrowPlusEffects_)\n  internal view returns (\n    uint sumCollateralSafe,\n    uint healthFactor18\n  ) {\n    (,uint collateralFactor,) = _comptroller.markets(cTokenCollateral_);\n\n    sumCollateralSafe = collateralFactor * sumCollateral_ / 10 ** 18;\n    healthFactor18 = sumBorrowPlusEffects_ == 0\n      ? type(uint).max\n      : sumCollateralSafe * 10 ** 18 / sumBorrowPlusEffects_;\n\n    return (sumCollateralSafe, healthFactor18);\n  }\n\n  function _validateHealthFactor(IConverterController controller_, uint hf18) internal view {\n    require(hf18 > uint(controller_.minHealthFactor2()) * 10 ** (18 - 2), AppErrors.WRONG_HEALTH_FACTOR);\n  }\n\n  //-----------------------------------------------------\n  ///                Native tokens\n  //-----------------------------------------------------\n\n  function _isMatic(address asset_) internal pure returns (bool) {\n    return asset_ == WMATIC;\n  }\n\n  function _getBalance(address asset) internal view returns (uint) {\n    return _isMatic(asset)\n      ? address(this).balance\n      : IERC20(asset).balanceOf(address(this));\n  }\n\n  receive() external payable {\n    // this is needed for the native token unwrapping\n    // no restrictions because this adpater is not used in production, it's for tests only\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/proxy/ControllableV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../libs/SlotsLib.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../interfaces/IConverterControllable.sol\";\nimport \"../interfaces/IConverterController.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract ControllableV3 is Initializable, IConverterControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"3.0.0\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) public onlyInitializing {\n    require(controller_ != address(0), AppErrors.ZERO_ADDRESS);\n    require(IConverterController(controller_).governance() != address(0), \"Zero governance\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address _value) public override view returns (bool) {\n    return _value == controller();\n  }\n  /// @dev Return true if given address is controller of tetu-contracts-v2 that is allowed to update proxy contracts\n  function isProxyUpdater(address _value) public override view returns (bool) {\n    return IConverterController(controller()).proxyUpdater() == _value;\n  }\n\n  /// @notice Return true if given address is setup as governance in ConverterController\n  function isGovernance(address _value) public override view returns (bool) {\n    return IConverterController(controller()).governance() == _value;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view returns (uint){\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view returns (address){\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return ConverterController address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/proxy/ProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"../interfaces/IConverterControllable.sol\";\nimport \"./UpgradeableProxy.sol\";\n\n/// @title EIP1967 Upgradable proxy implementation.\n/// @dev Only Controller has access and should implement time-lock for upgrade action.\n/// @author belbix\ncontract ProxyControlled is UpgradeableProxy, IProxyControlled {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant PROXY_CONTROLLED_VERSION = \"1.0.0\";\n\n  /// @dev Initialize proxy implementation. Need to call after deploy new proxy.\n  function initProxy(address _logic) external override {\n    //make sure that given logic is controllable and not inited\n    require(IConverterControllable(_logic).created() >= 0, \"Proxy: Wrong implementation\");\n    _init(_logic);\n  }\n\n  /// @notice Upgrade contract logic\n  /// @dev Upgrade allowed only for Controller of tetu-contracts-v2 and should be done only after time-lock period\n  /// @param _newImplementation Implementation address\n  function upgrade(address _newImplementation) external override {\n    require(IConverterControllable(address(this)).isProxyUpdater(msg.sender), \"Proxy: Forbidden\");\n    IConverterControllable(address(this)).increaseRevision(_implementation());\n    _upgradeTo(_newImplementation);\n    // the new contract must have the same ABI and you must have the power to change it again\n    require(IConverterControllable(address(this)).isProxyUpdater(msg.sender), \"Proxy: Wrong implementation\");\n  }\n\n  /// @notice Return current logic implementation\n  function implementation() external override view returns (address) {\n    return _implementation();\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Proxy.sol\";\nimport \"../openzeppelin/Address.sol\";\n\n/// @title OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/proxy/UpgradeableProxy.sol\n/// @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n///      implementation address that can be changed. This address is stored in storage in the location specified by\n///      https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n///      implementation behind the proxy.\n///      Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n///      {TransparentUpgradeableProxy}.\nabstract contract UpgradeableProxy is Proxy {\n\n  /// @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n  ///      If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n  ///      function call, and allows initializating the storage of the proxy like a Solidity constructor.\n  constructor() payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n  }\n\n  /// @dev Emitted when the implementation is upgraded.\n  event Upgraded(address indexed implementation);\n\n  ///@dev Storage slot with the address of the current implementation.\n  ///     This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n  ///     validated in the constructor.\n  bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /// @dev Post deploy initialisation for compatability with EIP-1167 factory\n  function _init(address _logic) internal {\n    require(_implementation() == address(0), \"Already inited\");\n    _setImplementation(_logic);\n  }\n\n  /// @dev Returns the current implementation address.\n  function _implementation() internal view virtual override returns (address impl) {\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /// @dev Upgrades the proxy to a new implementation.\n  ///      Emits an {Upgraded} event.\n  function _upgradeTo(address newImplementation) internal virtual {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /// @dev Stores a new address in the EIP1967 implementation slot.\n  function _setImplementation(address newImplementation) private {\n    require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/tests/dforce/DForcePriceOracleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"hardhat/console.sol\";\nimport \"../interfaces/IChangePriceForTests.sol\";\n\n\n/// @notice Replacement for the original DForce price oracle\ncontract DForcePriceOracleMock is IChangePriceForTests {\n  mapping(address => uint) public prices;\n\n  //-----------------------------------------------------//////////\n  ///                 IChangePriceForTests\n  //-----------------------------------------------------//////////\n\n  /// @notice Take exist price of the asset and multiple it on (multiplier100_/100)\n  function changePrice(address asset_, uint multiplier100_) external {\n    prices[asset_] = multiplier100_ * prices[asset_] / 100;\n    console.log(\"DForcePriceOracleMock changePrice\", asset_, prices[asset_], multiplier100_);\n  }\n\n  //-----------------------------------------------------//////////\n  ///    Same set of functions as in the original DForce oracle\n  //-----------------------------------------------------//////////\n\n  function setUnderlyingPrice(address iToken_, uint price_) external {\n    console.log(\"setUnderlyingPrice\", iToken_, price_);\n    prices[iToken_] = price_;\n  }\n\n  /**\n   * @notice Get the underlying price of a iToken asset\n     * @param iToken_ The iToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable.\n     */\n  function getUnderlyingPrice(address iToken_)\n  external\n  view\n  returns (uint256) {\n    console.log(\"getUnderlyingPrice\", iToken_, prices[iToken_]);\n    return prices[iToken_];\n  }\n\n  /**\n   * @notice Get the price of a underlying asset\n     * @param iToken_ The iToken to get the underlying price of\n     * @return The underlying asset price mantissa (scaled by 1e18).\n     *  Zero means the price is unavailable and whether the price is valid.\n     */\n  function getUnderlyingPriceAndStatus(address iToken_)\n  external\n  view\n  returns (uint256, bool) {\n    console.log(\"getUnderlyingPriceAndStatus\", iToken_, prices[iToken_]);\n    return (prices[iToken_], true);\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/tests/interfaces/IChangePriceForTests.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IChangePriceForTests {\n  /// @notice Take exist price of the asset and multiple it on (multiplier100_/100)\n  function changePrice(address asset_, uint multiplier100_) external;\n}"
    },
    "@tetu_io/tetu-converter/contracts/tests/keeper/KeeperCaller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/gelato/IResolver.sol\";\nimport \"hardhat/console.sol\";\nimport \"../../integrations/gelato/IOps.sol\";\n\ncontract KeeperCaller is IOps {\n  enum LastCallResults {\n    NOT_CALLED_0,\n    SUCCESS_1,\n    FAILED_2\n  }\n  address public keeperChecker;\n  address public keeperExecutor;\n  LastCallResults public lastCallResults;\n\n  function setupKeeper(\n    address keeperChecker_,\n    address keeperExecutor_\n  ) external {\n    keeperChecker = keeperChecker_;\n    keeperExecutor = keeperExecutor_;\n  }\n\n  function gelato() external view override returns (address payable) {\n    console.log(\"is gelato\", address(this));\n    return payable(address(this));\n  }\n\n  function taskTreasury() external view override returns (address) {\n    return address(this);\n  }\n\n  function callChecker() external {\n    console.log(\"KeeperCaller.callChecker\", address(keeperChecker));\n    (\n      bool canExecOut,\n      bytes memory execPayloadOut\n    ) = IResolver(keeperChecker).checker();\n    console.log(\"KeeperCaller.canExecOut\", canExecOut);\n\n    if (canExecOut) {\n      console.log(\"KeeperCaller.execute\", address(keeperExecutor));\n      (bool success,) = address(keeperExecutor).call(execPayloadOut);\n      console.log(\"KeeperCaller.execute success\", success);\n      lastCallResults = success\n        ? LastCallResults.SUCCESS_1\n        : LastCallResults.FAILED_2;\n    } else {\n      lastCallResults = LastCallResults.NOT_CALLED_0;\n    }\n  }\n}\n"
    },
    "contracts/integrations/algebra/AlgebraFeeConfiguration.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n// coefficients for sigmoids: α / (1 + e^( (β-x) / γ))\n// alpha1 + alpha2 + baseFee must be <= type(uint16).max\nstruct AlgebraFeeConfiguration {\n  uint16 alpha1; // max value of the first sigmoid\n  uint16 alpha2; // max value of the second sigmoid\n  uint32 beta1; // shift along the x-axis for the first sigmoid\n  uint32 beta2; // shift along the x-axis for the second sigmoid\n  uint16 gamma1; // horizontal stretch factor for the first sigmoid\n  uint16 gamma2; // horizontal stretch factor for the second sigmoid\n  uint16 baseFee; // minimum possible fee\n}\n"
    },
    "contracts/integrations/algebra/IAlgebraEternalFarming.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IncentiveKey.sol\";\n\ninterface IAlgebraEternalFarming {\n    /// @notice reward amounts can be outdated, actual amounts could be obtained via static call of `collectRewards` in FarmingCenter\n    function getRewardInfo(\n        IncentiveKey memory key,\n        uint256 tokenId\n    ) external view returns (uint256 reward, uint256 bonusReward);\n}"
    },
    "contracts/integrations/algebra/IAlgebraPool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IAlgebraPoolImmutables.sol';\nimport './pool/IAlgebraPoolState.sol';\nimport './pool/IAlgebraPoolDerivedState.sol';\nimport './pool/IAlgebraPoolActions.sol';\nimport './pool/IAlgebraPoolPermissionedActions.sol';\nimport './pool/IAlgebraPoolEvents.sol';\n\n/**\n * @title The interface for a Algebra Pool\n * @dev The pool interface is broken up into many smaller pieces.\n * Credit to Uniswap Labs under GPL-2.0-or-later license:\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\n */\ninterface IAlgebraPool is\nIAlgebraPoolImmutables,\nIAlgebraPoolState,\nIAlgebraPoolDerivedState,\nIAlgebraPoolActions,\nIAlgebraPoolPermissionedActions,\nIAlgebraPoolEvents\n{\n  // used only for combining interfaces\n}\n"
    },
    "contracts/integrations/algebra/IDataStorageOperator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\npragma abicoder v2;\n\nimport './AlgebraFeeConfiguration.sol';\n\n/// @title The interface for the DataStorageOperator\n/// @dev This contract stores timepoints and calculates adaptive fee and statistical averages\ninterface IDataStorageOperator {\n  /// @notice Emitted when the fee configuration is changed\n  /// @param feeConfig The structure with dynamic fee parameters\n  /// @dev See the AdaptiveFee library for more details\n  event FeeConfiguration(AlgebraFeeConfiguration feeConfig);\n\n  /// @notice Returns data belonging to a certain timepoint\n  /// @param index The index of timepoint in the array\n  /// @dev There is more convenient function to fetch a timepoint: getTimepoints(). Which requires not an index but seconds\n  /// @return initialized Whether the timepoint has been initialized and the values are safe to use\n  /// @return blockTimestamp The timestamp of the timepoint\n  /// @return tickCumulative The tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp\n  /// @return volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp\n  /// @return tick The tick at blockTimestamp\n  /// @return averageTick Time-weighted average tick\n  /// @return windowStartIndex Index of closest timepoint >= WINDOW seconds ago\n  function timepoints(\n    uint256 index\n  )\n    external\n    view\n    returns (\n      bool initialized,\n      uint32 blockTimestamp,\n      int56 tickCumulative,\n      uint88 volatilityCumulative,\n      int24 tick,\n      int24 averageTick,\n      uint16 windowStartIndex\n    );\n\n  /// @notice Initialize the dataStorage array by writing the first slot. Called once for the lifecycle of the timepoints array\n  /// @param time The time of the dataStorage initialization, via block.timestamp truncated to uint32\n  /// @param tick Initial tick\n  function initialize(uint32 time, int24 tick) external;\n\n  /// @dev Reverts if a timepoint at or before the desired timepoint timestamp does not exist.\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\n  /// If called with a timestamp falling between two timepoints, returns the counterfactual accumulator values\n  /// at exactly the timestamp between the two timepoints.\n  /// @param time The current block timestamp\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return a timepoint\n  /// @param tick The current tick\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\n  /// @return tickCumulative The cumulative tick since the pool was first initialized, as of `secondsAgo`\n  /// @return volatilityCumulative The cumulative volatility value since the pool was first initialized, as of `secondsAgo`\n  function getSingleTimepoint(\n    uint32 time,\n    uint32 secondsAgo,\n    int24 tick,\n    uint16 index\n  ) external view returns (int56 tickCumulative, uint112 volatilityCumulative);\n\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n  /// @dev Reverts if `secondsAgos` > oldest timepoint\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return a timepoint\n  /// @return tickCumulatives The cumulative tick since the pool was first initialized, as of each `secondsAgo`\n  /// @return volatilityCumulatives The cumulative volatility values since the pool was first initialized, as of each `secondsAgo`\n  function getTimepoints(uint32[] memory secondsAgos) external view returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives);\n\n  /// @notice Writes a dataStorage timepoint to the array\n  /// @dev Writable at most once per block. Index represents the most recently written element. index must be tracked externally.\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\n  /// @param blockTimestamp The timestamp of the new timepoint\n  /// @param tick The active tick at the time of the new timepoint\n  /// @return indexUpdated The new index of the most recently written element in the dataStorage array\n  /// @return newFee The fee in hundredths of a bip, i.e. 1e-6\n  function write(uint16 index, uint32 blockTimestamp, int24 tick) external returns (uint16 indexUpdated, uint16 newFee);\n\n  /// @notice Changes fee configuration for the pool\n  function changeFeeConfiguration(AlgebraFeeConfiguration calldata feeConfig) external;\n\n  /// @notice Fills uninitialized timepoints with nonzero value\n  /// @dev Can be used to reduce the gas cost of future swaps\n  /// @param startIndex The start index, must be not initialized\n  /// @param amount of slots to fill, startIndex + amount must be <= type(uint16).max\n  function prepayTimepointsStorageSlots(uint16 startIndex, uint16 amount) external;\n}\n"
    },
    "contracts/integrations/algebra/IFarmingCenter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IAlgebraEternalFarming.sol\";\nimport \"./IncentiveKey.sol\";\nimport \"./INonfungiblePositionManager.sol\";\n\ninterface IFarmingCenter {\n    /// @notice Returns information about a deposited NFT\n    /// @param tokenId The ID of the deposit (and token) that is being transferred\n    /// @return L2TokenId The nft layer2 id,\n    /// numberOfFarms The number of farms,\n    /// inLimitFarming The parameter showing if the token is in the limit farm,\n    /// owner The owner of deposit\n    function deposits(uint256 tokenId)\n    external\n    view\n    returns (\n        uint256 L2TokenId,\n        uint32 numberOfFarms,\n        bool inLimitFarming,\n        address owner\n    );\n\n    /// @notice Enters in incentive (time-limited or eternal farming) with NFT-position token\n    /// @dev token must be deposited in FarmingCenter\n    /// @param key The incentive event key\n    /// @param tokenId The id of position NFT\n    /// @param tokensLocked Amount of tokens to lock for liquidity multiplier (if tiers are used)\n    /// @param isLimit Is incentive time-limited or eternal\n    function enterFarming(\n        IncentiveKey memory key,\n        uint256 tokenId,\n        uint256 tokensLocked,\n        bool isLimit\n    ) external;\n\n    function eternalFarming() external view returns (IAlgebraEternalFarming);\n\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\n    /// @dev \"proxies\" to NonfungiblePositionManager\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\n    /// recipient The account that should receive the tokens,\n    /// amount0Max The maximum amount of token0 to collect,\n    /// amount1Max The maximum amount of token1 to collect\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(INonfungiblePositionManager.CollectParams calldata params)\n    external\n    returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Used to collect reward from eternal farming. Then reward can be claimed.\n    /// @param key The incentive event key\n    /// @param tokenId The id of position NFT\n    /// @return reward The amount of collected reward\n    /// @return bonusReward The amount of collected  bonus reward\n    function collectRewards(IncentiveKey memory key, uint256 tokenId)\n    external\n    returns (uint256 reward, uint256 bonusReward);\n\n    /// @notice Used to claim and send rewards from farming(s)\n    /// @dev can be used via static call to get current rewards for user\n    /// @param rewardToken The token that is a reward\n    /// @param to The address to be rewarded\n    /// @param amountRequestedIncentive Amount to claim in incentive (limit) farming\n    /// @param amountRequestedEternal Amount to claim in eternal farming\n    /// @return reward The summary amount of claimed rewards\n    function claimReward(\n        address rewardToken,\n        address to,\n        uint256 amountRequestedIncentive,\n        uint256 amountRequestedEternal\n    ) external returns (uint256 reward);\n\n    /// @notice Exits from incentive (time-limited or eternal farming) with NFT-position token\n    /// @param key The incentive event key\n    /// @param tokenId The id of position NFT\n    /// @param isLimit Is incentive time-limited or eternal\n    function exitFarming(\n        IncentiveKey memory key,\n        uint256 tokenId,\n        bool isLimit\n    ) external;\n\n    /// @notice Withdraw Algebra NFT-position token\n    /// @dev can be used via static call to get current rewards for user\n    /// @param tokenId The id of position NFT\n    /// @param to New owner of position NFT\n    /// @param data The additional data for NonfungiblePositionManager\n    function withdrawToken(\n        uint256 tokenId,\n        address to,\n        bytes memory data\n    ) external;\n}"
    },
    "contracts/integrations/algebra/IncentiveKey.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nstruct IncentiveKey {\n    address rewardToken;\n    address bonusRewardToken;\n    address pool;\n    uint256 startTime;\n    uint256 endTime;\n}"
    },
    "contracts/integrations/algebra/INonfungiblePositionManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface INonfungiblePositionManager {\n    struct MintParams {\n        address token0;\n        address token1;\n        int24 tickLower;\n        int24 tickUpper;\n        uint amount0Desired;\n        uint amount1Desired;\n        uint amount0Min;\n        uint amount1Min;\n        address recipient;\n        uint deadline;\n    }\n\n    function mint(\n        MintParams calldata params\n    ) external payable returns (uint tokenId, uint128 liquidity, uint amount0, uint amount1);\n\n    struct IncreaseLiquidityParams {\n        uint256 tokenId;\n        uint256 amount0Desired;\n        uint256 amount1Desired;\n        uint256 amount0Min;\n        uint256 amount1Min;\n        uint256 deadline;\n    }\n\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\n    external\n    payable\n    returns (\n        uint128 liquidity,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    struct DecreaseLiquidityParams {\n        uint tokenId;\n        uint128 liquidity;\n        uint amount0Min;\n        uint amount1Min;\n        uint deadline;\n    }\n\n    function decreaseLiquidity(\n        DecreaseLiquidityParams calldata params\n    ) external payable returns (uint amount0, uint amount1);\n\n    struct CollectParams {\n        uint tokenId;\n        address recipient;\n        uint128 amount0Max;\n        uint128 amount1Max;\n    }\n\n    function collect(CollectParams calldata params) external payable returns (uint amount0, uint amount1);\n\n    function burn(uint tokenId) external payable;\n\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    function positions(uint256 tokenId)\n    external\n    view\n    returns (\n        uint96 nonce,\n        address operator,\n        address token0,\n        address token1,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 liquidity,\n        uint256 feeGrowthInside0LastX128,\n        uint256 feeGrowthInside1LastX128,\n        uint128 tokensOwed0,\n        uint128 tokensOwed1\n    );\n}"
    },
    "contracts/integrations/algebra/pool/IAlgebraPoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\ninterface IAlgebraPoolActions {\n  /**\n   * @notice Sets the initial price for the pool\n   * @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n   * @param price the initial sqrt price of the pool as a Q64.96\n   */\n  function initialize(uint160 price) external;\n\n  /**\n   * @notice Adds liquidity for the given recipient/bottomTick/topTick position\n   * @dev The caller of this method receives a callback in the form of IAlgebraMintCallback# AlgebraMintCallback\n   * in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n   * on bottomTick, topTick, the amount of liquidity, and the current price.\n   * @param sender The address which will receive potential surplus of paid tokens\n   * @param recipient The address for which the liquidity will be created\n   * @param bottomTick The lower tick of the position in which to add liquidity\n   * @param topTick The upper tick of the position in which to add liquidity\n   * @param amount The desired amount of liquidity to mint\n   * @param data Any data that should be passed through to the callback\n   * @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n   * @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n   * @return liquidityActual The actual minted amount of liquidity\n   */\n  function mint(\n    address sender,\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount,\n    bytes calldata data\n  )\n  external\n  returns (\n    uint256 amount0,\n    uint256 amount1,\n    uint128 liquidityActual\n  );\n\n  /**\n   * @notice Collects tokens owed to a position\n   * @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n   * Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n   * amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n   * actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n   * @param recipient The address which should receive the fees collected\n   * @param bottomTick The lower tick of the position for which to collect fees\n   * @param topTick The upper tick of the position for which to collect fees\n   * @param amount0Requested How much token0 should be withdrawn from the fees owed\n   * @param amount1Requested How much token1 should be withdrawn from the fees owed\n   * @return amount0 The amount of fees collected in token0\n   * @return amount1 The amount of fees collected in token1\n   */\n  function collect(\n    address recipient,\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n\n  /**\n   * @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n   * @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n   * @dev Fees must be collected separately via a call to #collect\n   * @param bottomTick The lower tick of the position for which to burn liquidity\n   * @param topTick The upper tick of the position for which to burn liquidity\n   * @param amount How much liquidity to burn\n   * @return amount0 The amount of token0 sent to the recipient\n   * @return amount1 The amount of token1 sent to the recipient\n   */\n  function burn(\n    int24 bottomTick,\n    int24 topTick,\n    uint128 amount\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /**\n   * @notice Swap token0 for token1, or token1 for token0\n   * @dev The caller of this method receives a callback in the form of IAlgebraSwapCallback# AlgebraSwapCallback\n   * @param recipient The address to receive the output of the swap\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\n   * SwapRouter#SwapCallbackData\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n   */\n  function swap(\n    address recipient,\n    bool zeroToOne,\n    int256 amountSpecified,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /**\n   * @notice Swap token0 for token1, or token1 for token0 (tokens that have fee on transfer)\n   * @dev The caller of this method receives a callback in the form of I AlgebraSwapCallback# AlgebraSwapCallback\n   * @param sender The address called this function (Comes from the Router)\n   * @param recipient The address to receive the output of the swap\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\n   * SwapRouter#SwapCallbackData\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n   */\n  function swapSupportingFeeOnInputTokens(\n    address sender,\n    address recipient,\n    bool zeroToOne,\n    int256 amountSpecified,\n    uint160 limitSqrtPrice,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /**\n   * @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n   * @dev The caller of this method receives a callback in the form of IAlgebraFlashCallback# AlgebraFlashCallback\n   * @dev All excess tokens paid in the callback are distributed to liquidity providers as an additional fee. So this method can be used\n   * to donate underlying tokens to currently in-range liquidity providers by calling with 0 amount{0,1} and sending\n   * the donation amount(s) from the callback\n   * @param recipient The address which will receive the token0 and token1 amounts\n   * @param amount0 The amount of token0 to send\n   * @param amount1 The amount of token1 to send\n   * @param data Any data to be passed through to the callback\n   */\n  function flash(\n    address recipient,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/integrations/algebra/pool/IAlgebraPoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/**\n * @title Pool state that is not stored\n * @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n * blockchain. The functions here may have variable gas costs.\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\n */\ninterface IAlgebraPoolDerivedState {\n  /**\n   * @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n   * @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n   * the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n   * you must call it with secondsAgos = [3600, 0].\n   * @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n   * log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n   * @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n   * @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n   * @return secondsPerLiquidityCumulatives Cumulative seconds per liquidity-in-range value as of each `secondsAgos`\n   * from the current block timestamp\n   * @return volatilityCumulatives Cumulative standard deviation as of each `secondsAgos`\n   * @return volumePerAvgLiquiditys Cumulative swap volume per liquidity as of each `secondsAgos`\n   */\n  function getTimepoints(uint32[] calldata secondsAgos)\n  external\n  view\n  returns (\n    int56[] memory tickCumulatives,\n    uint160[] memory secondsPerLiquidityCumulatives,\n    uint112[] memory volatilityCumulatives,\n    uint256[] memory volumePerAvgLiquiditys\n  );\n\n  /**\n   * @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n   * @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n   * I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n   * snapshot is taken and the second snapshot is taken.\n   * @param bottomTick The lower tick of the range\n   * @param topTick The upper tick of the range\n   * @return innerTickCumulative The snapshot of the tick accumulator for the range\n   * @return innerSecondsSpentPerLiquidity The snapshot of seconds per liquidity for the range\n   * @return innerSecondsSpent The snapshot of the number of seconds during which the price was in this range\n   */\n  function getInnerCumulatives(int24 bottomTick, int24 topTick)\n  external\n  view\n  returns (\n    int56 innerTickCumulative,\n    uint160 innerSecondsSpentPerLiquidity,\n    uint32 innerSecondsSpent\n  );\n}\n"
    },
    "contracts/integrations/algebra/pool/IAlgebraPoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\ninterface IAlgebraPoolEvents {\n  /**\n   * @notice Emitted exactly once by a pool when #initialize is first called on the pool\n   * @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n   * @param price The initial sqrt price of the pool, as a Q64.96\n   * @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n   */\n  event Initialize(uint160 price, int24 tick);\n\n  /**\n   * @notice Emitted when liquidity is minted for a given position\n   * @param sender The address that minted the liquidity\n   * @param owner The owner of the position and recipient of any minted liquidity\n   * @param bottomTick The lower tick of the position\n   * @param topTick The upper tick of the position\n   * @param liquidityAmount The amount of liquidity minted to the position range\n   * @param amount0 How much token0 was required for the minted liquidity\n   * @param amount1 How much token1 was required for the minted liquidity\n   */\n  event Mint(\n    address sender,\n    address indexed owner,\n    int24 indexed bottomTick,\n    int24 indexed topTick,\n    uint128 liquidityAmount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /**\n   * @notice Emitted when fees are collected by the owner of a position\n   * @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n   * @param owner The owner of the position for which fees are collected\n   * @param recipient The address that received fees\n   * @param bottomTick The lower tick of the position\n   * @param topTick The upper tick of the position\n   * @param amount0 The amount of token0 fees collected\n   * @param amount1 The amount of token1 fees collected\n   */\n  event Collect(address indexed owner, address recipient, int24 indexed bottomTick, int24 indexed topTick, uint128 amount0, uint128 amount1);\n\n  /**\n   * @notice Emitted when a position's liquidity is removed\n   * @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n   * @param owner The owner of the position for which liquidity is removed\n   * @param bottomTick The lower tick of the position\n   * @param topTick The upper tick of the position\n   * @param liquidityAmount The amount of liquidity to remove\n   * @param amount0 The amount of token0 withdrawn\n   * @param amount1 The amount of token1 withdrawn\n   */\n  event Burn(address indexed owner, int24 indexed bottomTick, int24 indexed topTick, uint128 liquidityAmount, uint256 amount0, uint256 amount1);\n\n  /**\n   * @notice Emitted by the pool for any swaps between token0 and token1\n   * @param sender The address that initiated the swap call, and that received the callback\n   * @param recipient The address that received the output of the swap\n   * @param amount0 The delta of the token0 balance of the pool\n   * @param amount1 The delta of the token1 balance of the pool\n   * @param price The sqrt(price) of the pool after the swap, as a Q64.96\n   * @param liquidity The liquidity of the pool after the swap\n   * @param tick The log base 1.0001 of price of the pool after the swap\n   */\n  event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 price, uint128 liquidity, int24 tick);\n\n  /**\n   * @notice Emitted by the pool for any flashes of token0/token1\n   * @param sender The address that initiated the swap call, and that received the callback\n   * @param recipient The address that received the tokens from flash\n   * @param amount0 The amount of token0 that was flashed\n   * @param amount1 The amount of token1 that was flashed\n   * @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n   * @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n   */\n  event Flash(address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1);\n\n  /**\n   * @notice Emitted when the community fee is changed by the pool\n   * @param communityFee0New The updated value of the token0 community fee percent\n   * @param communityFee1New The updated value of the token1 community fee percent\n   */\n  event CommunityFee(uint8 communityFee0New, uint8 communityFee1New);\n\n  /**\n   * @notice Emitted when new activeIncentive is set\n   * @param virtualPoolAddress The address of a virtual pool associated with the current active incentive\n   */\n  event Incentive(address indexed virtualPoolAddress);\n\n  /**\n   * @notice Emitted when the fee changes\n   * @param fee The value of the token fee\n   */\n  event Fee(uint16 fee);\n\n  /**\n   * @notice Emitted when the LiquidityCooldown changes\n   * @param liquidityCooldown The value of locktime for added liquidity\n   */\n  event LiquidityCooldown(uint32 liquidityCooldown);\n}\n"
    },
    "contracts/integrations/algebra/pool/IAlgebraPoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport '../IDataStorageOperator.sol';\n\n/// @title Pool state that never changes\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\ninterface IAlgebraPoolImmutables {\n  /**\n   * @notice The contract that stores all the timepoints and can perform actions with them\n   * @return The operator address\n   */\n  function dataStorageOperator() external view returns (address);\n\n  /**\n   * @notice The contract that deployed the pool, which must adhere to the IAlgebraFactory interface\n   * @return The contract address\n   */\n  function factory() external view returns (address);\n\n  /**\n   * @notice The first of the two tokens of the pool, sorted by address\n   * @return The token contract address\n   */\n  function token0() external view returns (address);\n\n  /**\n   * @notice The second of the two tokens of the pool, sorted by address\n   * @return The token contract address\n   */\n  function token1() external view returns (address);\n\n  /**\n   * @notice The pool tick spacing\n   * @dev Ticks can only be used at multiples of this value\n   * e.g.: a tickSpacing of 60 means ticks can be initialized every 60th tick, i.e., ..., -120, -60, 0, 60, 120, ...\n   * This value is an int24 to avoid casting even though it is always positive.\n   * @return The tick spacing\n   */\n  function tickSpacing() external view returns (int24);\n\n  /**\n   * @notice The maximum amount of position liquidity that can use any tick in the range\n   * @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n   * also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n   * @return The max amount of liquidity per tick\n   */\n  function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/integrations/algebra/pool/IAlgebraPoolPermissionedActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/**\n * @title Permissioned pool actions\n * @notice Contains pool methods that may only be called by the factory owner or tokenomics\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\n */\ninterface IAlgebraPoolPermissionedActions {\n  /**\n   * @notice Set the community's % share of the fees. Cannot exceed 25% (250)\n   * @param communityFee0 new community fee percent for token0 of the pool in thousandths (1e-3)\n   * @param communityFee1 new community fee percent for token1 of the pool in thousandths (1e-3)\n   */\n  function setCommunityFee(uint8 communityFee0, uint8 communityFee1) external;\n\n  /**\n   * @notice Sets an active incentive\n   * @param virtualPoolAddress The address of a virtual pool associated with the incentive\n   */\n  function setIncentive(address virtualPoolAddress) external;\n\n  /**\n   * @notice Sets new lock time for added liquidity\n   * @param newLiquidityCooldown The time in seconds\n   */\n  function setLiquidityCooldown(uint32 newLiquidityCooldown) external;\n}\n"
    },
    "contracts/integrations/algebra/pool/IAlgebraPoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\ninterface IAlgebraPoolState {\n  /**\n   * @notice The globalState structure in the pool stores many values but requires only one slot\n   * and is exposed as a single method to save gas when accessed externally.\n   * @return price The current price of the pool as a sqrt(token1/token0) Q64.96 value;\n   * Returns tick The current tick of the pool, i.e. according to the last tick transition that was run;\n   * Returns This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick\n   * boundary;\n   * Returns fee The last pool fee value in hundredths of a bip, i.e. 1e-6;\n   * Returns timepointIndex The index of the last written timepoint;\n   * Returns communityFeeToken0 The community fee percentage of the swap fee in thousandths (1e-3) for token0;\n   * Returns communityFeeToken1 The community fee percentage of the swap fee in thousandths (1e-3) for token1;\n   * Returns unlocked Whether the pool is currently locked to reentrancy;\n   */\n  function globalState()\n  external\n  view\n  returns (\n    uint160 price,\n    int24 tick,\n    uint16 fee,\n    uint16 timepointIndex,\n    uint8 communityFeeToken0,\n    uint8 communityFeeToken1,\n    bool unlocked\n  );\n\n  /**\n   * @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n   * @dev This value can overflow the uint256\n   */\n  function totalFeeGrowth0Token() external view returns (uint256);\n\n  /**\n   * @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n   * @dev This value can overflow the uint256\n   */\n  function totalFeeGrowth1Token() external view returns (uint256);\n\n  /**\n   * @notice The currently in range liquidity available to the pool\n   * @dev This value has no relationship to the total liquidity across all ticks.\n   * Returned value cannot exceed type(uint128).max\n   */\n  function liquidity() external view returns (uint128);\n\n  /**\n   * @notice Look up information about a specific tick in the pool\n   * @dev This is a public structure, so the `return` natspec tags are omitted.\n   * @param tick The tick to look up\n   * @return liquidityTotal the total amount of position liquidity that uses the pool either as tick lower or\n   * tick upper;\n   * Returns liquidityDelta how much liquidity changes when the pool price crosses the tick;\n   * Returns outerFeeGrowth0Token the fee growth on the other side of the tick from the current tick in token0;\n   * Returns outerFeeGrowth1Token the fee growth on the other side of the tick from the current tick in token1;\n   * Returns outerTickCumulative the cumulative tick value on the other side of the tick from the current tick;\n   * Returns outerSecondsPerLiquidity the seconds spent per liquidity on the other side of the tick from the current tick;\n   * Returns outerSecondsSpent the seconds spent on the other side of the tick from the current tick;\n   * Returns initialized Set to true if the tick is initialized, i.e. liquidityTotal is greater than 0\n   * otherwise equal to false. Outside values can only be used if the tick is initialized.\n   * In addition, these values are only relative and must be used only in comparison to previous snapshots for\n   * a specific position.\n   */\n  function ticks(int24 tick)\n  external\n  view\n  returns (\n    uint128 liquidityTotal,\n    int128 liquidityDelta,\n    uint256 outerFeeGrowth0Token,\n    uint256 outerFeeGrowth1Token,\n    int56 outerTickCumulative,\n    uint160 outerSecondsPerLiquidity,\n    uint32 outerSecondsSpent,\n    bool initialized\n  );\n\n  /** @notice Returns 256 packed tick initialized boolean values. See TickTable for more information */\n  function tickTable(int16 wordPosition) external view returns (uint256);\n\n  /**\n   * @notice Returns the information about a position by the position's key\n   * @dev This is a public mapping of structures, so the `return` natspec tags are omitted.\n   * @param key The position's key is a hash of a preimage composed by the owner, bottomTick and topTick\n   * @return liquidityAmount The amount of liquidity in the position;\n   * Returns lastLiquidityAddTimestamp Timestamp of last adding of liquidity;\n   * Returns innerFeeGrowth0Token Fee growth of token0 inside the tick range as of the last mint/burn/poke;\n   * Returns innerFeeGrowth1Token Fee growth of token1 inside the tick range as of the last mint/burn/poke;\n   * Returns fees0 The computed amount of token0 owed to the position as of the last mint/burn/poke;\n   * Returns fees1 The computed amount of token1 owed to the position as of the last mint/burn/poke\n   */\n  function positions(bytes32 key)\n  external\n  view\n  returns (\n    uint128 liquidityAmount,\n    uint32 lastLiquidityAddTimestamp,\n    uint256 innerFeeGrowth0Token,\n    uint256 innerFeeGrowth1Token,\n    uint128 fees0,\n    uint128 fees1\n  );\n\n  /**\n   * @notice Returns data about a specific timepoint index\n   * @param index The element of the timepoints array to fetch\n   * @dev You most likely want to use #getTimepoints() instead of this method to get an timepoint as of some amount of time\n   * ago, rather than at a specific index in the array.\n   * This is a public mapping of structures, so the `return` natspec tags are omitted.\n   * @return initialized whether the timepoint has been initialized and the values are safe to use;\n   * Returns blockTimestamp The timestamp of the timepoint;\n   * Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp;\n   * Returns secondsPerLiquidityCumulative the seconds per in range liquidity for the life of the pool as of the timepoint timestamp;\n   * Returns volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp;\n   * Returns averageTick Time-weighted average tick;\n   * Returns volumePerLiquidityCumulative Cumulative swap volume per liquidity for the life of the pool as of the timepoint timestamp;\n   */\n  function timepoints(uint256 index)\n  external\n  view\n  returns (\n    bool initialized,\n    uint32 blockTimestamp,\n    int56 tickCumulative,\n    uint160 secondsPerLiquidityCumulative,\n    uint88 volatilityCumulative,\n    int24 averageTick,\n    uint144 volumePerLiquidityCumulative\n  );\n\n  /**\n   * @notice Returns the information about active incentive\n   * @dev if there is no active incentive at the moment, virtualPool,endTimestamp,startTimestamp would be equal to 0\n   * @return virtualPool The address of a virtual pool associated with the current active incentive\n   */\n  function activeIncentive() external view returns (address virtualPool);\n\n  /**\n   * @notice Returns the lock time for added liquidity\n   */\n  function liquidityCooldown() external view returns (uint32 cooldownInSeconds);\n}\n"
    },
    "contracts/integrations/balancer/IBalancerGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice gauge-v2, see 0xc9b36096f5201ea332Db35d6D195774ea0D5988f\n/// @dev see 20230316-child-chain-gauge-factory-v2 in balancer-deployments repository\ninterface IBalancerGauge {\n  event Approval(\n    address indexed _owner,\n    address indexed _spender,\n    uint256 _value\n  );\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event Deposit(address indexed _user, uint256 _value);\n  event Withdraw(address indexed _user, uint256 _value);\n  event UpdateLiquidityLimit(\n    address indexed _user,\n    uint256 _original_balance,\n    uint256 _original_supply,\n    uint256 _working_balance,\n    uint256 _working_supply\n  );\n\n  function deposit(uint256 _value) external;\n\n  function deposit(uint256 _value, address _user) external;\n\n  function withdraw(uint256 _value) external;\n\n  function withdraw(uint256 _value, address _user) external;\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external returns (bool);\n\n  function approve(address _spender, uint256 _value) external returns (bool);\n\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _value,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (bool);\n\n  function transfer(address _to, uint256 _value) external returns (bool);\n\n  function increaseAllowance(address _spender, uint256 _added_value)\n  external\n  returns (bool);\n\n  function decreaseAllowance(address _spender, uint256 _subtracted_value)\n  external\n  returns (bool);\n\n  function user_checkpoint(address addr) external returns (bool);\n\n  function claimable_tokens(address addr) external returns (uint256);\n\n  function claimed_reward(address _addr, address _token)\n  external\n  view\n  returns (uint256);\n\n  function claimable_reward(address _user, address _reward_token)\n  external\n  view\n  returns (uint256);\n\n  function set_rewards_receiver(address _receiver) external;\n\n  function claim_rewards() external;\n\n  function claim_rewards(address _addr) external;\n\n  function claim_rewards(address _addr, address _receiver) external;\n\n  function claim_rewards(\n    address _addr,\n    address _receiver,\n    uint256[] memory _reward_indexes\n  ) external;\n\n  function add_reward(address _reward_token, address _distributor) external;\n\n  function set_reward_distributor(address _reward_token, address _distributor)\n  external;\n\n  function deposit_reward_token(address _reward_token, uint256 _amount)\n  external;\n\n  function killGauge() external;\n\n  function unkillGauge() external;\n\n  function decimals() external view returns (uint256);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function integrate_checkpoint() external view returns (uint256);\n\n  function bal_token() external view returns (address);\n\n  function bal_pseudo_minter() external view returns (address);\n\n  function voting_escrow_delegation_proxy() external view returns (address);\n\n  function authorizer_adaptor() external view returns (address);\n\n  function initialize(address _lp_token, string memory _version) external;\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function nonces(address arg0) external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function balanceOf(address arg0) external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function lp_token() external view returns (address);\n\n  function version() external view returns (string memory);\n\n  function factory() external view returns (address);\n\n  function working_balances(address arg0) external view returns (uint256);\n\n  function working_supply() external view returns (uint256);\n\n  function period() external view returns (uint256);\n\n  function period_timestamp(uint256 arg0) external view returns (uint256);\n\n  function integrate_checkpoint_of(address arg0)\n  external\n  view\n  returns (uint256);\n\n  function integrate_fraction(address arg0) external view returns (uint256);\n\n  function integrate_inv_supply(uint256 arg0) external view returns (uint256);\n\n  function integrate_inv_supply_of(address arg0)\n  external\n  view\n  returns (uint256);\n\n  function reward_count() external view returns (uint256);\n\n  function reward_tokens(uint256 arg0) external view returns (address);\n\n  function reward_data(address arg0) external view returns (S_0 memory);\n\n  function rewards_receiver(address arg0) external view returns (address);\n\n  function reward_integral_for(address arg0, address arg1)\n  external\n  view\n  returns (uint256);\n\n  function is_killed() external view returns (bool);\n\n  function inflation_rate(uint256 arg0) external view returns (uint256);\n}\n\n  struct S_0 {\n    address distributor;\n    uint256 period_finish;\n    uint256 rate;\n    uint256 last_update;\n    uint256 integral;\n  }\n"
    },
    "contracts/integrations/balancer/IBalancerGaugeV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice gauge-v1, see 0x2E96068b3D5B5BAE3D7515da4A1D2E52d08A2647\n/// @dev see 20220413-child-chain-gauge-factory in balancer-deployments repository\ninterface IBalancerGaugeV1 {\n\n  function decimals() external view returns (uint256);\n\n  function version() external view returns (string memory);\n\n  function reward_contract() external view returns (address);\n\n  function last_claim() external view returns (uint256);\n\n  function claimed_reward(address _addr, address _token)\n  external\n  view\n  returns (uint256);\n\n  function claimable_reward(address _addr, address _token)\n  external\n  view\n  returns (uint256);\n\n  function reward_data(address _token) external view returns (\n    address token,\n    address distributor,\n    uint256 period_finish,\n    uint256 rate,\n    uint256 last_update,\n    uint256 integral\n  );\n\n  function claimable_reward_write(address _addr, address _token)\n  external\n  returns (uint256);\n\n  function set_rewards_receiver(address _receiver) external;\n\n  function claim_rewards() external;\n\n  function claim_rewards(address _addr) external;\n\n  function claim_rewards(address _addr, address _receiver) external;\n\n  function deposit(uint256 _value) external;\n\n  function deposit(uint256 _value, address _addr) external;\n\n  function deposit(\n    uint256 _value,\n    address _addr,\n    bool _claim_rewards\n  ) external;\n\n  function withdraw(uint256 _value) external;\n\n  function withdraw(uint256 _value, bool _claim_rewards) external;\n\n  function transfer(address _to, uint256 _value) external returns (bool);\n\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _value\n  ) external returns (bool);\n\n  function allowance(address owner, address spender)\n  external\n  view\n  returns (uint256);\n\n  function approve(address _spender, uint256 _value) external returns (bool);\n\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _value,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (bool);\n\n  function increaseAllowance(address _spender, uint256 _added_value)\n  external\n  returns (bool);\n\n  function decreaseAllowance(address _spender, uint256 _subtracted_value)\n  external\n  returns (bool);\n\n  function set_rewards(\n    address _reward_contract,\n    bytes32 _claim_sig,\n    address[8] memory _reward_tokens\n  ) external;\n\n  function initialize(\n    address _lp_token,\n    address _reward_contract,\n    bytes32 _claim_sig\n  ) external;\n\n  function lp_token() external view returns (address);\n\n  function balanceOf(address arg0) external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function nonces(address arg0) external view returns (uint256);\n\n  function reward_tokens(uint256 arg0) external view returns (address);\n\n  function reward_balances(address arg0) external view returns (uint256);\n\n  function rewards_receiver(address arg0) external view returns (address);\n\n  function claim_sig() external view returns (bytes memory);\n\n  function reward_integral(address arg0) external view returns (uint256);\n\n  function reward_integral_for(address arg0, address arg1)\n  external\n  view\n  returns (uint256);\n\n}\n"
    },
    "contracts/integrations/balancer/IBalancerHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IBVault.sol\";\n\ninterface IBalancerHelper {\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    IBVault.ExitPoolRequest memory request\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    IBVault.JoinPoolRequest memory request\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function vault() external view returns (address);\n}\n"
    },
    "contracts/integrations/balancer/IBalancerMinter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IBalancerMinter {\n  event Minted(address indexed recipient, address gauge, uint256 minted);\n  event MinterApprovalSet(\n    address indexed user,\n    address indexed minter,\n    bool approval\n  );\n\n  function allowed_to_mint_for(address minter, address user)\n  external\n  view\n  returns (bool);\n\n  function getBalancerToken() external view returns (address);\n\n  function getBalancerTokenAdmin() external view returns (address);\n\n  function getDomainSeparator() external view returns (bytes32);\n\n  function getGaugeController() external view returns (address);\n\n  function getMinterApproval(address minter, address user)\n  external\n  view\n  returns (bool);\n\n  function getNextNonce(address user) external view returns (uint256);\n\n  function mint(address gauge) external returns (uint256);\n\n  function mintFor(address gauge, address user) external returns (uint256);\n\n  function mintMany(address[] memory gauges) external returns (uint256);\n\n  function mintManyFor(address[] memory gauges, address user)\n  external\n  returns (uint256);\n\n  function mint_for(address gauge, address user) external;\n\n  function mint_many(address[8] memory gauges) external;\n\n  function minted(address user, address gauge)\n  external\n  view\n  returns (uint256);\n\n  function setMinterApproval(address minter, bool approval) external;\n\n  function setMinterApprovalWithSignature(\n    address minter,\n    bool approval,\n    address user,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function toggle_approve_mint(address minter) external;\n}\n"
    },
    "contracts/integrations/balancer/IBVault.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\n\ninterface IAsset {\n}\n\ninterface IBVault {\n  // Internal Balance\n  //\n  // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n  // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n  // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n  // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n  //\n  // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n  // operations of different kinds, with different senders and recipients, at once.\n\n  /**\n   * @dev Returns `user`'s Internal Balance for a set of tokens.\n     */\n  function getInternalBalance(address user, IERC20[] calldata tokens) external view returns (uint256[] memory);\n\n  /**\n   * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n  function manageUserBalance(UserBalanceOp[] calldata ops) external payable;\n\n  /**\n   * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n  struct UserBalanceOp {\n    UserBalanceOpKind kind;\n    IAsset asset;\n    uint256 amount;\n    address sender;\n    address payable recipient;\n  }\n\n  // There are four possible operations in `manageUserBalance`:\n  //\n  // - DEPOSIT_INTERNAL\n  // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n  // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n  // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n  // relevant for relayers).\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - WITHDRAW_INTERNAL\n  // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n  // it to the recipient as ETH.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_INTERNAL\n  // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_EXTERNAL\n  // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n  // relayers, as it lets them reuse a user's Vault allowance.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `ExternalBalanceTransfer` event.\n\n  enum UserBalanceOpKind {DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL}\n\n  /**\n   * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n  event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n  /**\n   * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n  event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n  // Pools\n  //\n  // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n  // functionality:\n  //\n  //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n  // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n  // which increase with the number of registered tokens.\n  //\n  //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n  // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n  // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n  // independent of the number of registered tokens.\n  //\n  //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n  // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n  enum PoolSpecialization {GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN}\n\n  /**\n   * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n  function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n  /**\n   * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n  event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n  /**\n   * @dev Returns a Pool's contract address and specialization setting.\n     */\n  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n  /**\n   * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n  function registerTokens(\n    bytes32 poolId,\n    IERC20[] calldata tokens,\n    address[] calldata assetManagers\n  ) external;\n\n  /**\n   * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n  event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n  /**\n   * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n  function deregisterTokens(bytes32 poolId, IERC20[] calldata tokens) external;\n\n  /**\n   * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n  event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n  /**\n   * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n  function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n  external\n  view\n  returns (\n    uint256 cash,\n    uint256 managed,\n    uint256 lastChangeBlock,\n    address assetManager\n  );\n\n  /**\n   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n  function getPoolTokens(bytes32 poolId)\n  external\n  view\n  returns (\n    IERC20[] memory tokens,\n    uint256[] memory balances,\n    uint256 lastChangeBlock\n  );\n\n  /**\n   * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     *\n     * See https://dev.balancer.fi/resources/joins-and-exits/pool-joins\n     */\n  function joinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    JoinPoolRequest calldata request\n  ) external payable;\n\n  enum JoinKind {INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT}\n\n  /// @notice WeightedPool ExitKinds\n  enum ExitKind {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT}\n  /// @notice Composable Stable V2 ExitKinds\n  enum ExitKindComposableStable {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT, EXACT_BPT_IN_FOR_ALL_TOKENS_OUT}\n\n\n  struct JoinPoolRequest {\n    IAsset[] assets;\n    uint256[] maxAmountsIn;\n    bytes userData;\n    bool fromInternalBalance;\n  }\n\n  /**\n   * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n  function exitPool(\n    bytes32 poolId,\n    address sender,\n    address payable recipient,\n    ExitPoolRequest calldata request\n  ) external;\n\n  struct ExitPoolRequest {\n    IAsset[] assets;\n    uint256[] minAmountsOut;\n    bytes userData;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n  event PoolBalanceChanged(\n    bytes32 indexed poolId,\n    address indexed liquidityProvider,\n    IERC20[] tokens,\n    int256[] deltas,\n    uint256[] protocolFeeAmounts\n  );\n\n  enum PoolBalanceChangeKind {JOIN, EXIT}\n\n  // Swaps\n  //\n  // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n  // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n  // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n  //\n  // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n  // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n  // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n  // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n  // individual swaps.\n  //\n  // There are two swap kinds:\n  //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n  // `onSwap` hook) the amount of tokens out (to send to the recipient).\n  //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n  // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n  //\n  // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n  // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n  // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n  // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n  // the final intended token.\n  //\n  // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n  // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n  // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n  // much less gas than they would otherwise.\n  //\n  // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n  // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n  // updating the Pool's internal accounting).\n  //\n  // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n  // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n  // minimum amount of tokens to receive (by passing a negative value) is specified.\n  //\n  // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n  // this point in time (e.g. if the transaction failed to be included in a block promptly).\n  //\n  // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n  // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n  // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n  // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n  //\n  // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n  enum SwapKind {GIVEN_IN, GIVEN_OUT}\n\n  /**\n   * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n  function swap(\n    SingleSwap calldata singleSwap,\n    FundManagement calldata funds,\n    uint256 limit,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  /**\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct SingleSwap {\n    bytes32 poolId;\n    SwapKind kind;\n    IAsset assetIn;\n    IAsset assetOut;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n  function batchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds,\n    int256[] calldata limits,\n    uint256 deadline\n  ) external payable returns (int256[] memory);\n\n  /**\n   * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct BatchSwapStep {\n    bytes32 poolId;\n    uint256 assetInIndex;\n    uint256 assetOutIndex;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n  event Swap(\n    bytes32 indexed poolId,\n    IERC20 indexed tokenIn,\n    IERC20 indexed tokenOut,\n    uint256 amountIn,\n    uint256 amountOut\n  );\n\n  /**\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n  struct FundManagement {\n    address sender;\n    bool fromInternalBalance;\n    address payable recipient;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n  function queryBatchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds\n  ) external returns (int256[] memory assetDeltas);\n\n  // BasePool.sol\n\n  /**\n* @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\n     *\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\n     * data, such as the protocol swap fee percentage and Pool balances.\n     *\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\n     * explicitly use eth_call instead of eth_sendTransaction.\n     */\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n\n}\n"
    },
    "contracts/integrations/balancer/IChildChainLiquidityGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\n/// @notice ChildChainLiquidityGaugeFactory, restored for 0x3b8cA519122CdD8efb272b0D3085453404B25bD0\n/// @dev See https://dev.balancer.fi/resources/vebal-and-gauges/gauges\ninterface IChildChainLiquidityGaugeFactory {\n  event RewardsOnlyGaugeCreated(\n    address indexed gauge,\n    address indexed pool,\n    address streamer\n  );\n\n  function create(address pool) external returns (address);\n\n  function getChildChainStreamerImplementation() external view returns (address);\n\n  function getGaugeImplementation() external view returns (address);\n\n  function getGaugePool(address gauge) external view returns (address);\n\n  function getGaugeStreamer(address gauge) external view returns (address);\n\n  function getPoolGauge(address pool) external view returns (address);\n\n  function getPoolStreamer(address pool) external view returns (address);\n\n  function isGaugeFromFactory(address gauge) external view returns (bool);\n\n  function isStreamerFromFactory(address streamer) external view returns (bool);\n}\n\n"
    },
    "contracts/integrations/balancer/IComposableStablePool.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IComposableStablePool {\n  function balanceOf(address account) external view returns (uint256);\n  function getActualSupply() external view returns (uint256);\n  function getPoolId() external view returns (bytes32);\n  function getBptIndex() external view returns (uint256);\n  function updateTokenRateCache(address token) external;\n}"
    },
    "contracts/integrations/balancer/ILinearPool.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface ILinearPool {\n  function getPoolId() external view returns (bytes32);\n\n  function getMainIndex() external view returns (uint);\n\n  function getMainToken() external view returns (address);\n\n  function getWrappedIndex() external view returns (uint);\n\n  function getWrappedToken() external view returns (address);\n\n  function getWrappedTokenRate() external view returns (uint);\n\n  function getRate() external view returns (uint);\n\n  function getBptIndex() external pure returns (uint);\n\n  function getVirtualSupply() external view returns (uint);\n\n  function getSwapFeePercentage() external view returns (uint);\n\n  function getTargets() external view returns (uint lowerTarget, uint upperTarget);\n\n  function totalSupply() external view returns (uint);\n\n  function getScalingFactors() external view returns (uint[] memory);\n}"
    },
    "contracts/integrations/tetu-v1/ITetuV1Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ITetuV1Controller {\n\n\n  function VERSION() external view returns (string memory);\n\n  function addHardWorker(address _worker) external;\n\n  function addStrategiesToSplitter(\n    address _splitter,\n    address[] memory _strategies\n  ) external;\n\n  function addStrategy(address _strategy) external;\n\n  function addVaultsAndStrategies(\n    address[] memory _vaults,\n    address[] memory _strategies\n  ) external;\n\n  function announcer() external view returns (address);\n\n  function bookkeeper() external view returns (address);\n\n  function changeWhiteListStatus(address[] memory _targets, bool status)\n  external;\n\n  function controllerTokenMove(\n    address _recipient,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function dao() external view returns (address);\n\n  function distributor() external view returns (address);\n\n  function doHardWork(address _vault) external;\n\n  function feeRewardForwarder() external view returns (address);\n\n  function fund() external view returns (address);\n\n  function fundDenominator() external view returns (uint256);\n\n  function fundKeeperTokenMove(\n    address _fund,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function fundNumerator() external view returns (uint256);\n\n  function fundToken() external view returns (address);\n\n  function governance() external view returns (address);\n\n  function hardWorkers(address) external view returns (bool);\n\n  function initialize() external;\n\n  function isAllowedUser(address _adr) external view returns (bool);\n\n  function isDao(address _adr) external view returns (bool);\n\n  function isHardWorker(address _adr) external view returns (bool);\n\n  function isPoorRewardConsumer(address _adr) external view returns (bool);\n\n  function isRewardDistributor(address _adr) external view returns (bool);\n\n  function isValidStrategy(address _strategy) external view returns (bool);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  function mintAndDistribute(uint256 totalAmount, bool mintAllAvailable)\n  external;\n\n  function mintHelper() external view returns (address);\n\n  function psDenominator() external view returns (uint256);\n\n  function psNumerator() external view returns (uint256);\n\n  function psVault() external view returns (address);\n\n  function pureRewardConsumers(address) external view returns (bool);\n\n  function rebalance(address _strategy) external;\n\n  function removeHardWorker(address _worker) external;\n\n  function rewardDistribution(address) external view returns (bool);\n\n  function rewardToken() external view returns (address);\n\n  function setAnnouncer(address _newValue) external;\n\n  function setBookkeeper(address newValue) external;\n\n  function setDao(address newValue) external;\n\n  function setDistributor(address _distributor) external;\n\n  function setFeeRewardForwarder(address _feeRewardForwarder) external;\n\n  function setFund(address _newValue) external;\n\n  function setFundNumeratorDenominator(uint256 numerator, uint256 denominator)\n  external;\n\n  function setFundToken(address _newValue) external;\n\n  function setGovernance(address newValue) external;\n\n  function setMintHelper(address _newValue) external;\n\n  function setPSNumeratorDenominator(uint256 numerator, uint256 denominator)\n  external;\n\n  function setPsVault(address _newValue) external;\n\n  function setPureRewardConsumers(address[] memory _targets, bool _flag)\n  external;\n\n  function setRewardDistribution(\n    address[] memory _newRewardDistribution,\n    bool _flag\n  ) external;\n\n  function setRewardToken(address _newValue) external;\n\n  function setVaultController(address _newValue) external;\n\n  function setVaultStrategyBatch(\n    address[] memory _vaults,\n    address[] memory _strategies\n  ) external;\n\n  function strategies(address) external view returns (bool);\n\n  function strategyTokenMove(\n    address _strategy,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function upgradeTetuProxyBatch(\n    address[] memory _contracts,\n    address[] memory _implementations\n  ) external;\n\n  function vaultController() external view returns (address);\n\n  function vaults(address) external view returns (bool);\n\n  function whiteList(address) external view returns (bool);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n  /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n  /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n  /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n  function uniswapV3MintCallback(\n    uint256 amount0Owed,\n    uint256 amount1Owed,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport './IUniswapV3PoolImmutables.sol';\nimport './IUniswapV3PoolState.sol';\nimport './IUniswapV3PoolDerivedState.sol';\nimport './IUniswapV3PoolActions.sol';\nimport './IUniswapV3PoolOwnerActions.sol';\nimport './IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\nIUniswapV3PoolImmutables,\nIUniswapV3PoolState,\nIUniswapV3PoolDerivedState,\nIUniswapV3PoolActions,\nIUniswapV3PoolOwnerActions,\nIUniswapV3PoolEvents\n{}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n  /// @notice Sets the initial price for the pool\n  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n  /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n  function initialize(uint160 sqrtPriceX96) external;\n\n  /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n  /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n  /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n  /// @param recipient The address for which the liquidity will be created\n  /// @param tickLower The lower tick of the position in which to add liquidity\n  /// @param tickUpper The upper tick of the position in which to add liquidity\n  /// @param amount The amount of liquidity to mint\n  /// @param data Any data that should be passed through to the callback\n  /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount,\n    bytes calldata data\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Collects tokens owed to a position\n  /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n  /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n  /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n  /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n  /// @param recipient The address which should receive the fees collected\n  /// @param tickLower The lower tick of the position for which to collect fees\n  /// @param tickUpper The upper tick of the position for which to collect fees\n  /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n  /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n  /// @return amount0 The amount of fees collected in token0\n  /// @return amount1 The amount of fees collected in token1\n  function collect(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n\n  /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n  /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n  /// @dev Fees must be collected separately via a call to #collect\n  /// @param tickLower The lower tick of the position for which to burn liquidity\n  /// @param tickUpper The upper tick of the position for which to burn liquidity\n  /// @param amount How much liquidity to burn\n  /// @return amount0 The amount of token0 sent to the recipient\n  /// @return amount1 The amount of token1 sent to the recipient\n  function burn(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Swap token0 for token1, or token1 for token0\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n  /// @param recipient The address to receive the output of the swap\n  /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n  /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n  /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n  /// @param data Any data to be passed through to the callback\n  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n  /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n  /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n  /// @param recipient The address which will receive the token0 and token1 amounts\n  /// @param amount0 The amount of token0 to send\n  /// @param amount1 The amount of token1 to send\n  /// @param data Any data to be passed through to the callback\n  function flash(\n    address recipient,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n\n  /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n  /// you must call it with secondsAgos = [3600, 0].\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n  /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n  /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n  /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n  /// timestamp\n  function observe(uint32[] calldata secondsAgos)\n  external\n  view\n  returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n  /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n  /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n  /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n  /// snapshot is taken and the second snapshot is taken.\n  /// @param tickLower The lower tick of the range\n  /// @param tickUpper The upper tick of the range\n  /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n  /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n  /// @return secondsInside The snapshot of seconds per liquidity for the range\n  function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n  external\n  view\n  returns (\n    int56 tickCumulativeInside,\n    uint160 secondsPerLiquidityInsideX128,\n    uint32 secondsInside\n  );\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n  /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n  /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n  /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n  event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n  /// @notice Emitted when liquidity is minted for a given position\n  /// @param sender The address that minted the liquidity\n  /// @param owner The owner of the position and recipient of any minted liquidity\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity minted to the position range\n  /// @param amount0 How much token0 was required for the minted liquidity\n  /// @param amount1 How much token1 was required for the minted liquidity\n  event Mint(\n    address sender,\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted when fees are collected by the owner of a position\n  /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n  /// @param owner The owner of the position for which fees are collected\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount0 The amount of token0 fees collected\n  /// @param amount1 The amount of token1 fees collected\n  event Collect(\n    address indexed owner,\n    address recipient,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount0,\n    uint128 amount1\n  );\n\n  /// @notice Emitted when a position's liquidity is removed\n  /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n  /// @param owner The owner of the position for which liquidity is removed\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity to remove\n  /// @param amount0 The amount of token0 withdrawn\n  /// @param amount1 The amount of token1 withdrawn\n  event Burn(\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted by the pool for any swaps between token0 and token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the output of the swap\n  /// @param amount0 The delta of the token0 balance of the pool\n  /// @param amount1 The delta of the token1 balance of the pool\n  /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n  /// @param liquidity The liquidity of the pool after the swap\n  /// @param tick The log base 1.0001 of price of the pool after the swap\n  event Swap(\n    address indexed sender,\n    address indexed recipient,\n    int256 amount0,\n    int256 amount1,\n    uint160 sqrtPriceX96,\n    uint128 liquidity,\n    int24 tick\n  );\n\n  /// @notice Emitted by the pool for any flashes of token0/token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the tokens from flash\n  /// @param amount0 The amount of token0 that was flashed\n  /// @param amount1 The amount of token1 that was flashed\n  /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n  /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n  event Flash(\n    address indexed sender,\n    address indexed recipient,\n    uint256 amount0,\n    uint256 amount1,\n    uint256 paid0,\n    uint256 paid1\n  );\n\n  /// @notice Emitted by the pool for increases to the number of observations that can be stored\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n  /// just before a mint/swap/burn.\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(\n    uint16 observationCardinalityNextOld,\n    uint16 observationCardinalityNextNew\n  );\n\n  /// @notice Emitted when the protocol fee is changed by the pool\n  /// @param feeProtocol0Old The previous value of the token0 protocol fee\n  /// @param feeProtocol1Old The previous value of the token1 protocol fee\n  /// @param feeProtocol0New The updated value of the token0 protocol fee\n  /// @param feeProtocol1New The updated value of the token1 protocol fee\n  event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n  /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n  /// @param sender The address that collects the protocol fees\n  /// @param recipient The address that receives the collected protocol fees\n  /// @param amount0 The amount of token0 protocol fees that is withdrawn\n  /// @param amount0 The amount of token1 protocol fees that is withdrawn\n  event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n  /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n  /// @return The contract address\n  function factory() external view returns (address);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (address);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (address);\n\n  /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n  /// @return The fee\n  function fee() external view returns (uint24);\n\n  /// @notice The pool tick spacing\n  /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n  /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n  /// This value is an int24 to avoid casting even though it is always positive.\n  /// @return The tick spacing\n  function tickSpacing() external view returns (int24);\n\n  /// @notice The maximum amount of position liquidity that can use any tick in the range\n  /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n  /// @notice Set the denominator of the protocol's % share of the fees\n  /// @param feeProtocol0 new protocol fee for token0 of the pool\n  /// @param feeProtocol1 new protocol fee for token1 of the pool\n  function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n  /// @notice Collect the protocol fee accrued to the pool\n  /// @param recipient The address to which collected protocol fees should be sent\n  /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n  /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n  /// @return amount0 The protocol fee collected in token0\n  /// @return amount1 The protocol fee collected in token1\n  function collectProtocol(\n    address recipient,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n  /// when accessed externally.\n  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n  /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n  /// boundary.\n  /// observationIndex The index of the last oracle observation that was written,\n  /// observationCardinality The current maximum number of observations stored in the pool,\n  /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n  /// feeProtocol The protocol fee for both tokens of the pool.\n  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n  /// unlocked Whether the pool is currently locked to reentrancy\n  function slot0()\n  external\n  view\n  returns (\n    uint160 sqrtPriceX96,\n    int24 tick,\n    uint16 observationIndex,\n    uint16 observationCardinality,\n    uint16 observationCardinalityNext,\n    uint8 feeProtocol,\n    bool unlocked\n  );\n\n  /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal0X128() external view returns (uint256);\n\n  /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal1X128() external view returns (uint256);\n\n  /// @notice The amounts of token0 and token1 that are owed to the protocol\n  /// @dev Protocol fees will never exceed uint128 max in either token\n  function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n  /// @notice The currently in range liquidity available to the pool\n  /// @dev This value has no relationship to the total liquidity across all ticks\n  function liquidity() external view returns (uint128);\n\n  /// @notice Look up information about a specific tick in the pool\n  /// @param tick The tick to look up\n  /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n  /// tick upper,\n  /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n  /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n  /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n  /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n  /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n  /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n  /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n  /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n  /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n  /// a specific position.\n  function ticks(int24 tick)\n  external\n  view\n  returns (\n    uint128 liquidityGross,\n    int128 liquidityNet,\n    uint256 feeGrowthOutside0X128,\n    uint256 feeGrowthOutside1X128,\n    int56 tickCumulativeOutside,\n    uint160 secondsPerLiquidityOutsideX128,\n    uint32 secondsOutside,\n    bool initialized\n  );\n\n  /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n  function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n  /// @notice Returns the information about a position by the position's key\n  /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n  /// @return _liquidity The amount of liquidity in the position,\n  /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n  /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n  /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n  /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n  function positions(bytes32 key)\n  external\n  view\n  returns (\n    uint128 _liquidity,\n    uint256 feeGrowthInside0LastX128,\n    uint256 feeGrowthInside1LastX128,\n    uint128 tokensOwed0,\n    uint128 tokensOwed1\n  );\n\n  /// @notice Returns data about a specific observation index\n  /// @param index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return blockTimestamp The timestamp of the observation,\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\n  function observations(uint256 index)\n  external\n  view\n  returns (\n    uint32 blockTimestamp,\n    int56 tickCumulative,\n    uint160 secondsPerLiquidityCumulativeX128,\n    bool initialized\n  );\n}\n"
    },
    "contracts/interfaces/IRebalancingStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IRebalancingStrategy {\n    function needRebalance() external view returns (bool);\n    function rebalance() external;\n}\n"
    },
    "contracts/libs/AppErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice List of all errors generated by the application\n///         Each error should have unique code TS-XXX and descriptive comment\nlibrary AppErrors {\n  /// @notice Provided address should be not zero\n  string public constant ZERO_ADDRESS = \"TS-1 zero address\";\n\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\n  string public constant UNISWAP_PAIR_NOT_FOUND = \"TS-2 pair not found\";\n\n  /// @notice Lengths not matched\n  string public constant WRONG_LENGTHS = \"TS-4 wrong lengths\";\n\n  /// @notice Unexpected zero balance\n  string public constant ZERO_BALANCE = \"TS-5 zero balance\";\n\n  string public constant ITEM_NOT_FOUND = \"TS-6 not found\";\n\n  string public constant NOT_ENOUGH_BALANCE = \"TS-7 not enough balance\";\n\n  /// @notice Price oracle returns zero price\n  string public constant ZERO_PRICE = \"TS-8 zero price\";\n\n  string public constant WRONG_VALUE = \"TS-9 wrong value\";\n\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\n  string public constant ZERO_AMOUNT_BORROWED = \"TS-10 zero borrowed amount\";\n\n  string public constant WITHDRAW_TOO_MUCH = \"TS-11 try to withdraw too much\";\n\n  string public constant UNKNOWN_ENTRY_KIND = \"TS-12 unknown entry kind\";\n\n  string public constant ONLY_TETU_CONVERTER = \"TS-13 only TetuConverter\";\n\n  string public constant WRONG_ASSET = \"TS-14 wrong asset\";\n\n  string public constant NO_LIQUIDATION_ROUTE = \"TS-15 No liquidation route\";\n\n  string public constant PRICE_IMPACT = \"TS-16 price impact\";\n\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\n  string public constant REPAY_MAKES_SWAP = \"TS-17 can not convert back\";\n\n  string public constant NO_INVESTMENTS = \"TS-18 no investments\";\n\n  string public constant INCORRECT_LENGTHS = \"TS-19 lengths\";\n\n  /// @notice We expect increasing of the balance, but it was decreased\n  string public constant BALANCE_DECREASE = \"TS-20 balance decrease\";\n\n  /// @notice Prices changed and invested assets amount was increased on S, value of S is too high\n  string public constant EARNED_AMOUNT_TOO_HIGH = \"TS-21 earned too high\";\n\n  string public constant GOVERNANCE_ONLY = \"TS-22 governance only\";\n}\n"
    },
    "contracts/libs/AppLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\n/// @notice Common internal utils\nlibrary AppLib {\n  using SafeERC20 for IERC20;\n\n  /// @notice Unchecked increment for for-cycles\n  function uncheckedInc(uint i) internal pure returns (uint) {\n    unchecked {\n      return i + 1;\n    }\n  }\n\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\n  /// @dev Should NOT be used for third-party pools\n  function approveIfNeeded(address token, uint amount, address spender) internal {\n    if (IERC20(token).allowance(address(this), spender) < amount) {\n      IERC20(token).safeApprove(spender, 0);\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\n      IERC20(token).safeApprove(spender, 2 ** 255);\n    }\n  }\n\n  function balance(address token) internal view returns (uint) {\n    return IERC20(token).balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/libs/AppPlatforms.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary AppPlatforms {\n  string public constant UNIV3 = \"UniswapV3\";\n  string public constant BALANCER = \"Balancer\";\n  string public constant ALGEBRA = \"Algebra\";\n}\n"
    },
    "contracts/libs/ConverterEntryKinds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\nlibrary ConverterEntryKinds {\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\n\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\n  ///         C2 should be used as collateral to make a borrow B.\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\n\n  /// @notice Borrow given amount using min possible collateral\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\n\n  /// @notice Decode entryData, extract first uint - entry kind\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\n    if (entryData_.length == 0) {\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\n    }\n    return abi.decode(entryData_, (uint));\n  }\n}\n"
    },
    "contracts/libs/TokenAmountsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AppErrors.sol\";\n\n/// @title Library for clearing / joining token addresses & amounts arrays\n/// @author bogdoslav\nlibrary TokenAmountsLib {\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \"1.0.1\";\n\n  function uncheckedInc(uint i) internal pure returns (uint) {\n    unchecked {\n      return i + 1;\n    }\n  }\n\n  function filterZeroAmounts(\n    address[] memory tokens,\n    uint[] memory amounts\n  ) internal pure returns (\n    address[] memory t,\n    uint[] memory a\n  ) {\n    require(tokens.length == amounts.length, AppErrors.INCORRECT_LENGTHS);\n    uint len2 = 0;\n    uint len = tokens.length;\n    for (uint i = 0; i < len; i++) {\n      if (amounts[i] != 0) len2++;\n    }\n\n    t = new address[](len2);\n    a = new uint[](len2);\n\n    uint j = 0;\n    for (uint i = 0; i < len; i++) {\n      uint amount = amounts[i];\n      if (amount != 0) {\n        t[j] = tokens[i];\n        a[j] = amount;\n        j++;\n      }\n    }\n  }\n\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\n  function combineArrays(\n    address[] memory tokens0,\n    uint[] memory amounts0,\n    address[] memory tokens1,\n    uint[] memory amounts1,\n    address[] memory tokens2,\n    uint[] memory amounts2\n  ) internal pure returns (\n    address[] memory allTokens,\n    uint[] memory allAmounts\n  ) {\n    uint[] memory lens = new uint[](3);\n    lens[0] = tokens0.length;\n    lens[1] = tokens1.length;\n    lens[2] = tokens2.length;\n\n    require(\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\n      AppErrors.INCORRECT_LENGTHS\n    );\n\n    uint maxLength = lens[0] + lens[1] + lens[2];\n    address[] memory tokensOut = new address[](maxLength);\n    uint[] memory amountsOut = new uint[](maxLength);\n    uint unitedLength;\n\n    for (uint step; step < 3; ++step) {\n      uint[] memory amounts = step == 0\n        ? amounts0\n        : (step == 1\n          ? amounts1\n          : amounts2);\n      address[] memory tokens = step == 0\n        ? tokens0\n        : (step == 1\n          ? tokens1\n          : tokens2);\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\n        uint amount1 = amounts[i1];\n        address token1 = tokens[i1];\n        bool united = false;\n\n        for (uint i = 0; i < unitedLength; i++) {\n          if (token1 == tokensOut[i]) {\n            amountsOut[i] += amount1;\n            united = true;\n            break;\n          }\n        }\n\n        if (!united) {\n          tokensOut[unitedLength] = token1;\n          amountsOut[unitedLength] = amount1;\n          unitedLength++;\n        }\n      }\n    }\n\n    // copy united tokens to result array\n    allTokens = new address[](unitedLength);\n    allAmounts = new uint[](unitedLength);\n    for (uint i; i < unitedLength; i++) {\n      allTokens[i] = tokensOut[i];\n      allAmounts[i] = amountsOut[i];\n    }\n\n  }\n}\n"
    },
    "contracts/strategies/algebra/AlgebraConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./AlgebraDepositor.sol\";\nimport \"./AlgebraConverterStrategyLogicLib.sol\";\nimport \"../../libs/AppPlatforms.sol\";\nimport \"../../interfaces/IRebalancingStrategy.sol\";\nimport \"./AlgebraStrategyErrors.sol\";\n\n\ncontract AlgebraConverterStrategy is AlgebraDepositor, ConverterStrategyBase, IRebalancingStrategy {\n\n    /////////////////////////////////////////////////////////////////////\n    ///                CONSTANTS\n    /////////////////////////////////////////////////////////////////////\n\n    string public constant override NAME = \"Algebra Converter Strategy\";\n    string public constant override PLATFORM = AppPlatforms.ALGEBRA;\n    string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n    /////////////////////////////////////////////////////////////////////\n    ///                INIT\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice Initialize the strategy with the given parameters.\n    /// @param controller_ The address of the controller.\n    /// @param splitter_ The address of the splitter.\n    /// @param converter_ The address of the converter.\n    /// @param pool_ The address of the pool.\n    /// @param tickRange_ The tick range for the liquidity position.\n    /// @param rebalanceTickRange_ The tick range for rebalancing.\n    function init(\n        address controller_,\n        address splitter_,\n        address converter_,\n        address pool_,\n        int24 tickRange_,\n        int24 rebalanceTickRange_,\n        bool isStablePool,\n        IncentiveKey memory key\n    ) external initializer {\n        __ConverterStrategyBase_init(controller_, splitter_, converter_);\n        AlgebraConverterStrategyLogicLib.initStrategyState(\n            state,\n            controller_,\n            converter_,\n            pool_,\n            tickRange_,\n            rebalanceTickRange_,\n            ISplitter(splitter_).asset(),\n            isStablePool\n        );\n\n        AlgebraConverterStrategyLogicLib.initFarmingState(\n            state,\n            key\n        );\n\n        // setup specific name for UI\n        strategySpecificName = AlgebraConverterStrategyLogicLib.createSpecificName(state);\n        emit StrategyLib.StrategySpecificNameChanged(strategySpecificName);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    ///                OPERATOR ACTIONS\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice Disable fuse for the strategy.\n    function disableFuse() external {\n        StrategyLib.onlyOperators(controller());\n        state.isFuseTriggered = false;\n        state.lastPrice = AlgebraConverterStrategyLogicLib.getOracleAssetsPrice(converter, state.tokenA, state.tokenB);\n\n        AlgebraConverterStrategyLogicLib.emitDisableFuse();\n    }\n\n    /// @notice Set the fuse threshold for the strategy.\n    /// @param newFuseThreshold The new fuse threshold value.\n    function setFuseThreshold(uint newFuseThreshold) external {\n        StrategyLib.onlyOperators(controller());\n        state.fuseThreshold = newFuseThreshold;\n\n        AlgebraConverterStrategyLogicLib.emitNewFuseThreshold(newFuseThreshold);\n    }\n\n    function setStrategyProfitHolder(address strategyProfitHolder) external {\n        StrategyLib.onlyOperators(controller());\n        state.strategyProfitHolder = strategyProfitHolder;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    ///                   METRIC VIEWS\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice Check if the strategy is ready for hard work.\n    /// @return A boolean indicating if the strategy is ready for hard work.\n    function isReadyToHardWork() override external virtual view returns (bool) {\n        return AlgebraConverterStrategyLogicLib.isReadyToHardWork(state, converter, controller());\n    }\n\n    /// @notice Check if the strategy needs rebalancing.\n    /// @return A boolean indicating if the strategy needs rebalancing.\n    function needRebalance() public view returns (bool) {\n        return AlgebraConverterStrategyLogicLib.needRebalance(state);\n    }\n\n    /// @return swapAtoB, swapAmount\n    function quoteRebalanceSwap() external returns (bool, uint) {\n        return AlgebraConverterStrategyLogicLib.quoteRebalanceSwap(state, converter);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    ///                   CALLBACKS\n    /////////////////////////////////////////////////////////////////////\n\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) external pure returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    ///                   REBALANCE\n    /////////////////////////////////////////////////////////////////////\n\n    /// @dev The rebalancing functionality is the core of this strategy.\n    ///      Swap method is used.\n    function rebalance() external {\n        address _controller = controller();\n        StrategyLib.onlyOperators(_controller);\n\n        (, uint profitToCover) = _fixPriceChanges(true);\n        uint oldTotalAssets = totalAssets() - profitToCover;\n\n        /// withdraw all liquidity from pool with adding calculated fees to rebalanceEarned0, rebalanceEarned1\n        /// after disableFuse() liquidity is zero\n        if (state.totalLiquidity > 0) {\n            _depositorEmergencyExit();\n        }\n\n        // _depositorEnter(tokenAmounts) if length == 2\n        uint[] memory tokenAmounts = AlgebraConverterStrategyLogicLib.rebalance(\n            state,\n            converter,\n            _controller,\n            oldTotalAssets,\n            profitToCover,\n            splitter\n        );\n\n        if (tokenAmounts.length == 2) {\n            _depositorEnter(tokenAmounts);\n        }\n\n        //updating investedAssets based on new baseAmounts\n        _updateInvestedAssets();\n    }\n\n    function rebalanceSwapByAgg(bool direction, uint amount, address agg, bytes memory swapData) external {\n        address _controller = controller();\n        StrategyLib.onlyOperators(_controller);\n\n        (, uint profitToCover) = _fixPriceChanges(true);\n        uint oldTotalAssets = totalAssets() - profitToCover;\n\n        /// withdraw all liquidity from pool with adding calculated fees to rebalanceEarned0, rebalanceEarned1\n        /// after disableFuse() liquidity is zero\n        if (state.totalLiquidity > 0) {\n            _depositorEmergencyExit();\n        }\n\n        // _depositorEnter(tokenAmounts) if length == 2\n        uint[] memory tokenAmounts = AlgebraConverterStrategyLogicLib.rebalanceSwapByAgg(\n            state,\n            converter,\n            oldTotalAssets,\n            AlgebraConverterStrategyLogicLib.RebalanceSwapByAggParams(\n                direction,\n                amount,\n                agg,\n                swapData\n            ),\n            profitToCover,\n            splitter\n        );\n\n        if (tokenAmounts.length == 2) {\n            _depositorEnter(tokenAmounts);\n        }\n\n        //updating investedAssets based on new baseAmounts\n        _updateInvestedAssets();\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    ///                   INTERNAL LOGIC\n    /////////////////////////////////////////////////////////////////////\n\n    function _beforeDeposit(\n        ITetuConverter tetuConverter_,\n        uint amount_,\n        address[] memory /*tokens_*/,\n        uint /*indexAsset_*/\n    ) override internal virtual returns (\n        uint[] memory tokenAmounts\n    ) {\n        require(!needRebalance(), AlgebraStrategyErrors.NEED_REBALANCE);\n\n        tokenAmounts = new uint[](2);\n        uint spentCollateral;\n\n        bytes memory entryData = AlgebraConverterStrategyLogicLib.getEntryData(\n            state.pool,\n            state.lowerTick,\n            state.upperTick,\n            state.depositorSwapTokens\n        );\n\n        AppLib.approveIfNeeded(state.tokenA, amount_, address(tetuConverter_));\n        (spentCollateral, tokenAmounts[1]) = ConverterStrategyBaseLib.openPosition(\n            tetuConverter_,\n            entryData,\n            state.tokenA,\n            state.tokenB,\n            amount_,\n            0\n        );\n\n        tokenAmounts[0] = amount_ - spentCollateral;\n    }\n\n    /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n    /// @return earned The amount of earned rewards.\n    /// @return lost The amount of lost rewards.\n    /// @return assetBalanceAfterClaim The asset balance after claiming rewards.\n    function _handleRewards() override internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n        (address[] memory rewardTokens, uint[] memory amounts) = _claim();\n        earned = AlgebraConverterStrategyLogicLib.calcEarned(state.tokenA, controller(), rewardTokens, amounts);\n        _rewardsLiquidation(rewardTokens, amounts);\n        return (earned, lost, AppLib.balance(asset));\n    }\n\n    /// @notice Deposit given amount to the pool.\n    /// @param amount_ The amount to be deposited.\n    /// @param updateTotalAssetsBeforeInvest_ A boolean indicating if the total assets should be updated before investing.\n    /// @return strategyLoss Loss should be covered from Insurance\n    function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n        uint strategyLoss\n    ) {\n        if (state.isFuseTriggered) {\n            uint[] memory tokenAmounts = new uint[](2);\n            tokenAmounts[0] = amount_;\n            emit OnDepositorEnter(tokenAmounts, tokenAmounts);\n            return 0;\n        } else {\n            return super._depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n        }\n    }\n\n    function _beforeWithdraw(uint /*amount*/) internal view override {\n        require(!needRebalance(), AlgebraStrategyErrors.NEED_REBALANCE);\n    }\n}\n"
    },
    "contracts/strategies/algebra/AlgebraConverterStrategyLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AlgebraLib.sol\";\nimport \"./AlgebraDebtLib.sol\";\nimport \"./AlgebraStrategyErrors.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\nlibrary AlgebraConverterStrategyLogicLib {\n    using SafeERC20 for IERC20;\n\n    //////////////////////////////////////////\n    //            CONSTANTS\n    //////////////////////////////////////////\n\n    uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_STABLE = 300;\n    uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE = 500;\n    uint internal constant HARD_WORK_USD_FEE_THRESHOLD = 100;\n    /// @dev 0.5% by default\n    uint internal constant DEFAULT_FUSE_THRESHOLD = 5e15;\n    INonfungiblePositionManager internal constant ALGEBRA_NFT = INonfungiblePositionManager(0x8eF88E4c7CfbbaC1C163f7eddd4B578792201de6);\n    IFarmingCenter internal constant FARMING_CENTER = IFarmingCenter(0x7F281A8cdF66eF5e9db8434Ec6D97acc1bc01E78);\n\n    //////////////////////////////////////////\n    //            EVENTS\n    //////////////////////////////////////////\n\n    event FuseTriggered();\n    event Rebalanced(uint loss);\n    event DisableFuse();\n    event NewFuseThreshold(uint newFuseThreshold);\n    event AlgebraFeesClaimed(uint fee0, uint fee1);\n    event AlgebraRewardsClaimed(uint reward, uint bonusReward);\n\n    //////////////////////////////////////////\n    //            STRUCTURES\n    //////////////////////////////////////////\n\n    struct State {\n        address strategyProfitHolder;\n        address tokenA;\n        address tokenB;\n        IAlgebraPool pool;\n        int24 tickSpacing;\n        bool isStablePool;\n        int24 lowerTick;\n        int24 upperTick;\n        int24 rebalanceTickRange;\n        bool depositorSwapTokens;\n        uint128 totalLiquidity;\n        bool isFuseTriggered;\n        uint fuseThreshold;\n        uint lastPrice;\n        uint tokenId;\n        // farming\n        address rewardToken;\n        address bonusRewardToken;\n        uint256 startTime;\n        uint256 endTime;\n    }\n\n    struct RebalanceSwapByAggParams {\n        bool direction;\n        uint amount;\n        address agg;\n        bytes swapData;\n    }\n\n    struct RebalanceLocalVariables {\n        int24 upperTick;\n        int24 lowerTick;\n        int24 tickSpacing;\n        IAlgebraPool pool;\n        address tokenA;\n        address tokenB;\n        uint lastPrice;\n        uint fuseThreshold;\n        bool depositorSwapTokens;\n        uint notCoveredLoss;\n        int24 newLowerTick;\n        int24 newUpperTick;\n        bool isStablePool;\n        uint newPrice;\n        uint newTotalAssets;\n    }\n\n    //////////////////////////////////////////\n    //            HELPERS\n    //////////////////////////////////////////\n\n    function emitDisableFuse() external {\n        emit DisableFuse();\n    }\n\n    function emitNewFuseThreshold(uint value) external {\n        emit NewFuseThreshold(value);\n    }\n\n    /// @notice Check if the fuse is enabled based on the price difference and fuse threshold.\n    /// @param oldPrice The old price.\n    /// @param newPrice The new price.\n    /// @param fuseThreshold The fuse threshold.\n    /// @return A boolean indicating if the fuse is enabled.\n    function isEnableFuse(uint oldPrice, uint newPrice, uint fuseThreshold) internal pure returns (bool) {\n        return oldPrice > newPrice ? (oldPrice - newPrice) > fuseThreshold : (newPrice - oldPrice) > fuseThreshold;\n    }\n\n    function initStrategyState(\n        State storage state,\n        address controller_,\n        address converter,\n        address pool,\n        int24 tickRange,\n        int24 rebalanceTickRange,\n        address asset_,\n        bool isStablePool\n    ) external {\n        require(pool != address(0), AppErrors.ZERO_ADDRESS);\n        state.pool = IAlgebraPool(pool);\n\n        state.isStablePool = isStablePool;\n\n        state.rebalanceTickRange = rebalanceTickRange;\n\n        _setInitialDepositorValues(\n            state,\n            IAlgebraPool(pool),\n            tickRange,\n            rebalanceTickRange,\n            asset_\n        );\n\n        address liquidator = IController(controller_).liquidator();\n        address tokenA = state.tokenA;\n        address tokenB = state.tokenB;\n        IERC20(tokenA).approve(liquidator, type(uint).max);\n        IERC20(tokenB).approve(liquidator, type(uint).max);\n        IERC20(tokenA).approve(address(ALGEBRA_NFT), type(uint).max);\n        IERC20(tokenB).approve(address(ALGEBRA_NFT), type(uint).max);\n\n        if (isStablePool) {\n            /// for stable pools fuse can be enabled\n            state.fuseThreshold = DEFAULT_FUSE_THRESHOLD;\n            emit NewFuseThreshold(DEFAULT_FUSE_THRESHOLD);\n            state.lastPrice = getOracleAssetsPrice(ITetuConverter(converter), tokenA, tokenB);\n        }\n    }\n\n    function initFarmingState(\n        State storage state,\n        IncentiveKey calldata key\n    ) external {\n        state.rewardToken = key.rewardToken;\n        state.bonusRewardToken = key.bonusRewardToken;\n        state.startTime = key.startTime;\n        state.endTime = key.endTime;\n    }\n\n    function createSpecificName(State storage state) external view returns (string memory) {\n        return string(abi.encodePacked(\"Algebra \", IERC20Metadata(state.tokenA).symbol(), \"/\", IERC20Metadata(state.tokenB).symbol()));\n    }\n\n    /// @notice Get the price ratio of the two given tokens from the oracle.\n    /// @param converter The Tetu converter.\n    /// @param tokenA The first token address.\n    /// @param tokenB The second token address.\n    /// @return The price ratio of the two tokens.\n    function getOracleAssetsPrice(ITetuConverter converter, address tokenA, address tokenB) public view returns (uint) {\n        IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n        uint priceA = oracle.getAssetPrice(tokenA);\n        uint priceB = oracle.getAssetPrice(tokenB);\n        return priceB * 1e18 / priceA;\n    }\n\n    function getIncentiveKey(State storage state) internal view returns(IncentiveKey memory) {\n        return IncentiveKey(state.rewardToken, state.bonusRewardToken, address(state.pool), state.startTime, state.endTime);\n    }\n\n    function getFees(State storage state) public view returns (uint fee0, uint fee1) {\n        (fee0, fee1) = AlgebraLib.getFees(state.pool, ALGEBRA_NFT, state.tokenId);\n    }\n\n    function getPoolReserves(State storage state) external view returns (uint[] memory reserves) {\n        reserves = new uint[](2);\n        (uint160 sqrtRatioX96, , , , , ,) = state.pool.globalState();\n\n        (reserves[0], reserves[1]) = AlgebraLib.getAmountsForLiquidity(\n            sqrtRatioX96,\n            state.lowerTick,\n            state.upperTick,\n            state.totalLiquidity\n        );\n\n        if (state.depositorSwapTokens) {\n            (reserves[0], reserves[1]) = (reserves[1], reserves[0]);\n        }\n    }\n\n    /// @dev Gets the liquidator swap slippage based on the pool type (stable or volatile).\n    /// @return The liquidator swap slippage percentage.\n    function _getLiquidatorSwapSlippage(bool isStablePool) internal pure returns (uint) {\n        return isStablePool ? LIQUIDATOR_SWAP_SLIPPAGE_STABLE : LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE;\n    }\n\n    //////////////////////////////////////////\n    //            Pool info\n    //////////////////////////////////////////\n\n    function getEntryData(\n        IAlgebraPool pool,\n        int24 lowerTick,\n        int24 upperTick,\n        bool depositorSwapTokens\n    ) public view returns (bytes memory entryData) {\n        return AlgebraDebtLib.getEntryData(pool, lowerTick, upperTick, depositorSwapTokens);\n    }\n\n    //////////////////////////////////////////\n    //            CALCULATIONS\n    //////////////////////////////////////////\n\n    /// @notice Calculate and set the initial values for a QuickSwap V3 pool Depositor.\n    /// @param state Depositor storage state struct\n    /// @param pool The QuickSwap V3 pool to get the initial values from.\n    /// @param tickRange_ The tick range for the pool.\n    /// @param rebalanceTickRange_ The rebalance tick range for the pool.\n    /// @param asset_ Underlying asset of the depositor.\n    function _setInitialDepositorValues(\n        State storage state,\n        IAlgebraPool pool,\n        int24 tickRange_,\n        int24 rebalanceTickRange_,\n        address asset_\n    ) internal {\n        int24 tickSpacing = AlgebraLib.tickSpacing();\n        if (tickRange_ != 0) {\n            require(tickRange_ == tickRange_ / tickSpacing * tickSpacing, AlgebraStrategyErrors.INCORRECT_TICK_RANGE);\n            require(rebalanceTickRange_ == rebalanceTickRange_ / tickSpacing * tickSpacing, AlgebraStrategyErrors.INCORRECT_REBALANCE_TICK_RANGE);\n        }\n        state.tickSpacing = tickSpacing;\n        (state.lowerTick, state.upperTick) = AlgebraDebtLib.calcTickRange(pool, tickRange_, tickSpacing);\n        require(asset_ == pool.token0() || asset_ == pool.token1(), AlgebraStrategyErrors.INCORRECT_ASSET);\n        if (asset_ == pool.token0()) {\n            state.tokenA = pool.token0();\n            state.tokenB = pool.token1();\n            state.depositorSwapTokens = false;\n        } else {\n            state.tokenA = pool.token1();\n            state.tokenB = pool.token0();\n            state.depositorSwapTokens = true;\n        }\n    }\n\n    //////////////////////////////////////////\n    //            Joins to the pool\n    //////////////////////////////////////////\n\n    function enter(\n        State storage state,\n        uint[] memory amountsDesired_\n    ) external returns (uint[] memory amountsConsumed, uint liquidityOut) {\n        bool depositorSwapTokens = state.depositorSwapTokens;\n        (address token0, address token1) = depositorSwapTokens ? (state.tokenB, state.tokenA) : (state.tokenA, state.tokenB);\n        if (depositorSwapTokens) {\n            (amountsDesired_[0], amountsDesired_[1]) = (amountsDesired_[1], amountsDesired_[0]);\n        }\n        amountsConsumed = new uint[](2);\n        uint128 liquidity;\n        uint tokenId = state.tokenId;\n        int24 lowerTick = state.lowerTick;\n        int24 upperTick = state.upperTick;\n\n        if (tokenId > 0) {\n            (,,,,int24 nftLowerTick, int24 nftUpperTick,,,,,) = ALGEBRA_NFT.positions(tokenId);\n            if (nftLowerTick != lowerTick || nftUpperTick != upperTick) {\n                ALGEBRA_NFT.burn(tokenId);\n                tokenId = 0;\n            }\n        }\n\n        if (tokenId == 0) {\n            (tokenId, liquidity, amountsConsumed[0], amountsConsumed[1]) = ALGEBRA_NFT.mint(INonfungiblePositionManager.MintParams(\n                    token0,\n                    token1,\n                    lowerTick,\n                    upperTick,\n                    amountsDesired_[0],\n                    amountsDesired_[1],\n                    0,\n                    0,\n                    address(this),\n                    block.timestamp\n                ));\n\n            state.tokenId = tokenId;\n\n            ALGEBRA_NFT.safeTransferFrom(address(this), address(FARMING_CENTER), tokenId);\n            FARMING_CENTER.enterFarming(IncentiveKey(state.rewardToken, state.bonusRewardToken, address(state.pool), state.startTime, state.endTime), tokenId, 0, false);\n        } else {\n            (liquidity, amountsConsumed[0], amountsConsumed[1]) = ALGEBRA_NFT.increaseLiquidity(INonfungiblePositionManager.IncreaseLiquidityParams(\n                    tokenId,\n                    amountsDesired_[0],\n                    amountsDesired_[1],\n                    0,\n                    0,\n                    block.timestamp\n                ));\n\n            if (state.totalLiquidity == 0) {\n                ALGEBRA_NFT.safeTransferFrom(address(this), address(FARMING_CENTER), tokenId);\n                FARMING_CENTER.enterFarming(IncentiveKey(state.rewardToken, state.bonusRewardToken, address(state.pool), state.startTime, state.endTime), tokenId, 0, false);\n            }\n        }\n\n        state.totalLiquidity += liquidity;\n        liquidityOut = uint(liquidity);\n    }\n\n    //////////////////////////////////////////\n    //            Exit from the pool\n    //////////////////////////////////////////\n\n    function exit(\n        State storage state,\n        uint128 liquidityAmountToExit\n    ) external returns (uint[] memory amountsOut) {\n        amountsOut = new uint[](2);\n        address strategyProfitHolder = state.strategyProfitHolder;\n        IncentiveKey memory key = getIncentiveKey(state);\n\n        uint128 liquidity = state.totalLiquidity;\n\n        require(liquidity >= liquidityAmountToExit, AlgebraStrategyErrors.WRONG_LIQUIDITY);\n\n        uint tokenId = state.tokenId;\n\n        // get reward amounts\n        (uint reward, uint bonusReward) = FARMING_CENTER.collectRewards(key, tokenId);\n\n        // exit farming (undeposit)\n        FARMING_CENTER.exitFarming(getIncentiveKey(state), state.tokenId, false);\n\n        // claim rewards and send to profit holder\n        {\n            if (reward > 0) {\n                address token = state.rewardToken;\n                FARMING_CENTER.claimReward(token, address(this), 0, reward);\n                IERC20(token).safeTransfer(strategyProfitHolder, reward);\n            }\n            if (bonusReward > 0) {\n                address token = state.bonusRewardToken;\n                FARMING_CENTER.claimReward(token, address(this), 0, bonusReward);\n                IERC20(token).safeTransfer(strategyProfitHolder, bonusReward);\n            }\n        }\n\n        // withdraw nft\n        FARMING_CENTER.withdrawToken(tokenId, address(this), '');\n\n        // burn liquidity\n        (amountsOut[0], amountsOut[1]) = ALGEBRA_NFT.decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams(tokenId, liquidityAmountToExit, 0, 0, block.timestamp));\n\n        {\n            // collect tokens and fee\n            (uint collected0, uint collected1) = ALGEBRA_NFT.collect(INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max));\n\n            uint fee0 = collected0 > amountsOut[0] ? (collected0 - amountsOut[0]) : 0;\n            uint fee1 = collected1 > amountsOut[1] ? (collected1 - amountsOut[1]) : 0;\n\n            emit AlgebraFeesClaimed(fee0, fee1);\n\n            if (state.depositorSwapTokens) {\n                (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n                (fee0, fee1) = (fee1, fee0);\n            }\n\n            // send fees to profit holder\n            if (fee0 > 0) {\n                IERC20(state.tokenA).safeTransfer(strategyProfitHolder, fee0);\n            }\n            if (fee1 > 0) {\n                IERC20(state.tokenB).safeTransfer(strategyProfitHolder, fee1);\n            }\n        }\n\n        liquidity -= liquidityAmountToExit;\n        state.totalLiquidity = liquidity;\n\n        if (liquidity > 0) {\n            ALGEBRA_NFT.safeTransferFrom(address(this), address(FARMING_CENTER), tokenId);\n            FARMING_CENTER.enterFarming(key, tokenId, 0, false);\n        }\n    }\n\n    function quoteExit(\n        State storage state,\n        uint128 liquidityAmountToExit\n    ) public view returns (uint[] memory amountsOut) {\n        (uint160 sqrtRatioX96, , , , , ,) = state.pool.globalState();\n        amountsOut = new uint[](2);\n        (amountsOut[0], amountsOut[1]) = AlgebraLib.getAmountsForLiquidity(\n            sqrtRatioX96,\n            state.lowerTick,\n            state.upperTick,\n            liquidityAmountToExit\n        );\n        if (state.depositorSwapTokens) {\n            (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n        }\n    }\n\n    //////////////////////////////////////////\n    //            Rewards\n    //////////////////////////////////////////\n\n    function isReadyToHardWork(State storage state, ITetuConverter converter, address controller) external view returns (bool isReady) {\n        address tokenA = state.tokenA;\n        uint rewardInTermOfTokenA;\n        uint bonusRewardInTermOfTokenA;\n        address h = state.strategyProfitHolder;\n\n        {\n            address rewardToken = state.rewardToken;\n            address bonusRewardToken = state.bonusRewardToken;\n            IncentiveKey memory key = getIncentiveKey(state);\n            (uint reward, uint bonusReward) = FARMING_CENTER.eternalFarming().getRewardInfo(key, state.tokenId);\n            reward += IERC20(rewardToken).balanceOf(h);\n            bonusReward += IERC20(bonusRewardToken).balanceOf(h);\n            ITetuLiquidator liquidator = ITetuLiquidator(IController(controller).liquidator());\n            if (reward > 0) {\n                rewardInTermOfTokenA = liquidator.getPrice(rewardToken, tokenA, reward);\n            }\n            if (bonusRewardInTermOfTokenA > 0) {\n                bonusRewardInTermOfTokenA = liquidator.getPrice(bonusRewardToken, tokenA, bonusReward);\n            }\n        }\n\n        address tokenB = state.tokenB;\n\n        // check claimable amounts and compare with thresholds\n        (uint fee0, uint fee1) = getFees(state);\n\n        if (state.depositorSwapTokens) {\n            (fee0, fee1) = (fee1, fee0);\n        }\n\n        fee0 += IERC20(tokenA).balanceOf(h);\n        fee1 += IERC20(tokenB).balanceOf(h);\n\n        IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n        uint priceA = oracle.getAssetPrice(tokenA);\n        uint priceB = oracle.getAssetPrice(tokenB);\n\n        uint fee0USD = fee0 * priceA / 1e18;\n        uint fee1USD = fee1 * priceB / 1e18;\n\n        return\n            fee0USD > HARD_WORK_USD_FEE_THRESHOLD\n            || fee1USD > HARD_WORK_USD_FEE_THRESHOLD\n            || rewardInTermOfTokenA * priceA / 1e18 > HARD_WORK_USD_FEE_THRESHOLD\n            || bonusRewardInTermOfTokenA * priceA / 1e18 > HARD_WORK_USD_FEE_THRESHOLD\n        ;\n    }\n\n    function claimRewards(State storage state) external returns (\n        address[] memory tokensOut,\n        uint[] memory amountsOut,\n        uint[] memory balancesBefore\n    ) {\n        address strategyProfitHolder = state.strategyProfitHolder;\n        uint tokenId = state.tokenId;\n        tokensOut = new address[](4);\n        tokensOut[0] = state.tokenA;\n        tokensOut[1] = state.tokenB;\n        tokensOut[2] = state.rewardToken;\n        tokensOut[3] = state.bonusRewardToken;\n\n        balancesBefore = new uint[](4);\n        for (uint i; i < tokensOut.length; i++) {\n            balancesBefore[i] = IERC20(tokensOut[i]).balanceOf(address(this));\n        }\n\n        amountsOut = new uint[](4);\n        if (tokenId > 0 && state.totalLiquidity > 0) {\n            (amountsOut[0], amountsOut[1]) = FARMING_CENTER.collect(INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max));\n\n            emit AlgebraFeesClaimed(amountsOut[0], amountsOut[1]);\n\n            if (state.depositorSwapTokens) {\n                (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n            }\n\n            (amountsOut[2], amountsOut[3]) = FARMING_CENTER.collectRewards(getIncentiveKey(state), tokenId);\n\n            if (amountsOut[2] > 0) {\n                FARMING_CENTER.claimReward(tokensOut[2], address(this), 0, amountsOut[2]);\n            }\n\n            if (amountsOut[3] > 0) {\n                FARMING_CENTER.claimReward(tokensOut[3], address(this), 0, amountsOut[3]);\n            }\n\n            emit AlgebraRewardsClaimed(amountsOut[2], amountsOut[3]);\n        }\n\n        for (uint i; i < tokensOut.length; ++i) {\n            uint b = IERC20(tokensOut[i]).balanceOf(strategyProfitHolder);\n            if (b > 0) {\n                IERC20(tokensOut[i]).transferFrom(strategyProfitHolder, address(this), b);\n                amountsOut[i] += b;\n            }\n        }\n    }\n\n    function calcEarned(address asset, address controller, address[] memory rewardTokens, uint[] memory amounts) external view returns (uint) {\n        ITetuLiquidator liquidator = ITetuLiquidator(IController(controller).liquidator());\n        uint len = rewardTokens.length;\n        uint earned;\n        for (uint i; i < len; ++i) {\n            address token = rewardTokens[i];\n            if (token == asset) {\n                earned += amounts[i];\n            } else {\n                earned += liquidator.getPrice(rewardTokens[i], asset, amounts[i]);\n            }\n        }\n\n        return earned;\n    }\n\n    //////////////////////////////////////////\n    //            Rebalance\n    //////////////////////////////////////////\n\n    function needRebalance(State storage state) public view returns (bool) {\n        if (state.isFuseTriggered) {\n            return false;\n        }\n\n        (, int24 tick, , , , ,) = state.pool.globalState();\n        int24 upperTick = state.upperTick;\n        int24 lowerTick = state.lowerTick;\n        if (upperTick - lowerTick == state.tickSpacing) {\n            return tick < lowerTick || tick >= upperTick;\n        } else {\n            int24 halfRange = (upperTick - lowerTick) / 2;\n            int24 oldMedianTick = lowerTick + halfRange;\n            if (tick > oldMedianTick) {\n                return tick - oldMedianTick >= state.rebalanceTickRange;\n            }\n            return oldMedianTick - tick > state.rebalanceTickRange;\n        }\n    }\n\n    function quoteRebalanceSwap(State storage state, ITetuConverter converter) external returns (bool, uint) {\n        address tokenA = state.tokenA;\n        address tokenB = state.tokenB;\n        uint debtAmount = AlgebraDebtLib.getDebtTotalDebtAmountOut(converter, tokenA, tokenB);\n\n        if (\n            !needRebalance(state)\n            || !AlgebraDebtLib.needCloseDebt(debtAmount, converter, tokenB)\n        ) {\n            return (false, 0);\n        }\n\n        uint[] memory amountsOut = quoteExit(state, state.totalLiquidity);\n\n        if (amountsOut[1] < debtAmount) {\n            uint tokenBprice = AlgebraLib.getPrice(address(state.pool), tokenB);\n            uint needToSellTokenA = tokenBprice * (debtAmount - amountsOut[1]) / 10 ** IERC20Metadata(tokenB).decimals();\n            // add 1% gap for price impact\n            needToSellTokenA += needToSellTokenA / AlgebraDebtLib.SELL_GAP;\n            uint b = amountsOut[0] + AppLib.balance(tokenA);\n            if (b > 0) {\n                needToSellTokenA = Math.min(needToSellTokenA, b - 1);\n            } else {\n                needToSellTokenA = 0;\n            }\n            return (true, needToSellTokenA);\n        } else {\n            return (false, amountsOut[1] - debtAmount);\n        }\n    }\n\n    function rebalance(\n        State storage state,\n        ITetuConverter converter,\n        address controller,\n        uint oldTotalAssets,\n        uint profitToCover,\n        address splitter\n    ) external returns (\n        uint[] memory tokenAmounts // _depositorEnter(tokenAmounts) if length == 2\n    ) {\n        uint loss;\n        tokenAmounts = new uint[](0);\n\n        RebalanceLocalVariables memory vars = RebalanceLocalVariables({\n            upperTick: state.upperTick,\n            lowerTick: state.lowerTick,\n            tickSpacing: state.tickSpacing,\n            pool: state.pool,\n            tokenA: state.tokenA,\n            tokenB: state.tokenB,\n            lastPrice: state.lastPrice,\n            fuseThreshold: state.fuseThreshold,\n            depositorSwapTokens: state.depositorSwapTokens,\n        // setup initial values\n            notCoveredLoss: 0,\n            newLowerTick: 0,\n            newUpperTick: 0,\n            isStablePool: state.isStablePool,\n            newPrice: 0,\n            newTotalAssets: 0\n        });\n\n        require(needRebalance(state), AlgebraStrategyErrors.NO_REBALANCE_NEEDED);\n\n        vars.newPrice = getOracleAssetsPrice(converter, vars.tokenA, vars.tokenB);\n\n        if (vars.isStablePool && isEnableFuse(vars.lastPrice, vars.newPrice, vars.fuseThreshold)) {\n            /// enabling fuse: close debt and stop providing liquidity\n            state.isFuseTriggered = true;\n            emit FuseTriggered();\n\n            AlgebraDebtLib.closeDebt(\n                converter,\n                controller,\n                vars.pool,\n                vars.tokenA,\n                vars.tokenB,\n                _getLiquidatorSwapSlippage(vars.isStablePool),\n                profitToCover,\n                oldTotalAssets,\n                splitter\n            );\n        } else {\n            /// rebalancing debt\n            /// setting new tick range\n            AlgebraDebtLib.rebalanceDebt(\n                converter,\n                controller,\n                state,\n                _getLiquidatorSwapSlippage(vars.isStablePool),\n                profitToCover,\n                oldTotalAssets,\n                splitter\n            );\n\n            tokenAmounts = new uint[](2);\n            tokenAmounts[0] = AppLib.balance(vars.tokenA);\n            tokenAmounts[1] = AppLib.balance(vars.tokenB);\n\n            address[] memory tokens = new address[](2);\n            tokens[0] = vars.tokenA;\n            tokens[1] = vars.tokenB;\n            uint[] memory amounts = new uint[](2);\n            amounts[0] = tokenAmounts[0];\n            vars.newTotalAssets = ConverterStrategyBaseLib.calcInvestedAssets(tokens, amounts, 0, converter);\n            if (vars.newTotalAssets < oldTotalAssets) {\n                loss = oldTotalAssets - vars.newTotalAssets;\n            }\n        }\n\n        // need to update last price only for stables coz only stables have fuse mechanic\n        if (vars.isStablePool) {\n            state.lastPrice = vars.newPrice;\n        }\n\n        if (loss > 0) {\n            ISplitter(splitter).coverPossibleStrategyLoss(0, loss);\n        }\n\n        emit Rebalanced(loss);\n    }\n\n    function rebalanceSwapByAgg(\n        State storage state,\n        ITetuConverter converter,\n        uint oldTotalAssets,\n        RebalanceSwapByAggParams memory aggParams,\n        uint profitToCover,\n        address splitter\n    ) external returns (\n        uint[] memory tokenAmounts // _depositorEnter(tokenAmounts) if length == 2\n    ) {\n        uint loss;\n        tokenAmounts = new uint[](0);\n\n        RebalanceLocalVariables memory vars = RebalanceLocalVariables({\n            upperTick: state.upperTick,\n            lowerTick: state.lowerTick,\n            tickSpacing: state.tickSpacing,\n            pool: state.pool,\n            tokenA: state.tokenA,\n            tokenB: state.tokenB,\n            lastPrice: state.lastPrice,\n            fuseThreshold: state.fuseThreshold,\n            depositorSwapTokens: state.depositorSwapTokens,\n        // setup initial values\n            notCoveredLoss: 0,\n            newLowerTick: 0,\n            newUpperTick: 0,\n            isStablePool: state.isStablePool,\n            newPrice: 0,\n            newTotalAssets: 0\n        });\n\n        require(needRebalance(state), AlgebraStrategyErrors.NO_REBALANCE_NEEDED);\n\n        vars.newPrice = getOracleAssetsPrice(converter, vars.tokenA, vars.tokenB);\n\n        if (vars.isStablePool && isEnableFuse(vars.lastPrice, vars.newPrice, vars.fuseThreshold)) {\n            /// enabling fuse: close debt and stop providing liquidity\n            state.isFuseTriggered = true;\n            emit FuseTriggered();\n\n            AlgebraDebtLib.closeDebtByAgg(\n                converter,\n                vars.tokenA,\n                vars.tokenB,\n                _getLiquidatorSwapSlippage(vars.isStablePool),\n                aggParams,\n                profitToCover,\n                oldTotalAssets,\n                splitter\n            );\n        } else {\n            /// rebalancing debt\n            /// setting new tick range\n            AlgebraDebtLib.rebalanceDebtSwapByAgg(\n                converter,\n                state,\n                _getLiquidatorSwapSlippage(vars.isStablePool),\n                aggParams,\n                profitToCover,\n                oldTotalAssets,\n                splitter\n            );\n\n            if (oldTotalAssets > 0) {\n                tokenAmounts = new uint[](2);\n                tokenAmounts[0] = AppLib.balance(vars.tokenA);\n                tokenAmounts[1] = AppLib.balance(vars.tokenB);\n\n                address[] memory tokens = new address[](2);\n                tokens[0] = vars.tokenA;\n                tokens[1] = vars.tokenB;\n                uint[] memory amounts = new uint[](2);\n                amounts[0] = tokenAmounts[0];\n                vars.newTotalAssets = ConverterStrategyBaseLib.calcInvestedAssets(tokens, amounts, 0, converter);\n                if (vars.newTotalAssets < oldTotalAssets) {\n                    loss = oldTotalAssets - vars.newTotalAssets;\n                }\n            }\n        }\n\n        // need to update last price only for stables coz only stables have fuse mechanic\n        if (vars.isStablePool) {\n            state.lastPrice = vars.newPrice;\n        }\n\n        if (loss > 0) {\n            ISplitter(splitter).coverPossibleStrategyLoss(0, loss);\n        }\n\n        emit Rebalanced(loss);\n    }\n}"
    },
    "contracts/strategies/algebra/AlgebraDebtLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBaseLib.sol\";\nimport \"../ConverterStrategyBaseLib2.sol\";\nimport \"./AlgebraLib.sol\";\nimport \"./AlgebraStrategyErrors.sol\";\nimport \"./AlgebraConverterStrategyLogicLib.sol\";\n\nlibrary AlgebraDebtLib {\n\n    uint public constant SELL_GAP = 100;\n    address internal constant ONEINCH = 0x1111111254EEB25477B68fb85Ed929f73A960582; // 1inch router V5\n    address internal constant OPENOCEAN = 0x6352a56caadC4F1E25CD6c75970Fa768A3304e64; // OpenOceanExchangeProxy\n\n    function calcTickRange(IAlgebraPool pool, int24 tickRange, int24 tickSpacing) public view returns (int24 lowerTick, int24 upperTick) {\n        (, int24 tick, , , , ,) = pool.globalState();\n        if (tick < 0 && tick / tickSpacing * tickSpacing != tick) {\n            lowerTick = ((tick - tickRange) / tickSpacing - 1) * tickSpacing;\n        } else {\n            lowerTick = (tick - tickRange) / tickSpacing * tickSpacing;\n        }\n        upperTick = tickRange == 0 ? lowerTick + tickSpacing : lowerTick + tickRange * 2;\n    }\n\n    function getEntryData(\n        IAlgebraPool pool,\n        int24 lowerTick,\n        int24 upperTick,\n        bool depositorSwapTokens\n    ) public view returns (bytes memory entryData) {\n        address token1 = pool.token1();\n        uint token1Price = AlgebraLib.getPrice(address(pool), token1);\n\n        uint token1Decimals = IERC20Metadata(token1).decimals();\n\n        uint token0Desired = token1Price;\n        uint token1Desired = 10 ** token1Decimals;\n\n        // calculate proportions\n        (uint consumed0, uint consumed1,) = AlgebraLib.addLiquidityPreview(address(pool), lowerTick, upperTick, token0Desired, token1Desired);\n\n        if (depositorSwapTokens) {\n            entryData = abi.encode(1, consumed1 * token1Price / token1Desired, consumed0);\n        } else {\n            entryData = abi.encode(1, consumed0, consumed1 * token1Price / token1Desired);\n        }\n    }\n\n    /// @dev Closes the debt positions for the given token pair.\n    /// @param tetuConverter The ITetuConverter instance.\n    /// @param controller The controller address.\n    /// @param pool The IUniswapV3Pool instance.\n    /// @param tokenA The address of tokenA.\n    /// @param tokenB The address of tokenB.\n    function closeDebt(\n        ITetuConverter tetuConverter,\n        address controller,\n        IAlgebraPool pool,\n        address tokenA,\n        address tokenB,\n        uint liquidatorSwapSlippage,\n        uint profitToCover,\n        uint totalAssets,\n        address splitter\n    ) public {\n        _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, liquidatorSwapSlippage);\n        if (profitToCover > 0) {\n            ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n        }\n    }\n\n    function closeDebtByAgg(\n        ITetuConverter tetuConverter,\n        address tokenA,\n        address tokenB,\n        uint liquidatorSwapSlippage,\n        AlgebraConverterStrategyLogicLib.RebalanceSwapByAggParams memory aggParams,\n        uint profitToCover,\n        uint totalAssets,\n        address splitter\n    ) public {\n        _closeDebtByAgg(tetuConverter, tokenA, tokenB, liquidatorSwapSlippage, aggParams);\n        if (profitToCover > 0) {\n            ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n        }\n    }\n\n    /// @dev Rebalances the debt by either filling up or closing and reopening debt positions. Sets new tick range.\n    function rebalanceDebt(\n        ITetuConverter tetuConverter,\n        address controller,\n        AlgebraConverterStrategyLogicLib.State storage state,\n        uint liquidatorSwapSlippage,\n        uint profitToCover,\n        uint totalAssets,\n        address splitter\n    ) external {\n        IAlgebraPool pool = state.pool;\n        address tokenA = state.tokenA;\n        address tokenB = state.tokenB;\n        bool depositorSwapTokens = state.depositorSwapTokens;\n        _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, liquidatorSwapSlippage);\n        if (profitToCover > 0) {\n            ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n        }\n        (int24 newLowerTick, int24 newUpperTick) = _calcNewTickRange(pool, state.lowerTick, state.upperTick, state.tickSpacing);\n        bytes memory entryData = getEntryData(pool, newLowerTick, newUpperTick, depositorSwapTokens);\n        _openDebt(tetuConverter, tokenA, tokenB, entryData);\n        state.lowerTick = newLowerTick;\n        state.upperTick = newUpperTick;\n    }\n\n    function rebalanceDebtSwapByAgg(\n        ITetuConverter tetuConverter,\n        AlgebraConverterStrategyLogicLib.State storage state,\n        uint liquidatorSwapSlippage,\n        AlgebraConverterStrategyLogicLib.RebalanceSwapByAggParams memory aggParams,\n        uint profitToCover,\n        uint totalAssets,\n        address splitter\n    ) external {\n        IAlgebraPool pool = state.pool;\n        address tokenA = state.tokenA;\n        address tokenB = state.tokenB;\n        bool depositorSwapTokens = state.depositorSwapTokens;\n        _closeDebtByAgg(tetuConverter, tokenA, tokenB, liquidatorSwapSlippage, aggParams);\n        if (profitToCover > 0) {\n            ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n        }\n        (int24 newLowerTick, int24 newUpperTick) = _calcNewTickRange(pool, state.lowerTick, state.upperTick, state.tickSpacing);\n        bytes memory entryData = getEntryData(pool, newLowerTick, newUpperTick, depositorSwapTokens);\n        _openDebt(tetuConverter, tokenA, tokenB, entryData);\n        state.lowerTick = newLowerTick;\n        state.upperTick = newUpperTick;\n    }\n\n    /// @dev Returns the total debt amount out for the given token pair.\n    /// @param tetuConverter The ITetuConverter instance.\n    /// @param tokenA The address of tokenA.\n    /// @param tokenB The address of tokenB.\n    /// @return totalDebtAmountOut The total debt amount out for the token pair.\n    function getDebtTotalDebtAmountOut(ITetuConverter tetuConverter, address tokenA, address tokenB) public returns (uint totalDebtAmountOut) {\n        (totalDebtAmountOut,) = tetuConverter.getDebtAmountCurrent(address(this), tokenA, tokenB, true);\n    }\n\n    /// @dev we close debt only if it is more than $0.1\n    function needCloseDebt(uint debtAmount, ITetuConverter tetuConverter, address tokenB) public view returns (bool) {\n        IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter.controller()).priceOracle());\n        return debtAmount * priceOracle.getAssetPrice(tokenB) / 10 ** IERC20Metadata(tokenB).decimals() > 1e17;\n    }\n\n    /// @notice Calculate the new tick range for a Algebra pool.\n    /// @param pool The Algebra pool to calculate the new tick range for.\n    /// @param lowerTick The current lower tick value for the pool.\n    /// @param upperTick The current upper tick value for the pool.\n    /// @param tickSpacing The tick spacing for the pool.\n    /// @return lowerTickNew The new lower tick value for the pool.\n    /// @return upperTickNew The new upper tick value for the pool.\n    function _calcNewTickRange(\n        IAlgebraPool pool,\n        int24 lowerTick,\n        int24 upperTick,\n        int24 tickSpacing\n    ) internal view returns (int24 lowerTickNew, int24 upperTickNew) {\n        int24 fullTickRange = upperTick - lowerTick;\n        (lowerTickNew, upperTickNew) = calcTickRange(pool, fullTickRange == tickSpacing ? int24(0) : fullTickRange / 2, tickSpacing);\n    }\n\n    /// @dev Opens a new debt position using entry data.\n    /// @param tetuConverter The TetuConverter contract.\n    /// @param tokenA The address of token A.\n    /// @param tokenB The address of token B.\n    /// @param entryData The data required to open a position.\n    function _openDebt(\n        ITetuConverter tetuConverter,\n        address tokenA,\n        address tokenB,\n        bytes memory entryData/*,\n    uint feeA*/\n    ) internal {\n        ConverterStrategyBaseLib.openPosition(\n            tetuConverter,\n            entryData,\n            tokenA,\n            tokenB,\n            AppLib.balance(tokenA)/* - feeA*/,\n            0\n        );\n    }\n\n    /// @notice Closes debt by liquidating tokens as necessary.\n    ///         This function helps ensure that the converter strategy maintains the appropriate balances\n    ///         and debt positions for token A and token B, while accounting for potential price impacts.\n    function _closeDebt(\n        ITetuConverter tetuConverter,\n        address controller,\n        IAlgebraPool pool,\n        address tokenA,\n        address tokenB,\n        uint liquidatorSwapSlippage\n    ) internal {\n        uint debtAmount = getDebtTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n\n        if (needCloseDebt(debtAmount, tetuConverter, tokenB)) {\n            uint availableBalanceTokenA = AppLib.balance(tokenA);\n            uint availableBalanceTokenB = AppLib.balance(tokenB);\n\n            if (availableBalanceTokenB < debtAmount) {\n                uint tokenBprice = AlgebraLib.getPrice(address(pool), tokenB);\n                uint needToSellTokenA = tokenBprice * (debtAmount - availableBalanceTokenB) / 10 ** IERC20Metadata(tokenB).decimals();\n                // add 1% gap for price impact\n                needToSellTokenA += needToSellTokenA / SELL_GAP;\n\n                ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, Math.min(needToSellTokenA, availableBalanceTokenA), liquidatorSwapSlippage, 0, false);\n                availableBalanceTokenB = AppLib.balance(tokenB);\n            }\n\n            ConverterStrategyBaseLib.closePosition(\n                tetuConverter,\n                tokenA,\n                tokenB,\n                Math.min(debtAmount, availableBalanceTokenB)\n            );\n\n            availableBalanceTokenB = AppLib.balance(tokenB);\n            ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenB, tokenA, availableBalanceTokenB, liquidatorSwapSlippage, 0, false);\n        }\n    }\n\n    function _closeDebtByAgg(\n        ITetuConverter tetuConverter,\n        address tokenA,\n        address tokenB,\n        uint liquidatorSwapSlippage,\n        AlgebraConverterStrategyLogicLib.RebalanceSwapByAggParams memory aggParams\n    ) internal {\n        _checkSwapRouter(aggParams.agg);\n\n        uint debtAmount = getDebtTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n\n        if (needCloseDebt(debtAmount, tetuConverter, tokenB)) {\n            uint balanceTokenABefore = AppLib.balance(tokenA);\n            uint balanceTokenBBefore = AppLib.balance(tokenB);\n\n            address tokenIn = aggParams.direction ? tokenA : tokenB;\n\n            AppLib.approveIfNeeded(tokenIn, aggParams.amount, aggParams.agg);\n\n            {\n                (bool success, bytes memory result) = aggParams.agg.call(aggParams.swapData);\n                require(success, string(result));\n            }\n\n            uint availableBalanceTokenA = AppLib.balance(tokenA);\n            uint availableBalanceTokenB = AppLib.balance(tokenB);\n\n            require(\n                tetuConverter.isConversionValid(\n                    tokenIn,\n                    aggParams.amount,\n                    aggParams.direction ? tokenB : tokenA,\n                    aggParams.direction ? availableBalanceTokenB - balanceTokenBBefore : availableBalanceTokenA - balanceTokenABefore,\n                    liquidatorSwapSlippage\n                ), AppErrors.PRICE_IMPACT);\n\n            ConverterStrategyBaseLib.closePosition(\n                tetuConverter,\n                tokenA,\n                tokenB,\n                Math.min(debtAmount, availableBalanceTokenB)\n            );\n\n            availableBalanceTokenB = AppLib.balance(tokenB);\n        }\n    }\n\n    function _checkSwapRouter(address router) internal pure {\n        require(router == ONEINCH || router == OPENOCEAN, AlgebraStrategyErrors.UNKNOWN_SWAP_ROUTER);\n    }\n}"
    },
    "contracts/strategies/algebra/AlgebraDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"../DepositorBase.sol\";\nimport \"./AlgebraStrategyErrors.sol\";\nimport \"./AlgebraConverterStrategyLogicLib.sol\";\n\n\nabstract contract AlgebraDepositor is DepositorBase, Initializable {\n    using SafeERC20 for IERC20;\n\n    /////////////////////////////////////////////////////////////////////\n    ///                CONSTANTS\n    /////////////////////////////////////////////////////////////////////\n\n    /// @dev Version of this contract. Adjust manually on each code modification.\n    string public constant Algebra_DEPOSITOR_VERSION = \"1.0.0\";\n\n    /////////////////////////////////////////////////////////////////////\n    ///                VARIABLES\n    /////////////////////////////////////////////////////////////////////\n\n    /// @dev State variable to store the current state of the whole strategy\n    AlgebraConverterStrategyLogicLib.State internal state;\n\n    /////////////////////////////////////////////////////////////////////\n    ///                       View\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice Returns the current state of the contract.\n    function getState() external view returns (\n        address tokenA,\n        address tokenB,\n        IAlgebraPool pool,\n        int24 tickSpacing,\n        int24 lowerTick,\n        int24 upperTick,\n        int24 rebalanceTickRange,\n        uint128 totalLiquidity,\n        bool isFuseTriggered,\n        uint fuseThreshold,\n        address profitHolder,\n        uint[] memory profitHolderBalances\n    ) {\n        tokenA = state.tokenA;\n        tokenB = state.tokenB;\n        pool = state.pool;\n        tickSpacing = state.tickSpacing;\n        lowerTick = state.lowerTick;\n        upperTick = state.upperTick;\n        rebalanceTickRange = state.rebalanceTickRange;\n        totalLiquidity = state.totalLiquidity;\n        isFuseTriggered = state.isFuseTriggered;\n        fuseThreshold = state.fuseThreshold;\n        profitHolder = state.strategyProfitHolder;\n        profitHolderBalances = new uint[](4);\n        profitHolderBalances[0] = IERC20(tokenA).balanceOf(profitHolder);\n        profitHolderBalances[1] = IERC20(tokenB).balanceOf(profitHolder);\n        profitHolderBalances[2] = IERC20(state.rewardToken).balanceOf(profitHolder);\n        profitHolderBalances[3] = IERC20(state.bonusRewardToken).balanceOf(profitHolder);\n    }\n\n    /// @notice Returns the fees for the current state.\n    /// @return fee0 and fee1.\n    function getFees() public view returns (uint fee0, uint fee1) {\n        return AlgebraConverterStrategyLogicLib.getFees(state);\n    }\n\n    /// @notice Returns the pool assets.\n    /// @return poolAssets An array containing the addresses of the pool assets.\n    function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n        poolAssets = new address[](2);\n        poolAssets[0] = state.tokenA;\n        poolAssets[1] = state.tokenB;\n    }\n\n    /// @notice Returns the pool weights and the total weight.\n    /// @return weights An array containing the weights of the pool assets, and totalWeight the sum of the weights.\n    function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n        weights = new uint[](2);\n        weights[0] = 1;\n        weights[1] = 1;\n        totalWeight = 2;\n    }\n\n    /// @notice Returns the pool reserves.\n    /// @return reserves An array containing the reserves of the pool assets.\n    function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n        return AlgebraConverterStrategyLogicLib.getPoolReserves(state);\n    }\n\n    /// @notice Returns the current liquidity of the depositor.\n    /// @return The current liquidity of the depositor.\n    function _depositorLiquidity() override internal virtual view returns (uint) {\n        return uint(state.totalLiquidity);\n    }\n\n    /// @notice Returns the total supply of the depositor.\n    /// @return In UniV3 we can not calculate the total supply of the wgole pool. Return only ourself value.\n    function _depositorTotalSupply() override internal view virtual returns (uint) {\n        return uint(state.totalLiquidity);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    ///             Enter, exit\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice Handles the deposit operation.\n    function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (uint[] memory amountsConsumed, uint liquidityOut) {\n        (amountsConsumed, liquidityOut) = AlgebraConverterStrategyLogicLib.enter(state, amountsDesired_);\n    }\n\n    /// @notice Handles the withdrawal operation.\n    /// @param liquidityAmount The amount of liquidity to be withdrawn.\n    /// @return amountsOut The amounts of the tokens withdrawn.\n    function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n        amountsOut = AlgebraConverterStrategyLogicLib.exit(state, uint128(liquidityAmount));\n    }\n\n    /// @notice Returns the amount of tokens that would be withdrawn based on the provided liquidity amount.\n    /// @param liquidityAmount The amount of liquidity to quote the withdrawal for.\n    /// @return amountsOut The amounts of the tokens that would be withdrawn.\n    function _depositorQuoteExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n        amountsOut = AlgebraConverterStrategyLogicLib.quoteExit(state, uint128(liquidityAmount));\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    ///             Claim rewards\n    /////////////////////////////////////////////////////////////////////\n\n    /// @notice Claims all possible rewards.\n    /// @return tokensOut An array containing the addresses of the reward tokens,\n    /// @return amountsOut An array containing the amounts of the reward tokens.\n    function _depositorClaimRewards() override internal virtual returns (\n        address[] memory tokensOut,\n        uint[] memory amountsOut,\n        uint[] memory balancesBefore\n    ) {\n        return AlgebraConverterStrategyLogicLib.claimRewards(state);\n    }\n\n    /// @dev This empty reserved space is put in place to allow future versions to add new\n    /// variables without shifting down storage in the inheritance chain.\n    /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n    uint[50-1] private __gap; // 50 - count of variables\n\n}\n"
    },
    "contracts/strategies/algebra/AlgebraLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/algebra/IAlgebraPool.sol\";\nimport \"../../integrations/algebra/INonfungiblePositionManager.sol\";\nimport \"../../integrations/algebra/IFarmingCenter.sol\";\nimport \"../../integrations/algebra/IncentiveKey.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\n\nlibrary AlgebraLib {\n    int24 internal constant TICKSPACING = 60;\n    uint8 internal constant RESOLUTION = 96;\n    uint internal constant Q96 = 0x1000000000000000000000000;\n    uint private constant TWO_96 = 2 ** 96;\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n    uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n    uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n    int24 internal constant MIN_TICK = - 887272;\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n    int24 internal constant MAX_TICK = - MIN_TICK;\n\n    function tickSpacing() external pure returns(int24) {\n        return TICKSPACING;\n    }\n\n    function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\n        IAlgebraPool pool = IAlgebraPool(pool_);\n        (uint160 sqrtRatioX96, , , , , ,) = pool.globalState();\n        liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\n        (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\n    }\n\n    /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n    /// pool prices and the prices at the tick boundaries\n    function getLiquidityForAmounts(\n        uint160 sqrtRatioX96,\n        int24 lowerTick,\n        int24 upperTick,\n        uint amount0,\n        uint amount1\n    ) public pure returns (uint128 liquidity) {\n        uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n        uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n        if (sqrtRatioAX96 > sqrtRatioBX96) {\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        }\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n            uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n            liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n        } else {\n            liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n        }\n    }\n\n    /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n    /// pool prices and the prices at the tick boundaries\n    function getAmountsForLiquidity(\n        uint160 sqrtRatioX96,\n        int24 lowerTick,\n        int24 upperTick,\n        uint128 liquidity\n    ) public pure returns (uint amount0, uint amount1) {\n        uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n        uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n\n        if (sqrtRatioAX96 > sqrtRatioBX96) {\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        }\n\n        if (sqrtRatioX96 <= sqrtRatioAX96) {\n            amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        } else if (sqrtRatioX96 < sqrtRatioBX96) {\n            amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n            amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n        } else {\n            amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n        }\n    }\n\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint a,\n        uint b,\n        uint denominator\n    ) public pure returns (uint result) {\n    unchecked {\n        // 512-bit multiply [prod1 prod0] = a * b\n        // Compute the product mod 2**256 and mod 2**256 - 1\n        // then use the Chinese Remainder Theorem to reconstruct\n        // the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2**256 + prod0\n        uint prod0;\n        // Least significant 256 bits of the product\n        uint prod1;\n        // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(a, b, not(0))\n            prod0 := mul(a, b)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division\n        if (prod1 == 0) {\n            require(denominator > 0);\n            assembly {\n                result := div(prod0, denominator)\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2**256.\n        // Also prevents denominator == 0\n        require(denominator > prod1);\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0]\n        // Compute remainder using mulmod\n        uint remainder;\n        assembly {\n            remainder := mulmod(a, b, denominator)\n        }\n        // Subtract 256 bit number from 512 bit number\n        assembly {\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator\n        // Compute largest power of two divisor of denominator.\n        // Always >= 1.\n        // EDIT for 0.8 compatibility:\n        // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\n        uint twos = denominator & (~denominator + 1);\n\n        // Divide denominator by power of two\n        assembly {\n            denominator := div(denominator, twos)\n        }\n\n        // Divide [prod1 prod0] by the factors of two\n        assembly {\n            prod0 := div(prod0, twos)\n        }\n        // Shift in bits from prod1 into prod0. For this we need\n        // to flip `twos` such that it is 2**256 / twos.\n        // If twos is zero, then it becomes one\n        assembly {\n            twos := add(div(sub(0, twos), twos), 1)\n        }\n        prod0 |= prod1 * twos;\n\n        // Invert denominator mod 2**256\n        // Now that denominator is an odd number, it has an inverse\n        // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n        // Compute the inverse by starting with a seed that is correct\n        // correct for four bits. That is, denominator * inv = 1 mod 2**4\n        uint inv = (3 * denominator) ^ 2;\n        // Now use Newton-Raphson iteration to improve the precision.\n        // Thanks to Hensel's lifting lemma, this also works in modular\n        // arithmetic, doubling the correct bits in each step.\n        inv *= 2 - denominator * inv;\n        // inverse mod 2**8\n        inv *= 2 - denominator * inv;\n        // inverse mod 2**16\n        inv *= 2 - denominator * inv;\n        // inverse mod 2**32\n        inv *= 2 - denominator * inv;\n        // inverse mod 2**64\n        inv *= 2 - denominator * inv;\n        // inverse mod 2**128\n        inv *= 2 - denominator * inv;\n        // inverse mod 2**256\n\n        // Because the division is now exact we can divide by multiplying\n        // with the modular inverse of denominator. This will give us the\n        // correct result modulo 2**256. Since the precoditions guarantee\n        // that the outcome is less than 2**256, this is the final result.\n        // We don't need to compute the high bits of the result and prod1\n        // is no longer required.\n        result = prod0 * inv;\n        return result;\n    }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint a,\n        uint b,\n        uint denominator\n    ) internal pure returns (uint result) {\n        result = mulDiv(a, b, denominator);\n        if (mulmod(a, b, denominator) > 0) {\n            require(result < type(uint).max);\n            result++;\n        }\n    }\n\n    /// @notice Calculates price in pool\n    function getPrice(address pool_, address tokenIn) public view returns (uint) {\n        IAlgebraPool pool = IAlgebraPool(pool_);\n        address token0 = pool.token0();\n        address token1 = pool.token1();\n\n        uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n        uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n        (uint160 sqrtPriceX96,,,,,,) = pool.globalState();\n\n        uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\n\n        uint priceDigits = _countDigits(uint(sqrtPriceX96));\n        uint purePrice;\n        uint precision;\n        if (tokenIn == token0) {\n            precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\n            uint part = uint(sqrtPriceX96) * precision / TWO_96;\n            purePrice = part * part;\n        } else {\n            precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\n            uint part = TWO_96 * precision / uint(sqrtPriceX96);\n            purePrice = part * part;\n        }\n        return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\n    }\n\n    function getFees(IAlgebraPool pool, INonfungiblePositionManager nft, uint tokenId) public view returns (uint fee0, uint fee1) {\n        (, int24 tick, , , , ,) = pool.globalState();\n        (,,,,int24 lowerTick,int24 upperTick,uint128 liquidity,uint feeGrowthInside0Last, uint feeGrowthInside1Last, uint128 tokensOwed0, uint128 tokensOwed1) = nft.positions(tokenId);\n        fee0 = _computeFeesEarned(pool, lowerTick, upperTick, liquidity, true, feeGrowthInside0Last, tick) + uint(tokensOwed0);\n        fee1 = _computeFeesEarned(pool, lowerTick, upperTick, liquidity, false, feeGrowthInside1Last, tick) + uint(tokensOwed1);\n    }\n\n    function _computeFeesEarned(\n        IAlgebraPool pool,\n        int24 lowerTick,\n        int24 upperTick,\n        uint128 liquidity,\n        bool isZero,\n        uint feeGrowthInsideLast,\n        int24 tick\n    ) internal view returns (uint fee) {\n        uint feeGrowthOutsideLower;\n        uint feeGrowthOutsideUpper;\n        uint feeGrowthGlobal;\n        if (isZero) {\n            feeGrowthGlobal = pool.totalFeeGrowth0Token();\n            (,, feeGrowthOutsideLower,,,,,) = pool.ticks(lowerTick);\n            (,, feeGrowthOutsideUpper,,,,,) = pool.ticks(upperTick);\n        } else {\n            feeGrowthGlobal = pool.totalFeeGrowth1Token();\n            (,,, feeGrowthOutsideLower,,,,) = pool.ticks(lowerTick);\n            (,,, feeGrowthOutsideUpper,,,,) = pool.ticks(upperTick);\n        }\n\n        unchecked {\n            // calculate fee growth below\n            uint feeGrowthBelow;\n            if (tick >= lowerTick) {\n                feeGrowthBelow = feeGrowthOutsideLower;\n            } else {\n                feeGrowthBelow = feeGrowthGlobal - feeGrowthOutsideLower;\n            }\n            // calculate fee growth above\n            uint feeGrowthAbove;\n            if (tick < upperTick) {\n                feeGrowthAbove = feeGrowthOutsideUpper;\n            } else {\n                feeGrowthAbove = feeGrowthGlobal - feeGrowthOutsideUpper;\n            }\n\n            uint feeGrowthInside =\n                feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove;\n            fee = mulDiv(\n                liquidity,\n                feeGrowthInside - feeGrowthInsideLast,\n                0x100000000000000000000000000000000\n            );\n        }\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n    /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param amount0 The amount0 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) {\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        }\n        uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\n        return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n    }\n\n    /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n    /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param amount1 The amount1 being sent in\n    /// @return liquidity The amount of returned liquidity\n    function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) {\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        }\n        return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\n    }\n\n    /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The liquidity being valued\n    /// @return amount0 The amount0\n    function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) {\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        }\n        return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\n    }\n\n    /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The liquidity being valued\n    /// @return amount1 The amount1\n    function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96) {\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n        }\n        return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\n    }\n\n    function _countDigits(uint n) internal pure returns (uint) {\n        if (n == 0) {\n            return 0;\n        }\n        uint count = 0;\n        while (n != 0) {\n            n = n / 10;\n            ++count;\n        }\n        return count;\n    }\n\n    function _min(uint a, uint b) internal pure returns (uint) {\n        return a < b ? a : b;\n    }\n\n    function _max(uint a, uint b) internal pure returns (uint) {\n        return a > b ? a : b;\n    }\n\n    function _toUint128(uint x) private pure returns (uint128 y) {\n        require((y = uint128(x)) == x);\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n    /// at the given tick\n    function _getSqrtRatioAtTick(int24 tick)\n    internal\n    pure\n    returns (uint160 sqrtPriceX96)\n    {\n        uint256 absTick =\n        tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\n\n        // EDIT: 0.8 compatibility\n        require(absTick <= uint256(int256(MAX_TICK)), \"T\");\n\n        uint256 ratio =\n        absTick & 0x1 != 0\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\n        : 0x100000000000000000000000000000000;\n        if (absTick & 0x2 != 0)\n            ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n        if (absTick & 0x4 != 0)\n            ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n        if (absTick & 0x8 != 0)\n            ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n        if (absTick & 0x10 != 0)\n            ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n        if (absTick & 0x20 != 0)\n            ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n        if (absTick & 0x40 != 0)\n            ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n        if (absTick & 0x80 != 0)\n            ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n        if (absTick & 0x100 != 0)\n            ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n        if (absTick & 0x200 != 0)\n            ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n        if (absTick & 0x400 != 0)\n            ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n        if (absTick & 0x800 != 0)\n            ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n        if (absTick & 0x1000 != 0)\n            ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n        if (absTick & 0x2000 != 0)\n            ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n        if (absTick & 0x4000 != 0)\n            ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n        if (absTick & 0x8000 != 0)\n            ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n        if (absTick & 0x10000 != 0)\n            ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n        if (absTick & 0x20000 != 0)\n            ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n        if (absTick & 0x40000 != 0)\n            ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n        if (absTick & 0x80000 != 0)\n            ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n        if (tick > 0) ratio = type(uint256).max / ratio;\n\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n        sqrtPriceX96 = uint160(\n            (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\n        );\n    }\n\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n    function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // second inequality must be < because the price can never reach the price at the max tick\n        require(\n            sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\n            \"R\"\n        );\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n        uint256 r = ratio;\n        uint256 msb = 0;\n\n        assembly {\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(5, gt(r, 0xFFFFFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(4, gt(r, 0xFFFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(3, gt(r, 0xFF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(2, gt(r, 0xF))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := shl(1, gt(r, 0x3))\n            msb := or(msb, f)\n            r := shr(f, r)\n        }\n        assembly {\n            let f := gt(r, 0x1)\n            msb := or(msb, f)\n        }\n\n        if (msb >= 128) r = ratio >> (msb - 127);\n        else r = ratio << (127 - msb);\n\n        int256 log_2 = (int256(msb) - 128) << 64;\n\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(63, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(62, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(61, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(60, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(59, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(58, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(57, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(56, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(55, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(54, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(53, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(52, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(51, f))\n            r := shr(f, r)\n        }\n        assembly {\n            r := shr(127, mul(r, r))\n            let f := shr(128, r)\n            log_2 := or(log_2, shl(50, f))\n        }\n\n        tick = _getFinalTick(log_2, sqrtPriceX96);\n    }\n\n    function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n        // 128.128 number\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141;\n\n        int24 tickLow =\n        int24(\n            (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\n        );\n        int24 tickHi =\n        int24(\n            (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\n        );\n\n        tick = (tickLow == tickHi)\n        ? tickLow\n        : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\n        ? tickHi\n        : tickLow);\n    }\n}"
    },
    "contracts/strategies/algebra/AlgebraStrategyErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary AlgebraStrategyErrors {\n\n    string public constant NEED_REBALANCE = \"AS-1 Need rebalance\";\n    string public constant WRONG_BALANCE = \"AS-2 Wrong balance\";\n    string public constant INCORRECT_TICK_RANGE = \"AS-3 Incorrect tickRange\";\n    string public constant INCORRECT_REBALANCE_TICK_RANGE = \"AS-4 Incorrect rebalanceTickRange\";\n    string public constant INCORRECT_ASSET = \"AS-5 Incorrect asset\";\n    string public constant WRONG_FEE = \"AS-6 Wrong fee\";\n    string public constant WRONG_LIQUIDITY = \"AS-7 Wrong liquidity\";\n    string public constant NO_REBALANCE_NEEDED = \"AS-9 No rebalance needed\";\n    string public constant BALANCE_LOWER_THAN_FEE = \"AS-10 Balance lower than fee\";\n    string public constant NOT_CALLBACK_CALLER = \"AS-11 Not callback caller\";\n    string public constant UNKNOWN_SWAP_ROUTER = \"AS-12 Unknown router\";\n    string public constant ZERO_PROFIT_HOLDER = \"AS-13 Zero strategy profit holder\";\n}"
    },
    "contracts/strategies/balancer/BalancerBoostedDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"../DepositorBase.sol\";\nimport \"./BalancerLogicLib.sol\";\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../integrations/balancer/IBalancerHelper.sol\";\nimport \"../../integrations/balancer/IComposableStablePool.sol\";\nimport \"../../integrations/balancer/IChildChainLiquidityGaugeFactory.sol\";\nimport \"../../integrations/balancer/IBalancerGauge.sol\";\n\n/// @title Depositor for Composable Stable Pool with several embedded linear pools like \"Balancer Boosted Tetu USD\"\n/// @dev See https://app.balancer.fi/polygon#/polygon/pool/0xb3d658d5b95bf04e2932370dd1ff976fe18dd66a000000000000000000000ace\n///            bb-t-DAI (DAI + tDAI) + bb-t-USDC (USDC + tUSDC) + bb-t-USDT (USDT + tUSDT)\n///      See https://docs.balancer.fi/products/balancer-pools/boosted-pools for explanation of Boosted Pools on BalanceR.\n///      Terms\n///         bb-t-USD = pool bpt\n///         bb-t-DAI, bb-t-USDC, bb-t-USDT = underlying bpt\n/// 1.0.1 Move to balancer gauge v2\nabstract contract BalancerBoostedDepositor is DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///region Constants\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant BALANCER_BOOSTED_DEPOSITOR_VERSION = \"1.0.1\";\n\n  /// @dev https://dev.balancer.fi/references/contracts/deployment-addresses\n  IBVault internal constant BALANCER_VAULT = IBVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n  address internal constant BALANCER_HELPER = 0x239e55F427D44C3cc793f49bFB507ebe76638a2b;\n  address internal constant BAL_TOKEN = 0x9a71012B13CA4d3D0Cdc72A177DF3ef03b0E76A3;\n\n  /////////////////////////////////////////////////////////////////////\n  ///endregion Constants\n  /////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////\n  //region Variables\n  //                Keep names and ordering!\n  // Add only in the bottom and don't forget to decrease gap variable\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice i.e. for \"Balancer Boosted Aave USD\": 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b\n  /// @notice i.e. for \"Balancer Boosted Tetu USD\": 0xb3d658d5b95bf04e2932370dd1ff976fe18dd66a000000000000000000000ace\n  bytes32 public poolId;\n\n  /// @notice Gauge for a pool - it can be found in the Logs of the transactions of\n  ///         ChildChainGaugeFactory == 0x22625eEDd92c81a219A83e1dc48f88d54786B017\n  ///         Topic 1 in the first event contains address of the gauge (Vyper_contract, vyper:0.3.3)\n  ///         The gauge has field \"lp_token\" that contains pool address.\n  IBalancerGauge public gauge;\n  /////////////////////////////////////////////////////////////////////\n  ///endregion Variables\n  /////////////////////////////////////////////////////////////////////\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  function __BalancerBoostedDepositor_init(address pool_, address gauge_) internal onlyInitializing {\n    poolId = IComposableStablePool(pool_).getPoolId();\n\n    gauge = IBalancerGauge(gauge_);\n\n    // infinite approve of pool-BPT to the gauge todo is it safe for the external gauge?\n    IERC20(pool_).safeApprove(address(gauge_), type(uint).max);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    return BalancerLogicLib.depositorPoolAssets(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Returns pool weights\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\n  /// @return totalWeight Total sum of all items of {weights}\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    return BalancerLogicLib.depositorPoolWeights(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of DAI, USDC, USDT\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \"Balancer Boosted Aave USD\" we return:\n  ///                     0: balance DAI + (balance amDAI recalculated to DAI)\n  ///                     1: balance USDC + (amUSDC recalculated to USDC)\n  ///                     2: balance USDT + (amUSDT recalculated to USDT)\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reservesOut) {\n    reservesOut = BalancerLogicLib.depositorPoolReserves(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() override internal virtual view returns (uint liquidityOut) {\n    liquidityOut = gauge.balanceOf(address(this))\n    + IComposableStablePool(BalancerLogicLib.getPoolAddress(poolId)).balanceOf(address(this));\n  }\n\n  //// @notice Total amount of liquidity (LP tokens) in the depositor\n  function _depositorTotalSupply() override internal view returns (uint totalSupplyOut) {\n    totalSupplyOut = IComposableStablePool(BalancerLogicLib.getPoolAddress(poolId)).getActualSupply();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  ///         i.e. for \"Balancer Boosted Aave USD\" we have DAI, USDC, USDT\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    bytes32 _poolId = poolId;\n    IComposableStablePool pool = IComposableStablePool(BalancerLogicLib.getPoolAddress(_poolId));\n\n    // join to the pool, receive pool-BPTs\n    (amountsConsumedOut, liquidityOut) = BalancerLogicLib.depositorEnter(BALANCER_VAULT, _poolId, amountsDesired_);\n\n    // stake all available pool-BPTs to the gauge\n    // we can have pool-BPTs on depositor's balance after previous exit, stake them too\n    gauge.deposit(pool.balanceOf(address(this)));\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then should make full exit\n  /// @param liquidityAmount_ Max amount to withdraw in bpt. Actual withdrawn amount will be less,\n  ///                         so it worth to add a gap to this amount, i.e. 1%\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function _depositorExit(uint liquidityAmount_) override internal virtual returns (\n    uint[] memory amountsOut\n  ) {\n    bytes32 _poolId = poolId;\n    IBalancerGauge __gauge = gauge;\n    IComposableStablePool pool = IComposableStablePool(BalancerLogicLib.getPoolAddress(_poolId));\n\n    // we need to withdraw pool-BPTs from the _gauge\n    // at first, let's try to use exist pool-BPTs on the depositor balance, probably it's enough\n    // we can have pool-BPTs on depositor's balance after previous exit, see BalancerLogicLib.depositorExit\n    uint depositorBalance = pool.balanceOf(address(this));\n    uint gaugeBalance = __gauge.balanceOf(address(this));\n\n    uint liquidityToWithdraw = liquidityAmount_ > depositorBalance\n    ? liquidityAmount_ - depositorBalance\n    : 0;\n\n    // calculate how much pool-BPTs we should withdraw from the gauge\n    if (liquidityToWithdraw > 0) {\n      if (liquidityToWithdraw > gaugeBalance) {\n        liquidityToWithdraw = gaugeBalance;\n      }\n    }\n\n    // un-stake required pool-BPTs from the gauge\n    if (liquidityToWithdraw > 0) {\n      __gauge.withdraw(liquidityToWithdraw);\n    }\n\n    // withdraw the liquidity from the pool\n    amountsOut = (liquidityAmount_ >= depositorBalance + gaugeBalance)\n    ? BalancerLogicLib.depositorExitFull(BALANCER_VAULT, _poolId)\n    : BalancerLogicLib.depositorExit(BALANCER_VAULT, _poolId, liquidityToWithdraw);\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then full exit is required\n  ///      we emulate is at normal exit + conversion of remain BPT directly to the main asset\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function _depositorQuoteExit(uint liquidityAmount_) override internal virtual returns (uint[] memory amountsOut) {\n    uint liquidity = _depositorLiquidity();\n    if (liquidity == 0) {\n      // there is no liquidity, output is zero\n      return new uint[](_depositorPoolAssets().length);\n    } else {\n      // BalancerLogicLib.depositorQuoteExit takes into account the cost of unused BPT\n      // so we don't need a special logic here for the full exit\n      return BalancerLogicLib.depositorQuoteExit(\n        BALANCER_VAULT,\n        IBalancerHelper(BALANCER_HELPER),\n        poolId,\n        liquidityAmount_\n      );\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Claim all possible rewards.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut,\n    uint[] memory depositorBalancesBefore\n  ) {\n    return BalancerLogicLib.depositorClaimRewards(gauge, _depositorPoolAssets(), rewardTokens());\n  }\n\n  /// @dev Returns reward token addresses array.\n  function rewardTokens() public view returns (address[] memory tokens) {\n    uint total;\n    for (; total < 8; ++total) {\n      if (gauge.reward_tokens(total) == address(0)) {\n        break;\n      }\n    }\n    tokens = new address[](total + 1);\n    for (uint i; i < total; ++i) {\n      tokens[i] = gauge.reward_tokens(i);\n    }\n\n    // BAL token is special, it's not registered inside gauge.reward_tokens, we claim it through pseudo-minter\n    tokens[total] = BAL_TOKEN;\n  }\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[50-2] private __gap; // 50 - count of variables\n}\n"
    },
    "contracts/strategies/balancer/BalancerBoostedStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./BalancerBoostedDepositor.sol\";\nimport \"../../libs/AppPlatforms.sol\";\n\n/// @title Delta-neutral converter strategy for Balancer boosted pools\n/// @author a17, dvpublic\n/// @notice Versions:\n/// 1.0.2 Add setGauge, move to balancer gauges v2\ncontract BalancerBoostedStrategy is ConverterStrategyBase, BalancerBoostedDepositor {\n  string public constant override NAME = \"Balancer Boosted Strategy\";\n  string public constant override PLATFORM = AppPlatforms.BALANCER;\n  string public constant override STRATEGY_VERSION = \"1.0.2\";\n\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address pool_,\n    address gauge_\n  ) external initializer {\n    __BalancerBoostedDepositor_init(pool_, gauge_);\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n\n    // setup specific name for UI\n    strategySpecificName = BalancerLogicLib.createSpecificName(pool_);\n    emit StrategyLib.StrategySpecificNameChanged(strategySpecificName);\n  }\n\n  function _handleRewards() internal virtual override returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    uint assetBalanceBefore = AppLib.balance(asset);\n    (address[] memory rewardTokens, uint[] memory amounts) = _claim();\n    _rewardsLiquidation(rewardTokens, amounts);\n    assetBalanceAfterClaim = AppLib.balance(asset);\n    (uint earned2, uint lost2) = ConverterStrategyBaseLib.registerIncome(assetBalanceBefore, assetBalanceAfterClaim);\n    return (earned + earned2, lost + lost2, assetBalanceAfterClaim);\n  }\n\n  function setGauge(address gauge_) external {\n    require(msg.sender == IController(controller()).governance(), AppErrors.GOVERNANCE_ONLY);\n\n    IBalancerGauge gaugeOld = IBalancerGauge(gauge);\n    uint balance = gaugeOld.balanceOf(address(this));\n    if (balance != 0) {\n      gaugeOld.withdraw(balance);\n    }\n\n    IBalancerGauge gaugeNew = IBalancerGauge(gauge_);\n    gauge = gaugeNew;\n\n    if (balance != 0) {\n      gaugeNew.deposit(balance);\n    }\n  }\n}\n"
    },
    "contracts/strategies/balancer/BalancerLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\nimport \"../../libs/AppErrors.sol\";\nimport \"../../libs/AppLib.sol\";\nimport \"../../libs/TokenAmountsLib.sol\";\nimport \"../../integrations/balancer/IComposableStablePool.sol\";\nimport \"../../integrations/balancer/ILinearPool.sol\";\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../integrations/balancer/IBalancerHelper.sol\";\nimport \"../../integrations/balancer/IBalancerGauge.sol\";\nimport \"../../integrations/balancer/IBalancerMinter.sol\";\n\n/// @notice Functions of BalancerBoostedDepositor\n/// @dev Many of functions are declared as external to reduce contract size\nlibrary BalancerLogicLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Types\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev local vars in getAmountsToDeposit to avoid stack too deep\n  struct LocalGetAmountsToDeposit {\n    /// @notice Decimals of {tokens_}, 0 for BPT\n    uint[] decimals;\n    /// @notice Length of {tokens_} array\n    uint len;\n    /// @notice amountBPT / underlyingAmount, decimals 18, 0 for BPT\n    uint[] rates;\n  }\n\n  /// @notice Local variables required inside _depositorEnter/Exit/QuoteExit, avoid stack too deep\n  struct DepositorLocal {\n    uint bptIndex;\n    uint len;\n    IERC20[] tokens;\n    uint[] balances;\n  }\n\n  /// @notice Used in linear pool quote swap math logic\n  struct LinearPoolParams {\n    uint fee;\n    uint lowerTarget;\n    uint upperTarget;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Asset related utils\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate amounts of {tokens} to be deposited to POOL_ID in proportions according to the {balances}\n  /// @param amountsDesired_ Desired amounts of tokens. The order of the tokens is exactly the same as in {tokens}.\n  ///                        But the array has length 3, not 4, because there is no amount for bb-am-USD here.\n  /// @param tokens_ All bb-am-* tokens (including bb-am-USD) received through getPoolTokens\n  ///                           The order of the tokens is exactly the same as in getPoolTokens-results\n  /// @param balances_ Balances of bb-am-* pools in terms of bb-am-USD tokens (received through getPoolTokens)\n  ///                           The order of the tokens is exactly the same as in {tokens}\n  /// @param totalUnderlying_ Total amounts of underlying assets (DAI, USDC, etc) in embedded linear pools.\n  ///                         The array should have same order of tokens as {tokens_}, value for BPT token is not used\n  /// @param indexBpt_ Index of BPT token inside {balances_}, {tokens_} and {totalUnderlying_} arrays\n  /// @return amountsOut Desired amounts in proper proportions for depositing.\n  ///         The order of the tokens is exactly the same as in results of getPoolTokens, 0 for BPT\n  ///         i.e. DAI, BB-AM-USD, USDC, USDT\n  function getAmountsToDeposit(\n    uint[] memory amountsDesired_,\n    IERC20[] memory tokens_,\n    uint[] memory balances_,\n    uint[] memory totalUnderlying_,\n    uint indexBpt_\n  ) internal view returns (\n    uint[] memory amountsOut\n  ) {\n    LocalGetAmountsToDeposit memory p;\n    // check not zero balances, cache index of bbAmUSD, save 10**decimals to array\n    p.len = tokens_.length;\n    require(p.len == balances_.length, AppErrors.WRONG_LENGTHS);\n    require(p.len == amountsDesired_.length || p.len - 1 == amountsDesired_.length, AppErrors.WRONG_LENGTHS);\n\n    p.decimals = new uint[](p.len);\n    p.rates = new uint[](p.len);\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexBpt_) {\n        require(balances_[i] != 0, AppErrors.ZERO_BALANCE);\n        p.decimals[i] = 10 ** IERC20Metadata(address(tokens_[i])).decimals();\n\n        // Let's calculate a rate: amountBPT / underlyingAmount, decimals 18\n        p.rates[i] = balances_[i] * 1e18 / totalUnderlying_[i];\n      }\n    }\n\n    amountsOut = new uint[](p.len - 1);\n\n    // The balances set proportions of underlying-bpt, i.e. bb-am-DAI : bb-am-USDC : bb-am-USDT\n    // Our task is find amounts of DAI : USDC : USDT that won't change that proportions after deposit.\n    // We have arbitrary desired amounts, i.e. DAI = X, USDC = Y, USDT = Z\n    // For each token: assume that it can be used in full.\n    // If so, what amounts will have other tokens in this case according to the given proportions?\n    // i.e. DAI = X = 100.0 => USDC = 200.0, USDT = 400.0. We need: Y >= 200, Z >= 400\n    // or   USDC = Y = 100.0 => DAI = 50.0, USDT = 200.0. We need: X >= 50, Z >= 200\n    // If any amount is less then expected, the token cannot be used in full.\n    // A token with min amount can be used in full, let's try to find its index.\n    // [0 : len - 1]\n    uint i3;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (indexBpt_ == i) continue;\n\n      uint amountInBpt18 = amountsDesired_[i3] * p.rates[i];\n\n      // [0 : len]\n      uint j;\n      // [0 : len - 1]\n      uint j3;\n      for (; j < p.len; j = AppLib.uncheckedInc(j)) {\n        if (indexBpt_ == j) continue;\n\n        // alpha = balancesDAI / balancesUSDC * decimalsDAI / decimalsUSDC\n        // amountDAI = amountUSDC * alpha * rateUSDC / rateDAI\n        amountsOut[j3] = amountInBpt18 * balances_[j] / p.rates[j] * p.decimals[j] / balances_[i] / p.decimals[i];\n        if (amountsOut[j3] > amountsDesired_[j3]) break;\n        j3++;\n      }\n\n      if (j == p.len) break;\n      i3++;\n    }\n  }\n\n  /// @notice Calculate total amount of underlying asset for each token except BPT\n  /// @dev Amount is calculated as MainTokenAmount + WrappedTokenAmount * WrappedTokenRate, see AaveLinearPool src\n  function getTotalAssetAmounts(IBVault vault_, IERC20[] memory tokens_, uint indexBpt_) internal view returns (\n    uint[] memory amountsOut\n  ) {\n    uint len = tokens_.length;\n    amountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexBpt_) {\n        ILinearPool linearPool = ILinearPool(address(tokens_[i]));\n        (, uint[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\n\n        amountsOut[i] =\n          balances[linearPool.getMainIndex()]\n          + balances[linearPool.getWrappedIndex()] * linearPool.getWrappedTokenRate() / 1e18;\n      }\n    }\n  }\n\n  /// @notice Split {liquidityAmount_} by assets according to proportions of their total balances\n  /// @param liquidityAmount_ Amount to withdraw in bpt\n  /// @param balances_ Balances received from getPoolTokens\n  /// @param bptIndex_ Index of pool-pbt inside {balances_}\n  /// @return bptAmountsOut Amounts of underlying-BPT. The array doesn't include an amount for pool-bpt\n  ///         Total amount of {bptAmountsOut}-items is equal to {liquidityAmount_}\n  function getBtpAmountsOut(\n    uint liquidityAmount_,\n    uint[] memory balances_,\n    uint bptIndex_\n  ) internal pure returns (uint[] memory bptAmountsOut) {\n    // we assume here, that len >= 2\n    // we don't check it because StableMath.sol in balancer has _MIN_TOKENS = 2;\n    uint len = balances_.length;\n    bptAmountsOut = new uint[](len - 1);\n\n    // compute total balance, skip pool-bpt\n    uint totalBalances;\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex_) continue;\n      totalBalances += balances_[i];\n      // temporary save incomplete amounts to bptAmountsOut\n      bptAmountsOut[k] = liquidityAmount_ * balances_[i];\n      ++k;\n    }\n\n    // finalize computation of bptAmountsOut using known totalBalances\n    uint total;\n    for (k = 0; k < len - 1; k = AppLib.uncheckedInc(k)) {\n      if (k == len - 2) {\n        // leftovers => last item\n        bptAmountsOut[k] = total > liquidityAmount_\n          ? 0\n          : liquidityAmount_ - total;\n      } else {\n        bptAmountsOut[k] /= totalBalances;\n        total += bptAmountsOut[k];\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Depositor view logic\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of USDT, USDC, DAI\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \"Balancer Boosted Tetu USD\" we return:\n  ///                     0: balance USDT + (tUSDT recalculated to USDT)\n  ///                     1: balance USDC + (tUSDC recalculated to USDC)\n  ///                     2: balance DAI + (balance tDAI recalculated to DAI)\n  function depositorPoolReserves(IBVault vault_, bytes32 poolId_) external view returns (uint[] memory reservesOut) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    uint bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    uint len = tokens.length;\n    // exclude pool-BPT\n    reservesOut = new uint[](len - 1);\n\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex) continue;\n      ILinearPool linearPool = ILinearPool(address(tokens[i]));\n\n      // Each bb-t-* returns (main-token, wrapped-token, bb-t-itself), the order of tokens is arbitrary\n      // i.e. (DAI + tDAI + bb-t-DAI) or (bb-t-USDC, tUSDC, USDC)\n\n      // get balances of all tokens of bb-am-XXX token, i.e. balances of (DAI, amDAI, bb-am-DAI)\n      (, uint[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\n      // DAI\n      uint mainIndex = linearPool.getMainIndex();\n      // tDAI\n      uint wrappedIndex = linearPool.getWrappedIndex();\n\n      reservesOut[k] = balances[mainIndex] + balances[wrappedIndex] * linearPool.getWrappedTokenRate() / 1e18;\n      ++k;\n    }\n  }\n\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\n  function depositorPoolAssets(IBVault vault_, bytes32 poolId_) external view returns (address[] memory poolAssets) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    uint bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    uint len = tokens.length;\n\n    poolAssets = new address[](len - 1);\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex) continue;\n\n      poolAssets[k] = ILinearPool(address(tokens[i])).getMainToken();\n      ++k;\n    }\n  }\n\n  /// @notice Returns pool weights\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\n  /// @return totalWeight Total sum of all items of {weights}\n  function depositorPoolWeights(IBVault vault_, bytes32 poolId_) external view returns (\n    uint[] memory weights,\n    uint totalWeight\n  ) {\n    (IERC20[] memory tokens,uint[] memory balances,) = vault_.getPoolTokens(poolId_);\n    uint len = tokens.length;\n    uint bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    weights = new uint[](len - 1);\n    uint j;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i != bptIndex) {\n        totalWeight += balances[i];\n        weights[j] = balances[i];\n        j = AppLib.uncheckedInc(j);\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Depositor enter, exit logic\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  ///         i.e. for \"Balancer Boosted Aave USD\" we have DAI, USDC, USDT\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\n  function depositorEnter(IBVault vault_, bytes32 poolId_, uint[] memory amountsDesired_) external returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    DepositorLocal memory p;\n\n    // The implementation below assumes, that getPoolTokens returns the assets in following order:\n    //    bb-am-dai, bb-am-usd, bb-am-usdc, bb-am-usdt\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n\n    // temporary save current liquidity\n    liquidityOut = IComposableStablePool(address(p.tokens[p.bptIndex])).balanceOf(address(this));\n\n    // Original amounts can have any values.\n    // But we need amounts in such proportions that won't move the current balances\n    {\n      uint[] memory underlying = BalancerLogicLib.getTotalAssetAmounts(vault_, p.tokens, p.bptIndex);\n      amountsConsumedOut = BalancerLogicLib.getAmountsToDeposit(amountsDesired_, p.tokens, p.balances, underlying, p.bptIndex);\n    }\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n      sender: address(this),\n      fromInternalBalance: false,\n      recipient: payable(address(this)),\n      toInternalBalance: false\n    });\n\n    // swap all tokens XX => bb-am-XX\n    // we need two arrays with same amounts: amountsToDeposit (with 0 for BB-AM-USD) and userDataAmounts (no BB-AM-USD)\n    uint[] memory amountsToDeposit = new uint[](p.len);\n    // no bpt\n    uint[] memory userDataAmounts = new uint[](p.len - 1);\n    uint k;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      amountsToDeposit[i] = BalancerLogicLib.swap(\n        vault_,\n        ILinearPool(address(p.tokens[i])).getPoolId(),\n        ILinearPool(address(p.tokens[i])).getMainToken(),\n        address(p.tokens[i]),\n        amountsConsumedOut[k],\n        funds\n      );\n      userDataAmounts[k] = amountsToDeposit[i];\n      AppLib.approveIfNeeded(address(p.tokens[i]), amountsToDeposit[i], address(vault_));\n      ++k;\n    }\n\n    // add liquidity to balancer\n    vault_.joinPool(\n      poolId_,\n      address(this),\n      address(this),\n      IBVault.JoinPoolRequest({\n        assets: asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\n        maxAmountsIn: amountsToDeposit,\n        userData: abi.encode(IBVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, userDataAmounts, 0),\n        fromInternalBalance: false\n      })\n    );\n\n    uint liquidityAfter = IERC20(address(p.tokens[p.bptIndex])).balanceOf(address(this));\n\n    liquidityOut = liquidityAfter > liquidityOut\n      ? liquidityAfter - liquidityOut\n      : 0;\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @param liquidityAmount_ Amount to withdraw in bpt\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorExit(IBVault vault_, bytes32 poolId_, uint liquidityAmount_) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n\n    require(liquidityAmount_ <= p.tokens[p.bptIndex].balanceOf(address(this)), AppErrors.NOT_ENOUGH_BALANCE);\n\n    // BalancerR can spend a bit less amount of liquidity than {liquidityAmount_}\n    // i.e. we if liquidityAmount_ = 2875841, we can have leftovers = 494 after exit\n    vault_.exitPool(\n      poolId_,\n      address(this),\n      payable(address(this)),\n      IBVault.ExitPoolRequest({\n        assets: asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\n        minAmountsOut: new uint[](p.len), // no limits\n        userData: abi.encode(IBVault.ExitKindComposableStable.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT, liquidityAmount_),\n        toInternalBalance: false\n      })\n    );\n\n    // now we have amBbXXX tokens; swap them to XXX assets\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n      sender: address(this),\n      fromInternalBalance: false,\n      recipient: payable(address(this)),\n      toInternalBalance: false\n    });\n\n    amountsOut = new uint[](p.len - 1);\n    uint k;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      uint amountIn = p.tokens[i].balanceOf(address(this));\n      if (amountIn != 0) {\n        amountsOut[k] = swap(\n          vault_,\n          ILinearPool(address(p.tokens[i])).getPoolId(),\n          address(p.tokens[i]),\n          ILinearPool(address(p.tokens[i])).getMainToken(),\n          amountIn,\n          funds\n        );\n      }\n      ++k;\n    }\n  }\n\n  /// @notice Withdraw all available amount of LP-tokens from the pool\n  ///         BalanceR doesn't allow to withdraw exact amount, so it's allowed to leave dust amount on the balance\n  /// @dev We make at most N attempts to withdraw (not more, each attempt takes a lot of gas).\n  ///      Each attempt reduces available balance at ~1e4 times.\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///                    The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorExitFull(IBVault vault_, bytes32 poolId_) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n    amountsOut = new uint[](p.len - 1);\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n      sender: address(this),\n      fromInternalBalance: false,\n      recipient: payable(address(this)),\n      toInternalBalance: false\n    });\n\n    uint liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\n    if (liquidityAmount > 0) {\n      uint liquidityThreshold = 10 ** IERC20Metadata(address(p.tokens[p.bptIndex])).decimals() / 100;\n\n      // we can make at most N attempts to withdraw amounts from the balanceR pool\n      for (uint i = 0; i < 2; ++i) {\n        vault_.exitPool(\n          poolId_,\n          address(this),\n          payable(address(this)),\n          IBVault.ExitPoolRequest({\n            assets: asIAsset(p.tokens),\n            minAmountsOut: new uint[](p.len), // no limits\n            userData: abi.encode(IBVault.ExitKindComposableStable.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT, liquidityAmount),\n            toInternalBalance: false\n          })\n        );\n        liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\n        if (liquidityAmount < liquidityThreshold || i == 1) {\n          break;\n        }\n        (, p.balances,) = vault_.getPoolTokens(poolId_);\n      }\n\n      // now we have amBbXXX tokens; swap them to XXX assets\n      uint k;\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n        if (i == p.bptIndex) continue;\n\n        uint amountIn = p.tokens[i].balanceOf(address(this));\n        if (amountIn != 0) {\n          amountsOut[k] = swap(\n            vault_,\n            ILinearPool(address(p.tokens[i])).getPoolId(),\n            address(p.tokens[i]),\n            ILinearPool(address(p.tokens[i])).getMainToken(),\n            amountIn,\n            funds\n          );\n        }\n        ++k;\n      }\n    }\n\n    uint depositorBalance = p.tokens[p.bptIndex].balanceOf(address(this));\n    if (depositorBalance > 0) {\n      uint k = 0;\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n        if (i == p.bptIndex) continue;\n\n        // we assume here, that the depositorBalance is small\n        // so we can directly swap it to any single asset without changing of pool resources proportions\n        amountsOut[k] += _convertSmallBptRemainder(vault_, poolId_, p, funds, depositorBalance, i);\n        break;\n      }\n    }\n\n    return amountsOut;\n  }\n\n  /// @notice convert remained SMALL amount of bpt => am-bpt => main token of the am-bpt\n  /// @return amountOut Received amount of am-bpt's main token\n  function _convertSmallBptRemainder(\n    IBVault vault_,\n    bytes32 poolId_,\n    DepositorLocal memory p,\n    IBVault.FundManagement memory funds,\n    uint bptAmountIn_,\n    uint indexTargetAmBpt_\n  ) internal returns (uint amountOut) {\n    uint amountAmBpt = BalancerLogicLib.swap(\n      vault_,\n      poolId_,\n      address(p.tokens[p.bptIndex]),\n      address(p.tokens[indexTargetAmBpt_]),\n      bptAmountIn_,\n      funds\n    );\n    amountOut = swap(\n      vault_,\n      ILinearPool(address(p.tokens[indexTargetAmBpt_])).getPoolId(),\n      address(p.tokens[indexTargetAmBpt_]),\n      ILinearPool(address(p.tokens[indexTargetAmBpt_])).getMainToken(),\n      amountAmBpt,\n      funds\n    );\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorQuoteExit(\n    IBVault vault_,\n    IBalancerHelper helper_,\n    bytes32 poolId_,\n    uint liquidityAmount_\n  ) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n\n    (, uint[] memory amountsBpt) = helper_.queryExit(\n      poolId_,\n      address(this),\n      payable(address(this)),\n      IBVault.ExitPoolRequest({\n        assets: asIAsset(p.tokens),\n        minAmountsOut: new uint[](p.len), // no limits\n        userData: abi.encode(\n          IBVault.ExitKindComposableStable.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT,\n          liquidityAmount_\n        ),\n        toInternalBalance: false\n      })\n    );\n\n    uint k;\n    amountsOut = new uint[](p.len - 1);\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      ILinearPool linearPool = ILinearPool(address(p.tokens[i]));\n      amountsOut[k] = _calcLinearMainOutPerBptIn(vault_, linearPool, amountsBpt[i]);\n      ++k;\n    }\n  }\n\n  /// @notice Swap given {amountIn_} of {assetIn_} to {assetOut_} using the given BalanceR pool\n  function swap(\n    IBVault vault_,\n    bytes32 poolId_,\n    address assetIn_,\n    address assetOut_,\n    uint amountIn_,\n    IBVault.FundManagement memory funds_\n  ) internal returns (uint amountOut) {\n    uint balanceBefore = IERC20(assetOut_).balanceOf(address(this));\n\n    IERC20(assetIn_).approve(address(vault_), amountIn_);\n    vault_.swap(\n      IBVault.SingleSwap({\n        poolId: poolId_,\n        kind: IBVault.SwapKind.GIVEN_IN,\n        assetIn: IAsset(assetIn_),\n        assetOut: IAsset(assetOut_),\n        amount: amountIn_,\n        userData: bytes(\"\")\n      }),\n      funds_,\n      1,\n      block.timestamp\n    );\n\n    // we assume here, that the balance cannot be decreased\n    amountOut = IERC20(assetOut_).balanceOf(address(this)) - balanceBefore;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Rewards\n  /////////////////////////////////////////////////////////////////////\n\n  function depositorClaimRewards(IBalancerGauge gauge_, address[] memory tokens_, address[] memory rewardTokens_) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut,\n    uint[] memory depositorBalancesBefore\n  ) {\n    uint tokensLen = tokens_.length;\n    uint rewardTokensLen = rewardTokens_.length;\n\n    tokensOut = new address[](rewardTokensLen);\n    amountsOut = new uint[](rewardTokensLen);\n    depositorBalancesBefore = new uint[](tokensLen);\n\n    for (uint i; i < tokensLen; i = AppLib.uncheckedInc(i)) {\n      depositorBalancesBefore[i] = IERC20(tokens_[i]).balanceOf(address(this));\n    }\n\n    for (uint i; i < rewardTokensLen; i = AppLib.uncheckedInc(i)) {\n      tokensOut[i] = rewardTokens_[i];\n\n      // temporary store current reward balance\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this));\n    }\n\n    // claim BAL tokens\n    IBalancerMinter(gauge_.bal_pseudo_minter()).mint(address(gauge_));\n\n    // claim other rewards\n    gauge_.claim_rewards();\n\n    for (uint i; i < rewardTokensLen; i = AppLib.uncheckedInc(i)) {\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this)) - amountsOut[i];\n    }\n\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Utils\n  /////////////////////////////////////////////////////////////////////\n\n  function createSpecificName(address pool_) external view returns (string memory) {\n    return string(abi.encodePacked(\"Balancer \", IERC20Metadata(pool_).symbol()));\n  }\n\n  /// @dev Returns the address of a Pool's contract.\n  ///      Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\n  function getPoolAddress(bytes32 id) internal pure returns (address) {\n    // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\n    // since the logical shift already sets the upper bits to zero.\n    return address(uint160(uint(id) >> (12 * 8)));\n  }\n\n  /// @dev see balancer-labs, ERC20Helpers.sol\n  function asIAsset(IERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      assets := tokens\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Linear pool quote swap math logic\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev This logic is needed for hardworks in conditions of lack of funds in linear pools.\n  ///      The lack of funds in linear pools is a typical situation caused by pool rebalancing after deposits from the strategy.\n  ///      Main tokens are leaving linear pools to mint wrapped tokens.\n  function _calcLinearMainOutPerBptIn(IBVault vault, ILinearPool pool, uint amount) internal view returns (uint) {\n    (uint lowerTarget, uint upperTarget) = pool.getTargets();\n    LinearPoolParams memory params = LinearPoolParams(pool.getSwapFeePercentage(), lowerTarget, upperTarget);\n    (,uint[] memory balances,) = vault.getPoolTokens(pool.getPoolId());\n    uint[] memory scalingFactors = pool.getScalingFactors();\n    _upscaleArray(balances, scalingFactors);\n    amount *= scalingFactors[0] / 1e18;\n    uint mainIndex = pool.getMainIndex();\n    uint mainBalance = balances[mainIndex];\n    uint bptSupply = pool.totalSupply() - balances[0];\n    uint previousNominalMain = _toNominal(mainBalance, params);\n    uint invariant = previousNominalMain + balances[pool.getWrappedIndex()];\n    uint deltaNominalMain = invariant * amount / bptSupply;\n    uint afterNominalMain = previousNominalMain > deltaNominalMain ? previousNominalMain - deltaNominalMain : 0;\n    uint newMainBalance = _fromNominal(afterNominalMain, params);\n    return (mainBalance - newMainBalance) * 1e18 / scalingFactors[mainIndex];\n  }\n\n  function _toNominal(uint real, LinearPoolParams memory params) internal pure returns (uint) {\n    if (real < params.lowerTarget) {\n      uint fees = (params.lowerTarget - real) * params.fee / 1e18;\n      return real - fees;\n    } else if (real <= params.upperTarget) {\n      return real;\n    } else {\n      uint fees = (real - params.upperTarget) * params.fee / 1e18;\n      return real - fees;\n    }\n  }\n\n  function _fromNominal(uint nominal, LinearPoolParams memory params) internal pure returns (uint) {\n    if (nominal < params.lowerTarget) {\n      return (nominal + (params.fee * params.lowerTarget / 1e18)) * 1e18 / (1e18 + params.fee);\n    } else if (nominal <= params.upperTarget) {\n      return nominal;\n    } else {\n      return (nominal - (params.fee * params.upperTarget / 1e18)) * 1e18 / (1e18 - params.fee);\n    }\n  }\n\n  function _upscaleArray(uint[] memory amounts, uint[] memory scalingFactors) internal pure {\n    uint length = amounts.length;\n    for (uint i; i < length; ++i) {\n      amounts[i] = amounts[i] * scalingFactors[i] / 1e18;\n    }\n  }\n}\n"
    },
    "contracts/strategies/ConverterStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\";\nimport \"./ConverterStrategyBaseLib.sol\";\nimport \"./ConverterStrategyBaseLib2.sol\";\nimport \"./DepositorBase.sol\";\n\n/////////////////////////////////////////////////////////////////////\n///                        TERMS\n///  Main asset == underlying: the asset deposited to the vault by users\n///  Secondary assets: all assets deposited to the internal pool except the main asset\n/////////////////////////////////////////////////////////////////////\n\n/// @title Abstract contract for base Converter strategy functionality\n/// @notice All depositor assets must be correlated (ie USDC/USDT/DAI)\n/// @author bogdoslav, dvpublic\nabstract contract ConverterStrategyBase is ITetuConverterCallback, DepositorBase, StrategyBaseV2 {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  //region DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n\n  struct WithdrawUniversalLocal {\n    bool all;\n    uint[] reservesBeforeWithdraw;\n    uint totalSupplyBeforeWithdraw;\n    uint depositorLiquidity;\n    uint liquidityAmountToWithdraw;\n    uint assetPrice;\n    uint[] amountsToConvert;\n    uint expectedTotalMainAssetAmount;\n    uint[] expectedMainAssetAmounts;\n    uint investedAssetsAfterWithdraw;\n    uint balanceAfterWithdraw;\n    address[] tokens;\n    address asset;\n    uint indexAsset;\n    uint balanceBefore;\n    uint[] withdrawnAmounts;\n    ITetuConverter converter;\n  }\n  //endregion DATA TYPES\n\n  /////////////////////////////////////////////////////////////////////\n  //region CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant CONVERTER_STRATEGY_BASE_VERSION = \"1.2.0\";\n\n  /// @notice 1% gap to cover possible liquidation inefficiency\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\n  uint internal constant GAP_CONVERSION = 1_000;\n  uint internal constant DENOMINATOR = 100_000;\n  //endregion CONSTANTS\n\n  /////////////////////////////////////////////////////////////////////\n  //region VARIABLES\n  //                Keep names and ordering!\n  // Add only in the bottom and don't forget to decrease gap variable\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Amount of underlying assets invested to the pool.\n  uint internal _investedAssets;\n\n  /// @dev Linked Tetu Converter\n  ITetuConverter public converter;\n\n  /// @notice Minimum token amounts that can be liquidated\n  mapping(address => uint) public liquidationThresholds;\n\n  /// @notice Percent of asset amount that can be not invested, it's allowed to just keep it on balance\n  ///         decimals = {DENOMINATOR}\n  /// @dev We need this threshold to avoid numerous conversions of small amounts\n  uint public reinvestThresholdPercent;\n\n  /// @notice Ratio to split performance fee on toPerf + toInsurance, [0..100_000]\n  ///         100_000 - send full amount toPerf, 0 - send full amount toInsurance.\n  uint public performanceFeeRatio;\n  //endregion VARIABLES\n\n  /////////////////////////////////////////////////////////////////////\n  //region Events\n  /////////////////////////////////////////////////////////////////////\n  event OnDepositorEnter(uint[] amounts, uint[] consumedAmounts);\n  event OnDepositorExit(uint liquidityAmount, uint[] withdrawnAmounts);\n  event OnDepositorEmergencyExit(uint[] withdrawnAmounts);\n  event OnHardWorkEarnedLost(\n    uint investedAssetsNewPrices,\n    uint earnedByPrices,\n    uint earnedHandleRewards,\n    uint lostHandleRewards,\n    uint earnedDeposit,\n    uint lostDeposit\n  );\n\n  /// @notice Recycle was made\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\n  /// @param amountsToForward Amounts to be sent to forwarder\n  event Recycle(\n    address[] rewardTokens,\n    uint[] amountsToForward,\n    uint toPerf,\n    uint toInsurance\n  );\n  //endregion Events\n\n  /////////////////////////////////////////////////////////////////////\n  //region Initialization and configuration\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __ConverterStrategyBase_init(\n    address controller_,\n    address splitter_,\n    address converter_\n  ) internal onlyInitializing {\n    __StrategyBase_init(controller_, splitter_);\n    converter = ITetuConverter(converter_);\n\n    // 1% by default\n    reinvestThresholdPercent = DENOMINATOR / 100;\n    emit ConverterStrategyBaseLib2.ReinvestThresholdPercentChanged(DENOMINATOR / 100);\n  }\n\n  function setLiquidationThreshold(address token, uint amount) external {\n    ConverterStrategyBaseLib2.checkLiquidationThresholdChanged(controller(), token, amount);\n    liquidationThresholds[token] = amount;\n  }\n\n  /// @param percent_ New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\n  function setReinvestThresholdPercent(uint percent_) external {\n    ConverterStrategyBaseLib2.checkReinvestThresholdPercentChanged(controller(), percent_);\n    reinvestThresholdPercent = percent_;\n  }\n\n  /// @notice [0..100_000], 100_000 - send full amount toPerf, 0 - send full amount toInsurance.\n  function setPerformanceFeeRatio(uint ratio_) external {\n    ConverterStrategyBaseLib2.checkPerformanceFeeRatioChanged(controller(), ratio_);\n    performanceFeeRatio = ratio_;\n  }\n  //endregion Initialization and configuration\n\n  /////////////////////////////////////////////////////////////////////\n  //region Deposit to the pool\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Amount of underlying assets converted to pool assets and invested to the pool.\n  function investedAssets() override public view virtual returns (uint) {\n    return _investedAssets;\n  }\n\n  /// @notice Deposit given amount to the pool.\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    uint strategyLoss\n  ){\n    (uint updatedInvestedAssets, uint earnedByPrices) = _fixPriceChanges(updateTotalAssetsBeforeInvest_);\n    (strategyLoss,) = _depositToPoolUniversal(amount_, earnedByPrices, updatedInvestedAssets);\n  }\n\n  /// @notice Deposit {amount_} to the pool, send {earnedByPrices_} to insurance.\n  ///         totalAsset will decrease on earnedByPrices_ and sharePrice won't change after all recalculations.\n  /// @dev We need to deposit {amount_} and withdraw {earnedByPrices_} here\n  /// @param amount_ Amount of underlying to be deposited\n  /// @param earnedByPrices_ Profit received because of price changing\n  /// @param investedAssets_ Invested assets value calculated with updated prices\n  /// @return strategyLoss Loss happened on the depositing. It doesn't include any price-changing losses\n  /// @return amountSentToInsurance Price-changing-profit that was sent to the insurance\n  function _depositToPoolUniversal(uint amount_, uint earnedByPrices_, uint investedAssets_) internal virtual returns (\n    uint strategyLoss,\n    uint amountSentToInsurance\n  ){\n    address _asset = asset;\n\n    uint amountToDeposit = amount_ > earnedByPrices_\n      ? amount_ - earnedByPrices_\n      : 0;\n\n    // skip deposit for small amounts\n    if (amountToDeposit > reinvestThresholdPercent * investedAssets_ / DENOMINATOR) {\n      if (earnedByPrices_ != 0) {\n        amountSentToInsurance = ConverterStrategyBaseLib2.sendToInsurance(\n          _asset,\n          earnedByPrices_,\n          splitter,\n          investedAssets_ + AppLib.balance(_asset)\n        );\n      }\n      uint balanceBefore = AppLib.balance(_asset);\n\n      (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n\n      // prepare array of amounts ready to deposit, borrow missed amounts\n      uint[] memory amounts = _beforeDeposit(converter, amountToDeposit, tokens, indexAsset);\n\n      // make deposit, actually consumed amounts can be different from the desired amounts\n      (uint[] memory consumedAmounts,) = _depositorEnter(amounts);\n      emit OnDepositorEnter(amounts, consumedAmounts);\n\n      // update _investedAssets with new deposited amount\n      uint updatedInvestedAssetsAfterDeposit = _updateInvestedAssets();\n      // after deposit some asset can exist\n      uint balanceAfter = AppLib.balance(_asset);\n      // we need to compensate difference if during deposit we lost some assets\n      if ((updatedInvestedAssetsAfterDeposit + balanceAfter) < (investedAssets_ + balanceBefore)) {\n        strategyLoss = (investedAssets_ + balanceBefore) - (updatedInvestedAssetsAfterDeposit + balanceAfter);\n      }\n    } else if (earnedByPrices_ != 0) {\n      // we just skip check of expectedWithdrewUSD here\n      uint balance = AppLib.balance(_asset);\n      if (balance < earnedByPrices_) {\n        (/* expectedWithdrewUSD */,, strategyLoss, amountSentToInsurance) = _withdrawUniversal(0, earnedByPrices_, investedAssets_);\n      } else {\n        amountSentToInsurance = ConverterStrategyBaseLib2.sendToInsurance(\n          _asset,\n          earnedByPrices_,\n          splitter,\n          investedAssets_ + balance\n        );\n      }\n    }\n\n    return (strategyLoss, amountSentToInsurance);\n  }\n  //endregion Deposit to the pool\n\n  /////////////////////////////////////////////////////////////////////\n  //region Convert amounts before deposit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Prepare {tokenAmounts} to be passed to depositorEnter\n  /// @dev Override this function to customize entry kind\n  /// @param amount_ The amount of main asset that should be invested\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return tokenAmounts Amounts of depositor's assets ready to invest (this array can be passed to depositorEnter)\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) internal virtual returns (\n    uint[] memory tokenAmounts\n  ) {\n    // calculate required collaterals for each token and temporary save them to tokenAmounts\n    (uint[] memory weights, uint totalWeight) = _depositorPoolWeights();\n\n    // temporary save collateral to tokensAmounts\n    tokenAmounts = ConverterStrategyBaseLib2.getCollaterals(\n      amount_,\n      tokens_,\n      weights,\n      totalWeight,\n      indexAsset_,\n      IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle())\n    );\n\n    // make borrow and save amounts of tokens available for deposit to tokenAmounts, zero result amounts are possible\n    tokenAmounts = ConverterStrategyBaseLib.getTokenAmounts(\n      tetuConverter_,\n      tokens_,\n      indexAsset_,\n      tokenAmounts,\n      liquidationThresholds[tokens_[indexAsset_]]\n    );\n  }\n  //endregion Convert amounts before deposit\n\n  /////////////////////////////////////////////////////////////////////\n  //region Withdraw from the pool\n  /////////////////////////////////////////////////////////////////////\n\n  function _beforeWithdraw(uint /*amount*/) internal virtual {\n    // do nothing\n  }\n\n  /// @notice Withdraw given amount from the pool.\n  /// @param amount Amount to be withdrawn in terms of the asset in addition to the exist balance.\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing (in USD, decimals of the {asset})\n  /// @return assetPrice Price of the {asset} from the price oracle\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawFromPool(uint amount) override internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  ) {\n    // calculate profit/loss because of price changes, try to compensate the loss from the insurance\n    (uint investedAssetsNewPrices, uint earnedByPrices) = _fixPriceChanges(true);\n    (expectedWithdrewUSD, assetPrice, strategyLoss,) = _withdrawUniversal(amount, earnedByPrices, investedAssetsNewPrices);\n  }\n\n  /// @notice Withdraw all from the pool.\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing\n  /// @return assetPrice Price of the {asset} taken from the price oracle\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawAllFromPool() override internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  ) {\n    return _withdrawFromPool(type(uint).max);\n  }\n\n  /// @param amount Amount to be trying to withdrawn. Max uint means attempt to withdraw all possible invested assets.\n  /// @param earnedByPrices_ Additional amount that should be withdrawn and send to the insurance\n  /// @param investedAssets_ Value of invested assets recalculated using current prices\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing in terms of USD value of each asset in the pool\n  /// @return __assetPrice Price of the {asset} taken from the price oracle\n  /// @return strategyLoss Loss before withdrawing: [new-investedAssets - old-investedAssets]\n  /// @return amountSentToInsurance Actual amount of underlying sent to the insurance\n  function _withdrawUniversal(uint amount, uint earnedByPrices_, uint investedAssets_) internal returns (\n    uint expectedWithdrewUSD,\n    uint __assetPrice,\n    uint strategyLoss,\n    uint amountSentToInsurance\n  ) {\n    _beforeWithdraw(amount);\n\n    WithdrawUniversalLocal memory v;\n    v.all = amount == type(uint).max;\n    strategyLoss = 0;\n\n    if ((v.all || amount + earnedByPrices_ != 0) && investedAssets_ != 0) {\n\n      // --- init variables ---\n      v.tokens = _depositorPoolAssets();\n      v.asset = asset;\n      v.converter = converter;\n      v.indexAsset = ConverterStrategyBaseLib.getAssetIndex(v.tokens, v.asset);\n      v.balanceBefore = AppLib.balance(v.asset);\n\n      v.reservesBeforeWithdraw = _depositorPoolReserves();\n      v.totalSupplyBeforeWithdraw = _depositorTotalSupply();\n      v.depositorLiquidity = _depositorLiquidity();\n      v.assetPrice = ConverterStrategyBaseLib.getAssetPriceFromConverter(v.converter, v.asset);\n      // -----------------------\n\n      // calculate how much liquidity we need to withdraw for getting the requested amount\n      (v.liquidityAmountToWithdraw, v.amountsToConvert) = ConverterStrategyBaseLib2.getLiquidityAmount(\n        v.all ? 0 : amount + earnedByPrices_,\n        address(this),\n        v.tokens,\n        v.indexAsset,\n        v.converter,\n        investedAssets_,\n        v.depositorLiquidity\n      );\n\n      if (v.liquidityAmountToWithdraw != 0) {\n\n        // =============== WITHDRAW =====================\n        // make withdraw\n        v.withdrawnAmounts = _depositorExit(v.liquidityAmountToWithdraw);\n        // the depositor is able to use less liquidity than it was asked, i.e. Balancer-depositor leaves some BPT unused\n        // use what exactly was withdrew instead of the expectation\n        // assume that liquidity cannot increase in _depositorExit\n        v.liquidityAmountToWithdraw = v.depositorLiquidity - _depositorLiquidity();\n        emit OnDepositorExit(v.liquidityAmountToWithdraw, v.withdrawnAmounts);\n        // ==============================================\n\n        // we need to call expectation after withdraw for calculate it based on the real liquidity amount that was withdrew\n        // it should be called BEFORE the converter will touch our positions coz we need to call quote the estimations\n        // amountsToConvert should contains amounts was withdrawn from the pool and amounts received from the converter\n        (v.expectedMainAssetAmounts, v.amountsToConvert) = ConverterStrategyBaseLib.postWithdrawActions(\n          v.converter,\n          v.tokens,\n          v.indexAsset,\n          v.reservesBeforeWithdraw,\n          v.liquidityAmountToWithdraw,\n          v.totalSupplyBeforeWithdraw,\n          v.amountsToConvert,\n          v.withdrawnAmounts\n        );\n      } else {\n        // we don't need to withdraw any amounts from the pool, available converted amounts are enough for us\n        v.expectedMainAssetAmounts = ConverterStrategyBaseLib.postWithdrawActionsEmpty(\n          v.converter,\n          v.tokens,\n          v.indexAsset,\n          v.amountsToConvert\n        );\n      }\n\n      // convert amounts to main asset\n      // it is safe to use amountsToConvert from expectation - we will try to repay only necessary amounts\n      v.expectedTotalMainAssetAmount += ConverterStrategyBaseLib.makeRequestedAmount(\n        v.tokens,\n        v.indexAsset,\n        v.amountsToConvert,\n        v.converter,\n        _getLiquidator(controller()),\n        v.all ? amount : amount + earnedByPrices_,\n        v.expectedMainAssetAmounts,\n        liquidationThresholds\n      );\n\n      if (earnedByPrices_ != 0) {\n        amountSentToInsurance = ConverterStrategyBaseLib2.sendToInsurance(\n          v.asset,\n          earnedByPrices_,\n          splitter,\n          investedAssets_ + v.balanceBefore\n        );\n      }\n\n      v.investedAssetsAfterWithdraw = _updateInvestedAssets();\n      v.balanceAfterWithdraw = AppLib.balance(v.asset);\n\n      // we need to compensate difference if during withdraw we lost some assets\n      if ((v.investedAssetsAfterWithdraw + v.balanceAfterWithdraw + earnedByPrices_) < (investedAssets_ + v.balanceBefore)) {\n        strategyLoss += (investedAssets_ + v.balanceBefore) - (v.investedAssetsAfterWithdraw + v.balanceAfterWithdraw + earnedByPrices_);\n      }\n\n      return (\n        v.expectedTotalMainAssetAmount * v.assetPrice / 1e18,\n        v.assetPrice,\n        strategyLoss,\n        amountSentToInsurance\n      );\n    }\n    return (0, 0, 0, 0);\n  }\n\n  /// @notice If pool supports emergency withdraw need to call it for emergencyExit()\n  function _emergencyExitFromPool() override internal virtual {\n    uint[] memory withdrawnAmounts = _depositorEmergencyExit();\n    emit OnDepositorEmergencyExit(withdrawnAmounts);\n\n    // convert amounts to main asset\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n    ConverterStrategyBaseLib.closePositionsToGetAmount(\n      converter,\n      _getLiquidator(controller()),\n      indexAsset,\n      liquidationThresholds,\n      type(uint).max,\n      tokens\n    );\n\n    // adjust _investedAssets\n    _updateInvestedAssets();\n  }\n  //endregion Withdraw from the pool\n\n  /////////////////////////////////////////////////////////////////////\n  //region Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claim all possible rewards.\n  function _claim() override internal virtual returns (address[] memory rewardTokensOut, uint[] memory amountsOut) {\n    // get rewards from the Depositor\n    (address[] memory rewardTokens, uint[] memory rewardAmounts, uint[] memory balancesBefore) = _depositorClaimRewards();\n\n    (rewardTokensOut, amountsOut) = ConverterStrategyBaseLib2.claimConverterRewards(\n      converter,\n      _depositorPoolAssets(),\n      rewardTokens,\n      rewardAmounts,\n      balancesBefore\n    );\n  }\n\n  /// @dev Call recycle process and send tokens to forwarder.\n  ///      Need to be separated from the claim process - the claim can be called by operator for other purposes.\n  function _rewardsLiquidation(address[] memory rewardTokens, uint[] memory amounts) internal {\n    uint len = rewardTokens.length;\n    if (len > 0) {\n      uint[] memory amountsToForward = _recycle(rewardTokens, amounts);\n\n      // send forwarder-part of the rewards to the forwarder\n      ConverterStrategyBaseLib2.sendTokensToForwarder(controller(), splitter, rewardTokens, amountsToForward);\n    }\n  }\n\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just left on the balance\n  ///   Performance amounts should be liquidate, result underlying should be sent to performance receiver and insurance.\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\n  /// @dev {_recycle} is implemented as separate (inline) function to simplify unit testing\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @return amountsToForward Amounts to be sent to forwarder\n  function _recycle(address[] memory rewardTokens_, uint[] memory rewardAmounts_) internal returns (\n    uint[] memory amountsToForward\n  ) {\n    address _asset = asset; // save gas\n\n    uint amountPerf; // total amount for the performance receiver and insurance\n    (amountsToForward, amountPerf) = ConverterStrategyBaseLib.recycle(\n      converter,\n      _asset,\n      compoundRatio,\n      _depositorPoolAssets(),\n      _getLiquidator(controller()),\n      liquidationThresholds,\n      rewardTokens_,\n      rewardAmounts_,\n      performanceFee\n    );\n\n    // send performance-part of the underlying to the performance receiver and insurance\n    (uint toPerf, uint toInsurance) = ConverterStrategyBaseLib2.sendPerformanceFee(\n      _asset,\n      amountPerf,\n      splitter,\n      performanceReceiver,\n      performanceFeeRatio\n    );\n\n    emit Recycle(rewardTokens_, amountsToForward, toPerf, toInsurance);\n  }\n  //endregion Claim rewards\n\n  /////////////////////////////////////////////////////////////////////\n  //region Hardwork\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice A virtual handler to make any action before hardwork\n  function _preHardWork(bool reInvest) internal virtual {}\n\n  /// @notice A virtual handler to make any action after hardwork\n  function _postHardWork() internal virtual {}\n\n  /// @notice Is strategy ready to hard work\n  function isReadyToHardWork() override external virtual view returns (bool) {\n    // check claimable amounts and compare with thresholds\n    return true;\n  }\n\n  /// @notice Do hard work with reinvesting\n  /// @return earned Earned amount in terms of {asset}\n  /// @return lost Lost amount in terms of {asset}\n  function doHardWork() override public returns (uint earned, uint lost) {\n    require(msg.sender == splitter, StrategyLib.DENIED);\n    return _doHardWork(true);\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  function _handleRewards() internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim);\n\n  /// @param reInvest Deposit to pool all available amount if it's greater than the threshold\n  /// @return earned Earned amount in terms of {asset}\n  /// @return lost Lost amount in terms of {asset}\n  function _doHardWork(bool reInvest) internal returns (uint earned, uint lost) {\n    // ATTENTION! splitter will not cover the loss if it is lower than profit\n    (uint investedAssetsNewPrices, uint earnedByPrices) = _fixPriceChanges(true);\n\n    _preHardWork(reInvest);\n\n    // claim rewards and get current asset balance\n    uint assetBalance;\n    (earned, lost, assetBalance) = _handleRewards();\n\n    // re-invest income\n    (, uint amountSentToInsurance) = _depositToPoolUniversal(\n      reInvest\n      && investedAssetsNewPrices != 0\n      && assetBalance > reinvestThresholdPercent * investedAssetsNewPrices / DENOMINATOR\n        ? assetBalance\n        : 0,\n      earnedByPrices,\n      investedAssetsNewPrices\n    );\n    (uint earned2, uint lost2) = ConverterStrategyBaseLib.registerIncome(\n      investedAssetsNewPrices + assetBalance, // assets in use before deposit\n      _investedAssets + AppLib.balance(asset) + amountSentToInsurance // assets in use after deposit\n    );\n\n    _postHardWork();\n\n    emit OnHardWorkEarnedLost(investedAssetsNewPrices, earnedByPrices, earned, lost, earned2, lost2);\n    return (earned + earned2, lost + lost2);\n  }\n  //endregion Hardwork\n\n  /////////////////////////////////////////////////////////////////////\n  //region InvestedAssets Calculations\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Updates cached _investedAssets to actual value\n  /// @dev Should be called after deposit / withdraw / claim; virtual - for ut\n  function _updateInvestedAssets() internal returns (uint investedAssetsOut) {\n    investedAssetsOut = _calcInvestedAssets();\n    _investedAssets = investedAssetsOut;\n  }\n\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return Invested asset amount under control (in terms of {asset})\n  function _calcInvestedAssets() internal returns (uint) {\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n    return ConverterStrategyBaseLib.calcInvestedAssets(\n      tokens,\n      // quote exit should check zero liquidity\n      _depositorQuoteExit(_depositorLiquidity()),\n      indexAsset,\n      converter\n    );\n  }\n\n  function calcInvestedAssets() external returns (uint) {\n    StrategyLib.onlyOperators(controller());\n    return _calcInvestedAssets();\n  }\n\n  /// @notice Calculate profit/loss happened because of price changing. Try to cover the loss, send the profit to the insurance\n  /// @param updateInvestedAssetsAmount_ If false - just return current value of invested assets\n  /// @return investedAssetsOut Updated value of {_investedAssets}\n  /// @return earnedOut Profit that was received because of price changes. It should be sent back to insurance.\n  ///                   It's to dangerous to get this to try to get this amount here because of the problem \"borrow-repay is not allowed in a single block\"\n  ///                   So, we need to handle it in the caller code.\n  function _fixPriceChanges(bool updateInvestedAssetsAmount_) internal returns (uint investedAssetsOut, uint earnedOut) {\n    if (updateInvestedAssetsAmount_) {\n      uint investedAssetsBefore = _investedAssets;\n      investedAssetsOut = _updateInvestedAssets();\n      earnedOut = ConverterStrategyBaseLib.coverPossibleStrategyLoss(investedAssetsBefore, investedAssetsOut, splitter);\n    } else {\n      investedAssetsOut = _investedAssets;\n      earnedOut = 0;\n    }\n  }\n  //endregion InvestedAssets Calculations\n\n  /////////////////////////////////////////////////////////////////////\n  //region ITetuConverterCallback\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Converters asks to send some amount back.\n  /// @param theAsset_ Required asset (either collateral or borrow)\n  /// @param amount_ Required amount of the {theAsset_}\n  /// @return amountOut Amount sent to balance of TetuConverter, amountOut <= amount_\n  function requirePayAmountBack(address theAsset_, uint amount_) external override returns (uint amountOut) {\n    address __converter = address(converter);\n    require(msg.sender == __converter, StrategyLib.DENIED);\n\n    // detect index of the target asset\n    (address[] memory tokens, uint indexTheAsset) = _getTokens(theAsset_);\n    // get amount of target asset available to be sent\n    uint balance = AppLib.balance(theAsset_);\n\n    // withdraw from the pool if not enough\n    if (balance < amount_) {\n      // the strategy doesn't have enough target asset on balance\n      // withdraw all from the pool but don't convert assets to underlying\n      uint liquidity = _depositorLiquidity();\n      if (liquidity != 0) {\n        uint[] memory withdrawnAmounts = _depositorExit(liquidity);\n        emit OnDepositorExit(liquidity, withdrawnAmounts);\n      }\n    }\n\n    amountOut = ConverterStrategyBaseLib.swapToGivenAmountAndSendToConverter(\n      amount_,\n      indexTheAsset,\n      tokens,\n      __converter,\n      controller(),\n      asset,\n      liquidationThresholds\n    );\n\n    // update invested assets anyway, even if we suppose it will be called in other places\n    _updateInvestedAssets();\n  }\n\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external override {\n    require(msg.sender == address(converter), StrategyLib.DENIED);\n\n    uint len = assets_.length;\n    require(len == amounts_.length, AppErrors.INCORRECT_LENGTHS);\n\n    // TetuConverter is able two call this function in two cases:\n    // 1) rebalancing (the health factor of some borrow is too low)\n    // 2) forcible closing of the borrow\n    // In both cases we update invested assets value here\n    // and avoid fixing any related losses in hardwork\n    _updateInvestedAssets();\n  }\n  //endregion ITetuConverterCallback\n\n  /////////////////////////////////////////////////////////////////////\n  //region Others\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Unlimited capacity by default\n  function capacity() external virtual view returns (uint) {\n    return 2 ** 255;\n    // almost same as type(uint).max but more gas efficient\n  }\n\n  function _getTokens(address asset_) internal view returns (address[] memory tokens, uint indexAsset) {\n    tokens = _depositorPoolAssets();\n    indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, asset_);\n    require(indexAsset != type(uint).max, StrategyLib.WRONG_VALUE);\n  }\n\n  function _getLiquidator(address controller_) internal view returns (ITetuLiquidator) {\n    return ITetuLiquidator(IController(controller_).liquidator());\n  }\n  //endregion Others\n\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[50 - 5] private __gap; // 50 - count of variables\n\n}\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppLib.sol\";\nimport \"../libs/TokenAmountsLib.sol\";\nimport \"../libs/ConverterEntryKinds.sol\";\n\nlibrary ConverterStrategyBaseLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  //region Data types\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\n  struct RecycleLocalParams {\n    /// @notice Compound amount + Performance amount\n    uint amountCP;\n    /// @notice Amount to compound\n    uint amountC;\n    /// @notice Amount to send to performance and insurance\n    uint amountP;\n    /// @notice Amount to forwarder + amount to compound\n    uint amountFC;\n    address rewardToken;\n    uint liquidationThresholdAsset;\n    uint len;\n    uint receivedAmountOut;\n  }\n\n  struct OpenPositionLocal {\n    uint entryKind;\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n  }\n\n  struct OpenPositionEntryKind1Local {\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n    uint c1;\n    uint c3;\n    uint ratio;\n    uint alpha;\n  }\n\n  struct CalcInvestedAssetsLocal {\n    uint len;\n    uint[] prices;\n    uint[] decs;\n    uint[] debts;\n  }\n\n  struct ConvertAfterWithdrawLocal {\n    address asset;\n    uint collateral;\n    uint spent;\n    uint received;\n    uint balance;\n    uint balanceBefore;\n    uint len;\n  }\n\n  struct SwapToGivenAmountInputParams {\n    uint targetAmount;\n    address[] tokens;\n    uint indexTargetAsset;\n    address underlying;\n    uint[] amounts;\n    ITetuConverter converter;\n    ITetuLiquidator liquidator;\n    uint liquidationThresholdForTargetAsset;\n    /// @notice Allow to swap more then required (i.e. 1_000 => +1%)\n    ///         to avoid additional swap if the swap return amount a bit less than we expected\n    uint overswap;\n  }\n\n  struct SwapToGivenAmountLocal {\n    uint len;\n    uint[] availableAmounts;\n    uint i;\n  }\n\n  struct CloseDebtsForRequiredAmountLocal {\n    uint len;\n    address asset;\n    uint collateral;\n    uint spentAmountIn;\n    uint receivedAmount;\n    uint balance;\n    uint[] tokensBalancesBefore;\n\n    uint totalDebt;\n    uint totalCollateral;\n\n    /// @notice Cost of $1 in terms of the assets, decimals 18\n    uint[] prices;\n    /// @notice 10**decimal for the assets\n    uint[] decs;\n\n    uint newBalance;\n  }\n  //endregion Data types\n\n  /////////////////////////////////////////////////////////////////////\n  //region Constants\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice approx one month for average block time 2 sec\n  uint internal constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\n  uint internal constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n  uint internal constant DENOMINATOR = 100_000;\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\n  uint internal constant PRICE_IMPACT_TOLERANCE = 300;\n  /// @notice borrow/collateral amount cannot be less than given number of tokens\n  uint internal constant DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD = 10;\n  /// @notice Allow to swap more then required (i.e. 1_000 => +1%) inside {swapToGivenAmount}\n  ///         to avoid additional swap if the swap will return amount a bit less than we expected\n  uint internal constant OVERSWAP = PRICE_IMPACT_TOLERANCE + _ASSET_LIQUIDATION_SLIPPAGE;\n  /// @dev Absolute value for any token\n  uint internal constant DEFAULT_LIQUIDATION_THRESHOLD = 100_000;\n  /// @notice 1% gap to cover possible liquidation inefficiency\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\n  uint internal constant GAP_CONVERSION = 1_000;\n  //endregion Constants\n\n  /////////////////////////////////////////////////////////////////////\n  //region Events\n  /////////////////////////////////////////////////////////////////////\n  /// @notice A borrow was made\n  event OpenPosition(\n    address converter,\n    address collateralAsset,\n    uint collateralAmount,\n    address borrowAsset,\n    uint borrowedAmount,\n    address recepient\n  );\n\n  /// @notice Some borrow(s) was/were repaid\n  event ClosePosition(\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    address recepient,\n    uint returnedAssetAmountOut,\n    uint returnedBorrowAmountOut\n  );\n\n  /// @notice A liquidation was made\n  event Liquidation(\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint spentAmountIn,\n    uint receivedAmountOut\n  );\n\n  event ReturnAssetToConverter(address asset, uint amount);\n\n  event FixPriceChanges(uint investedAssetsBefore, uint investedAssetsOut);\n  //endregion Events\n\n  /////////////////////////////////////////////////////////////////////\n  //region View functions\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Get amount of assets that we expect to receive after withdrawing\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\n  ///                  one of assets must be {asset_}\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\n  function getExpectedWithdrawnAmounts(\n    uint[] memory reserves_,\n    uint liquidityAmount_,\n    uint totalSupply_\n  ) internal pure returns (\n    uint[] memory withdrawnAmountsOut\n  ) {\n    uint ratio = totalSupply_ == 0\n      ? 0\n      : (liquidityAmount_ >= totalSupply_\n        ? 1e18\n        : 1e18 * liquidityAmount_ / totalSupply_\n      );\n\n    uint len = reserves_.length;\n    withdrawnAmountsOut = new uint[](len);\n\n    if (ratio != 0) {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\n      }\n    }\n  }\n\n  /// @return prices Asset prices in USD, decimals 18\n  /// @return decs 10**decimals\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\n    uint[] memory prices,\n    uint[] memory decs\n  ) {\n    prices = new uint[](len);\n    decs = new uint[](len);\n    {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\n      }\n    }\n  }\n\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\n    uint len = tokens_.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (tokens_[i] == asset_) {\n        return i;\n      }\n    }\n    return type(uint).max;\n  }\n  //endregion View functions\n\n  /////////////////////////////////////////////////////////////////////\n  //region Borrow and close positions\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  function openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdAmountIn_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return _openPosition(tetuConverter_, entryData_, collateralAsset_, borrowAsset_, amountIn_, thresholdAmountIn_);\n  }\n\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  /// @param thresholdAmountIn_ Min value of amountIn allowed for the second and subsequent conversions.\n  ///        0 - use default min value\n  ///        If amountIn becomes too low, no additional borrows are possible, so\n  ///        the rest amountIn is just added to collateral/borrow amount of previous conversion.\n  function _openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdAmountIn_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    if (thresholdAmountIn_ == 0) {\n      // zero threshold is not allowed because round-issues are possible, see openPosition.dust test\n      // we assume here, that it's useless to borrow amount using collateral/borrow amount\n      // less than given number of tokens (event for BTC)\n      thresholdAmountIn_ = DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD;\n    }\n    if (amountIn_ <= thresholdAmountIn_) {\n      return (0, 0);\n    }\n\n    OpenPositionLocal memory vars;\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\n    vars.entryKind = ConverterEntryKinds.getEntryKind(entryData_);\n    if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\n      return openPositionEntryKind1(\n        tetuConverter_,\n        entryData_,\n        collateralAsset_,\n        borrowAsset_,\n        amountIn_,\n        thresholdAmountIn_\n      );\n    } else {\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n        entryData_,\n        collateralAsset_,\n        amountIn_,\n        borrowAsset_,\n        _LOAN_PERIOD_IN_BLOCKS\n      );\n\n      uint len = vars.converters.length;\n      if (len > 0) {\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\n          vars.collateral;\n          vars.amountToBorrow;\n          if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\n            // we have exact amount of total collateral amount\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\n              ? amountIn_\n              : vars.collateralsRequired[i];\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\n              ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\n              : vars.amountsToBorrow[i];\n            amountIn_ -= vars.collateral;\n          } else {\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\n            // we have exact amount of total amount-to-borrow\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\n              ? amountIn_\n              : vars.amountsToBorrow[i];\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\n              ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\n              : vars.collateralsRequired[i];\n            amountIn_ -= vars.amountToBorrow;\n          }\n\n          if (amountIn_ < thresholdAmountIn_ && amountIn_ != 0) {\n            // dust amount is left, just leave it unused\n            // we cannot add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\n            amountIn_ = 0;\n          }\n\n          if (vars.amountToBorrow != 0) {\n            borrowedAmountOut += tetuConverter_.borrow(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n            collateralAmountOut += vars.collateral;\n            emit OpenPosition(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n          }\n\n          if (amountIn_ == 0) break;\n        }\n      }\n\n      return (collateralAmountOut, borrowedAmountOut);\n    }\n  }\n\n  /// @notice Open position using entry kind 1 - split provided amount on two parts according provided proportions\n  /// @param amountIn_ Amount of collateral to be divided on parts. We assume {amountIn_} > 0\n  /// @param collateralThreshold_ Min allowed collateral amount to be used for new borrow, > 0\n  /// @return collateralAmountOut Total collateral used to borrow {borrowedAmountOut}\n  /// @return borrowedAmountOut Total borrowed amount\n  function openPositionEntryKind1(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint collateralThreshold_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    OpenPositionEntryKind1Local memory vars;\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n      entryData_,\n      collateralAsset_,\n      amountIn_,\n      borrowAsset_,\n      _LOAN_PERIOD_IN_BLOCKS\n    );\n\n    uint len = vars.converters.length;\n    if (len > 0) {\n      // we should split amountIn on two amounts with proportions x:y\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\n      // calculate prices conversion ratio using price oracle, decimals 18\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\n\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\n        // and give us required proportions in result\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\n        // C1 is collateral amount left untouched (x)\n        // C2 is collateral amount converted to B2 (y)\n        // but if lending platform doesn't have enough liquidity\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        vars.ratio = (vars.collateralsRequired[i] + vars.c1) > amountIn_\n          ? 1e18 * amountIn_ / (vars.collateralsRequired[i] + vars.c1)\n          : 1e18;\n\n        vars.collateral = vars.collateralsRequired[i] * vars.ratio / 1e18;\n        vars.amountToBorrow = vars.amountsToBorrow[i] * vars.ratio / 1e18;\n\n        // skip any attempts to borrow zero amount or use too little collateral\n        if (vars.collateral < collateralThreshold_ || vars.amountToBorrow == 0) {\n          if (vars.collateralsRequired[i] + vars.c1 + collateralThreshold_ > amountIn_) {\n            // The lending platform has enough resources to make the borrow but amount of the borrow is too low\n            // Skip the borrow, leave leftover of collateral untouched\n            break;\n          } else {\n            // The lending platform doesn't have enough resources to make the borrow.\n            // We should try to make borrow on the next platform (if any)\n            continue;\n          }\n        }\n\n        require(\n          tetuConverter_.borrow(\n            vars.converters[i],\n            collateralAsset_,\n            vars.collateral,\n            borrowAsset_,\n            vars.amountToBorrow,\n            address(this)\n          ) == vars.amountToBorrow,\n          StrategyLib.WRONG_VALUE\n        );\n        emit OpenPosition(\n          vars.converters[i],\n          collateralAsset_,\n          vars.collateral,\n          borrowAsset_,\n          vars.amountToBorrow,\n          address(this)\n        );\n\n        borrowedAmountOut += vars.amountToBorrow;\n        collateralAmountOut += vars.collateral;\n\n        // calculate amount to be borrowed in the next converter\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        amountIn_ = (amountIn_ > vars.c1 + vars.collateral)\n          ? amountIn_ - (vars.c1 + vars.collateral)\n          : 0;\n\n        // protection against dust amounts, see \"openPosition.dust\", just leave dust amount unused\n        // we CAN NOT add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\n        // we assume here, that collateralThreshold_ != 0, so check amountIn_ != 0 is not required\n        if (amountIn_ < collateralThreshold_) break;\n      }\n    }\n\n    return (collateralAmountOut, borrowedAmountOut);\n  }\n\n  /// @notice Get ratio18 = collateral / borrow\n  function _getCollateralToBorrowRatio(\n    ITetuConverter tetuConverter_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) internal view returns (uint){\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle());\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\n    return 1e18 * priceBorrow * 10 ** IERC20Metadata(collateralAsset_).decimals()\n    / priceCollateral / 10 ** IERC20Metadata(borrowAsset_).decimals();\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  ///         It doesn't repay more than the actual amount of the debt, so it can use less amount than {amountToRepay}\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function _closePosition(\n    ITetuConverter converter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) internal returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\n\n    // We shouldn't try to pay more than we actually need to repay\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\n    // Let's limit amountToRepay by needToRepay-amount\n    (uint needToRepay,) = converter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\n\n    return _closePositionExact(converter_, collateralAsset, borrowAsset, amountRepay, balanceBefore);\n  }\n\n  /// @notice Close the given position, pay {amountRepay} exactly and ensure that all amount was accepted,\n  /// @param amountRepay Amount to repay in terms of {borrowAsset}\n  /// @param balanceBorrowAsset Current balance of the borrow asset\n  /// @return collateralOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function _closePositionExact(\n    ITetuConverter converter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    uint balanceBorrowAsset\n  ) internal returns (\n    uint collateralOut,\n    uint repaidAmountOut\n  ) {\n    // Make full/partial repayment\n    IERC20(borrowAsset).safeTransfer(address(converter_), amountRepay);\n\n    uint notUsedAmount;\n    (collateralOut, notUsedAmount,,) = converter_.repay(collateralAsset, borrowAsset, amountRepay, address(this));\n\n    emit ClosePosition(collateralAsset, borrowAsset, amountRepay, address(this), collateralOut, notUsedAmount);\n    uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\n\n    // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (debt-gap)\n    repaidAmountOut = balanceBorrowAsset > balanceAfter\n      ? balanceBorrowAsset - balanceAfter\n      : 0;\n\n    require(notUsedAmount == 0, StrategyLib.WRONG_VALUE);\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\n  }\n  //endregion Borrow and close positions\n\n  /////////////////////////////////////////////////////////////////////\n  //region Liquidation\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\n  function liquidate(\n    ITetuConverter converter,\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdTokenOut_,\n    bool skipValidation\n  ) external returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    return _liquidate(converter, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdTokenOut_, skipValidation);\n  }\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator (== 0 | amountIn_)\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\n  function _liquidate(\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdForTokenOut_,\n    bool skipValidation\n  ) internal returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    if (amountIn_ == 0) {\n      return (0, 0);\n    }\n\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\n\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\n\n    // calculate balance in out value for check threshold\n    uint amountOut = liquidator_.getPriceForRoute(route, amountIn_);\n\n    // if the expected value is higher than threshold distribute to destinations\n    return amountOut > liquidationThresholdForTokenOut_\n      ? (amountIn_, _liquidateWithRoute(converter_, route, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, skipValidation))\n      : (0, 0);\n  }\n\n  /// @notice Make liquidation using given route and check correctness using TetuConverter's price oracle\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\n  function _liquidateWithRoute(\n    ITetuConverter converter_,\n    ITetuLiquidator.PoolData[] memory route,\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    bool skipValidation\n  ) internal returns (\n    uint receivedAmountOut\n  ) {\n    // we need to approve each time, liquidator address can be changed in controller\n    AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\n\n    uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\n    liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\n    uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\n\n    require(balanceAfter > balanceBefore, AppErrors.BALANCE_DECREASE);\n    receivedAmountOut = balanceAfter - balanceBefore;\n\n    // Oracle in TetuConverter \"knows\" only limited number of the assets\n    // It may not know prices for reward assets, so for rewards this validation should be skipped to avoid TC-4 error\n    require(skipValidation || converter_.isConversionValid(tokenIn_, amountIn_, tokenOut_, receivedAmountOut, slippage_), AppErrors.PRICE_IMPACT);\n    emit Liquidation(tokenIn_, tokenOut_, amountIn_, amountIn_, receivedAmountOut);\n  }\n  //endregion Liquidation\n\n  /////////////////////////////////////////////////////////////////////\n  //region requirePayAmountBack\n  /////////////////////////////////////////////////////////////////////\n\n  /// @param amount_ Amount of the main asset requested by converter\n  /// @param indexTheAsset Index of the asset required by converter in the {tokens}\n  /// @param asset Main asset or underlying (it can be different from tokens[indexTheAsset])\n  /// @return amountOut Amount of the main asset sent to converter\n  function swapToGivenAmountAndSendToConverter(\n    uint amount_,\n    uint indexTheAsset,\n    address[] memory tokens,\n    address converter,\n    address controller,\n    address asset,\n    mapping(address => uint) storage liquidationThresholds\n  ) external returns (\n    uint amountOut\n  ) {\n    // msg.sender == converter; we assume here that it was checked before the call of this function\n    address theAsset = tokens[indexTheAsset];\n\n    amountOut = IERC20(theAsset).balanceOf(address(this));\n\n    // convert withdrawn assets to the target asset if not enough\n    if (amountOut < amount_) {\n      ConverterStrategyBaseLib.swapToGivenAmount(\n        amount_ - amountOut,\n        tokens,\n        indexTheAsset,\n        asset, // underlying === main asset\n        ITetuConverter(converter),\n        ITetuLiquidator(IController(controller).liquidator()),\n        liquidationThresholds[theAsset],\n        OVERSWAP\n      );\n      amountOut = IERC20(theAsset).balanceOf(address(this));\n    }\n\n    // we should send the asset as is even if it is lower than requested\n    // but shouldn't sent more amount than requested\n    amountOut = Math.min(amount_, amountOut);\n    if (amountOut != 0) {\n      IERC20(theAsset).safeTransfer(converter, amountOut);\n    }\n\n    // There are two cases of calling requirePayAmountBack by converter:\n    // 1) close a borrow: we will receive collateral back and amount of investedAssets almost won't change\n    // 2) rebalancing: we have real loss, it will be taken into account at next hard work\n    emit ReturnAssetToConverter(theAsset, amountOut);\n\n    // let's leave any leftovers un-invested, they will be reinvested at next hardwork\n  }\n\n  /// @notice Swap available amounts of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\n  /// @param targetAmount_ Required amount of tokens[indexTheAsset_] that should be received by swap(s)\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param indexTargetAsset_ Index of target asset in tokens_ array\n  /// @param underlying_ Index of underlying\n  /// @param liquidationThresholdForTargetAsset_ Liquidation thresholds for the target asset\n  /// @param overswap_ Allow to swap more then required (i.e. 1_000 => +1%)\n  ///                  to avoid additional swap if the swap return amount a bit less than we expected\n  /// @return spentAmounts Any amounts spent during the swaps\n  function swapToGivenAmount(\n    uint targetAmount_,\n    address[] memory tokens_,\n    uint indexTargetAsset_,\n    address underlying_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint liquidationThresholdForTargetAsset_,\n    uint overswap_\n  ) internal returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    SwapToGivenAmountLocal memory v;\n    v.len = tokens_.length;\n\n    v.availableAmounts = new uint[](v.len);\n    for (; v.i < v.len; v.i = AppLib.uncheckedInc(v.i)) {\n      v.availableAmounts[v.i] = IERC20(tokens_[v.i]).balanceOf(address(this));\n    }\n\n    (spentAmounts, receivedAmounts) = _swapToGivenAmount(\n      SwapToGivenAmountInputParams({\n        targetAmount: targetAmount_,\n        tokens: tokens_,\n        indexTargetAsset: indexTargetAsset_,\n        underlying: underlying_,\n        amounts: v.availableAmounts,\n        converter: converter_,\n        liquidator: liquidator_,\n        liquidationThresholdForTargetAsset: Math.max(liquidationThresholdForTargetAsset_, DEFAULT_LIQUIDATION_THRESHOLD),\n        overswap: overswap_\n      })\n    );\n  }\n\n  /// @notice Swap available {amounts_} of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\n  /// @return spentAmounts Any amounts spent during the swaps\n  /// @return receivedAmounts Any amounts received during the swaps\n  function _swapToGivenAmount(SwapToGivenAmountInputParams memory p) internal returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = p.tokens.length;\n    receivedAmounts = new uint[](v.len);\n    spentAmounts = new uint[](v.len);\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(p.converter.controller()).priceOracle()),\n      p.tokens,\n      v.len\n    );\n\n    // we need to swap other assets to the asset\n    // at first we should swap NOT underlying.\n    // if it would be not enough, we can swap underlying too.\n\n    // swap NOT underlying, initialize {indexUnderlying}\n    uint indexUnderlying;\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (p.underlying == p.tokens[i]) {\n        indexUnderlying = i;\n        continue;\n      }\n      if (p.indexTargetAsset == i) continue;\n\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, i);\n      spentAmounts[i] += spent;\n      receivedAmounts[p.indexTargetAsset] += received;\n\n      if (receivedAmounts[p.indexTargetAsset] >= p.targetAmount) break;\n    }\n\n    // swap underlying\n    if (receivedAmounts[p.indexTargetAsset] < p.targetAmount && p.indexTargetAsset != indexUnderlying) {\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, indexUnderlying);\n      spentAmounts[indexUnderlying] += spent;\n      receivedAmounts[p.indexTargetAsset] += received;\n    }\n  }\n\n  /// @notice Swap a part of amount of asset {tokens[indexTokenIn]} to {targetAsset} to get {targetAmount} in result\n  /// @param receivedTargetAmount Already received amount of {targetAsset} in previous swaps\n  /// @param indexTokenIn Index of the tokenIn in p.tokens\n  function _swapToGetAmount(\n    uint receivedTargetAmount,\n    SwapToGivenAmountInputParams memory p,\n    CalcInvestedAssetsLocal memory v,\n    uint indexTokenIn\n  ) internal returns (\n    uint amountSpent,\n    uint amountReceived\n  ) {\n    if (p.amounts[indexTokenIn] != 0) {\n      // we assume here, that p.targetAmount > receivedTargetAmount, see _swapToGivenAmount implementation\n\n      // calculate amount that should be swapped\n      // {overswap} allows to swap a bit more\n      // to avoid additional swaps if the swap will give us a bit less amount than expected\n      uint amountIn = (\n        (p.targetAmount - receivedTargetAmount)\n        * v.prices[p.indexTargetAsset] * v.decs[indexTokenIn]\n        / v.prices[indexTokenIn] / v.decs[p.indexTargetAsset]\n      ) * (p.overswap + DENOMINATOR) / DENOMINATOR;\n\n      (amountSpent, amountReceived) = _liquidate(\n        p.converter,\n        p.liquidator,\n        p.tokens[indexTokenIn],\n        p.tokens[p.indexTargetAsset],\n        Math.min(amountIn, p.amounts[indexTokenIn]),\n        _ASSET_LIQUIDATION_SLIPPAGE,\n        p.liquidationThresholdForTargetAsset,\n        false\n      );\n    }\n\n    return (amountSpent, amountReceived);\n  }\n  //endregion requirePayAmountBack\n\n  /////////////////////////////////////////////////////////////////////\n  //region Recycle rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Recycle the amounts: split each amount on tree parts: performance+insurance (P), forwarder (F), compound (C)\n  ///         Liquidate P+C, send F to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just left on the balance\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\n  ///   Performance amounts are liquidated, result amount of underlying is returned in {amountToPerformanceAndInsurance}\n  /// @param asset Underlying asset\n  /// @param compoundRatio Compound ration in the range [0...COMPOUND_DENOMINATOR]\n  /// @param tokens tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @param liquidationThresholds Liquidation thresholds for rewards tokens\n  /// @param performanceFee Performance fee in the range [0...FEE_DENOMINATOR]\n  /// @return amountsToForward Amounts of {rewardTokens} to be sent to forwarder, zero amounts are allowed here\n  /// @return amountToPerformanceAndInsurance Amount of underlying to be sent to performance receiver and insurance\n  function recycle(\n    ITetuConverter converter_,\n    address asset,\n    uint compoundRatio,\n    address[] memory tokens,\n    ITetuLiquidator liquidator,\n    mapping(address => uint) storage liquidationThresholds,\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    uint performanceFee\n  ) external returns (\n    uint[] memory amountsToForward,\n    uint amountToPerformanceAndInsurance\n  ) {\n    RecycleLocalParams memory p;\n\n    p.len = rewardTokens.length;\n    require(p.len == rewardAmounts.length, AppErrors.WRONG_LENGTHS);\n\n    p.liquidationThresholdAsset = Math.max(liquidationThresholds[asset], DEFAULT_LIQUIDATION_THRESHOLD);\n\n    amountsToForward = new uint[](p.len);\n\n    // rewardAmounts => P + F + C, where P - performance + insurance, F - forwarder, C - compound\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      p.amountFC = rewardAmounts[i] * (COMPOUND_DENOMINATOR - performanceFee) / COMPOUND_DENOMINATOR;\n      p.amountC = p.amountFC * compoundRatio / COMPOUND_DENOMINATOR;\n      p.amountP = rewardAmounts[i] - p.amountFC;\n      p.rewardToken = rewardTokens[i];\n      p.amountCP = p.amountC + p.amountP;\n\n      if (p.amountCP > 0) {\n        if (ConverterStrategyBaseLib.getAssetIndex(tokens, p.rewardToken) != type(uint).max) {\n          if (p.rewardToken == asset) {\n            // This is underlying, liquidation of compound part is not allowed; just keep on the balance, should be handled later\n            amountToPerformanceAndInsurance += p.amountP;\n          } else {\n            // This is secondary asset, Liquidation of compound part is not allowed, we should liquidate performance part only\n            if (p.amountP < Math.max(liquidationThresholds[p.rewardToken], DEFAULT_LIQUIDATION_THRESHOLD)) {\n              // performance amount is too small, liquidation is not allowed, we just keep that dust tokens on balance forever\n            } else {\n              (, p.receivedAmountOut) = _liquidate(\n                converter_,\n                liquidator,\n                p.rewardToken,\n                asset,\n                p.amountP,\n                _REWARD_LIQUIDATION_SLIPPAGE,\n                p.liquidationThresholdAsset,\n                false // use conversion validation for these rewards\n              );\n              amountToPerformanceAndInsurance += p.receivedAmountOut;\n            }\n          }\n        } else {\n          if (p.amountCP < Math.max(liquidationThresholds[p.rewardToken], DEFAULT_LIQUIDATION_THRESHOLD)) {\n            // amount is too small, liquidation is not allowed, we just keep that dust tokens on balance forever\n          } else {\n            // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\n            // We assume here, that {token} cannot be equal to {_asset}\n            // because the {_asset} is always included to the list of depositor's assets\n            (, p.receivedAmountOut) = _liquidate(\n              converter_,\n              liquidator,\n              p.rewardToken,\n              asset,\n              p.amountCP,\n              _REWARD_LIQUIDATION_SLIPPAGE,\n              p.liquidationThresholdAsset,\n              true // skip conversion validation for rewards becase we can have arbitrary assets here\n            );\n\n            amountToPerformanceAndInsurance += p.receivedAmountOut * (rewardAmounts[i] - p.amountFC) / p.amountCP;\n          }\n        }\n      }\n      amountsToForward[i] = p.amountFC - p.amountC;\n    }\n    return (amountsToForward, amountToPerformanceAndInsurance);\n  }\n  //endregion Recycle rewards\n\n  /////////////////////////////////////////////////////////////////////\n  //region calcInvestedAssets\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return amountOut Invested asset amount under control (in terms of {asset})\n  function calcInvestedAssets(\n    address[] memory tokens,\n    uint[] memory depositorQuoteExitAmountsOut,\n    uint indexAsset,\n    ITetuConverter converter_\n  ) external returns (\n    uint amountOut\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = tokens.length;\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\n      tokens,\n      v.len\n    );\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\n        amountOut += depositorQuoteExitAmountsOut[i];\n      } else {\n        // available amount to repay\n        uint toRepay = IERC20(tokens[i]).balanceOf(address(this)) + depositorQuoteExitAmountsOut[i];\n\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(\n          address(this),\n          tokens[indexAsset],\n          tokens[i],\n          // investedAssets is calculated using exact debts, debt-gaps are not taken into account\n          false\n        );\n        amountOut += collateral;\n\n        if (toRepay >= toPay) {\n          amountOut += (toRepay - toPay) * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        } else {\n          // there is not enough amount to pay the debt\n          // let's register a debt and try to resolve it later below\n          if (v.debts.length == 0) {\n            // lazy initialization\n            v.debts = new uint[](v.len);\n          }\n\n          // to pay the following amount we need to swap some other asset at first\n          v.debts[i] = toPay - toRepay;\n        }\n      }\n    }\n    if (v.debts.length == v.len) {\n      // we assume here, that it would be always profitable to save collateral\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n        if (v.debts[i] == 0) continue;\n\n        // estimatedAssets should be reduced on the debt-value\n        // this estimation is approx and do not count price impact on the liquidation\n        // we will able to count the real output only after withdraw process\n        uint debtInAsset = v.debts[i] * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        if (debtInAsset > amountOut) {\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\n          amountOut = 0;\n        } else {\n          amountOut -= debtInAsset;\n        }\n      }\n    }\n\n    return amountOut;\n  }\n  //endregion calcInvestedAssets\n\n  /////////////////////////////////////////////////////////////////////\n  //region getExpectedAmountMainAsset\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate expected amount of the main asset after withdrawing\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\n  /// @return amountsOut Expected amounts of the main asset received after conversion withdrawnAmounts+amountsToConvert\n  function getExpectedAmountMainAsset(\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint[] memory withdrawnAmounts_,\n    uint[] memory amountsToConvert_\n  ) internal returns (\n    uint[] memory amountsOut\n  ) {\n    uint len = tokens.length;\n    amountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        amountsOut[i] = withdrawnAmounts_[i];\n      } else {\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\n        if (amount != 0) {\n          (amountsOut[i],) = converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\n        }\n      }\n    }\n\n    return amountsOut;\n  }\n  //endregion getExpectedAmountMainAsset\n\n  /////////////////////////////////////////////////////////////////////\n  //region Reduce size of ConverterStrategyBase\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make borrow and save amounts of tokens available for deposit to tokenAmounts\n  /// @param thresholdMainAsset_ Min allowed value of collateral in terms of main asset, 0 - use default min value\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\n  /// @param collaterals_ Amounts of main asset that can be used as collateral to borrow {tokens_}\n  /// @param thresholdMainAsset_ Value of liquidation threshold for the main (collateral) asset\n  /// @return tokenAmountsOut Amounts available for deposit\n  function getTokenAmounts(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory collaterals_,\n    uint thresholdMainAsset_\n  ) external returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    // content of tokenAmounts will be modified in place\n    uint len = tokens_.length;\n    tokenAmountsOut = new uint[](len);\n\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexAsset_) {\n        if (collaterals_[i] != 0) {\n          AppLib.approveIfNeeded(tokens_[indexAsset_], collaterals_[i], address(tetuConverter_));\n          _openPosition(\n            tetuConverter_,\n            \"\", // entry kind = 0: fixed collateral amount, max possible borrow amount\n            tokens_[indexAsset_],\n            tokens_[i],\n            collaterals_[i],\n            Math.max(thresholdMainAsset_, DEFAULT_LIQUIDATION_THRESHOLD)\n          );\n\n          // zero borrowed amount is possible here (conversion is not available)\n          // if it's not suitable for depositor, the depositor should check zero amount in other places\n        }\n        tokenAmountsOut[i] = IERC20(tokens_[i]).balanceOf(address(this));\n      }\n    }\n\n    tokenAmountsOut[indexAsset_] = Math.min(\n      collaterals_[indexAsset_],\n      IERC20(tokens_[indexAsset_]).balanceOf(address(this))\n    );\n  }\n\n  /// @notice Convert {amountsToConvert_} to the main {asset}\n  ///         Swap leftovers (if any) to the main asset.\n  ///         If result amount is less than expected, try to close any other available debts (1 repay per block only)\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @param requestedAmount Amount to be withdrawn in terms of the asset in addition to the exist balance.\n  ///        Max uint means attempt to withdraw all possible invested assets.\n  /// @param amountsToConvert_ Amounts available for conversion after withdrawing from the pool\n  /// @param expectedMainAssetAmounts Amounts of main asset that we expect to receive after conversion amountsToConvert_\n  /// @return expectedAmount Expected total amount of main asset after all conversions, swaps and repays\n  function makeRequestedAmount(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint requestedAmount,\n    uint[] memory expectedMainAssetAmounts,\n    mapping(address => uint) storage liquidationThresholds\n  ) external returns (uint expectedAmount) {\n    // get the total expected amount\n    for (uint i; i < tokens_.length; i = AppLib.uncheckedInc(i)) {\n      expectedAmount += expectedMainAssetAmounts[i];\n    }\n\n    // we cannot repay a debt twice\n    // suppose, we have usdt = 1 and we need to convert it to usdc, then get additional usdt=10 and make second repay\n    // But: we cannot make repay(1) and than repay(10). We MUST make single repay(11)\n\n    if (requestedAmount != type(uint).max\n      && expectedAmount > requestedAmount * (GAP_CONVERSION + DENOMINATOR) / DENOMINATOR\n    ) {\n      // amountsToConvert_ are enough to get requestedAmount\n      _convertAfterWithdraw(\n        converter_,\n        liquidator_,\n        indexAsset_,\n        liquidationThresholds[tokens_[indexAsset_]],\n        tokens_,\n        amountsToConvert_\n      );\n    } else {\n      // amountsToConvert_ are NOT enough to get requestedAmount\n      // We are allowed to make only one repay per block, so, we shouldn't try to convert amountsToConvert_\n      // We should try to close the exist debts instead:\n      //    convert a part of main assets to get amount of secondary assets required to repay the debts\n      // and only then make conversion.\n      expectedAmount = _closePositionsToGetAmount(\n        converter_,\n        liquidator_,\n        indexAsset_,\n        liquidationThresholds,\n        requestedAmount,\n        tokens_\n      ) + expectedMainAssetAmounts[indexAsset_];\n    }\n\n    return expectedAmount;\n  }\n  //endregion Reduce size of ConverterStrategyBase\n\n  /////////////////////////////////////////////////////////////////////\n  //region Withdraw helpers\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\n  /// @param amountsToConvert Amounts of {tokens} to be converted, they are located on the balance before withdraw\n  /// @param withdrawnAmounts Amounts of {tokens} that were withdrew from the pool\n  function postWithdrawActions(\n    ITetuConverter converter,\n    address[] memory tokens,\n    uint indexAsset,\n\n    uint[] memory reservesBeforeWithdraw,\n    uint liquidityAmountWithdrew,\n    uint totalSupplyBeforeWithdraw,\n\n    uint[] memory amountsToConvert,\n    uint[] memory withdrawnAmounts\n  ) external returns (\n    uint[] memory expectedMainAssetAmounts,\n    uint[] memory _amountsToConvert\n  ) {\n    // estimate expected amount of assets to be withdrawn\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\n      reservesBeforeWithdraw,\n      liquidityAmountWithdrew,\n      totalSupplyBeforeWithdraw\n    );\n\n    // from received amounts after withdraw calculate how much we receive from converter for them in terms of the underlying asset\n    expectedMainAssetAmounts = getExpectedAmountMainAsset(\n      tokens,\n      indexAsset,\n      converter,\n      expectedWithdrawAmounts,\n      amountsToConvert\n    );\n\n    uint len = tokens.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      amountsToConvert[i] += withdrawnAmounts[i];\n    }\n\n    return (expectedMainAssetAmounts, amountsToConvert);\n  }\n\n  /// @notice return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\n  function postWithdrawActionsEmpty(\n    ITetuConverter converter,\n    address[] memory tokens,\n    uint indexAsset,\n    uint[] memory amountsToConvert_\n  ) external returns (\n    uint[] memory expectedAmountsMainAsset\n  ) {\n    expectedAmountsMainAsset = getExpectedAmountMainAsset(\n      tokens,\n      indexAsset,\n      converter,\n      // there are no withdrawn amounts\n      new uint[](tokens.length), // array with all zero values\n      amountsToConvert_\n    );\n  }\n\n  //endregion Withdraw helpers\n\n  /////////////////////////////////////////////////////////////////////\n  //region convertAfterWithdraw\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Convert {amountsToConvert_} (available on balance) to the main asset\n  ///         Swap leftovers if any.\n  ///         Result amount can be less than requested one, we don't try to close any other debts here\n  /// @param indexAsset Index of the main asset in {tokens}\n  /// @param liquidationThreshold Min allowed amount of main asset to be liquidated in {liquidator}\n  /// @param tokens Tokens received from {_depositorPoolAssets}\n  /// @param amountsToConvert Amounts to convert, the order of asset is same as in {tokens}\n  /// @return collateralOut Total amount of main asset returned after closing positions\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\n  function _convertAfterWithdraw(\n    ITetuConverter tetuConverter,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    uint liquidationThreshold,\n    address[] memory tokens,\n    uint[] memory amountsToConvert\n  ) internal returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    ConvertAfterWithdrawLocal memory v;\n    v.asset = tokens[indexAsset];\n    v.balanceBefore = IERC20(v.asset).balanceOf(address(this));\n    v.len = tokens.length;\n\n    // Close positions to convert all required amountsToConvert\n    repaidAmountsOut = new uint[](tokens.length);\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset || amountsToConvert[i] == 0) continue;\n      (, repaidAmountsOut[i]) = _closePosition(tetuConverter, v.asset, tokens[i], amountsToConvert[i]);\n    }\n\n    // Manually swap remain leftovers\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset || amountsToConvert[i] == 0) continue;\n      if (amountsToConvert[i] > repaidAmountsOut[i]) {\n        (v.spent, v.received) = _liquidate(\n          tetuConverter,\n          liquidator,\n          tokens[i],\n          v.asset,\n          amountsToConvert[i] - repaidAmountsOut[i],\n          _ASSET_LIQUIDATION_SLIPPAGE,\n          liquidationThreshold,\n          false\n        );\n        collateralOut += v.received;\n        repaidAmountsOut[i] += v.spent;\n      }\n    }\n\n    // Calculate amount of received collateral\n    v.balance = IERC20(v.asset).balanceOf(address(this));\n    collateralOut = v.balance > v.balanceBefore\n      ? v.balance - v.balanceBefore\n      : 0;\n\n    return (collateralOut, repaidAmountsOut);\n  }\n\n  /// @notice Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\n  /// @dev We assume here that this function is called before closing any positions in the current block\n  /// @param liquidationThresholds Min allowed amounts-out for liquidations\n  /// @param requestedAmount Requested amount of main asset that should be added to the current balance\n  /// @return expectedAmount Main asset amount expected to be received on balance after all conversions and swaps\n  function closePositionsToGetAmount(\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    mapping(address => uint) storage liquidationThresholds,\n    uint requestedAmount,\n    address[] memory tokens\n  ) external returns (\n    uint expectedAmount\n  ) {\n    return _closePositionsToGetAmount(\n      converter_,\n      liquidator,\n      indexAsset,\n      liquidationThresholds,\n      requestedAmount,\n      tokens\n    );\n  }\n\n  function _closePositionsToGetAmount(\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    mapping(address => uint) storage liquidationThresholds,\n    uint requestedAmount,\n    address[] memory tokens\n  ) internal returns (\n    uint expectedAmount\n  ) {\n    if (requestedAmount != 0) {\n      CloseDebtsForRequiredAmountLocal memory v;\n      v.asset = tokens[indexAsset];\n      v.len = tokens.length;\n      v.balance = IERC20(v.asset).balanceOf(address(this));\n\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n        if (i == indexAsset) continue;\n\n        // we need to increase balance on the following amount: requestedAmount - v.balance;\n        // we have following borrow: amount-to-pay and corresponded collateral\n        (v.totalDebt, v.totalCollateral) = converter_.getDebtAmountCurrent(address(this), v.asset, tokens[i], true);\n\n        uint tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\n\n        if (v.totalDebt != 0 || tokenBalance != 0) {\n          //lazy initialization of the prices and decs\n          if (v.prices.length == 0) {\n            (v.prices, v.decs) = _getPricesAndDecs(\n              IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\n              tokens,\n              v.len\n            );\n          }\n\n          // repay the debt if any\n          if (v.totalDebt != 0) {\n            // what amount of main asset we should sell to pay the debt\n            uint toSell = _getAmountToSell(\n              requestedAmount,\n              v.totalDebt,\n              v.totalCollateral,\n              v.prices,\n              v.decs,\n              indexAsset,\n              i,\n              tokenBalance\n            );\n\n            // convert {toSell} amount of main asset to tokens[i]\n            if (toSell != 0 && v.balance != 0) {\n              toSell = Math.min(toSell, v.balance);\n              (toSell,) = _liquidate(\n                converter_,\n                liquidator,\n                v.asset,\n                tokens[i],\n                toSell,\n                _ASSET_LIQUIDATION_SLIPPAGE,\n                liquidationThresholds[tokens[i]],\n                false\n              );\n              tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\n            }\n\n            // sell {toSell}, repay the debt, return collateral back; we should receive amount > toSell\n            expectedAmount += _repayDebt(converter_, v.asset, tokens[i], tokenBalance) - toSell;\n\n            // we can have some leftovers after closing the debt\n            tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\n          }\n\n          // directly swap leftovers\n          if (tokenBalance != 0) {\n            (uint spentAmountIn,) = _liquidate(\n              converter_,\n              liquidator,\n              tokens[i],\n              v.asset,\n              tokenBalance,\n              _ASSET_LIQUIDATION_SLIPPAGE,\n              liquidationThresholds[v.asset],\n              false\n            );\n            if (spentAmountIn != 0) {\n              // spentAmountIn can be zero if token balance is less than liquidationThreshold\n              expectedAmount += spentAmountIn * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n            }\n          }\n\n          // reduce of requestedAmount on the balance increment\n          v.newBalance = IERC20(v.asset).balanceOf(address(this));\n          require(v.newBalance >= v.balance, AppErrors.BALANCE_DECREASE);\n\n          if (requestedAmount > v.newBalance - v.balance) {\n            requestedAmount -= (v.newBalance - v.balance);\n            v.balance = v.newBalance;\n          } else {\n            // we get requestedAmount on the balance and don't need to make any other conversions\n            break;\n          }\n        }\n      }\n    }\n\n    return expectedAmount;\n  }\n\n  /// @notice What amount of collateral should be sold to pay the debt and receive {requestedAmount}\n  /// @dev It doesn't allow to sell more than the amount of total debt in the borrow\n  /// @param requestedAmount We need to increase balance (of collateral asset) on this amount\n  /// @param totalDebt Total debt of the borrow in terms of borrow asset\n  /// @param totalCollateral Total collateral of the borrow in terms of collateral asset\n  /// @param prices Cost of $1 in terms of the asset, decimals 18\n  /// @param decs 10**decimals for each asset\n  /// @param indexCollateral Index of the collateral asset in {prices} and {decs}\n  /// @param indexBorrowAsset Index of the borrow asset in {prices} and {decs}\n  /// @param balanceBorrowAsset Available balance of the borrow asset, it will be used to cover the debt\n  function _getAmountToSell(\n    uint requestedAmount,\n    uint totalDebt,\n    uint totalCollateral,\n    uint[] memory prices,\n    uint[] memory decs,\n    uint indexCollateral,\n    uint indexBorrowAsset,\n    uint balanceBorrowAsset\n  ) internal pure returns (\n    uint amountOut\n  ) {\n    if (totalDebt != 0) {\n      if (balanceBorrowAsset != 0) {\n        // there is some borrow asset on balance\n        // it will be used to cover the debt\n        // let's reduce the size of totalDebt/Collateral to exclude balanceBorrowAsset\n        uint sub = Math.min(balanceBorrowAsset, totalDebt);\n        totalCollateral -= totalCollateral * sub / totalDebt;\n        totalDebt -= sub;\n      }\n\n      // for definiteness: usdc - collateral asset, dai - borrow asset\n      // Pc = price of the USDC, Pb = price of the DAI, alpha = Pc / Pb [DAI / USDC]\n      // S [USDC] - amount to sell, R [DAI] = alpha * S - amount to repay\n      // After repaying R we get: alpha * S * C / R\n      // Balance should be increased on: requestedAmount = alpha * S * C / R - S\n      // So, we should sell: S = requestedAmount / (alpha * C / R - 1))\n      // We can lost some amount on liquidation of S => R, so we need to use some gap = {GAP_AMOUNT_TO_SELL}\n      // Same formula: S * h = S + requestedAmount, where h = health factor => s = requestedAmount / (h - 1)\n      // h = alpha * C / R\n      uint alpha18 = prices[indexCollateral] * decs[indexBorrowAsset] * 1e18\n        / prices[indexBorrowAsset] / decs[indexCollateral];\n\n      // if totalCollateral is zero (liquidation happens) we will have zero amount (the debt shouldn't be paid)\n      amountOut = totalDebt != 0 && alpha18 * totalCollateral / totalDebt > 1e18\n        ? Math.min(requestedAmount, totalCollateral) * 1e18 / (alpha18 * totalCollateral / totalDebt - 1e18)\n        : 0;\n\n      if (amountOut != 0) {\n        // we shouldn't try to sell amount greater than amount of totalDebt in terms of collateral asset\n        // but we always asks +1% because liquidation results can be different a bit from expected\n        amountOut = (GAP_CONVERSION + DENOMINATOR) * Math.min(amountOut, totalDebt * 1e18 / alpha18) / DENOMINATOR;\n      }\n    }\n\n    return amountOut;\n  }\n\n  /// @notice Repay {amountIn} and get collateral in return, calculate expected amount\n  ///         Take into account possible debt-gap and the fact that the amount of debt may be less than {amountIn}\n  /// @param amountToRepay Max available amount of borrow asset that we can repay\n  /// @return expectedAmountOut Estimated amount of main asset that should be added to balance = collateral - {toSell}\n  function _repayDebt(\n    ITetuConverter converter,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) internal returns (\n    uint expectedAmountOut\n  ) {\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\n\n    // get amount of debt with debt-gap\n    (uint needToRepay,) = converter.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\n\n    // get expected amount without debt-gap\n    uint swappedAmountOut;\n    (expectedAmountOut, swappedAmountOut) = converter.quoteRepay(address(this), collateralAsset, borrowAsset, amountRepay);\n\n    if (expectedAmountOut > swappedAmountOut) {\n      // Following situation is possible\n      //    needToRepay = 100, needToRepayExact = 90 (debt gap is 10)\n      //    1) amountRepay = 80\n      //       expectedAmountOut is calculated for 80, no problems\n      //    2) amountRepay = 99,\n      //       expectedAmountOut is calculated for 90 + 9 (90 - repay, 9 - direct swap)\n      //       expectedAmountOut must be reduced on 9 here (!)\n      expectedAmountOut -= swappedAmountOut;\n    }\n\n    // close the debt\n    _closePositionExact(converter, collateralAsset, borrowAsset, amountRepay, balanceBefore);\n\n    return expectedAmountOut;\n  }\n  //endregion convertAfterWithdraw\n\n  /////////////////////////////////////////////////////////////////////\n  //region Other helpers\n  /////////////////////////////////////////////////////////////////////\n\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\n    return IPriceOracle(IConverterController(converter.controller()).priceOracle()).getAssetPrice(token);\n  }\n\n  function registerIncome(uint assetBefore, uint assetAfter) internal pure returns (uint earned, uint lost) {\n    if (assetAfter > assetBefore) {\n      earned = assetAfter - assetBefore;\n    } else {\n      lost = assetBefore - assetAfter;\n    }\n    return (earned, lost);\n  }\n\n  /// @notice Register income and cover possible loss\n  function coverPossibleStrategyLoss(uint assetBefore, uint assetAfter, address splitter) external returns (uint earned) {\n    uint lost;\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(assetBefore, assetAfter);\n    if (lost != 0) {\n      ISplitter(splitter).coverPossibleStrategyLoss(earned, lost);\n    }\n    emit FixPriceChanges(assetBefore, assetAfter);\n  }\n\n  //endregion Other helpers\n}\n\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppLib.sol\";\nimport \"../libs/TokenAmountsLib.sol\";\nimport \"../libs/ConverterEntryKinds.sol\";\n\n/// @notice Continuation of ConverterStrategyBaseLib (workaround for size limits)\nlibrary ConverterStrategyBaseLib2 {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  uint internal constant DENOMINATOR = 100_000;\n\n  /// @dev 0.5% of max profit for strategy TVL\n  /// @notice Limit max amount of profit that can be send to insurance after price changing\n  uint public constant PRICE_CHANGE_PROFIT_TOLERANCE = 500;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        EVENTS\n  /////////////////////////////////////////////////////////////////////\n\n  event OnChangePerformanceFeeRatio(uint newRatio);\n  event LiquidationThresholdChanged(address token, uint amount);\n  event ReinvestThresholdPercentChanged(uint amount);\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        MAIN LOGIC\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\n  function getAvailableBalances(\n    address[] memory tokens_,\n    uint indexAsset\n  ) external view returns (uint[] memory) {\n    uint len = tokens_.length;\n    uint[] memory amountsToConvert = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this));\n    }\n    return amountsToConvert;\n  }\n\n  /// @notice Send {amount_} of {asset_} to {receiver_} and insurance\n  /// @param asset_ Underlying asset\n  /// @param amount_ Amount of underlying asset to be sent to\n  /// @param receiver_ Performance receiver\n  /// @param ratio [0..100_000], 100_000 - send full amount to perf, 0 - send full amount to the insurance.\n  function sendPerformanceFee(address asset_, uint amount_, address splitter, address receiver_, uint ratio) external returns (\n    uint toPerf,\n    uint toInsurance\n  ) {\n    // read inside lib for reduce contract space in the main contract\n    address insurance = address(ITetuVaultV2(ISplitter(splitter).vault()).insurance());\n\n    toPerf = amount_ * ratio / DENOMINATOR;\n    toInsurance = amount_ - toPerf;\n\n    if (toPerf != 0) {\n      IERC20(asset_).safeTransfer(receiver_, toPerf);\n    }\n    if (toInsurance != 0) {\n      IERC20(asset_).safeTransfer(insurance, toInsurance);\n    }\n  }\n\n  function sendTokensToForwarder(\n    address controller_,\n    address splitter_,\n    address[] memory tokens_,\n    uint[] memory amounts_\n  ) external {\n    uint len = tokens_.length;\n    IForwarder forwarder = IForwarder(IController(controller_).forwarder());\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      AppLib.approveIfNeeded(tokens_[i], amounts_[i], address(forwarder));\n    }\n\n    (tokens_, amounts_) = TokenAmountsLib.filterZeroAmounts(tokens_, amounts_);\n    forwarder.registerIncome(tokens_, amounts_, ISplitter(splitter_).vault(), true);\n  }\n\n  /// @notice For each {token_} calculate a part of {amount_} to be used as collateral according to the weights.\n  ///         I.e. we have 300 USDC, we need to split it on 100 USDC, 100 USDT, 100 DAI\n  ///         USDC is main asset, USDT and DAI should be borrowed. We check amounts of USDT and DAI on the balance\n  ///         and return collaterals reduced on that amounts. For main asset, we return full amount always (100 USDC).\n  /// @return tokenAmountsOut Length of the array is equal to the length of {tokens_}\n  function getCollaterals(\n    uint amount_,\n    address[] memory tokens_,\n    uint[] memory weights_,\n    uint totalWeight_,\n    uint indexAsset_,\n    IPriceOracle priceOracle\n  ) external view returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    uint len = tokens_.length;\n    tokenAmountsOut = new uint[](len);\n\n    // get token prices and decimals\n    uint[] memory prices = new uint[](len);\n    uint[] memory decs = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\n      prices[i] = priceOracle.getAssetPrice(tokens_[i]);\n    }\n\n    // split the amount on tokens proportionally to the weights\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      uint amountAssetForToken = amount_ * weights_[i] / totalWeight_;\n\n      if (i == indexAsset_) {\n        tokenAmountsOut[i] = amountAssetForToken;\n      } else {\n        // if we have some tokens on balance then we need to use only a part of the collateral\n        uint tokenAmountToBeBorrowed = amountAssetForToken\n          * prices[indexAsset_]\n          * decs[i]\n          / prices[i]\n          / decs[indexAsset_];\n\n        uint tokenBalance = IERC20(tokens_[i]).balanceOf(address(this));\n        if (tokenBalance < tokenAmountToBeBorrowed) {\n          tokenAmountsOut[i] = amountAssetForToken * (tokenAmountToBeBorrowed - tokenBalance) / tokenAmountToBeBorrowed;\n        }\n      }\n    }\n  }\n\n  /// @notice Calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\n  ///         User needs to withdraw {targetAmount_} in main asset.\n  ///         There are two kinds of available liquidity:\n  ///         1) liquidity in the pool - {depositorLiquidity_}\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\n  ///         To withdraw {targetAmount_} we need\n  ///         1) Reconvert converted amounts back to main asset\n  ///         2) IF result amount is not necessary - withdraw some liquidity from the pool\n  ///            and also convert it to the main asset.\n  /// @dev This is a writable function with read-only behavior (because of the quote-call)\n  /// @param targetAmount_ Required amount of main asset to be withdrawn from the strategy; 0 - withdraw all\n  /// @param strategy_ Address of the strategy\n  /// @return resultAmount Amount of liquidity that should be withdrawn from the pool, cannot exceed depositorLiquidity\n  /// @return amountsToConvertOut Amounts of {tokens} that should be converted to the main asset\n  function getLiquidityAmount(\n    uint targetAmount_,\n    address strategy_,\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint investedAssets,\n    uint depositorLiquidity\n  ) external returns (\n    uint resultAmount,\n    uint[] memory amountsToConvertOut\n  ) {\n    bool all = targetAmount_ == 0;\n\n    uint len = tokens.length;\n    amountsToConvertOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n\n      uint balance = IERC20(tokens[i]).balanceOf(address(this));\n      if (balance != 0) {\n        // let's estimate collateral that we received back after repaying balance-amount\n        (uint expectedCollateral,) = converter.quoteRepay(strategy_, tokens[indexAsset], tokens[i], balance);\n\n        if (all || targetAmount_ != 0) {\n          // We always repay WHOLE available balance-amount even if it gives us much more amount then we need.\n          // We cannot repay a part of it because converter doesn't allow to know\n          // what amount should be repaid to get given amount of collateral.\n          // And it's too dangerous to assume that we can calculate this amount\n          // by reducing balance-amount proportionally to expectedCollateral/targetAmount_\n          amountsToConvertOut[i] = balance;\n        }\n\n        targetAmount_ = targetAmount_ > expectedCollateral\n          ? targetAmount_ - expectedCollateral\n          : 0;\n\n        investedAssets = investedAssets > expectedCollateral\n          ? investedAssets - expectedCollateral\n          : 0;\n      }\n    }\n\n    uint liquidityRatioOut = all || investedAssets == 0\n      ? 1e18\n      : ((targetAmount_ == 0)\n        ? 0\n        : 1e18\n        * 101 // add 1% on top...\n        * targetAmount_ / investedAssets // a part of amount that we are going to withdraw\n        / 100 // .. add 1% on top\n      );\n\n    resultAmount = liquidityRatioOut != 0\n      ? Math.min(liquidityRatioOut * depositorLiquidity / 1e18, depositorLiquidity)\n      : 0;\n  }\n\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\n  /// @dev The post-processing is rewards conversion to the main asset\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens_ List of rewards claimed from the internal pool\n  /// @param rewardTokens_ Amounts of rewards claimed from the internal pool\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\n  /// @param amountsOut Amounts of available rewards\n  function claimConverterRewards(\n    ITetuConverter converter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_,\n    uint[] memory balancesBefore\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    // Rewards from TetuConverter\n    (address[] memory tokensTC, uint[] memory amountsTC) = converter_.claimRewards(address(this));\n\n    // Join arrays and recycle tokens\n    (tokensOut, amountsOut) = TokenAmountsLib.combineArrays(\n      rewardTokens_, rewardAmounts_,\n      tokensTC, amountsTC,\n      // by default, depositor assets have zero amounts here\n      tokens_, new uint[](tokens_.length)\n    );\n\n    // set fresh balances for depositor tokens\n    uint len = tokensOut.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      for (uint j; j < tokens_.length; j = AppLib.uncheckedInc(j)) {\n        if (tokensOut[i] == tokens_[j]) {\n          amountsOut[i] = IERC20(tokens_[j]).balanceOf(address(this)) - balancesBefore[j];\n        }\n      }\n    }\n\n    // filter zero amounts out\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n\n  /// @notice Send given amount of underlying to the insurance\n  /// @param strategyBalance Total strategy balance = balance of underlying + current invested assets amount\n  /// @return Amount of underlying sent to the insurance\n  function sendToInsurance(address asset, uint amount, address splitter, uint strategyBalance) external returns (uint) {\n    uint amountToSend = Math.min(amount, IERC20(asset).balanceOf(address(this)));\n    if (amountToSend != 0) {\n      // max amount that can be send to insurance is limited by PRICE_CHANGE_PROFIT_TOLERANCE\n\n      // Amount limitation should be implemented in the same way as in StrategySplitterV2._coverLoss\n      // Revert or cutting amount in both cases\n\n      // amountToSend = Math.min(amountToSend, PRICE_CHANGE_PROFIT_TOLERANCE * strategyBalance / 100_000);\n      require(strategyBalance != 0, AppErrors.ZERO_BALANCE);\n      require(amountToSend <= PRICE_CHANGE_PROFIT_TOLERANCE * strategyBalance / 100_000, AppErrors.EARNED_AMOUNT_TOO_HIGH);\n      IERC20(asset).safeTransfer(address(ITetuVaultV2(ISplitter(splitter).vault()).insurance()), amountToSend);\n    }\n    return amountToSend;\n  }\n\n  //region ---------------------------------------- Setters\n  function checkPerformanceFeeRatioChanged(address controller, uint ratio_) external {\n    StrategyLib.onlyOperators(controller);\n    require(ratio_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\n    emit OnChangePerformanceFeeRatio(ratio_);\n  }\n\n  function checkReinvestThresholdPercentChanged(address controller, uint percent_) external {\n    StrategyLib.onlyOperators(controller);\n    require(percent_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\n    emit ReinvestThresholdPercentChanged(percent_);\n  }\n\n  function checkLiquidationThresholdChanged(address controller, address token, uint amount) external {\n    StrategyLib.onlyOperators(controller);\n    emit LiquidationThresholdChanged(token, amount);\n  }\n  //endregion ---------------------------------------- Setters\n\n}\n\n"
    },
    "contracts/strategies/DepositorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @title Abstract base Depositor contract.\n/// @notice Converter strategies should inherit xDepositor.\n/// @notice All communication with external pools should be done at inherited contract\n/// @author bogdoslav\nabstract contract DepositorBase {\n\n  /// @notice Returns pool assets\n  function _depositorPoolAssets() internal virtual view returns (address[] memory assets);\n\n  /// @notice Returns pool token proportions\n  function _depositorPoolWeights() internal virtual view returns (uint[] memory weights, uint total);\n\n  /// @notice Returns pool token reserves\n  function _depositorPoolReserves() internal virtual view returns (uint[] memory reserves);\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() internal virtual view returns (uint);\n\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() internal view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @dev Depositor must care about tokens approval by itself.\n  function _depositorEnter(uint[] memory amountsDesired_) internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  );\n\n  /// @notice Withdraw given lp amount from the pool.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @notice Quotes output for given lp amount from the pool.\n  /// @dev Write function with read-only behavior. BalanceR's depositor requires not-view.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorQuoteExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @dev If pool supports emergency withdraw need to call it for emergencyExit()\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorEmergencyExit() internal virtual returns (uint[] memory amountsOut) {\n    return _depositorExit(_depositorLiquidity());\n  }\n\n  /// @notice Claim all possible rewards.\n  /// @return rewardTokens Claimed token addresses\n  /// @return rewardAmounts Claimed token amounts\n  /// @return depositorBalancesBefore Must have the same length as _depositorPoolAssets and represent balances before claim in the same order\n  function _depositorClaimRewards() internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    uint[] memory depositorBalancesBefore\n  );\n}\n"
    },
    "contracts/strategies/uniswap/Uni3StrategyErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary Uni3StrategyErrors {\n\n  string public constant NEED_REBALANCE = \"U3S-1 Need rebalance\";\n  string public constant WRONG_BALANCE = \"U3S-2 Wrong balance\";\n  string public constant INCORRECT_TICK_RANGE = \"U3S-3 Incorrect tickRange\";\n  string public constant INCORRECT_REBALANCE_TICK_RANGE = \"U3S-4 Incorrect rebalanceTickRange\";\n  string public constant INCORRECT_ASSET = \"U3S-5 Incorrect asset\";\n  string public constant WRONG_FEE = \"U3S-6 Wrong fee\";\n  string public constant WRONG_LIQUIDITY = \"U3S-7 Wrong liquidity\";\n  string public constant WRONG_FILLUP = \"U3S-8 Wrong fillup\";\n  string public constant NO_REBALANCE_NEEDED = \"U3S-9 No rebalance needed\";\n  string public constant BALANCE_LOWER_THAN_FEE = \"U3S-10 Balance lower than fee\";\n  string public constant NOT_CALLBACK_CALLER = \"U3S-11 Not callback caller\";\n  string public constant UNKNOWN_SWAP_ROUTER = \"U3S-12 Unknown router\";\n  string public constant ZERO_PROFIT_HOLDER = \"U3S-13 Zero strategy profit holder\";\n\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3ConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./UniswapV3Depositor.sol\";\nimport \"./UniswapV3ConverterStrategyLogicLib.sol\";\nimport \"../../libs/AppPlatforms.sol\";\nimport \"../../interfaces/IRebalancingStrategy.sol\";\nimport \"./Uni3StrategyErrors.sol\";\n\n/// @title Delta-neutral liquidity hedging converter fill-up/swap rebalancing strategy for UniswapV3\n/// @notice This strategy provides delta-neutral liquidity hedging for Uniswap V3 pools. It rebalances the liquidity\n///         by utilizing fill-up and swap methods depending on the range size of the liquidity provided.\n/// @author a17\ncontract UniswapV3ConverterStrategy is UniswapV3Depositor, ConverterStrategyBase, IRebalancingStrategy {\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  string public constant override NAME = \"UniswapV3 Converter Strategy\";\n  string public constant override PLATFORM = AppPlatforms.UNIV3;\n  string public constant override STRATEGY_VERSION = \"1.4.4\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                INIT\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize the strategy with the given parameters.\n  /// @param controller_ The address of the controller.\n  /// @param splitter_ The address of the splitter.\n  /// @param converter_ The address of the converter.\n  /// @param pool_ The address of the pool.\n  /// @param tickRange_ The tick range for the liquidity position.\n  /// @param rebalanceTickRange_ The tick range for rebalancing.\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address pool_,\n    int24 tickRange_,\n    int24 rebalanceTickRange_\n  ) external initializer {\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n    UniswapV3ConverterStrategyLogicLib.initStrategyState(\n      state,\n      controller_,\n      converter_,\n      pool_,\n      tickRange_,\n      rebalanceTickRange_,\n      ISplitter(splitter_).asset()\n    );\n\n    // setup specific name for UI\n    strategySpecificName = UniswapV3ConverterStrategyLogicLib.createSpecificName(state);\n    emit StrategyLib.StrategySpecificNameChanged(strategySpecificName); // todo: change to _checkStrategySpecificNameChanged\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                OPERATOR ACTIONS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Disable fuse for the strategy.\n  function disableFuse() external {\n    StrategyLib.onlyOperators(controller());\n    UniswapV3ConverterStrategyLogicLib.disableFuse(state, converter);\n  }\n\n  /// @notice Set the fuse threshold for the strategy.\n  /// @param newFuseThreshold The new fuse threshold value.\n  function setFuseThreshold(uint newFuseThreshold) external {\n    StrategyLib.onlyOperators(controller());\n    UniswapV3ConverterStrategyLogicLib.newFuseThreshold(state, newFuseThreshold);\n  }\n\n  function setStrategyProfitHolder(address strategyProfitHolder) external {\n    StrategyLib.onlyOperators(controller());\n    state.strategyProfitHolder = strategyProfitHolder;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   METRIC VIEWS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Check if the strategy is ready for hard work.\n  /// @return A boolean indicating if the strategy is ready for hard work.\n  function isReadyToHardWork() override external virtual view returns (bool) {\n    return UniswapV3ConverterStrategyLogicLib.isReadyToHardWork(state, converter);\n  }\n\n  /// @notice Check if the strategy needs rebalancing.\n  /// @return A boolean indicating if the strategy needs rebalancing.\n  function needRebalance() public view returns (bool) {\n    return UniswapV3ConverterStrategyLogicLib.needRebalance(\n      state.isFuseTriggered,\n      state.pool,\n      state.lowerTick,\n      state.upperTick,\n      state.tickSpacing,\n      state.rebalanceTickRange\n    );\n  }\n\n  /// @return swapAtoB, swapAmount\n  function quoteRebalanceSwap() external returns (bool, uint) {\n    return UniswapV3ConverterStrategyLogicLib.quoteRebalanceSwap(state, converter);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   REBALANCE\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev The rebalancing functionality is the core of this strategy.\n  ///      Depending on the size of the range of liquidity provided, the Fill-up or Swap method is used.\n  ///      There is also an attempt to cover rebalancing losses with rewards.\n  function rebalance() external {\n    address _controller = controller();\n    StrategyLib.onlyOperators(_controller);\n\n    (, uint profitToCover) = _fixPriceChanges(true);\n    uint oldTotalAssets = totalAssets() - profitToCover;\n\n    /// withdraw all liquidity from pool\n    /// after disableFuse() liquidity is zero\n    if (state.totalLiquidity > 0) {\n      _depositorEmergencyExit();\n    }\n\n    (\n    uint[] memory tokenAmounts, // _depositorEnter(tokenAmounts) if length == 2\n    bool isNeedFillup\n    ) = UniswapV3ConverterStrategyLogicLib.rebalance(\n      state,\n      converter,\n      _controller,\n      oldTotalAssets,\n      profitToCover,\n      splitter\n    );\n\n    if (tokenAmounts.length == 2) {\n      _depositorEnter(tokenAmounts);\n\n      //add fill-up liquidity part of fill-up is used\n      if (isNeedFillup) {\n        UniswapV3ConverterStrategyLogicLib.addFillup(state);\n      }\n    }\n\n    _updateInvestedAssets();\n  }\n\n  function rebalanceSwapByAgg(bool direction, uint amount, address agg, bytes memory swapData) external {\n    address _controller = controller();\n    StrategyLib.onlyOperators(_controller);\n\n    (, uint profitToCover) = _fixPriceChanges(true);\n    uint oldTotalAssets = totalAssets() - profitToCover;\n\n    /// withdraw all liquidity from pool\n    /// after disableFuse() liquidity is zero\n    if (state.totalLiquidity > 0) {\n      _depositorEmergencyExit();\n    }\n\n    // _depositorEnter(tokenAmounts) if length == 2\n    uint[] memory tokenAmounts = UniswapV3ConverterStrategyLogicLib.rebalanceSwapByAgg(\n      state,\n      converter,\n      oldTotalAssets,\n      UniswapV3ConverterStrategyLogicLib.RebalanceSwapByAggParams(\n        direction,\n        amount,\n        agg,\n        swapData\n      ),\n      profitToCover,\n      splitter\n    );\n\n    if (tokenAmounts.length == 2) {\n      _depositorEnter(tokenAmounts);\n    }\n\n    _updateInvestedAssets();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   INTERNAL LOGIC\n  /////////////////////////////////////////////////////////////////////\n\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory /*tokens_*/,\n    uint /*indexAsset_*/\n  ) override internal virtual returns (\n    uint[] memory tokenAmounts\n  ) {\n    require(!needRebalance(), Uni3StrategyErrors.NEED_REBALANCE);\n\n    tokenAmounts = new uint[](2);\n    uint spentCollateral;\n\n    bytes memory entryData = UniswapV3ConverterStrategyLogicLib.getEntryData(\n      state.pool,\n      state.lowerTick,\n      state.upperTick,\n      state.depositorSwapTokens\n    );\n\n    AppLib.approveIfNeeded(state.tokenA, amount_, address(tetuConverter_));\n    (spentCollateral, tokenAmounts[1]) = ConverterStrategyBaseLib.openPosition(\n      tetuConverter_,\n      entryData,\n      state.tokenA,\n      state.tokenB,\n      amount_,\n      0\n    );\n\n    tokenAmounts[0] = amount_ - spentCollateral;\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  /// @return earned The amount of earned rewards.\n  /// @return lost The amount of lost rewards.\n  /// @return assetBalanceAfterClaim The asset balance after claiming rewards.\n  function _handleRewards() override internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    (address[] memory rewardTokens, uint[] memory amounts) = _claim();\n    earned = UniswapV3ConverterStrategyLogicLib.calcEarned(state.tokenA, controller(), rewardTokens, amounts);\n    _rewardsLiquidation(rewardTokens, amounts);\n    lost = 0; // hide warning\n    assetBalanceAfterClaim = AppLib.balance(asset);\n  }\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amount_ The amount to be deposited.\n  /// @param updateTotalAssetsBeforeInvest_ A boolean indicating if the total assets should be updated before investing.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    uint strategyLoss\n  ) {\n    if (state.isFuseTriggered) {\n      uint[] memory tokenAmounts = new uint[](2);\n      tokenAmounts[0] = amount_;\n      emit OnDepositorEnter(tokenAmounts, tokenAmounts);\n      return 0;\n    } else {\n      return super._depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n    }\n  }\n\n  function _beforeWithdraw(uint /*amount*/) internal view override {\n    require(!needRebalance(), Uni3StrategyErrors.NEED_REBALANCE);\n  }\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3ConverterStrategyLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./UniswapV3Lib.sol\";\nimport \"./UniswapV3DebtLib.sol\";\nimport \"./Uni3StrategyErrors.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol\";\n\nlibrary UniswapV3ConverterStrategyLogicLib {\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////\n  //            CONSTANTS\n  //////////////////////////////////////////\n\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_STABLE = 300;\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE = 500;\n  uint internal constant HARD_WORK_USD_FEE_THRESHOLD = 100;\n  /// @dev 0.5% by default\n  uint public constant DEFAULT_FUSE_THRESHOLD = 5e15;\n\n  //////////////////////////////////////////\n  //            EVENTS\n  //////////////////////////////////////////\n\n  event FuseTriggered();\n  event Rebalanced(uint loss);\n  event DisableFuse();\n  event NewFuseThreshold(uint newFuseThreshold);\n  event UniV3FeesClaimed(uint fee0, uint fee1);\n\n  //////////////////////////////////////////\n  //            STRUCTURES\n  //////////////////////////////////////////\n\n  struct State {\n    address tokenA;\n    address tokenB;\n    IUniswapV3Pool pool;\n    int24 tickSpacing;\n    bool fillUp;\n    bool isStablePool;\n    int24 lowerTick;\n    int24 upperTick;\n    int24 lowerTickFillup;\n    int24 upperTickFillup;\n    int24 rebalanceTickRange;\n    bool depositorSwapTokens;\n    uint128 totalLiquidity;\n    uint128 totalLiquidityFillup;\n    uint deprecated0;\n    uint deprecated1;\n    uint deprecated2;\n    bool isFuseTriggered;\n    uint fuseThreshold;\n    uint lastPrice;\n    address strategyProfitHolder;\n  }\n\n  struct TryCoverLossParams {\n    IUniswapV3Pool pool;\n    address tokenA;\n    address tokenB;\n    bool depositorSwapTokens;\n    uint oldInvestedAssets;\n  }\n\n  struct RebalanceLocalVariables {\n    int24 upperTick;\n    int24 lowerTick;\n    int24 tickSpacing;\n    IUniswapV3Pool pool;\n    address tokenA;\n    address tokenB;\n    uint lastPrice;\n    uint fuseThreshold;\n    bool depositorSwapTokens;\n    uint notCoveredLoss;\n    int24 newLowerTick;\n    int24 newUpperTick;\n    bool fillUp;\n    bool isStablePool;\n    uint newPrice;\n    uint newTotalAssets;\n  }\n\n  struct RebalanceSwapByAggParams {\n    bool direction;\n    uint amount;\n    address agg;\n    bytes swapData;\n  }\n\n  //////////////////////////////////////////\n  //            HELPERS\n  //////////////////////////////////////////\n\n  function disableFuse(State storage state, ITetuConverter converter) external {\n    state.isFuseTriggered = false;\n    state.lastPrice = getOracleAssetsPrice(converter, state.tokenA, state.tokenB);\n    emit DisableFuse();\n  }\n\n  function newFuseThreshold(State storage state, uint value) external {\n    state.fuseThreshold = value;\n    emit NewFuseThreshold(value);\n  }\n\n  /// @dev Gets the liquidator swap slippage based on the pool type (stable or volatile).\n  /// @param pool The IUniswapV3Pool instance.\n  /// @return The liquidator swap slippage percentage.\n  function _getLiquidatorSwapSlippage(IUniswapV3Pool pool) internal view returns (uint) {\n    return isStablePool(pool) ? LIQUIDATOR_SWAP_SLIPPAGE_STABLE : LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE;\n  }\n\n  /// @notice Check if the given pool is a stable pool.\n  /// @param pool The Uniswap V3 pool.\n  /// @return A boolean indicating if the pool is stable.\n  function isStablePool(IUniswapV3Pool pool) public view returns (bool) {\n    return pool.fee() == 100;\n  }\n\n  /// @notice Get the token amounts held by the contract\n  /// @param state The state of the pool.\n  /// @return amountA The balance of tokenA.\n  /// @return amountB The balance of tokenB.\n  function getTokenAmounts(State storage state) external view returns (uint amountA, uint amountB) {\n    amountA = AppLib.balance(state.tokenA);\n    amountB = AppLib.balance(state.tokenB);\n  }\n\n  /// @notice Get the price ratio of the two given tokens from the oracle.\n  /// @param converter The Tetu converter.\n  /// @param tokenA The first token address.\n  /// @param tokenB The second token address.\n  /// @return The price ratio of the two tokens.\n  function getOracleAssetsPrice(ITetuConverter converter, address tokenA, address tokenB) public view returns (uint) {\n    IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n    uint priceA = oracle.getAssetPrice(tokenA);\n    uint priceB = oracle.getAssetPrice(tokenB);\n    return priceB * 1e18 / priceA;\n  }\n\n  /// @notice Check if the fuse is enabled based on the price difference and fuse threshold.\n  /// @param oldPrice The old price.\n  /// @param newPrice The new price.\n  /// @param fuseThreshold The fuse threshold.\n  /// @return A boolean indicating if the fuse is enabled.\n  function isEnableFuse(uint oldPrice, uint newPrice, uint fuseThreshold) internal pure returns (bool) {\n    return oldPrice > newPrice ? (oldPrice - newPrice) > fuseThreshold : (newPrice - oldPrice) > fuseThreshold;\n  }\n\n  function initStrategyState(\n    State storage state,\n    address controller_,\n    address converter,\n    address pool,\n    int24 tickRange,\n    int24 rebalanceTickRange,\n    address asset_\n  ) external {\n    require(pool != address(0), AppErrors.ZERO_ADDRESS);\n    state.pool = IUniswapV3Pool(pool);\n\n    state.rebalanceTickRange = rebalanceTickRange;\n\n    _setInitialDepositorValues(\n      state,\n      IUniswapV3Pool(pool),\n      tickRange,\n      rebalanceTickRange,\n      asset_\n    );\n\n    address liquidator = IController(controller_).liquidator();\n    IERC20(state.tokenA).approve(liquidator, type(uint).max);\n    IERC20(state.tokenB).approve(liquidator, type(uint).max);\n\n    /// for ultra-wide ranges we use Swap rebalancing strategy and Fill-up for other\n    /// upperTick always greater then lowerTick\n    state.fillUp = state.upperTick - state.lowerTick >= 4 * state.tickSpacing;\n\n    if (isStablePool(state.pool)) {\n      /// for stable pools fuse can be enabled\n      state.isStablePool = true;\n      state.fuseThreshold = DEFAULT_FUSE_THRESHOLD;\n      emit NewFuseThreshold(DEFAULT_FUSE_THRESHOLD);\n      state.lastPrice = getOracleAssetsPrice(ITetuConverter(converter), state.tokenA, state.tokenB);\n    }\n  }\n\n  function createSpecificName(State storage state) external view returns (string memory) {\n    return string(abi.encodePacked(\"UniV3 \", IERC20Metadata(state.tokenA).symbol(), \"/\", IERC20Metadata(state.tokenB).symbol(), \"-\", StringLib._toString(state.pool.fee())));\n  }\n\n  //////////////////////////////////////////\n  //            CALCULATIONS\n  //////////////////////////////////////////\n\n  /// @notice Calculate and set the initial values for a Uniswap V3 pool Depositor.\n  /// @param state Depositor storage state struct\n  /// @param pool The Uniswap V3 pool to get the initial values from.\n  /// @param tickRange_ The tick range for the pool.\n  /// @param rebalanceTickRange_ The rebalance tick range for the pool.\n  /// @param asset_ Underlying asset of the depositor.\n  function _setInitialDepositorValues(\n    State storage state,\n    IUniswapV3Pool pool,\n    int24 tickRange_,\n    int24 rebalanceTickRange_,\n    address asset_\n  ) internal {\n    int24 tickSpacing = UniswapV3Lib.getTickSpacing(pool.fee());\n    if (tickRange_ != 0) {\n      require(tickRange_ == tickRange_ / tickSpacing * tickSpacing, Uni3StrategyErrors.INCORRECT_TICK_RANGE);\n      require(rebalanceTickRange_ == rebalanceTickRange_ / tickSpacing * tickSpacing, Uni3StrategyErrors.INCORRECT_REBALANCE_TICK_RANGE);\n    }\n    state.tickSpacing = tickSpacing;\n    (state.lowerTick, state.upperTick) = UniswapV3DebtLib.calcTickRange(pool, tickRange_, tickSpacing);\n    require(asset_ == pool.token0() || asset_ == pool.token1(), Uni3StrategyErrors.INCORRECT_ASSET);\n    if (asset_ == pool.token0()) {\n      state.tokenA = pool.token0();\n      state.tokenB = pool.token1();\n      state.depositorSwapTokens = false;\n    } else {\n      state.tokenA = pool.token1();\n      state.tokenB = pool.token0();\n      state.depositorSwapTokens = true;\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Pool info\n  //////////////////////////////////////////\n\n  /// @notice Retrieve the reserves of a Uniswap V3 pool managed by this contract.\n  /// @param state The State storage containing the pool's information.\n  /// @return reserves An array containing the reserve amounts of the contract owned liquidity.\n  function getPoolReserves(State storage state) external view returns (uint[] memory reserves) {\n    reserves = new uint[](2);\n    (uint160 sqrtRatioX96, , , , , ,) = state.pool.slot0();\n\n    (reserves[0], reserves[1]) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTick,\n      state.upperTick,\n      state.totalLiquidity\n    );\n\n    (uint amount0CurrentFillup, uint amount1CurrentFillup) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTickFillup,\n      state.upperTickFillup,\n      state.totalLiquidityFillup\n    );\n\n    reserves[0] += amount0CurrentFillup;\n    reserves[1] += amount1CurrentFillup;\n\n    if (state.depositorSwapTokens) {\n      (reserves[0], reserves[1]) = (reserves[1], reserves[0]);\n    }\n  }\n\n  /// @notice Retrieve the fees generated by a Uniswap V3 pool managed by this contract.\n  /// @param state The State storage containing the pool's information.\n  /// @return fee0 The fees generated for the first token in the pool.\n  /// @return fee1 The fees generated for the second token in the pool.\n  function getFees(State storage state) public view returns (uint fee0, uint fee1) {\n    UniswapV3Lib.PoolPosition memory position = UniswapV3Lib.PoolPosition(address(state.pool), state.lowerTick, state.upperTick, state.totalLiquidity, address(this));\n    (fee0, fee1) = UniswapV3Lib.getFees(position);\n    UniswapV3Lib.PoolPosition memory positionFillup = UniswapV3Lib.PoolPosition(address(state.pool), state.lowerTickFillup, state.upperTickFillup, state.totalLiquidityFillup, address(this));\n    (uint fee0Fillup, uint fee1Fillup) = UniswapV3Lib.getFees(positionFillup);\n    fee0 += fee0Fillup;\n    fee1 += fee1Fillup;\n  }\n\n  /// @notice Estimate the exit amounts for a given liquidity amount in a Uniswap V3 pool.\n  /// @param liquidityAmountToExit The amount of liquidity to exit.\n  /// @return amountsOut An array containing the estimated exit amounts for each token in the pool.\n  function quoteExit(\n    State storage state,\n    uint128 liquidityAmountToExit\n  ) public view returns (uint[] memory amountsOut) {\n    uint128 liquidity = state.totalLiquidity;\n    uint128 liquidityFillup = state.totalLiquidityFillup;\n\n    amountsOut = new uint[](2);\n    (uint160 sqrtRatioX96, , , , , ,) = state.pool.slot0();\n\n    (amountsOut[0], amountsOut[1]) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTick,\n      state.upperTick,\n      liquidityAmountToExit\n    );\n\n    if (liquidity > 0 && liquidityFillup > 0) {\n      (uint amountOut0Fillup, uint amountOut1Fillup) = UniswapV3Lib.getAmountsForLiquidity(\n        sqrtRatioX96,\n        state.lowerTickFillup,\n        state.upperTickFillup,\n        uint128(uint(liquidityFillup) * uint(liquidityAmountToExit) / uint(liquidity))\n      );\n\n      amountsOut[0] += amountOut0Fillup;\n      amountsOut[1] += amountOut1Fillup;\n    }\n\n    if (state.depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  /// @notice Determine if the pool needs to be rebalanced.\n  /// @return A boolean indicating if the pool needs to be rebalanced.\n  function needRebalance(\n    bool isFuseTriggered,\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing,\n    int24 rebalanceTickRange\n  ) public view returns (bool) {\n    if (isFuseTriggered) {\n      return false;\n    }\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (upperTick - lowerTick == tickSpacing) {\n      return tick < lowerTick || tick >= upperTick;\n    } else {\n      int24 halfRange = (upperTick - lowerTick) / 2;\n      int24 oldMedianTick = lowerTick + halfRange;\n      if (tick > oldMedianTick) {\n        return tick - oldMedianTick >= rebalanceTickRange;\n      }\n      return oldMedianTick - tick > rebalanceTickRange;\n    }\n  }\n\n  /// @notice Get entry data for a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool instance.\n  /// @param lowerTick The lower tick of the pool's main range.\n  /// @param upperTick The upper tick of the pool's main range.\n  /// @param depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return entryData A byte array containing the entry data for the pool.\n  function getEntryData(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    bool depositorSwapTokens\n  ) public view returns (bytes memory entryData) {\n    return UniswapV3DebtLib.getEntryData(pool, lowerTick, upperTick, depositorSwapTokens);\n  }\n\n  function quoteRebalanceSwap(State storage state, ITetuConverter converter) external returns (bool, uint) {\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    IUniswapV3Pool pool = state.pool;\n    uint debtAmount = UniswapV3DebtLib.getDebtTotalDebtAmountOut(converter, tokenA, tokenB);\n\n    if (\n      state.fillUp\n      || !needRebalance(state.isFuseTriggered, pool, state.lowerTick, state.upperTick, state.tickSpacing, state.rebalanceTickRange)\n      || !UniswapV3DebtLib.needCloseDebt(debtAmount, converter, tokenB)\n    ) {\n      return (false, 0);\n    }\n\n    uint[] memory amountsOut = quoteExit(state, state.totalLiquidity);\n\n    if (amountsOut[1] < debtAmount) {\n      uint tokenBprice = UniswapV3Lib.getPrice(address(pool), tokenB);\n      uint needToSellTokenA = tokenBprice * (debtAmount - amountsOut[1]) / 10 ** IERC20Metadata(tokenB).decimals();\n      // add 1% gap for price impact\n      needToSellTokenA += needToSellTokenA / UniswapV3DebtLib.SELL_GAP;\n      uint b = amountsOut[0] + AppLib.balance(tokenA);\n      if (b > 0) {\n        needToSellTokenA = Math.min(needToSellTokenA, b - 1);\n      } else {\n        needToSellTokenA = 0;\n      }\n      return (true, needToSellTokenA);\n    } else {\n      return (false, amountsOut[1] - debtAmount);\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Joins to the pool\n  //////////////////////////////////////////\n\n  /// @notice Enter the pool and provide liquidity with desired token amounts.\n  /// @param pool The Uniswap V3 pool to provide liquidity to.\n  /// @param lowerTick The lower tick value for the pool.\n  /// @param upperTick The upper tick value for the pool.\n  /// @param amountsDesired_ An array containing the desired amounts of tokens to provide liquidity.\n  /// @param totalLiquidity The current total liquidity in the pool.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsConsumed An array containing the consumed amounts for each token in the pool.\n  /// @return liquidityOut The amount of liquidity added to the pool.\n  /// @return totalLiquidityNew The updated total liquidity after providing liquidity.\n  function enter(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    uint[] memory amountsDesired_,\n    uint128 totalLiquidity,\n    bool _depositorSwapTokens\n  ) external returns (uint[] memory amountsConsumed, uint liquidityOut, uint128 totalLiquidityNew) {\n    amountsConsumed = new uint[](2);\n\n    if (amountsDesired_[1] > 0) {\n      if (_depositorSwapTokens) {\n        (amountsDesired_[0], amountsDesired_[1]) = (amountsDesired_[1], amountsDesired_[0]);\n      }\n      uint128 newLiquidity;\n      (amountsConsumed[0], amountsConsumed[1], newLiquidity) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTick, upperTick, amountsDesired_[0], amountsDesired_[1]);\n      pool.mint(address(this), lowerTick, upperTick, newLiquidity, \"\");\n      liquidityOut = uint(newLiquidity);\n      totalLiquidityNew = totalLiquidity + newLiquidity;\n      if (_depositorSwapTokens) {\n        (amountsConsumed[0], amountsConsumed[1]) = (amountsConsumed[1], amountsConsumed[0]);\n      }\n    }\n\n    return (amountsConsumed, liquidityOut, totalLiquidityNew);\n  }\n\n  /// @notice Add liquidity to a Uniswap V3 pool in a specified tick range according fill up rules.\n  function addFillup(State storage state) external {\n    int24 lowerTickFillup;\n    int24 upperTickFillup;\n    uint128 liquidityOutFillup;\n    IUniswapV3Pool pool = state.pool;\n    int24 lowerTick = state.lowerTick;\n    int24 upperTick = state.upperTick;\n    int24 tickSpacing = state.tickSpacing;\n    uint balance0 = AppLib.balance(pool.token0());\n    uint balance1 = AppLib.balance(pool.token1());\n\n    if (balance0 > 0 || balance1 > 0) {\n      (, int24 tick, , , , ,) = pool.slot0();\n      if (balance0 > balance1 * UniswapV3Lib.getPrice(address(pool), pool.token1()) / 10 ** IERC20Metadata(pool.token1()).decimals()) {\n        // add token0 to half range\n        lowerTickFillup = tick / tickSpacing * tickSpacing + tickSpacing;\n        upperTickFillup = upperTick;\n        (,, liquidityOutFillup) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTickFillup, upperTickFillup, balance0, 0);\n        pool.mint(address(this), lowerTickFillup, upperTickFillup, liquidityOutFillup, \"\");\n      } else {\n        lowerTickFillup = lowerTick;\n        upperTickFillup = tick / tickSpacing * tickSpacing - tickSpacing;\n        (,, liquidityOutFillup) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTickFillup, upperTickFillup, 0, balance1);\n        pool.mint(address(this), lowerTickFillup, upperTickFillup, liquidityOutFillup, \"\");\n      }\n      state.lowerTickFillup = lowerTickFillup;\n      state.upperTickFillup = upperTickFillup;\n      state.totalLiquidityFillup = liquidityOutFillup;\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Exit from the pool\n  //////////////////////////////////////////\n\n\n  /// @notice Exit the pool and collect tokens proportional to the liquidity amount to exit.\n  /// @param state The State storage object.\n  /// @param liquidityAmountToExit The amount of liquidity to exit.\n  /// @return amountsOut An array containing the collected amounts for each token in the pool.\n  function exit(\n    State storage state,\n    uint128 liquidityAmountToExit\n  ) external returns (uint[] memory amountsOut) {\n    uint128 totalLiquidityFillup = 0;\n    IUniswapV3Pool pool = state.pool;\n    int24 lowerTick = state.lowerTick;\n    int24 upperTick = state.upperTick;\n    int24 lowerTickFillup = state.lowerTickFillup;\n    int24 upperTickFillup = state.upperTickFillup;\n    uint128 liquidity = state.totalLiquidity;\n    uint128 liquidityFillup = state.totalLiquidityFillup;\n    bool _depositorSwapTokens = state.depositorSwapTokens;\n\n    require(liquidity >= liquidityAmountToExit, Uni3StrategyErrors.WRONG_LIQUIDITY);\n\n    amountsOut = new uint[](2);\n    (amountsOut[0], amountsOut[1]) = pool.burn(lowerTick, upperTick, liquidityAmountToExit);\n    // all fees will be collected but not returned in amountsOut\n    pool.collect(\n      address(this),\n      lowerTick,\n      upperTick,\n      type(uint128).max,\n      type(uint128).max\n    );\n\n    // remove proportional part of fillup liquidity\n    if (liquidityFillup != 0) {\n      uint128 toRemoveFillUpAmount = uint128(uint(liquidityFillup) * uint(liquidityAmountToExit) / uint(liquidity));\n      (uint amountsOutFillup0, uint amountsOutFillup1) = pool.burn(lowerTickFillup, upperTickFillup, toRemoveFillUpAmount);\n      pool.collect(\n        address(this),\n        lowerTickFillup,\n        upperTickFillup,\n        type(uint128).max,\n        type(uint128).max\n      );\n      amountsOut[0] += amountsOutFillup0;\n      amountsOut[1] += amountsOutFillup1;\n\n      require(liquidityFillup >= toRemoveFillUpAmount, Uni3StrategyErrors.WRONG_FILLUP);\n      totalLiquidityFillup = liquidityFillup - toRemoveFillUpAmount;\n    }\n\n    state.totalLiquidity = liquidity - liquidityAmountToExit;\n    state.totalLiquidityFillup = totalLiquidityFillup;\n\n    if (_depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Claim\n  //////////////////////////////////////////\n\n  /// @notice Claim rewards from the Uniswap V3 pool.\n  /// @return tokensOut An array containing tokenA and tokenB.\n  /// @return amountsOut An array containing the amounts of token0 and token1 claimed as rewards.\n  function claimRewards(State storage state) external returns (address[] memory tokensOut, uint[] memory amountsOut, uint[] memory balancesBefore) {\n    address strategyProfitHolder = state.strategyProfitHolder;\n    IUniswapV3Pool pool = state.pool;\n    int24 lowerTick = state.lowerTick;\n    int24 upperTick = state.upperTick;\n    int24 lowerTickFillup = state.lowerTickFillup;\n    int24 upperTickFillup = state.upperTickFillup;\n    tokensOut = new address[](2);\n    tokensOut[0] = state.tokenA;\n    tokensOut[1] = state.tokenB;\n\n    balancesBefore = new uint[](2);\n    for (uint i; i < tokensOut.length; i++) {\n      balancesBefore[i] = IERC20(tokensOut[i]).balanceOf(address(this));\n    }\n\n    amountsOut = new uint[](2);\n    if (state.totalLiquidity > 0) {\n      pool.burn(lowerTick, upperTick, 0);\n      (amountsOut[0], amountsOut[1]) = pool.collect(\n        address(this),\n        lowerTick,\n        upperTick,\n        type(uint128).max,\n        type(uint128).max\n      );\n    }\n    if (state.totalLiquidityFillup > 0) {\n      pool.burn(lowerTickFillup, upperTickFillup, 0);\n      (uint fillup0, uint fillup1) = pool.collect(\n        address(this),\n        lowerTickFillup,\n        upperTickFillup,\n        type(uint128).max,\n        type(uint128).max\n      );\n      amountsOut[0] += fillup0;\n      amountsOut[1] += fillup1;\n    }\n\n    emit UniV3FeesClaimed(amountsOut[0], amountsOut[1]);\n\n    if (state.depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n\n    for (uint i; i < tokensOut.length; ++i) {\n      uint b = IERC20(tokensOut[i]).balanceOf(strategyProfitHolder);\n      if (b > 0) {\n        IERC20(tokensOut[i]).transferFrom(strategyProfitHolder, address(this), b);\n        amountsOut[i] += b;\n      }\n    }\n  }\n\n  function isReadyToHardWork(State storage state, ITetuConverter converter) external view returns (bool isReady) {\n    // check claimable amounts and compare with thresholds\n    (uint fee0, uint fee1) = getFees(state);\n\n    if (state.depositorSwapTokens) {\n      (fee0, fee1) = (fee1, fee0);\n    }\n\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    address h = state.strategyProfitHolder;\n\n    fee0 += IERC20(tokenA).balanceOf(h);\n    fee1 += IERC20(tokenB).balanceOf(h);\n\n    IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n    uint priceA = oracle.getAssetPrice(tokenA);\n    uint priceB = oracle.getAssetPrice(tokenB);\n\n    uint fee0USD = fee0 * priceA / 1e18;\n    uint fee1USD = fee1 * priceB / 1e18;\n\n    return fee0USD > HARD_WORK_USD_FEE_THRESHOLD || fee1USD > HARD_WORK_USD_FEE_THRESHOLD;\n  }\n\n  function sendFeeToProfitHolder(State storage state, uint fee0, uint fee1) external {\n    address strategyProfitHolder = state.strategyProfitHolder;\n    require(strategyProfitHolder != address (0), Uni3StrategyErrors.ZERO_PROFIT_HOLDER);\n    if (state.depositorSwapTokens) {\n      IERC20(state.tokenA).safeTransfer(strategyProfitHolder, fee1);\n      IERC20(state.tokenB).safeTransfer(strategyProfitHolder, fee0);\n    } else {\n      IERC20(state.tokenA).safeTransfer(strategyProfitHolder, fee0);\n      IERC20(state.tokenB).safeTransfer(strategyProfitHolder, fee1);\n    }\n    emit UniV3FeesClaimed(fee0, fee1);\n  }\n\n  //////////////////////////////////////////\n  //            Rebalance\n  //////////////////////////////////////////\n\n  /// @dev Rebalances the current position, adjusts the tick range, and attempts to cover loss with pool rewards.\n  /// @param state The State storage object.\n  /// @param converter The TetuConverter contract.\n  /// @param controller The Tetu controller address.\n  /// @param oldTotalAssets The amount of total assets before rebalancing.\n  /// @return tokenAmounts The token amounts for deposit (if length != 2 then do nothing).\n  /// @return isNeedFillup Indicates if fill-up is required after rebalancing.\n  function rebalance(\n    State storage state,\n    ITetuConverter converter,\n    address controller,\n    uint oldTotalAssets,\n    uint profitToCover,\n    address splitter\n  ) external returns (\n    uint[] memory tokenAmounts, // _depositorEnter(tokenAmounts) if length == 2\n    bool isNeedFillup\n  ) {\n    uint loss;\n    tokenAmounts = new uint[](0);\n    isNeedFillup = false;\n\n    RebalanceLocalVariables memory vars = RebalanceLocalVariables({\n      upperTick: state.upperTick,\n      lowerTick: state.lowerTick,\n      tickSpacing: state.tickSpacing,\n      pool: state.pool,\n      tokenA: state.tokenA,\n      tokenB: state.tokenB,\n      lastPrice: state.lastPrice,\n      fuseThreshold: state.fuseThreshold,\n      depositorSwapTokens: state.depositorSwapTokens,\n    // setup initial values\n      notCoveredLoss: 0,\n      newLowerTick: 0,\n      newUpperTick: 0,\n      fillUp: state.fillUp,\n      isStablePool: state.isStablePool,\n      newPrice: 0,\n      newTotalAssets: 0\n    });\n\n    require(needRebalance(\n      state.isFuseTriggered,\n      vars.pool,\n      vars.lowerTick,\n      vars.upperTick,\n      vars.tickSpacing,\n      state.rebalanceTickRange\n    ), Uni3StrategyErrors.NO_REBALANCE_NEEDED);\n\n    vars.newPrice = getOracleAssetsPrice(converter, vars.tokenA, vars.tokenB);\n\n    if (vars.isStablePool && isEnableFuse(vars.lastPrice, vars.newPrice, vars.fuseThreshold)) {\n      /// enabling fuse: close debt and stop providing liquidity\n      state.isFuseTriggered = true;\n      emit FuseTriggered();\n\n      UniswapV3DebtLib.closeDebt(\n        converter,\n        controller,\n        vars.pool,\n        vars.tokenA,\n        vars.tokenB,\n        _getLiquidatorSwapSlippage(vars.pool),\n        profitToCover,\n        oldTotalAssets,\n        splitter\n      );\n    } else {\n      /// rebalancing debt\n      /// setting new tick range\n      UniswapV3DebtLib.rebalanceDebt(\n        converter,\n        controller,\n        state,\n        _getLiquidatorSwapSlippage(vars.pool),\n        profitToCover,\n        oldTotalAssets,\n        splitter\n      );\n\n      tokenAmounts = new uint[](2);\n      tokenAmounts[0] = AppLib.balance(vars.tokenA);\n      tokenAmounts[1] = AppLib.balance(vars.tokenB);\n\n      if (vars.fillUp) {\n        isNeedFillup = true;\n      }\n\n      address[] memory tokens = new address[](2);\n      tokens[0] = vars.tokenA;\n      tokens[1] = vars.tokenB;\n      uint[] memory amounts = new uint[](2);\n      amounts[0] = tokenAmounts[0];\n      vars.newTotalAssets = ConverterStrategyBaseLib.calcInvestedAssets(tokens, amounts, 0, converter);\n      if (vars.newTotalAssets < oldTotalAssets) {\n        loss = oldTotalAssets - vars.newTotalAssets;\n      }\n    }\n\n    // need to update last price only for stables coz only stables have fuse mechanic\n    if (vars.isStablePool) {\n      state.lastPrice = vars.newPrice;\n    }\n\n    if (loss > 0) {\n      ISplitter(splitter).coverPossibleStrategyLoss(0, loss);\n    }\n\n    emit Rebalanced(loss);\n  }\n\n  function rebalanceSwapByAgg(\n    State storage state,\n    ITetuConverter converter,\n    uint oldTotalAssets,\n    RebalanceSwapByAggParams memory aggParams,\n    uint profitToCover,\n    address splitter\n  ) external returns (\n    uint[] memory tokenAmounts // _depositorEnter(tokenAmounts) if length == 2\n  ) {\n    uint loss;\n    tokenAmounts = new uint[](0);\n\n    if (state.fillUp) {\n      revert('Only for swap strategy.');\n    }\n\n    RebalanceLocalVariables memory vars = RebalanceLocalVariables({\n      upperTick: state.upperTick,\n      lowerTick: state.lowerTick,\n      tickSpacing: state.tickSpacing,\n      pool: state.pool,\n      tokenA: state.tokenA,\n      tokenB: state.tokenB,\n      lastPrice: state.lastPrice,\n      fuseThreshold: state.fuseThreshold,\n      depositorSwapTokens: state.depositorSwapTokens,\n    // setup initial values\n      notCoveredLoss: 0,\n      newLowerTick: 0,\n      newUpperTick: 0,\n      fillUp: state.fillUp,\n      isStablePool: state.isStablePool,\n      newPrice: 0,\n      newTotalAssets: 0\n    });\n\n    require(needRebalance(\n      state.isFuseTriggered,\n      vars.pool,\n      vars.lowerTick,\n      vars.upperTick,\n      vars.tickSpacing,\n      state.rebalanceTickRange\n    ), Uni3StrategyErrors.NO_REBALANCE_NEEDED);\n\n    vars.newPrice = getOracleAssetsPrice(converter, vars.tokenA, vars.tokenB);\n\n    if (vars.isStablePool && isEnableFuse(vars.lastPrice, vars.newPrice, vars.fuseThreshold)) {\n      /// enabling fuse: close debt and stop providing liquidity\n      state.isFuseTriggered = true;\n      emit FuseTriggered();\n\n      UniswapV3DebtLib.closeDebtByAgg(\n        converter,\n        vars.tokenA,\n        vars.tokenB,\n        _getLiquidatorSwapSlippage(vars.pool),\n        aggParams,\n        profitToCover,\n        oldTotalAssets,\n        splitter\n      );\n    } else {\n      /// rebalancing debt\n      /// setting new tick range\n      UniswapV3DebtLib.rebalanceDebtSwapByAgg(\n        converter,\n        state,\n        _getLiquidatorSwapSlippage(vars.pool),\n        aggParams,\n        profitToCover,\n        oldTotalAssets,\n        splitter\n      );\n\n      tokenAmounts = new uint[](2);\n      tokenAmounts[0] = AppLib.balance(vars.tokenA);\n      tokenAmounts[1] = AppLib.balance(vars.tokenB);\n\n      address[] memory tokens = new address[](2);\n      tokens[0] = vars.tokenA;\n      tokens[1] = vars.tokenB;\n      uint[] memory amounts = new uint[](2);\n      amounts[0] = tokenAmounts[0];\n      vars.newTotalAssets = ConverterStrategyBaseLib.calcInvestedAssets(tokens, amounts, 0, converter);\n      if (vars.newTotalAssets < oldTotalAssets) {\n        loss = oldTotalAssets - vars.newTotalAssets;\n      }\n    }\n\n    // need to update last price only for stables coz only stables have fuse mechanic\n    if (vars.isStablePool) {\n      state.lastPrice = vars.newPrice;\n    }\n\n    if (loss > 0) {\n      ISplitter(splitter).coverPossibleStrategyLoss(0, loss);\n    }\n\n    emit Rebalanced(loss);\n  }\n\n  function calcEarned(address asset, address controller, address[] memory rewardTokens, uint[] memory amounts) external view returns (uint) {\n    ITetuLiquidator liquidator = ITetuLiquidator(IController(controller).liquidator());\n    uint len = rewardTokens.length;\n    uint earned;\n    for (uint i; i < len; ++i) {\n      address token = rewardTokens[i];\n      if (token == asset) {\n        earned += amounts[i];\n      } else {\n        earned += liquidator.getPrice(rewardTokens[i], asset, amounts[i]);\n      }\n    }\n\n    return earned;\n  }\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3DebtLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBaseLib.sol\";\nimport \"../ConverterStrategyBaseLib2.sol\";\nimport \"./UniswapV3Lib.sol\";\nimport \"./Uni3StrategyErrors.sol\";\nimport \"./UniswapV3ConverterStrategyLogicLib.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\";\n\nlibrary UniswapV3DebtLib {\n\n  //////////////////////////////////////////\n  //            CONSTANTS\n  //////////////////////////////////////////\n\n  uint public constant SELL_GAP = 100;\n  /// @dev should be placed local, probably will be adjusted later\n  uint internal constant BORROW_PERIOD_ESTIMATION = 30 days / 2;\n  address internal constant ONEINCH = 0x1111111254EEB25477B68fb85Ed929f73A960582; // 1inch router V5\n  address internal constant OPENOCEAN = 0x6352a56caadC4F1E25CD6c75970Fa768A3304e64; // OpenOceanExchangeProxy\n\n  //////////////////////////////////////////\n  //            STRUCTURES\n  //////////////////////////////////////////\n\n  struct RebalanceDebtFillUpLocalVariables {\n    uint debtAmount;\n    uint availableBalanceTokenA;\n    uint availableBalanceTokenB;\n    uint needToBorrowOrFreeFromBorrow;\n  }\n\n  //////////////////////////////////////////\n  //            MAIN LOGIC\n  //////////////////////////////////////////\n\n  /// @dev Returns the total collateral amount out for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  /// @return totalCollateralAmountOut The total collateral amount out for the token pair.\n  function getDebtTotalCollateralAmountOut(ITetuConverter tetuConverter, address tokenA, address tokenB) public returns (uint totalCollateralAmountOut) {\n    (, totalCollateralAmountOut) = tetuConverter.getDebtAmountCurrent(address(this), tokenA, tokenB, false);\n  }\n\n  /// @dev Returns the total debt amount out for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  /// @return totalDebtAmountOut The total debt amount out for the token pair.\n  function getDebtTotalDebtAmountOut(ITetuConverter tetuConverter, address tokenA, address tokenB) public returns (uint totalDebtAmountOut) {\n    (totalDebtAmountOut,) = tetuConverter.getDebtAmountCurrent(address(this), tokenA, tokenB, true);\n  }\n\n  /// @dev Closes the debt positions for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param controller The controller address.\n  /// @param pool The IUniswapV3Pool instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  function closeDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    IUniswapV3Pool pool,\n    address tokenA,\n    address tokenB,\n    uint liquidatorSwapSlippage,\n    uint profitToCover,\n    uint totalAssets,\n    address splitter\n  ) public {\n    _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, liquidatorSwapSlippage);\n    if (profitToCover > 0) {\n      ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n    }\n  }\n\n  function closeDebtByAgg(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    uint liquidatorSwapSlippage,\n    UniswapV3ConverterStrategyLogicLib.RebalanceSwapByAggParams memory aggParams,\n    uint profitToCover,\n    uint totalAssets,\n    address splitter\n  ) public {\n    _closeDebtByAgg(tetuConverter, tokenA, tokenB, liquidatorSwapSlippage, aggParams);\n    if (profitToCover > 0) {\n      ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n    }\n  }\n\n  /// @dev Rebalances the debt by either filling up or closing and reopening debt positions. Sets new tick range.\n  function rebalanceDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    UniswapV3ConverterStrategyLogicLib.State storage state,\n    uint liquidatorSwapSlippage,\n    uint profitToCover,\n    uint totalAssets,\n    address splitter\n  ) external {\n    IUniswapV3Pool pool = state.pool;\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    if (state.fillUp) {\n      if (profitToCover > 0) {\n        ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n      }\n      _rebalanceDebtFillup(tetuConverter, controller, pool, tokenA, tokenB, liquidatorSwapSlippage);\n      (state.lowerTick, state.upperTick) = _calcNewTickRange(pool, state.lowerTick, state.upperTick, state.tickSpacing);\n    } else {\n      _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, liquidatorSwapSlippage);\n      if (profitToCover > 0) {\n        ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n      }\n      (int24 newLowerTick, int24 newUpperTick) = _calcNewTickRange(pool, state.lowerTick, state.upperTick, state.tickSpacing);\n      bytes memory entryData = getEntryData(pool, newLowerTick, newUpperTick, depositorSwapTokens);\n      _openDebt(tetuConverter, tokenA, tokenB, entryData);\n      state.lowerTick = newLowerTick;\n      state.upperTick = newUpperTick;\n    }\n  }\n\n  function rebalanceDebtSwapByAgg(\n    ITetuConverter tetuConverter,\n    UniswapV3ConverterStrategyLogicLib.State storage state,\n    uint liquidatorSwapSlippage,\n    UniswapV3ConverterStrategyLogicLib.RebalanceSwapByAggParams memory aggParams,\n    uint profitToCover,\n    uint totalAssets,\n    address splitter\n  ) external {\n    IUniswapV3Pool pool = state.pool;\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    _closeDebtByAgg(tetuConverter, tokenA, tokenB, liquidatorSwapSlippage, aggParams);\n    if (profitToCover > 0) {\n      ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n    }\n  (int24 newLowerTick, int24 newUpperTick) = _calcNewTickRange(pool, state.lowerTick, state.upperTick, state.tickSpacing);\n    bytes memory entryData = getEntryData(pool, newLowerTick, newUpperTick, depositorSwapTokens);\n    _openDebt(tetuConverter, tokenA, tokenB, entryData);\n    state.lowerTick = newLowerTick;\n    state.upperTick = newUpperTick;\n  }\n\n  function getEntryData(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    bool depositorSwapTokens\n  ) public view returns (bytes memory entryData) {\n    address token1 = pool.token1();\n    uint token1Price = UniswapV3Lib.getPrice(address(pool), token1);\n\n    uint token1Decimals = IERC20Metadata(token1).decimals();\n\n    uint token0Desired = token1Price;\n    uint token1Desired = 10 ** token1Decimals;\n\n    // calculate proportions\n    (uint consumed0, uint consumed1,) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTick, upperTick, token0Desired, token1Desired);\n\n    if (depositorSwapTokens) {\n      entryData = abi.encode(1, consumed1 * token1Price / token1Desired, consumed0);\n    } else {\n      entryData = abi.encode(1, consumed0, consumed1 * token1Price / token1Desired);\n    }\n  }\n\n  /// @dev we close debt only if it is more than $0.1\n  function needCloseDebt(uint debtAmount, ITetuConverter tetuConverter, address tokenB) public view returns (bool) {\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter.controller()).priceOracle());\n    return debtAmount * priceOracle.getAssetPrice(tokenB) / 10 ** IERC20Metadata(tokenB).decimals() > 1e17;\n  }\n\n  function calcTickRange(IUniswapV3Pool pool, int24 tickRange, int24 tickSpacing) public view returns (int24 lowerTick, int24 upperTick) {\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (tick < 0 && tick / tickSpacing * tickSpacing != tick) {\n      lowerTick = ((tick - tickRange) / tickSpacing - 1) * tickSpacing;\n    } else {\n      lowerTick = (tick - tickRange) / tickSpacing * tickSpacing;\n    }\n    upperTick = tickRange == 0 ? lowerTick + tickSpacing : lowerTick + tickRange * 2;\n  }\n\n  /// @notice Calculate the new tick range for a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool to calculate the new tick range for.\n  /// @param lowerTick The current lower tick value for the pool.\n  /// @param upperTick The current upper tick value for the pool.\n  /// @param tickSpacing The tick spacing for the pool.\n  /// @return lowerTickNew The new lower tick value for the pool.\n  /// @return upperTickNew The new upper tick value for the pool.\n  function _calcNewTickRange(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing\n  ) internal view returns (int24 lowerTickNew, int24 upperTickNew) {\n    int24 fullTickRange = upperTick - lowerTick;\n    (lowerTickNew, upperTickNew) = calcTickRange(pool, fullTickRange == tickSpacing ? int24(0) : fullTickRange / 2, tickSpacing);\n  }\n\n  /// @notice Closes debt by liquidating tokens as necessary.\n  ///         This function helps ensure that the converter strategy maintains the appropriate balances\n  ///         and debt positions for token A and token B, while accounting for potential price impacts.\n  function _closeDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    IUniswapV3Pool pool,\n    address tokenA,\n    address tokenB,\n    uint liquidatorSwapSlippage\n  ) internal {\n    uint debtAmount = getDebtTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n\n    if (needCloseDebt(debtAmount, tetuConverter, tokenB)) {\n      uint availableBalanceTokenA = AppLib.balance(tokenA);\n      uint availableBalanceTokenB = AppLib.balance(tokenB);\n\n      if (availableBalanceTokenB < debtAmount) {\n        uint tokenBprice = UniswapV3Lib.getPrice(address(pool), tokenB);\n        uint needToSellTokenA = tokenBprice * (debtAmount - availableBalanceTokenB) / 10 ** IERC20Metadata(tokenB).decimals();\n        // add 1% gap for price impact\n        needToSellTokenA += needToSellTokenA / SELL_GAP;\n\n        ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, Math.min(needToSellTokenA, availableBalanceTokenA), liquidatorSwapSlippage, 0, false);\n        availableBalanceTokenB = AppLib.balance(tokenB);\n      }\n\n      ConverterStrategyBaseLib.closePosition(\n        tetuConverter,\n        tokenA,\n        tokenB,\n        Math.min(debtAmount, availableBalanceTokenB)\n      );\n\n      availableBalanceTokenB = AppLib.balance(tokenB);\n      ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenB, tokenA, availableBalanceTokenB, liquidatorSwapSlippage, 0, false);\n    }\n  }\n\n  function _closeDebtByAgg(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    uint liquidatorSwapSlippage,\n    UniswapV3ConverterStrategyLogicLib.RebalanceSwapByAggParams memory aggParams\n  ) internal {\n    _checkSwapRouter(aggParams.agg);\n\n    uint debtAmount = getDebtTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n\n    if (needCloseDebt(debtAmount, tetuConverter, tokenB)) {\n      uint balanceTokenABefore = AppLib.balance(tokenA);\n      uint balanceTokenBBefore = AppLib.balance(tokenB);\n\n      address tokenIn = aggParams.direction ? tokenA : tokenB;\n\n      AppLib.approveIfNeeded(tokenIn, aggParams.amount, aggParams.agg);\n\n      {\n        (bool success, bytes memory result) = aggParams.agg.call(aggParams.swapData);\n        require(success, string(result));\n      }\n\n      uint availableBalanceTokenA = AppLib.balance(tokenA);\n      uint availableBalanceTokenB = AppLib.balance(tokenB);\n\n      require(\n        tetuConverter.isConversionValid(\n          tokenIn,\n          aggParams.amount,\n          aggParams.direction ? tokenB : tokenA,\n          aggParams.direction ? availableBalanceTokenB - balanceTokenBBefore : availableBalanceTokenA - balanceTokenABefore,\n          liquidatorSwapSlippage\n        ), AppErrors.PRICE_IMPACT);\n\n      ConverterStrategyBaseLib.closePosition(\n        tetuConverter,\n        tokenA,\n        tokenB,\n        Math.min(debtAmount, availableBalanceTokenB)\n      );\n\n      availableBalanceTokenB = AppLib.balance(tokenB);\n    }\n  }\n\n  /// @dev Opens a new debt position using entry data.\n  /// @param tetuConverter The TetuConverter contract.\n  /// @param tokenA The address of token A.\n  /// @param tokenB The address of token B.\n  /// @param entryData The data required to open a position.\n  function _openDebt(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    bytes memory entryData/*,\n    uint feeA*/\n  ) internal {\n    ConverterStrategyBaseLib.openPosition(\n      tetuConverter,\n      entryData,\n      tokenA,\n      tokenB,\n      AppLib.balance(tokenA)/* - feeA*/,\n      0\n    );\n  }\n\n  /// @dev Rebalances the debt to reach the optimal ratio between token A and token B.\n  function _rebalanceDebtFillup(\n    ITetuConverter tetuConverter,\n    address controller,\n    IUniswapV3Pool pool,\n    address tokenA,\n    address tokenB,\n    uint liquidatorSwapSlippage\n  ) internal {\n    RebalanceDebtFillUpLocalVariables memory vars;\n    vars.debtAmount = getDebtTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n\n    vars.availableBalanceTokenA = AppLib.balance(tokenA);\n    vars.availableBalanceTokenB = AppLib.balance(tokenB);\n\n    // todo fix this logic, i think its incorrect now\n    if (vars.debtAmount > 0) {\n      if (vars.availableBalanceTokenB > vars.debtAmount) {\n        vars.needToBorrowOrFreeFromBorrow = vars.availableBalanceTokenB - vars.debtAmount;\n\n        if (_getCollateralAmountForBorrow(tetuConverter, tokenA, tokenB, vars.needToBorrowOrFreeFromBorrow) < vars.availableBalanceTokenA) {\n          ConverterStrategyBaseLib.openPosition(\n            tetuConverter,\n            abi.encode(2),\n            tokenA,\n            tokenB,\n            vars.needToBorrowOrFreeFromBorrow,\n            0\n          );\n        } else {\n          ConverterStrategyBaseLib.closePosition(\n            tetuConverter,\n            tokenA,\n            tokenB,\n            vars.debtAmount\n          );\n\n          vars.availableBalanceTokenB = AppLib.balance(tokenB);\n\n          ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenB, tokenA, vars.availableBalanceTokenB, liquidatorSwapSlippage, 0, false);\n\n          vars.availableBalanceTokenA = AppLib.balance(tokenA);\n\n          ConverterStrategyBaseLib.openPosition(\n            tetuConverter,\n            abi.encode(1, 1, 1),\n            tokenA,\n            tokenB,\n            vars.availableBalanceTokenA,\n            0\n          );\n        }\n      } else {\n        vars.needToBorrowOrFreeFromBorrow = vars.debtAmount - vars.availableBalanceTokenB;\n        if (vars.availableBalanceTokenB > vars.needToBorrowOrFreeFromBorrow) {\n          ConverterStrategyBaseLib.closePosition(\n            tetuConverter,\n            tokenA,\n            tokenB,\n            vars.needToBorrowOrFreeFromBorrow\n          );\n        } else {\n          uint needToSellTokenA = UniswapV3Lib.getPrice(address(pool), tokenB) * vars.needToBorrowOrFreeFromBorrow / 10 ** IERC20Metadata(tokenB).decimals();\n          // add % gap for price impact\n          needToSellTokenA += needToSellTokenA / SELL_GAP;\n\n          if (needToSellTokenA <= vars.availableBalanceTokenA) {\n            ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, needToSellTokenA, liquidatorSwapSlippage, 0, false);\n\n            vars.availableBalanceTokenB = AppLib.balance(tokenB);\n\n            ConverterStrategyBaseLib.closePosition(\n              tetuConverter,\n              tokenA,\n              tokenB,\n              vars.debtAmount < vars.availableBalanceTokenB ? vars.debtAmount : vars.availableBalanceTokenB\n            );\n\n            vars.availableBalanceTokenA = AppLib.balance(tokenA);\n\n            ConverterStrategyBaseLib.openPosition(\n              tetuConverter,\n              abi.encode(1, 1, 1),\n              tokenA,\n              tokenB,\n              vars.availableBalanceTokenA,\n              0\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /// @dev Calculates the collateral amount required for borrowing a specified amount.\n  /// @param tetuConverter The TetuConverter contract.\n  /// @param tokenA The address of token A.\n  /// @param tokenB The address of token B.\n  /// @param needToBorrow The amount that needs to be borrowed.\n  /// @return collateralAmount The amount of collateral required for borrowing the specified amount.\n  function _getCollateralAmountForBorrow(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    uint needToBorrow\n  ) internal view returns (uint collateralAmount) {\n    ConverterStrategyBaseLib.OpenPositionLocal memory vars;\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter.findBorrowStrategies(\n      abi.encode(2),\n      tokenA,\n      needToBorrow,\n      tokenB,\n      BORROW_PERIOD_ESTIMATION\n    );\n\n    uint len = vars.converters.length;\n    if (len > 0) {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        vars.amountToBorrow = needToBorrow < vars.amountsToBorrow[i]\n        ? needToBorrow\n        : vars.amountsToBorrow[i];\n        vars.collateral = needToBorrow < vars.amountsToBorrow[i]\n        ? vars.collateralsRequired[i] * needToBorrow / vars.amountsToBorrow[i]\n        : vars.collateralsRequired[i];\n        needToBorrow -= vars.amountToBorrow;\n        if (needToBorrow == 0) break;\n      }\n    }\n    return vars.collateral;\n  }\n\n  /// @dev Gets the token balance without fees.\n  /// @param token The token address.\n  /// @param fee The fee amount to be subtracted from the balance.\n  /// @return balanceWithoutFees The token balance without the specified fee amount.\n  function getBalanceWithoutFees(address token, uint fee) internal view returns (uint balanceWithoutFees) {\n    balanceWithoutFees = AppLib.balance(token);\n    require(balanceWithoutFees >= fee, Uni3StrategyErrors.BALANCE_LOWER_THAN_FEE);\n    balanceWithoutFees -= fee;\n  }\n\n  function _checkSwapRouter(address router) internal pure {\n    require(router == ONEINCH || router == OPENOCEAN, Uni3StrategyErrors.UNKNOWN_SWAP_ROUTER);\n  }\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3Depositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"../DepositorBase.sol\";\nimport \"./Uni3StrategyErrors.sol\";\nimport \"../../integrations/uniswap/IUniswapV3MintCallback.sol\";\nimport \"./UniswapV3ConverterStrategyLogicLib.sol\";\n\n/// @title UniswapV3Depositor\n/// @dev Abstract contract that is designed to interact with Uniswap V3 pools and manage liquidity.\n///      Inherits from IUniswapV3MintCallback, DepositorBase, and Initializable.\nabstract contract UniswapV3Depositor is IUniswapV3MintCallback, DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant UNISWAPV3_DEPOSITOR_VERSION = \"1.0.4\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                VARIABLES\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev State variable to store the current state of the whole strategy\n  UniswapV3ConverterStrategyLogicLib.State internal state;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns the current state of the contract.\n  function getState() external view returns (\n    address tokenA,\n    address tokenB,\n    address pool,\n    address profitHolder,\n    int24 tickSpacing,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 rebalanceTickRange,\n    uint128 totalLiquidity,\n    bool isFuseTriggered,\n    uint fuseThreshold,\n    uint[] memory rebalanceResults\n  ) {\n    tokenA = state.tokenA;\n    tokenB = state.tokenB;\n    pool = address(state.pool);\n    profitHolder = state.strategyProfitHolder;\n    tickSpacing = state.tickSpacing;\n    lowerTick = state.lowerTick;\n    upperTick = state.upperTick;\n    rebalanceTickRange = state.rebalanceTickRange;\n    totalLiquidity = state.totalLiquidity;\n    isFuseTriggered = state.isFuseTriggered;\n    fuseThreshold = state.fuseThreshold;\n\n    rebalanceResults = new uint[](3);\n    rebalanceResults[0] = IERC20(tokenA).balanceOf(state.strategyProfitHolder);\n    rebalanceResults[1] = IERC20(tokenB).balanceOf(state.strategyProfitHolder);\n    rebalanceResults[2] = 0;\n  }\n\n  /// @notice Returns the fees for the current state.\n  /// @return fee0 and fee1.\n  function getFees() public view returns (uint fee0, uint fee1) {\n    return UniswapV3ConverterStrategyLogicLib.getFees(state);\n  }\n\n  /// @notice Returns the pool assets.\n  /// @return poolAssets An array containing the addresses of the pool assets.\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    poolAssets = new address[](2);\n    poolAssets[0] = state.tokenA;\n    poolAssets[1] = state.tokenB;\n  }\n\n  /// @notice Returns the pool weights and the total weight.\n  /// @return weights An array containing the weights of the pool assets, and totalWeight the sum of the weights.\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    weights = new uint[](2);\n    weights[0] = 1;\n    weights[1] = 1;\n    totalWeight = 2;\n  }\n\n  /// @notice Returns the pool reserves.\n  /// @return reserves An array containing the reserves of the pool assets.\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    return UniswapV3ConverterStrategyLogicLib.getPoolReserves(state);\n  }\n\n  /// @notice Returns the current liquidity of the depositor.\n  /// @return The current liquidity of the depositor.\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return uint(state.totalLiquidity);\n  }\n\n  /// @notice Returns the total supply of the depositor.\n  /// @return In UniV3 we can not calculate the total supply of the wgole pool. Return only ourself value.\n  function _depositorTotalSupply() override internal view virtual returns (uint) {\n    return uint(state.totalLiquidity);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CALLBACK\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Callback function called by Uniswap V3 pool on mint operation.\n  /// @param amount0Owed The amount of token0 owed to the pool.\n  /// @param amount1Owed The amount of token1 owed to the pool.\n  function uniswapV3MintCallback(\n    uint amount0Owed,\n    uint amount1Owed,\n    bytes calldata /*_data*/\n  ) external override {\n    require(msg.sender == address(state.pool), Uni3StrategyErrors.NOT_CALLBACK_CALLER);\n    if (amount0Owed > 0) IERC20(state.depositorSwapTokens ? state.tokenB : state.tokenA).safeTransfer(msg.sender, amount0Owed);\n    if (amount1Owed > 0) IERC20(state.depositorSwapTokens ? state.tokenA : state.tokenB).safeTransfer(msg.sender, amount1Owed);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Handles the deposit operation.\n  function _depositorEnter(\n    uint[] memory amountsDesired_\n  ) override internal virtual returns (uint[] memory amountsConsumed, uint liquidityOut) {\n    (amountsConsumed, liquidityOut, state.totalLiquidity) = UniswapV3ConverterStrategyLogicLib.enter(state.pool, state.lowerTick, state.upperTick, amountsDesired_, state.totalLiquidity, state.depositorSwapTokens);\n  }\n\n  /// @notice Handles the withdrawal operation.\n  /// @param liquidityAmount The amount of liquidity to be withdrawn.\n  /// @return amountsOut The amounts of the tokens withdrawn.\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    (uint fee0, uint fee1) = getFees();\n    amountsOut = UniswapV3ConverterStrategyLogicLib.exit(state, uint128(liquidityAmount));\n    UniswapV3ConverterStrategyLogicLib.sendFeeToProfitHolder(state, fee0, fee1);\n  }\n\n  /// @notice Returns the amount of tokens that would be withdrawn based on the provided liquidity amount.\n  /// @param liquidityAmount The amount of liquidity to quote the withdrawal for.\n  /// @return amountsOut The amounts of the tokens that would be withdrawn.\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    amountsOut = UniswapV3ConverterStrategyLogicLib.quoteExit(state, uint128(liquidityAmount));\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claims all possible rewards.\n  /// @return tokensOut An array containing the addresses of the reward tokens,\n  /// @return amountsOut An array containing the amounts of the reward tokens.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut,\n    uint[] memory balancesBefore\n  ) {\n    (tokensOut, amountsOut, balancesBefore) = UniswapV3ConverterStrategyLogicLib.claimRewards(state);\n  }\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[50 - 2] private __gap; // 50 - count of variables\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/uniswap/IUniswapV3Pool.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\n\n/// @title Uniswap V3 liquidity management helper\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary UniswapV3Lib {\n  uint8 internal constant RESOLUTION = 96;\n  uint internal constant Q96 = 0x1000000000000000000000000;\n  uint private constant TWO_96 = 2 ** 96;\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n  int24 internal constant MIN_TICK = - 887272;\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n  int24 internal constant MAX_TICK = - MIN_TICK;\n\n  struct PoolPosition {\n    address pool;\n    int24 lowerTick;\n    int24 upperTick;\n    uint128 liquidity;\n    address owner;\n  }\n\n  function getTickSpacing(uint24 fee) external pure returns (int24) {\n    if (fee == 10000) {\n      return 200;\n    }\n    if (fee == 3000) {\n      return 60;\n    }\n    if (fee == 500) {\n      return 10;\n    }\n    return 1;\n  }\n\n  function getFees(PoolPosition memory position) public view returns (uint fee0, uint fee1) {\n    bytes32 positionId = _getPositionId(position);\n    IUniswapV3Pool pool = IUniswapV3Pool(position.pool);\n    (, int24 tick, , , , ,) = pool.slot0();\n    (, uint feeGrowthInside0Last, uint feeGrowthInside1Last, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(positionId);\n    fee0 = _computeFeesEarned(position, true, feeGrowthInside0Last, tick) + uint(tokensOwed0);\n    fee1 = _computeFeesEarned(position, false, feeGrowthInside1Last, tick) + uint(tokensOwed1);\n  }\n\n  function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\n    IUniswapV3Pool pool = IUniswapV3Pool(pool_);\n    (uint160 sqrtRatioX96, , , , , ,) = pool.slot0();\n    liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\n    (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\n  }\n\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n  /// pool prices and the prices at the tick boundaries\n  function getLiquidityForAmounts(\n    uint160 sqrtRatioX96,\n    int24 lowerTick,\n    int24 upperTick,\n    uint amount0,\n    uint amount1\n  ) public pure returns (uint128 liquidity) {\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n      uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n    } else {\n      liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n    }\n  }\n\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n  /// pool prices and the prices at the tick boundaries\n  function getAmountsForLiquidity(\n    uint160 sqrtRatioX96,\n    int24 lowerTick,\n    int24 upperTick,\n    uint128 liquidity\n  ) public pure returns (uint amount0, uint amount1) {\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n    } else {\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    }\n  }\n\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(\n    uint a,\n    uint b,\n    uint denominator\n  ) public pure returns (uint result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = a * b\n    // Compute the product mod 2**256 and mod 2**256 - 1\n    // then use the Chinese Remainder Theorem to reconstruct\n    // the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2**256 + prod0\n    uint prod0;\n    // Least significant 256 bits of the product\n    uint prod1;\n    // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(a, b, not(0))\n      prod0 := mul(a, b)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division\n    if (prod1 == 0) {\n      require(denominator > 0);\n      assembly {\n        result := div(prod0, denominator)\n      }\n      return result;\n    }\n\n    // Make sure the result is less than 2**256.\n    // Also prevents denominator == 0\n    require(denominator > prod1);\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0]\n    // Compute remainder using mulmod\n    uint remainder;\n    assembly {\n      remainder := mulmod(a, b, denominator)\n    }\n    // Subtract 256 bit number from 512 bit number\n    assembly {\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator\n    // Compute largest power of two divisor of denominator.\n    // Always >= 1.\n    // EDIT for 0.8 compatibility:\n    // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\n    uint twos = denominator & (~denominator + 1);\n\n    // Divide denominator by power of two\n    assembly {\n      denominator := div(denominator, twos)\n    }\n\n    // Divide [prod1 prod0] by the factors of two\n    assembly {\n      prod0 := div(prod0, twos)\n    }\n    // Shift in bits from prod1 into prod0. For this we need\n    // to flip `twos` such that it is 2**256 / twos.\n    // If twos is zero, then it becomes one\n    assembly {\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2**256\n    // Now that denominator is an odd number, it has an inverse\n    // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n    // Compute the inverse by starting with a seed that is correct\n    // correct for four bits. That is, denominator * inv = 1 mod 2**4\n    uint inv = (3 * denominator) ^ 2;\n    // Now use Newton-Raphson iteration to improve the precision.\n    // Thanks to Hensel's lifting lemma, this also works in modular\n    // arithmetic, doubling the correct bits in each step.\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**8\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**16\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**32\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**64\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**128\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**256\n\n    // Because the division is now exact we can divide by multiplying\n    // with the modular inverse of denominator. This will give us the\n    // correct result modulo 2**256. Since the precoditions guarantee\n    // that the outcome is less than 2**256, this is the final result.\n    // We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inv;\n    return result;\n  }\n  }\n\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(\n    uint a,\n    uint b,\n    uint denominator\n  ) internal pure returns (uint result) {\n    result = mulDiv(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      require(result < type(uint).max);\n      result++;\n    }\n  }\n\n  /// @notice Calculates price in pool\n  function getPrice(address pool_, address tokenIn) public view returns (uint) {\n    IUniswapV3Pool pool = IUniswapV3Pool(pool_);\n    address token0 = pool.token0();\n    address token1 = pool.token1();\n\n    uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    (uint160 sqrtPriceX96,,,,,,) = pool.slot0();\n\n    uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\n\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\n    uint purePrice;\n    uint precision;\n    if (tokenIn == token0) {\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\n      purePrice = part * part;\n    } else {\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\n      purePrice = part * part;\n    }\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount0 The amount0 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\n    return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount1 The amount1 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount0 The amount0\n  function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\n  }\n\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount1 The amount1\n  function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\n  }\n\n  function _computeFeesEarned(\n    PoolPosition memory position,\n    bool isZero,\n    uint feeGrowthInsideLast,\n    int24 tick\n  ) internal view returns (uint fee) {\n    IUniswapV3Pool pool = IUniswapV3Pool(position.pool);\n    uint feeGrowthOutsideLower;\n    uint feeGrowthOutsideUpper;\n    uint feeGrowthGlobal;\n    if (isZero) {\n      feeGrowthGlobal = pool.feeGrowthGlobal0X128();\n      (,, feeGrowthOutsideLower,,,,,) = pool.ticks(position.lowerTick);\n      (,, feeGrowthOutsideUpper,,,,,) = pool.ticks(position.upperTick);\n    } else {\n      feeGrowthGlobal = pool.feeGrowthGlobal1X128();\n      (,,, feeGrowthOutsideLower,,,,) = pool.ticks(position.lowerTick);\n      (,,, feeGrowthOutsideUpper,,,,) = pool.ticks(position.upperTick);\n    }\n\n  unchecked {\n    // calculate fee growth below\n    uint feeGrowthBelow;\n    if (tick >= position.lowerTick) {\n      feeGrowthBelow = feeGrowthOutsideLower;\n    } else {\n      feeGrowthBelow = feeGrowthGlobal - feeGrowthOutsideLower;\n    }\n\n    // calculate fee growth above\n    uint feeGrowthAbove;\n    if (tick < position.upperTick) {\n      feeGrowthAbove = feeGrowthOutsideUpper;\n    } else {\n      feeGrowthAbove = feeGrowthGlobal - feeGrowthOutsideUpper;\n    }\n\n    uint feeGrowthInside =\n    feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove;\n    fee = mulDiv(\n      position.liquidity,\n      feeGrowthInside - feeGrowthInsideLast,\n      0x100000000000000000000000000000000\n    );\n  }\n  }\n\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\n  /// @dev Throws if |tick| > max tick\n  /// @param tick The input tick for the above formula\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n  /// at the given tick\n  function _getSqrtRatioAtTick(int24 tick)\n  internal\n  pure\n  returns (uint160 sqrtPriceX96)\n  {\n    uint256 absTick =\n    tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\n\n    // EDIT: 0.8 compatibility\n    require(absTick <= uint256(int256(MAX_TICK)), \"T\");\n\n    uint256 ratio =\n    absTick & 0x1 != 0\n    ? 0xfffcb933bd6fad37aa2d162d1a594001\n    : 0x100000000000000000000000000000000;\n    if (absTick & 0x2 != 0)\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n    if (absTick & 0x4 != 0)\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n    if (absTick & 0x8 != 0)\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n    if (absTick & 0x10 != 0)\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n    if (absTick & 0x20 != 0)\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n    if (absTick & 0x40 != 0)\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n    if (absTick & 0x80 != 0)\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n    if (absTick & 0x100 != 0)\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n    if (absTick & 0x200 != 0)\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n    if (absTick & 0x400 != 0)\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n    if (absTick & 0x800 != 0)\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n    if (absTick & 0x1000 != 0)\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n    if (absTick & 0x2000 != 0)\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n    if (absTick & 0x4000 != 0)\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n    if (absTick & 0x8000 != 0)\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n    if (absTick & 0x10000 != 0)\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n    if (absTick & 0x20000 != 0)\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n    if (absTick & 0x40000 != 0)\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n    if (absTick & 0x80000 != 0)\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n    if (tick > 0) ratio = type(uint256).max / ratio;\n\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n    sqrtPriceX96 = uint160(\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\n    );\n  }\n\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n  /// ever return.\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n  function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    // second inequality must be < because the price can never reach the price at the max tick\n    require(\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\n      \"R\"\n    );\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n    uint256 r = ratio;\n    uint256 msb = 0;\n\n    assembly {\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(5, gt(r, 0xFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(4, gt(r, 0xFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(3, gt(r, 0xFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(2, gt(r, 0xF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(1, gt(r, 0x3))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := gt(r, 0x1)\n      msb := or(msb, f)\n    }\n\n    if (msb >= 128) r = ratio >> (msb - 127);\n    else r = ratio << (127 - msb);\n\n    int256 log_2 = (int256(msb) - 128) << 64;\n\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(63, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(62, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(61, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(60, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(59, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(58, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(57, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(56, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(55, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(54, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(53, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(52, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(51, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(50, f))\n    }\n\n    tick = _getFinalTick(log_2, sqrtPriceX96);\n  }\n\n  function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    // 128.128 number\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\n\n    int24 tickLow =\n    int24(\n      (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\n    );\n    int24 tickHi =\n    int24(\n      (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\n    );\n\n    tick = (tickLow == tickHi)\n    ? tickLow\n    : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\n    ? tickHi\n    : tickLow);\n  }\n\n  function _getPositionId(PoolPosition memory position) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(position.owner, position.lowerTick, position.upperTick));\n  }\n\n  function _countDigits(uint n) internal pure returns (uint) {\n    if (n == 0) {\n      return 0;\n    }\n    uint count = 0;\n    while (n != 0) {\n      n = n / 10;\n      ++count;\n    }\n    return count;\n  }\n\n  function _min(uint a, uint b) internal pure returns (uint) {\n    return a < b ? a : b;\n  }\n\n  function _max(uint a, uint b) internal pure returns (uint) {\n    return a > b ? a : b;\n  }\n\n  function _toUint128(uint x) private pure returns (uint128 y) {\n    require((y = uint128(x)) == x);\n  }\n}\n"
    },
    "contracts/test/balancer/BalancerBoostedDepositorFacade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../strategies/balancer/BalancerBoostedDepositor.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @notice Provide direct access to internal functions of {BalancerBoostedDepositor}\ncontract BalancerBoostedDepositorFacade is BalancerBoostedDepositor {\n  function init(\n    address pool_,\n    address gauge_\n  ) external initializer {\n    console.log(\"BalancerBoostedDepositorFacade.init pool, gauge\", pool_, gauge_);\n    __BalancerBoostedDepositor_init(pool_, gauge_);\n  }\n\n  function _depositorPoolAssetsAccess() external virtual view returns (address[] memory poolAssets) {\n    return _depositorPoolAssets();\n  }\n\n  function _depositorPoolWeightsAccess() external virtual view returns (uint[] memory weights, uint totalWeight) {\n    return _depositorPoolWeights();\n  }\n\n  function _depositorPoolReservesAccess() external virtual view returns (uint[] memory reserves) {\n    return _depositorPoolReserves();\n  }\n\n  function _depositorLiquidityAccess() external virtual view returns (uint) {\n    return _depositorLiquidity();\n  }\n\n  function _depositorTotalSupplyAccess() external view returns (uint) {\n    return _depositorTotalSupply();\n  }\n\n  uint[] public lastAmountsConsumedOut;\n  uint public lastAmountsConsumedOutLength;\n  uint public lastLiquidityOut;\n\n  function _depositorEnterAccess(uint[] memory amountsDesired_) external virtual returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    (amountsConsumedOut, liquidityOut) = _depositorEnter(amountsDesired_);\n    // let's store results of _depositorEnter last call to public members\n    (lastAmountsConsumedOut, lastLiquidityOut) = (amountsConsumedOut, liquidityOut);\n    lastAmountsConsumedOutLength = lastAmountsConsumedOut.length;\n  }\n\n  uint[] public lastAmountsOut;\n  uint public lastAmountsOutLength;\n  uint public lastLiquidityAmountIn;\n\n  function _depositorExitAccess(uint liquidityAmount_) external returns (uint[] memory) {\n    lastLiquidityAmountIn = liquidityAmount_ == 0  // 0 means that we should withdraw all liquidity\n    ? _depositorLiquidity()\n    : liquidityAmount_;\n    lastAmountsOut = _depositorExit(lastLiquidityAmountIn);\n    lastAmountsOutLength = lastAmountsOut.length;\n    return lastAmountsOut;\n  }\n\n  uint[] public lastQuoteExitAmountsOut;\n  uint public lastQuoteExitAmountsOutLength;\n\n  function _depositorQuoteExitAccess(uint liquidityAmount_) external returns (uint[] memory) {\n    lastQuoteExitAmountsOut = _depositorQuoteExit(\n      liquidityAmount_ == 0  // 0 means that we should withdraw all liquidity\n      ? _depositorLiquidity()\n      : liquidityAmount_\n    );\n    lastQuoteExitAmountsOutLength = lastQuoteExitAmountsOut.length;\n    return lastQuoteExitAmountsOut;\n  }\n\n  uint[] public lastRewardsAmountsOut;\n  address[] public lastRewardsTokensOut;\n  uint public lastRewardsAmountsOutLength;\n  uint public lastRewardsTokensOutLength;\n\n  function _depositorClaimRewardsAccess() external virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut,\n    uint[] memory depositorBalancesBefore\n  ) {\n    (tokensOut, amountsOut, depositorBalancesBefore) = _depositorClaimRewards();\n    console.log(\"_depositorClaimRewardsAccess.tokensOut\", tokensOut.length);\n    console.log(\"_depositorClaimRewardsAccess.amountsOut\", amountsOut.length);\n    lastRewardsAmountsOut = amountsOut;\n    lastRewardsTokensOut = tokensOut;\n    lastRewardsAmountsOutLength = amountsOut.length;\n    lastRewardsTokensOutLength = tokensOut.length;\n  }\n}\n"
    },
    "contracts/test/balancer/BalancerLogicLibFacade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"../../strategies/balancer/BalancerLogicLib.sol\";\n\n/// @notice Provide external access to all functions of BalancerLogicLib\ncontract BalancerLogicLibFacade {\n  function getAmountsToDeposit(\n    uint[] memory amountsDesired_,\n    IERC20[] memory tokens_,\n    uint[] memory balances_,\n    uint[] memory totalUnderlying_,\n    uint indexBpt_\n  ) external view returns (\n    uint[] memory amountsOut\n  ) {\n    return BalancerLogicLib.getAmountsToDeposit(amountsDesired_, tokens_, balances_, totalUnderlying_, indexBpt_);\n  }\n\n  function getTotalAssetAmounts(IBVault vault_, IERC20[] memory tokens_, uint indexBpt_) external view returns (\n    uint[] memory amountsOut\n  ) {\n    return BalancerLogicLib.getTotalAssetAmounts(vault_, tokens_, indexBpt_);\n  }\n\n  function getBtpAmountsOut(\n    uint liquidityAmount_,\n    uint[] memory balances_,\n    uint bptIndex_\n  ) external pure returns (uint[] memory) {\n    return BalancerLogicLib.getBtpAmountsOut(liquidityAmount_, balances_, bptIndex_);\n  }\n}\n"
    },
    "contracts/test/BalancerBoostedStrategyAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/balancer/BalancerBoostedStrategy.sol\";\n\n/// @notice Provide direct access to BalancerBoostedStrategy internal functions\ncontract BalancerBoostedStrategyAccess is BalancerBoostedStrategy {\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  ///  Access to internal functions\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function _depositToPoolAccess(uint amount_, bool updateTotalAssetsBeforeInvest_) external returns (\n    uint loss\n  ) {\n    return _depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n  }\n\n  function _withdrawFromPoolAccess(uint amount) external returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    uint loss\n  ) {\n    return _withdrawFromPool(amount);\n  }\n\n  function _withdrawAllFromPoolAccess() external returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    uint loss\n  ) {\n    return _withdrawAllFromPool();\n  }\n}\n"
    },
    "contracts/test/Converter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// converter\nimport \"@tetu_io/tetu-converter/contracts/proxy/ProxyControlled.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/BorrowManager.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/ConverterController.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/DebtMonitor.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/Keeper.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/SwapManager.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/TetuConverter.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/PriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/tests/keeper/KeeperCaller.sol\";\nimport \"@tetu_io/tetu-converter/contracts/protocols/hundred-finance/HfPoolAdapter.sol\";\nimport \"@tetu_io/tetu-converter/contracts/protocols/hundred-finance/HfPlatformAdapter.sol\";\nimport \"@tetu_io/tetu-converter/contracts/tests/dforce/DForcePriceOracleMock.sol\";\nimport \"@tetu_io/tetu-converter/contracts/integrations/dforce/IDForceController.sol\";\nimport \"@tetu_io/tetu-converter/contracts/integrations/dforce/IDForcePriceOracle.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/aave3/Aave3PlatformAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/aave3/Aave3PoolAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/aave3/Aave3PoolAdapterEMode.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/aaveTwo/AaveTwoPlatformAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/aaveTwo/AaveTwoPoolAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/dforce/DForcePlatformAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/dforce/DForcePoolAdapter.sol\";\n"
    },
    "contracts/test/facades/ConverterStrategyBaseLibFacade.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\n\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"../../strategies/ConverterStrategyBaseLib.sol\";\nimport \"../../strategies/ConverterStrategyBaseLib2.sol\";\nimport \"../../integrations/tetu-v1/ITetuV1Controller.sol\";\n\n/// @notice Provide public access to internal functions of ConverterStrategyBaseLib and ConverterStrategyBaseLib2\ncontract ConverterStrategyBaseLibFacade {\n  mapping (address => uint) public liquidationThresholds;\n\n  function setLiquidationThreshold(address asset, uint values) external {\n    liquidationThresholds[asset] = values;\n  }\n\n  function getExpectedWithdrawnAmounts(\n    uint[] memory reserves_,\n    uint liquidityAmount_,\n    uint totalSupply_\n  ) external pure returns (\n    uint[] memory withdrawnAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.getExpectedWithdrawnAmounts(reserves_, liquidityAmount_, totalSupply_);\n  }\n\n  function getLiquidityAmount(\n    uint targetAmount_,\n    address strategy_,\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint investedAssets,\n    uint depositorLiquidity\n  ) external returns (\n    uint resultAmount,\n    uint[] memory amountsToConvertOut\n  ) {\n    return ConverterStrategyBaseLib2.getLiquidityAmount(\n      targetAmount_,\n      strategy_,\n      tokens,\n      indexAsset,\n      converter,\n      investedAssets,\n      depositorLiquidity\n    );\n  }\n\n  function getCollaterals(\n    uint amount_,\n    address[] memory tokens_,\n    uint[] memory weights_,\n    uint totalWeight_,\n    uint indexAsset_,\n    IPriceOracle priceOracle\n  ) external view returns (uint[] memory tokenAmountsOut) {\n    return ConverterStrategyBaseLib2.getCollaterals(\n      amount_,\n      tokens_,\n      weights_,\n      totalWeight_,\n      indexAsset_,\n      priceOracle\n    );\n  }\n\n  function openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdMainAsset_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.openPosition(\n      tetuConverter_,\n      entryData_,\n      collateralAsset_,\n      borrowAsset_,\n      amountIn_,\n      thresholdMainAsset_\n    );\n  }\n\n  function openPositionEntryKind1(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint collateralThreshold_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.openPositionEntryKind1(\n      tetuConverter_,\n      entryData_,\n      collateralAsset_,\n      borrowAsset_,\n      amountIn_,\n      collateralThreshold_\n    );\n  }\n\n  function closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint leftoverOut\n  ) {\n    return ConverterStrategyBaseLib.closePosition(\n      tetuConverter_,\n      collateralAsset,\n      borrowAsset,\n      amountToRepay\n    );\n  }\n\n  function liquidate(\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint slippage,\n    uint rewardLiquidationThresholdForTokenOut,\n    bool skipValidation\n  ) external returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.liquidate(\n      converter_,\n      liquidator_,\n      tokenIn,\n      tokenOut,\n      amountIn,\n      slippage,\n      rewardLiquidationThresholdForTokenOut,\n      skipValidation\n    );\n  }\n\n  function getAssetIndex(address[] memory tokens_, address asset_) external pure returns (uint) {\n    return ConverterStrategyBaseLib.getAssetIndex(tokens_, asset_);\n  }\n\n  function getAvailableBalances(\n    address[] memory tokens_,\n    uint indexAsset\n  ) external view returns (uint[] memory) {\n    return ConverterStrategyBaseLib2.getAvailableBalances(tokens_, indexAsset);\n  }\n\n  function calcInvestedAssets(\n    address[] memory tokens,\n    uint[] memory amountsOut,\n    uint indexAsset,\n    ITetuConverter converter_\n  ) external returns (\n    uint amountOut\n  ) {\n    return ConverterStrategyBaseLib.calcInvestedAssets(\n      tokens,\n      amountsOut,\n      indexAsset,\n      converter_\n    );\n  }\n\n  function sendPerformanceFee(address asset_, uint amount_, address splitter, address receiver_, uint ratio) external returns (\n    uint toPerf,\n    uint toInsurance\n  ) {\n    return ConverterStrategyBaseLib2.sendPerformanceFee(asset_, amount_, splitter, receiver_, ratio);\n  }\n\n  function swapToGivenAmountAccess(\n    uint targetAmount_,\n    address[] memory tokens_,\n    uint indexTargetAsset_,\n    address underlying_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint liquidationThresholdForTargetAsset_,\n    uint overswap_\n  ) external returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    return ConverterStrategyBaseLib.swapToGivenAmount(\n      targetAmount_,\n      tokens_,\n      indexTargetAsset_,\n      underlying_,\n      converter_,\n      liquidator_,\n      liquidationThresholdForTargetAsset_,\n      overswap_\n    );\n  }\n\n  function _swapToGivenAmountAccess(ConverterStrategyBaseLib.SwapToGivenAmountInputParams memory p) external returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    return ConverterStrategyBaseLib._swapToGivenAmount(p);\n  }\n\n  function swapToGetAmountAccess(\n    uint receivedTargetAmount,\n    ConverterStrategyBaseLib.SwapToGivenAmountInputParams memory p,\n    ConverterStrategyBaseLib.CalcInvestedAssetsLocal memory v,\n    uint indexTokenIn\n  ) external returns (\n    uint amountSpent,\n    uint amountReceived\n  ) {\n    return ConverterStrategyBaseLib._swapToGetAmount(receivedTargetAmount, p, v, indexTokenIn);\n  }\n\n  function convertAfterWithdraw(\n    ITetuConverter tetuConverter,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    uint liquidationThreshold,\n    address[] memory tokens,\n    uint[] memory amountsToConvert\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return ConverterStrategyBaseLib._convertAfterWithdraw(\n      tetuConverter,\n      liquidator,\n      indexAsset,\n      liquidationThreshold,\n      tokens,\n      amountsToConvert\n    );\n  }\n\n  function closePositionsToGetAmount(\n    ITetuConverter tetuConverter,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    uint requestedAmount,\n    address[] memory tokens\n  ) external returns (\n    uint expectedAmountMainAssetOut\n  ) {\n    return ConverterStrategyBaseLib.closePositionsToGetAmount(\n      tetuConverter,\n      liquidator,\n      indexAsset,\n      liquidationThresholds,\n      requestedAmount,\n      tokens\n    );\n  }\n\n  function _getAmountToSell(\n    uint remainingRequestedAmount,\n    uint totalDebt,\n    uint totalCollateral,\n    uint[] memory prices,\n    uint[] memory decs,\n    uint indexCollateral,\n    uint indexBorrowAsset,\n    uint balanceBorrowAsset\n  ) external pure returns (\n    uint amountOut\n  ) {\n    return ConverterStrategyBaseLib._getAmountToSell(\n      remainingRequestedAmount,\n      totalDebt,\n      totalCollateral,\n      prices,\n      decs,\n      indexCollateral,\n      indexBorrowAsset,\n      balanceBorrowAsset\n    );\n  }\n\n  function registerIncome(uint assetBefore, uint assetAfter) external pure returns (uint earned, uint lost) {\n    return ConverterStrategyBaseLib.registerIncome(assetBefore, assetAfter);\n  }\n\n  function sendTokensToForwarder(\n    address controller_,\n    address splitter_,\n    address[] memory tokens_,\n    uint[] memory amounts_\n  ) external {\n    return ConverterStrategyBaseLib2.sendTokensToForwarder(controller_, splitter_, tokens_, amounts_);\n  }\n\n  function recycle(\n    ITetuConverter converter_,\n    address asset,\n    uint compoundRatio,\n    address[] memory tokens,\n    ITetuLiquidator liquidator,\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    uint performanceFee\n  ) external returns (\n    uint[] memory amountsToForward,\n    uint amountToPerformanceAndInsurance\n  ) {\n    return ConverterStrategyBaseLib.recycle(\n      converter_,\n      asset,\n      compoundRatio,\n      tokens,\n      liquidator,\n      liquidationThresholds,\n      rewardTokens,\n      rewardAmounts,\n      performanceFee\n    );\n  }\n\n  function claimConverterRewards(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_,\n    uint[] memory balancesBefore\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    return ConverterStrategyBaseLib2.claimConverterRewards(\n      tetuConverter_,\n      tokens_,\n      rewardTokens_,\n      rewardAmounts_,\n      balancesBefore\n    );\n  }\n\n  function getTokenAmounts(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory collaterals_,\n    uint thresholdMainAsset_\n  ) external returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.getTokenAmounts(\n      tetuConverter_,\n      tokens_,\n      indexAsset_,\n      collaterals_,\n      thresholdMainAsset_\n    );\n  }\n\n  function _closePositionExact(\n    ITetuConverter converter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    uint balanceBorrowAsset\n  ) external returns (\n    uint collateralOut,\n    uint repaidAmountOut\n  ) {\n    return ConverterStrategyBaseLib._closePositionExact(\n      converter_,\n      collateralAsset,\n      borrowAsset,\n      amountRepay,\n      balanceBorrowAsset\n    );\n  }\n\n  function _closePosition(\n    ITetuConverter converter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n    return ConverterStrategyBaseLib._closePosition(converter_, collateralAsset, borrowAsset, amountToRepay);\n  }\n\n  function postWithdrawActions(\n    ITetuConverter converter,\n    address[] memory tokens,\n    uint indexAsset,\n\n    uint[] memory reservesBeforeWithdraw,\n    uint liquidityAmountWithdrew,\n    uint totalSupplyBeforeWithdraw,\n\n    uint[] memory amountsToConvert,\n    uint[] memory withdrawnAmounts\n  ) external returns (\n    uint[] memory expectedMainAssetAmounts,\n    uint[] memory _amountsToConvert\n  ) {\n    return ConverterStrategyBaseLib.postWithdrawActions(\n      converter,\n      tokens,\n      indexAsset,\n      reservesBeforeWithdraw,\n      liquidityAmountWithdrew,\n      totalSupplyBeforeWithdraw,\n      amountsToConvert,\n      withdrawnAmounts\n    );\n  }\n\n  function postWithdrawActionsEmpty(\n    ITetuConverter converter,\n    address[] memory tokens,\n    uint indexAsset,\n    uint[] memory amountsToConvert_\n  ) external returns (\n    uint[] memory expectedAmountsMainAsset\n  ) {\n      return ConverterStrategyBaseLib.postWithdrawActionsEmpty(converter, tokens, indexAsset, amountsToConvert_);\n  }\n}\n"
    },
    "contracts/test/facades/TokenAmountsLibTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../libs/TokenAmountsLib.sol\";\n\n/// @author bogdoslav\ncontract TokenAmountsLibTest {\n\n  function filterZeroAmounts(\n    address[] memory tokens,\n    uint[] memory amounts\n  ) external pure returns (\n    address[] memory t,\n    uint[] memory a\n  ) {\n    return TokenAmountsLib.filterZeroAmounts(tokens, amounts);\n  }\n\n  function combineArrays(\n    address[] memory tokens0,\n    uint[] memory amounts0,\n    address[] memory tokens1,\n    uint[] memory amounts1,\n    address[] memory tokens2,\n    uint[] memory amounts2\n  ) external pure returns (\n    address[] memory allTokens,\n    uint[] memory allAmounts\n  ) {\n    return TokenAmountsLib.combineArrays(\n      tokens0, amounts0,\n      tokens1, amounts1,\n      tokens2, amounts2\n    );\n  }\n\n  function uncheckedInc(uint i) external pure returns (uint) {\n    return TokenAmountsLib.uncheckedInc(i);\n  }\n}\n"
    },
    "contracts/test/MockConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../strategies/ConverterStrategyBase.sol\";\nimport \"./mocks/MockDepositor.sol\";\n\n/// @title Mock Converter Strategy with MockDepositor\n/// @author bogdoslav\ncontract MockConverterStrategy is ConverterStrategyBase, MockDepositor {\n\n  string public constant override NAME = \"mock converter strategy\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address[] memory depositorTokens_,\n    uint[] memory depositorWeights_,\n    uint[] memory depositorReserves_\n  ) external initializer {\n\n    __MockDepositor_init(\n      depositorTokens_,\n      depositorWeights_,\n      depositorReserves_\n    );\n\n    __ConverterStrategyBase_init(\n      controller_,\n      splitter_,\n      converter_\n    );\n  }\n\n  function init2(address controller_, address splitter_, address converter_) external {\n    __ConverterStrategyBase_init(\n      controller_,\n      splitter_,\n      converter_\n    );\n  }\n  //////////////////////////////////////////////////////////////////////\n  ///    Provide direct access to internal functions for tests\n  //////////////////////////////////////////////////////////////////////\n  function closePositionTestAccess(address collateralAsset, address borrowAsset, uint amountToRepay) external returns (\n    uint returnedAssetAmount,\n    uint leftover\n  ) {\n    return ConverterStrategyBaseLib.closePosition(converter, collateralAsset, borrowAsset, amountToRepay);\n  }\n\n  function updateInvestedAssetsTestAccess() external {\n    _updateInvestedAssets();\n  }\n\n  function withdrawUniversalTestAccess(uint amount, bool all, uint earnedByPrices_, uint investedAssets_) external returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss,\n    uint amountSentToInsurance\n  ) {\n    return _withdrawUniversal(all ? type(uint).max : amount, earnedByPrices_, investedAssets_);\n  }\n\n  function _doHardWorkAccess(bool reInvest) external returns (uint earned, uint lost) {\n    return _doHardWork(reInvest);\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// _handleRewards, mocked version + accessor\n  /////////////////////////////////////////////////////////////////////////////////////\n  function _handleRewards() internal override returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    if (handleRewardsParams.initialized) {\n      //      console.log(\"_handleRewards.mocked-version is called\");\n      if (handleRewardsParams.assetBalanceChange > 0) {\n        IERC20(asset).transferFrom(\n          handleRewardsParams.providerBalanceChange,\n          address(this),\n          uint(handleRewardsParams.assetBalanceChange)\n        );\n      } else if (handleRewardsParams.assetBalanceChange < 0) {\n        IERC20(asset).transfer(\n          handleRewardsParams.providerBalanceChange,\n          uint(- handleRewardsParams.assetBalanceChange)\n        );\n      }\n      return (handleRewardsParams.earned, handleRewardsParams.lost, AppLib.balance(asset));\n    } else {\n      return __handleRewards();\n    }\n  }\n\n  function __handleRewards() internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    uint assetBalanceBefore = AppLib.balance(asset);\n    (address[] memory rewardTokens, uint[] memory amounts) = _claim();\n    _rewardsLiquidation(rewardTokens, amounts);\n    assetBalanceAfterClaim = AppLib.balance(asset);\n    (uint earned2, uint lost2) = ConverterStrategyBaseLib.registerIncome(assetBalanceBefore, assetBalanceAfterClaim);\n    return (earned + earned2, lost + lost2, assetBalanceAfterClaim);\n  }\n\n  struct MockedHandleRewardsParams {\n    bool initialized;\n    uint earned;\n    uint lost;\n    int assetBalanceChange;\n    address providerBalanceChange;\n  }\n\n  MockedHandleRewardsParams private handleRewardsParams;\n\n  function setMockedHandleRewardsResults(\n    uint earned,\n    uint lost,\n    int assetBalanceChange,\n    address providerBalanceChange\n  ) external {\n    handleRewardsParams = MockedHandleRewardsParams({\n      initialized: true,\n      earned: earned,\n      lost: lost,\n      assetBalanceChange: assetBalanceChange,\n      providerBalanceChange: providerBalanceChange\n    });\n  }\n\n  //region -------------------------------------------- _depositToPoolUni mock\n  struct MockedDepositToPoolUniParams {\n    bool initialized;\n    int balanceChange;\n    address providerBalanceChange;\n    uint loss;\n    uint amountSentToInsurance;\n  }\n\n  MockedDepositToPoolUniParams internal depositToPoolParams;\n\n  function _depositToPoolAccess(uint amount_, bool updateTotalAssetsBeforeInvest_) external returns (\n    uint loss\n  ) {\n    return _depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n  }\n\n\n  function depositToPoolUniAccess(uint amount_, uint earnedByPrices_, uint investedAssets_) external returns (\n    uint strategyLoss,\n    uint amountSentToInsurance\n  ) {\n    return _depositToPoolUniversal(amount_, earnedByPrices_, investedAssets_);\n  }\n\n  function _depositToPoolUniversal(uint amount_, uint earnedByPrices_, uint investedAssets_) override internal virtual returns (\n    uint strategyLoss,\n    uint amountSentToInsurance\n  ){\n    if (depositToPoolParams.initialized) {\n      //      console.log(\"_depositToPool.mocked-version is called\");\n      if (depositToPoolParams.balanceChange > 0) {\n        IERC20(asset).transferFrom(\n          depositToPoolParams.providerBalanceChange,\n          address(this),\n          uint(depositToPoolParams.balanceChange)\n        );\n      } else if (depositToPoolParams.balanceChange < 0) {\n        IERC20(asset).transfer(\n          depositToPoolParams.providerBalanceChange,\n          uint(- depositToPoolParams.balanceChange)\n        );\n      }\n      return (depositToPoolParams.loss, depositToPoolParams.amountSentToInsurance);\n    } else {\n      return super._depositToPoolUniversal(amount_, earnedByPrices_, investedAssets_);\n    }\n  }\n\n  function setMockedDepositToPoolUni(\n    int balanceChange,\n    address providerBalanceChange,\n    uint loss,\n    uint amountSentToInsurance\n  ) external {\n    depositToPoolParams = MockedDepositToPoolUniParams({\n      initialized: true,\n      balanceChange: balanceChange,\n      providerBalanceChange: providerBalanceChange,\n      loss: loss,\n      amountSentToInsurance: amountSentToInsurance\n    });\n  }\n  //endregion -------------------------------------------- _depositToPoolUni mock\n\n  //region ---------------------------------------- _beforeDeposit\n  struct BeforeDepositParams {\n    uint amount;\n    uint indexAsset;\n    uint[] tokenAmounts;\n  }\n  mapping(bytes32 => BeforeDepositParams) internal _beforeDepositParams;\n  function setBeforeDeposit(uint amount_, uint indexAsset_, uint[] memory tokenAmounts) external {\n    bytes32 key = keccak256(abi.encodePacked(amount_, indexAsset_));\n    _beforeDepositParams[key] = BeforeDepositParams({\n      amount: amount_,\n      indexAsset: indexAsset_,\n      tokenAmounts: tokenAmounts\n    });\n  }\n\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) internal override returns (\n    uint[] memory tokenAmounts\n  ) {\n    bytes32 key = keccak256(abi.encodePacked(amount_, indexAsset_));\n    if (_beforeDepositParams[key].amount == amount_) {\n      return _beforeDepositParams[key].tokenAmounts;\n    } else {\n      return super._beforeDeposit(tetuConverter_, amount_, tokens_, indexAsset_);\n    }\n  }\n\n  function _beforeDepositAccess(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) external returns (\n    uint[] memory tokenAmounts\n  ) {\n    return _beforeDeposit(\n      tetuConverter_,\n      amount_,\n      tokens_,\n      indexAsset_\n    );\n  }\n  //endregion ---------------------------------------- _beforeDeposit\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// Others\n  /////////////////////////////////////////////////////////////////////////////////////\n\n  function _emergencyExitFromPoolAccess() external {\n    _emergencyExitFromPool();\n  }\n\n  function _prepareRewardsListAccess(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    return ConverterStrategyBaseLib2.claimConverterRewards(tetuConverter_, tokens_, rewardTokens_, rewardAmounts_, new uint[](0));\n  }\n\n  function _recycleAccess(address[] memory tokens, uint[] memory amounts) external returns (\n    uint[] memory amountsToForward\n  ) {\n    return _recycle(tokens, amounts);\n  }\n\n  function _makeRequestedAmountAccess(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint requestedAmount,\n    uint[] memory expectedMainAssetAmounts\n  ) external returns (\n    uint expectedTotalAmountMainAsset\n  ) {\n    return ConverterStrategyBaseLib.makeRequestedAmount(\n      tokens_,\n      indexAsset_,\n      amountsToConvert_,\n      converter_,\n      liquidator_,\n      requestedAmount,\n      expectedMainAssetAmounts,\n      liquidationThresholds\n    );\n  }\n}\n"
    },
    "contracts/test/mocks/MockDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../strategies/DepositorBase.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/IMockToken.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\n// import \"hardhat/console.sol\";\n\n/// @title Mock contract for base Depositor.\ncontract MockDepositor is DepositorBase, Initializable {\n\n  uint[] private _depositorReserves;\n  uint[] private _depositorWeights;\n\n  address[] private _depositorAssets;\n\n  /// @notice total amount of active LP tokens.\n  uint public totalSupply;\n  uint private depositorLiquidity;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  // @notice tokens must be MockTokens\n  function __MockDepositor_init(\n    address[] memory tokens_,\n    uint[] memory depositorWeights_,\n    uint[] memory depositorReserves_\n  ) internal onlyInitializing {\n    uint tokensLength = tokens_.length;\n    for (uint i = 0; i < tokensLength; ++i) {\n      _depositorAssets.push(tokens_[i]);\n      _depositorWeights.push(depositorWeights_[i]);\n      _depositorReserves.push(depositorReserves_[i]);\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorTotalSupply\n  /////////////////////////////////////////////////////////////////////\n  function setTotalSupply(uint totalSupply_) external {\n    totalSupply = totalSupply_;\n  }\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() override internal view returns (uint) {\n    return totalSupply;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorLiquidity\n  /////////////////////////////////////////////////////////////////////\n\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return depositorLiquidity;\n  }\n\n  function setDepositorLiquidity(uint depositorLiquidity_) external {\n    depositorLiquidity = depositorLiquidity_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Misc\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Returns pool assets\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory) {\n    //    console.log(\"_depositorPoolAssets\");\n    return _depositorAssets;\n  }\n\n  /// @dev Returns pool weights\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    //    console.log(\"_depositorPoolWeights\", _depositorWeights.length);\n    weights = _depositorWeights;\n    uint len = weights.length;\n    totalWeight = 0;\n    for (uint i; i < len; i++) {\n      totalWeight += weights[i];\n    }\n  }\n\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    reserves = _depositorReserves;\n  }\n\n  function setDepositorPoolReserves(uint[] memory depositorReserves_) external {\n    _depositorReserves = depositorReserves_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorEnter\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorEnterParams {\n    uint[] amountsDesired;\n    uint[] amountsConsumed;\n    uint liquidityOut;\n  }\n\n  DepositorEnterParams internal depositorEnterParams;\n\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  ) {\n    require(_depositorAssets.length == amountsDesired_.length);\n\n    uint len = amountsDesired_.length;\n    amountsConsumed = depositorEnterParams.amountsConsumed;\n\n    for (uint i = 0; i < len; ++i) {\n      require(amountsDesired_[i] == depositorEnterParams.amountsDesired[i], \"!depositorEnter\");\n      IMockToken token = IMockToken(_depositorAssets[i]);\n      token.burn(address(this), depositorEnterParams.amountsConsumed[i]);\n    }\n\n    liquidityOut = depositorEnterParams.liquidityOut;\n    depositorLiquidity += liquidityOut;\n  }\n\n  function setDepositorEnter(uint[] memory amountsDesired_, uint[] memory amountsConsumed_, uint liquidityOut_) external {\n    depositorEnterParams.liquidityOut = liquidityOut_;\n    depositorEnterParams.amountsDesired = amountsDesired_;\n    depositorEnterParams.amountsConsumed = amountsConsumed_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorExit\n  /////////////////////////////////////////////////////////////////////\n\n  struct DepositorExitParams {\n    uint liquidityAmount;\n    uint[] amountsOut;\n  }\n\n  DepositorExitParams internal depositorExitParams;\n\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    require(liquidityAmount == depositorExitParams.liquidityAmount, \"!depositorExit\");\n\n    uint len = _depositorAssets.length;\n    amountsOut = depositorExitParams.amountsOut;\n\n    for (uint i = 0; i < len; ++i) {\n      IMockToken token = IMockToken(_depositorAssets[i]);\n      token.mint(address(this), depositorExitParams.amountsOut[i]);\n    }\n\n    // we need to modify depositorLiquidity for tests with _updateInvestedAssets\n    if (depositorLiquidity >= liquidityAmount) {\n      depositorLiquidity -= liquidityAmount;\n    }\n  }\n\n  function setDepositorExit(uint liquidityAmount_, uint[] memory amountsOut_) external {\n    //    console.log(\"MockDepositor.setDepositorExit liquidityAmount\", liquidityAmount_);\n    depositorExitParams.liquidityAmount = liquidityAmount_;\n    depositorExitParams.amountsOut = amountsOut_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorQuoteExit\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorQuoteExitParams {\n    uint liquidityAmount;\n    uint[] amountsOut;\n  }\n  /// @notice keccak256(liquidityAmount + 1) => results\n  mapping(bytes32 => DepositorQuoteExitParams) internal depositorQuoteExitParams;\n\n  /// @dev Quotes output for given lp amount from the pool.\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual view returns (uint[] memory amountsOut) {\n    // console.log(\"_depositorQuoteExit.liquidityAmount\", liquidityAmount);\n    bytes32 key = keccak256(abi.encodePacked(liquidityAmount + 1));\n    DepositorQuoteExitParams memory p = depositorQuoteExitParams[key];\n    if (p.liquidityAmount == liquidityAmount) {\n      amountsOut = p.amountsOut;\n    } else {\n      //console.log(\"_depositorQuoteExit.missed liquidityAmount\", liquidityAmount);\n      revert(\"MockDepositor.!liquidityAmount\");\n    }\n\n    return amountsOut;\n  }\n\n  function setDepositorQuoteExit(uint liquidityAmount_, uint[] memory amountsOut_) external {\n    //    console.log(\"setDepositorQuoteExit, liquidityAmount_\", liquidityAmount_);\n    bytes32 key = keccak256(abi.encodePacked(liquidityAmount_ + 1));\n\n    DepositorQuoteExitParams memory p = DepositorQuoteExitParams({\n    liquidityAmount : liquidityAmount_,\n    amountsOut : amountsOut_\n    });\n\n    depositorQuoteExitParams[key] = p;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorClaimRewards\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorClaimRewardsParams {\n    address[] rewardTokens;\n    uint[] rewardAmounts;\n  }\n\n  DepositorClaimRewardsParams internal depositorClaimRewardsParams;\n\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    uint[] memory balancesBefore\n  ) {\n    uint len = depositorClaimRewardsParams.rewardTokens.length;\n    rewardTokens = depositorClaimRewardsParams.rewardTokens;\n    rewardAmounts = depositorClaimRewardsParams.rewardAmounts;\n\n    for (uint i = 0; i < len; ++i) {\n      IMockToken token = IMockToken(depositorClaimRewardsParams.rewardTokens[i]);\n      token.mint(address(this), depositorClaimRewardsParams.rewardAmounts[i]);\n    }\n    return (rewardTokens, rewardAmounts, balancesBefore);\n  }\n\n  function setDepositorClaimRewards(address[] memory rewardTokens_, uint[] memory rewardAmounts_) external {\n    depositorClaimRewardsParams.rewardTokens = rewardTokens_;\n    depositorClaimRewardsParams.rewardAmounts = rewardAmounts_;\n  }\n}\n"
    },
    "contracts/test/mocks/MockTetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\";\nimport \"../../libs/AppErrors.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @notice Mock of ITetuConverter, each function saves input params and has customizable output value\n///         Some functions can be not implemented\n/// @dev We assume, that in each test only single function is called, so we can setup behavior before the call\n///      and check results after the call on the side of the script\ncontract MockTetuConverter is ITetuConverter {\n  //////////////////////////////////////////////////////////\n  ///  Controller\n  //////////////////////////////////////////////////////////\n  address public _controller;\n\n  function controller() external view returns (address) {\n    return _controller;\n  }\n\n  function setController(address controller_) external {\n    _controller = controller_;\n  }\n\n\n  //////////////////////////////////////////////////////////\n  ///  findBorrowStrategy\n  //////////////////////////////////////////////////////////\n  struct FindBorrowStrategyOutputParams {\n    bytes entryData;\n    address[] converters;\n    uint[] collateralAmountsOut;\n    uint[] amountsToBorrowOut;\n    int[] aprs18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n    uint periodInBlocks;\n  }\n  /// @notice keccak256(entryData, sourceToken, targetToken) => results\n  mapping(bytes32 => FindBorrowStrategyOutputParams) public findBorrowStrategyOutputParams;\n\n  function findBorrowStrategies(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountsToBorrowOut,\n    int[] memory aprs18\n  ) {\n    periodInBlocks_;\n    console.log(\"MockTetuConverter.findBorrowStrategies token,amountIn\", sourceToken_, amountIn_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindBorrowStrategyOutputParams memory p = findBorrowStrategyOutputParams[key];\n    console.log(\"MockTetuConverter.p.sourceToken\", p.sourceToken);\n    if (sourceToken_ == p.sourceToken) {\n      return (\n      p.converters,\n      p.collateralAmountsOut,\n      p.amountsToBorrowOut,\n      p.aprs18\n      );\n    } else {\n      console.log(\"findBorrowStrategy.missed\", _tokenName(sourceToken_), amountIn_, _tokenName(targetToken_));\n      return (converters, collateralAmountsOut, amountsToBorrowOut, aprs18);\n    }\n  }\n\n  function setFindBorrowStrategyOutputParams(\n    bytes memory entryData_,\n    address[] memory converters_,\n    uint[] memory collateralAmountsOut_,\n    uint[] memory amountToBorrowsOut_,\n    int[] memory aprs18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external {\n    console.log(\"setFindBorrowStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    findBorrowStrategyOutputParams[key] = FindBorrowStrategyOutputParams({\n    entryData : entryData_,\n    converters : converters_,\n    collateralAmountsOut : collateralAmountsOut_,\n    amountsToBorrowOut : amountToBorrowsOut_,\n    aprs18 : aprs18_,\n    sourceAmount : sourceAmount_,\n    sourceToken : sourceToken_,\n    targetToken : targetToken_,\n    periodInBlocks : periodInBlocks_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  findSwapStrategy\n  //////////////////////////////////////////////////////////\n  struct FindSwapStrategyOutputParams {\n    bytes entryData;\n    address converter;\n    uint sourceAmountOut;\n    uint targetAmountOut;\n    int apr18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n  }\n  /// @notice keccak256(entryData_, sourceToken, targetToken) => results\n  mapping(bytes32 => FindSwapStrategyOutputParams) public findSwapStrategyOutputParams;\n\n  function findSwapStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external view returns (\n    address converter,\n    uint sourceAmountOut,\n    uint targetAmountOut,\n    int apr18\n  ) {\n    console.log(\"MockTetuConverter.findSwapStrategy token,amount\", sourceToken_, sourceAmount_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindSwapStrategyOutputParams memory p = findSwapStrategyOutputParams[key];\n    if (sourceToken_ == p.sourceToken) {\n      return (p.converter, p.sourceAmountOut, p.targetAmountOut, p.apr18);\n    } else {\n      console.log(\"findSwapStrategy.missed\", _tokenName(sourceToken_), sourceAmount_, _tokenName(targetToken_));\n      return (converter, sourceAmountOut, targetAmountOut, apr18);\n    }\n  }\n\n  function setFindSwapStrategyOutputParams(\n    bytes memory entryData_,\n    address converter_,\n    uint sourceAmountOut_,\n    uint targetAmountOut_,\n    int apr18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external {\n    console.log(\"setFindSwapStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(sourceToken_, targetToken_));\n    findSwapStrategyOutputParams[key] = FindSwapStrategyOutputParams({\n    entryData : entryData_,\n    converter : converter_,\n    sourceAmountOut : sourceAmountOut_,\n    targetAmountOut : targetAmountOut_,\n    apr18 : apr18_,\n    sourceToken : sourceToken_,\n    sourceAmount : sourceAmount_,\n    targetToken : targetToken_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  findConversionStrategy\n  //////////////////////////////////////////////////////////\n  struct FindConversionStrategyOutputParams {\n    bytes entryData;\n    address converter;\n    uint amountToBorrowOut;\n    uint collateralAmountOut;\n    int apr18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n    uint periodInBlocks;\n  }\n  /// @notice keccak256(entryData, sourceToken, targetToken) => results\n  mapping(bytes32 => FindConversionStrategyOutputParams) public findConversionStrategyOutputParams;\n\n  function findConversionStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address converter,\n    uint collateralAmountOut,\n    uint amountToBorrowOut,\n    int apr18\n  ) {\n    periodInBlocks_;\n    console.log(\"MockTetuConverter.findConversionStrategy token,amount\", sourceToken_, sourceAmount_);\n\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindConversionStrategyOutputParams memory p = findConversionStrategyOutputParams[key];\n    if (sourceToken_ == p.sourceToken) {\n      return (p.converter, p.collateralAmountOut, p.amountToBorrowOut, p.apr18);\n    } else {\n      console.log(\"findConversionStrategy.missed\", _tokenName(sourceToken_), sourceAmount_, _tokenName(targetToken_));\n      return (converter, collateralAmountOut, amountToBorrowOut, apr18);\n    }\n  }\n\n  function setFindConversionStrategyOutputParams(\n    bytes memory entryData_,\n    address converter_,\n    uint collateralAmountOut_,\n    uint amountToBorrowOut_,\n    int apr18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external {\n    console.log(\"setFindConversionStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    findConversionStrategyOutputParams[key] = FindConversionStrategyOutputParams({\n    entryData : entryData_,\n    converter : converter_,\n    collateralAmountOut : collateralAmountOut_,\n    amountToBorrowOut : amountToBorrowOut_,\n    apr18 : apr18_,\n    sourceAmount : sourceAmount_,\n    sourceToken : sourceToken_,\n    targetToken : targetToken_,\n    periodInBlocks : periodInBlocks_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  borrow\n  //////////////////////////////////////////////////////////\n  struct BorrowParams {\n    uint borrowedAmountOut;\n\n    address converter;\n    address collateralAsset;\n    uint collateralAmount;\n    address borrowAsset;\n    uint amountToBorrow;\n    address receiver;\n  }\n  /// @notice keccak256(converter_, collateralAsset_, collateralAmount_, borrowAsset_) => results\n  mapping(bytes32 => BorrowParams) public borrowParams;\n\n  function borrow(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_\n  ) external returns (\n    uint borrowedAmountOut\n  ) {\n    console.log(\"MockTetuConverter.borrow token,amount\", _tokenName(collateralAsset_), collateralAmount_);\n    bytes32 key = keccak256(abi.encodePacked(converter_, collateralAsset_, collateralAmount_, borrowAsset_));\n    BorrowParams memory p = borrowParams[key];\n    if (converter_ == p.converter\n    && collateralAsset_ == p.collateralAsset\n    && collateralAmount_ == p.collateralAmount\n      && borrowAsset_ == p.borrowAsset\n    ) {\n      IERC20Metadata(collateralAsset_).transferFrom(msg.sender, address(this), collateralAmount_);\n\n      uint balance = IERC20Metadata(borrowAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverter.borrow.balance, amountToBorrow_\", balance, amountToBorrow_);\n      require(balance >= amountToBorrow_, \"MockTetuConverter.borrow.balance\");\n      IERC20Metadata(borrowAsset_).transfer(receiver_, amountToBorrow_);\n\n      return p.borrowedAmountOut;\n    } else {\n      console.log(\"MockTetuConverter.borrow.missed.collateralAsset_\", _tokenName(collateralAsset_));\n      console.log(\"MockTetuConverter.borrow.missed.collateralAmount_\", collateralAmount_);\n      console.log(\"MockTetuConverter.borrow.missed.borrowAsset_\", _tokenName(borrowAsset_));\n      console.log(\"MockTetuConverter.borrow.missed.amountToBorrow_\", amountToBorrow_);\n      return 0;\n    }\n  }\n\n  function setBorrowParams(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_,\n    uint borrowedAmountOut_\n  ) external {\n    console.log(\"setBorrowParams\", collateralAsset_, collateralAmount_, borrowAsset_);\n    bytes32 key = keccak256(abi.encodePacked(converter_, collateralAsset_, collateralAmount_, borrowAsset_));\n    borrowParams[key] = BorrowParams({\n    converter : converter_,\n    collateralAsset : collateralAsset_,\n    collateralAmount : collateralAmount_,\n    borrowAsset : borrowAsset_,\n    amountToBorrow : amountToBorrow_,\n    receiver : receiver_,\n    borrowedAmountOut : borrowedAmountOut_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  repay\n  //////////////////////////////////////////////////////////\n  struct RepayParams {\n    address collateralAsset;\n    address borrowAsset;\n    uint amountToRepay;\n    address receiver;\n    uint collateralAmountOut;\n    uint returnedBorrowAmountOut;\n    uint swappedLeftoverCollateralOut;\n    uint swappedLeftoverBorrowOut;\n    uint debtGapValue;\n  }\n  /// @notice keccak256(collateralAsset_, borrowAsset_, amountToRepay_) => results\n  mapping(bytes32 => RepayParams) public repayParams;\n\n  function repay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_\n  ) external returns (\n    uint collateralAmountOut,\n    uint returnedBorrowAmountOut,\n    uint swappedLeftoverCollateralOut,\n    uint swappedLeftoverBorrowOut\n  ) {\n    console.log(\"MockTetuConverter.repay collateral,borrow,amount\", _tokenName(collateralAsset_), _tokenName(borrowAsset_), amountToRepay_);\n\n    require(IERC20Metadata(borrowAsset_).balanceOf(address(this)) == amountToRepay_, \"MockTetuConverter.repay.amountToRepay_\");\n\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    RepayParams memory p = repayParams[key];\n    if (collateralAsset_ == p.collateralAsset && borrowAsset_ == p.borrowAsset && amountToRepay_ == p.amountToRepay) {\n      // transfer collateral back to the strategy\n      uint balanceCollateral = IERC20Metadata(collateralAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverter.repay balanceCollateral, collateralAmountOut\", balanceCollateral, p.collateralAmountOut);\n      require(balanceCollateral >= p.collateralAmountOut, \"MockTetuConverter.repay.collateralAmountOut\");\n      IERC20Metadata(collateralAsset_).transfer(receiver_, p.collateralAmountOut);\n\n      // return debtGap if any\n      uint balanceBorrow = IERC20Metadata(borrowAsset_).balanceOf(address(this));\n      if (p.debtGapValue != 0) {\n        require(balanceBorrow >= p.debtGapValue, \"MockTetuConverter.repay.debtGapValue\");\n        IERC20Metadata(borrowAsset_).transfer(receiver_, p.debtGapValue);\n      }\n\n      // needToRepay was bigger than amountRepaid, we need to return the leftover back to the strategy\n      balanceBorrow = IERC20Metadata(borrowAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverter.repay balanceBorrow, returnedBorrowAmountOut\", balanceBorrow, p.returnedBorrowAmountOut);\n      if (p.returnedBorrowAmountOut != 0) {\n        require(balanceBorrow >= p.returnedBorrowAmountOut, \"MockTetuConverter.repay.returnedBorrowAmountOut\");\n        IERC20Metadata(borrowAsset_).transfer(receiver_, p.returnedBorrowAmountOut);\n      }\n\n      return (\n        p.collateralAmountOut,\n        p.returnedBorrowAmountOut,\n        p.swappedLeftoverCollateralOut,\n        p.swappedLeftoverBorrowOut\n      );\n    } else {\n      console.log(\"MockTetuConverter.repay.missed collateral,borrow,amountToRepay\", _tokenName(collateralAsset_), _tokenName(borrowAsset_), amountToRepay_);\n      return (collateralAmountOut, returnedBorrowAmountOut, swappedLeftoverCollateralOut, swappedLeftoverBorrowOut);\n    }\n  }\n\n  function setRepay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_,\n    uint collateralAmountOut_,\n    uint returnedBorrowAmountOut_,\n    uint swappedLeftoverCollateralOut_,\n    uint swappedLeftoverBorrowOut_,\n    uint debtGapValue\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    repayParams[key] = RepayParams({\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      amountToRepay: amountToRepay_,\n      receiver: receiver_,\n      collateralAmountOut: collateralAmountOut_,\n      returnedBorrowAmountOut: returnedBorrowAmountOut_,\n      swappedLeftoverCollateralOut: swappedLeftoverCollateralOut_,\n      swappedLeftoverBorrowOut: swappedLeftoverBorrowOut_,\n      debtGapValue: debtGapValue\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  quoteRepay\n  //////////////////////////////////////////////////////////\n  struct QuoteRepayParams {\n    address user;\n    address collateralAsset;\n    address borrowAsset;\n    uint amountToRepay;\n    uint collateralAmountOut;\n    uint swappedAmountOut;\n  }\n  /// @notice keccak256(collateralAsset_, borrowAsset_, amountToRepay_) => results\n  mapping(bytes32 => QuoteRepayParams) public quoteRepayParams;\n\n  function quoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_\n  ) external view returns (\n    uint collateralAmountOut,\n    uint swappedAmountOut\n  ) {\n    user_;\n    // hide warning\n    console.log(\"MockTetuConverter.quoteRepay collateral,borrow,amount\", _tokenName(collateralAsset_), _tokenName(borrowAsset_), amountToRepay_);\n\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    QuoteRepayParams memory p = quoteRepayParams[key];\n    if (p.collateralAsset == collateralAsset_) {\n      return (p.collateralAmountOut, p.swappedAmountOut);\n    } else {\n      console.log(\"MockTetuConverter.quoteRepay.missed amountToRepay_,collateralAsset_,borrowAsset_\", amountToRepay_, _tokenName(collateralAsset_), _tokenName(borrowAsset_));\n      return (0, 0);\n    }\n  }\n\n  function setQuoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    uint collateralAmountOut,\n    uint swappedAmountOut\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    quoteRepayParams[key] = QuoteRepayParams({\n      user: user_,\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      amountToRepay: amountToRepay_,\n      collateralAmountOut: collateralAmountOut,\n      swappedAmountOut: swappedAmountOut\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  getDebtAmountCurrent\n  //////////////////////////////////////////////////////////\n  struct GetDebtAmountParams {\n    address user;\n    address collateralAsset;\n    address borrowAsset;\n    uint totalDebtAmountOut;\n    uint totalCollateralAmountOut;\n    bool useDebtGap;\n  }\n\n  /// @notice keccak256(user_, collateralAsset_, borrowAsset_, useDebtGap_) => results\n  mapping(bytes32 => GetDebtAmountParams) public getDebtAmountCurrentParams;\n\n  function getDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    bool useDebtGap_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) {\n    console.log(\"MockTetuConverter.getDebtAmountCurrent user,collateral,borrow\", user_, _tokenName(collateralAsset_), _tokenName(borrowAsset_));\n\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_, useDebtGap_));\n    GetDebtAmountParams memory p = getDebtAmountCurrentParams[key];\n    if (\n      p.user == user_\n      && p.collateralAsset == collateralAsset_\n      && p.borrowAsset == borrowAsset_\n    ) {\n      console.log(\"MockTetuConverter.getDebtAmountCurrent totalDebtAmountOut,totalCollateralAmountOut\",\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut\n      );\n      return (\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut\n      );\n    } else {\n      console.log(\"MockTetuConverter.getDebtAmountCurrent.missed user,collateral,borrow\", user_, _tokenName(collateralAsset_), _tokenName(borrowAsset_));\n      console.log(\"MockTetuConverter.getDebtAmountCurrent.missed useDebtGap\", useDebtGap_);\n      return (0, 0);\n    }\n  }\n\n  function setGetDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut,\n    bool useDebtGap\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_, useDebtGap));\n    getDebtAmountCurrentParams[key] = GetDebtAmountParams({\n      user: user_,\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      totalCollateralAmountOut: totalCollateralAmountOut,\n      totalDebtAmountOut: totalDebtAmountOut,\n      useDebtGap: useDebtGap\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  getDebtAmountStored\n  //////////////////////////////////////////////////////////\n  /// @notice keccak256(user_, collateralAsset_, borrowAsset_, useDebtGap_) => results\n  mapping(bytes32 => GetDebtAmountParams) public getDebtAmountStoredParams;\n\n  function getDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    bool useDebtGap_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) {\n    console.log(\"MockTetuConverter.getDebtAmountStored user,collateral,borrow\", user_, _tokenName(collateralAsset_), _tokenName(borrowAsset_));\n\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_, useDebtGap_));\n    GetDebtAmountParams memory p = getDebtAmountCurrentParams[key];\n    if (p.user == user_) {\n      console.log(\"MockTetuConverter.getDebtAmountStored totalDebtAmountOut,totalCollateralAmountOut,useDebtGap_\",\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut,\n        useDebtGap_\n      );\n      return (\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut\n      );\n    } else {\n      console.log(\"MockTetuConverter.getDebtAmountStored.missed user,collateral,borrow\", user_, _tokenName(collateralAsset_), _tokenName(borrowAsset_));\n      console.log(\"MockTetuConverter.getDebtAmountStored.missed useDebtGap_\", useDebtGap_);\n      return (0, 0);\n    }\n  }\n\n  function setGetDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut,\n    bool useDebtGap\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_, useDebtGap));\n    getDebtAmountStoredParams[key] = GetDebtAmountParams({\n      user: user_,\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      totalCollateralAmountOut: totalCollateralAmountOut,\n      totalDebtAmountOut: totalDebtAmountOut,\n      useDebtGap: useDebtGap\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  estimateRepay\n  //////////////////////////////////////////////////////////\n  function estimateRepay(\n    address user_,\n    address collateralAsset_,\n    uint collateralAmountRequired_,\n    address borrowAsset_\n  ) external pure returns (\n    uint borrowAssetAmount,\n    uint unobtainableCollateralAssetAmount\n  ) {\n    user_;\n    collateralAsset_;\n    collateralAmountRequired_;\n    borrowAsset_;\n    borrowAssetAmount;\n    unobtainableCollateralAssetAmount;\n    revert (\"estimateRepay is not implemented\");\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  claimRewards\n  //////////////////////////////////////////////////////////\n  struct ClaimRewardsParams {\n    address[] rewardTokensOut;\n    uint[] amountsOut;\n  }\n\n  ClaimRewardsParams private claimRewardsParams;\n\n  function claimRewards(address receiver_) external returns (\n    address[] memory rewardTokensOut,\n    uint[] memory amountsOut\n  ) {\n    for (uint i = 0; i < claimRewardsParams.rewardTokensOut.length; ++i) {\n      uint balance = IERC20Metadata(claimRewardsParams.rewardTokensOut[i]).balanceOf(address(this));\n      console.log(\"claimRewards asset, balance, amountOut\", claimRewardsParams.rewardTokensOut[i], balance, claimRewardsParams.amountsOut[i]);\n      IERC20Metadata(claimRewardsParams.rewardTokensOut[i]).transfer(receiver_, claimRewardsParams.amountsOut[i]);\n    }\n    return (claimRewardsParams.rewardTokensOut, claimRewardsParams.amountsOut);\n  }\n\n  function setClaimRewards(address[] memory rewardTokensOut, uint[] memory amountsOut) external {\n    claimRewardsParams = ClaimRewardsParams({\n    rewardTokensOut : rewardTokensOut,\n    amountsOut : amountsOut\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  Safe liquidation\n  //////////////////////////////////////////////////////////\n  function safeLiquidate(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    address receiver_,\n    uint priceImpactToleranceSource_,\n    uint priceImpactToleranceTarget_\n  ) external pure returns (\n    uint amountOut\n  ) {\n    assetIn_;\n    amountIn_;\n    assetOut_;\n    receiver_;\n    priceImpactToleranceSource_;\n    priceImpactToleranceTarget_;\n    amountOut;\n    revert(\"safeLiquidate is not implemented\");\n  }\n\n  //region ----------------------------------------------  isConversionValid\n  enum SetIsConversionValidResult {\n    FAILED_0,\n    SUCCESS_1,\n    PRICE_ZERO_ERROR_2\n  }\n\n  struct IsConversionValidParams {\n    address assetIn;\n    uint amountIn;\n    address assetOut;\n    uint amountOut;\n    SetIsConversionValidResult result;\n  }\n  /// @notice keccak256(assetIn_, amountIn_, assetOut_, amountOut_) => results\n  mapping(bytes32 => IsConversionValidParams) public isConversionValidParams;\n\n  function isConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    uint priceImpactTolerance_\n  ) external view returns (bool) {\n    bytes32 key = keccak256(abi.encodePacked(assetIn_, amountIn_, assetOut_, amountOut_));\n    priceImpactTolerance_;\n    IsConversionValidParams memory p = isConversionValidParams[key];\n    if (p.assetIn == assetIn_) {\n      if (p.result == SetIsConversionValidResult.FAILED_0) {\n        return false;\n      } else if (p.result == SetIsConversionValidResult.SUCCESS_1) {\n        return true;\n      } else {\n        revert(AppErrors.ZERO_PRICE);\n      }\n    } else {\n      console.log(\"isConversionValid assetIn\", _tokenName(assetIn_), amountIn_);\n      console.log(\"isConversionValid assetOut\", _tokenName(assetOut_), amountOut_);\n      revert(\"isConversionValid is missed\");\n    }\n  }\n\n  function setIsConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    SetIsConversionValidResult result_\n  ) external {\n    console.log(\"setIsConversionValid assetIn\", assetIn_, amountIn_);\n    console.log(\"setIsConversionValid assetOut\", assetOut_, amountOut_);\n    bytes32 key = keccak256(abi.encodePacked(assetIn_, amountIn_, assetOut_, amountOut_));\n    isConversionValidParams[key] = IsConversionValidParams({\n      assetIn: assetIn_,\n      amountIn: amountIn_,\n      assetOut: assetOut_,\n      amountOut: amountOut_,\n      result: result_\n    });\n  }\n  //endregion ----------------------------------------------  isConversionValid\n\n\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external pure returns (\n    uint collateralAmountOut,\n    uint repaidAmountOut\n  ) {\n    poolAdapter_;\n    closePosition;\n    return (collateralAmountOut, repaidAmountOut);\n  }\n\n  function _tokenName(address token) internal view returns (string memory) {\n    return IERC20Metadata(token).symbol();\n  }\n\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external pure returns (\n    address[] memory poolAdaptersOut\n  ) {\n    user_; // hide warning\n    collateralToken_; // hide warning\n    borrowedToken_; // hide warning\n\n    return poolAdaptersOut;\n  }\n\n  function salvage(address receiver, address token, uint amount) external pure {\n    receiver;\n    token;\n    amount;\n    // not implemented\n  }\n\n}\n"
    },
    "contracts/test/PriceOracleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\n// import \"hardhat/console.sol\";\n\ncontract PriceOracleMock is IPriceOracle {\n  /// how much 1 token costs in USD, decimals 18\n  mapping(address => uint256) public prices;\n\n  constructor(address[] memory assets, uint[] memory pricesInUSD) {\n    _changePrices(assets, pricesInUSD);\n  }\n  ///////////////////////////////////////////////////////\n  ///           Set up\n  ///////////////////////////////////////////////////////\n  function changePrices(address[] memory assets, uint[] memory pricesInUSD) external {\n    _changePrices(assets, pricesInUSD);\n  }\n\n  function _changePrices(address[] memory assets, uint[] memory pricesInUSD) internal {\n    require(assets.length == pricesInUSD.length, \"wrong lengths\");\n    for (uint i = 0; i < assets.length; ++i) {\n      prices[assets[i]] = pricesInUSD[i];\n      // console.log(\"Price for %d is %d USD\", assets[i], pricesInUSD[i]);\n    }\n  }\n\n  ///////////////////////////////////////////////////////\n  ///           IPriceOracle\n  ///////////////////////////////////////////////////////\n\n  /// @notice Return asset price in USD, decimals 18\n  function getAssetPrice(address asset) external view override returns (uint256) {\n    // console.log(\"PriceOracleMock.getAssetPrice\", asset, prices[asset]);\n    return prices[asset];\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 150
    },
    "outputSelection": {
      "*": {
        "*": [
          "*",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "*",
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}