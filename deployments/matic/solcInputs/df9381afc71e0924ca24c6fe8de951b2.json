{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IControllable {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IController {\n\n  // --- DEPENDENCY ADDRESSES\n  function governance() external view returns (address);\n\n  function voter() external view returns (address);\n\n  function liquidator() external view returns (address);\n\n  function forwarder() external view returns (address);\n\n  function investFund() external view returns (address);\n\n  function veDistributor() external view returns (address);\n\n  function platformVoter() external view returns (address);\n\n  // --- VAULTS\n\n  function vaults(uint id) external view returns (address);\n\n  function vaultsList() external view returns (address[] memory);\n\n  function vaultsListLength() external view returns (uint);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  // --- restrictions\n\n  function isOperator(address _adr) external view returns (bool);\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n     */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n     */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IForwarder {\n\n  function tetu() external view returns (address);\n  function tetuThreshold() external view returns (uint);\n\n  function tokenPerDestinationLength(address destination) external view returns (uint);\n\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\n\n  function amountPerDestination(address token, address destination) external view returns (uint amount);\n\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vault,\n    bool isDistribute\n  ) external;\n\n  function distributeAll(address destination) external;\n\n  function distribute(address token) external;\n\n  function setInvestFundRatio(uint value) external;\n\n  function setGaugesRatio(uint value) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISplitter {\n\n  function init(address controller_, address _asset, address _vault) external;\n\n  // *************** ACTIONS **************\n\n  function withdrawAllToVault() external;\n\n  function withdrawToVault(uint256 amount) external;\n\n  function coverPossibleStrategyLoss(uint earned, uint lost) external;\n\n  function doHardWork() external;\n\n  function investAll() external;\n\n  // **************** VIEWS ***************\n\n  function asset() external view returns (address);\n\n  function vault() external view returns (address);\n\n  function totalAssets() external view returns (uint256);\n\n  function isHardWorking() external view returns (bool);\n\n  function strategies(uint i) external view returns (address);\n\n  function strategiesLength() external view returns (uint);\n\n  function HARDWORK_DELAY() external view returns (uint);\n\n  function lastHardWorks(address strategy) external view returns (uint);\n\n  function pausedStrategies(address strategy) external view returns (bool);\n\n  function pauseInvesting(address strategy) external;\n\n  function continueInvesting(address strategy, uint apr) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IStrategyV2 {\n\n  function NAME() external view returns (string memory);\n\n  function strategySpecificName() external view returns (string memory);\n\n  function PLATFORM() external view returns (string memory);\n\n  function STRATEGY_VERSION() external view returns (string memory);\n\n  function asset() external view returns (address);\n\n  function splitter() external view returns (address);\n\n  function compoundRatio() external view returns (uint);\n\n  function totalAssets() external view returns (uint);\n\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\n  function isReadyToHardWork() external view returns (bool);\n\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawAllToSplitter() external returns (uint strategyLoss);\n\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawToSplitter(uint amount) external returns (uint strategyLoss);\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external returns (\n    uint strategyLoss\n  );\n\n  function doHardWork() external returns (uint earned, uint lost);\n\n  function setCompoundRatio(uint value) external;\n\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\n  ///         0 means no deposit is allowed at this moment\n  function capacity() external view returns (uint);\n\n  /// @notice {performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\n  function performanceReceiver() external view returns (address);\n\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\n  /// @dev use FEE_DENOMINATOR\n  function performanceFee() external view returns (uint);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ITetuLiquidator {\n\n  struct PoolData {\n    address pool;\n    address swapper;\n    address tokenIn;\n    address tokenOut;\n  }\n\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\n\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\n\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\n\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint slippage\n  ) external;\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint slippage\n  ) external;\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IVaultInsurance.sol\";\nimport \"./IERC20.sol\";\nimport \"./ISplitter.sol\";\n\ninterface ITetuVaultV2 {\n\n  function splitter() external view returns (ISplitter);\n\n  function insurance() external view returns (IVaultInsurance);\n\n  function depositFee() external view returns (uint);\n\n  function withdrawFee() external view returns (uint);\n\n  function init(\n    address controller_,\n    IERC20 _asset,\n    string memory _name,\n    string memory _symbol,\n    address _gauge,\n    uint _buffer\n  ) external;\n\n  function setSplitter(address _splitter) external;\n\n  function coverLoss(uint amount) external;\n\n  function initInsurance(IVaultInsurance _insurance) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVaultInsurance {\n\n  function init(address _vault, address _asset) external;\n\n  function vault() external view returns (address);\n\n  function asset() external view returns (address);\n\n  function transferToVault(uint amount) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/InterfaceIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for interface IDs\n/// @author bogdoslav\nlibrary InterfaceIds {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant INTERFACE_IDS_LIB_VERSION = \"1.0.0\";\n\n  /// default notation:\n  /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\n\n  /// As type({Interface}).interfaceId can be changed,\n  /// when some functions changed at the interface,\n  /// so used hardcoded interface identifiers\n\n  bytes4 public constant I_VOTER = bytes4(keccak256(\"IVoter\"));\n  bytes4 public constant I_BRIBE = bytes4(keccak256(\"IBribe\"));\n  bytes4 public constant I_GAUGE = bytes4(keccak256(\"IGauge\"));\n  bytes4 public constant I_VE_TETU = bytes4(keccak256(\"IVeTetu\"));\n  bytes4 public constant I_SPLITTER = bytes4(keccak256(\"ISplitter\"));\n  bytes4 public constant I_FORWARDER = bytes4(keccak256(\"IForwarder\"));\n  bytes4 public constant I_MULTI_POOL = bytes4(keccak256(\"IMultiPool\"));\n  bytes4 public constant I_CONTROLLER = bytes4(keccak256(\"IController\"));\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\"ITetuERC165\"));\n  bytes4 public constant I_STRATEGY_V2 = bytes4(keccak256(\"IStrategyV2\"));\n  bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\"IControllable\"));\n  bytes4 public constant I_TETU_VAULT_V2 = bytes4(keccak256(\"ITetuVaultV2\"));\n  bytes4 public constant I_PLATFORM_VOTER = bytes4(keccak256(\"IPlatformVoter\"));\n  bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\"IVeDistributor\"));\n  bytes4 public constant I_TETU_CONVERTER = bytes4(keccak256(\"ITetuConverter\"));\n  bytes4 public constant I_VAULT_INSURANCE = bytes4(keccak256(\"IVaultInsurance\"));\n  bytes4 public constant I_STRATEGY_STRICT = bytes4(keccak256(\"IStrategyStrict\"));\n  bytes4 public constant I_ERC4626 = bytes4(keccak256(\"IERC4626\"));\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  /// @dev Gets a slot array by index as uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  // ************* ARRAY SETTERS *******************\n\n  /// @dev Sets a slot array at index with address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, address value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets a slot array at index with uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, uint value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets an array length\n  function setLength(bytes32 slot, uint length) internal {\n    assembly {\n      sstore(slot, length)\n    }\n  }\n\n  /// @dev Pushes an address to the array\n  function push(bytes32 slot, address value) internal {\n    uint length = arrayLength(slot);\n    setAt(slot, length, value);\n    setLength(slot, length + 1);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n\nlibrary StringLib {\n\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n  function toString(uint value) external pure returns (string memory) {\n    return _toString(value);\n  }\n\n  function _toString(uint value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint temp = value;\n    uint digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  function toAsciiString(address x) external pure returns (string memory) {\n    return _toAsciiString(x);\n  }\n\n  function _toAsciiString(address x) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = _char(hi);\n      s[2 * i + 1] = _char(lo);\n    }\n    return string(s);\n  }\n\n  function char(bytes1 b) external pure returns (bytes1 c) {\n    return _char(b);\n  }\n\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n    else return bytes1(uint8(b) + 0x57);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n     */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n  uint8 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n     */\n  bool private _initializing;\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n  event Initialized(uint8 version);\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n      \"Initializable: contract is already initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n      emit Initialized(1);\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier reinitializer(uint8 version) {\n    require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n    emit Initialized(version);\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n  modifier onlyInitializing() {\n    require(_initializing, \"Initializable: contract is not initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Initializable: contract is initializing\");\n    if (_initialized != type(uint8).max) {\n      _initialized = type(uint8).max;\n      emit Initialized(type(uint8).max);\n    }\n  }\n\n  /**\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n  function _getInitializedVersion() internal view returns (uint8) {\n    return _initialized;\n  }\n\n  /**\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n  function _isInitializing() internal view returns (bool) {\n    return _initializing;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n     */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n     */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(x, y, not(0))\n      prod0 := mul(x, y)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n      return prod0 / denominator;\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    require(denominator > prod1, \"Math: mulDiv overflow\");\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly {\n    // Compute remainder using mulmod.\n      remainder := mulmod(x, y, denominator)\n\n    // Subtract 256 bit number from 512 bit number.\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n    // See https://cs.stackexchange.com/q/138556/92363.\n\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\n    uint256 twos = denominator & (~denominator + 1);\n    assembly {\n    // Divide denominator by twos.\n      denominator := div(denominator, twos)\n\n    // Divide [prod1 prod0] by twos.\n      prod0 := div(prod0, twos)\n\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n\n    // Shift in bits from prod1 into prod0.\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n    // four bits. That is, denominator * inv = 1 mod 2^4.\n    uint256 inverse = (3 * denominator) ^ 2;\n\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n    // in modular arithmetic, doubling the correct bits in each step.\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inverse;\n    return result;\n  }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator,\n    Rounding rounding\n  ) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n  unchecked {\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    return min(result, a / result);\n  }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = sqrt(a);\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 128;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 64;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 32;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 16;\n    }\n    if (value >> 8 > 0) {\n      value >>= 8;\n      result += 8;\n    }\n    if (value >> 4 > 0) {\n      value >>= 4;\n      result += 4;\n    }\n    if (value >> 2 > 0) {\n      value >>= 2;\n      result += 2;\n    }\n    if (value >> 1 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log2(value);\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >= 10**64) {\n      value /= 10**64;\n      result += 64;\n    }\n    if (value >= 10**32) {\n      value /= 10**32;\n      result += 32;\n    }\n    if (value >= 10**16) {\n      value /= 10**16;\n      result += 16;\n    }\n    if (value >= 10**8) {\n      value /= 10**8;\n      result += 8;\n    }\n    if (value >= 10**4) {\n      value /= 10**4;\n      result += 4;\n    }\n    if (value >= 10**2) {\n      value /= 10**2;\n      result += 2;\n    }\n    if (value >= 10**1) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log10(value);\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 16;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 8;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 4;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 2;\n    }\n    if (value >> 8 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log256(value);\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n  }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n  unchecked {\n    uint256 oldAllowance = token.allowance(address(this), spender);\n    require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n    uint256 newAllowance = oldAllowance - value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/ControllableV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/SlotsLib.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"3.0.0\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  /// @dev Prevent implementation init\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) internal onlyInitializing {\n    require(controller_ != address(0), \"Zero controller\");\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\n    require(IController(controller_).governance() != address(0), \"Zero governance\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address _value) public override view returns (bool) {\n    return _value == controller();\n  }\n\n  /// @notice Return true if given address is setup as governance in Controller\n  function isGovernance(address _value) public override view returns (bool) {\n    return IController(controller()).governance() == _value;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view returns (uint){\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view returns (address){\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return controller address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./StrategyLib.sol\";\n\n/// @title Abstract contract for base strategy functionality\n/// @author belbix\nabstract contract StrategyBaseV2 is IStrategyV2, ControllableV3 {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant STRATEGY_BASE_VERSION = \"2.3.0\";\n  /// @notice 10% of total profit is sent to {performanceReceiver} before compounding\n  uint internal constant DEFAULT_PERFORMANCE_FEE = 10_000;\n  address internal constant DEFAULT_PERF_FEE_RECEIVER = 0x9Cc199D4353b5FB3e6C8EEBC99f5139e0d8eA06b;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Linked splitter\n  address public override splitter;\n  /// @dev Percent of profit for autocompound inside this strategy.\n  uint public override compoundRatio;\n  uint private __deprecatedSlot1;\n\n  /// @notice {performanceFee}% of total profit is sent to {performanceReceiver} before compounding\n  /// @dev governance by default\n  address public override performanceReceiver;\n\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\n  /// @dev {DEFAULT_PERFORMANCE_FEE} by default, FEE_DENOMINATOR is used\n  uint public override performanceFee;\n  /// @dev Represent specific name for this strategy. Should include short strategy name and used assets. Uniq across the vault.\n  string public override strategySpecificName;\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __StrategyBase_init(\n    address controller_,\n    address _splitter\n  ) internal onlyInitializing {\n    _requireInterface(_splitter, InterfaceIds.I_SPLITTER);\n    __Controllable_init(controller_);\n\n    require(IControllable(_splitter).isController(controller_), StrategyLib.WRONG_VALUE);\n\n    asset = ISplitter(_splitter).asset();\n    splitter = _splitter;\n\n    performanceReceiver = DEFAULT_PERF_FEE_RECEIVER;\n    performanceFee = DEFAULT_PERFORMANCE_FEE;\n  }\n\n  // *************************************************************\n  //                     PERFORMANCE FEE\n  // *************************************************************\n  /// @notice Set performance fee and receiver\n  function setupPerformanceFee(uint fee_, address receiver_) external {\n    StrategyLib._checkSetupPerformanceFee(controller(), fee_, receiver_);\n    performanceFee = fee_;\n    performanceReceiver = receiver_;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of underlying assets under control of this strategy.\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this)) + investedAssets();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_STRATEGY_V2 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                   VOTER ACTIONS\n  // *************************************************************\n\n  /// @dev PlatformVoter can change compound ratio for some strategies.\n  ///      A strategy can implement another logic for some uniq cases.\n  function setCompoundRatio(uint value) external virtual override {\n    StrategyLib._checkCompoundRatioChanged(controller(), compoundRatio, value);\n    compoundRatio = value;\n  }\n\n  // *************************************************************\n  //                   OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev The name will be used for UI.\n  function setStrategySpecificName(string calldata name) external {\n    StrategyLib._checkStrategySpecificNameChanged(controller(), name);\n    strategySpecificName = name;\n  }\n\n  /// @dev In case of any issue operator can withdraw all from pool.\n  function emergencyExit() external {\n    // check inside lib call\n\n    _emergencyExitFromPool();\n    StrategyLib.sendOnEmergencyExit(controller(), asset, splitter);\n  }\n\n  /// @dev Manual claim rewards.\n  function claim() external {\n    StrategyLib._checkManualClaim(controller());\n    _claim();\n  }\n\n  // *************************************************************\n  //                    DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function investAll(\n    uint /*amount_*/,\n    bool updateTotalAssetsBeforeInvest_\n  ) external override returns (\n    uint strategyLoss\n  ) {\n    uint balance = StrategyLib._checkInvestAll(splitter, asset);\n\n    if (balance > 0) {\n      strategyLoss = _depositToPool(balance, updateTotalAssetsBeforeInvest_);\n    }\n\n    return strategyLoss;\n  }\n\n  /// @dev Withdraws all underlying assets to the vault\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawAllToSplitter() external override returns (uint strategyLoss) {\n    address _splitter = splitter;\n    address _asset = asset;\n\n    uint balance = StrategyLib._checkSplitterSenderAndGetBalance(_splitter, _asset);\n\n    (uint expectedWithdrewUSD, uint assetPrice, uint _strategyLoss) = _withdrawAllFromPool();\n\n    StrategyLib._withdrawAllToSplitterPostActions(\n      _asset,\n      balance,\n      expectedWithdrewUSD,\n      assetPrice,\n      _splitter\n    );\n    return _strategyLoss;\n  }\n\n  /// @dev Withdraws some assets to the splitter\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawToSplitter(uint amount) external override returns (uint strategyLoss) {\n    address _splitter = splitter;\n    address _asset = asset;\n\n    uint balance = StrategyLib._checkSplitterSenderAndGetBalance(_splitter, _asset);\n\n    if (amount > balance) {\n      uint expectedWithdrewUSD;\n      uint assetPrice;\n\n      (expectedWithdrewUSD, assetPrice, strategyLoss) = _withdrawFromPool(amount - balance);\n      balance = StrategyLib.checkWithdrawImpact(\n        _asset,\n        balance,\n        expectedWithdrewUSD,\n        assetPrice,\n        _splitter\n      );\n    }\n\n    StrategyLib._withdrawToSplitterPostActions(\n      amount,\n      balance,\n      _asset,\n      _splitter\n    );\n    return strategyLoss;\n  }\n\n  // *************************************************************\n  //                       VIRTUAL\n  // These functions must be implemented in the strategy contract\n  // *************************************************************\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _depositToPool(\n    uint amount,\n    bool updateTotalAssetsBeforeInvest_\n  ) internal virtual returns (\n    uint strategyLoss\n  );\n\n  /// @dev Withdraw given amount from the pool.\n  /// @return expectedWithdrewUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawFromPool(uint amount) internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  );\n\n  /// @dev Withdraw all from the pool.\n  /// @return expectedWithdrewUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawAllFromPool() internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  );\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  ///      Withdraw assets without impact checking.\n  function _emergencyExitFromPool() internal virtual;\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal virtual returns (address[] memory rewardTokens, uint[] memory amounts);\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  ///      variables without shifting down storage in the inheritance chain.\n  ///      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[43] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\n\nlibrary StrategyLib {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Denominator for fee calculation.\n  uint internal constant FEE_DENOMINATOR = 100_000;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event CompoundRatioChanged(uint oldValue, uint newValue);\n  event StrategySpecificNameChanged(string name);\n  event EmergencyExit(address sender, uint amount);\n  event ManualClaim(address sender);\n  event InvestAll(uint balance);\n  event WithdrawAllToSplitter(uint amount);\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\n\n  // *************************************************************\n  //                        ERRORS\n  // *************************************************************\n\n  string internal constant DENIED = \"SB: Denied\";\n  string internal constant TOO_HIGH = \"SB: Too high\";\n  string internal constant WRONG_VALUE = \"SB: Wrong value\";\n  /// @dev Denominator for compound ratio\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n\n  // *************************************************************\n  //                        CHECKS AND EMITS\n  // *************************************************************\n\n  function _checkCompoundRatioChanged(address controller, uint oldValue, uint newValue) external {\n    onlyPlatformVoter(controller);\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\n    emit CompoundRatioChanged(oldValue, newValue);\n  }\n\n  function _checkStrategySpecificNameChanged(address controller, string calldata newName) external {\n    onlyOperators(controller);\n    emit StrategySpecificNameChanged(newName);\n  }\n\n  function _checkManualClaim(address controller) external {\n    onlyOperators(controller);\n    emit ManualClaim(msg.sender);\n  }\n\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\n    onlySplitter(splitter);\n    assetBalance = IERC20(asset).balanceOf(address(this));\n    emit InvestAll(assetBalance);\n  }\n\n  // *************************************************************\n  //                     RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Restrict access only for operators\n  function onlyOperators(address controller) public view {\n    require(IController(controller).isOperator(msg.sender), DENIED);\n  }\n\n  /// @dev Restrict access only for governance\n  function onlyGovernance(address controller) public view {\n    require(IController(controller).governance() == msg.sender, DENIED);\n  }\n\n  /// @dev Restrict access only for platform voter\n  function onlyPlatformVoter(address controller) public view {\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\n  }\n\n  /// @dev Restrict access only for splitter\n  function onlySplitter(address splitter) public view {\n    require(splitter == msg.sender, DENIED);\n  }\n\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_) external view {\n    onlyGovernance(controller);\n    require(fee_ <= 100_000, TOO_HIGH);\n    require(receiver_ != address(0), WRONG_VALUE);\n  }\n\n  // *************************************************************\n  //                       HELPERS\n  // *************************************************************\n\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\n  ///         Revert if the amount is different from expected too much (high price impact)\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\n  /// @param assetPrice Price of the asset, decimals 18\n  /// @return balance Current asset balance of the strategy\n  function checkWithdrawImpact(\n    address _asset,\n    uint balanceBefore,\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    address _splitter\n  ) public view returns (uint balance) {\n    balance = IERC20(_asset).balanceOf(address(this));\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\n\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\n    }\n  }\n\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\n    onlyOperators(controller);\n\n    uint balance = IERC20(asset).balanceOf(address(this));\n    IERC20(asset).safeTransfer(splitter, balance);\n    emit EmergencyExit(msg.sender, balance);\n  }\n\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\n    onlySplitter(splitter);\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  function _withdrawAllToSplitterPostActions(\n    address _asset,\n    uint balanceBefore,\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    address _splitter\n  ) external {\n    uint balance = checkWithdrawImpact(\n      _asset,\n      balanceBefore,\n      expectedWithdrewUSD,\n      assetPrice,\n      _splitter\n    );\n\n    if (balance != 0) {\n      IERC20(_asset).safeTransfer(_splitter, balance);\n    }\n    emit WithdrawAllToSplitter(balance);\n  }\n\n  function _withdrawToSplitterPostActions(\n    uint amount,\n    uint balance,\n    address _asset,\n    address _splitter\n  ) external {\n    uint amountAdjusted = Math.min(amount, balance);\n    if (amountAdjusted != 0) {\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\n    }\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/tools/TetuERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC165.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\n/// @author bogdoslav\nabstract contract TetuERC165 is ERC165 {\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        HELPER FUNCTIONS\n  // *************************************************************\n  /// @author bogdoslav\n\n  /// @dev Checks what interface with id is supported by contract.\n  /// @return bool. Do not throws\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\n      return isSupported;\n    } catch {\n    }\n    return false;\n  }\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\n    require(_isInterfaceSupported(contractAddress, interfaceId), \"Interface is not supported\");\n  }\n\n  /// @dev Checks what address is ERC20.\n  /// @return bool. Do not throws\n  function _isERC20(address contractAddress) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    bool totalSupplySupported;\n    try IERC20(contractAddress).totalSupply() returns (uint) {\n      totalSupplySupported = true;\n    } catch {\n    }\n\n    bool balanceSupported;\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\n      balanceSupported = true;\n    } catch {\n    }\n\n    return totalSupplySupported && balanceSupported;\n  }\n\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireERC20(address contractAddress) internal view {\n    require(_isERC20(contractAddress), \"Not ERC20\");\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @notice Keep and provide addresses of all application contracts\ninterface IConverterController {\n  function governance() external view returns (address);\n\n  // ********************* Health factor explanation  ****************\n  // For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\n  // For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\n  // We set min-health-factor = 1.1, target-health-factor = 1.3\n  // For collateral 100 we will borrow 100/1.3 = 76.92\n  //\n  // Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\n  // Collateral * LT    85         65.45\n  // Borrow value       65.38      65.38         but borrow value is the same as before\n  // Health factor      1.3        1.001         liquidation almost happens here (!)\n  //\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\n  // and the borrow value won't change at the same time, the liquidation happens at that point.\n  // Min health factor marks the point at which a rebalancing must be made asap.\n  // *****************************************************************\n\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\n  function minHealthFactor2() external view returns (uint16);\n  function setMinHealthFactor2(uint16 value_) external;\n\n  /// @notice target health factor with decimals 2\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\n  ///      or additional borrow and restore the health factor to the given target value\n  function targetHealthFactor2() external view returns (uint16);\n  function setTargetHealthFactor2(uint16 value_) external;\n\n  /// @notice max allowed health factor with decimals 2\n  /// @dev For future versions, currently max health factor is not used\n  function maxHealthFactor2() external view returns (uint16);\n  /// @dev For future versions, currently max health factor is not used\n  function setMaxHealthFactor2(uint16 value_) external;\n\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\n  function blocksPerDay() external view returns (uint);\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\n  /// @notice Check if it's time to call updateBlocksPerDay()\n  /// @param periodInSeconds_ Period of auto-update in seconds\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\n  /// @notice Recalculate blocksPerDay value\n  /// @param periodInSeconds_ Period of auto-update in seconds\n  function updateBlocksPerDay(uint periodInSeconds_) external;\n\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\n  function paused() external view returns (bool);\n\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\n  function isWhitelisted(address user_) external view returns (bool);\n\n  /// @notice The size of the gap by which the debt should be increased upon repayment\n  ///         Such gaps are required by AAVE pool adapters to workaround dust tokens problem\n  ///         and be able to make full repayment.\n  /// @dev Debt gap is applied as following: toPay = debt * (DEBT_GAP_DENOMINATOR + debtGap) / DEBT_GAP_DENOMINATOR\n  function debtGap() external view returns (uint);\n\n  //-----------------------------------------------------\n  //        Core application contracts\n  //-----------------------------------------------------\n\n  function tetuConverter() external view returns (address);\n  function borrowManager() external view returns (address);\n  function debtMonitor() external view returns (address);\n  function tetuLiquidator() external view returns (address);\n  function swapManager() external view returns (address);\n  function priceOracle() external view returns (address);\n\n  //-----------------------------------------------------\n  //        External contracts\n  //-----------------------------------------------------\n  /// @notice A keeper to control health and efficiency of the borrows\n  function keeper() external view returns (address);\n  /// @notice Controller of tetu-contracts-v2, that is allowed to update proxy contracts\n  function proxyUpdater() external view returns (address);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverterControllerProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IConverterControllerProvider {\n  function controller() external view returns (address);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IPriceOracle {\n  /// @notice Return asset price in USD, decimals 18\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IConverterControllerProvider.sol\";\n\n/// @notice Main contract of the TetuConverter application\n/// @dev Borrower (strategy) makes all operations via this contract only.\ninterface ITetuConverter is IConverterControllerProvider {\n\n  /// @notice Find possible borrow strategies and provide \"cost of money\" as interest for the period for each strategy\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param amountIn_  The meaning depends on entryData\n  ///                   For entryKind=0 it's max available amount of collateral\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\n  /// @return converters Array of available converters ordered in ascending order of APR.\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\n  ///                    This address should be passed to borrow-function during conversion.\n  ///                    The length of array is always equal to the count of available lending platforms.\n  ///                    Last items in array can contain zero addresses (it means they are not used)\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\n  /// @return amountToBorrowsOut Amounts that should be borrowed\n  ///                            This amount is not zero if corresponded converter is not zero.\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\n  function findBorrowStrategies(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountToBorrowsOut,\n    int[] memory aprs18\n  );\n\n  /// @notice Find best swap strategy and provide \"cost of money\" as interest for the period\n  /// @dev This is writable function with read-only behavior.\n  ///      It should be writable to be able to simulate real swap and get a real APR.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param amountIn_  The meaning depends on entryData\n  ///                   For entryKind=0 it's max available amount of collateral\n  ///                   This amount must be approved to TetuConverter before the call.\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\n  function findSwapStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_\n  ) external returns (\n    address converter,\n    uint sourceAmountOut,\n    uint targetAmountOut,\n    int apr18\n  );\n\n  /// @notice Find best conversion strategy (swap or borrow) and provide \"cost of money\" as interest for the period.\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\n  /// @dev This is writable function with read-only behavior.\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param amountIn_  The meaning depends on entryData\n  ///                   For entryKind=0 it's max available amount of collateral\n  ///                   This amount must be approved to TetuConverter before the call.\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\n  function findConversionStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external returns (\n    address converter,\n    uint collateralAmountOut,\n    uint amountToBorrowOut,\n    int apr18\n  );\n\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\n  ///      Only whitelisted users are allowed to make borrows\n  /// @param converter_ A converter received from findBestConversionStrategy.\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\n  ///                          This amount must be approved to TetuConverter before the call.\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\n  /// @param receiver_ A receiver of borrowed amount\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\n  function borrow(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_\n  ) external returns (\n    uint borrowedAmountOut\n  );\n\n  /// @notice Full or partial repay of the borrow\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\n  ///        You can know exact total amount of debt using {getStatusCurrent}.\n  ///        if the amount exceed total amount of the debt:\n  ///           - the debt will be fully repaid\n  ///           - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\n  ///        This amount should be calculated with taking into account possible debt gap,\n  ///        You should call getDebtAmountCurrent(debtGap = true) to get this amount.\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\n  ///         If TetuConverter is not able to make the swap, it reverts\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\n  ///                                 This amount is returned back to the collateralReceiver_\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\n  function repay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_\n  ) external returns (\n    uint collateralAmountOut,\n    uint returnedBorrowAmountOut,\n    uint swappedLeftoverCollateralOut,\n    uint swappedLeftoverBorrowOut\n  );\n\n  /// @notice Estimate result amount after making full or partial repay\n  /// @dev It works in exactly same way as repay() but don't make actual repay\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\n  /// @param user_ user whose amount-to-repay will be calculated\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\n  ///        This amount should be calculated without possible debt gap.\n  ///        In this way it's differ from {repay}\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\n  /// @return swappedAmountOut A part of {collateralAmountOut} that were received by direct swap\n  function quoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_\n  ) external returns (\n    uint collateralAmountOut,\n    uint swappedAmountOut\n  );\n\n  /// @notice Update status in all opened positions\n  ///         After this call getDebtAmount will be able to return exact amount to repay\n  /// @param user_ user whose debts will be returned\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\n  function getDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    bool useDebtGap_\n  ) external returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  );\n\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\n  /// @param user_ user whose debts will be returned\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\n  function getDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    bool useDebtGap_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  );\n\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\n  /// @param user_ user whose debts will be returned\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\n  ///                                           even if all borrowed amount will be returned.\n  ///                                           If this amount is not 0, you ask to get too much collateral.\n  function estimateRepay(\n    address user_,\n    address collateralAsset_,\n    uint collateralAmountRequired_,\n    address borrowAsset_\n  ) external view returns (\n    uint borrowAssetAmount,\n    uint unobtainableCollateralAssetAmount\n  );\n\n  /// @notice Transfer all reward tokens to {receiver_}\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\n  function claimRewards(address receiver_) external returns (\n    address[] memory rewardTokensOut,\n    uint[] memory amountsOut\n  );\n\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\n  ///                      It should be transferred on balance of the TetuConverter before the function call\n  /// @param receiver_ Result amount will be sent to this address\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\n  function safeLiquidate(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    address receiver_,\n    uint priceImpactToleranceSource_,\n    uint priceImpactToleranceTarget_\n  ) external returns (\n    uint amountOut\n  );\n\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\n  function isConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    uint priceImpactTolerance_\n  ) external view returns (bool);\n\n  /// @notice Close given borrow and return collateral back to the user, governance only\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\n  /// @param poolAdapter_ The pool adapter that represents the borrow\n  /// @param closePosition Close position after repay\n  ///        Usually it should be true, because the function always tries to repay all debt\n  ///        false can be used if user doesn't have enough amount to pay full debt\n  ///              and we are trying to pay \"as much as possible\"\n  /// @return collateralAmountOut Amount of collateral returned to the user\n  /// @return repaidAmountOut Amount of borrow asset paid to the lending platform\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\n    uint collateralAmountOut,\n    uint repaidAmountOut\n  );\n\n  /// @notice Get active borrows of the user with given collateral/borrowToken\n  /// @dev Simple access to IDebtMonitor.getPositions\n  /// @return poolAdaptersOut The instances of IPoolAdapter\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external view returns (\n    address[] memory poolAdaptersOut\n  );\n\n  /// @notice Save token from TC-balance to {receiver}\n  /// @dev Normally TetuConverter doesn't have any tokens on balance, they can appear there accidentally only\n  function salvage(address receiver, address token, uint amount) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice TetuConverter sends callback notifications to its user via this interface\ninterface ITetuConverterCallback {\n  /// @notice Converters calls this function if user should return some amount back.\n  ///         f.e. when the health factor is unhealthy and the converter needs more tokens to fix it.\n  ///         or when the full repay is required and converter needs to get full amount-to-repay.\n  /// @param asset_ Required asset (either collateral or borrow)\n  /// @param amount_ Required amount of the {asset_}\n  /// @return amountOut Exact amount that borrower has sent to balance of TetuConverter\n  function requirePayAmountBack(address asset_, uint amount_) external returns (uint amountOut);\n\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external;\n}\n"
    },
    "contracts/integrations/kyber/base_position_manager/IBasePositionManagerEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IBasePositionManagerEvents {\n  /// @notice Emitted when a token is minted for a given position\n  /// @param tokenId the newly minted tokenId\n  /// @param poolId poolId of the token\n  /// @param liquidity liquidity minted to the position range\n  /// @param amount0 token0 quantity needed to mint the liquidity\n  /// @param amount1 token1 quantity needed to mint the liquidity\n  event MintPosition(\n    uint256 indexed tokenId,\n    uint80 indexed poolId,\n    uint128 liquidity,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted when a token is burned\n  /// @param tokenId id of the token\n  event BurnPosition(uint256 indexed tokenId);\n\n  /// @notice Emitted when add liquidity\n  /// @param tokenId id of the token\n  /// @param liquidity the increase amount of liquidity\n  /// @param amount0 token0 quantity needed to increase liquidity\n  /// @param amount1 token1 quantity needed to increase liquidity\n  /// @param additionalRTokenOwed additional rToken earned\n  event AddLiquidity(\n    uint256 indexed tokenId,\n    uint128 liquidity,\n    uint256 amount0,\n    uint256 amount1,\n    uint256 additionalRTokenOwed\n  );\n\n  /// @notice Emitted when remove liquidity\n  /// @param tokenId id of the token\n  /// @param liquidity the decease amount of liquidity\n  /// @param amount0 token0 quantity returned when remove liquidity\n  /// @param amount1 token1 quantity returned when remove liquidity\n  /// @param additionalRTokenOwed additional rToken earned\n  event RemoveLiquidity(\n    uint256 indexed tokenId,\n    uint128 liquidity,\n    uint256 amount0,\n    uint256 amount1,\n    uint256 additionalRTokenOwed\n  );\n\n  /// @notice Emitted when burn position's RToken\n  /// @param tokenId id of the token\n  /// @param rTokenBurn amount of position's RToken burnt\n  event BurnRToken(uint256 indexed tokenId, uint256 rTokenBurn);\n\n  /// @notice Emitted when sync fee growth\n  /// @param tokenId id of the token\n  /// @param additionalRTokenOwed additional rToken earned\n  event SyncFeeGrowth(uint256 indexed tokenId, uint256 additionalRTokenOwed);\n}\n"
    },
    "contracts/integrations/kyber/IBasePositionManager.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\nimport {IRouterTokenHelper} from './IRouterTokenHelper.sol';\nimport {IBasePositionManagerEvents} from './base_position_manager/IBasePositionManagerEvents.sol';\n\ninterface IBasePositionManager is IRouterTokenHelper, IBasePositionManagerEvents {\n  struct Position {\n    // the nonce for permits\n    uint96 nonce;\n    // the address that is approved for spending this token\n    address operator;\n    // the ID of the pool with which this token is connected\n    uint80 poolId;\n    // the tick range of the position\n    int24 tickLower;\n    int24 tickUpper;\n    // the liquidity of the position\n    uint128 liquidity;\n    // the current rToken that the position owed\n    uint256 rTokenOwed;\n    // fee growth per unit of liquidity as of the last update to liquidity\n    uint256 feeGrowthInsideLast;\n  }\n\n  struct PoolInfo {\n    address token0;\n    uint24 fee;\n    address token1;\n  }\n\n  /// @notice Params for the first time adding liquidity, mint new nft to sender\n  /// @param token0 the token0 of the pool\n  /// @param token1 the token1 of the pool\n  ///   - must make sure that token0 < token1\n  /// @param fee the pool's fee in fee units\n  /// @param tickLower the position's lower tick\n  /// @param tickUpper the position's upper tick\n  ///   - must make sure tickLower < tickUpper, and both are in tick distance\n  /// @param ticksPrevious the nearest tick that has been initialized and lower than or equal to\n  ///   the tickLower and tickUpper, use to help insert the tickLower and tickUpper if haven't initialized\n  /// @param amount0Desired the desired amount for token0\n  /// @param amount1Desired the desired amount for token1\n  /// @param amount0Min min amount of token 0 to add\n  /// @param amount1Min min amount of token 1 to add\n  /// @param recipient the owner of the position\n  /// @param deadline time that the transaction will be expired\n  struct MintParams {\n    address token0;\n    address token1;\n    uint24 fee;\n    int24 tickLower;\n    int24 tickUpper;\n    int24[2] ticksPrevious;\n    uint256 amount0Desired;\n    uint256 amount1Desired;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    address recipient;\n    uint256 deadline;\n  }\n\n  /// @notice Params for adding liquidity to the existing position\n  /// @param tokenId id of the position to increase its liquidity\n  /// @param ticksPrevious the nearest tick that has been initialized and lower than or equal to\n  ///   the tickLower and tickUpper, use to help insert the tickLower and tickUpper if haven't initialized\n  ///   only needed if the position has been closed and the owner wants to add more liquidity\n  /// @param amount0Desired the desired amount for token0\n  /// @param amount1Desired the desired amount for token1\n  /// @param amount0Min min amount of token 0 to add\n  /// @param amount1Min min amount of token 1 to add\n  /// @param deadline time that the transaction will be expired\n  struct IncreaseLiquidityParams {\n    uint256 tokenId;\n    int24[2] ticksPrevious;\n    uint256 amount0Desired;\n    uint256 amount1Desired;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    uint256 deadline;\n  }\n\n  /// @notice Params for remove liquidity from the existing position\n  /// @param tokenId id of the position to remove its liquidity\n  /// @param amount0Min min amount of token 0 to receive\n  /// @param amount1Min min amount of token 1 to receive\n  /// @param deadline time that the transaction will be expired\n  struct RemoveLiquidityParams {\n    uint256 tokenId;\n    uint128 liquidity;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    uint256 deadline;\n  }\n\n  /// @notice Burn the rTokens to get back token0 + token1 as fees\n  /// @param tokenId id of the position to burn r token\n  /// @param amount0Min min amount of token 0 to receive\n  /// @param amount1Min min amount of token 1 to receive\n  /// @param deadline time that the transaction will be expired\n  struct BurnRTokenParams {\n    uint256 tokenId;\n    uint256 amount0Min;\n    uint256 amount1Min;\n    uint256 deadline;\n  }\n\n  /// @notice Creates a new pool if it does not exist, then unlocks if it has not been unlocked\n  /// @param token0 the token0 of the pool\n  /// @param token1 the token1 of the pool\n  /// @param fee the fee for the pool\n  /// @param currentSqrtP the initial price of the pool\n  /// @return pool returns the pool address\n  function createAndUnlockPoolIfNecessary(\n    address token0,\n    address token1,\n    uint24 fee,\n    uint160 currentSqrtP\n  ) external payable returns (address pool);\n\n  function mint(MintParams calldata params)\n    external\n    payable\n    returns (\n      uint256 tokenId,\n      uint128 liquidity,\n      uint256 amount0,\n      uint256 amount1\n    );\n\n  function addLiquidity(IncreaseLiquidityParams calldata params)\n    external\n    payable\n    returns (\n      uint128 liquidity,\n      uint256 amount0,\n      uint256 amount1,\n      uint256 additionalRTokenOwed\n    );\n\n  function removeLiquidity(RemoveLiquidityParams calldata params)\n    external\n    returns (\n      uint256 amount0,\n      uint256 amount1,\n      uint256 additionalRTokenOwed\n    );\n\n  function burnRTokens(BurnRTokenParams calldata params)\n    external\n    returns (\n      uint256 rTokenQty,\n      uint256 amount0,\n      uint256 amount1\n    );\n\n  /**\n   * @dev Burn the token by its owner\n   * @notice All liquidity should be removed before burning\n   */\n  function burn(uint256 tokenId) external payable;\n\n  function syncFeeGrowth(uint256 tokenId) external returns (uint256 additionalRTokenOwed);\n\n  function positions(uint256 tokenId)\n    external\n    view\n    returns (Position memory pos, PoolInfo memory info);\n\n  function addressToPoolId(address pool) external view returns (uint80);\n\n  function isRToken(address token) external view returns (bool);\n\n  function nextPoolId() external view returns (uint80);\n\n  function nextTokenId() external view returns (uint256);\n\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/integrations/kyber/IFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\n/// @title KyberSwap v2 factory\n/// @notice Deploys KyberSwap v2 pools and manages control over government fees\ninterface IFactory {\n  /// @notice Emitted when a pool is created\n  /// @param token0 First pool token by address sort order\n  /// @param token1 Second pool token by address sort order\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\n  /// @param tickDistance Minimum number of ticks between initialized ticks\n  /// @param pool The address of the created pool\n  event PoolCreated(\n    address indexed token0,\n    address indexed token1,\n    uint24 indexed swapFeeUnits,\n    int24 tickDistance,\n    address pool\n  );\n\n  /// @notice Emitted when a new fee is enabled for pool creation via the factory\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\n  /// @param tickDistance Minimum number of ticks between initialized ticks for pools created with the given fee\n  event SwapFeeEnabled(uint24 indexed swapFeeUnits, int24 indexed tickDistance);\n\n  /// @notice Emitted when vesting period changes\n  /// @param vestingPeriod The maximum time duration for which LP fees\n  /// are proportionally burnt upon LP removals\n  event VestingPeriodUpdated(uint32 vestingPeriod);\n\n  /// @notice Emitted when configMaster changes\n  /// @param oldConfigMaster configMaster before the update\n  /// @param newConfigMaster configMaster after the update\n  event ConfigMasterUpdated(address oldConfigMaster, address newConfigMaster);\n\n  /// @notice Emitted when fee configuration changes\n  /// @param feeTo Recipient of government fees\n  /// @param governmentFeeUnits Fee amount, in fee units,\n  /// to be collected out of the fee charged for a pool swap\n  event FeeConfigurationUpdated(address feeTo, uint24 governmentFeeUnits);\n\n  /// @notice Emitted when whitelist feature is enabled\n  event WhitelistEnabled();\n\n  /// @notice Emitted when whitelist feature is disabled\n  event WhitelistDisabled();\n\n  /// @notice Returns the maximum time duration for which LP fees\n  /// are proportionally burnt upon LP removals\n  function vestingPeriod() external view returns (uint32);\n\n  /// @notice Returns the tick distance for a specified fee.\n  /// @dev Once added, cannot be updated or removed.\n  /// @param swapFeeUnits Swap fee, in fee units.\n  /// @return The tick distance. Returns 0 if fee has not been added.\n  function feeAmountTickDistance(uint24 swapFeeUnits) external view returns (int24);\n\n  /// @notice Returns the address which can update the fee configuration\n  function configMaster() external view returns (address);\n\n  /// @notice Returns the keccak256 hash of the Pool creation code\n  /// This is used for pre-computation of pool addresses\n  function poolInitHash() external view returns (bytes32);\n\n  /// @notice Returns the pool oracle contract for twap\n  function poolOracle() external view returns (address);\n\n  /// @notice Fetches the recipient of government fees\n  /// and current government fee charged in fee units\n  function feeConfiguration() external view returns (address _feeTo, uint24 _governmentFeeUnits);\n\n  /// @notice Returns the status of whitelisting feature of NFT managers\n  /// If true, anyone can mint liquidity tokens\n  /// Otherwise, only whitelisted NFT manager(s) are allowed to mint liquidity tokens\n  function whitelistDisabled() external view returns (bool);\n\n  //// @notice Returns all whitelisted NFT managers\n  /// If the whitelisting feature is turned on,\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\n  function getWhitelistedNFTManagers() external view returns (address[] memory);\n\n  /// @notice Checks if sender is a whitelisted NFT manager\n  /// If the whitelisting feature is turned on,\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\n  /// @param sender address to be checked\n  /// @return true if sender is a whistelisted NFT manager, false otherwise\n  function isWhitelistedNFTManager(address sender) external view returns (bool);\n\n  /// @notice Returns the pool address for a given pair of tokens and a swap fee\n  /// @dev Token order does not matter\n  /// @param tokenA Contract address of either token0 or token1\n  /// @param tokenB Contract address of the other token\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\n  /// @return pool The pool address. Returns null address if it does not exist\n  function getPool(\n    address tokenA,\n    address tokenB,\n    uint24 swapFeeUnits\n  ) external view returns (address pool);\n\n  /// @notice Fetch parameters to be used for pool creation\n  /// @dev Called by the pool constructor to fetch the parameters of the pool\n  /// @return factory The factory address\n  /// @return poolOracle The pool oracle for twap\n  /// @return token0 First pool token by address sort order\n  /// @return token1 Second pool token by address sort order\n  /// @return swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\n  /// @return tickDistance Minimum number of ticks between initialized ticks\n  function parameters()\n    external\n    view\n    returns (\n      address factory,\n      address poolOracle,\n      address token0,\n      address token1,\n      uint24 swapFeeUnits,\n      int24 tickDistance\n    );\n\n  /// @notice Creates a pool for the given two tokens and fee\n  /// @param tokenA One of the two tokens in the desired pool\n  /// @param tokenB The other of the two tokens in the desired pool\n  /// @param swapFeeUnits Desired swap fee for the pool, in fee units\n  /// @dev Token order does not matter. tickDistance is determined from the fee.\n  /// Call will revert under any of these conditions:\n  ///     1) pool already exists\n  ///     2) invalid swap fee\n  ///     3) invalid token arguments\n  /// @return pool The address of the newly created pool\n  function createPool(\n    address tokenA,\n    address tokenB,\n    uint24 swapFeeUnits\n  ) external returns (address pool);\n\n  /// @notice Enables a fee amount with the given tickDistance\n  /// @dev Fee amounts may never be removed once enabled\n  /// @param swapFeeUnits The fee amount to enable, in fee units\n  /// @param tickDistance The distance between ticks to be enforced for all pools created with the given fee amount\n  function enableSwapFee(uint24 swapFeeUnits, int24 tickDistance) external;\n\n  /// @notice Updates the address which can update the fee configuration\n  /// @dev Must be called by the current configMaster\n  function updateConfigMaster(address) external;\n\n  /// @notice Updates the vesting period\n  /// @dev Must be called by the current configMaster\n  function updateVestingPeriod(uint32) external;\n\n  /// @notice Updates the address receiving government fees and fee quantity\n  /// @dev Only configMaster is able to perform the update\n  /// @param feeTo Address to receive government fees collected from pools\n  /// @param governmentFeeUnits Fee amount, in fee units,\n  /// to be collected out of the fee charged for a pool swap\n  function updateFeeConfiguration(address feeTo, uint24 governmentFeeUnits) external;\n\n  /// @notice Enables the whitelisting feature\n  /// @dev Only configMaster is able to perform the update\n  function enableWhitelist() external;\n\n  /// @notice Disables the whitelisting feature\n  /// @dev Only configMaster is able to perform the update\n  function disableWhitelist() external;\n}\n"
    },
    "contracts/integrations/kyber/IKyberSwapElasticLM.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\n\ninterface IKyberSwapElasticLM {\n  struct RewardData {\n    address rewardToken;\n    uint256 rewardUnclaimed;\n  }\n\n  struct LMPoolInfo {\n    address poolAddress;\n    uint32 startTime;\n    uint32 endTime;\n    uint256 totalSecondsClaimed; // scaled by (1 << 96)\n    RewardData[] rewards;\n    uint256 feeTarget;\n    uint256 numStakes;\n  }\n\n  struct PositionInfo {\n    address owner;\n    uint256 liquidity;\n  }\n\n  struct StakeInfo {\n    uint128 secondsPerLiquidityLast;\n    uint256[] rewardLast;\n    uint256[] rewardPending;\n    uint256[] rewardHarvested;\n    int256 feeFirst;\n    uint256 liquidity;\n  }\n\n  // input data in harvestMultiplePools function\n  struct HarvestData {\n    uint256[] pIds;\n  }\n\n  // avoid stack too deep error\n  struct RewardCalculationData {\n    uint128 secondsPerLiquidityNow;\n    int256 feeNow;\n    uint256 vestingVolume;\n    uint256 totalSecondsUnclaimed;\n    uint256 secondsPerLiquidity;\n    uint256 secondsClaim; // scaled by (1 << 96)\n  }\n\n  // nftId => Position info\n  function positions(uint nftId) external view returns (PositionInfo memory);\n\n  function admin() external view returns(address);\n\n  /**\n   * @dev Add new pool to LM\n   * @param poolAddr pool address\n   * @param startTime start time of liquidity mining\n   * @param endTime end time of liquidity mining\n   * @param rewardTokens reward token list for pool\n   * @param rewardAmounts reward amount of list token\n   * @param feeTarget fee target for pool\n   *\n   */\n  function addPool(\n    address poolAddr,\n    uint32 startTime,\n    uint32 endTime,\n    address[] calldata rewardTokens,\n    uint256[] calldata rewardAmounts,\n    uint256 feeTarget\n  ) external;\n\n  /**\n   * @dev Renew a pool to start another LM program\n   * @param pId pool id to update\n   * @param startTime start time of liquidity mining\n   * @param endTime end time of liquidity mining\n   * @param rewardAmounts reward amount of list token\n   * @param feeTarget fee target for pool\n   *\n   */\n  function renewPool(\n    uint256 pId,\n    uint32 startTime,\n    uint32 endTime,\n    uint256[] calldata rewardAmounts,\n    uint256 feeTarget\n  ) external;\n\n  /**\n   * @dev Deposit NFT\n   * @param nftIds list nft id\n   *\n   */\n  function deposit(uint256[] calldata nftIds) external;\n\n  /**\n   * @dev Deposit NFTs into the pool and join farms if applicable\n   * @param pId pool id to join farm\n   * @param nftIds List of NFT ids from BasePositionManager, should match with the pId\n   *\n   */\n  function depositAndJoin(uint256 pId, uint256[] calldata nftIds) external;\n\n  /**\n   * @dev Withdraw NFT, must exit all pool before call.\n   * @param nftIds list nft id\n   *\n   */\n  function withdraw(uint256[] calldata nftIds) external;\n\n  /**\n   * @dev Join pools\n   * @param pId pool id to join\n   * @param nftIds nfts to join\n   * @param liqs list liquidity value to join each nft\n   *\n   */\n  function join(uint256 pId, uint256[] calldata nftIds, uint256[] calldata liqs) external;\n\n  /**\n   * @dev Exit from pools\n   * @param pId pool ids to exit\n   * @param nftIds list nfts id\n   * @param liqs list liquidity value to exit from each nft\n   *\n   */\n  function exit(uint256 pId, uint256[] calldata nftIds, uint256[] calldata liqs) external;\n\n  /**\n   * @dev Claim rewards for a list of pools for a list of nft positions\n   * @param nftIds List of NFT ids to harvest\n   * @param datas List of pool ids to harvest for each nftId, encoded into bytes\n   */\n  function harvestMultiplePools(uint256[] calldata nftIds, bytes[] calldata datas) external;\n\n  /**\n   * @dev remove liquidity from elastic for a list of nft position, also update on farm\n   * @param nftId to remove\n   * @param liquidity liquidity amount to remove from nft\n   * @param amount0Min expected min amount of token0 should receive\n   * @param amount1Min expected min amount of token1 should receive\n   * @param deadline deadline of this tx\n   * @param isReceiveNative should unwrap native or not\n   * @param claimFeeAndRewards also claim LP Fee and farm rewards\n   */\n  function removeLiquidity(\n    uint256 nftId,\n    uint128 liquidity,\n    uint256 amount0Min,\n    uint256 amount1Min,\n    uint256 deadline,\n    bool isReceiveNative,\n    bool[2] calldata claimFeeAndRewards\n  ) external;\n\n  /**\n   * @dev Claim fee from elastic for a list of nft positions\n   * @param nftIds List of NFT ids to claim\n   * @param amount0Min expected min amount of token0 should receive\n   * @param amount1Min expected min amount of token1 should receive\n   * @param poolAddress address of Elastic pool of those nfts\n   * @param isReceiveNative should unwrap native or not\n   * @param deadline deadline of this tx\n   */\n  function claimFee(\n    uint256[] calldata nftIds,\n    uint256 amount0Min,\n    uint256 amount1Min,\n    address poolAddress,\n    bool isReceiveNative,\n    uint256 deadline\n  ) external;\n\n  /**\n   * @dev Operator only. Call to withdraw all reward from list pools.\n   * @param rewards list reward address erc20 token\n   * @param amounts amount to withdraw\n   *\n   */\n  function emergencyWithdrawForOwner(\n    address[] calldata rewards,\n    uint256[] calldata amounts\n  ) external;\n\n  /**\n   * @dev Withdraw NFT, can call any time, reward will be reset. Must enable this func by operator\n   * @param pIds list pool to withdraw\n   *\n   */\n  function emergencyWithdraw(uint256[] calldata pIds) external;\n\n  /**\n   * @dev get list of pool that this nft joined\n   * @param nftId to get\n   */\n  function getJoinedPools(uint256 nftId) external view returns (uint256[] memory poolIds);\n\n  /**\n   * @dev get list of pool that this nft joined, only in a specific range\n   * @param nftId to get\n   * @param fromIndex index from\n   * @param toIndex index to\n   */\n  function getJoinedPoolsInRange(\n    uint256 nftId,\n    uint256 fromIndex,\n    uint256 toIndex\n  ) external view returns (uint256[] memory poolIds);\n\n  /**\n   * @dev get user's info (staked info) of a nft in a pool\n   * @param nftId to get\n   * @param pId to get\n   */\n  function getUserInfo(\n    uint256 nftId,\n    uint256 pId\n  )\n  external\n  view\n  returns (uint256 liquidity, uint256[] memory rewardPending, uint256[] memory rewardLast);\n\n  /**\n   * @dev get pool info\n   * @param pId to get\n   */\n  function getPoolInfo(\n    uint256 pId\n  )\n  external\n  view\n  returns (\n    address poolAddress,\n    uint32 startTime,\n    uint32 endTime,\n    uint256 totalSecondsClaimed,\n    uint256 feeTarget,\n    uint256 numStakes,\n  //index reward => reward data\n    address[] memory rewardTokens,\n    uint256[] memory rewardUnclaimeds\n  );\n\n  /**\n   * @dev get list of deposited nfts of an address\n   * @param user address of user to get\n   */\n  function getDepositedNFTs(address user) external view returns (uint256[] memory listNFTs);\n\n  function nft() external view returns (IERC721);\n\n  function poolLength() external view returns (uint256);\n\n  function getRewardCalculationData(\n    uint256 nftId,\n    uint256 pId\n  ) external view returns (RewardCalculationData memory data);\n}\n"
    },
    "contracts/integrations/kyber/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IPoolActions} from './pool/IPoolActions.sol';\nimport {IPoolEvents} from './pool/IPoolEvents.sol';\nimport {IPoolStorage} from './pool/IPoolStorage.sol';\n\ninterface IPool is IPoolActions, IPoolEvents, IPoolStorage {}\n"
    },
    "contracts/integrations/kyber/IRouterTokenHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.8.0;\n\ninterface IRouterTokenHelper {\n  /// @notice Unwraps the contract's WETH balance and sends it to recipient as ETH.\n  /// @dev The minAmount parameter prevents malicious contracts from stealing WETH from users.\n  /// @param minAmount The minimum amount of WETH to unwrap\n  /// @param recipient The address receiving ETH\n  function unwrapWeth(uint256 minAmount, address recipient) external payable;\n\n  /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n  /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n  /// that use ether for the input amount\n  function refundEth() external payable;\n\n  /// @notice Transfers the full amount of a token held by this contract to recipient\n  /// @dev The minAmount parameter prevents malicious contracts from stealing the token from users\n  /// @param token The contract address of the token which will be transferred to `recipient`\n  /// @param minAmount The minimum amount of token required for a transfer\n  /// @param recipient The destination address of the token\n  function transferAllTokens(\n    address token,\n    uint256 minAmount,\n    address recipient\n  ) external payable;\n}\n"
    },
    "contracts/integrations/kyber/ITicksFeesReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface ITicksFeesReader {\n  function getTotalFeesOwedToPosition(\n    address posManager,\n    address pool,\n    uint256 tokenId\n  ) external view returns (uint256 token0Owed, uint256 token1Owed);\n}\n"
    },
    "contracts/integrations/kyber/oracle/IPoolOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IPoolOracle {\n  /// @notice Owner withdrew funds in the pool oracle in case some funds are stuck there\n  event OwnerWithdrew(\n    address indexed owner,\n    address indexed token,\n    uint256 indexed amount\n  );\n\n  /// @notice Emitted by the Pool Oracle for increases to the number of observations that can be stored\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n  /// just before a mint/swap/burn.\n  /// @param pool The pool address to update\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(\n    address pool,\n    uint16 observationCardinalityNextOld,\n    uint16 observationCardinalityNextNew\n  );\n\n  /// @notice Initalize observation data for the caller.\n  function initializeOracle(uint32 time)\n    external\n    returns (uint16 cardinality, uint16 cardinalityNext);\n\n  /// @notice Write a new oracle entry into the array\n  ///   and update the observation index and cardinality\n  /// Read the Oralce.write function for more details\n  function writeNewEntry(\n    uint16 index,\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity,\n    uint16 cardinality,\n    uint16 cardinalityNext\n  )\n    external\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated);\n\n  /// @notice Write a new oracle entry into the array, take the latest observaion data as inputs\n  ///   and update the observation index and cardinality\n  /// Read the Oralce.write function for more details\n  function write(\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity\n  )\n    external\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated);\n\n  /// @notice Increase the maximum number of price observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param pool The pool address to be updated\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(\n    address pool,\n    uint16 observationCardinalityNext\n  )\n    external;\n\n  /// @notice Returns the accumulator values as of each time seconds ago from the latest block time in the array of `secondsAgos`\n  /// @dev Reverts if `secondsAgos` > oldest observation\n  /// @dev It fetches the latest current tick data from the pool\n  /// Read the Oracle.observe function for more details\n  function observeFromPool(\n    address pool,\n    uint32[] memory secondsAgos\n  )\n    external view\n    returns (int56[] memory tickCumulatives);\n\n  /// @notice Returns the accumulator values as the time seconds ago from the latest block time of secondsAgo\n  /// @dev Reverts if `secondsAgo` > oldest observation\n  /// @dev It fetches the latest current tick data from the pool\n  /// Read the Oracle.observeSingle function for more details\n  function observeSingleFromPool(\n    address pool,\n    uint32 secondsAgo\n  )\n    external view\n    returns (int56 tickCumulative);\n\n  /// @notice Return the latest pool observation data given the pool address\n  function getPoolObservation(address pool)\n    external view\n    returns (bool initialized, uint16 index, uint16 cardinality, uint16 cardinalityNext);\n\n  /// @notice Returns data about a specific observation index\n  /// @param pool The pool address of the observations array to fetch\n  /// @param index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return blockTimestamp The timestamp of the observation,\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\n  function getObservationAt(address pool, uint256 index)\n    external view\n    returns (\n      uint32 blockTimestamp,\n      int56 tickCumulative,\n      bool initialized\n    );\n}\n"
    },
    "contracts/integrations/kyber/pool/IPoolActions.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IPoolActions {\n  /// @notice Sets the initial price for the pool and seeds reinvestment liquidity\n  /// @dev Assumes the caller has sent the necessary token amounts\n  /// required for initializing reinvestment liquidity prior to calling this function\n  /// @param initialSqrtP the initial sqrt price of the pool\n  /// @param qty0 token0 quantity sent to and locked permanently in the pool\n  /// @param qty1 token1 quantity sent to and locked permanently in the pool\n  function unlockPool(uint160 initialSqrtP) external returns (uint256 qty0, uint256 qty1);\n\n  /// @notice Adds liquidity for the specified recipient/tickLower/tickUpper position\n  /// @dev Any token0 or token1 owed for the liquidity provision have to be paid for when\n  /// the IMintCallback#mintCallback is called to this method's caller\n  /// The quantity of token0/token1 to be sent depends on\n  /// tickLower, tickUpper, the amount of liquidity, and the current price of the pool.\n  /// Also sends reinvestment tokens (fees) to the recipient for any fees collected\n  /// while the position is in range\n  /// Reinvestment tokens have to be burnt via #burnRTokens in exchange for token0 and token1\n  /// @param recipient Address for which the added liquidity is credited to\n  /// @param tickLower Recipient position's lower tick\n  /// @param tickUpper Recipient position's upper tick\n  /// @param ticksPrevious The nearest tick that is initialized and <= the lower & upper ticks\n  /// @param qty Liquidity quantity to mint\n  /// @param data Data (if any) to be passed through to the callback\n  /// @return qty0 token0 quantity sent to the pool in exchange for the minted liquidity\n  /// @return qty1 token1 quantity sent to the pool in exchange for the minted liquidity\n  /// @return feeGrowthInside position's updated feeGrowthInside value\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    int24[2] calldata ticksPrevious,\n    uint128 qty,\n    bytes calldata data\n  )\n    external\n    returns (\n      uint256 qty0,\n      uint256 qty1,\n      uint256 feeGrowthInside\n    );\n\n  /// @notice Remove liquidity from the caller\n  /// Also sends reinvestment tokens (fees) to the caller for any fees collected\n  /// while the position is in range\n  /// Reinvestment tokens have to be burnt via #burnRTokens in exchange for token0 and token1\n  /// @param tickLower Position's lower tick for which to burn liquidity\n  /// @param tickUpper Position's upper tick for which to burn liquidity\n  /// @param qty Liquidity quantity to burn\n  /// @return qty0 token0 quantity sent to the caller\n  /// @return qty1 token1 quantity sent to the caller\n  /// @return feeGrowthInside position's updated feeGrowthInside value\n  function burn(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 qty\n  )\n    external\n    returns (\n      uint256 qty0,\n      uint256 qty1,\n      uint256 feeGrowthInside\n    );\n\n  /// @notice Burns reinvestment tokens in exchange to receive the fees collected in token0 and token1\n  /// @param qty Reinvestment token quantity to burn\n  /// @param isLogicalBurn true if burning rTokens without returning any token0/token1\n  ///         otherwise should transfer token0/token1 to sender\n  /// @return qty0 token0 quantity sent to the caller for burnt reinvestment tokens\n  /// @return qty1 token1 quantity sent to the caller for burnt reinvestment tokens\n  function burnRTokens(uint256 qty, bool isLogicalBurn)\n    external\n    returns (uint256 qty0, uint256 qty1);\n\n  /// @notice Swap token0 -> token1, or vice versa\n  /// @dev This method's caller receives a callback in the form of ISwapCallback#swapCallback\n  /// @dev swaps will execute up to limitSqrtP or swapQty is fully used\n  /// @param recipient The address to receive the swap output\n  /// @param swapQty The swap quantity, which implicitly configures the swap as exact input (>0), or exact output (<0)\n  /// @param isToken0 Whether the swapQty is specified in token0 (true) or token1 (false)\n  /// @param limitSqrtP the limit of sqrt price after swapping\n  /// could be MAX_SQRT_RATIO-1 when swapping 1 -> 0 and MIN_SQRT_RATIO+1 when swapping 0 -> 1 for no limit swap\n  /// @param data Any data to be passed through to the callback\n  /// @return qty0 Exact token0 qty sent to recipient if < 0. Minimally received quantity if > 0.\n  /// @return qty1 Exact token1 qty sent to recipient if < 0. Minimally received quantity if > 0.\n  function swap(\n    address recipient,\n    int256 swapQty,\n    bool isToken0,\n    uint160 limitSqrtP,\n    bytes calldata data\n  ) external returns (int256 qty0, int256 qty1);\n\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n  /// @dev The caller of this method receives a callback in the form of IFlashCallback#flashCallback\n  /// @dev Fees collected are sent to the feeTo address if it is set in Factory\n  /// @param recipient The address which will receive the token0 and token1 quantities\n  /// @param qty0 token0 quantity to be loaned to the recipient\n  /// @param qty1 token1 quantity to be loaned to the recipient\n  /// @param data Any data to be passed through to the callback\n  function flash(\n    address recipient,\n    uint256 qty0,\n    uint256 qty1,\n    bytes calldata data\n  ) external;\n\n\n  /// @notice sync fee of position\n  /// @param tickLower Position's lower tick\n  /// @param tickUpper Position's upper tick\n  function tweakPosZeroLiq(int24 tickLower, int24 tickUpper)\n    external returns(uint256 feeGrowthInsideLast);\n}\n"
    },
    "contracts/integrations/kyber/pool/IPoolEvents.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\ninterface IPoolEvents {\n  /// @notice Emitted only once per pool when #initialize is first called\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n  /// @param sqrtP The initial price of the pool\n  /// @param tick The initial tick of the pool\n  event Initialize(uint160 sqrtP, int24 tick);\n\n  /// @notice Emitted when liquidity is minted for a given position\n  /// @dev transfers reinvestment tokens for any collected fees earned by the position\n  /// @param sender address that minted the liquidity\n  /// @param owner address of owner of the position\n  /// @param tickLower position's lower tick\n  /// @param tickUpper position's upper tick\n  /// @param qty liquidity minted to the position range\n  /// @param qty0 token0 quantity needed to mint the liquidity\n  /// @param qty1 token1 quantity needed to mint the liquidity\n  event Mint(\n    address sender,\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 qty,\n    uint256 qty0,\n    uint256 qty1\n  );\n\n  /// @notice Emitted when a position's liquidity is removed\n  /// @dev transfers reinvestment tokens for any collected fees earned by the position\n  /// @param owner address of owner of the position\n  /// @param tickLower position's lower tick\n  /// @param tickUpper position's upper tick\n  /// @param qty liquidity removed\n  /// @param qty0 token0 quantity withdrawn from removal of liquidity\n  /// @param qty1 token1 quantity withdrawn from removal of liquidity\n  event Burn(\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 qty,\n    uint256 qty0,\n    uint256 qty1\n  );\n\n  /// @notice Emitted when reinvestment tokens are burnt\n  /// @param owner address which burnt the reinvestment tokens\n  /// @param qty reinvestment token quantity burnt\n  /// @param qty0 token0 quantity sent to owner for burning reinvestment tokens\n  /// @param qty1 token1 quantity sent to owner for burning reinvestment tokens\n  event BurnRTokens(address indexed owner, uint256 qty, uint256 qty0, uint256 qty1);\n\n  /// @notice Emitted for swaps by the pool between token0 and token1\n  /// @param sender Address that initiated the swap call, and that received the callback\n  /// @param recipient Address that received the swap output\n  /// @param deltaQty0 Change in pool's token0 balance\n  /// @param deltaQty1 Change in pool's token1 balance\n  /// @param sqrtP Pool's sqrt price after the swap\n  /// @param liquidity Pool's liquidity after the swap\n  /// @param currentTick Log base 1.0001 of pool's price after the swap\n  event Swap(\n    address indexed sender,\n    address indexed recipient,\n    int256 deltaQty0,\n    int256 deltaQty1,\n    uint160 sqrtP,\n    uint128 liquidity,\n    int24 currentTick\n  );\n\n  /// @notice Emitted by the pool for any flash loans of token0/token1\n  /// @param sender The address that initiated the flash loan, and that received the callback\n  /// @param recipient The address that received the flash loan quantities\n  /// @param qty0 token0 quantity loaned to the recipient\n  /// @param qty1 token1 quantity loaned to the recipient\n  /// @param paid0 token0 quantity paid for the flash, which can exceed qty0 + fee\n  /// @param paid1 token1 quantity paid for the flash, which can exceed qty0 + fee\n  event Flash(\n    address indexed sender,\n    address indexed recipient,\n    uint256 qty0,\n    uint256 qty1,\n    uint256 paid0,\n    uint256 paid1\n  );\n}\n"
    },
    "contracts/integrations/kyber/pool/IPoolStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0;\n\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\n\nimport {IFactory} from '../IFactory.sol';\nimport {IPoolOracle} from '../oracle/IPoolOracle.sol';\n\ninterface IPoolStorage {\n  /// @notice The contract that deployed the pool, which must adhere to the IFactory interface\n  /// @return The contract address\n  function factory() external view returns (IFactory);\n\n  /// @notice The oracle contract that stores necessary data for price oracle\n  /// @return The contract address\n  function poolOracle() external view returns (IPoolOracle);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (IERC20);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (IERC20);\n\n  /// @notice The fee to be charged for a swap in basis points\n  /// @return The swap fee in basis points\n  function swapFeeUnits() external view returns (uint24);\n\n  /// @notice The pool tick distance\n  /// @dev Ticks can only be initialized and used at multiples of this value\n  /// It remains an int24 to avoid casting even though it is >= 1.\n  /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\n  /// @return The tick distance\n  function tickDistance() external view returns (int24);\n\n  /// @notice Maximum gross liquidity that an initialized tick can have\n  /// @dev This is to prevent overflow the pool's active base liquidity (uint128)\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxTickLiquidity() external view returns (uint128);\n\n  /// @notice Look up information about a specific tick in the pool\n  /// @param tick The tick to look up\n  /// @return liquidityGross total liquidity amount from positions that uses this tick as a lower or upper tick\n  /// liquidityNet how much liquidity changes when the pool tick crosses above the tick\n  /// feeGrowthOutside the fee growth on the other side of the tick relative to the current tick\n  /// secondsPerLiquidityOutside the seconds per unit of liquidity  spent on the other side of the tick relative to the current tick\n  function ticks(int24 tick)\n    external\n    view\n    returns (\n      uint128 liquidityGross,\n      int128 liquidityNet,\n      uint256 feeGrowthOutside,\n      uint128 secondsPerLiquidityOutside\n    );\n\n  /// @notice Returns the previous and next initialized ticks of a specific tick\n  /// @dev If specified tick is uninitialized, the returned values are zero.\n  /// @param tick The tick to look up\n  function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\n\n  /// @notice Returns the information about a position by the position's key\n  /// @return liquidity the liquidity quantity of the position\n  /// @return feeGrowthInsideLast fee growth inside the tick range as of the last mint / burn action performed\n  function getPositions(\n    address owner,\n    int24 tickLower,\n    int24 tickUpper\n  ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\n\n  /// @notice Fetches the pool's prices, ticks and lock status\n  /// @return sqrtP sqrt of current price: sqrt(token1/token0)\n  /// @return currentTick pool's current tick\n  /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\n  /// @return locked true if pool is locked, false otherwise\n  function getPoolState()\n    external\n    view\n    returns (\n      uint160 sqrtP,\n      int24 currentTick,\n      int24 nearestCurrentTick,\n      bool locked\n    );\n\n  /// @notice Fetches the pool's liquidity values\n  /// @return baseL pool's base liquidity without reinvest liqudity\n  /// @return reinvestL the liquidity is reinvested into the pool\n  /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\n  function getLiquidityState()\n    external\n    view\n    returns (\n      uint128 baseL,\n      uint128 reinvestL,\n      uint128 reinvestLLast\n    );\n\n  /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\n  function getFeeGrowthGlobal() external view returns (uint256);\n\n  /// @return secondsPerLiquidityGlobal All-time seconds per unit of liquidity of the pool\n  /// @return lastUpdateTime The timestamp in which secondsPerLiquidityGlobal was last updated\n  function getSecondsPerLiquidityData()\n    external\n    view\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\n\n  /// @notice Calculates and returns the active time per unit of liquidity until current block.timestamp\n  /// @param tickLower The lower tick (of a position)\n  /// @param tickUpper The upper tick (of a position)\n  /// @return secondsPerLiquidityInside active time (multiplied by 2^96)\n  /// between the 2 ticks, per unit of liquidity.\n  function getSecondsPerLiquidityInside(int24 tickLower, int24 tickUpper)\n    external\n    view\n    returns (uint128 secondsPerLiquidityInside);\n}\n"
    },
    "contracts/interfaces/IFarmingStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IFarmingStrategy {\n  function canFarm() external view returns (bool);\n}\n"
    },
    "contracts/interfaces/IRebalancingStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IRebalancingStrategy {\n    function needRebalance() external view returns (bool);\n    function rebalance() external;\n}\n"
    },
    "contracts/libs/AppErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice List of all errors generated by the application\n///         Each error should have unique code TS-XXX and descriptive comment\nlibrary AppErrors {\n  /// @notice Provided address should be not zero\n  string public constant ZERO_ADDRESS = \"TS-1 zero address\";\n\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\n  string public constant UNISWAP_PAIR_NOT_FOUND = \"TS-2 pair not found\";\n\n  /// @notice Lengths not matched\n  string public constant WRONG_LENGTHS = \"TS-4 wrong lengths\";\n\n  /// @notice Unexpected zero balance\n  string public constant ZERO_BALANCE = \"TS-5 zero balance\";\n\n  string public constant ITEM_NOT_FOUND = \"TS-6 not found\";\n\n  string public constant NOT_ENOUGH_BALANCE = \"TS-7 not enough balance\";\n\n  /// @notice Price oracle returns zero price\n  string public constant ZERO_PRICE = \"TS-8 zero price\";\n\n  string public constant WRONG_VALUE = \"TS-9 wrong value\";\n\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\n  string public constant ZERO_AMOUNT_BORROWED = \"TS-10 zero borrowed amount\";\n\n  string public constant WITHDRAW_TOO_MUCH = \"TS-11 try to withdraw too much\";\n\n  string public constant UNKNOWN_ENTRY_KIND = \"TS-12 unknown entry kind\";\n\n  string public constant ONLY_TETU_CONVERTER = \"TS-13 only TetuConverter\";\n\n  string public constant WRONG_ASSET = \"TS-14 wrong asset\";\n\n  string public constant NO_LIQUIDATION_ROUTE = \"TS-15 No liquidation route\";\n\n  string public constant PRICE_IMPACT = \"TS-16 price impact\";\n\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\n  string public constant REPAY_MAKES_SWAP = \"TS-17 can not convert back\";\n\n  string public constant NO_INVESTMENTS = \"TS-18 no investments\";\n\n  string public constant INCORRECT_LENGTHS = \"TS-19 lengths\";\n\n  /// @notice We expect increasing of the balance, but it was decreased\n  string public constant BALANCE_DECREASE = \"TS-20 balance decrease\";\n\n  /// @notice Prices changed and invested assets amount was increased on S, value of S is too high\n  string public constant EARNED_AMOUNT_TOO_HIGH = \"TS-21 earned too high\";\n\n  string public constant GOVERNANCE_ONLY = \"TS-22 governance only\";\n}\n"
    },
    "contracts/libs/AppLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\n/// @notice Common internal utils\nlibrary AppLib {\n  using SafeERC20 for IERC20;\n\n  /// @notice Unchecked increment for for-cycles\n  function uncheckedInc(uint i) internal pure returns (uint) {\n    unchecked {\n      return i + 1;\n    }\n  }\n\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\n  /// @dev Should NOT be used for third-party pools\n  function approveIfNeeded(address token, uint amount, address spender) internal {\n    if (IERC20(token).allowance(address(this), spender) < amount) {\n      IERC20(token).safeApprove(spender, 0);\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\n      IERC20(token).safeApprove(spender, 2 ** 255);\n    }\n  }\n\n  function balance(address token) internal view returns (uint) {\n    return IERC20(token).balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/libs/AppPlatforms.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary AppPlatforms {\n  string public constant UNIV3 = \"UniswapV3\";\n  string public constant BALANCER = \"Balancer\";\n  string public constant ALGEBRA = \"Algebra\";\n  string public constant KYBER = \"Kyber\";\n}\n"
    },
    "contracts/libs/ConverterEntryKinds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\nlibrary ConverterEntryKinds {\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\n\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\n  ///         C2 should be used as collateral to make a borrow B.\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\n\n  /// @notice Borrow given amount using min possible collateral\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\n\n  /// @notice Decode entryData, extract first uint - entry kind\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\n    if (entryData_.length == 0) {\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\n    }\n    return abi.decode(entryData_, (uint));\n  }\n}\n"
    },
    "contracts/libs/TokenAmountsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AppErrors.sol\";\n\n/// @title Library for clearing / joining token addresses & amounts arrays\n/// @author bogdoslav\nlibrary TokenAmountsLib {\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \"1.0.1\";\n\n  function uncheckedInc(uint i) internal pure returns (uint) {\n    unchecked {\n      return i + 1;\n    }\n  }\n\n  function filterZeroAmounts(\n    address[] memory tokens,\n    uint[] memory amounts\n  ) internal pure returns (\n    address[] memory t,\n    uint[] memory a\n  ) {\n    require(tokens.length == amounts.length, AppErrors.INCORRECT_LENGTHS);\n    uint len2 = 0;\n    uint len = tokens.length;\n    for (uint i = 0; i < len; i++) {\n      if (amounts[i] != 0) len2++;\n    }\n\n    t = new address[](len2);\n    a = new uint[](len2);\n\n    uint j = 0;\n    for (uint i = 0; i < len; i++) {\n      uint amount = amounts[i];\n      if (amount != 0) {\n        t[j] = tokens[i];\n        a[j] = amount;\n        j++;\n      }\n    }\n  }\n\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\n  function combineArrays(\n    address[] memory tokens0,\n    uint[] memory amounts0,\n    address[] memory tokens1,\n    uint[] memory amounts1,\n    address[] memory tokens2,\n    uint[] memory amounts2\n  ) internal pure returns (\n    address[] memory allTokens,\n    uint[] memory allAmounts\n  ) {\n    uint[] memory lens = new uint[](3);\n    lens[0] = tokens0.length;\n    lens[1] = tokens1.length;\n    lens[2] = tokens2.length;\n\n    require(\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\n      AppErrors.INCORRECT_LENGTHS\n    );\n\n    uint maxLength = lens[0] + lens[1] + lens[2];\n    address[] memory tokensOut = new address[](maxLength);\n    uint[] memory amountsOut = new uint[](maxLength);\n    uint unitedLength;\n\n    for (uint step; step < 3; ++step) {\n      uint[] memory amounts = step == 0\n        ? amounts0\n        : (step == 1\n          ? amounts1\n          : amounts2);\n      address[] memory tokens = step == 0\n        ? tokens0\n        : (step == 1\n          ? tokens1\n          : tokens2);\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\n        uint amount1 = amounts[i1];\n        address token1 = tokens[i1];\n        bool united = false;\n\n        for (uint i = 0; i < unitedLength; i++) {\n          if (token1 == tokensOut[i]) {\n            amountsOut[i] += amount1;\n            united = true;\n            break;\n          }\n        }\n\n        if (!united) {\n          tokensOut[unitedLength] = token1;\n          amountsOut[unitedLength] = amount1;\n          unitedLength++;\n        }\n      }\n    }\n\n    // copy united tokens to result array\n    allTokens = new address[](unitedLength);\n    allAmounts = new uint[](unitedLength);\n    for (uint i; i < unitedLength; i++) {\n      allTokens[i] = tokensOut[i];\n      allAmounts[i] = amountsOut[i];\n    }\n\n  }\n}\n"
    },
    "contracts/strategies/ConverterStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\";\nimport \"./ConverterStrategyBaseLib.sol\";\nimport \"./ConverterStrategyBaseLib2.sol\";\nimport \"./DepositorBase.sol\";\n\n/////////////////////////////////////////////////////////////////////\n///                        TERMS\n///  Main asset == underlying: the asset deposited to the vault by users\n///  Secondary assets: all assets deposited to the internal pool except the main asset\n/////////////////////////////////////////////////////////////////////\n\n/// @title Abstract contract for base Converter strategy functionality\n/// @notice All depositor assets must be correlated (ie USDC/USDT/DAI)\n/// @author bogdoslav, dvpublic\nabstract contract ConverterStrategyBase is ITetuConverterCallback, DepositorBase, StrategyBaseV2 {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  //region DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n\n  struct WithdrawUniversalLocal {\n    bool all;\n    uint[] reservesBeforeWithdraw;\n    uint totalSupplyBeforeWithdraw;\n    uint depositorLiquidity;\n    uint liquidityAmountToWithdraw;\n    uint assetPrice;\n    uint[] amountsToConvert;\n    uint expectedTotalMainAssetAmount;\n    uint[] expectedMainAssetAmounts;\n    uint investedAssetsAfterWithdraw;\n    uint balanceAfterWithdraw;\n    address[] tokens;\n    address asset;\n    uint indexAsset;\n    uint balanceBefore;\n    uint[] withdrawnAmounts;\n    ITetuConverter converter;\n  }\n  //endregion DATA TYPES\n\n  /////////////////////////////////////////////////////////////////////\n  //region CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant CONVERTER_STRATEGY_BASE_VERSION = \"1.2.0\";\n\n  /// @notice 1% gap to cover possible liquidation inefficiency\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\n  uint internal constant GAP_CONVERSION = 1_000;\n  uint internal constant DENOMINATOR = 100_000;\n  //endregion CONSTANTS\n\n  /////////////////////////////////////////////////////////////////////\n  //region VARIABLES\n  //                Keep names and ordering!\n  // Add only in the bottom and don't forget to decrease gap variable\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Amount of underlying assets invested to the pool.\n  uint internal _investedAssets;\n\n  /// @dev Linked Tetu Converter\n  ITetuConverter public converter;\n\n  /// @notice Minimum token amounts that can be liquidated\n  mapping(address => uint) public liquidationThresholds;\n\n  /// @notice Percent of asset amount that can be not invested, it's allowed to just keep it on balance\n  ///         decimals = {DENOMINATOR}\n  /// @dev We need this threshold to avoid numerous conversions of small amounts\n  uint public reinvestThresholdPercent;\n\n  /// @notice Ratio to split performance fee on toPerf + toInsurance, [0..100_000]\n  ///         100_000 - send full amount toPerf, 0 - send full amount toInsurance.\n  uint public performanceFeeRatio;\n  //endregion VARIABLES\n\n  /////////////////////////////////////////////////////////////////////\n  //region Events\n  /////////////////////////////////////////////////////////////////////\n  event OnDepositorEnter(uint[] amounts, uint[] consumedAmounts);\n  event OnDepositorExit(uint liquidityAmount, uint[] withdrawnAmounts);\n  event OnDepositorEmergencyExit(uint[] withdrawnAmounts);\n  event OnHardWorkEarnedLost(\n    uint investedAssetsNewPrices,\n    uint earnedByPrices,\n    uint earnedHandleRewards,\n    uint lostHandleRewards,\n    uint earnedDeposit,\n    uint lostDeposit\n  );\n\n  /// @notice Recycle was made\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\n  /// @param amountsToForward Amounts to be sent to forwarder\n  event Recycle(\n    address[] rewardTokens,\n    uint[] amountsToForward,\n    uint toPerf,\n    uint toInsurance\n  );\n  //endregion Events\n\n  /////////////////////////////////////////////////////////////////////\n  //region Initialization and configuration\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __ConverterStrategyBase_init(\n    address controller_,\n    address splitter_,\n    address converter_\n  ) internal onlyInitializing {\n    __StrategyBase_init(controller_, splitter_);\n    converter = ITetuConverter(converter_);\n\n    // 1% by default\n    reinvestThresholdPercent = DENOMINATOR / 100;\n    emit ConverterStrategyBaseLib2.ReinvestThresholdPercentChanged(DENOMINATOR / 100);\n  }\n\n  function setLiquidationThreshold(address token, uint amount) external {\n    ConverterStrategyBaseLib2.checkLiquidationThresholdChanged(controller(), token, amount);\n    liquidationThresholds[token] = amount;\n  }\n\n  /// @param percent_ New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\n  function setReinvestThresholdPercent(uint percent_) external {\n    ConverterStrategyBaseLib2.checkReinvestThresholdPercentChanged(controller(), percent_);\n    reinvestThresholdPercent = percent_;\n  }\n\n  /// @notice [0..100_000], 100_000 - send full amount toPerf, 0 - send full amount toInsurance.\n  function setPerformanceFeeRatio(uint ratio_) external {\n    ConverterStrategyBaseLib2.checkPerformanceFeeRatioChanged(controller(), ratio_);\n    performanceFeeRatio = ratio_;\n  }\n  //endregion Initialization and configuration\n\n  /////////////////////////////////////////////////////////////////////\n  //region Deposit to the pool\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Amount of underlying assets converted to pool assets and invested to the pool.\n  function investedAssets() override public view virtual returns (uint) {\n    return _investedAssets;\n  }\n\n  /// @notice Deposit given amount to the pool.\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    uint strategyLoss\n  ){\n    (uint updatedInvestedAssets, uint earnedByPrices) = _fixPriceChanges(updateTotalAssetsBeforeInvest_);\n    (strategyLoss,) = _depositToPoolUniversal(amount_, earnedByPrices, updatedInvestedAssets);\n  }\n\n  /// @notice Deposit {amount_} to the pool, send {earnedByPrices_} to insurance.\n  ///         totalAsset will decrease on earnedByPrices_ and sharePrice won't change after all recalculations.\n  /// @dev We need to deposit {amount_} and withdraw {earnedByPrices_} here\n  /// @param amount_ Amount of underlying to be deposited\n  /// @param earnedByPrices_ Profit received because of price changing\n  /// @param investedAssets_ Invested assets value calculated with updated prices\n  /// @return strategyLoss Loss happened on the depositing. It doesn't include any price-changing losses\n  /// @return amountSentToInsurance Price-changing-profit that was sent to the insurance\n  function _depositToPoolUniversal(uint amount_, uint earnedByPrices_, uint investedAssets_) internal virtual returns (\n    uint strategyLoss,\n    uint amountSentToInsurance\n  ){\n    address _asset = asset;\n\n    uint amountToDeposit = amount_ > earnedByPrices_\n      ? amount_ - earnedByPrices_\n      : 0;\n\n    // skip deposit for small amounts\n    if (amountToDeposit > reinvestThresholdPercent * investedAssets_ / DENOMINATOR) {\n      if (earnedByPrices_ != 0) {\n        amountSentToInsurance = ConverterStrategyBaseLib2.sendToInsurance(\n          _asset,\n          earnedByPrices_,\n          splitter,\n          investedAssets_ + AppLib.balance(_asset)\n        );\n      }\n      uint balanceBefore = AppLib.balance(_asset);\n\n      (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n\n      // prepare array of amounts ready to deposit, borrow missed amounts\n      uint[] memory amounts = _beforeDeposit(converter, amountToDeposit, tokens, indexAsset);\n\n      // make deposit, actually consumed amounts can be different from the desired amounts\n      (uint[] memory consumedAmounts,) = _depositorEnter(amounts);\n      emit OnDepositorEnter(amounts, consumedAmounts);\n\n      // update _investedAssets with new deposited amount\n      uint updatedInvestedAssetsAfterDeposit = _updateInvestedAssets();\n      // after deposit some asset can exist\n      uint balanceAfter = AppLib.balance(_asset);\n      // we need to compensate difference if during deposit we lost some assets\n      if ((updatedInvestedAssetsAfterDeposit + balanceAfter) < (investedAssets_ + balanceBefore)) {\n        strategyLoss = (investedAssets_ + balanceBefore) - (updatedInvestedAssetsAfterDeposit + balanceAfter);\n      }\n    } else if (earnedByPrices_ != 0) {\n      // we just skip check of expectedWithdrewUSD here\n      uint balance = AppLib.balance(_asset);\n      if (balance < earnedByPrices_) {\n        (/* expectedWithdrewUSD */,, strategyLoss, amountSentToInsurance) = _withdrawUniversal(0, earnedByPrices_, investedAssets_);\n      } else {\n        amountSentToInsurance = ConverterStrategyBaseLib2.sendToInsurance(\n          _asset,\n          earnedByPrices_,\n          splitter,\n          investedAssets_ + balance\n        );\n      }\n    }\n\n    return (strategyLoss, amountSentToInsurance);\n  }\n  //endregion Deposit to the pool\n\n  /////////////////////////////////////////////////////////////////////\n  //region Convert amounts before deposit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Prepare {tokenAmounts} to be passed to depositorEnter\n  /// @dev Override this function to customize entry kind\n  /// @param amount_ The amount of main asset that should be invested\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return tokenAmounts Amounts of depositor's assets ready to invest (this array can be passed to depositorEnter)\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) internal virtual returns (\n    uint[] memory tokenAmounts\n  ) {\n    // calculate required collaterals for each token and temporary save them to tokenAmounts\n    (uint[] memory weights, uint totalWeight) = _depositorPoolWeights();\n\n    // temporary save collateral to tokensAmounts\n    tokenAmounts = ConverterStrategyBaseLib2.getCollaterals(\n      amount_,\n      tokens_,\n      weights,\n      totalWeight,\n      indexAsset_,\n      IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle())\n    );\n\n    // make borrow and save amounts of tokens available for deposit to tokenAmounts, zero result amounts are possible\n    tokenAmounts = ConverterStrategyBaseLib.getTokenAmounts(\n      tetuConverter_,\n      tokens_,\n      indexAsset_,\n      tokenAmounts,\n      liquidationThresholds[tokens_[indexAsset_]]\n    );\n  }\n  //endregion Convert amounts before deposit\n\n  /////////////////////////////////////////////////////////////////////\n  //region Withdraw from the pool\n  /////////////////////////////////////////////////////////////////////\n\n  function _beforeWithdraw(uint /*amount*/) internal virtual {\n    // do nothing\n  }\n\n  /// @notice Withdraw given amount from the pool.\n  /// @param amount Amount to be withdrawn in terms of the asset in addition to the exist balance.\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing (in USD, decimals of the {asset})\n  /// @return assetPrice Price of the {asset} from the price oracle\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawFromPool(uint amount) override internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  ) {\n    // calculate profit/loss because of price changes, try to compensate the loss from the insurance\n    (uint investedAssetsNewPrices, uint earnedByPrices) = _fixPriceChanges(true);\n    (expectedWithdrewUSD, assetPrice, strategyLoss,) = _withdrawUniversal(amount, earnedByPrices, investedAssetsNewPrices);\n  }\n\n  /// @notice Withdraw all from the pool.\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing\n  /// @return assetPrice Price of the {asset} taken from the price oracle\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawAllFromPool() override internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  ) {\n    return _withdrawFromPool(type(uint).max);\n  }\n\n  /// @param amount Amount to be trying to withdrawn. Max uint means attempt to withdraw all possible invested assets.\n  /// @param earnedByPrices_ Additional amount that should be withdrawn and send to the insurance\n  /// @param investedAssets_ Value of invested assets recalculated using current prices\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing in terms of USD value of each asset in the pool\n  /// @return __assetPrice Price of the {asset} taken from the price oracle\n  /// @return strategyLoss Loss before withdrawing: [new-investedAssets - old-investedAssets]\n  /// @return amountSentToInsurance Actual amount of underlying sent to the insurance\n  function _withdrawUniversal(uint amount, uint earnedByPrices_, uint investedAssets_) internal returns (\n    uint expectedWithdrewUSD,\n    uint __assetPrice,\n    uint strategyLoss,\n    uint amountSentToInsurance\n  ) {\n    _beforeWithdraw(amount);\n\n    WithdrawUniversalLocal memory v;\n    v.all = amount == type(uint).max;\n    strategyLoss = 0;\n\n    if ((v.all || amount + earnedByPrices_ != 0) && investedAssets_ != 0) {\n\n      // --- init variables ---\n      v.tokens = _depositorPoolAssets();\n      v.asset = asset;\n      v.converter = converter;\n      v.indexAsset = ConverterStrategyBaseLib.getAssetIndex(v.tokens, v.asset);\n      v.balanceBefore = AppLib.balance(v.asset);\n\n      v.reservesBeforeWithdraw = _depositorPoolReserves();\n      v.totalSupplyBeforeWithdraw = _depositorTotalSupply();\n      v.depositorLiquidity = _depositorLiquidity();\n      v.assetPrice = ConverterStrategyBaseLib.getAssetPriceFromConverter(v.converter, v.asset);\n      // -----------------------\n\n      // calculate how much liquidity we need to withdraw for getting the requested amount\n      (v.liquidityAmountToWithdraw, v.amountsToConvert) = ConverterStrategyBaseLib2.getLiquidityAmount(\n        v.all ? 0 : amount + earnedByPrices_,\n        address(this),\n        v.tokens,\n        v.indexAsset,\n        v.converter,\n        investedAssets_,\n        v.depositorLiquidity\n      );\n\n      if (v.liquidityAmountToWithdraw != 0) {\n\n        // =============== WITHDRAW =====================\n        // make withdraw\n        v.withdrawnAmounts = _depositorExit(v.liquidityAmountToWithdraw);\n        // the depositor is able to use less liquidity than it was asked, i.e. Balancer-depositor leaves some BPT unused\n        // use what exactly was withdrew instead of the expectation\n        // assume that liquidity cannot increase in _depositorExit\n        v.liquidityAmountToWithdraw = v.depositorLiquidity - _depositorLiquidity();\n        emit OnDepositorExit(v.liquidityAmountToWithdraw, v.withdrawnAmounts);\n        // ==============================================\n\n        // we need to call expectation after withdraw for calculate it based on the real liquidity amount that was withdrew\n        // it should be called BEFORE the converter will touch our positions coz we need to call quote the estimations\n        // amountsToConvert should contains amounts was withdrawn from the pool and amounts received from the converter\n        (v.expectedMainAssetAmounts, v.amountsToConvert) = ConverterStrategyBaseLib.postWithdrawActions(\n          v.converter,\n          v.tokens,\n          v.indexAsset,\n          v.reservesBeforeWithdraw,\n          v.liquidityAmountToWithdraw,\n          v.totalSupplyBeforeWithdraw,\n          v.amountsToConvert,\n          v.withdrawnAmounts\n        );\n      } else {\n        // we don't need to withdraw any amounts from the pool, available converted amounts are enough for us\n        v.expectedMainAssetAmounts = ConverterStrategyBaseLib.postWithdrawActionsEmpty(\n          v.converter,\n          v.tokens,\n          v.indexAsset,\n          v.amountsToConvert\n        );\n      }\n\n      // convert amounts to main asset\n      // it is safe to use amountsToConvert from expectation - we will try to repay only necessary amounts\n      v.expectedTotalMainAssetAmount += ConverterStrategyBaseLib.makeRequestedAmount(\n        v.tokens,\n        v.indexAsset,\n        v.amountsToConvert,\n        v.converter,\n        _getLiquidator(controller()),\n        v.all ? amount : amount + earnedByPrices_,\n        v.expectedMainAssetAmounts,\n        liquidationThresholds\n      );\n\n      if (earnedByPrices_ != 0) {\n        amountSentToInsurance = ConverterStrategyBaseLib2.sendToInsurance(\n          v.asset,\n          earnedByPrices_,\n          splitter,\n          investedAssets_ + v.balanceBefore\n        );\n      }\n\n      v.investedAssetsAfterWithdraw = _updateInvestedAssets();\n      v.balanceAfterWithdraw = AppLib.balance(v.asset);\n\n      // we need to compensate difference if during withdraw we lost some assets\n      if ((v.investedAssetsAfterWithdraw + v.balanceAfterWithdraw + earnedByPrices_) < (investedAssets_ + v.balanceBefore)) {\n        strategyLoss += (investedAssets_ + v.balanceBefore) - (v.investedAssetsAfterWithdraw + v.balanceAfterWithdraw + earnedByPrices_);\n      }\n\n      return (\n        v.expectedTotalMainAssetAmount * v.assetPrice / 1e18,\n        v.assetPrice,\n        strategyLoss,\n        amountSentToInsurance\n      );\n    }\n    return (0, 0, 0, 0);\n  }\n\n  /// @notice If pool supports emergency withdraw need to call it for emergencyExit()\n  function _emergencyExitFromPool() override internal virtual {\n    uint[] memory withdrawnAmounts = _depositorEmergencyExit();\n    emit OnDepositorEmergencyExit(withdrawnAmounts);\n\n    // convert amounts to main asset\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n    ConverterStrategyBaseLib.closePositionsToGetAmount(\n      converter,\n      _getLiquidator(controller()),\n      indexAsset,\n      liquidationThresholds,\n      type(uint).max,\n      tokens\n    );\n\n    // adjust _investedAssets\n    _updateInvestedAssets();\n  }\n  //endregion Withdraw from the pool\n\n  /////////////////////////////////////////////////////////////////////\n  //region Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claim all possible rewards.\n  function _claim() override internal virtual returns (address[] memory rewardTokensOut, uint[] memory amountsOut) {\n    // get rewards from the Depositor\n    (address[] memory rewardTokens, uint[] memory rewardAmounts, uint[] memory balancesBefore) = _depositorClaimRewards();\n\n    (rewardTokensOut, amountsOut) = ConverterStrategyBaseLib2.claimConverterRewards(\n      converter,\n      _depositorPoolAssets(),\n      rewardTokens,\n      rewardAmounts,\n      balancesBefore\n    );\n  }\n\n  /// @dev Call recycle process and send tokens to forwarder.\n  ///      Need to be separated from the claim process - the claim can be called by operator for other purposes.\n  function _rewardsLiquidation(address[] memory rewardTokens, uint[] memory amounts) internal {\n    uint len = rewardTokens.length;\n    if (len > 0) {\n      uint[] memory amountsToForward = _recycle(rewardTokens, amounts);\n\n      // send forwarder-part of the rewards to the forwarder\n      ConverterStrategyBaseLib2.sendTokensToForwarder(controller(), splitter, rewardTokens, amountsToForward);\n    }\n  }\n\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just left on the balance\n  ///   Performance amounts should be liquidate, result underlying should be sent to performance receiver and insurance.\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\n  /// @dev {_recycle} is implemented as separate (inline) function to simplify unit testing\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @return amountsToForward Amounts to be sent to forwarder\n  function _recycle(address[] memory rewardTokens_, uint[] memory rewardAmounts_) internal returns (\n    uint[] memory amountsToForward\n  ) {\n    address _asset = asset; // save gas\n\n    uint amountPerf; // total amount for the performance receiver and insurance\n    (amountsToForward, amountPerf) = ConverterStrategyBaseLib.recycle(\n      converter,\n      _asset,\n      compoundRatio,\n      _depositorPoolAssets(),\n      _getLiquidator(controller()),\n      liquidationThresholds,\n      rewardTokens_,\n      rewardAmounts_,\n      performanceFee\n    );\n\n    // send performance-part of the underlying to the performance receiver and insurance\n    (uint toPerf, uint toInsurance) = ConverterStrategyBaseLib2.sendPerformanceFee(\n      _asset,\n      amountPerf,\n      splitter,\n      performanceReceiver,\n      performanceFeeRatio\n    );\n\n    emit Recycle(rewardTokens_, amountsToForward, toPerf, toInsurance);\n  }\n  //endregion Claim rewards\n\n  /////////////////////////////////////////////////////////////////////\n  //region Hardwork\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice A virtual handler to make any action before hardwork\n  function _preHardWork(bool reInvest) internal virtual {}\n\n  /// @notice A virtual handler to make any action after hardwork\n  function _postHardWork() internal virtual {}\n\n  /// @notice Is strategy ready to hard work\n  function isReadyToHardWork() override external virtual view returns (bool) {\n    // check claimable amounts and compare with thresholds\n    return true;\n  }\n\n  /// @notice Do hard work with reinvesting\n  /// @return earned Earned amount in terms of {asset}\n  /// @return lost Lost amount in terms of {asset}\n  function doHardWork() override public returns (uint earned, uint lost) {\n    require(msg.sender == splitter, StrategyLib.DENIED);\n    return _doHardWork(true);\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  function _handleRewards() internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim);\n\n  /// @param reInvest Deposit to pool all available amount if it's greater than the threshold\n  /// @return earned Earned amount in terms of {asset}\n  /// @return lost Lost amount in terms of {asset}\n  function _doHardWork(bool reInvest) internal returns (uint earned, uint lost) {\n    // ATTENTION! splitter will not cover the loss if it is lower than profit\n    (uint investedAssetsNewPrices, uint earnedByPrices) = _fixPriceChanges(true);\n\n    _preHardWork(reInvest);\n\n    // claim rewards and get current asset balance\n    uint assetBalance;\n    (earned, lost, assetBalance) = _handleRewards();\n\n    // re-invest income\n    (, uint amountSentToInsurance) = _depositToPoolUniversal(\n      reInvest\n      && investedAssetsNewPrices != 0\n      && assetBalance > reinvestThresholdPercent * investedAssetsNewPrices / DENOMINATOR\n        ? assetBalance\n        : 0,\n      earnedByPrices,\n      investedAssetsNewPrices\n    );\n    (uint earned2, uint lost2) = ConverterStrategyBaseLib.registerIncome(\n      investedAssetsNewPrices + assetBalance, // assets in use before deposit\n      _investedAssets + AppLib.balance(asset) + amountSentToInsurance // assets in use after deposit\n    );\n\n    _postHardWork();\n\n    emit OnHardWorkEarnedLost(investedAssetsNewPrices, earnedByPrices, earned, lost, earned2, lost2);\n    return (earned + earned2, lost + lost2);\n  }\n  //endregion Hardwork\n\n  /////////////////////////////////////////////////////////////////////\n  //region InvestedAssets Calculations\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Updates cached _investedAssets to actual value\n  /// @dev Should be called after deposit / withdraw / claim; virtual - for ut\n  function _updateInvestedAssets() internal returns (uint investedAssetsOut) {\n    investedAssetsOut = _calcInvestedAssets();\n    _investedAssets = investedAssetsOut;\n  }\n\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return Invested asset amount under control (in terms of {asset})\n  function _calcInvestedAssets() internal returns (uint) {\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n    return ConverterStrategyBaseLib.calcInvestedAssets(\n      tokens,\n      // quote exit should check zero liquidity\n      _depositorQuoteExit(_depositorLiquidity()),\n      indexAsset,\n      converter\n    );\n  }\n\n  function calcInvestedAssets() external returns (uint) {\n    StrategyLib.onlyOperators(controller());\n    return _calcInvestedAssets();\n  }\n\n  /// @notice Calculate profit/loss happened because of price changing. Try to cover the loss, send the profit to the insurance\n  /// @param updateInvestedAssetsAmount_ If false - just return current value of invested assets\n  /// @return investedAssetsOut Updated value of {_investedAssets}\n  /// @return earnedOut Profit that was received because of price changes. It should be sent back to insurance.\n  ///                   It's to dangerous to get this to try to get this amount here because of the problem \"borrow-repay is not allowed in a single block\"\n  ///                   So, we need to handle it in the caller code.\n  function _fixPriceChanges(bool updateInvestedAssetsAmount_) internal returns (uint investedAssetsOut, uint earnedOut) {\n    if (updateInvestedAssetsAmount_) {\n      uint investedAssetsBefore = _investedAssets;\n      investedAssetsOut = _updateInvestedAssets();\n      earnedOut = ConverterStrategyBaseLib.coverPossibleStrategyLoss(investedAssetsBefore, investedAssetsOut, splitter);\n    } else {\n      investedAssetsOut = _investedAssets;\n      earnedOut = 0;\n    }\n  }\n  //endregion InvestedAssets Calculations\n\n  /////////////////////////////////////////////////////////////////////\n  //region ITetuConverterCallback\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Converters asks to send some amount back.\n  /// @param theAsset_ Required asset (either collateral or borrow)\n  /// @param amount_ Required amount of the {theAsset_}\n  /// @return amountOut Amount sent to balance of TetuConverter, amountOut <= amount_\n  function requirePayAmountBack(address theAsset_, uint amount_) external override returns (uint amountOut) {\n    address __converter = address(converter);\n    require(msg.sender == __converter, StrategyLib.DENIED);\n\n    // detect index of the target asset\n    (address[] memory tokens, uint indexTheAsset) = _getTokens(theAsset_);\n    // get amount of target asset available to be sent\n    uint balance = AppLib.balance(theAsset_);\n\n    // withdraw from the pool if not enough\n    if (balance < amount_) {\n      // the strategy doesn't have enough target asset on balance\n      // withdraw all from the pool but don't convert assets to underlying\n      uint liquidity = _depositorLiquidity();\n      if (liquidity != 0) {\n        uint[] memory withdrawnAmounts = _depositorExit(liquidity);\n        emit OnDepositorExit(liquidity, withdrawnAmounts);\n      }\n    }\n\n    amountOut = ConverterStrategyBaseLib.swapToGivenAmountAndSendToConverter(\n      amount_,\n      indexTheAsset,\n      tokens,\n      __converter,\n      controller(),\n      asset,\n      liquidationThresholds\n    );\n\n    // update invested assets anyway, even if we suppose it will be called in other places\n    _updateInvestedAssets();\n  }\n\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external override {\n    require(msg.sender == address(converter), StrategyLib.DENIED);\n\n    uint len = assets_.length;\n    require(len == amounts_.length, AppErrors.INCORRECT_LENGTHS);\n\n    // TetuConverter is able two call this function in two cases:\n    // 1) rebalancing (the health factor of some borrow is too low)\n    // 2) forcible closing of the borrow\n    // In both cases we update invested assets value here\n    // and avoid fixing any related losses in hardwork\n    _updateInvestedAssets();\n  }\n  //endregion ITetuConverterCallback\n\n  /////////////////////////////////////////////////////////////////////\n  //region Others\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Unlimited capacity by default\n  function capacity() external virtual view returns (uint) {\n    return 2 ** 255;\n    // almost same as type(uint).max but more gas efficient\n  }\n\n  function _getTokens(address asset_) internal view returns (address[] memory tokens, uint indexAsset) {\n    tokens = _depositorPoolAssets();\n    indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, asset_);\n    require(indexAsset != type(uint).max, StrategyLib.WRONG_VALUE);\n  }\n\n  function _getLiquidator(address controller_) internal view returns (ITetuLiquidator) {\n    return ITetuLiquidator(IController(controller_).liquidator());\n  }\n  //endregion Others\n\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[50 - 5] private __gap; // 50 - count of variables\n\n}\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppLib.sol\";\nimport \"../libs/TokenAmountsLib.sol\";\nimport \"../libs/ConverterEntryKinds.sol\";\n\nlibrary ConverterStrategyBaseLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  //region Data types\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\n  struct RecycleLocalParams {\n    /// @notice Compound amount + Performance amount\n    uint amountCP;\n    /// @notice Amount to compound\n    uint amountC;\n    /// @notice Amount to send to performance and insurance\n    uint amountP;\n    /// @notice Amount to forwarder + amount to compound\n    uint amountFC;\n    address rewardToken;\n    uint liquidationThresholdAsset;\n    uint len;\n    uint receivedAmountOut;\n  }\n\n  struct OpenPositionLocal {\n    uint entryKind;\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n  }\n\n  struct OpenPositionEntryKind1Local {\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n    uint c1;\n    uint c3;\n    uint ratio;\n    uint alpha;\n  }\n\n  struct CalcInvestedAssetsLocal {\n    uint len;\n    uint[] prices;\n    uint[] decs;\n    uint[] debts;\n  }\n\n  struct ConvertAfterWithdrawLocal {\n    address asset;\n    uint collateral;\n    uint spent;\n    uint received;\n    uint balance;\n    uint balanceBefore;\n    uint len;\n  }\n\n  struct SwapToGivenAmountInputParams {\n    uint targetAmount;\n    address[] tokens;\n    uint indexTargetAsset;\n    address underlying;\n    uint[] amounts;\n    ITetuConverter converter;\n    ITetuLiquidator liquidator;\n    uint liquidationThresholdForTargetAsset;\n    /// @notice Allow to swap more then required (i.e. 1_000 => +1%)\n    ///         to avoid additional swap if the swap return amount a bit less than we expected\n    uint overswap;\n  }\n\n  struct SwapToGivenAmountLocal {\n    uint len;\n    uint[] availableAmounts;\n    uint i;\n  }\n\n  struct CloseDebtsForRequiredAmountLocal {\n    uint len;\n    address asset;\n    uint collateral;\n    uint spentAmountIn;\n    uint receivedAmount;\n    uint balance;\n    uint[] tokensBalancesBefore;\n\n    uint totalDebt;\n    uint totalCollateral;\n\n    /// @notice Cost of $1 in terms of the assets, decimals 18\n    uint[] prices;\n    /// @notice 10**decimal for the assets\n    uint[] decs;\n\n    uint newBalance;\n  }\n  //endregion Data types\n\n  /////////////////////////////////////////////////////////////////////\n  //region Constants\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice approx one month for average block time 2 sec\n  uint internal constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\n  uint internal constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n  uint internal constant DENOMINATOR = 100_000;\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\n  uint internal constant PRICE_IMPACT_TOLERANCE = 300;\n  /// @notice borrow/collateral amount cannot be less than given number of tokens\n  uint internal constant DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD = 10;\n  /// @notice Allow to swap more then required (i.e. 1_000 => +1%) inside {swapToGivenAmount}\n  ///         to avoid additional swap if the swap will return amount a bit less than we expected\n  uint internal constant OVERSWAP = PRICE_IMPACT_TOLERANCE + _ASSET_LIQUIDATION_SLIPPAGE;\n  /// @dev Absolute value for any token\n  uint internal constant DEFAULT_LIQUIDATION_THRESHOLD = 100_000;\n  /// @notice 1% gap to cover possible liquidation inefficiency\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\n  uint internal constant GAP_CONVERSION = 1_000;\n  //endregion Constants\n\n  /////////////////////////////////////////////////////////////////////\n  //region Events\n  /////////////////////////////////////////////////////////////////////\n  /// @notice A borrow was made\n  event OpenPosition(\n    address converter,\n    address collateralAsset,\n    uint collateralAmount,\n    address borrowAsset,\n    uint borrowedAmount,\n    address recepient\n  );\n\n  /// @notice Some borrow(s) was/were repaid\n  event ClosePosition(\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    address recepient,\n    uint returnedAssetAmountOut,\n    uint returnedBorrowAmountOut\n  );\n\n  /// @notice A liquidation was made\n  event Liquidation(\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint spentAmountIn,\n    uint receivedAmountOut\n  );\n\n  event ReturnAssetToConverter(address asset, uint amount);\n\n  event FixPriceChanges(uint investedAssetsBefore, uint investedAssetsOut);\n  //endregion Events\n\n  /////////////////////////////////////////////////////////////////////\n  //region View functions\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Get amount of assets that we expect to receive after withdrawing\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\n  ///                  one of assets must be {asset_}\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\n  function getExpectedWithdrawnAmounts(\n    uint[] memory reserves_,\n    uint liquidityAmount_,\n    uint totalSupply_\n  ) internal pure returns (\n    uint[] memory withdrawnAmountsOut\n  ) {\n    uint ratio = totalSupply_ == 0\n      ? 0\n      : (liquidityAmount_ >= totalSupply_\n        ? 1e18\n        : 1e18 * liquidityAmount_ / totalSupply_\n      );\n\n    uint len = reserves_.length;\n    withdrawnAmountsOut = new uint[](len);\n\n    if (ratio != 0) {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\n      }\n    }\n  }\n\n  /// @return prices Asset prices in USD, decimals 18\n  /// @return decs 10**decimals\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\n    uint[] memory prices,\n    uint[] memory decs\n  ) {\n    prices = new uint[](len);\n    decs = new uint[](len);\n    {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\n      }\n    }\n  }\n\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\n    uint len = tokens_.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (tokens_[i] == asset_) {\n        return i;\n      }\n    }\n    return type(uint).max;\n  }\n\n  /// @notice Get the price ratio of the two given tokens from the oracle.\n  /// @param converter The Tetu converter.\n  /// @param tokenA The first token address.\n  /// @param tokenB The second token address.\n  /// @return The price ratio of the two tokens.\n  function getOracleAssetsPrice(ITetuConverter converter, address tokenA, address tokenB) external view returns (uint) {\n    IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n    uint priceA = oracle.getAssetPrice(tokenA);\n    uint priceB = oracle.getAssetPrice(tokenB);\n    return priceB * 1e18 / priceA;\n  }\n  //endregion View functions\n\n  /////////////////////////////////////////////////////////////////////\n  //region Borrow and close positions\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  function openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdAmountIn_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return _openPosition(tetuConverter_, entryData_, collateralAsset_, borrowAsset_, amountIn_, thresholdAmountIn_);\n  }\n\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  /// @param thresholdAmountIn_ Min value of amountIn allowed for the second and subsequent conversions.\n  ///        0 - use default min value\n  ///        If amountIn becomes too low, no additional borrows are possible, so\n  ///        the rest amountIn is just added to collateral/borrow amount of previous conversion.\n  function _openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdAmountIn_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    if (thresholdAmountIn_ == 0) {\n      // zero threshold is not allowed because round-issues are possible, see openPosition.dust test\n      // we assume here, that it's useless to borrow amount using collateral/borrow amount\n      // less than given number of tokens (event for BTC)\n      thresholdAmountIn_ = DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD;\n    }\n    if (amountIn_ <= thresholdAmountIn_) {\n      return (0, 0);\n    }\n\n    OpenPositionLocal memory vars;\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\n    vars.entryKind = ConverterEntryKinds.getEntryKind(entryData_);\n    if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\n      return openPositionEntryKind1(\n        tetuConverter_,\n        entryData_,\n        collateralAsset_,\n        borrowAsset_,\n        amountIn_,\n        thresholdAmountIn_\n      );\n    } else {\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n        entryData_,\n        collateralAsset_,\n        amountIn_,\n        borrowAsset_,\n        _LOAN_PERIOD_IN_BLOCKS\n      );\n\n      uint len = vars.converters.length;\n      if (len > 0) {\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\n          vars.collateral;\n          vars.amountToBorrow;\n          if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\n            // we have exact amount of total collateral amount\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\n              ? amountIn_\n              : vars.collateralsRequired[i];\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\n              ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\n              : vars.amountsToBorrow[i];\n            amountIn_ -= vars.collateral;\n          } else {\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\n            // we have exact amount of total amount-to-borrow\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\n              ? amountIn_\n              : vars.amountsToBorrow[i];\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\n              ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\n              : vars.collateralsRequired[i];\n            amountIn_ -= vars.amountToBorrow;\n          }\n\n          if (amountIn_ < thresholdAmountIn_ && amountIn_ != 0) {\n            // dust amount is left, just leave it unused\n            // we cannot add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\n            amountIn_ = 0;\n          }\n\n          if (vars.amountToBorrow != 0) {\n            borrowedAmountOut += tetuConverter_.borrow(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n            collateralAmountOut += vars.collateral;\n            emit OpenPosition(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n          }\n\n          if (amountIn_ == 0) break;\n        }\n      }\n\n      return (collateralAmountOut, borrowedAmountOut);\n    }\n  }\n\n  /// @notice Open position using entry kind 1 - split provided amount on two parts according provided proportions\n  /// @param amountIn_ Amount of collateral to be divided on parts. We assume {amountIn_} > 0\n  /// @param collateralThreshold_ Min allowed collateral amount to be used for new borrow, > 0\n  /// @return collateralAmountOut Total collateral used to borrow {borrowedAmountOut}\n  /// @return borrowedAmountOut Total borrowed amount\n  function openPositionEntryKind1(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint collateralThreshold_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    OpenPositionEntryKind1Local memory vars;\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n      entryData_,\n      collateralAsset_,\n      amountIn_,\n      borrowAsset_,\n      _LOAN_PERIOD_IN_BLOCKS\n    );\n\n    uint len = vars.converters.length;\n    if (len > 0) {\n      // we should split amountIn on two amounts with proportions x:y\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\n      // calculate prices conversion ratio using price oracle, decimals 18\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\n\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\n        // and give us required proportions in result\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\n        // C1 is collateral amount left untouched (x)\n        // C2 is collateral amount converted to B2 (y)\n        // but if lending platform doesn't have enough liquidity\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        vars.ratio = (vars.collateralsRequired[i] + vars.c1) > amountIn_\n          ? 1e18 * amountIn_ / (vars.collateralsRequired[i] + vars.c1)\n          : 1e18;\n\n        vars.collateral = vars.collateralsRequired[i] * vars.ratio / 1e18;\n        vars.amountToBorrow = vars.amountsToBorrow[i] * vars.ratio / 1e18;\n\n        // skip any attempts to borrow zero amount or use too little collateral\n        if (vars.collateral < collateralThreshold_ || vars.amountToBorrow == 0) {\n          if (vars.collateralsRequired[i] + vars.c1 + collateralThreshold_ > amountIn_) {\n            // The lending platform has enough resources to make the borrow but amount of the borrow is too low\n            // Skip the borrow, leave leftover of collateral untouched\n            break;\n          } else {\n            // The lending platform doesn't have enough resources to make the borrow.\n            // We should try to make borrow on the next platform (if any)\n            continue;\n          }\n        }\n\n        require(\n          tetuConverter_.borrow(\n            vars.converters[i],\n            collateralAsset_,\n            vars.collateral,\n            borrowAsset_,\n            vars.amountToBorrow,\n            address(this)\n          ) == vars.amountToBorrow,\n          StrategyLib.WRONG_VALUE\n        );\n        emit OpenPosition(\n          vars.converters[i],\n          collateralAsset_,\n          vars.collateral,\n          borrowAsset_,\n          vars.amountToBorrow,\n          address(this)\n        );\n\n        borrowedAmountOut += vars.amountToBorrow;\n        collateralAmountOut += vars.collateral;\n\n        // calculate amount to be borrowed in the next converter\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        amountIn_ = (amountIn_ > vars.c1 + vars.collateral)\n          ? amountIn_ - (vars.c1 + vars.collateral)\n          : 0;\n\n        // protection against dust amounts, see \"openPosition.dust\", just leave dust amount unused\n        // we CAN NOT add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\n        // we assume here, that collateralThreshold_ != 0, so check amountIn_ != 0 is not required\n        if (amountIn_ < collateralThreshold_) break;\n      }\n    }\n\n    return (collateralAmountOut, borrowedAmountOut);\n  }\n\n  /// @notice Get ratio18 = collateral / borrow\n  function _getCollateralToBorrowRatio(\n    ITetuConverter tetuConverter_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) internal view returns (uint){\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle());\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\n    return 1e18 * priceBorrow * 10 ** IERC20Metadata(collateralAsset_).decimals()\n    / priceCollateral / 10 ** IERC20Metadata(borrowAsset_).decimals();\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  ///         It doesn't repay more than the actual amount of the debt, so it can use less amount than {amountToRepay}\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function _closePosition(\n    ITetuConverter converter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) internal returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\n\n    // We shouldn't try to pay more than we actually need to repay\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\n    // Let's limit amountToRepay by needToRepay-amount\n    (uint needToRepay,) = converter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\n\n    return _closePositionExact(converter_, collateralAsset, borrowAsset, amountRepay, balanceBefore);\n  }\n\n  /// @notice Close the given position, pay {amountRepay} exactly and ensure that all amount was accepted,\n  /// @param amountRepay Amount to repay in terms of {borrowAsset}\n  /// @param balanceBorrowAsset Current balance of the borrow asset\n  /// @return collateralOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function _closePositionExact(\n    ITetuConverter converter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    uint balanceBorrowAsset\n  ) internal returns (\n    uint collateralOut,\n    uint repaidAmountOut\n  ) {\n    // Make full/partial repayment\n    IERC20(borrowAsset).safeTransfer(address(converter_), amountRepay);\n\n    uint notUsedAmount;\n    (collateralOut, notUsedAmount,,) = converter_.repay(collateralAsset, borrowAsset, amountRepay, address(this));\n\n    emit ClosePosition(collateralAsset, borrowAsset, amountRepay, address(this), collateralOut, notUsedAmount);\n    uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\n\n    // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (debt-gap)\n    repaidAmountOut = balanceBorrowAsset > balanceAfter\n      ? balanceBorrowAsset - balanceAfter\n      : 0;\n\n    require(notUsedAmount == 0, StrategyLib.WRONG_VALUE);\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\n  }\n  //endregion Borrow and close positions\n\n  /////////////////////////////////////////////////////////////////////\n  //region Liquidation\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\n  function liquidate(\n    ITetuConverter converter,\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdTokenOut_,\n    bool skipValidation\n  ) external returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    return _liquidate(converter, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdTokenOut_, skipValidation);\n  }\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator (== 0 | amountIn_)\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\n  function _liquidate(\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdForTokenOut_,\n    bool skipValidation\n  ) internal returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    if (amountIn_ == 0) {\n      return (0, 0);\n    }\n\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\n\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\n\n    // calculate balance in out value for check threshold\n    uint amountOut = liquidator_.getPriceForRoute(route, amountIn_);\n\n    // if the expected value is higher than threshold distribute to destinations\n    return amountOut > liquidationThresholdForTokenOut_\n      ? (amountIn_, _liquidateWithRoute(converter_, route, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, skipValidation))\n      : (0, 0);\n  }\n\n  /// @notice Make liquidation using given route and check correctness using TetuConverter's price oracle\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\n  function _liquidateWithRoute(\n    ITetuConverter converter_,\n    ITetuLiquidator.PoolData[] memory route,\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    bool skipValidation\n  ) internal returns (\n    uint receivedAmountOut\n  ) {\n    // we need to approve each time, liquidator address can be changed in controller\n    AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\n\n    uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\n    liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\n    uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\n\n    require(balanceAfter > balanceBefore, AppErrors.BALANCE_DECREASE);\n    receivedAmountOut = balanceAfter - balanceBefore;\n\n    // Oracle in TetuConverter \"knows\" only limited number of the assets\n    // It may not know prices for reward assets, so for rewards this validation should be skipped to avoid TC-4 error\n    require(skipValidation || converter_.isConversionValid(tokenIn_, amountIn_, tokenOut_, receivedAmountOut, slippage_), AppErrors.PRICE_IMPACT);\n    emit Liquidation(tokenIn_, tokenOut_, amountIn_, amountIn_, receivedAmountOut);\n  }\n  //endregion Liquidation\n\n  /////////////////////////////////////////////////////////////////////\n  //region requirePayAmountBack\n  /////////////////////////////////////////////////////////////////////\n\n  /// @param amount_ Amount of the main asset requested by converter\n  /// @param indexTheAsset Index of the asset required by converter in the {tokens}\n  /// @param asset Main asset or underlying (it can be different from tokens[indexTheAsset])\n  /// @return amountOut Amount of the main asset sent to converter\n  function swapToGivenAmountAndSendToConverter(\n    uint amount_,\n    uint indexTheAsset,\n    address[] memory tokens,\n    address converter,\n    address controller,\n    address asset,\n    mapping(address => uint) storage liquidationThresholds\n  ) external returns (\n    uint amountOut\n  ) {\n    // msg.sender == converter; we assume here that it was checked before the call of this function\n    address theAsset = tokens[indexTheAsset];\n\n    amountOut = IERC20(theAsset).balanceOf(address(this));\n\n    // convert withdrawn assets to the target asset if not enough\n    if (amountOut < amount_) {\n      ConverterStrategyBaseLib.swapToGivenAmount(\n        amount_ - amountOut,\n        tokens,\n        indexTheAsset,\n        asset, // underlying === main asset\n        ITetuConverter(converter),\n        ITetuLiquidator(IController(controller).liquidator()),\n        liquidationThresholds[theAsset],\n        OVERSWAP\n      );\n      amountOut = IERC20(theAsset).balanceOf(address(this));\n    }\n\n    // we should send the asset as is even if it is lower than requested\n    // but shouldn't sent more amount than requested\n    amountOut = Math.min(amount_, amountOut);\n    if (amountOut != 0) {\n      IERC20(theAsset).safeTransfer(converter, amountOut);\n    }\n\n    // There are two cases of calling requirePayAmountBack by converter:\n    // 1) close a borrow: we will receive collateral back and amount of investedAssets almost won't change\n    // 2) rebalancing: we have real loss, it will be taken into account at next hard work\n    emit ReturnAssetToConverter(theAsset, amountOut);\n\n    // let's leave any leftovers un-invested, they will be reinvested at next hardwork\n  }\n\n  /// @notice Swap available amounts of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\n  /// @param targetAmount_ Required amount of tokens[indexTheAsset_] that should be received by swap(s)\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param indexTargetAsset_ Index of target asset in tokens_ array\n  /// @param underlying_ Index of underlying\n  /// @param liquidationThresholdForTargetAsset_ Liquidation thresholds for the target asset\n  /// @param overswap_ Allow to swap more then required (i.e. 1_000 => +1%)\n  ///                  to avoid additional swap if the swap return amount a bit less than we expected\n  /// @return spentAmounts Any amounts spent during the swaps\n  function swapToGivenAmount(\n    uint targetAmount_,\n    address[] memory tokens_,\n    uint indexTargetAsset_,\n    address underlying_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint liquidationThresholdForTargetAsset_,\n    uint overswap_\n  ) internal returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    SwapToGivenAmountLocal memory v;\n    v.len = tokens_.length;\n\n    v.availableAmounts = new uint[](v.len);\n    for (; v.i < v.len; v.i = AppLib.uncheckedInc(v.i)) {\n      v.availableAmounts[v.i] = IERC20(tokens_[v.i]).balanceOf(address(this));\n    }\n\n    (spentAmounts, receivedAmounts) = _swapToGivenAmount(\n      SwapToGivenAmountInputParams({\n        targetAmount: targetAmount_,\n        tokens: tokens_,\n        indexTargetAsset: indexTargetAsset_,\n        underlying: underlying_,\n        amounts: v.availableAmounts,\n        converter: converter_,\n        liquidator: liquidator_,\n        liquidationThresholdForTargetAsset: Math.max(liquidationThresholdForTargetAsset_, DEFAULT_LIQUIDATION_THRESHOLD),\n        overswap: overswap_\n      })\n    );\n  }\n\n  /// @notice Swap available {amounts_} of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\n  /// @return spentAmounts Any amounts spent during the swaps\n  /// @return receivedAmounts Any amounts received during the swaps\n  function _swapToGivenAmount(SwapToGivenAmountInputParams memory p) internal returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = p.tokens.length;\n    receivedAmounts = new uint[](v.len);\n    spentAmounts = new uint[](v.len);\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(p.converter.controller()).priceOracle()),\n      p.tokens,\n      v.len\n    );\n\n    // we need to swap other assets to the asset\n    // at first we should swap NOT underlying.\n    // if it would be not enough, we can swap underlying too.\n\n    // swap NOT underlying, initialize {indexUnderlying}\n    uint indexUnderlying;\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (p.underlying == p.tokens[i]) {\n        indexUnderlying = i;\n        continue;\n      }\n      if (p.indexTargetAsset == i) continue;\n\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, i);\n      spentAmounts[i] += spent;\n      receivedAmounts[p.indexTargetAsset] += received;\n\n      if (receivedAmounts[p.indexTargetAsset] >= p.targetAmount) break;\n    }\n\n    // swap underlying\n    if (receivedAmounts[p.indexTargetAsset] < p.targetAmount && p.indexTargetAsset != indexUnderlying) {\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, indexUnderlying);\n      spentAmounts[indexUnderlying] += spent;\n      receivedAmounts[p.indexTargetAsset] += received;\n    }\n  }\n\n  /// @notice Swap a part of amount of asset {tokens[indexTokenIn]} to {targetAsset} to get {targetAmount} in result\n  /// @param receivedTargetAmount Already received amount of {targetAsset} in previous swaps\n  /// @param indexTokenIn Index of the tokenIn in p.tokens\n  function _swapToGetAmount(\n    uint receivedTargetAmount,\n    SwapToGivenAmountInputParams memory p,\n    CalcInvestedAssetsLocal memory v,\n    uint indexTokenIn\n  ) internal returns (\n    uint amountSpent,\n    uint amountReceived\n  ) {\n    if (p.amounts[indexTokenIn] != 0) {\n      // we assume here, that p.targetAmount > receivedTargetAmount, see _swapToGivenAmount implementation\n\n      // calculate amount that should be swapped\n      // {overswap} allows to swap a bit more\n      // to avoid additional swaps if the swap will give us a bit less amount than expected\n      uint amountIn = (\n        (p.targetAmount - receivedTargetAmount)\n        * v.prices[p.indexTargetAsset] * v.decs[indexTokenIn]\n        / v.prices[indexTokenIn] / v.decs[p.indexTargetAsset]\n      ) * (p.overswap + DENOMINATOR) / DENOMINATOR;\n\n      (amountSpent, amountReceived) = _liquidate(\n        p.converter,\n        p.liquidator,\n        p.tokens[indexTokenIn],\n        p.tokens[p.indexTargetAsset],\n        Math.min(amountIn, p.amounts[indexTokenIn]),\n        _ASSET_LIQUIDATION_SLIPPAGE,\n        p.liquidationThresholdForTargetAsset,\n        false\n      );\n    }\n\n    return (amountSpent, amountReceived);\n  }\n  //endregion requirePayAmountBack\n\n  /////////////////////////////////////////////////////////////////////\n  //region Recycle rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Recycle the amounts: split each amount on tree parts: performance+insurance (P), forwarder (F), compound (C)\n  ///         Liquidate P+C, send F to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just left on the balance\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\n  ///   Performance amounts are liquidated, result amount of underlying is returned in {amountToPerformanceAndInsurance}\n  /// @param asset Underlying asset\n  /// @param compoundRatio Compound ration in the range [0...COMPOUND_DENOMINATOR]\n  /// @param tokens tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @param liquidationThresholds Liquidation thresholds for rewards tokens\n  /// @param performanceFee Performance fee in the range [0...FEE_DENOMINATOR]\n  /// @return amountsToForward Amounts of {rewardTokens} to be sent to forwarder, zero amounts are allowed here\n  /// @return amountToPerformanceAndInsurance Amount of underlying to be sent to performance receiver and insurance\n  function recycle(\n    ITetuConverter converter_,\n    address asset,\n    uint compoundRatio,\n    address[] memory tokens,\n    ITetuLiquidator liquidator,\n    mapping(address => uint) storage liquidationThresholds,\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    uint performanceFee\n  ) external returns (\n    uint[] memory amountsToForward,\n    uint amountToPerformanceAndInsurance\n  ) {\n    RecycleLocalParams memory p;\n\n    p.len = rewardTokens.length;\n    require(p.len == rewardAmounts.length, AppErrors.WRONG_LENGTHS);\n\n    p.liquidationThresholdAsset = Math.max(liquidationThresholds[asset], DEFAULT_LIQUIDATION_THRESHOLD);\n\n    amountsToForward = new uint[](p.len);\n\n    // rewardAmounts => P + F + C, where P - performance + insurance, F - forwarder, C - compound\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      p.amountFC = rewardAmounts[i] * (COMPOUND_DENOMINATOR - performanceFee) / COMPOUND_DENOMINATOR;\n      p.amountC = p.amountFC * compoundRatio / COMPOUND_DENOMINATOR;\n      p.amountP = rewardAmounts[i] - p.amountFC;\n      p.rewardToken = rewardTokens[i];\n      p.amountCP = p.amountC + p.amountP;\n\n      if (p.amountCP > 0) {\n        if (ConverterStrategyBaseLib.getAssetIndex(tokens, p.rewardToken) != type(uint).max) {\n          if (p.rewardToken == asset) {\n            // This is underlying, liquidation of compound part is not allowed; just keep on the balance, should be handled later\n            amountToPerformanceAndInsurance += p.amountP;\n          } else {\n            // This is secondary asset, Liquidation of compound part is not allowed, we should liquidate performance part only\n            if (p.amountP < Math.max(liquidationThresholds[p.rewardToken], DEFAULT_LIQUIDATION_THRESHOLD)) {\n              // performance amount is too small, liquidation is not allowed, we just keep that dust tokens on balance forever\n            } else {\n              (, p.receivedAmountOut) = _liquidate(\n                converter_,\n                liquidator,\n                p.rewardToken,\n                asset,\n                p.amountP,\n                _REWARD_LIQUIDATION_SLIPPAGE,\n                p.liquidationThresholdAsset,\n                false // use conversion validation for these rewards\n              );\n              amountToPerformanceAndInsurance += p.receivedAmountOut;\n            }\n          }\n        } else {\n          if (p.amountCP < Math.max(liquidationThresholds[p.rewardToken], DEFAULT_LIQUIDATION_THRESHOLD)) {\n            // amount is too small, liquidation is not allowed, we just keep that dust tokens on balance forever\n          } else {\n            // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\n            // We assume here, that {token} cannot be equal to {_asset}\n            // because the {_asset} is always included to the list of depositor's assets\n            (, p.receivedAmountOut) = _liquidate(\n              converter_,\n              liquidator,\n              p.rewardToken,\n              asset,\n              p.amountCP,\n              _REWARD_LIQUIDATION_SLIPPAGE,\n              p.liquidationThresholdAsset,\n              true // skip conversion validation for rewards becase we can have arbitrary assets here\n            );\n\n            amountToPerformanceAndInsurance += p.receivedAmountOut * (rewardAmounts[i] - p.amountFC) / p.amountCP;\n          }\n        }\n      }\n      amountsToForward[i] = p.amountFC - p.amountC;\n    }\n    return (amountsToForward, amountToPerformanceAndInsurance);\n  }\n  //endregion Recycle rewards\n\n  /////////////////////////////////////////////////////////////////////\n  //region calcInvestedAssets\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return amountOut Invested asset amount under control (in terms of {asset})\n  function calcInvestedAssets(\n    address[] memory tokens,\n    uint[] memory depositorQuoteExitAmountsOut,\n    uint indexAsset,\n    ITetuConverter converter_\n  ) external returns (\n    uint amountOut\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = tokens.length;\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\n      tokens,\n      v.len\n    );\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\n        amountOut += depositorQuoteExitAmountsOut[i];\n      } else {\n        // available amount to repay\n        uint toRepay = IERC20(tokens[i]).balanceOf(address(this)) + depositorQuoteExitAmountsOut[i];\n\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(\n          address(this),\n          tokens[indexAsset],\n          tokens[i],\n          // investedAssets is calculated using exact debts, debt-gaps are not taken into account\n          false\n        );\n        amountOut += collateral;\n\n        if (toRepay >= toPay) {\n          amountOut += (toRepay - toPay) * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        } else {\n          // there is not enough amount to pay the debt\n          // let's register a debt and try to resolve it later below\n          if (v.debts.length == 0) {\n            // lazy initialization\n            v.debts = new uint[](v.len);\n          }\n\n          // to pay the following amount we need to swap some other asset at first\n          v.debts[i] = toPay - toRepay;\n        }\n      }\n    }\n    if (v.debts.length == v.len) {\n      // we assume here, that it would be always profitable to save collateral\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n        if (v.debts[i] == 0) continue;\n\n        // estimatedAssets should be reduced on the debt-value\n        // this estimation is approx and do not count price impact on the liquidation\n        // we will able to count the real output only after withdraw process\n        uint debtInAsset = v.debts[i] * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        if (debtInAsset > amountOut) {\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\n          amountOut = 0;\n        } else {\n          amountOut -= debtInAsset;\n        }\n      }\n    }\n\n    return amountOut;\n  }\n  //endregion calcInvestedAssets\n\n  /////////////////////////////////////////////////////////////////////\n  //region getExpectedAmountMainAsset\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate expected amount of the main asset after withdrawing\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\n  /// @return amountsOut Expected amounts of the main asset received after conversion withdrawnAmounts+amountsToConvert\n  function getExpectedAmountMainAsset(\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint[] memory withdrawnAmounts_,\n    uint[] memory amountsToConvert_\n  ) internal returns (\n    uint[] memory amountsOut\n  ) {\n    uint len = tokens.length;\n    amountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        amountsOut[i] = withdrawnAmounts_[i];\n      } else {\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\n        if (amount != 0) {\n          (amountsOut[i],) = converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\n        }\n      }\n    }\n\n    return amountsOut;\n  }\n  //endregion getExpectedAmountMainAsset\n\n  /////////////////////////////////////////////////////////////////////\n  //region Reduce size of ConverterStrategyBase\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make borrow and save amounts of tokens available for deposit to tokenAmounts\n  /// @param thresholdMainAsset_ Min allowed value of collateral in terms of main asset, 0 - use default min value\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\n  /// @param collaterals_ Amounts of main asset that can be used as collateral to borrow {tokens_}\n  /// @param thresholdMainAsset_ Value of liquidation threshold for the main (collateral) asset\n  /// @return tokenAmountsOut Amounts available for deposit\n  function getTokenAmounts(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory collaterals_,\n    uint thresholdMainAsset_\n  ) external returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    // content of tokenAmounts will be modified in place\n    uint len = tokens_.length;\n    tokenAmountsOut = new uint[](len);\n\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexAsset_) {\n        if (collaterals_[i] != 0) {\n          AppLib.approveIfNeeded(tokens_[indexAsset_], collaterals_[i], address(tetuConverter_));\n          _openPosition(\n            tetuConverter_,\n            \"\", // entry kind = 0: fixed collateral amount, max possible borrow amount\n            tokens_[indexAsset_],\n            tokens_[i],\n            collaterals_[i],\n            Math.max(thresholdMainAsset_, DEFAULT_LIQUIDATION_THRESHOLD)\n          );\n\n          // zero borrowed amount is possible here (conversion is not available)\n          // if it's not suitable for depositor, the depositor should check zero amount in other places\n        }\n        tokenAmountsOut[i] = IERC20(tokens_[i]).balanceOf(address(this));\n      }\n    }\n\n    tokenAmountsOut[indexAsset_] = Math.min(\n      collaterals_[indexAsset_],\n      IERC20(tokens_[indexAsset_]).balanceOf(address(this))\n    );\n  }\n\n  /// @notice Convert {amountsToConvert_} to the main {asset}\n  ///         Swap leftovers (if any) to the main asset.\n  ///         If result amount is less than expected, try to close any other available debts (1 repay per block only)\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @param requestedAmount Amount to be withdrawn in terms of the asset in addition to the exist balance.\n  ///        Max uint means attempt to withdraw all possible invested assets.\n  /// @param amountsToConvert_ Amounts available for conversion after withdrawing from the pool\n  /// @param expectedMainAssetAmounts Amounts of main asset that we expect to receive after conversion amountsToConvert_\n  /// @return expectedAmount Expected total amount of main asset after all conversions, swaps and repays\n  function makeRequestedAmount(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint requestedAmount,\n    uint[] memory expectedMainAssetAmounts,\n    mapping(address => uint) storage liquidationThresholds\n  ) external returns (uint expectedAmount) {\n    // get the total expected amount\n    for (uint i; i < tokens_.length; i = AppLib.uncheckedInc(i)) {\n      expectedAmount += expectedMainAssetAmounts[i];\n    }\n\n    // we cannot repay a debt twice\n    // suppose, we have usdt = 1 and we need to convert it to usdc, then get additional usdt=10 and make second repay\n    // But: we cannot make repay(1) and than repay(10). We MUST make single repay(11)\n\n    if (requestedAmount != type(uint).max\n      && expectedAmount > requestedAmount * (GAP_CONVERSION + DENOMINATOR) / DENOMINATOR\n    ) {\n      // amountsToConvert_ are enough to get requestedAmount\n      _convertAfterWithdraw(\n        converter_,\n        liquidator_,\n        indexAsset_,\n        liquidationThresholds[tokens_[indexAsset_]],\n        tokens_,\n        amountsToConvert_\n      );\n    } else {\n      // amountsToConvert_ are NOT enough to get requestedAmount\n      // We are allowed to make only one repay per block, so, we shouldn't try to convert amountsToConvert_\n      // We should try to close the exist debts instead:\n      //    convert a part of main assets to get amount of secondary assets required to repay the debts\n      // and only then make conversion.\n      expectedAmount = _closePositionsToGetAmount(\n        converter_,\n        liquidator_,\n        indexAsset_,\n        liquidationThresholds,\n        requestedAmount,\n        tokens_\n      ) + expectedMainAssetAmounts[indexAsset_];\n    }\n\n    return expectedAmount;\n  }\n  //endregion Reduce size of ConverterStrategyBase\n\n  /////////////////////////////////////////////////////////////////////\n  //region Withdraw helpers\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\n  /// @param amountsToConvert Amounts of {tokens} to be converted, they are located on the balance before withdraw\n  /// @param withdrawnAmounts Amounts of {tokens} that were withdrew from the pool\n  function postWithdrawActions(\n    ITetuConverter converter,\n    address[] memory tokens,\n    uint indexAsset,\n\n    uint[] memory reservesBeforeWithdraw,\n    uint liquidityAmountWithdrew,\n    uint totalSupplyBeforeWithdraw,\n\n    uint[] memory amountsToConvert,\n    uint[] memory withdrawnAmounts\n  ) external returns (\n    uint[] memory expectedMainAssetAmounts,\n    uint[] memory _amountsToConvert\n  ) {\n    // estimate expected amount of assets to be withdrawn\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\n      reservesBeforeWithdraw,\n      liquidityAmountWithdrew,\n      totalSupplyBeforeWithdraw\n    );\n\n    // from received amounts after withdraw calculate how much we receive from converter for them in terms of the underlying asset\n    expectedMainAssetAmounts = getExpectedAmountMainAsset(\n      tokens,\n      indexAsset,\n      converter,\n      expectedWithdrawAmounts,\n      amountsToConvert\n    );\n\n    uint len = tokens.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      amountsToConvert[i] += withdrawnAmounts[i];\n    }\n\n    return (expectedMainAssetAmounts, amountsToConvert);\n  }\n\n  /// @notice return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\n  function postWithdrawActionsEmpty(\n    ITetuConverter converter,\n    address[] memory tokens,\n    uint indexAsset,\n    uint[] memory amountsToConvert_\n  ) external returns (\n    uint[] memory expectedAmountsMainAsset\n  ) {\n    expectedAmountsMainAsset = getExpectedAmountMainAsset(\n      tokens,\n      indexAsset,\n      converter,\n      // there are no withdrawn amounts\n      new uint[](tokens.length), // array with all zero values\n      amountsToConvert_\n    );\n  }\n\n  //endregion Withdraw helpers\n\n  /////////////////////////////////////////////////////////////////////\n  //region convertAfterWithdraw\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Convert {amountsToConvert_} (available on balance) to the main asset\n  ///         Swap leftovers if any.\n  ///         Result amount can be less than requested one, we don't try to close any other debts here\n  /// @param indexAsset Index of the main asset in {tokens}\n  /// @param liquidationThreshold Min allowed amount of main asset to be liquidated in {liquidator}\n  /// @param tokens Tokens received from {_depositorPoolAssets}\n  /// @param amountsToConvert Amounts to convert, the order of asset is same as in {tokens}\n  /// @return collateralOut Total amount of main asset returned after closing positions\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\n  function _convertAfterWithdraw(\n    ITetuConverter tetuConverter,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    uint liquidationThreshold,\n    address[] memory tokens,\n    uint[] memory amountsToConvert\n  ) internal returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    ConvertAfterWithdrawLocal memory v;\n    v.asset = tokens[indexAsset];\n    v.balanceBefore = IERC20(v.asset).balanceOf(address(this));\n    v.len = tokens.length;\n\n    // Close positions to convert all required amountsToConvert\n    repaidAmountsOut = new uint[](tokens.length);\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset || amountsToConvert[i] == 0) continue;\n      (, repaidAmountsOut[i]) = _closePosition(tetuConverter, v.asset, tokens[i], amountsToConvert[i]);\n    }\n\n    // Manually swap remain leftovers\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset || amountsToConvert[i] == 0) continue;\n      if (amountsToConvert[i] > repaidAmountsOut[i]) {\n        (v.spent, v.received) = _liquidate(\n          tetuConverter,\n          liquidator,\n          tokens[i],\n          v.asset,\n          amountsToConvert[i] - repaidAmountsOut[i],\n          _ASSET_LIQUIDATION_SLIPPAGE,\n          liquidationThreshold,\n          false\n        );\n        collateralOut += v.received;\n        repaidAmountsOut[i] += v.spent;\n      }\n    }\n\n    // Calculate amount of received collateral\n    v.balance = IERC20(v.asset).balanceOf(address(this));\n    collateralOut = v.balance > v.balanceBefore\n      ? v.balance - v.balanceBefore\n      : 0;\n\n    return (collateralOut, repaidAmountsOut);\n  }\n\n  /// @notice Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\n  /// @dev We assume here that this function is called before closing any positions in the current block\n  /// @param liquidationThresholds Min allowed amounts-out for liquidations\n  /// @param requestedAmount Requested amount of main asset that should be added to the current balance\n  /// @return expectedAmount Main asset amount expected to be received on balance after all conversions and swaps\n  function closePositionsToGetAmount(\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    mapping(address => uint) storage liquidationThresholds,\n    uint requestedAmount,\n    address[] memory tokens\n  ) external returns (\n    uint expectedAmount\n  ) {\n    return _closePositionsToGetAmount(\n      converter_,\n      liquidator,\n      indexAsset,\n      liquidationThresholds,\n      requestedAmount,\n      tokens\n    );\n  }\n\n  function _closePositionsToGetAmount(\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    mapping(address => uint) storage liquidationThresholds,\n    uint requestedAmount,\n    address[] memory tokens\n  ) internal returns (\n    uint expectedAmount\n  ) {\n    if (requestedAmount != 0) {\n      CloseDebtsForRequiredAmountLocal memory v;\n      v.asset = tokens[indexAsset];\n      v.len = tokens.length;\n      v.balance = IERC20(v.asset).balanceOf(address(this));\n\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n        if (i == indexAsset) continue;\n\n        // we need to increase balance on the following amount: requestedAmount - v.balance;\n        // we have following borrow: amount-to-pay and corresponded collateral\n        (v.totalDebt, v.totalCollateral) = converter_.getDebtAmountCurrent(address(this), v.asset, tokens[i], true);\n\n        uint tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\n\n        if (v.totalDebt != 0 || tokenBalance != 0) {\n          //lazy initialization of the prices and decs\n          if (v.prices.length == 0) {\n            (v.prices, v.decs) = _getPricesAndDecs(\n              IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\n              tokens,\n              v.len\n            );\n          }\n\n          // repay the debt if any\n          if (v.totalDebt != 0) {\n            // what amount of main asset we should sell to pay the debt\n            uint toSell = _getAmountToSell(\n              requestedAmount,\n              v.totalDebt,\n              v.totalCollateral,\n              v.prices,\n              v.decs,\n              indexAsset,\n              i,\n              tokenBalance\n            );\n\n            // convert {toSell} amount of main asset to tokens[i]\n            if (toSell != 0 && v.balance != 0) {\n              toSell = Math.min(toSell, v.balance);\n              (toSell,) = _liquidate(\n                converter_,\n                liquidator,\n                v.asset,\n                tokens[i],\n                toSell,\n                _ASSET_LIQUIDATION_SLIPPAGE,\n                liquidationThresholds[tokens[i]],\n                false\n              );\n              tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\n            }\n\n            // sell {toSell}, repay the debt, return collateral back; we should receive amount > toSell\n            expectedAmount += _repayDebt(converter_, v.asset, tokens[i], tokenBalance) - toSell;\n\n            // we can have some leftovers after closing the debt\n            tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\n          }\n\n          // directly swap leftovers\n          if (tokenBalance != 0) {\n            (uint spentAmountIn,) = _liquidate(\n              converter_,\n              liquidator,\n              tokens[i],\n              v.asset,\n              tokenBalance,\n              _ASSET_LIQUIDATION_SLIPPAGE,\n              liquidationThresholds[v.asset],\n              false\n            );\n            if (spentAmountIn != 0) {\n              // spentAmountIn can be zero if token balance is less than liquidationThreshold\n              expectedAmount += spentAmountIn * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n            }\n          }\n\n          // reduce of requestedAmount on the balance increment\n          v.newBalance = IERC20(v.asset).balanceOf(address(this));\n          require(v.newBalance >= v.balance, AppErrors.BALANCE_DECREASE);\n\n          if (requestedAmount > v.newBalance - v.balance) {\n            requestedAmount -= (v.newBalance - v.balance);\n            v.balance = v.newBalance;\n          } else {\n            // we get requestedAmount on the balance and don't need to make any other conversions\n            break;\n          }\n        }\n      }\n    }\n\n    return expectedAmount;\n  }\n\n  /// @notice What amount of collateral should be sold to pay the debt and receive {requestedAmount}\n  /// @dev It doesn't allow to sell more than the amount of total debt in the borrow\n  /// @param requestedAmount We need to increase balance (of collateral asset) on this amount\n  /// @param totalDebt Total debt of the borrow in terms of borrow asset\n  /// @param totalCollateral Total collateral of the borrow in terms of collateral asset\n  /// @param prices Cost of $1 in terms of the asset, decimals 18\n  /// @param decs 10**decimals for each asset\n  /// @param indexCollateral Index of the collateral asset in {prices} and {decs}\n  /// @param indexBorrowAsset Index of the borrow asset in {prices} and {decs}\n  /// @param balanceBorrowAsset Available balance of the borrow asset, it will be used to cover the debt\n  function _getAmountToSell(\n    uint requestedAmount,\n    uint totalDebt,\n    uint totalCollateral,\n    uint[] memory prices,\n    uint[] memory decs,\n    uint indexCollateral,\n    uint indexBorrowAsset,\n    uint balanceBorrowAsset\n  ) internal pure returns (\n    uint amountOut\n  ) {\n    if (totalDebt != 0) {\n      if (balanceBorrowAsset != 0) {\n        // there is some borrow asset on balance\n        // it will be used to cover the debt\n        // let's reduce the size of totalDebt/Collateral to exclude balanceBorrowAsset\n        uint sub = Math.min(balanceBorrowAsset, totalDebt);\n        totalCollateral -= totalCollateral * sub / totalDebt;\n        totalDebt -= sub;\n      }\n\n      // for definiteness: usdc - collateral asset, dai - borrow asset\n      // Pc = price of the USDC, Pb = price of the DAI, alpha = Pc / Pb [DAI / USDC]\n      // S [USDC] - amount to sell, R [DAI] = alpha * S - amount to repay\n      // After repaying R we get: alpha * S * C / R\n      // Balance should be increased on: requestedAmount = alpha * S * C / R - S\n      // So, we should sell: S = requestedAmount / (alpha * C / R - 1))\n      // We can lost some amount on liquidation of S => R, so we need to use some gap = {GAP_AMOUNT_TO_SELL}\n      // Same formula: S * h = S + requestedAmount, where h = health factor => s = requestedAmount / (h - 1)\n      // h = alpha * C / R\n      uint alpha18 = prices[indexCollateral] * decs[indexBorrowAsset] * 1e18\n        / prices[indexBorrowAsset] / decs[indexCollateral];\n\n      // if totalCollateral is zero (liquidation happens) we will have zero amount (the debt shouldn't be paid)\n      amountOut = totalDebt != 0 && alpha18 * totalCollateral / totalDebt > 1e18\n        ? Math.min(requestedAmount, totalCollateral) * 1e18 / (alpha18 * totalCollateral / totalDebt - 1e18)\n        : 0;\n\n      if (amountOut != 0) {\n        // we shouldn't try to sell amount greater than amount of totalDebt in terms of collateral asset\n        // but we always asks +1% because liquidation results can be different a bit from expected\n        amountOut = (GAP_CONVERSION + DENOMINATOR) * Math.min(amountOut, totalDebt * 1e18 / alpha18) / DENOMINATOR;\n      }\n    }\n\n    return amountOut;\n  }\n\n  /// @notice Repay {amountIn} and get collateral in return, calculate expected amount\n  ///         Take into account possible debt-gap and the fact that the amount of debt may be less than {amountIn}\n  /// @param amountToRepay Max available amount of borrow asset that we can repay\n  /// @return expectedAmountOut Estimated amount of main asset that should be added to balance = collateral - {toSell}\n  function _repayDebt(\n    ITetuConverter converter,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) internal returns (\n    uint expectedAmountOut\n  ) {\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\n\n    // get amount of debt with debt-gap\n    (uint needToRepay,) = converter.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\n\n    // get expected amount without debt-gap\n    uint swappedAmountOut;\n    (expectedAmountOut, swappedAmountOut) = converter.quoteRepay(address(this), collateralAsset, borrowAsset, amountRepay);\n\n    if (expectedAmountOut > swappedAmountOut) {\n      // Following situation is possible\n      //    needToRepay = 100, needToRepayExact = 90 (debt gap is 10)\n      //    1) amountRepay = 80\n      //       expectedAmountOut is calculated for 80, no problems\n      //    2) amountRepay = 99,\n      //       expectedAmountOut is calculated for 90 + 9 (90 - repay, 9 - direct swap)\n      //       expectedAmountOut must be reduced on 9 here (!)\n      expectedAmountOut -= swappedAmountOut;\n    }\n\n    // close the debt\n    _closePositionExact(converter, collateralAsset, borrowAsset, amountRepay, balanceBefore);\n\n    return expectedAmountOut;\n  }\n  //endregion convertAfterWithdraw\n\n  /////////////////////////////////////////////////////////////////////\n  //region Other helpers\n  /////////////////////////////////////////////////////////////////////\n\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\n    return IPriceOracle(IConverterController(converter.controller()).priceOracle()).getAssetPrice(token);\n  }\n\n  function registerIncome(uint assetBefore, uint assetAfter) internal pure returns (uint earned, uint lost) {\n    if (assetAfter > assetBefore) {\n      earned = assetAfter - assetBefore;\n    } else {\n      lost = assetBefore - assetAfter;\n    }\n    return (earned, lost);\n  }\n\n  /// @notice Register income and cover possible loss\n  function coverPossibleStrategyLoss(uint assetBefore, uint assetAfter, address splitter) external returns (uint earned) {\n    uint lost;\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(assetBefore, assetAfter);\n    if (lost != 0) {\n      ISplitter(splitter).coverPossibleStrategyLoss(earned, lost);\n    }\n    emit FixPriceChanges(assetBefore, assetAfter);\n  }\n\n  //endregion Other helpers\n}\n\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppLib.sol\";\nimport \"../libs/TokenAmountsLib.sol\";\nimport \"../libs/ConverterEntryKinds.sol\";\n\n/// @notice Continuation of ConverterStrategyBaseLib (workaround for size limits)\nlibrary ConverterStrategyBaseLib2 {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  uint internal constant DENOMINATOR = 100_000;\n\n  /// @dev 0.5% of max profit for strategy TVL\n  /// @notice Limit max amount of profit that can be send to insurance after price changing\n  uint public constant PRICE_CHANGE_PROFIT_TOLERANCE = 500;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        EVENTS\n  /////////////////////////////////////////////////////////////////////\n\n  event OnChangePerformanceFeeRatio(uint newRatio);\n  event LiquidationThresholdChanged(address token, uint amount);\n  event ReinvestThresholdPercentChanged(uint amount);\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        MAIN LOGIC\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\n  function getAvailableBalances(\n    address[] memory tokens_,\n    uint indexAsset\n  ) external view returns (uint[] memory) {\n    uint len = tokens_.length;\n    uint[] memory amountsToConvert = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this));\n    }\n    return amountsToConvert;\n  }\n\n  /// @notice Send {amount_} of {asset_} to {receiver_} and insurance\n  /// @param asset_ Underlying asset\n  /// @param amount_ Amount of underlying asset to be sent to\n  /// @param receiver_ Performance receiver\n  /// @param ratio [0..100_000], 100_000 - send full amount to perf, 0 - send full amount to the insurance.\n  function sendPerformanceFee(address asset_, uint amount_, address splitter, address receiver_, uint ratio) external returns (\n    uint toPerf,\n    uint toInsurance\n  ) {\n    // read inside lib for reduce contract space in the main contract\n    address insurance = address(ITetuVaultV2(ISplitter(splitter).vault()).insurance());\n\n    toPerf = amount_ * ratio / DENOMINATOR;\n    toInsurance = amount_ - toPerf;\n\n    if (toPerf != 0) {\n      IERC20(asset_).safeTransfer(receiver_, toPerf);\n    }\n    if (toInsurance != 0) {\n      IERC20(asset_).safeTransfer(insurance, toInsurance);\n    }\n  }\n\n  function sendTokensToForwarder(\n    address controller_,\n    address splitter_,\n    address[] memory tokens_,\n    uint[] memory amounts_\n  ) external {\n    uint len = tokens_.length;\n    IForwarder forwarder = IForwarder(IController(controller_).forwarder());\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      AppLib.approveIfNeeded(tokens_[i], amounts_[i], address(forwarder));\n    }\n\n    (tokens_, amounts_) = TokenAmountsLib.filterZeroAmounts(tokens_, amounts_);\n    forwarder.registerIncome(tokens_, amounts_, ISplitter(splitter_).vault(), true);\n  }\n\n  /// @notice For each {token_} calculate a part of {amount_} to be used as collateral according to the weights.\n  ///         I.e. we have 300 USDC, we need to split it on 100 USDC, 100 USDT, 100 DAI\n  ///         USDC is main asset, USDT and DAI should be borrowed. We check amounts of USDT and DAI on the balance\n  ///         and return collaterals reduced on that amounts. For main asset, we return full amount always (100 USDC).\n  /// @return tokenAmountsOut Length of the array is equal to the length of {tokens_}\n  function getCollaterals(\n    uint amount_,\n    address[] memory tokens_,\n    uint[] memory weights_,\n    uint totalWeight_,\n    uint indexAsset_,\n    IPriceOracle priceOracle\n  ) external view returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    uint len = tokens_.length;\n    tokenAmountsOut = new uint[](len);\n\n    // get token prices and decimals\n    uint[] memory prices = new uint[](len);\n    uint[] memory decs = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\n      prices[i] = priceOracle.getAssetPrice(tokens_[i]);\n    }\n\n    // split the amount on tokens proportionally to the weights\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      uint amountAssetForToken = amount_ * weights_[i] / totalWeight_;\n\n      if (i == indexAsset_) {\n        tokenAmountsOut[i] = amountAssetForToken;\n      } else {\n        // if we have some tokens on balance then we need to use only a part of the collateral\n        uint tokenAmountToBeBorrowed = amountAssetForToken\n          * prices[indexAsset_]\n          * decs[i]\n          / prices[i]\n          / decs[indexAsset_];\n\n        uint tokenBalance = IERC20(tokens_[i]).balanceOf(address(this));\n        if (tokenBalance < tokenAmountToBeBorrowed) {\n          tokenAmountsOut[i] = amountAssetForToken * (tokenAmountToBeBorrowed - tokenBalance) / tokenAmountToBeBorrowed;\n        }\n      }\n    }\n  }\n\n  /// @notice Calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\n  ///         User needs to withdraw {targetAmount_} in main asset.\n  ///         There are two kinds of available liquidity:\n  ///         1) liquidity in the pool - {depositorLiquidity_}\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\n  ///         To withdraw {targetAmount_} we need\n  ///         1) Reconvert converted amounts back to main asset\n  ///         2) IF result amount is not necessary - withdraw some liquidity from the pool\n  ///            and also convert it to the main asset.\n  /// @dev This is a writable function with read-only behavior (because of the quote-call)\n  /// @param targetAmount_ Required amount of main asset to be withdrawn from the strategy; 0 - withdraw all\n  /// @param strategy_ Address of the strategy\n  /// @return resultAmount Amount of liquidity that should be withdrawn from the pool, cannot exceed depositorLiquidity\n  /// @return amountsToConvertOut Amounts of {tokens} that should be converted to the main asset\n  function getLiquidityAmount(\n    uint targetAmount_,\n    address strategy_,\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint investedAssets,\n    uint depositorLiquidity\n  ) external returns (\n    uint resultAmount,\n    uint[] memory amountsToConvertOut\n  ) {\n    bool all = targetAmount_ == 0;\n\n    uint len = tokens.length;\n    amountsToConvertOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n\n      uint balance = IERC20(tokens[i]).balanceOf(address(this));\n      if (balance != 0) {\n        // let's estimate collateral that we received back after repaying balance-amount\n        (uint expectedCollateral,) = converter.quoteRepay(strategy_, tokens[indexAsset], tokens[i], balance);\n\n        if (all || targetAmount_ != 0) {\n          // We always repay WHOLE available balance-amount even if it gives us much more amount then we need.\n          // We cannot repay a part of it because converter doesn't allow to know\n          // what amount should be repaid to get given amount of collateral.\n          // And it's too dangerous to assume that we can calculate this amount\n          // by reducing balance-amount proportionally to expectedCollateral/targetAmount_\n          amountsToConvertOut[i] = balance;\n        }\n\n        targetAmount_ = targetAmount_ > expectedCollateral\n          ? targetAmount_ - expectedCollateral\n          : 0;\n\n        investedAssets = investedAssets > expectedCollateral\n          ? investedAssets - expectedCollateral\n          : 0;\n      }\n    }\n\n    uint liquidityRatioOut = all || investedAssets == 0\n      ? 1e18\n      : ((targetAmount_ == 0)\n        ? 0\n        : 1e18\n        * 101 // add 1% on top...\n        * targetAmount_ / investedAssets // a part of amount that we are going to withdraw\n        / 100 // .. add 1% on top\n      );\n\n    resultAmount = liquidityRatioOut != 0\n      ? Math.min(liquidityRatioOut * depositorLiquidity / 1e18, depositorLiquidity)\n      : 0;\n  }\n\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\n  /// @dev The post-processing is rewards conversion to the main asset\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens_ List of rewards claimed from the internal pool\n  /// @param rewardTokens_ Amounts of rewards claimed from the internal pool\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\n  /// @param amountsOut Amounts of available rewards\n  function claimConverterRewards(\n    ITetuConverter converter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_,\n    uint[] memory balancesBefore\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    // Rewards from TetuConverter\n    (address[] memory tokensTC, uint[] memory amountsTC) = converter_.claimRewards(address(this));\n\n    // Join arrays and recycle tokens\n    (tokensOut, amountsOut) = TokenAmountsLib.combineArrays(\n      rewardTokens_, rewardAmounts_,\n      tokensTC, amountsTC,\n      // by default, depositor assets have zero amounts here\n      tokens_, new uint[](tokens_.length)\n    );\n\n    // set fresh balances for depositor tokens\n    uint len = tokensOut.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      for (uint j; j < tokens_.length; j = AppLib.uncheckedInc(j)) {\n        if (tokensOut[i] == tokens_[j]) {\n          amountsOut[i] = IERC20(tokens_[j]).balanceOf(address(this)) - balancesBefore[j];\n        }\n      }\n    }\n\n    // filter zero amounts out\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n\n  /// @notice Send given amount of underlying to the insurance\n  /// @param strategyBalance Total strategy balance = balance of underlying + current invested assets amount\n  /// @return Amount of underlying sent to the insurance\n  function sendToInsurance(address asset, uint amount, address splitter, uint strategyBalance) external returns (uint) {\n    uint amountToSend = Math.min(amount, IERC20(asset).balanceOf(address(this)));\n    if (amountToSend != 0) {\n      // max amount that can be send to insurance is limited by PRICE_CHANGE_PROFIT_TOLERANCE\n\n      // Amount limitation should be implemented in the same way as in StrategySplitterV2._coverLoss\n      // Revert or cutting amount in both cases\n\n      // amountToSend = Math.min(amountToSend, PRICE_CHANGE_PROFIT_TOLERANCE * strategyBalance / 100_000);\n      require(strategyBalance != 0, AppErrors.ZERO_BALANCE);\n      require(amountToSend <= PRICE_CHANGE_PROFIT_TOLERANCE * strategyBalance / 100_000, AppErrors.EARNED_AMOUNT_TOO_HIGH);\n      IERC20(asset).safeTransfer(address(ITetuVaultV2(ISplitter(splitter).vault()).insurance()), amountToSend);\n    }\n    return amountToSend;\n  }\n\n  //region ---------------------------------------- Setters\n  function checkPerformanceFeeRatioChanged(address controller, uint ratio_) external {\n    StrategyLib.onlyOperators(controller);\n    require(ratio_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\n    emit OnChangePerformanceFeeRatio(ratio_);\n  }\n\n  function checkReinvestThresholdPercentChanged(address controller, uint percent_) external {\n    StrategyLib.onlyOperators(controller);\n    require(percent_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\n    emit ReinvestThresholdPercentChanged(percent_);\n  }\n\n  function checkLiquidationThresholdChanged(address controller, address token, uint amount) external {\n    StrategyLib.onlyOperators(controller);\n    emit LiquidationThresholdChanged(token, amount);\n  }\n  //endregion ---------------------------------------- Setters\n\n}\n\n"
    },
    "contracts/strategies/DepositorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @title Abstract base Depositor contract.\n/// @notice Converter strategies should inherit xDepositor.\n/// @notice All communication with external pools should be done at inherited contract\n/// @author bogdoslav\nabstract contract DepositorBase {\n\n  /// @notice Returns pool assets\n  function _depositorPoolAssets() internal virtual view returns (address[] memory assets);\n\n  /// @notice Returns pool token proportions\n  function _depositorPoolWeights() internal virtual view returns (uint[] memory weights, uint total);\n\n  /// @notice Returns pool token reserves\n  function _depositorPoolReserves() internal virtual view returns (uint[] memory reserves);\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() internal virtual view returns (uint);\n\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() internal view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @dev Depositor must care about tokens approval by itself.\n  function _depositorEnter(uint[] memory amountsDesired_) internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  );\n\n  /// @notice Withdraw given lp amount from the pool.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @notice Quotes output for given lp amount from the pool.\n  /// @dev Write function with read-only behavior. BalanceR's depositor requires not-view.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorQuoteExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @dev If pool supports emergency withdraw need to call it for emergencyExit()\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorEmergencyExit() internal virtual returns (uint[] memory amountsOut) {\n    return _depositorExit(_depositorLiquidity());\n  }\n\n  /// @notice Claim all possible rewards.\n  /// @return rewardTokens Claimed token addresses\n  /// @return rewardAmounts Claimed token amounts\n  /// @return depositorBalancesBefore Must have the same length as _depositorPoolAssets and represent balances before claim in the same order\n  function _depositorClaimRewards() internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    uint[] memory depositorBalancesBefore\n  );\n}\n"
    },
    "contracts/strategies/kyber/KyberConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./KyberDepositor.sol\";\nimport \"./KyberConverterStrategyLogicLib.sol\";\nimport \"../../libs/AppPlatforms.sol\";\nimport \"../../interfaces/IRebalancingStrategy.sol\";\nimport \"../../interfaces/IFarmingStrategy.sol\";\nimport \"./KyberStrategyErrors.sol\";\n\n\ncontract KyberConverterStrategy is KyberDepositor, ConverterStrategyBase, IRebalancingStrategy, IFarmingStrategy {\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  string public constant override NAME = \"Kyber Converter Strategy\";\n  string public constant override PLATFORM = AppPlatforms.KYBER;\n  string public constant override STRATEGY_VERSION = \"1.0.2\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                INIT\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize the strategy with the given parameters.\n  /// @param controller_ The address of the controller.\n  /// @param splitter_ The address of the splitter.\n  /// @param converter_ The address of the converter.\n  /// @param pool_ The address of the pool.\n  /// @param tickRange_ The tick range for the liquidity position.\n  /// @param rebalanceTickRange_ The tick range for rebalancing.\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address pool_,\n    int24 tickRange_,\n    int24 rebalanceTickRange_,\n    bool isStablePool,\n    uint pId\n  ) external initializer {\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n    KyberConverterStrategyLogicLib.initStrategyState(\n      state,\n      controller_,\n      converter_,\n      pool_,\n      tickRange_,\n      rebalanceTickRange_,\n      ISplitter(splitter_).asset(),\n      isStablePool\n    );\n\n    state.pId = pId;\n\n    // setup specific name for UI\n    strategySpecificName = KyberConverterStrategyLogicLib.createSpecificName(state);\n    emit StrategyLib.StrategySpecificNameChanged(strategySpecificName);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                OPERATOR ACTIONS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Disable fuse for the strategy.\n  function disableFuse() external {\n    StrategyLib.onlyOperators(controller());\n    state.isFuseTriggered = false;\n    state.lastPrice = ConverterStrategyBaseLib.getOracleAssetsPrice(converter, state.tokenA, state.tokenB);\n\n    KyberConverterStrategyLogicLib.emitDisableFuse();\n  }\n\n  function changePId(uint pId) external {\n    StrategyLib.onlyOperators(controller());\n    require(!state.staked, KyberStrategyErrors.NOT_UNSTAKED);\n    state.pId = pId;\n  }\n\n  /// @notice Set the fuse threshold for the strategy.\n  /// @param newFuseThreshold The new fuse threshold value.\n  function setFuseThreshold(uint newFuseThreshold) external {\n    StrategyLib.onlyOperators(controller());\n    state.fuseThreshold = newFuseThreshold;\n\n    KyberConverterStrategyLogicLib.emitNewFuseThreshold(newFuseThreshold);\n  }\n\n  function setStrategyProfitHolder(address strategyProfitHolder) external {\n    StrategyLib.onlyOperators(controller());\n    state.strategyProfitHolder = strategyProfitHolder;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   METRIC VIEWS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Check if the strategy needs rebalancing.\n  /// @return A boolean indicating if the strategy needs rebalancing.\n  function needRebalance() public view returns (bool) {\n    (bool needStake, bool needUnstake) = KyberConverterStrategyLogicLib.needRebalanceStaking(state);\n    return KyberConverterStrategyLogicLib.needRebalance(state) || needStake || needUnstake;\n  }\n\n  /// @return swapAtoB, swapAmount\n  function quoteRebalanceSwap() external returns (bool, uint) {\n    return KyberConverterStrategyLogicLib.quoteRebalanceSwap(state, converter);\n  }\n\n  function canFarm() external view returns (bool) {\n    return !KyberConverterStrategyLogicLib.isFarmEnded(state.pId);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   CALLBACKS\n  /////////////////////////////////////////////////////////////////////\n\n  function onERC721Received(\n    address,\n    address,\n    uint256,\n    bytes memory\n  ) external pure returns (bytes4) {\n    return this.onERC721Received.selector;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   REBALANCE\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev The rebalancing functionality is the core of this strategy.\n  ///      Swap method is used.\n  function rebalance() external {\n    (uint profitToCover, uint oldTotalAssets, address _controller) = _startRebalance();\n\n    // _depositorEnter(tokenAmounts) if length == 2\n    uint[] memory tokenAmounts = KyberConverterStrategyLogicLib.rebalance(\n      state,\n      converter,\n      _controller,\n      oldTotalAssets,\n      profitToCover,\n      splitter\n    );\n\n    if (tokenAmounts.length == 2) {\n      _depositorEnter(tokenAmounts);\n    }\n\n    //updating investedAssets based on new baseAmounts\n    _updateInvestedAssets();\n  }\n\n  function rebalanceSwapByAgg(bool direction, uint amount, address agg, bytes memory swapData) external {\n    (uint profitToCover, uint oldTotalAssets,) = _startRebalance();\n\n    // _depositorEnter(tokenAmounts) if length == 2\n    uint[] memory tokenAmounts = KyberConverterStrategyLogicLib.rebalanceSwapByAgg(\n      state,\n      converter,\n      oldTotalAssets,\n      KyberConverterStrategyLogicLib.RebalanceSwapByAggParams(\n        direction,\n        amount,\n        agg,\n        swapData\n      ),\n      profitToCover,\n      splitter\n    );\n\n    if (tokenAmounts.length == 2) {\n      _depositorEnter(tokenAmounts);\n    }\n\n    //updating investedAssets based on new baseAmounts\n    _updateInvestedAssets();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   INTERNAL LOGIC\n  /////////////////////////////////////////////////////////////////////\n\n  function _startRebalance() internal returns(uint profitToCover, uint oldTotalAssets,  address _controller) {\n    _controller = controller();\n    StrategyLib.onlyOperators(_controller);\n\n    require(needRebalance(), KyberStrategyErrors.NO_REBALANCE_NEEDED);\n\n    (, profitToCover) = _fixPriceChanges(true);\n    oldTotalAssets = totalAssets() - profitToCover;\n\n    KyberConverterStrategyLogicLib.claimRewardsBeforeExitIfRequired(state);\n\n    /// withdraw all liquidity from pool with adding calculated fees to rebalanceEarned0, rebalanceEarned1\n    /// after disableFuse() liquidity is zero\n    if (state.totalLiquidity > 0) {\n      _depositorEmergencyExit();\n    }\n  }\n\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory /*tokens_*/,\n    uint /*indexAsset_*/\n  ) override internal virtual returns (\n    uint[] memory tokenAmounts\n  ) {\n    require(!needRebalance(), KyberStrategyErrors.NEED_REBALANCE);\n\n    tokenAmounts = new uint[](2);\n    uint spentCollateral;\n\n    bytes memory entryData = KyberConverterStrategyLogicLib.getEntryData(\n      state.pool,\n      state.lowerTick,\n      state.upperTick,\n      state.depositorSwapTokens\n    );\n\n    AppLib.approveIfNeeded(state.tokenA, amount_, address(tetuConverter_));\n    (spentCollateral, tokenAmounts[1]) = ConverterStrategyBaseLib.openPosition(\n      tetuConverter_,\n      entryData,\n      state.tokenA,\n      state.tokenB,\n      amount_,\n      0\n    );\n\n    tokenAmounts[0] = amount_ - spentCollateral;\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  /// @return earned The amount of earned rewards.\n  /// @return lost The amount of lost rewards.\n  /// @return assetBalanceAfterClaim The asset balance after claiming rewards.\n  function _handleRewards() override internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    (address[] memory rewardTokens, uint[] memory amounts) = _claim();\n    earned = KyberConverterStrategyLogicLib.calcEarned(state.tokenA, controller(), rewardTokens, amounts);\n    _rewardsLiquidation(rewardTokens, amounts);\n    return (earned, lost, AppLib.balance(asset));\n  }\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amount_ The amount to be deposited.\n  /// @param updateTotalAssetsBeforeInvest_ A boolean indicating if the total assets should be updated before investing.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    uint strategyLoss\n  ) {\n    if (state.isFuseTriggered) {\n      uint[] memory tokenAmounts = new uint[](2);\n      tokenAmounts[0] = amount_;\n      emit OnDepositorEnter(tokenAmounts, tokenAmounts);\n      return 0;\n    } else {\n      return super._depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n    }\n  }\n\n  function _beforeWithdraw(uint /*amount*/) internal view override {\n    require(!needRebalance(), KyberStrategyErrors.NEED_REBALANCE);\n  }\n}\n"
    },
    "contracts/strategies/kyber/KyberConverterStrategyLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./KyberLib.sol\";\nimport \"./KyberDebtLib.sol\";\nimport \"./KyberStrategyErrors.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\nlibrary KyberConverterStrategyLogicLib {\n  using SafeERC20 for IERC20;\n\n  //////////////////////////////////////////\n  //            CONSTANTS\n  //////////////////////////////////////////\n\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_STABLE = 300;\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE = 500;\n  /// @dev 0.5% by default\n  uint internal constant DEFAULT_FUSE_THRESHOLD = 5e15;\n  IBasePositionManager internal constant KYBER_NFT = IBasePositionManager(0xe222fBE074A436145b255442D919E4E3A6c6a480);\n  IKyberSwapElasticLM internal constant FARMING_CENTER = IKyberSwapElasticLM(0x7D5ba536ab244aAA1EA42aB88428847F25E3E676);\n  ITicksFeesReader internal constant TICKS_FEES_READER = ITicksFeesReader(0x8Fd8Cb948965d9305999D767A02bf79833EADbB3);\n  address public constant KNC = 0x1C954E8fe737F99f68Fa1CCda3e51ebDB291948C;\n\n  //////////////////////////////////////////\n  //            EVENTS\n  //////////////////////////////////////////\n\n  event FuseTriggered();\n  event Rebalanced(uint loss, uint coveredByRewards);\n  event DisableFuse();\n  event NewFuseThreshold(uint newFuseThreshold);\n  event KyberFeesClaimed(uint fee0, uint fee1);\n  event KyberRewardsClaimed(uint reward);\n\n  //////////////////////////////////////////\n  //            STRUCTURES\n  //////////////////////////////////////////\n\n  struct State {\n    address strategyProfitHolder;\n    address tokenA;\n    address tokenB;\n    IPool pool;\n    int24 tickSpacing;\n    bool isStablePool;\n    int24 lowerTick;\n    int24 upperTick;\n    int24 rebalanceTickRange;\n    bool depositorSwapTokens;\n    uint128 totalLiquidity;\n    bool isFuseTriggered;\n    uint fuseThreshold;\n    uint lastPrice;\n    uint tokenId;\n    // farming\n    uint pId;\n    bool staked;\n  }\n\n  struct RebalanceSwapByAggParams {\n    bool direction;\n    uint amount;\n    address agg;\n    bytes swapData;\n  }\n\n  struct RebalanceLocalVariables {\n    int24 upperTick;\n    int24 lowerTick;\n    int24 tickSpacing;\n    IPool pool;\n    address tokenA;\n    address tokenB;\n    uint lastPrice;\n    uint fuseThreshold;\n    bool depositorSwapTokens;\n    uint notCoveredLoss;\n    int24 newLowerTick;\n    int24 newUpperTick;\n    bool isStablePool;\n    uint newPrice;\n    uint newTotalAssets;\n    bool needRebalance;\n  }\n\n  struct EnterLocalVariables {\n    IPool pool;\n    int24 upperTick;\n    int24 lowerTick;\n    uint tokenId;\n    uint pId;\n  }\n\n  struct ExitLocalVariables {\n    address strategyProfitHolder;\n    uint pId;\n    address tokenA;\n    address tokenB;\n  }\n\n  //////////////////////////////////////////\n  //            HELPERS\n  //////////////////////////////////////////\n\n  function emitDisableFuse() external {\n    emit DisableFuse();\n  }\n\n  function emitNewFuseThreshold(uint value) external {\n    emit NewFuseThreshold(value);\n  }\n\n  /// @notice Check if the fuse is enabled based on the price difference and fuse threshold.\n  /// @param oldPrice The old price.\n  /// @param newPrice The new price.\n  /// @param fuseThreshold The fuse threshold.\n  /// @return A boolean indicating if the fuse is enabled.\n  function isEnableFuse(uint oldPrice, uint newPrice, uint fuseThreshold) internal pure returns (bool) {\n    return oldPrice > newPrice ? (oldPrice - newPrice) > fuseThreshold : (newPrice - oldPrice) > fuseThreshold;\n  }\n\n  function initStrategyState(\n    State storage state,\n    address controller_,\n    address converter,\n    address pool,\n    int24 tickRange,\n    int24 rebalanceTickRange,\n    address asset_,\n    bool isStablePool\n  ) external {\n    require(pool != address(0), AppErrors.ZERO_ADDRESS);\n    state.pool = IPool(pool);\n\n    state.isStablePool = isStablePool;\n\n    state.rebalanceTickRange = rebalanceTickRange;\n\n    _setInitialDepositorValues(\n      state,\n      IPool(pool),\n      tickRange,\n      rebalanceTickRange,\n      asset_\n    );\n\n    address liquidator = IController(controller_).liquidator();\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    IERC20(tokenA).approve(liquidator, type(uint).max);\n    IERC20(tokenB).approve(liquidator, type(uint).max);\n    IERC20(tokenA).approve(address(KYBER_NFT), type(uint).max);\n    IERC20(tokenB).approve(address(KYBER_NFT), type(uint).max);\n    IERC721(address(KYBER_NFT)).setApprovalForAll(address(FARMING_CENTER), true);\n\n    if (isStablePool) {\n      /// for stable pools fuse can be enabled\n      state.fuseThreshold = DEFAULT_FUSE_THRESHOLD;\n      emit NewFuseThreshold(DEFAULT_FUSE_THRESHOLD);\n      state.lastPrice = ConverterStrategyBaseLib.getOracleAssetsPrice(ITetuConverter(converter), tokenA, tokenB);\n    }\n  }\n\n  function createSpecificName(State storage state) external view returns (string memory) {\n    return string(abi.encodePacked(\"Kyber \", IERC20Metadata(state.tokenA).symbol(), \"/\", IERC20Metadata(state.tokenB).symbol()));\n  }\n\n  function getPoolReserves(State storage state) external view returns (uint[] memory reserves) {\n    reserves = new uint[](2);\n    (uint160 sqrtRatioX96, , ,) = state.pool.getPoolState();\n\n    (reserves[0], reserves[1]) = KyberLib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTick,\n      state.upperTick,\n      state.totalLiquidity\n    );\n\n    if (state.depositorSwapTokens) {\n      (reserves[0], reserves[1]) = (reserves[1], reserves[0]);\n    }\n  }\n\n  /// @dev Gets the liquidator swap slippage based on the pool type (stable or volatile).\n  /// @return The liquidator swap slippage percentage.\n  function _getLiquidatorSwapSlippage(bool isStablePool) internal pure returns (uint) {\n    return isStablePool ? LIQUIDATOR_SWAP_SLIPPAGE_STABLE : LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE;\n  }\n\n  //////////////////////////////////////////\n  //            Pool info\n  //////////////////////////////////////////\n\n  function getEntryData(\n    IPool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    bool depositorSwapTokens\n  ) public view returns (bytes memory entryData) {\n    return KyberDebtLib.getEntryData(pool, lowerTick, upperTick, depositorSwapTokens);\n  }\n\n  //////////////////////////////////////////\n  //            CALCULATIONS\n  //////////////////////////////////////////\n\n  /// @notice Calculate and set the initial values for a QuickSwap V3 pool Depositor.\n  /// @param state Depositor storage state struct\n  /// @param pool The QuickSwap V3 pool to get the initial values from.\n  /// @param tickRange_ The tick range for the pool.\n  /// @param rebalanceTickRange_ The rebalance tick range for the pool.\n  /// @param asset_ Underlying asset of the depositor.\n  function _setInitialDepositorValues(\n    State storage state,\n    IPool pool,\n    int24 tickRange_,\n    int24 rebalanceTickRange_,\n    address asset_\n  ) internal {\n    int24 tickSpacing = KyberLib.getTickSpacing(pool);\n    if (tickRange_ != 0) {\n      require(tickRange_ == tickRange_ / tickSpacing * tickSpacing, KyberStrategyErrors.INCORRECT_TICK_RANGE);\n      require(rebalanceTickRange_ == rebalanceTickRange_ / tickSpacing * tickSpacing, KyberStrategyErrors.INCORRECT_REBALANCE_TICK_RANGE);\n    }\n    state.tickSpacing = tickSpacing;\n    (state.lowerTick, state.upperTick) = KyberDebtLib.calcTickRange(pool, tickRange_, tickSpacing);\n    address token0 = address(pool.token0());\n    address token1 = address(pool.token1());\n    require(asset_ == token0 || asset_ == token1, KyberStrategyErrors.INCORRECT_ASSET);\n    if (asset_ == token0) {\n      state.tokenA = token0;\n      state.tokenB = token1;\n      state.depositorSwapTokens = false;\n    } else {\n      state.tokenA = token1;\n      state.tokenB = token0;\n      state.depositorSwapTokens = true;\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Joins to the pool\n  //////////////////////////////////////////\n\n  function enter(\n    State storage state,\n    uint[] memory amountsDesired_\n  ) external returns (uint[] memory amountsConsumed, uint liquidityOut) {\n    EnterLocalVariables memory vars = EnterLocalVariables({\n      pool: state.pool,\n      lowerTick : state.lowerTick,\n      upperTick : state.upperTick,\n      tokenId : state.tokenId,\n      pId : state.pId\n    });\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    (address token0, address token1) = depositorSwapTokens ? (state.tokenB, state.tokenA) : (state.tokenA, state.tokenB);\n    if (depositorSwapTokens) {\n      (amountsDesired_[0], amountsDesired_[1]) = (amountsDesired_[1], amountsDesired_[0]);\n    }\n    amountsConsumed = new uint[](2);\n    uint128 liquidity;\n\n    if (vars.tokenId > 0) {\n      (IBasePositionManager.Position memory pos,) = KYBER_NFT.positions(vars.tokenId);\n      if (pos.tickLower != vars.lowerTick || pos.tickUpper != vars.upperTick) {\n        KYBER_NFT.burn(vars.tokenId);\n        vars.tokenId = 0;\n      }\n    }\n\n    if (vars.tokenId == 0) {\n      (vars.tokenId, liquidity, amountsConsumed[0], amountsConsumed[1]) = KYBER_NFT.mint(IBasePositionManager.MintParams(\n        token0,\n        token1,\n        state.pool.swapFeeUnits(),\n        vars.lowerTick,\n        vars.upperTick,\n        KyberLib.getPreviousTicks(vars.pool, vars.lowerTick, vars.upperTick),\n        amountsDesired_[0],\n        amountsDesired_[1],\n        0,\n        0,\n        address(this),\n        block.timestamp\n      ));\n\n      state.tokenId = vars.tokenId;\n\n      {\n        if (!isFarmEnded(vars.pId)) {\n          uint[] memory nftIds = new uint[](1);\n          nftIds[0] = vars.tokenId;\n          uint[] memory liqs = new uint[](1);\n          liqs[0] = uint(liquidity);\n          FARMING_CENTER.deposit(nftIds);\n          state.staked = true;\n          FARMING_CENTER.join(vars.pId, nftIds, liqs);\n        }\n      }\n    } else {\n      (liquidity, amountsConsumed[0], amountsConsumed[1],) = KYBER_NFT.addLiquidity(IBasePositionManager.IncreaseLiquidityParams(\n        vars.tokenId,\n        KyberLib.getPreviousTicks(vars.pool, vars.lowerTick, vars.upperTick),\n        amountsDesired_[0],\n        amountsDesired_[1],\n        0,\n        0,\n        block.timestamp\n      ));\n\n      if (!isFarmEnded(vars.pId)) {\n        uint[] memory nftIds = new uint[](1);\n        nftIds[0] = vars.tokenId;\n        if (state.totalLiquidity == 0) {\n          FARMING_CENTER.deposit(nftIds);\n          state.staked = true;\n        }\n\n        uint[] memory liqs = new uint[](1);\n        liqs[0] = uint(liquidity);\n        FARMING_CENTER.join(vars.pId, nftIds, liqs);\n      }\n    }\n\n    state.totalLiquidity += liquidity;\n    liquidityOut = uint(liquidity);\n  }\n\n  //////////////////////////////////////////\n  //            Exit from the pool\n  //////////////////////////////////////////\n\n  function exit(\n    State storage state,\n    uint128 liquidityAmountToExit\n  ) external returns (uint[] memory amountsOut) {\n    amountsOut = new uint[](2);\n\n    ExitLocalVariables memory vars = ExitLocalVariables({\n      strategyProfitHolder : state.strategyProfitHolder,\n      pId : state.pId,\n      tokenA : state.tokenA,\n      tokenB : state.tokenB\n    });\n\n    uint128 liquidity = state.totalLiquidity;\n\n    require(liquidity >= liquidityAmountToExit, KyberStrategyErrors.WRONG_LIQUIDITY);\n\n    bool staked = state.staked;\n\n    uint[] memory nftIds = new uint[](1);\n    nftIds[0] = state.tokenId;\n    uint[] memory liqs = new uint[](1);\n    uint feeA;\n    uint feeB;\n\n    // get rewards\n    if (staked) {\n      uint reward = _harvest(nftIds[0], vars.pId);\n      // send to profit holder\n      if (reward > 0) {\n        IERC20(KNC).safeTransfer(vars.strategyProfitHolder, reward);\n      }\n\n      // get fees\n      // when exiting, fees are collected twice so as not to lose anything when rebalancing (the position goes out of range)\n      (feeA, feeB) = _claimFees(state);\n\n      liqs[0] = uint(liquidity);\n\n      FARMING_CENTER.exit(vars.pId, nftIds, liqs);\n\n      // withdraw\n      FARMING_CENTER.withdraw(nftIds);\n      state.staked = false;\n    }\n\n    // burn liquidity\n    uint rTokensOwed;\n    (amountsOut[0], amountsOut[1], rTokensOwed) = KYBER_NFT.removeLiquidity(IBasePositionManager.RemoveLiquidityParams(nftIds[0], liquidityAmountToExit, 0, 0, block.timestamp));\n\n    if (rTokensOwed > 0) {\n      (,uint amount0, uint amount1) = KYBER_NFT.burnRTokens(IBasePositionManager.BurnRTokenParams(nftIds[0], 0, 0, block.timestamp));\n      if (state.depositorSwapTokens) {\n        feeA += amount1;\n        feeB += amount0;\n        emit KyberFeesClaimed(amount1, amount0);\n      } else {\n        feeA += amount0;\n        feeB += amount1;\n        emit KyberFeesClaimed(amount0, amount1);\n      }\n    }\n\n    // transfer tokens\n    KYBER_NFT.transferAllTokens(vars.tokenA, 0, address(this));\n    KYBER_NFT.transferAllTokens(vars.tokenB, 0, address(this));\n\n    // send fees to profit holder\n    if (feeA > 0) {\n      IERC20(vars.tokenA).safeTransfer(vars.strategyProfitHolder, feeA);\n    }\n    if (feeB > 0) {\n      IERC20(vars.tokenB).safeTransfer(vars.strategyProfitHolder, feeB);\n    }\n\n    liquidity -= liquidityAmountToExit;\n    state.totalLiquidity = liquidity;\n\n    if (liquidity > 0 && !isFarmEnded(vars.pId)) {\n      liqs[0] = uint(liquidity);\n      FARMING_CENTER.deposit(nftIds);\n      state.staked = true;\n      FARMING_CENTER.join(vars.pId, nftIds, liqs);\n    }\n  }\n\n  function quoteExit(\n    State storage state,\n    uint128 liquidityAmountToExit\n  ) public view returns (uint[] memory amountsOut) {\n    (uint160 sqrtRatioX96, , ,) = state.pool.getPoolState();\n    amountsOut = new uint[](2);\n    (amountsOut[0], amountsOut[1]) = KyberLib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTick,\n      state.upperTick,\n      liquidityAmountToExit\n    );\n    if (state.depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Rewards\n  //////////////////////////////////////////\n\n  function claimRewardsBeforeExitIfRequired(State storage state) external {\n    (,bool needUnstake) = needRebalanceStaking(state);\n    if (needUnstake) {\n      claimRewards(state);\n    }\n  }\n\n  function claimRewards(State storage state) public returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut,\n    uint[] memory balancesBefore\n  ) {\n    address strategyProfitHolder = state.strategyProfitHolder;\n    uint tokenId = state.tokenId;\n    tokensOut = new address[](3);\n    tokensOut[0] = state.tokenA;\n    tokensOut[1] = state.tokenB;\n    tokensOut[2] = KNC;\n\n    balancesBefore = new uint[](3);\n    for (uint i; i < tokensOut.length; i++) {\n      balancesBefore[i] = AppLib.balance(tokensOut[i]);\n    }\n\n    amountsOut = new uint[](3);\n    if (tokenId > 0 && state.totalLiquidity > 0) {\n      (amountsOut[0], amountsOut[1]) = _claimFees(state);\n      amountsOut[2] = _harvest(tokenId, state.pId);\n    }\n\n    for (uint i; i < tokensOut.length; ++i) {\n      uint b = IERC20(tokensOut[i]).balanceOf(strategyProfitHolder);\n      if (b > 0) {\n        IERC20(tokensOut[i]).transferFrom(strategyProfitHolder, address(this), b);\n        amountsOut[i] += b;\n      }\n    }\n  }\n\n  function _claimFees(State storage state) internal returns (uint amountA, uint amountB) {\n    uint[] memory nftIds = new uint[](1);\n    nftIds[0] = state.tokenId;\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    uint bABefore = AppLib.balance(tokenA);\n    uint bBBefore = AppLib.balance(tokenB);\n\n    (uint token0Owed, uint token1Owed) = TICKS_FEES_READER.getTotalFeesOwedToPosition(address(KYBER_NFT), address(state.pool), nftIds[0]);\n    if (token0Owed > 0 || token1Owed > 0) {\n      FARMING_CENTER.claimFee(nftIds, 0, 0, address(state.pool), false, block.timestamp);\n\n      amountA = AppLib.balance(tokenA) - bABefore;\n      amountB = AppLib.balance(tokenB) - bBBefore;\n      emit KyberFeesClaimed(amountA, amountB);\n    }\n  }\n\n  function _harvest(uint tokenId, uint pId) internal returns (uint amount) {\n    uint[] memory nftIds = new uint[](1);\n    nftIds[0] = tokenId;\n    uint[] memory pids = new uint[](1);\n    pids[0] = pId;\n    IKyberSwapElasticLM.HarvestData memory data = IKyberSwapElasticLM.HarvestData({\n      pIds: pids\n    });\n    bytes[] memory datas = new bytes[](1);\n    datas[0] = abi.encode(data);\n    uint bBefore = AppLib.balance(KNC);\n    FARMING_CENTER.harvestMultiplePools(nftIds, datas);\n    amount = AppLib.balance(KNC) - bBefore;\n    if (amount > 0) {\n      emit KyberRewardsClaimed(amount);\n    }\n  }\n\n  function calcEarned(address asset, address controller, address[] memory rewardTokens, uint[] memory amounts) external view returns (uint) {\n    ITetuLiquidator liquidator = ITetuLiquidator(IController(controller).liquidator());\n    uint len = rewardTokens.length;\n    uint earned;\n    for (uint i; i < len; ++i) {\n      address token = rewardTokens[i];\n      if (token == asset) {\n        earned += amounts[i];\n      } else {\n        earned += liquidator.getPrice(rewardTokens[i], asset, amounts[i]);\n      }\n    }\n\n    return earned;\n  }\n\n  //////////////////////////////////////////\n  //            Rebalance\n  //////////////////////////////////////////\n\n  function needRebalance(State storage state) public view returns (bool) {\n    if (state.isFuseTriggered) {\n      return false;\n    }\n\n    (, int24 tick, ,) = state.pool.getPoolState();\n    int24 upperTick = state.upperTick;\n    int24 lowerTick = state.lowerTick;\n    if (upperTick - lowerTick == state.tickSpacing) {\n      return tick < lowerTick || tick >= upperTick;\n    } else {\n      int24 halfRange = (upperTick - lowerTick) / 2;\n      int24 oldMedianTick = lowerTick + halfRange;\n      if (tick > oldMedianTick) {\n        return tick - oldMedianTick >= state.rebalanceTickRange;\n      }\n      return oldMedianTick - tick > state.rebalanceTickRange;\n    }\n  }\n\n  function needRebalanceStaking(State storage state) public view returns (bool needStake, bool needUnstake) {\n    bool farmEnded = isFarmEnded(state.pId);\n    bool haveLiquidity = state.totalLiquidity > 0;\n    bool staked = state.staked;\n    needStake = haveLiquidity && !farmEnded && !staked;\n    needUnstake = haveLiquidity && farmEnded && staked;\n  }\n\n  function isFarmEnded(uint pId) public view returns(bool) {\n    (,,uint endTime,,,,,) = FARMING_CENTER.getPoolInfo(pId);\n    return endTime < block.timestamp;\n  }\n\n  function quoteRebalanceSwap(State storage state, ITetuConverter converter) external returns (bool, uint) {\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    uint debtAmount = KyberDebtLib.getDebtTotalDebtAmountOut(converter, tokenA, tokenB);\n\n    if (\n      !needRebalance(state)\n      || !KyberDebtLib.needCloseDebt(debtAmount, converter, tokenB)\n    ) {\n      return (false, 0);\n    }\n\n    uint[] memory amountsOut = quoteExit(state, state.totalLiquidity);\n    amountsOut[0] += AppLib.balance(tokenA);\n    amountsOut[1] += AppLib.balance(tokenB);\n\n    if (amountsOut[1] < debtAmount) {\n      uint tokenBprice = KyberLib.getPrice(address(state.pool), tokenB);\n      uint needToSellTokenA = tokenBprice * (debtAmount - amountsOut[1]) / 10 ** IERC20Metadata(tokenB).decimals();\n      // add 1% gap for price impact\n      needToSellTokenA += needToSellTokenA / KyberDebtLib.SELL_GAP;\n      if (amountsOut[0] > 0) {\n        needToSellTokenA = Math.min(needToSellTokenA, amountsOut[0] - 1);\n      } else {\n        needToSellTokenA = 0;\n      }\n      return (true, needToSellTokenA);\n    } else {\n      return (false, amountsOut[1] - debtAmount);\n    }\n  }\n\n  function rebalance(\n    State storage state,\n    ITetuConverter converter,\n    address controller,\n    uint oldTotalAssets,\n    uint profitToCover,\n    address splitter\n  ) external returns (\n    uint[] memory tokenAmounts // _depositorEnter(tokenAmounts) if length == 2\n  ) {\n    uint loss;\n    tokenAmounts = new uint[](0);\n\n    RebalanceLocalVariables memory vars = RebalanceLocalVariables({\n      upperTick: state.upperTick,\n      lowerTick: state.lowerTick,\n      tickSpacing: state.tickSpacing,\n      pool: state.pool,\n      tokenA: state.tokenA,\n      tokenB: state.tokenB,\n      lastPrice: state.lastPrice,\n      fuseThreshold: state.fuseThreshold,\n      depositorSwapTokens: state.depositorSwapTokens,\n    // setup initial values\n      notCoveredLoss: 0,\n      newLowerTick: 0,\n      newUpperTick: 0,\n      isStablePool: state.isStablePool,\n      newPrice: 0,\n      newTotalAssets: 0,\n      needRebalance : needRebalance(state)\n    });\n\n    if (vars.needRebalance) {\n      vars.newPrice = ConverterStrategyBaseLib.getOracleAssetsPrice(converter, vars.tokenA, vars.tokenB);\n\n      if (vars.isStablePool && isEnableFuse(vars.lastPrice, vars.newPrice, vars.fuseThreshold)) {\n        /// enabling fuse: close debt and stop providing liquidity\n        state.isFuseTriggered = true;\n        emit FuseTriggered();\n\n        KyberDebtLib.closeDebt(\n          converter,\n          controller,\n          vars.pool,\n          vars.tokenA,\n          vars.tokenB,\n          _getLiquidatorSwapSlippage(vars.isStablePool),\n          profitToCover,\n          oldTotalAssets,\n          splitter\n        );\n      } else {\n        /// rebalancing debt\n        /// setting new tick range\n        KyberDebtLib.rebalanceDebt(\n          converter,\n          controller,\n          state,\n          _getLiquidatorSwapSlippage(vars.isStablePool),\n          profitToCover,\n          oldTotalAssets,\n          splitter\n        );\n\n        tokenAmounts = new uint[](2);\n        tokenAmounts[0] = AppLib.balance(vars.tokenA);\n        tokenAmounts[1] = AppLib.balance(vars.tokenB);\n\n        address[] memory tokens = new address[](2);\n        tokens[0] = vars.tokenA;\n        tokens[1] = vars.tokenB;\n        uint[] memory amounts = new uint[](2);\n        amounts[0] = tokenAmounts[0];\n        vars.newTotalAssets = ConverterStrategyBaseLib.calcInvestedAssets(tokens, amounts, 0, converter);\n        if (vars.newTotalAssets < oldTotalAssets) {\n          loss = oldTotalAssets - vars.newTotalAssets;\n        }\n      }\n\n      // need to update last price only for stables coz only stables have fuse mechanic\n      if (vars.isStablePool) {\n        state.lastPrice = vars.newPrice;\n      }\n\n      uint covered;\n      if (loss > 0) {\n        covered = KyberDebtLib.coverLossFromRewards(loss, state.strategyProfitHolder, vars.tokenA, vars.tokenB, address(vars.pool));\n        uint notCovered = loss - covered;\n        if (notCovered > 0) {\n          ISplitter(splitter).coverPossibleStrategyLoss(0, notCovered);\n        }\n      }\n\n      emit Rebalanced(loss, covered);\n    } else {\n      tokenAmounts = new uint[](2);\n      tokenAmounts[0] = AppLib.balance(vars.tokenA);\n      tokenAmounts[1] = AppLib.balance(vars.tokenB);\n    }\n  }\n\n  function rebalanceSwapByAgg(\n    State storage state,\n    ITetuConverter converter,\n    uint oldTotalAssets,\n    RebalanceSwapByAggParams memory aggParams,\n    uint profitToCover,\n    address splitter\n  ) external returns (\n    uint[] memory tokenAmounts // _depositorEnter(tokenAmounts) if length == 2\n  ) {\n    uint loss;\n    tokenAmounts = new uint[](0);\n\n    RebalanceLocalVariables memory vars = RebalanceLocalVariables({\n      upperTick: state.upperTick,\n      lowerTick: state.lowerTick,\n      tickSpacing: state.tickSpacing,\n      pool: state.pool,\n      tokenA: state.tokenA,\n      tokenB: state.tokenB,\n      lastPrice: state.lastPrice,\n      fuseThreshold: state.fuseThreshold,\n      depositorSwapTokens: state.depositorSwapTokens,\n    // setup initial values\n      notCoveredLoss: 0,\n      newLowerTick: 0,\n      newUpperTick: 0,\n      isStablePool: state.isStablePool,\n      newPrice: 0,\n      newTotalAssets: 0,\n      needRebalance : needRebalance(state)\n    });\n\n    if (vars.needRebalance) {\n      vars.newPrice = ConverterStrategyBaseLib.getOracleAssetsPrice(converter, vars.tokenA, vars.tokenB);\n\n      if (vars.isStablePool && isEnableFuse(vars.lastPrice, vars.newPrice, vars.fuseThreshold)) {\n        /// enabling fuse: close debt and stop providing liquidity\n        state.isFuseTriggered = true;\n        emit FuseTriggered();\n\n        KyberDebtLib.closeDebtByAgg(\n          converter,\n          vars.tokenA,\n          vars.tokenB,\n          _getLiquidatorSwapSlippage(vars.isStablePool),\n          aggParams,\n          profitToCover,\n          oldTotalAssets,\n          splitter\n        );\n      } else {\n        /// rebalancing debt\n        /// setting new tick range\n        KyberDebtLib.rebalanceDebtSwapByAgg(\n          converter,\n          state,\n          _getLiquidatorSwapSlippage(vars.isStablePool),\n          aggParams,\n          profitToCover,\n          oldTotalAssets,\n          splitter\n        );\n\n        if (oldTotalAssets > 0) {\n          tokenAmounts = new uint[](2);\n          tokenAmounts[0] = AppLib.balance(vars.tokenA);\n          tokenAmounts[1] = AppLib.balance(vars.tokenB);\n\n          address[] memory tokens = new address[](2);\n          tokens[0] = vars.tokenA;\n          tokens[1] = vars.tokenB;\n          uint[] memory amounts = new uint[](2);\n          amounts[0] = tokenAmounts[0];\n          vars.newTotalAssets = ConverterStrategyBaseLib.calcInvestedAssets(tokens, amounts, 0, converter);\n          if (vars.newTotalAssets < oldTotalAssets) {\n            loss = oldTotalAssets - vars.newTotalAssets;\n          }\n        }\n      }\n\n      // need to update last price only for stables coz only stables have fuse mechanic\n      if (vars.isStablePool) {\n        state.lastPrice = vars.newPrice;\n      }\n\n      uint covered;\n      if (loss > 0) {\n        covered = KyberDebtLib.coverLossFromRewards(loss, state.strategyProfitHolder, vars.tokenA, vars.tokenB, address(vars.pool));\n        uint notCovered = loss - covered;\n        if (notCovered > 0) {\n          ISplitter(splitter).coverPossibleStrategyLoss(0, notCovered);\n        }\n      }\n\n      emit Rebalanced(loss, covered);\n    } else {\n      tokenAmounts = new uint[](2);\n      tokenAmounts[0] = AppLib.balance(vars.tokenA);\n      tokenAmounts[1] = AppLib.balance(vars.tokenB);\n    }\n  }\n}"
    },
    "contracts/strategies/kyber/KyberDebtLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBaseLib.sol\";\nimport \"../ConverterStrategyBaseLib2.sol\";\nimport \"./KyberLib.sol\";\nimport \"./KyberStrategyErrors.sol\";\nimport \"./KyberConverterStrategyLogicLib.sol\";\n\nlibrary KyberDebtLib {\n  using SafeERC20 for IERC20;\n\n  uint public constant SELL_GAP = 100;\n  address internal constant ONEINCH = 0x1111111254EEB25477B68fb85Ed929f73A960582; // 1inch router V5\n  address internal constant OPENOCEAN = 0x6352a56caadC4F1E25CD6c75970Fa768A3304e64; // OpenOceanExchangeProxy\n\n  function calcTickRange(IPool pool, int24 tickRange, int24 tickSpacing) public view returns (int24 lowerTick, int24 upperTick) {\n    (, int24 tick, ,) = pool.getPoolState();\n    if (tick < 0 && tick / tickSpacing * tickSpacing != tick) {\n      lowerTick = ((tick - tickRange) / tickSpacing - 1) * tickSpacing;\n    } else {\n      lowerTick = (tick - tickRange) / tickSpacing * tickSpacing;\n    }\n    upperTick = tickRange == 0 ? lowerTick + tickSpacing : lowerTick + tickRange * 2;\n  }\n\n  function getEntryData(\n    IPool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    bool depositorSwapTokens\n  ) public view returns (bytes memory entryData) {\n    address token1 = address(pool.token1());\n    uint token1Price = KyberLib.getPrice(address(pool), token1);\n\n    uint token1Decimals = IERC20Metadata(token1).decimals();\n\n    uint token0Desired = token1Price;\n    uint token1Desired = 10 ** token1Decimals;\n\n    // calculate proportions\n    (uint consumed0, uint consumed1,) = KyberLib.addLiquidityPreview(address(pool), lowerTick, upperTick, token0Desired, token1Desired);\n\n    if (depositorSwapTokens) {\n      entryData = abi.encode(1, consumed1 * token1Price / token1Desired, consumed0);\n    } else {\n      entryData = abi.encode(1, consumed0, consumed1 * token1Price / token1Desired);\n    }\n  }\n\n  /// @dev Closes the debt positions for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param controller The controller address.\n  /// @param pool The IUniswapV3Pool instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  function closeDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    IPool pool,\n    address tokenA,\n    address tokenB,\n    uint liquidatorSwapSlippage,\n    uint profitToCover,\n    uint totalAssets,\n    address splitter\n  ) public {\n    _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, liquidatorSwapSlippage);\n    if (profitToCover > 0) {\n      ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n    }\n  }\n\n  function closeDebtByAgg(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    uint liquidatorSwapSlippage,\n    KyberConverterStrategyLogicLib.RebalanceSwapByAggParams memory aggParams,\n    uint profitToCover,\n    uint totalAssets,\n    address splitter\n  ) public {\n    _closeDebtByAgg(tetuConverter, tokenA, tokenB, liquidatorSwapSlippage, aggParams);\n    if (profitToCover > 0) {\n      ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n    }\n  }\n\n  /// @dev Rebalances the debt by either filling up or closing and reopening debt positions. Sets new tick range.\n  function rebalanceDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    KyberConverterStrategyLogicLib.State storage state,\n    uint liquidatorSwapSlippage,\n    uint profitToCover,\n    uint totalAssets,\n    address splitter\n  ) external {\n    IPool pool = state.pool;\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, liquidatorSwapSlippage);\n    if (profitToCover > 0) {\n      ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n    }\n    (int24 newLowerTick, int24 newUpperTick) = _calcNewTickRange(pool, state.lowerTick, state.upperTick, state.tickSpacing);\n    bytes memory entryData = getEntryData(pool, newLowerTick, newUpperTick, depositorSwapTokens);\n    _openDebt(tetuConverter, tokenA, tokenB, entryData);\n    state.lowerTick = newLowerTick;\n    state.upperTick = newUpperTick;\n  }\n\n  function rebalanceDebtSwapByAgg(\n    ITetuConverter tetuConverter,\n    KyberConverterStrategyLogicLib.State storage state,\n    uint liquidatorSwapSlippage,\n    KyberConverterStrategyLogicLib.RebalanceSwapByAggParams memory aggParams,\n    uint profitToCover,\n    uint totalAssets,\n    address splitter\n  ) external {\n    IPool pool = state.pool;\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    _closeDebtByAgg(tetuConverter, tokenA, tokenB, liquidatorSwapSlippage, aggParams);\n    if (profitToCover > 0) {\n      ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets);\n    }\n    (int24 newLowerTick, int24 newUpperTick) = _calcNewTickRange(pool, state.lowerTick, state.upperTick, state.tickSpacing);\n    bytes memory entryData = getEntryData(pool, newLowerTick, newUpperTick, depositorSwapTokens);\n    _openDebt(tetuConverter, tokenA, tokenB, entryData);\n    state.lowerTick = newLowerTick;\n    state.upperTick = newUpperTick;\n  }\n\n  /// @dev Returns the total debt amount out for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  /// @return totalDebtAmountOut The total debt amount out for the token pair.\n  function getDebtTotalDebtAmountOut(ITetuConverter tetuConverter, address tokenA, address tokenB) public returns (uint totalDebtAmountOut) {\n    (totalDebtAmountOut,) = tetuConverter.getDebtAmountCurrent(address(this), tokenA, tokenB, true);\n  }\n\n  /// @dev we close debt only if it is more than $0.1\n  function needCloseDebt(uint debtAmount, ITetuConverter tetuConverter, address tokenB) public view returns (bool) {\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter.controller()).priceOracle());\n    return debtAmount * priceOracle.getAssetPrice(tokenB) / 10 ** IERC20Metadata(tokenB).decimals() > 1e17;\n  }\n\n  function coverLossFromRewards(uint loss, address strategyProfitHolder, address tokenA, address tokenB, address pool) external returns (uint covered) {\n    uint bA = IERC20Metadata(tokenA).balanceOf(strategyProfitHolder);\n    uint bB = IERC20Metadata(tokenB).balanceOf(strategyProfitHolder);\n\n    if (loss <= bA) {\n      IERC20(tokenA).safeTransferFrom(strategyProfitHolder, address(this), loss);\n      covered = loss;\n    } else {\n      uint needToCoverA = loss;\n      if (bA > 0) {\n        IERC20(tokenA).safeTransferFrom(strategyProfitHolder, address(this), bA);\n        needToCoverA -= bA;\n      }\n      if (bB > 0) {\n        uint needTransferB = KyberLib.getPrice(pool, tokenA) * needToCoverA / 10 ** IERC20Metadata(tokenA).decimals();\n        uint canTransferB = Math.min(needTransferB, bB);\n        IERC20(tokenB).safeTransferFrom(strategyProfitHolder, address(this), canTransferB);\n        needToCoverA -= needToCoverA * canTransferB / needTransferB;\n      }\n      covered = loss - needToCoverA;\n    }\n  }\n\n  /// @notice Calculate the new tick range for a Kyber pool.\n  /// @param pool The Kyber pool to calculate the new tick range for.\n  /// @param lowerTick The current lower tick value for the pool.\n  /// @param upperTick The current upper tick value for the pool.\n  /// @param tickSpacing The tick spacing for the pool.\n  /// @return lowerTickNew The new lower tick value for the pool.\n  /// @return upperTickNew The new upper tick value for the pool.\n  function _calcNewTickRange(\n    IPool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing\n  ) internal view returns (int24 lowerTickNew, int24 upperTickNew) {\n    int24 fullTickRange = upperTick - lowerTick;\n    (lowerTickNew, upperTickNew) = calcTickRange(pool, fullTickRange == tickSpacing ? int24(0) : fullTickRange / 2, tickSpacing);\n  }\n\n  /// @dev Opens a new debt position using entry data.\n  /// @param tetuConverter The TetuConverter contract.\n  /// @param tokenA The address of token A.\n  /// @param tokenB The address of token B.\n  /// @param entryData The data required to open a position.\n  function _openDebt(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    bytes memory entryData/*,\n    uint feeA*/\n  ) internal {\n    ConverterStrategyBaseLib.openPosition(\n      tetuConverter,\n      entryData,\n      tokenA,\n      tokenB,\n      AppLib.balance(tokenA)/* - feeA*/,\n      0\n    );\n  }\n\n  /// @notice Closes debt by liquidating tokens as necessary.\n  ///         This function helps ensure that the converter strategy maintains the appropriate balances\n  ///         and debt positions for token A and token B, while accounting for potential price impacts.\n  function _closeDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    IPool pool,\n    address tokenA,\n    address tokenB,\n    uint liquidatorSwapSlippage\n  ) internal {\n    uint debtAmount = getDebtTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n\n    if (needCloseDebt(debtAmount, tetuConverter, tokenB)) {\n      uint availableBalanceTokenA = AppLib.balance(tokenA);\n      uint availableBalanceTokenB = AppLib.balance(tokenB);\n\n      if (availableBalanceTokenB < debtAmount) {\n        uint tokenBprice = KyberLib.getPrice(address(pool), tokenB);\n        uint needToSellTokenA = tokenBprice * (debtAmount - availableBalanceTokenB) / 10 ** IERC20Metadata(tokenB).decimals();\n        // add 1% gap for price impact\n        needToSellTokenA += needToSellTokenA / SELL_GAP;\n\n        ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, Math.min(needToSellTokenA, availableBalanceTokenA), liquidatorSwapSlippage, 0, false);\n        availableBalanceTokenB = AppLib.balance(tokenB);\n      }\n\n      ConverterStrategyBaseLib.closePosition(\n        tetuConverter,\n        tokenA,\n        tokenB,\n        Math.min(debtAmount, availableBalanceTokenB)\n      );\n\n      availableBalanceTokenB = AppLib.balance(tokenB);\n      ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenB, tokenA, availableBalanceTokenB, liquidatorSwapSlippage, 0, false);\n    }\n  }\n\n  function _closeDebtByAgg(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    uint liquidatorSwapSlippage,\n    KyberConverterStrategyLogicLib.RebalanceSwapByAggParams memory aggParams\n  ) internal {\n    _checkSwapRouter(aggParams.agg);\n\n    uint debtAmount = getDebtTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n\n    if (needCloseDebt(debtAmount, tetuConverter, tokenB)) {\n      uint balanceTokenABefore = AppLib.balance(tokenA);\n      uint balanceTokenBBefore = AppLib.balance(tokenB);\n\n      address tokenIn = aggParams.direction ? tokenA : tokenB;\n\n      AppLib.approveIfNeeded(tokenIn, aggParams.amount, aggParams.agg);\n\n      {\n        (bool success, bytes memory result) = aggParams.agg.call(aggParams.swapData);\n        require(success, string(result));\n      }\n\n      uint availableBalanceTokenA = AppLib.balance(tokenA);\n      uint availableBalanceTokenB = AppLib.balance(tokenB);\n\n      require(\n        tetuConverter.isConversionValid(\n          tokenIn,\n          aggParams.amount,\n          aggParams.direction ? tokenB : tokenA,\n          aggParams.direction ? availableBalanceTokenB - balanceTokenBBefore : availableBalanceTokenA - balanceTokenABefore,\n          liquidatorSwapSlippage\n        ), AppErrors.PRICE_IMPACT);\n\n      ConverterStrategyBaseLib.closePosition(\n        tetuConverter,\n        tokenA,\n        tokenB,\n        Math.min(debtAmount, availableBalanceTokenB)\n      );\n\n      availableBalanceTokenB = AppLib.balance(tokenB);\n    }\n  }\n\n  function _checkSwapRouter(address router) internal pure {\n    require(router == ONEINCH || router == OPENOCEAN, KyberStrategyErrors.UNKNOWN_SWAP_ROUTER);\n  }\n}"
    },
    "contracts/strategies/kyber/KyberDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"../DepositorBase.sol\";\nimport \"./KyberStrategyErrors.sol\";\nimport \"./KyberConverterStrategyLogicLib.sol\";\n\n\nabstract contract KyberDepositor is DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant KYBER_DEPOSITOR_VERSION = \"1.0.0\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                VARIABLES\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev State variable to store the current state of the whole strategy\n  KyberConverterStrategyLogicLib.State internal state;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns the current state of the contract.\n  function getState() external view returns (\n    address tokenA,\n    address tokenB,\n    address profitHolder,\n    IPool pool,\n    uint128 totalLiquidity,\n    uint fuseThreshold,\n    int24[] memory ticks,\n    uint[] memory profitHolderBalances,\n    bool[] memory flags\n  ) {\n    tokenA = state.tokenA;\n    tokenB = state.tokenB;\n    pool = state.pool;\n    ticks = new int24[](4);\n    ticks[0] = state.lowerTick;\n    ticks[1] = state.upperTick;\n    ticks[2] = state.tickSpacing;\n    ticks[3] = state.rebalanceTickRange;\n    totalLiquidity = state.totalLiquidity;\n    fuseThreshold = state.fuseThreshold;\n    profitHolder = state.strategyProfitHolder;\n    profitHolderBalances = new uint[](3);\n    profitHolderBalances[0] = IERC20(tokenA).balanceOf(profitHolder);\n    profitHolderBalances[1] = IERC20(tokenB).balanceOf(profitHolder);\n    profitHolderBalances[2] = IERC20(KyberConverterStrategyLogicLib.KNC).balanceOf(profitHolder);\n    flags = new bool[](4);\n    flags[0] = state.isFuseTriggered;\n    flags[1] = state.staked;\n    (flags[2], flags[3]) = KyberConverterStrategyLogicLib.needRebalanceStaking(state);\n  }\n\n  /// @notice Returns the pool assets.\n  /// @return poolAssets An array containing the addresses of the pool assets.\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    poolAssets = new address[](2);\n    poolAssets[0] = state.tokenA;\n    poolAssets[1] = state.tokenB;\n  }\n\n  /// @notice Returns the pool weights and the total weight.\n  /// @return weights An array containing the weights of the pool assets, and totalWeight the sum of the weights.\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    weights = new uint[](2);\n    weights[0] = 1;\n    weights[1] = 1;\n    totalWeight = 2;\n  }\n\n  /// @notice Returns the pool reserves.\n  /// @return reserves An array containing the reserves of the pool assets.\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    return KyberConverterStrategyLogicLib.getPoolReserves(state);\n  }\n\n  /// @notice Returns the current liquidity of the depositor.\n  /// @return The current liquidity of the depositor.\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return uint(state.totalLiquidity);\n  }\n\n  /// @notice Returns the total supply of the depositor.\n  /// @return In UniV3 we can not calculate the total supply of the wgole pool. Return only ourself value.\n  function _depositorTotalSupply() override internal view virtual returns (uint) {\n    return uint(state.totalLiquidity);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Handles the deposit operation.\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (uint[] memory amountsConsumed, uint liquidityOut) {\n    (amountsConsumed, liquidityOut) = KyberConverterStrategyLogicLib.enter(state, amountsDesired_);\n  }\n\n  /// @notice Handles the withdrawal operation.\n  /// @param liquidityAmount The amount of liquidity to be withdrawn.\n  /// @return amountsOut The amounts of the tokens withdrawn.\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    amountsOut = KyberConverterStrategyLogicLib.exit(state, uint128(liquidityAmount));\n  }\n\n  /// @notice Returns the amount of tokens that would be withdrawn based on the provided liquidity amount.\n  /// @param liquidityAmount The amount of liquidity to quote the withdrawal for.\n  /// @return amountsOut The amounts of the tokens that would be withdrawn.\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    amountsOut = KyberConverterStrategyLogicLib.quoteExit(state, uint128(liquidityAmount));\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claims all possible rewards.\n  /// @return tokensOut An array containing the addresses of the reward tokens,\n  /// @return amountsOut An array containing the amounts of the reward tokens.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut,\n    uint[] memory balancesBefore\n  ) {\n    return KyberConverterStrategyLogicLib.claimRewards(state);\n  }\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[50 - 1] private __gap; // 50 - count of variables\n\n}\n"
    },
    "contracts/strategies/kyber/KyberLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/kyber/IPool.sol\";\nimport \"../../integrations/kyber/IBasePositionManager.sol\";\nimport \"../../integrations/kyber/IKyberSwapElasticLM.sol\";\nimport \"../../integrations/kyber/ITicksFeesReader.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\n\nlibrary KyberLib {\n  uint8 internal constant RESOLUTION = 96;\n  uint internal constant Q96 = 0x1000000000000000000000000;\n  uint private constant TWO_96 = 2 ** 96;\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n  int24 internal constant MIN_TICK = - 887272;\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n  int24 internal constant MAX_TICK = - MIN_TICK;\n\n  function getPreviousTicks(IPool pool, int24 tickLower, int24 tickUpper) external view returns (int24[2] memory ticks) {\n    (ticks[0],) = _getNearestInitializedTicks(pool, tickLower);\n    (ticks[1],) = _getNearestInitializedTicks(pool, tickUpper);\n  }\n\n  function _getNearestInitializedTicks(IPool pool, int24 tick) internal view returns (int24 previous, int24 next) {\n    require(MIN_TICK <= tick && tick <= MAX_TICK, 'tick not in range');\n    // if queried tick already initialized, fetch and return values\n    (previous, next) = pool.initializedTicks(tick);\n    if (previous != 0 || next != 0) return (previous, next);\n\n    // search downtick from MAX_TICK\n    if (tick > 0) {\n      previous = MAX_TICK;\n      while (previous > tick) {\n        (previous, ) = pool.initializedTicks(previous);\n      }\n      (, next) = pool.initializedTicks(previous);\n    } else {\n      // search uptick from MIN_TICK\n      next = MIN_TICK;\n      while (next < tick) {\n        (, next) = pool.initializedTicks(next);\n      }\n      (previous, ) = pool.initializedTicks(next);\n    }\n  }\n\n  function getTickSpacing(IPool pool) external view returns (int24) {\n    return pool.tickDistance();\n  }\n\n  function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\n    IPool pool = IPool(pool_);\n    (uint160 sqrtRatioX96, , ,) = pool.getPoolState();\n    liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\n    (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\n  }\n\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n  /// pool prices and the prices at the tick boundaries\n  function getLiquidityForAmounts(\n    uint160 sqrtRatioX96,\n    int24 lowerTick,\n    int24 upperTick,\n    uint amount0,\n    uint amount1\n  ) public pure returns (uint128 liquidity) {\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n      uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n    } else {\n      liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n    }\n  }\n\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n  /// pool prices and the prices at the tick boundaries\n  function getAmountsForLiquidity(\n    uint160 sqrtRatioX96,\n    int24 lowerTick,\n    int24 upperTick,\n    uint128 liquidity\n  ) public pure returns (uint amount0, uint amount1) {\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n    } else {\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    }\n  }\n\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(\n    uint a,\n    uint b,\n    uint denominator\n  ) public pure returns (uint result) {\n    unchecked {\n      // 512-bit multiply [prod1 prod0] = a * b\n      // Compute the product mod 2**256 and mod 2**256 - 1\n      // then use the Chinese Remainder Theorem to reconstruct\n      // the 512 bit result. The result is stored in two 256\n      // variables such that product = prod1 * 2**256 + prod0\n      uint prod0;\n      // Least significant 256 bits of the product\n      uint prod1;\n      // Most significant 256 bits of the product\n      assembly {\n        let mm := mulmod(a, b, not(0))\n        prod0 := mul(a, b)\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n      }\n\n      // Handle non-overflow cases, 256 by 256 division\n      if (prod1 == 0) {\n        require(denominator > 0);\n        assembly {\n          result := div(prod0, denominator)\n        }\n        return result;\n      }\n\n      // Make sure the result is less than 2**256.\n      // Also prevents denominator == 0\n      require(denominator > prod1);\n\n      ///////////////////////////////////////////////\n      // 512 by 256 division.\n      ///////////////////////////////////////////////\n\n      // Make division exact by subtracting the remainder from [prod1 prod0]\n      // Compute remainder using mulmod\n      uint remainder;\n      assembly {\n        remainder := mulmod(a, b, denominator)\n      }\n      // Subtract 256 bit number from 512 bit number\n      assembly {\n        prod1 := sub(prod1, gt(remainder, prod0))\n        prod0 := sub(prod0, remainder)\n      }\n\n      // Factor powers of two out of denominator\n      // Compute largest power of two divisor of denominator.\n      // Always >= 1.\n      // EDIT for 0.8 compatibility:\n      // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\n      uint twos = denominator & (~denominator + 1);\n\n      // Divide denominator by power of two\n      assembly {\n        denominator := div(denominator, twos)\n      }\n\n      // Divide [prod1 prod0] by the factors of two\n      assembly {\n        prod0 := div(prod0, twos)\n      }\n      // Shift in bits from prod1 into prod0. For this we need\n      // to flip `twos` such that it is 2**256 / twos.\n      // If twos is zero, then it becomes one\n      assembly {\n        twos := add(div(sub(0, twos), twos), 1)\n      }\n      prod0 |= prod1 * twos;\n\n      // Invert denominator mod 2**256\n      // Now that denominator is an odd number, it has an inverse\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n      // Compute the inverse by starting with a seed that is correct\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\n      uint inv = (3 * denominator) ^ 2;\n      // Now use Newton-Raphson iteration to improve the precision.\n      // Thanks to Hensel's lifting lemma, this also works in modular\n      // arithmetic, doubling the correct bits in each step.\n      inv *= 2 - denominator * inv;\n      // inverse mod 2**8\n      inv *= 2 - denominator * inv;\n      // inverse mod 2**16\n      inv *= 2 - denominator * inv;\n      // inverse mod 2**32\n      inv *= 2 - denominator * inv;\n      // inverse mod 2**64\n      inv *= 2 - denominator * inv;\n      // inverse mod 2**128\n      inv *= 2 - denominator * inv;\n      // inverse mod 2**256\n\n      // Because the division is now exact we can divide by multiplying\n      // with the modular inverse of denominator. This will give us the\n      // correct result modulo 2**256. Since the precoditions guarantee\n      // that the outcome is less than 2**256, this is the final result.\n      // We don't need to compute the high bits of the result and prod1\n      // is no longer required.\n      result = prod0 * inv;\n      return result;\n    }\n  }\n\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(\n    uint a,\n    uint b,\n    uint denominator\n  ) internal pure returns (uint result) {\n    result = mulDiv(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      require(result < type(uint).max);\n      result++;\n    }\n  }\n\n  /// @notice Calculates price in pool\n  function getPrice(address pool_, address tokenIn) public view returns (uint) {\n    IPool pool = IPool(pool_);\n    address token0 = address(pool.token0());\n    address token1 = address(pool.token1());\n\n    uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    (uint160 sqrtPriceX96,,,) = pool.getPoolState();\n\n    uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\n\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\n    uint purePrice;\n    uint precision;\n    if (tokenIn == token0) {\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\n      purePrice = part * part;\n    } else {\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\n      purePrice = part * part;\n    }\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount0 The amount0 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\n    return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount1 The amount1 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount0 The amount0\n  function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\n  }\n\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount1 The amount1\n  function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\n  }\n\n  function _countDigits(uint n) internal pure returns (uint) {\n    if (n == 0) {\n      return 0;\n    }\n    uint count = 0;\n    while (n != 0) {\n      n = n / 10;\n      ++count;\n    }\n    return count;\n  }\n\n  function _min(uint a, uint b) internal pure returns (uint) {\n    return a < b ? a : b;\n  }\n\n  function _max(uint a, uint b) internal pure returns (uint) {\n    return a > b ? a : b;\n  }\n\n  function _toUint128(uint x) private pure returns (uint128 y) {\n    require((y = uint128(x)) == x);\n  }\n\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\n  /// @dev Throws if |tick| > max tick\n  /// @param tick The input tick for the above formula\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n  /// at the given tick\n  function _getSqrtRatioAtTick(int24 tick)\n  internal\n  pure\n  returns (uint160 sqrtPriceX96)\n  {\n    uint256 absTick =\n      tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\n\n    // EDIT: 0.8 compatibility\n    require(absTick <= uint256(int256(MAX_TICK)), \"T\");\n\n    uint256 ratio =\n      absTick & 0x1 != 0\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\n        : 0x100000000000000000000000000000000;\n    if (absTick & 0x2 != 0)\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n    if (absTick & 0x4 != 0)\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n    if (absTick & 0x8 != 0)\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n    if (absTick & 0x10 != 0)\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n    if (absTick & 0x20 != 0)\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n    if (absTick & 0x40 != 0)\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n    if (absTick & 0x80 != 0)\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n    if (absTick & 0x100 != 0)\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n    if (absTick & 0x200 != 0)\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n    if (absTick & 0x400 != 0)\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n    if (absTick & 0x800 != 0)\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n    if (absTick & 0x1000 != 0)\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n    if (absTick & 0x2000 != 0)\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n    if (absTick & 0x4000 != 0)\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n    if (absTick & 0x8000 != 0)\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n    if (absTick & 0x10000 != 0)\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n    if (absTick & 0x20000 != 0)\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n    if (absTick & 0x40000 != 0)\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n    if (absTick & 0x80000 != 0)\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n    if (tick > 0) ratio = type(uint256).max / ratio;\n\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n    sqrtPriceX96 = uint160(\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\n    );\n  }\n\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n  /// ever return.\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n  function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    // second inequality must be < because the price can never reach the price at the max tick\n    require(\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\n      \"R\"\n    );\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n    uint256 r = ratio;\n    uint256 msb = 0;\n\n    assembly {\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(5, gt(r, 0xFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(4, gt(r, 0xFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(3, gt(r, 0xFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(2, gt(r, 0xF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(1, gt(r, 0x3))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := gt(r, 0x1)\n      msb := or(msb, f)\n    }\n\n    if (msb >= 128) r = ratio >> (msb - 127);\n    else r = ratio << (127 - msb);\n\n    int256 log_2 = (int256(msb) - 128) << 64;\n\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(63, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(62, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(61, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(60, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(59, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(58, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(57, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(56, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(55, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(54, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(53, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(52, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(51, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(50, f))\n    }\n\n    tick = _getFinalTick(log_2, sqrtPriceX96);\n  }\n\n  function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    // 128.128 number\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\n\n    int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n    int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n    tick = (tickLow == tickHi)\n      ? tickLow\n      : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow);\n  }\n}"
    },
    "contracts/strategies/kyber/KyberStrategyErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary KyberStrategyErrors {\n\n  string public constant NEED_REBALANCE = \"KS-1 Need rebalance\";\n  string public constant WRONG_BALANCE = \"KS-2 Wrong balance\";\n  string public constant INCORRECT_TICK_RANGE = \"KS-3 Incorrect tickRange\";\n  string public constant INCORRECT_REBALANCE_TICK_RANGE = \"KS-4 Incorrect rebalanceTickRange\";\n  string public constant INCORRECT_ASSET = \"KS-5 Incorrect asset\";\n  string public constant WRONG_FEE = \"KS-6 Wrong fee\";\n  string public constant WRONG_LIQUIDITY = \"KS-7 Wrong liquidity\";\n  string public constant NO_REBALANCE_NEEDED = \"KS-9 No rebalance needed\";\n  string public constant BALANCE_LOWER_THAN_FEE = \"KS-10 Balance lower than fee\";\n  string public constant NOT_CALLBACK_CALLER = \"KS-11 Not callback caller\";\n  string public constant UNKNOWN_SWAP_ROUTER = \"KS-12 Unknown router\";\n  string public constant ZERO_PROFIT_HOLDER = \"KS-13 Zero strategy profit holder\";\n  string public constant NOT_UNSTAKED = \"KS-14 Liquidity must be unstaked\";\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 150
    },
    "outputSelection": {
      "*": {
        "*": [
          "*",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "*",
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}