{
  "language": "Solidity",
  "sources": {
    "@tetu_io/tetu-contracts-v2/contracts/infrastructure/ControllerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/EnumerableMap.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title A central contract of the TETU platform.\n///        Holds all important contract addresses.\n///        Able to upgrade proxies with time-lock.\n/// @author belbix\ncontract ControllerV2 is ControllableV3, IController {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using EnumerableMap for EnumerableMap.UintToUintMap;\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n  enum AddressType {\n    UNKNOWN, // 0\n    GOVERNANCE, // 1\n    TETU_VOTER, // 2\n    PLATFORM_VOTER, // 3\n    LIQUIDATOR, // 4\n    FORWARDER, // 5\n    INVEST_FUND, // 6\n    VE_DIST // 7\n  }\n\n  struct AddressAnnounce {\n    uint _type;\n    address newAddress;\n    uint timeLockAt;\n  }\n\n  struct ProxyAnnounce {\n    address proxy;\n    address implementation;\n    uint timeLockAt;\n  }\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant CONTROLLER_VERSION = \"2.0.1\";\n  uint public constant TIME_LOCK = 18 hours;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  // --- restrictions\n\n  /// @dev Gnosis safe multi signature wallet with maximum power under the platform.\n  address public override governance;\n  /// @dev Operators can execute not-critical functions of the platform.\n  EnumerableSet.AddressSet internal _operators;\n\n  // --- dependency\n\n  /// @dev Voter for distribute TETU to gauges.\n  address public override voter;\n  /// @dev External solution for sell any tokens with minimal gas usage.\n  address public override liquidator;\n  /// @dev Accumulate performance fees and distribute them properly.\n  address public override forwarder;\n  /// @dev Contract for holding assets for the Second Stage\n  address public override investFund;\n  /// @dev Contract for accumulate TETU rewards for veTETU and weekly distribute them.\n  address public override veDistributor;\n  /// @dev Special voter for platform attributes.\n  address public override platformVoter;\n\n  // --- elements\n\n  /// @dev Set of valid vaults\n  EnumerableSet.AddressSet internal _vaults;\n\n  // --- time locks\n\n  EnumerableMap.UintToUintMap internal _addressTimeLocks;\n  EnumerableMap.UintToAddressMap internal _addressAnnounces;\n\n  EnumerableMap.AddressToUintMap internal _proxyTimeLocks;\n  mapping(address => address) public proxyAnnounces;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event AddressChangeAnnounced(uint _type, address value);\n  event AddressChanged(uint _type, address oldAddress, address newAddress);\n  event AddressAnnounceRemove(uint _type);\n  event ProxyUpgradeAnnounced(address proxy, address implementation);\n  event ProxyUpgraded(address proxy, address implementation);\n  event ProxyAnnounceRemoved(address proxy);\n  event RegisterVault(address vault);\n  event VaultRemoved(address vault);\n  event OperatorAdded(address operator);\n  event OperatorRemoved(address operator);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(address _governance) external initializer {\n    require(_governance != address(0), \"WRONG_INPUT\");\n    governance = _governance;\n    __Controllable_init(address(this));\n    _operators.add(_governance);\n  }\n\n  // *************************************************************\n  //                     RESTRICTIONS\n  // *************************************************************\n\n  function _onlyGovernance() internal view {\n    require(msg.sender == governance, \"DENIED\");\n  }\n\n  function _onlyOperators() internal view {\n    require(_operators.contains(msg.sender), \"DENIED\");\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Return all announced address changes.\n  function addressAnnouncesList() external view returns (AddressAnnounce[] memory announces) {\n    uint length = _addressTimeLocks.length();\n    announces = new AddressAnnounce[](length);\n    for (uint i; i < length; ++i) {\n      (uint _type, uint timeLock) = _addressTimeLocks.at(i);\n      address newAddress = _addressAnnounces.get(_type);\n      announces[i] = AddressAnnounce(_type, newAddress, timeLock);\n    }\n  }\n\n  /// @dev Return all announced proxy upgrades.\n  function proxyAnnouncesList() external view returns (ProxyAnnounce[] memory announces) {\n    uint length = _proxyTimeLocks.length();\n    announces = new ProxyAnnounce[](length);\n    for (uint i; i < length; ++i) {\n      (address proxy, uint timeLock) = _proxyTimeLocks.at(i);\n      address implementation = proxyAnnounces[proxy];\n      announces[i] = ProxyAnnounce(proxy, implementation, timeLock);\n    }\n  }\n\n  /// @dev Return true if the value exist in the operator set.\n  function isOperator(address value) external view override returns (bool) {\n    return _operators.contains(value);\n  }\n\n  /// @dev Return all operators. Expect the array will have reasonable size.\n  function operatorsList() external view returns (address[] memory) {\n    return _operators.values();\n  }\n\n  /// @dev Return all vaults. Array can be too big for use this function.\n  function vaultsList() external view override returns (address[] memory) {\n    return _vaults.values();\n  }\n\n  /// @dev Vault set size.\n  function vaultsListLength() external view override returns (uint) {\n    return _vaults.length();\n  }\n\n  /// @dev Return vault with given id. Ordering can be changed with time!\n  function vaults(uint id) external view override returns (address) {\n    return _vaults.at(id);\n  }\n\n  /// @dev Return true if the vault valid.\n  function isValidVault(address _vault) external view override returns (bool) {\n    return _vaults.contains(_vault);\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLER || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //          SET ADDRESSES WITH TIME-LOCK PROTECTION\n  // *************************************************************\n\n  /// @dev Add announce information for given address type.\n  function announceAddressChange(AddressType _type, address value) external {\n    _onlyGovernance();\n    require(value != address(0), \"ZERO_VALUE\");\n    require(_addressAnnounces.set(uint(_type), value), \"ANNOUNCED\");\n    _addressTimeLocks.set(uint(_type), block.timestamp + TIME_LOCK);\n\n    emit AddressChangeAnnounced(uint(_type), value);\n  }\n\n  /// @dev Change time-locked address and remove lock info.\n  ///      Less strict for reduce governance actions.\n  function changeAddress(AddressType _type) external {\n    _onlyOperators();\n\n    address newAddress = _addressAnnounces.get(uint(_type));\n    uint timeLock = _addressTimeLocks.get(uint(_type));\n    // no need to check values - get for non-exist values will be reverted\n    address oldAddress;\n\n    if (_type == AddressType.GOVERNANCE) {\n      oldAddress = governance;\n      governance = newAddress;\n\n    } else if (_type == AddressType.TETU_VOTER) {\n      oldAddress = voter;\n      voter = newAddress;\n\n    } else if (_type == AddressType.LIQUIDATOR) {\n      oldAddress = liquidator;\n      liquidator = newAddress;\n\n    } else if (_type == AddressType.FORWARDER) {\n      _requireInterface(newAddress, InterfaceIds.I_FORWARDER);\n      oldAddress = forwarder;\n      forwarder = newAddress;\n\n    } else if (_type == AddressType.INVEST_FUND) {\n      oldAddress = investFund;\n      investFund = newAddress;\n\n    } else if (_type == AddressType.VE_DIST) {\n      _requireInterface(newAddress, InterfaceIds.I_VE_DISTRIBUTOR);\n      oldAddress = veDistributor;\n      veDistributor = newAddress;\n\n    } else if (_type == AddressType.PLATFORM_VOTER) {\n      _requireInterface(newAddress, InterfaceIds.I_PLATFORM_VOTER);\n      oldAddress = platformVoter;\n      platformVoter = newAddress;\n    } else {\n      revert(\"UNKNOWN\");\n    }\n\n    // skip time-lock for initialization\n    if (oldAddress != address(0)) {\n      require(timeLock < block.timestamp, \"LOCKED\");\n    }\n\n    _addressAnnounces.remove(uint(_type));\n    _addressTimeLocks.remove(uint(_type));\n\n    emit AddressChanged(uint(_type), oldAddress, newAddress);\n  }\n\n  /// @dev Remove announced address change.\n  function removeAddressAnnounce(AddressType _type) external {\n    _onlyOperators();\n\n    _addressAnnounces.remove(uint(_type));\n    _addressTimeLocks.remove(uint(_type));\n\n    emit AddressAnnounceRemove(uint(_type));\n  }\n\n  // *************************************************************\n  //          UPGRADE PROXIES WITH TIME-LOCK PROTECTION\n  // *************************************************************\n\n  function announceProxyUpgrade(\n    address[] memory proxies,\n    address[] memory implementations\n  ) external {\n    _onlyGovernance();\n    require(proxies.length == implementations.length, \"WRONG_INPUT\");\n\n    for (uint i; i < proxies.length; i++) {\n      address proxy = proxies[i];\n      address implementation = implementations[i];\n\n      require(implementation != address(0), \"ZERO_IMPL\");\n      require(_proxyTimeLocks.set(proxy, block.timestamp + TIME_LOCK), \"ANNOUNCED\");\n      proxyAnnounces[proxy] = implementation;\n\n      emit ProxyUpgradeAnnounced(proxy, implementation);\n    }\n  }\n\n  /// @dev Upgrade proxy. Less strict for reduce governance actions.\n  function upgradeProxy(address[] memory proxies) external {\n    _onlyOperators();\n\n    for (uint i; i < proxies.length; i++) {\n      address proxy = proxies[i];\n      uint timeLock = _proxyTimeLocks.get(proxy);\n      // Map get will revert on not exist key, no need to check to zero\n      address implementation = proxyAnnounces[proxy];\n\n      require(timeLock < block.timestamp, \"LOCKED\");\n\n      IProxyControlled(proxy).upgrade(implementation);\n\n      _proxyTimeLocks.remove(proxy);\n      delete proxyAnnounces[proxy];\n\n      emit ProxyUpgraded(proxy, implementation);\n    }\n  }\n\n  function removeProxyAnnounce(address proxy) external {\n    _onlyOperators();\n\n    _proxyTimeLocks.remove(proxy);\n    delete proxyAnnounces[proxy];\n\n    emit ProxyAnnounceRemoved(proxy);\n  }\n\n  // *************************************************************\n  //                     REGISTER ACTIONS\n  // *************************************************************\n\n  /// @dev Register vault in the system.\n  ///      Operator should do it as part of deployment process.\n  function registerVault(address vault) external {\n    _onlyOperators();\n\n    require(_vaults.add(vault), \"EXIST\");\n    emit RegisterVault(vault);\n  }\n\n  /// @dev Remove vault from the system. Only for critical cases.\n  function removeVault(address vault) external {\n    _onlyGovernance();\n\n    require(_vaults.remove(vault), \"NOT_EXIST\");\n    emit VaultRemoved(vault);\n  }\n\n  /// @dev Register new operator.\n  function registerOperator(address value) external {\n    _onlyGovernance();\n\n    require(_operators.add(value), \"EXIST\");\n    emit OperatorAdded(value);\n  }\n\n  /// @dev Remove operator.\n  function removeOperator(address value) external {\n    _onlyGovernance();\n\n    require(_operators.remove(value), \"NOT_EXIST\");\n    emit OperatorRemoved(value);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/infrastructure/ForwarderV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/ITetuLiquidator.sol\";\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../interfaces/IMultiPool.sol\";\nimport \"../interfaces/IBribe.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title This contract should contains a buffer of fees from strategies.\n///        Periodically sell rewards and distribute to their destinations.\n/// @author belbix\ncontract ForwarderV3 is ReentrancyGuard, ControllableV3, IForwarder {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant FORWARDER_VERSION = \"3.0.0\";\n  /// @dev Denominator for different ratios. It is default for the whole platform.\n  uint public constant RATIO_DENOMINATOR = 100_000;\n  /// @dev If slippage not defined for concrete token will be used 5% tolerance.\n  uint public constant DEFAULT_SLIPPAGE = 5_000;\n  /// @dev Max handled destinations from queue per call.\n  uint public constant MAX_DESTINATIONS = 50;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  // -- ratios\n\n  /// @dev Percent of tokens for Invest Fund\n  uint public toInvestFundRatio;\n  /// @dev Percent of tokens for gauges.\n  uint public toGaugesRatio;\n\n  // -- convert options\n\n  /// @dev We will convert all tokens to TETU and distribute to destinations.\n  address public override tetu;\n  /// @dev Contract for bribes distribution\n  address public bribe;\n  /// @dev Minimum amount of TETU tokens for distribution.\n  uint public override tetuThreshold;\n  /// @dev Specific slippages for volatile tokens.\n  mapping(address => uint) public tokenSlippage;\n\n  // -- registered destinations\n\n  /// @dev Tokens ready for distribution\n  ///      This Set need for easy handle tokens off-chain, can be removed for gas optimisation.\n  EnumerableSet.AddressSet internal _queuedTokens;\n  /// @dev Token => Set of destinations with positive balances for the given token\n  mapping(address => EnumerableSet.AddressSet) internal _destinationQueue;\n  /// @dev Destination => Tokens ready to distribute\n  mapping(address => EnumerableSet.AddressSet) internal _tokensPerDestination;\n  /// @dev Token => Destination => Registered amount\n  mapping(address => mapping(address => uint)) public override amountPerDestination;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Distributed(\n    address sender,\n    address incomeToken,\n    uint queuedBalance,\n    uint tetuValue,\n    uint tetuBalance,\n    uint toInvestFund,\n    uint toGauges,\n    uint toBribes\n  );\n  event InvestFundRatioChanged(uint oldValue, uint newValue);\n  event GaugeRatioChanged(uint oldValue, uint newValue);\n  event TetuThresholdChanged(uint oldValue, uint newValue);\n  event SlippageChanged(address token, uint value);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(address controller_, address _tetu, address _bribe) external initializer {\n    _requireInterface(_bribe, InterfaceIds.I_BRIBE);\n    _requireERC20(_tetu);\n    __Controllable_init(controller_);\n    tetu = _tetu;\n    bribe = _bribe;\n    // 10k TETU by default\n    tetuThreshold = 10_000 * 1e18;\n  }\n\n  // *************************************************************\n  //                      GOV ACTIONS\n  // *************************************************************\n\n  /// @dev Check that sender is governance.\n  function _onlyGov() internal view {\n    require(isGovernance(msg.sender), \"DENIED\");\n  }\n\n  /// @dev Set specific token slippage for given token.\n  function setSlippage(address token, uint value) external {\n    _onlyGov();\n    require(value < RATIO_DENOMINATOR, \"TOO_HIGH\");\n\n    tokenSlippage[token] = value;\n    emit SlippageChanged(token, value);\n  }\n\n  /// @dev Set TETU threshold for distribution.\n  function setTetuThreshold(uint value) external {\n    _onlyGov();\n\n    emit TetuThresholdChanged(tetuThreshold, value);\n    tetuThreshold = value;\n  }\n\n  // *************************************************************\n  //                     VOTER ACTIONS\n  // *************************************************************\n\n  /// @dev Check that sender is platform voter.\n  function _onlyPlatformVoter() internal view {\n    require(msg.sender == IController(controller()).platformVoter(), \"DENIED\");\n  }\n\n  /// @dev veTETU holders can change proportion via special voter.\n  function setInvestFundRatio(uint value) external override {\n    _onlyPlatformVoter();\n    require(value <= RATIO_DENOMINATOR, \"TOO_HIGH\");\n\n    emit InvestFundRatioChanged(toInvestFundRatio, value);\n    toInvestFundRatio = value;\n  }\n\n  /// @dev veTETU holders can change proportion via special voter.\n  function setGaugesRatio(uint value) external override {\n    _onlyPlatformVoter();\n    require(value <= RATIO_DENOMINATOR, \"TOO_HIGH\");\n\n    emit GaugeRatioChanged(toGaugesRatio, value);\n    toGaugesRatio = value;\n  }\n\n  // *************************************************************\n  //                         VIEWS\n  // *************************************************************\n\n  /// @dev Size of array of tokens ready for distribution.\n  function queuedTokensLength() external view returns (uint) {\n    return _queuedTokens.length();\n  }\n\n  /// @dev Return queued token address for given id. Ordering can be changed between calls!\n  function queuedTokenAt(uint i) external view returns (address) {\n    return _queuedTokens.at(i);\n  }\n\n  /// @dev Size of array of tokens ready for distribution for given destination.\n  function tokenPerDestinationLength(address destination) public view override returns (uint) {\n    return _tokensPerDestination[destination].length();\n  }\n\n  /// @dev Return queued token address for given id and destination. Ordering can be changed between calls!\n  function tokenPerDestinationAt(address destination, uint i) external view override returns (address) {\n    return _tokensPerDestination[destination].at(i);\n  }\n\n  /// @dev Size of array of destinations for distribution for given token.\n  function destinationsLength(address incomeToken) external view returns (uint) {\n    return _destinationQueue[incomeToken].length();\n  }\n\n  /// @dev Return destination for given income token. Ordering can be changed between calls!\n  function destinationAt(address incomeToken, uint i) external view returns (address) {\n    return _destinationQueue[incomeToken].at(i);\n  }\n\n  /// @dev In case of too many queued destinations `targetTokenThreshold` should be lowered to reasonable value.\n  function getQueuedDestinations(address token) public view returns (\n    address[] memory queuedDestinations,\n    uint[] memory queuedAmounts,\n    uint balance\n  ){\n    EnumerableSet.AddressSet storage destinations = _destinationQueue[token];\n    mapping(address => uint) storage tokenPerDst = amountPerDestination[token];\n    uint length = Math.min(destinations.length(), MAX_DESTINATIONS);\n\n    queuedDestinations = new address[](length);\n    queuedAmounts = new uint[](length);\n    balance = 0;\n    for (uint i; i < length; ++i) {\n      address destination = destinations.at(i);\n      queuedDestinations[i] = destination;\n      uint amount = tokenPerDst[destination];\n      balance += amount;\n      queuedAmounts[i] = amount;\n    }\n  }\n\n  // *************************************************************\n  //                     REGISTER INCOME\n  // *************************************************************\n\n  /// @dev Strategy should call this on reward liquidation after compound part.\n  ///      Register tokens for the given destination.\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vaults,\n    bool isDistribute\n  ) external nonReentrant override {\n\n    for (uint i; i < tokens.length; ++i) {\n      address token = tokens[i];\n      uint amount = amounts[i];\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n      amountPerDestination[token][vaults] += amount;\n      // suppose to be not unique, relatively cheap\n      _destinationQueue[token].add(vaults);\n      _tokensPerDestination[vaults].add(token);\n      _queuedTokens.add(token);\n    }\n\n    // call it on cheap network\n    if (isDistribute) {\n      _distributeAll(vaults);\n    }\n  }\n\n  // *************************************************************\n  //                      DISTRIBUTE\n  // *************************************************************\n\n  function distributeAll(address destination) external nonReentrant override {\n    _distributeAll(destination);\n  }\n\n  function _distributeAll(address destination) internal {\n    address[] memory tokens = _tokensPerDestination[destination].values();\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      _distribute(tokens[i]);\n    }\n  }\n\n  /// @dev Try to distribute given income token using  a target token from converter.\n  ///      No strict access.\n  ///      We assume that amount will be distributed before accumulate huge value reasonable for arbitrage attack.\n  function distribute(address incomeToken) external nonReentrant override {\n    _distribute(incomeToken);\n  }\n\n  function _distribute(address incomeToken) internal {\n\n    (address[] memory vaults, uint[] memory queuedAmounts, uint queuedBalance)\n    = getQueuedDestinations(incomeToken);\n\n    IController controller_ = IController(controller());\n    address _tetu = tetu;\n\n    (uint tetuBalance, uint tetuValue) = _liquidate(controller_, incomeToken, _tetu, queuedBalance);\n\n    if (tetuBalance != 0) {\n      uint toInvestFund = tetuBalance * toInvestFundRatio / RATIO_DENOMINATOR;\n      uint toGauges = (tetuBalance - toInvestFund) * toGaugesRatio / RATIO_DENOMINATOR;\n      uint toBribes = (tetuBalance - toInvestFund) - toGauges;\n\n      if (toInvestFund != 0) {\n        IERC20(_tetu).safeTransfer(controller_.investFund(), toInvestFund);\n      }\n\n      if (toGauges != 0) {\n        address voter = controller_.voter();\n        IERC20(_tetu).safeApprove(voter, toGauges);\n        IVoter(voter).notifyRewardAmount(toGauges);\n      }\n\n      if (toBribes != 0) {\n        _distributeToBribes(\n          incomeToken,\n          _tetu,\n          vaults,\n          queuedAmounts,\n          queuedBalance,\n          toBribes\n        );\n      }\n\n      emit Distributed(\n        msg.sender,\n        incomeToken,\n        queuedBalance,\n        tetuValue,\n        tetuBalance,\n        toInvestFund,\n        toGauges,\n        toBribes\n      );\n    }\n  }\n\n  function _liquidate(\n    IController controller_,\n    address tokenIn,\n    address _tetu,\n    uint amount\n  ) internal returns (uint boughtTetu, uint tetuValue) {\n\n    if (tokenIn == _tetu) {\n      return (amount, amount);\n    }\n\n    boughtTetu = 0;\n    ITetuLiquidator _liquidator = ITetuLiquidator(controller_.liquidator());\n\n    (ITetuLiquidator.PoolData[] memory route, string memory error)\n    = _liquidator.buildRoute(tokenIn, _tetu);\n\n    if (route.length == 0) {\n      revert(error);\n    }\n\n    // calculate balance in tetu value for check threshold\n    tetuValue = _liquidator.getPriceForRoute(route, amount);\n\n    // if the value higher than threshold distribute to destinations\n    if (tetuValue > tetuThreshold) {\n\n      uint slippage = tokenSlippage[tokenIn];\n      if (slippage == 0) {\n        slippage = DEFAULT_SLIPPAGE;\n      }\n\n      uint tetuBalanceBefore = IERC20(_tetu).balanceOf(address(this));\n\n      _approveIfNeed(tokenIn, address(_liquidator), amount);\n      _liquidator.liquidateWithRoute(route, amount, slippage);\n\n      boughtTetu = IERC20(_tetu).balanceOf(address(this)) - tetuBalanceBefore;\n    }\n  }\n\n  // *************************************************************\n  //                      INTERNAL LOGIC\n  // *************************************************************\n\n\n  function _distributeToBribes(\n    address incomeToken,\n    address tokenToDistribute,\n    address[] memory vaults,\n    uint[] memory queuedAmounts,\n    uint queuedBalance,\n    uint toDistribute\n  ) internal {\n    address _bribe = bribe;\n    uint _epoch = IBribe(_bribe).epoch();\n    _approveIfNeed(tokenToDistribute, _bribe, toDistribute);\n\n    uint remaining = toDistribute;\n    for (uint i; i < vaults.length; i++) {\n      uint toSend = toDistribute * queuedAmounts[i] / queuedBalance;\n      // for avoid rounding issue send all remaining amount\n      if (i == vaults.length - 1) {\n        toSend = remaining;\n      } else {\n        remaining -= toSend;\n      }\n\n      _registerRewardInBribe(_bribe, vaults[i], tokenToDistribute);\n      IBribe(_bribe).notifyForNextEpoch(vaults[i], tokenToDistribute, toSend);\n      IBribe(_bribe).notifyDelayedRewards(vaults[i], tokenToDistribute, _epoch);\n\n      // clear queued data\n      _destinationQueue[incomeToken].remove(vaults[i]);\n      delete amountPerDestination[incomeToken][vaults[i]];\n      _tokensPerDestination[vaults[i]].remove(incomeToken);\n    }\n\n    if (IERC20(incomeToken).balanceOf(address(this)) == 0) {\n      _queuedTokens.remove(incomeToken);\n    }\n  }\n\n  function _registerRewardInBribe(address _bribe, address stakingToken, address rewardToken) internal {\n    if (!IMultiPool(_bribe).isRewardToken(stakingToken, rewardToken)) {\n      IMultiPool(_bribe).registerRewardToken(stakingToken, rewardToken);\n    }\n  }\n\n  function _approveIfNeed(address token, address dst, uint amount) internal {\n    if (IERC20(token).allowance(address(this), dst) < amount) {\n      IERC20(token).safeApprove(dst, 0);\n      IERC20(token).safeApprove(dst, type(uint).max);\n    }\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_FORWARDER || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/infrastructure/InvestFundV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../proxy/ControllableV3.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\n\n/// @title Upgradable contract with assets for invest in different places under control of Tetu platform.\n/// @author belbix\ncontract InvestFundV2 is ControllableV3 {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant INVEST_FUND_VERSION = \"2.0.0\";\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  EnumerableSet.AddressSet internal _tokens;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event FundDeposit(address indexed token, uint256 amount);\n  event FundWithdrawn(address indexed token, uint256 amount);\n\n  // *************************************************************\n  //                         INIT\n  // *************************************************************\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function init(address __controller) external initializer {\n    __Controllable_init(__controller);\n  }\n\n  // *************************************************************\n  //                      RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Allow operation only for Controller\n  modifier onlyGov() {\n    require(isGovernance(msg.sender), \"!gov\");\n    _;\n  }\n\n  // *************************************************************\n  //                         VIEWS\n  // *************************************************************\n\n  function tokens() external view returns (address[] memory) {\n    return _tokens.values();\n  }\n\n  // *************************************************************\n  //                     GOVERNANCE ACTIONS\n  // *************************************************************\n\n  /// @dev Move tokens to governance gnosis safe\n  function withdraw(address _token, uint256 amount) external onlyGov {\n    IERC20(_token).safeTransfer(msg.sender, amount);\n    emit FundWithdrawn(_token, amount);\n  }\n\n  /// @dev Transfer any token to this contract. The token will be added in the token list.\n  function deposit(address _token, uint256 amount) external onlyGov {\n    _tokens.add(_token);\n    if (amount != 0) {\n      IERC20(_token).safeTransferFrom(msg.sender, address(this), amount);\n    }\n    emit FundDeposit(_token, amount);\n  }\n\n  // *************************************************************\n  //                      FUND CONTROL\n  // *************************************************************\n\n  // TBD - implement invest strategy\n  // implementation highly depends on the Tetu Second Stage\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/infrastructure/PlatformVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../interfaces/IPlatformVoter.sol\";\nimport \"../interfaces/IVeTetu.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Ve holders can vote for platform attributes values.\n/// @author belbix\ncontract PlatformVoter is ControllableV3, IPlatformVoter {\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant PLATFORM_VOTER_VERSION = \"1.0.0\";\n  /// @dev Denominator for different ratios. It is default for the whole platform.\n  uint public constant RATIO_DENOMINATOR = 100_000;\n  /// @dev Delay between votes.\n  uint public constant VOTE_DELAY = 1 weeks;\n  /// @dev Maximum votes per veNFT\n  uint public constant MAX_VOTES = 20;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev The ve token that governs these contracts\n  address public ve;\n\n  // --- VOTES\n  /// @dev veId => votes\n  mapping(uint => Vote[]) public votes;\n  /// @dev Attribute => Target(zero for not-strategy) => sum of votes weights\n  mapping(AttributeType => mapping(address => uint)) public attributeWeights;\n  /// @dev Attribute => Target(zero for not-strategy) => sum of weights multiple on values\n  mapping(AttributeType => mapping(address => uint)) public attributeValues;\n\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event AttributeChanged(uint _type, uint value);\n  event Voted(\n    uint tokenId,\n    uint _type,\n    uint value,\n    address target,\n    uint veWeight,\n    uint veWeightedValue,\n    uint totalAttributeWeight,\n    uint totalAttributeValue,\n    uint newValue\n  );\n  event VoteReset(\n    uint tokenId,\n    uint _type,\n    address target,\n    uint weight,\n    uint weightedValue,\n    uint timestamp\n  );\n  event VoteRemoved(uint tokenId, uint _type, uint newValue, address target);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(address controller_, address _ve) external initializer {\n    __Controllable_init(controller_);\n    _requireInterface(_ve, InterfaceIds.I_VE_TETU);\n    ve = _ve;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Array of votes. Safe to return the whole array until we have MAX_VOTES restriction.\n  function veVotes(uint veId) external view returns (Vote[] memory) {\n    return votes[veId];\n  }\n\n  /// @dev Length of votes array for given id\n  function veVotesLength(uint veId) external view returns (uint) {\n    return votes[veId].length;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_PLATFORM_VOTER || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        VOTES\n  // *************************************************************\n\n  /// @dev Resubmit exist votes for given token.\n  ///      Need to call it for ve that did not renew votes too long.\n  function poke(uint tokenId) external {\n    Vote[] memory _votes = votes[tokenId];\n    for (uint i; i < _votes.length; ++i) {\n      Vote memory v = _votes[i];\n      _vote(tokenId, v._type, v.weightedValue / v.weight, v.target);\n    }\n  }\n\n  /// @dev Vote for multiple attributes in one call.\n  function voteBatch(\n    uint tokenId,\n    AttributeType[] memory types,\n    uint[] memory values,\n    address[] memory targets\n  ) external {\n    require(IVeTetu(ve).isApprovedOrOwner(msg.sender, tokenId), \"!owner\");\n    for (uint i; i < types.length; ++i) {\n      _vote(tokenId, types[i], values[i], targets[i]);\n    }\n  }\n\n  /// @dev Vote for given parameter using a vote power of given tokenId. Reset previous vote.\n  function vote(uint tokenId, AttributeType _type, uint value, address target) external {\n    require(IVeTetu(ve).isApprovedOrOwner(msg.sender, tokenId), \"!owner\");\n    _vote(tokenId, _type, value, target);\n  }\n\n  function _vote(uint tokenId, AttributeType _type, uint value, address target) internal {\n    require(value <= RATIO_DENOMINATOR, \"!value\");\n\n    // load maps for reduce gas usage\n    mapping(address => uint) storage _attributeWeights = attributeWeights[_type];\n    mapping(address => uint) storage _attributeValues = attributeValues[_type];\n    Vote[] storage _votes = votes[tokenId];\n\n    uint totalAttributeWeight;\n    uint totalAttributeValue;\n\n    //remove votes optimised\n    {\n      uint oldVeWeight;\n      uint oldVeValue;\n\n      uint length = _votes.length;\n      if (length != 0) {\n        uint i;\n        bool found;\n        for (; i < length; ++i) {\n          Vote memory v = _votes[i];\n          if (v._type == _type && v.target == target) {\n            require(v.timestamp + VOTE_DELAY < block.timestamp, \"delay\");\n            oldVeWeight = v.weight;\n            oldVeValue = v.weightedValue;\n            found = true;\n            break;\n          }\n        }\n        if (found) {\n          if (i != length - 1) {\n            _votes[i] = _votes[length - 1];\n          }\n          _votes.pop();\n        } else {\n          // it is a new type of vote\n          // need to check MAX votes in this case\n          require(length < MAX_VOTES, \"max\");\n        }\n      }\n\n      totalAttributeWeight = _attributeWeights[target] - oldVeWeight;\n      totalAttributeValue = _attributeValues[target] - oldVeValue;\n    }\n\n\n    // get new values for ve\n    uint veWeight = IVeTetu(ve).balanceOfNFT(tokenId);\n    uint veWeightedValue = veWeight * value;\n\n    if (veWeight != 0) {\n\n      // add ve values to total values\n      totalAttributeWeight += veWeight;\n      totalAttributeValue += veWeightedValue;\n\n      // store new total values\n      _attributeWeights[target] = totalAttributeWeight;\n      _attributeValues[target] = totalAttributeValue;\n\n      // set new attribute value\n      _setAttribute(_type, totalAttributeValue / totalAttributeWeight, target);\n\n      // write attachments\n      IVeTetu(ve).voting(tokenId);\n      _votes.push(Vote(_type, target, veWeight, veWeightedValue, block.timestamp));\n\n      emit Voted(\n        tokenId,\n        uint(_type),\n        value,\n        target,\n        veWeight,\n        veWeightedValue,\n        totalAttributeWeight,\n        totalAttributeValue,\n        totalAttributeValue / totalAttributeWeight\n      );\n    }\n  }\n\n  /// @dev Change attribute value for given type.\n  function _setAttribute(AttributeType _type, uint newValue, address target) internal {\n    if (_type == AttributeType.INVEST_FUND_RATIO) {\n      require(target == address(0), \"!target\");\n      IForwarder(IController(controller()).forwarder()).setInvestFundRatio(newValue);\n    } else if (_type == AttributeType.GAUGE_RATIO) {\n      require(target == address(0), \"!target\");\n      IForwarder(IController(controller()).forwarder()).setGaugesRatio(newValue);\n    } else if (_type == AttributeType.STRATEGY_COMPOUND) {\n      IStrategyV2(target).setCompoundRatio(newValue);\n    } else {\n      revert(\"!type\");\n    }\n    emit AttributeChanged(uint(_type), newValue);\n  }\n\n  /// @dev Remove all votes for given tokenId.\n  function reset(uint tokenId, uint[] memory types, address[] memory targets) external {\n    require(IVeTetu(ve).isApprovedOrOwner(msg.sender, tokenId) || msg.sender == ve, \"!owner\");\n\n    Vote[] storage _votes = votes[tokenId];\n    uint length = _votes.length;\n    for (uint i = length; i > 0; --i) {\n\n      Vote memory v = _votes[i - 1];\n      bool found;\n      for (uint j; j < types.length; ++j) {\n        uint _type = types[j];\n        address target = targets[j];\n        if (uint(v._type) == _type && v.target == target) {\n          found = true;\n          break;\n        }\n      }\n\n      if (found) {\n        require(v.timestamp + VOTE_DELAY < block.timestamp, \"delay\");\n        _removeVote(tokenId, v._type, v.target, v.weight, v.weightedValue);\n        // with descent loop we remove one by one last elements\n        _votes.pop();\n\n        IVeTetu(ve).abstain(tokenId);\n        emit VoteReset(\n          tokenId,\n          uint(v._type),\n          v.target,\n          v.weight,\n          v.weightedValue,\n          v.timestamp\n        );\n      }\n    }\n  }\n\n  function _removeVote(uint tokenId, AttributeType _type, address target, uint weight, uint veValue) internal {\n    uint totalWeights = attributeWeights[_type][target] - weight;\n    uint totalValues = attributeValues[_type][target] - veValue;\n    attributeWeights[_type][target] = totalWeights;\n    if (veValue != 0) {\n      attributeValues[_type][target] = totalValues;\n    }\n    uint newValue;\n    if (totalWeights != 0) {\n      newValue = totalValues / totalWeights;\n    }\n    _setAttribute(_type, newValue, target);\n    emit VoteRemoved(tokenId, uint(_type), newValue, target);\n  }\n\n  function detachTokenFromAll(uint tokenId, address) external override {\n    require(msg.sender == ve, \"!ve\");\n\n    Vote[] storage _votes = votes[tokenId];\n    uint length = _votes.length;\n    for (uint i = length; i > 0; --i) {\n      Vote memory v = _votes[i - 1];\n      _removeVote(tokenId, v._type, v.target, v.weight, v.weightedValue);\n      _votes.pop();\n    }\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IBribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IBribe {\n\n  function epoch() external view returns (uint);\n\n  function getReward(\n    address vault,\n    uint veId,\n    address[] memory tokens\n  ) external;\n\n  function getAllRewards(\n    address vault,\n    uint veId\n  ) external;\n\n  function getAllRewardsForTokens(\n    address[] memory vaults,\n    uint veId\n  ) external;\n\n  function deposit(address vault, uint amount, uint tokenId) external;\n\n  function withdraw(address vault, uint amount, uint tokenId) external;\n\n  function notifyRewardAmount(address vault, address token, uint amount) external;\n\n  function notifyForNextEpoch(address vault, address token, uint amount) external;\n\n  function notifyDelayedRewards(address vault, address token, uint _epoch) external;\n\n  function increaseEpoch() external;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IControllable {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IController {\n\n  // --- DEPENDENCY ADDRESSES\n  function governance() external view returns (address);\n\n  function voter() external view returns (address);\n\n  function liquidator() external view returns (address);\n\n  function forwarder() external view returns (address);\n\n  function investFund() external view returns (address);\n\n  function veDistributor() external view returns (address);\n\n  function platformVoter() external view returns (address);\n\n  // --- VAULTS\n\n  function vaults(uint id) external view returns (address);\n\n  function vaultsList() external view returns (address[] memory);\n\n  function vaultsListLength() external view returns (uint);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  // --- restrictions\n\n  function isOperator(address _adr) external view returns (bool);\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n     */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n     */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n  event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n  event Withdraw(\n    address indexed sender,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  /**\n   * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n  function asset() external view returns (address assetTokenAddress);\n\n  /**\n   * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n  function totalAssets() external view returns (uint256 totalManagedAssets);\n\n  /**\n   * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n  function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n  /**\n   * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n  function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n  /**\n   * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n  function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n  function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n  /**\n   * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n  function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n  /**\n   * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n  function maxMint(address receiver) external view returns (uint256 maxShares);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n  function previewMint(uint256 shares) external view returns (uint256 assets);\n\n  /**\n   * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n  function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n  /**\n   * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n  function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n  function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n  /**\n   * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) external returns (uint256 shares);\n\n  /**\n   * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n  function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n  function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n  /**\n   * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) external returns (uint256 assets);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n  /**\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n  /**\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n   */\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n  /**\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n   */\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n  /**\n   * @dev Returns the number of tokens in ``owner``'s account.\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @dev Returns the owner of the `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @dev Transfers `tokenId` token from `from` to `to`.\n   *\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n   * The approval is cleared when the token is transferred.\n   *\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n   *\n   * Requirements:\n   *\n   * - The caller must own the token or be an approved operator.\n   * - `tokenId` must exist.\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address to, uint256 tokenId) external;\n\n  /**\n   * @dev Returns the account approved for `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function getApproved(uint256 tokenId) external view returns (address operator);\n\n  /**\n   * @dev Approve or remove `operator` as an operator for the caller.\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n   *\n   * Requirements:\n   *\n   * - The `operator` cannot be the caller.\n   *\n   * Emits an {ApprovalForAll} event.\n   */\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  /**\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n   *\n   * See {setApprovalForAll}\n   */\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC721.sol\";\n\n/**\n* @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n* @dev See https://eips.ethereum.org/EIPS/eip-721\n*/\ninterface IERC721Metadata is IERC721 {\n  /**\n  * @dev Returns the token collection name.\n  */\n  function name() external view returns (string memory);\n\n  /**\n  * @dev Returns the token collection symbol.\n  */\n  function symbol() external view returns (string memory);\n\n  /**\n  * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n  */\n  function tokenURI(uint tokenId) external view returns (string memory);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n  /**\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n   * by `operator` from `from`, this function is called.\n   *\n   * It must return its Solidity selector to confirm the token transfer.\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n   *\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n  ) external returns (bytes4);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IForwarder {\n\n  function tetu() external view returns (address);\n  function tetuThreshold() external view returns (uint);\n\n  function tokenPerDestinationLength(address destination) external view returns (uint);\n\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\n\n  function amountPerDestination(address token, address destination) external view returns (uint amount);\n\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vault,\n    bool isDistribute\n  ) external;\n\n  function distributeAll(address destination) external;\n\n  function distribute(address token) external;\n\n  function setInvestFundRatio(uint value) external;\n\n  function setGaugesRatio(uint value) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IGauge {\n\n  function veIds(address stakingToken, address account) external view returns (uint);\n\n  function getReward(\n    address stakingToken,\n    address account,\n    address[] memory tokens\n  ) external;\n\n  function getAllRewards(\n    address stakingToken,\n    address account\n  ) external;\n\n  function getAllRewardsForTokens(\n    address[] memory stakingTokens,\n    address account\n  ) external;\n\n  function attachVe(address stakingToken, address account, uint veId) external;\n\n  function detachVe(address stakingToken, address account, uint veId) external;\n\n  function handleBalanceChange(address account) external;\n\n  function notifyRewardAmount(address stakingToken, address token, uint amount) external;\n\n  function addStakingToken(address token) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IMultiPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IMultiPool {\n\n  function totalSupply(address stakingToken) external view returns (uint);\n\n  function derivedSupply(address stakingToken) external view returns (uint);\n\n  function derivedBalances(address stakingToken, address account) external view returns (uint);\n\n  function balanceOf(address stakingToken, address account) external view returns (uint);\n\n  function rewardTokens(address stakingToken, uint id) external view returns (address);\n\n  function isRewardToken(address stakingToken, address token) external view returns (bool);\n\n  function rewardTokensLength(address stakingToken) external view returns (uint);\n\n  function derivedBalance(address stakingToken, address account) external view returns (uint);\n\n  function left(address stakingToken, address token) external view returns (uint);\n\n  function earned(address stakingToken, address token, address account) external view returns (uint);\n\n  function registerRewardToken(address stakingToken, address token) external;\n\n  function removeRewardToken(address stakingToken, address token) external;\n\n  function isStakeToken(address token) external view returns (bool);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IPlatformVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IPlatformVoter {\n\n  enum AttributeType {\n    UNKNOWN,\n    INVEST_FUND_RATIO,\n    GAUGE_RATIO,\n    STRATEGY_COMPOUND\n  }\n\n  struct Vote {\n    AttributeType _type;\n    address target;\n    uint weight;\n    uint weightedValue;\n    uint timestamp;\n  }\n\n  function detachTokenFromAll(uint tokenId, address owner) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IProxyControlled {\n\n  function initProxy(address _logic) external;\n\n  function upgrade(address _newImplementation) external;\n\n  function implementation() external view returns (address);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ISmartVault.sol": {
      "content": "// SPDX-License-Identifier: ISC\n/**\n* By using this software, you understand, acknowledge and accept that Tetu\n* and/or the underlying software are provided “as is” and “as available”\n* basis and without warranties or representations of any kind either expressed\n* or implied. Any use of this open source software released under the ISC\n* Internet Systems Consortium license is done at your own risk to the fullest\n* extent permissible pursuant to applicable law any and all liability as well\n* as all warranties, including any fitness for a particular purpose with respect\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\n*/\n\npragma solidity 0.8.17;\n\ninterface ISmartVault {\n\n  function DEPOSIT_FEE_DENOMINATOR() external view returns (uint256);\n\n  function LOCK_PENALTY_DENOMINATOR() external view returns (uint256);\n\n  function TO_INVEST_DENOMINATOR() external view returns (uint256);\n\n  function VERSION() external view returns (string memory);\n\n  function active() external view returns (bool);\n\n  function addRewardToken(address rt) external;\n\n  function alwaysInvest() external view returns (bool);\n\n  function availableToInvestOut() external view returns (uint256);\n\n  function changeActivityStatus(bool _active) external;\n\n  function changeAlwaysInvest(bool _active) external;\n\n  function changeDoHardWorkOnInvest(bool _active) external;\n\n  function changePpfsDecreaseAllowed(bool _value) external;\n\n  function changeProtectionMode(bool _active) external;\n\n  function deposit(uint256 amount) external;\n\n  function depositAndInvest(uint256 amount) external;\n\n  function depositFeeNumerator() external view returns (uint256);\n\n  function depositFor(uint256 amount, address holder) external;\n\n  function doHardWork() external;\n\n  function doHardWorkOnInvest() external view returns (bool);\n\n  function duration() external view returns (uint256);\n\n  function earned(address rt, address account)\n  external\n  view\n  returns (uint256);\n\n  function earnedWithBoost(address rt, address account)\n  external\n  view\n  returns (uint256);\n\n  function exit() external;\n\n  function getAllRewards() external;\n\n  function getAllRewardsAndRedirect(address owner) external;\n\n  function getPricePerFullShare() external view returns (uint256);\n\n  function getReward(address rt) external;\n\n  function getRewardTokenIndex(address rt) external view returns (uint256);\n\n  function initializeSmartVault(\n    string memory _name,\n    string memory _symbol,\n    address _controller,\n    address __underlying,\n    uint256 _duration,\n    bool _lockAllowed,\n    address _rewardToken,\n    uint256 _depositFee\n  ) external;\n\n  function lastTimeRewardApplicable(address rt)\n  external\n  view\n  returns (uint256);\n\n  function lastUpdateTimeForToken(address) external view returns (uint256);\n\n  function lockAllowed() external view returns (bool);\n\n  function lockPenalty() external view returns (uint256);\n\n  function notifyRewardWithoutPeriodChange(\n    address _rewardToken,\n    uint256 _amount\n  ) external;\n\n  function notifyTargetRewardAmount(address _rewardToken, uint256 amount)\n  external;\n\n  function overrideName(string memory value) external;\n\n  function overrideSymbol(string memory value) external;\n\n  function periodFinishForToken(address) external view returns (uint256);\n\n  function ppfsDecreaseAllowed() external view returns (bool);\n\n  function protectionMode() external view returns (bool);\n\n  function rebalance() external;\n\n  function removeRewardToken(address rt) external;\n\n  function rewardPerToken(address rt) external view returns (uint256);\n\n  function rewardPerTokenStoredForToken(address)\n  external\n  view\n  returns (uint256);\n\n  function rewardRateForToken(address) external view returns (uint256);\n\n  function rewardTokens() external view returns (address[] memory);\n\n  function rewardTokensLength() external view returns (uint256);\n\n  function rewardsForToken(address, address) external view returns (uint256);\n\n  function setLockPenalty(uint256 _value) external;\n\n  function setRewardsRedirect(address owner, address receiver) external;\n\n  function setLockPeriod(uint256 _value) external;\n\n  function setStrategy(address newStrategy) external;\n\n  function setToInvest(uint256 _value) external;\n\n  function stop() external;\n\n  function strategy() external view returns (address);\n\n  function toInvest() external view returns (uint256);\n\n  function underlying() external view returns (address);\n\n  function underlyingBalanceInVault() external view returns (uint256);\n\n  function underlyingBalanceWithInvestment() external view returns (uint256);\n\n  function underlyingBalanceWithInvestmentForHolder(address holder)\n  external\n  view\n  returns (uint256);\n\n  function underlyingUnit() external view returns (uint256);\n\n  function userBoostTs(address) external view returns (uint256);\n\n  function userLastDepositTs(address) external view returns (uint256);\n\n  function userLastWithdrawTs(address) external view returns (uint256);\n\n  function userLockTs(address) external view returns (uint256);\n\n  function userRewardPerTokenPaidForToken(address, address)\n  external\n  view\n  returns (uint256);\n\n  function withdraw(uint256 numberOfShares) external;\n\n  function withdrawAllToVault() external;\n\n  function getAllRewardsFor(address rewardsReceiver) external;\n\n  function lockPeriod() external view returns (uint256);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISplitter {\n\n  function init(address controller_, address _asset, address _vault) external;\n\n  // *************** ACTIONS **************\n\n  function withdrawAllToVault() external;\n\n  function withdrawToVault(uint256 amount) external;\n\n  function doHardWork() external;\n\n  function investAll() external;\n\n  // **************** VIEWS ***************\n\n  function asset() external view returns (address);\n\n  function vault() external view returns (address);\n\n  function totalAssets() external view returns (uint256);\n\n  function isHardWorking() external view returns (bool);\n\n  function strategies(uint i) external view returns (address);\n\n  function strategiesLength() external view returns (uint);\n\n  function HARDWORK_DELAY() external view returns(uint);\n\n  function lastHardWorks(address strategy) external view returns(uint);\n\n  function pausedStrategies(address strategy) external view returns(bool);\n\n  function pauseInvesting(address strategy) external;\n\n  function continueInvesting(address strategy, uint apr) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IStrategyV2 {\n\n  function NAME() external view returns (string memory);\n\n  function strategySpecificName() external view returns (string memory);\n\n  function PLATFORM() external view returns (string memory);\n\n  function STRATEGY_VERSION() external view returns (string memory);\n\n  function asset() external view returns (address);\n\n  function splitter() external view returns (address);\n\n  function compoundRatio() external view returns (uint);\n\n  function totalAssets() external view returns (uint);\n\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\n  function isReadyToHardWork() external view returns (bool);\n\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawAllToSplitter() external returns (uint strategyLoss);\n\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawToSplitter(uint amount) external returns (uint strategyLoss);\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external returns (\n    uint strategyLoss\n  );\n\n  function doHardWork() external returns (uint earned, uint lost);\n\n  function setCompoundRatio(uint value) external;\n\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\n  ///         0 means no deposit is allowed at this moment\n  function capacity() external view returns (uint);\n\n  /// @notice {performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\n  function performanceReceiver() external view returns (address);\n\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\n  /// @dev use FEE_DENOMINATOR\n  function performanceFee() external view returns (uint);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ITetuLiquidator {\n\n  struct PoolData {\n    address pool;\n    address swapper;\n    address tokenIn;\n    address tokenOut;\n  }\n\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\n\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\n\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\n\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint slippage\n  ) external;\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint slippage\n  ) external;\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IVaultInsurance.sol\";\nimport \"./IERC20.sol\";\nimport \"./ISplitter.sol\";\n\ninterface ITetuVaultV2 {\n\n  function splitter() external view returns (ISplitter);\n\n  function insurance() external view returns (IVaultInsurance);\n\n  function depositFee() external view returns (uint);\n\n  function withdrawFee() external view returns (uint);\n\n  function init(\n    address controller_,\n    IERC20 _asset,\n    string memory _name,\n    string memory _symbol,\n    address _gauge,\n    uint _buffer\n  ) external;\n\n  function setSplitter(address _splitter) external;\n\n  function coverLoss(uint amount) external;\n\n  function initInsurance(IVaultInsurance _insurance) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVaultInsurance {\n\n  function init(address _vault, address _asset) external;\n\n  function vault() external view returns (address);\n\n  function asset() external view returns (address);\n\n  function transferToVault(uint amount) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVeDistributor {\n\n  function rewardToken() external view returns (address);\n\n  function checkpoint() external;\n\n  function checkpointTotalSupply() external;\n\n  function claim(uint _tokenId) external returns (uint);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeTetu.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVeTetu {\n\n  enum DepositType {\n    DEPOSIT_FOR_TYPE,\n    CREATE_LOCK_TYPE,\n    INCREASE_LOCK_AMOUNT,\n    INCREASE_UNLOCK_TIME,\n    MERGE_TYPE\n  }\n\n  struct Point {\n    int128 bias;\n    int128 slope; // # -dweight / dt\n    uint ts;\n    uint blk; // block\n  }\n  /* We cannot really do block numbers per se b/c slope is per time, not per block\n  * and per block could be fairly bad b/c Ethereum changes blocktimes.\n  * What we can do is to extrapolate ***At functions */\n\n  function attachments(uint tokenId) external view returns (uint);\n\n  function lockedAmounts(uint veId, address stakingToken) external view returns (uint);\n\n  function lockedDerivedAmount(uint veId) external view returns (uint);\n\n  function lockedEnd(uint veId) external view returns (uint);\n\n  function voted(uint tokenId) external view returns (uint);\n\n  function tokens(uint idx) external view returns (address);\n\n  function balanceOfNFT(uint) external view returns (uint);\n\n  function isApprovedOrOwner(address, uint) external view returns (bool);\n\n  function createLockFor(address _token, uint _value, uint _lockDuration, address _to) external returns (uint);\n\n  function userPointEpoch(uint tokenId) external view returns (uint);\n\n  function epoch() external view returns (uint);\n\n  function userPointHistory(uint tokenId, uint loc) external view returns (Point memory);\n\n  function pointHistory(uint loc) external view returns (Point memory);\n\n  function checkpoint() external;\n\n  function increaseAmount(address _token, uint _tokenId, uint _value) external;\n\n  function attachToken(uint tokenId) external;\n\n  function detachToken(uint tokenId) external;\n\n  function voting(uint tokenId) external;\n\n  function abstain(uint tokenId) external;\n\n  function totalSupplyAt(uint _block) external view returns (uint);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVoter {\n\n  function ve() external view returns (address);\n\n  function attachTokenToGauge(address stakingToken, uint _tokenId, address account) external;\n\n  function detachTokenFromGauge(address stakingToken, uint _tokenId, address account) external;\n\n  function distribute(address stakingToken) external;\n\n  function notifyRewardAmount(uint amount) external;\n\n  function detachTokenFromAll(uint tokenId, address account) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n  bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  /// @notice Encodes some bytes to the base64 representation\n  function encode(bytes memory data) internal pure returns (string memory) {\n    uint len = data.length;\n    if (len == 0) return \"\";\n\n    // multiply by 4/3 rounded up\n    uint encodedLen = 4 * ((len + 2) / 3);\n\n    // Add some extra buffer at the end\n    bytes memory result = new bytes(encodedLen + 32);\n\n    bytes memory table = TABLE;\n\n    assembly {\n      let tablePtr := add(table, 1)\n      let resultPtr := add(result, 32)\n\n      for {\n        let i := 0\n      } lt(i, len) {\n\n      } {\n        i := add(i, 3)\n        let input := and(mload(add(data, i)), 0xffffff)\n\n        let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n        out := shl(224, out)\n\n        mstore(resultPtr, out)\n\n        resultPtr := add(resultPtr, 4)\n      }\n\n      switch mod(len, 3)\n      case 1 {\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n      }\n      case 2 {\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\n      }\n\n      mstore(result, encodedLen)\n    }\n\n    return string(result);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n  /*//////////////////////////////////////////////////////////////\n  //SIMPLIFIED FIXED POINT OPERATIONS\n  //////////////////////////////////////////////////////////////*/\n\n  uint internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n  function mulWadDown(uint x, uint y) internal pure returns (uint) {\n    return mulDivDown(x, y, WAD);\n    // Equivalent to (x * y) / WAD rounded down.\n  }\n\n  function mulWadUp(uint x, uint y) internal pure returns (uint) {\n    return mulDivUp(x, y, WAD);\n    // Equivalent to (x * y) / WAD rounded up.\n  }\n\n  function divWadDown(uint x, uint y) internal pure returns (uint) {\n    return mulDivDown(x, WAD, y);\n    // Equivalent to (x * WAD) / y rounded down.\n  }\n\n  function divWadUp(uint x, uint y) internal pure returns (uint) {\n    return mulDivUp(x, WAD, y);\n    // Equivalent to (x * WAD) / y rounded up.\n  }\n\n  function positiveInt128(int128 value) internal pure returns (int128) {\n    return value < 0 ? int128(0) : value;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //LOW LEVEL FIXED POINT OPERATIONS\n  //////////////////////////////////////////////////////////////*/\n\n  function mulDivDown(\n    uint x,\n    uint y,\n    uint denominator\n  ) internal pure returns (uint z) {\n    assembly {\n    // Store x * y in z for now.\n      z := mul(x, y)\n\n    // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n        revert(0, 0)\n      }\n\n    // Divide z by the denominator.\n      z := div(z, denominator)\n    }\n  }\n\n  function mulDivUp(\n    uint x,\n    uint y,\n    uint denominator\n  ) internal pure returns (uint z) {\n    assembly {\n    // Store x * y in z for now.\n      z := mul(x, y)\n\n    // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n        revert(0, 0)\n      }\n\n    // First, divide z - 1 by the denominator and add 1.\n    // We allow z - 1 to underflow if z is 0, because we multiply the\n    // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n      z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n    }\n  }\n\n  function rpow(\n    uint x,\n    uint n,\n    uint scalar\n  ) internal pure returns (uint z) {\n    assembly {\n      switch x\n      case 0 {\n        switch n\n        case 0 {\n        // 0 ** 0 = 1\n          z := scalar\n        }\n        default {\n        // 0 ** n = 0\n          z := 0\n        }\n      }\n      default {\n        switch mod(n, 2)\n        case 0 {\n        // If n is even, store scalar in z for now.\n          z := scalar\n        }\n        default {\n        // If n is odd, store x in z for now.\n          z := x\n        }\n\n      // Shifting right by 1 is like dividing by 2.\n        let half := shr(1, scalar)\n\n        for {\n        // Shift n right by 1 before looping to halve it.\n          n := shr(1, n)\n        } n {\n        // Shift n right by 1 each iteration to halve it.\n          n := shr(1, n)\n        } {\n        // Revert immediately if x ** 2 would overflow.\n        // Equivalent to iszero(eq(div(xx, x), x)) here.\n          if shr(128, x) {\n            revert(0, 0)\n          }\n\n        // Store x squared.\n          let xx := mul(x, x)\n\n        // Round to the nearest number.\n          let xxRound := add(xx, half)\n\n        // Revert if xx + half overflowed.\n          if lt(xxRound, xx) {\n            revert(0, 0)\n          }\n\n        // Set x to scaled xxRound.\n          x := div(xxRound, scalar)\n\n        // If n is even:\n          if mod(n, 2) {\n          // Compute z * x.\n            let zx := mul(z, x)\n\n          // If z * x overflowed:\n            if iszero(eq(div(zx, x), z)) {\n            // Revert if x is non-zero.\n              if iszero(iszero(x)) {\n                revert(0, 0)\n              }\n            }\n\n          // Round to the nearest number.\n            let zxRound := add(zx, half)\n\n          // Revert if zx + half overflowed.\n            if lt(zxRound, zx) {\n              revert(0, 0)\n            }\n\n          // Return properly scaled zxRound.\n            z := div(zxRound, scalar)\n          }\n        }\n      }\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  // GENERAL NUMBER UTILITIES\n  //////////////////////////////////////////////////////////////*/\n\n  function sqrt(uint x) internal pure returns (uint z) {\n    assembly {\n    // Start off with z at 1.\n      z := 1\n\n    // Used below to help find a nearby power of 2.\n      let y := x\n\n    // Find the lowest power of 2 that is at least sqrt(x).\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\n        y := shr(128, y) // Like dividing by 2 ** 128.\n        z := shl(64, z) // Like multiplying by 2 ** 64.\n      }\n      if iszero(lt(y, 0x10000000000000000)) {\n        y := shr(64, y) // Like dividing by 2 ** 64.\n        z := shl(32, z) // Like multiplying by 2 ** 32.\n      }\n      if iszero(lt(y, 0x100000000)) {\n        y := shr(32, y) // Like dividing by 2 ** 32.\n        z := shl(16, z) // Like multiplying by 2 ** 16.\n      }\n      if iszero(lt(y, 0x10000)) {\n        y := shr(16, y) // Like dividing by 2 ** 16.\n        z := shl(8, z) // Like multiplying by 2 ** 8.\n      }\n      if iszero(lt(y, 0x100)) {\n        y := shr(8, y) // Like dividing by 2 ** 8.\n        z := shl(4, z) // Like multiplying by 2 ** 4.\n      }\n      if iszero(lt(y, 0x10)) {\n        y := shr(4, y) // Like dividing by 2 ** 4.\n        z := shl(2, z) // Like multiplying by 2 ** 2.\n      }\n      if iszero(lt(y, 0x8)) {\n      // Equivalent to 2 ** z.\n        z := shl(1, z)\n      }\n\n    // Shifting right by 1 is like dividing by 2.\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n\n    // Compute a rounded down version of z.\n      let zRoundDown := div(x, z)\n\n    // If zRoundDown is smaller, use it.\n      if lt(zRoundDown, z) {\n        z := zRoundDown\n      }\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/InterfaceIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for interface IDs\n/// @author bogdoslav\nlibrary InterfaceIds {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant INTERFACE_IDS_LIB_VERSION = \"1.0.0\";\n\n  /// default notation:\n  /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\n\n  /// As type({Interface}).interfaceId can be changed,\n  /// when some functions changed at the interface,\n  /// so used hardcoded interface identifiers\n\n  bytes4 public constant I_VOTER = bytes4(keccak256(\"IVoter\"));\n  bytes4 public constant I_BRIBE = bytes4(keccak256(\"IBribe\"));\n  bytes4 public constant I_GAUGE = bytes4(keccak256(\"IGauge\"));\n  bytes4 public constant I_VE_TETU = bytes4(keccak256(\"IVeTetu\"));\n  bytes4 public constant I_SPLITTER = bytes4(keccak256(\"ISplitter\"));\n  bytes4 public constant I_FORWARDER = bytes4(keccak256(\"IForwarder\"));\n  bytes4 public constant I_MULTI_POOL = bytes4(keccak256(\"IMultiPool\"));\n  bytes4 public constant I_CONTROLLER = bytes4(keccak256(\"IController\"));\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\"ITetuERC165\"));\n  bytes4 public constant I_STRATEGY_V2 = bytes4(keccak256(\"IStrategyV2\"));\n  bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\"IControllable\"));\n  bytes4 public constant I_TETU_VAULT_V2 = bytes4(keccak256(\"ITetuVaultV2\"));\n  bytes4 public constant I_PLATFORM_VOTER = bytes4(keccak256(\"IPlatformVoter\"));\n  bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\"IVeDistributor\"));\n  bytes4 public constant I_TETU_CONVERTER = bytes4(keccak256(\"ITetuConverter\"));\n  bytes4 public constant I_VAULT_INSURANCE = bytes4(keccak256(\"IVaultInsurance\"));\n  bytes4 public constant I_STRATEGY_STRICT = bytes4(keccak256(\"IStrategyStrict\"));\n  bytes4 public constant I_ERC4626 = bytes4(keccak256(\"IERC4626\"));\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  /// @dev Gets a slot array by index as uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  // ************* ARRAY SETTERS *******************\n\n  /// @dev Sets a slot array at index with address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, address value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets a slot array at index with uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, uint value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets an array length\n  function setLength(bytes32 slot, uint length) internal {\n    assembly {\n      sstore(slot, length)\n    }\n  }\n\n  /// @dev Pushes an address to the array\n  function push(bytes32 slot, address value) internal {\n    uint length = arrayLength(slot);\n    setAt(slot, length, value);\n    setLength(slot, length + 1);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n\nlibrary StringLib {\n\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n  function toString(uint value) external pure returns (string memory) {\n    return _toString(value);\n  }\n\n  function _toString(uint value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint temp = value;\n    uint digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  function toAsciiString(address x) external pure returns (string memory) {\n    return _toAsciiString(x);\n  }\n\n  function _toAsciiString(address x) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = _char(hi);\n      s[2 * i + 1] = _char(lo);\n    }\n    return string(s);\n  }\n\n  function char(bytes1 b) external pure returns (bytes1 c) {\n    return _char(b);\n  }\n\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n    else return bytes1(uint8(b) + 0x57);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity 0.8.17;\nimport \"./Initializable.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/utils/ContextUpgradeable.sol\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n  function __Context_init() internal onlyInitializing {\n  }\n\n  function __Context_init_unchained() internal onlyInitializing {\n  }\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[50] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n  unchecked {\n    counter._value += 1;\n  }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n  unchecked {\n    counter._value = value - 1;\n  }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS,\n    InvalidSignatureV // Deprecated in v4.8\n  }\n\n  function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert(\"ECDSA: invalid signature\");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert(\"ECDSA: invalid signature length\");\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert(\"ECDSA: invalid signature 's' value\");\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength);\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n  function tryRecover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address, RecoverError) {\n    bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n  function recover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n  function tryRecover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address, RecoverError) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      return (address(0), RecoverError.InvalidSignatureS);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature);\n    }\n\n    return (signer, RecoverError.NoError);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n  function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n  function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n  /* solhint-disable var-name-mixedcase */\n  bytes32 private _HASHED_NAME;\n  bytes32 private _HASHED_VERSION;\n  bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n  /* solhint-enable var-name-mixedcase */\n\n  /**\n   * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n  function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n    __EIP712_init_unchained(name, version);\n  }\n\n  function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n  }\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n     */\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n  }\n\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 nameHash,\n    bytes32 versionHash\n  ) private view returns (bytes32) {\n    return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n  function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n    return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n\n  /**\n   * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n  function _EIP712NameHash() internal virtual view returns (bytes32) {\n    return _HASHED_NAME;\n  }\n\n  /**\n   * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n  function _EIP712VersionHash() internal virtual view returns (bytes32) {\n    return _HASHED_VERSION;\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint256[50] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity 0.8.17;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Map type with\n  // bytes32 keys and values.\n  // The Map implementation uses private functions, and user-facing\n  // implementations (such as Uint256ToAddressMap) are just wrappers around\n  // the underlying Map.\n  // This means that we can only create new EnumerableMaps for types that fit\n  // in bytes32.\n\n  struct Bytes32ToBytes32Map {\n    // Storage of keys\n    EnumerableSet.Bytes32Set _keys;\n    mapping(bytes32 => bytes32) _values;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    bytes32 value\n  ) internal returns (bool) {\n    map._values[key] = value;\n    return map._keys.add(key);\n  }\n\n  /**\n   * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n    delete map._values[key];\n    return map._keys.remove(key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n    return map._keys.contains(key);\n  }\n\n  /**\n   * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n    return map._keys.length();\n  }\n\n  /**\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n    bytes32 key = map._keys.at(index);\n    return (key, map._values[key]);\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n    bytes32 value = map._values[key];\n    if (value == bytes32(0)) {\n      return (contains(map, key), bytes32(0));\n    } else {\n      return (true, value);\n    }\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n    return value;\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    string memory errorMessage\n  ) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), errorMessage);\n    return value;\n  }\n\n  // UintToUintMap\n\n  struct UintToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    UintToUintMap storage map,\n    uint256 key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(UintToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(key)));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    UintToUintMap storage map,\n    uint256 key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(key), errorMessage));\n  }\n\n  // UintToAddressMap\n\n  struct UintToAddressMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    UintToAddressMap storage map,\n    uint256 key,\n    address value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    UintToAddressMap storage map,\n    uint256 key,\n    string memory errorMessage\n  ) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n  }\n\n  // AddressToUintMap\n\n  struct AddressToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    AddressToUintMap storage map,\n    address key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n    return remove(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n    return contains(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (address(uint160(uint256(key))), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    AddressToUintMap storage map,\n    address key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n  }\n\n  // Bytes32ToUintMap\n\n  struct Bytes32ToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    Bytes32ToUintMap storage map,\n    bytes32 key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, key, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n    return remove(map._inner, key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n    return contains(map._inner, key);\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (key, uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, key);\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n    return uint256(get(map._inner, key));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    Bytes32ToUintMap storage map,\n    bytes32 key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, key, errorMessage));\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity 0.8.17;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n     */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    bytes32[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n     */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity 0.8.17;\n\nimport \"./ERC20Upgradeable.sol\";\nimport \"./ECDSAUpgradeable.sol\";\nimport \"./EIP712Upgradeable.sol\";\nimport \"./CountersUpgradeable.sol\";\nimport \"./Initializable.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable {\n  using CountersUpgradeable for CountersUpgradeable.Counter;\n\n  mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 private constant _PERMIT_TYPEHASH =\n  keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  /**\n   * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n  /**\n   * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n  function __ERC20Permit_init(string memory name) internal onlyInitializing {\n    __EIP712_init_unchained(name, \"1\");\n  }\n\n  function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n  /**\n   * @dev See {IERC20Permit-permit}.\n     */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual override {\n    require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n    bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n    bytes32 hash = _hashTypedDataV4(structHash);\n\n    address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n    require(signer == owner, \"ERC20Permit: invalid signature\");\n\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev See {IERC20Permit-nonces}.\n     */\n  function nonces(address owner) public view virtual override returns (uint256) {\n    return _nonces[owner].current();\n  }\n\n  /**\n   * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n  function _useNonce(address owner) internal virtual returns (uint256 current) {\n    CountersUpgradeable.Counter storage nonce = _nonces[owner];\n    current = nonce.current();\n    nonce.increment();\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint256[49] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"./ContextUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata {\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) internal _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n  function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n    __ERC20_init_unchained(name_, symbol_);\n  }\n\n  function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n     */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n     */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n  function transfer(address to, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n     */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    uint256 currentAllowance = allowance(owner, spender);\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n  unchecked {\n    _approve(owner, spender, currentAllowance - subtractedValue);\n  }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n  unchecked {\n    _balances[from] = fromBalance - amount;\n    // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n    // decrementing then incrementing.\n    _balances[to] += amount;\n  }\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n  unchecked {\n    // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n    _balances[account] += amount;\n  }\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n  unchecked {\n    _balances[account] = accountBalance - amount;\n    // Overflow not possible: amount <= accountBalance <= totalSupply.\n    _totalSupply -= amount;\n  }\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - amount);\n    }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint256[45] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n  uint8 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n     */\n  bool private _initializing;\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n  event Initialized(uint8 version);\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n      \"Initializable: contract is already initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n      emit Initialized(1);\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier reinitializer(uint8 version) {\n    require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n    emit Initialized(version);\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n  modifier onlyInitializing() {\n    require(_initializing, \"Initializable: contract is not initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Initializable: contract is initializing\");\n    if (_initialized != type(uint8).max) {\n      _initialized = type(uint8).max;\n      emit Initialized(type(uint8).max);\n    }\n  }\n\n  /**\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n  function _getInitializedVersion() internal view returns (uint8) {\n    return _initialized;\n  }\n\n  /**\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n  function _isInitializing() internal view returns (bool) {\n    return _initializing;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n     */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n     */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(x, y, not(0))\n      prod0 := mul(x, y)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n      return prod0 / denominator;\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    require(denominator > prod1, \"Math: mulDiv overflow\");\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly {\n    // Compute remainder using mulmod.\n      remainder := mulmod(x, y, denominator)\n\n    // Subtract 256 bit number from 512 bit number.\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n    // See https://cs.stackexchange.com/q/138556/92363.\n\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\n    uint256 twos = denominator & (~denominator + 1);\n    assembly {\n    // Divide denominator by twos.\n      denominator := div(denominator, twos)\n\n    // Divide [prod1 prod0] by twos.\n      prod0 := div(prod0, twos)\n\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n\n    // Shift in bits from prod1 into prod0.\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n    // four bits. That is, denominator * inv = 1 mod 2^4.\n    uint256 inverse = (3 * denominator) ^ 2;\n\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n    // in modular arithmetic, doubling the correct bits in each step.\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inverse;\n    return result;\n  }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator,\n    Rounding rounding\n  ) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n  unchecked {\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    return min(result, a / result);\n  }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = sqrt(a);\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 128;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 64;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 32;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 16;\n    }\n    if (value >> 8 > 0) {\n      value >>= 8;\n      result += 8;\n    }\n    if (value >> 4 > 0) {\n      value >>= 4;\n      result += 4;\n    }\n    if (value >> 2 > 0) {\n      value >>= 2;\n      result += 2;\n    }\n    if (value >> 1 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log2(value);\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >= 10**64) {\n      value /= 10**64;\n      result += 64;\n    }\n    if (value >= 10**32) {\n      value /= 10**32;\n      result += 32;\n    }\n    if (value >= 10**16) {\n      value /= 10**16;\n      result += 16;\n    }\n    if (value >= 10**8) {\n      value /= 10**8;\n      result += 8;\n    }\n    if (value >= 10**4) {\n      value /= 10**4;\n      result += 4;\n    }\n    if (value >= 10**2) {\n      value /= 10**2;\n      result += 2;\n    }\n    if (value >= 10**1) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log10(value);\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 16;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 8;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 4;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 2;\n    }\n    if (value >> 8 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log256(value);\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n  }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n    // Copy msg.data. We take full control of memory in this inline assembly\n    // block because it will not return to Solidity code. We overwrite the\n    // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n    // Call the implementation.\n    // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n    // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return (0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n  // Booleans are more expensive than uint256 or any type that takes up a full\n  // word because each write operation emits an extra SLOAD to first read the\n  // slot's contents, replace the bits taken up by the boolean, and then write\n  // back. This is the compiler's defense against contract upgrades and\n  // pointer aliasing, and it cannot be disabled.\n\n  // The values being non-zero value makes deployment a bit more expensive,\n  // but in exchange the refund on every call to nonReentrant will be lower in\n  // amount. Since refunds are capped to a percentage of the total\n  // transaction's gas, it is best to keep them low in cases like this one, to\n  // increase the likelihood of the full refund coming into effect.\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor() {\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n  modifier nonReentrant() {\n    _nonReentrantBefore();\n    _;\n    _nonReentrantAfter();\n  }\n\n  function _nonReentrantBefore() private {\n    // On the first call to nonReentrant, _status will be _NOT_ENTERED\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n  }\n\n  function _nonReentrantAfter() private {\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n  function _reentrancyGuardEntered() internal view returns (bool) {\n    return _status == _ENTERED;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n  unchecked {\n    uint256 oldAllowance = token.allowance(address(this), spender);\n    require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n    uint256 newAllowance = oldAllowance - value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n  function toString(uint256 value) internal pure returns (string memory) {\n  unchecked {\n    uint256 length = Math.log10(value) + 1;\n    string memory buffer = new string(length);\n    uint256 ptr;\n    /// @solidity memory-safe-assembly\n    assembly {\n      ptr := add(buffer, add(32, length))\n    }\n    while (true) {\n      ptr--;\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n      }\n      value /= 10;\n      if (value == 0) break;\n    }\n    return buffer;\n  }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n  unchecked {\n    return toHexString(value, Math.log256(value) + 1);\n  }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/ControllableV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/SlotsLib.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"3.0.0\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  /// @dev Prevent implementation init\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) internal onlyInitializing {\n    require(controller_ != address(0), \"Zero controller\");\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\n    require(IController(controller_).governance() != address(0), \"Zero governance\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address _value) public override view returns (bool) {\n    return _value == controller();\n  }\n\n  /// @notice Return true if given address is setup as governance in Controller\n  function isGovernance(address _value) public override view returns (bool) {\n    return IController(controller()).governance() == _value;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view returns (uint){\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view returns (address){\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return controller address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/ProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"./UpgradeableProxy.sol\";\nimport \"../interfaces/IERC165.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title EIP1967 Upgradable proxy implementation.\n/// @dev Only Controller has access and should implement time-lock for upgrade action.\n/// @author belbix\ncontract ProxyControlled is UpgradeableProxy, IProxyControlled {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant PROXY_CONTROLLED_VERSION = \"1.0.1\";\n\n  /// @dev Initialize proxy implementation. Need to call after deploy new proxy.\n  function initProxy(address _logic) external override {\n    //make sure that given logic is controllable and not inited\n    require(IERC165(_logic).supportsInterface(InterfaceIds.I_CONTROLLABLE), \"Proxy: Wrong implementation\");\n    _init(_logic);\n  }\n\n  /// @notice Upgrade contract logic\n  /// @dev Upgrade allowed only for Controller and should be done only after time-lock period\n  /// @param _newImplementation Implementation address\n  function upgrade(address _newImplementation) external override {\n    require(IERC165(_newImplementation).supportsInterface(InterfaceIds.I_CONTROLLABLE), \"Proxy: Wrong implementation\");\n    require(IControllable(address(this)).isController(msg.sender), \"Proxy: Forbidden\");\n    IControllable(address(this)).increaseRevision(_implementation());\n    _upgradeTo(_newImplementation);\n    // the new contract must have the same ABI and you must have the power to change it again\n    require(IControllable(address(this)).isController(msg.sender), \"Proxy: Wrong implementation\");\n  }\n\n  /// @notice Return current logic implementation\n  function implementation() external override view returns (address) {\n    return _implementation();\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Proxy.sol\";\nimport \"../openzeppelin/Address.sol\";\n\n/// @title OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/proxy/UpgradeableProxy.sol\n/// @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n///      implementation address that can be changed. This address is stored in storage in the location specified by\n///      https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n///      implementation behind the proxy.\n///      Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n///      {TransparentUpgradeableProxy}.\nabstract contract UpgradeableProxy is Proxy {\n\n  /// @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n  ///      If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n  ///      function call, and allows initializating the storage of the proxy like a Solidity constructor.\n  constructor() payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n  }\n\n  /// @dev Emitted when the implementation is upgraded.\n  event Upgraded(address indexed implementation);\n\n  ///@dev Storage slot with the address of the current implementation.\n  ///     This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n  ///     validated in the constructor.\n  bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /// @dev Post deploy initialisation for compatability with EIP-1167 factory\n  function _init(address _logic) internal {\n    require(_implementation() == address(0), \"Already inited\");\n    _setImplementation(_logic);\n  }\n\n  /// @dev Returns the current implementation address.\n  function _implementation() internal view virtual override returns (address impl) {\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /// @dev Upgrades the proxy to a new implementation.\n  ///      Emits an {Upgraded} event.\n  function _upgradeTo(address newImplementation) internal virtual {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /// @dev Stores a new address in the EIP1967 implementation slot.\n  function _setImplementation(address newImplementation) private {\n    require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/reward/MultiBribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IBribe.sol\";\nimport \"./StakelessMultiPoolBase.sol\";\nimport \"../interfaces/IForwarder.sol\";\n\n/// @title Stakeless pool for ve token\n/// @author belbix\ncontract MultiBribe is StakelessMultiPoolBase, IBribe {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant MULTI_BRIBE_VERSION = \"1.0.1\";\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev The ve token used for gauges\n  address public ve;\n  /// @dev vault => rt => epoch => amount\n  mapping(address => mapping(address => mapping(uint => uint))) public rewardsQueue;\n  /// @dev Current epoch for delayed rewards\n  uint public override epoch;\n  address public epochOperator;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event BribeDeposit(address indexed vault, uint indexed veId, uint amount);\n  event BribeWithdraw(address indexed vault, uint indexed veId, uint amount);\n  event RewardsForNextEpoch(address vault, address token, uint epoch, uint amount);\n  event DelayedRewardsNotified(address vault, address token, uint epoch, uint amount);\n  event EpochOperatorChanged(address value);\n  event EpochIncreased(uint epoch);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  function init(\n    address controller_,\n    address _ve,\n    address _defaultReward\n  ) external initializer {\n    __MultiPool_init(controller_, _defaultReward, 1);\n    _requireInterface(_ve, InterfaceIds.I_VE_TETU);\n    ve = _ve;\n  }\n\n  function voter() public view returns (address) {\n    return IController(controller()).voter();\n  }\n\n  // *************************************************************\n  //                      GOV ACTIONS\n  // *************************************************************\n\n  function setEpochOperator(address value) external {\n    require(isGovernance(msg.sender), \"!gov\");\n    epochOperator = value;\n    emit EpochOperatorChanged(value);\n  }\n\n  // *************************************************************\n  //                        CLAIMS\n  // *************************************************************\n\n  function getReward(\n    address _vault,\n    uint veId,\n    address[] memory tokens\n  ) external override {\n    _getReward(_vault, veId, tokens, IERC721(ve).ownerOf(veId));\n  }\n\n  function getAllRewards(\n    address _vault,\n    uint veId\n  ) external override {\n    _getAllRewards(_vault, veId, IERC721(ve).ownerOf(veId));\n  }\n\n  function _getAllRewards(\n    address _vault,\n    uint veId,\n    address recipient\n  ) internal {\n    address[] storage rts = rewardTokens[_vault];\n    uint length = rts.length;\n    address[] memory tokens = new address[](length + 1);\n    for (uint i; i < length; ++i) {\n      tokens[i] = rts[i];\n    }\n    tokens[length] = defaultRewardToken;\n    _getReward(_vault, veId, tokens, recipient);\n  }\n\n  function getAllRewardsForTokens(\n    address[] memory _vaults,\n    uint veId\n  ) external override {\n    address recipient = IERC721(ve).ownerOf(veId);\n    for (uint i; i < _vaults.length; i++) {\n      _getAllRewards(_vaults[i], veId, recipient);\n    }\n  }\n\n  function _getReward(\n    address _vault,\n    uint veId,\n    address[] memory _rewardTokens,\n    address recipient\n  ) internal {\n    IForwarder(IController(controller()).forwarder()).distributeAll(_vault);\n    uint _epoch = epoch;\n    for (uint i; i < _rewardTokens.length; ++i) {\n      _notifyDelayedRewards(_vault, _rewardTokens[i], _epoch);\n    }\n    _getReward(_vault, tokenIdToAddress(veId), _rewardTokens, recipient);\n  }\n\n  // *************************************************************\n  //                   DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  /// @dev Only voter can call it when a user vote for the vault\n  function deposit(address vault, uint amount, uint veId) external override {\n    require(msg.sender == voter(), \"Not voter\");\n    _registerBalanceIncreasing(vault, tokenIdToAddress(veId), amount);\n    emit BribeDeposit(vault, veId, amount);\n  }\n\n  /// @dev Only voter can call it when a user reset the vote for the vault.\n  function withdraw(address vault, uint amount, uint veId) external override {\n    require(msg.sender == voter(), \"Not voter\");\n    _registerBalanceDecreasing(vault, tokenIdToAddress(veId), amount);\n    emit BribeWithdraw(vault, veId, amount);\n  }\n\n  // *************************************************************\n  //                   REWARDS DISTRIBUTION\n  // *************************************************************\n\n  /// @dev Add rewards to the current users\n  function notifyRewardAmount(address vault, address token, uint amount) external nonReentrant override {\n    _notifyRewardAmount(vault, token, amount, true);\n  }\n\n  /// @dev Add delayed rewards for the next epoch\n  function notifyForNextEpoch(address vault, address token, uint amount) external nonReentrant override {\n    require(defaultRewardToken == token || isRewardToken[vault][token], \"Token not allowed\");\n\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n    uint _epoch = epoch + 1;\n    rewardsQueue[vault][token][_epoch] = amount;\n\n    emit RewardsForNextEpoch(vault, token, _epoch, amount);\n  }\n\n  /// @dev Notify delayed rewards\n  function notifyDelayedRewards(address vault, address token, uint _epoch) external nonReentrant override {\n    require(epoch >= _epoch, \"!epoch\");\n    _notifyDelayedRewards(vault, token, _epoch);\n  }\n\n  function _notifyDelayedRewards(address vault, address token, uint _epoch) internal {\n    uint amount = rewardsQueue[vault][token][_epoch];\n    if (amount != 0 && amount > left(vault, token)) {\n      _notifyRewardAmount(vault, token, amount, false);\n      delete rewardsQueue[vault][token][_epoch];\n      emit DelayedRewardsNotified(vault, token, epoch, amount);\n    }\n  }\n\n  /// @dev Increase the current epoch by one, Epoch operator should increase it weekly.\n  function increaseEpoch() external override {\n    require(msg.sender == epochOperator, \"!operator\");\n    epoch++;\n    emit EpochIncreased(epoch);\n  }\n\n  // *************************************************************\n  //                   INTERNAL LOGIC\n  // *************************************************************\n\n  function isStakeToken(address token) public view override returns (bool) {\n    return IController(controller()).isValidVault(token);\n  }\n\n  function addressToTokenId(address adr) public pure returns (uint) {\n    return uint(uint160(adr));\n  }\n\n  function tokenIdToAddress(uint tokenId) public pure returns (address) {\n    address adr = address(uint160(tokenId));\n    require(addressToTokenId(adr) == tokenId, \"Wrong convert\");\n    return adr;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override(StakelessMultiPoolBase) returns (bool) {\n    return interfaceId == InterfaceIds.I_BRIBE || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/reward/MultiGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IVeTetu.sol\";\nimport \"../interfaces/IGauge.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./StakelessMultiPoolBase.sol\";\n\n/// @title Stakeless pool for vaults\n/// @author belbix\ncontract MultiGauge is StakelessMultiPoolBase, IGauge {\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant MULTI_GAUGE_VERSION = \"1.0.0\";\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev The ve token used for gauges\n  address public ve;\n  /// @dev staking token => ve owner => veId\n  mapping(address => mapping(address => uint)) public override veIds;\n  /// @dev Staking token => whitelist status\n  mapping(address => bool) public stakingTokens;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event AddStakingToken(address token);\n  event Deposit(address indexed stakingToken, address indexed account, uint amount);\n  event Withdraw(address indexed stakingToken, address indexed account, uint amount, bool full, uint veId);\n  event VeTokenLocked(address indexed stakingToken, address indexed account, uint tokenId);\n  event VeTokenUnlocked(address indexed stakingToken, address indexed account, uint tokenId);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  function init(\n    address controller_,\n    address _ve,\n    address _defaultRewardToken\n  ) external initializer {\n    __MultiPool_init(controller_, _defaultRewardToken, 7 days);\n    _requireInterface(_ve, InterfaceIds.I_VE_TETU);\n    ve = _ve;\n  }\n\n  function voter() public view returns (IVoter) {\n    return IVoter(IController(controller()).voter());\n  }\n\n  // *************************************************************\n  //                    OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev Allowed contracts can whitelist token. Removing is forbidden.\n  function addStakingToken(address token) external override onlyAllowedContracts {\n    stakingTokens[token] = true;\n    emit AddStakingToken(token);\n  }\n\n  // *************************************************************\n  //                        CLAIMS\n  // *************************************************************\n\n  function getReward(\n    address stakingToken,\n    address account,\n    address[] memory tokens\n  ) external override {\n    _getReward(stakingToken, account, tokens);\n  }\n\n  function getAllRewards(\n    address stakingToken,\n    address account\n  ) external override {\n    _getAllRewards(stakingToken, account);\n  }\n\n  function _getAllRewards(\n    address stakingToken,\n    address account\n  ) internal {\n    address[] storage rts = rewardTokens[stakingToken];\n    uint length = rts.length;\n    address[] memory tokens = new address[](length + 1);\n    for (uint i; i < length; ++i) {\n      tokens[i] = rts[i];\n    }\n    tokens[length] = defaultRewardToken;\n    _getReward(stakingToken, account, tokens);\n  }\n\n  function getAllRewardsForTokens(\n    address[] memory _stakingTokens,\n    address account\n  ) external override {\n    for (uint i; i < _stakingTokens.length; i++) {\n      _getAllRewards(_stakingTokens[i], account);\n    }\n  }\n\n  function _getReward(address stakingToken, address account, address[] memory tokens) internal {\n    voter().distribute(stakingToken);\n    _getReward(stakingToken, account, tokens, account);\n  }\n\n  // *************************************************************\n  //                   VIRTUAL DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  function attachVe(address stakingToken, address account, uint veId) external override {\n    require(IERC721(ve).ownerOf(veId) == account && account == msg.sender, \"Not ve token owner\");\n    require(isStakeToken(stakingToken), \"Wrong staking token\");\n\n    if (veIds[stakingToken][account] == 0) {\n      veIds[stakingToken][account] = veId;\n      voter().attachTokenToGauge(stakingToken, veId, account);\n    }\n    require(veIds[stakingToken][account] == veId, \"Wrong ve\");\n\n    _updateDerivedBalance(stakingToken, account);\n    _updateRewardForAllTokens(stakingToken, account);\n    emit VeTokenLocked(stakingToken, account, veId);\n  }\n\n  function detachVe(address stakingToken, address account, uint veId) external override {\n    require((IERC721(ve).ownerOf(veId) == account && msg.sender == account)\n      || msg.sender == address(voter()), \"Not ve token owner or voter\");\n    require(isStakeToken(stakingToken), \"Wrong staking token\");\n\n    _unlockVeToken(stakingToken, account, veId);\n    _updateDerivedBalance(stakingToken, account);\n    _updateRewardForAllTokens(stakingToken, account);\n  }\n\n  /// @dev Must be called from stakingToken when user balance changed.\n  function handleBalanceChange(address account) external override {\n    address stakingToken = msg.sender;\n    require(isStakeToken(stakingToken), \"Wrong staking token\");\n\n    uint stakedBalance = balanceOf[stakingToken][account];\n    uint actualBalance = IERC20(stakingToken).balanceOf(account);\n    if (stakedBalance < actualBalance) {\n      _deposit(stakingToken, account, actualBalance - stakedBalance);\n    } else if (stakedBalance > actualBalance) {\n      _withdraw(stakingToken, account, stakedBalance - actualBalance, actualBalance == 0);\n    }\n  }\n\n  function _deposit(\n    address stakingToken,\n    address account,\n    uint amount\n  ) internal {\n    _registerBalanceIncreasing(stakingToken, account, amount);\n    emit Deposit(stakingToken, account, amount);\n  }\n\n  function _withdraw(\n    address stakingToken,\n    address account,\n    uint amount,\n    bool fullWithdraw\n  ) internal {\n    uint veId = 0;\n    if (fullWithdraw) {\n      veId = veIds[stakingToken][account];\n    }\n    if (veId > 0) {\n      _unlockVeToken(stakingToken, account, veId);\n    }\n    _registerBalanceDecreasing(stakingToken, account, amount);\n    emit Withdraw(\n      stakingToken,\n      account,\n      amount,\n      fullWithdraw,\n      veId\n    );\n  }\n\n  /// @dev Balance should be recalculated after the unlock\n  function _unlockVeToken(address stakingToken, address account, uint veId) internal {\n    require(veId == veIds[stakingToken][account], \"Wrong ve\");\n    veIds[stakingToken][account] = 0;\n    voter().detachTokenFromGauge(stakingToken, veId, account);\n    emit VeTokenUnlocked(stakingToken, account, veId);\n  }\n\n  // *************************************************************\n  //                   LOGIC OVERRIDES\n  // *************************************************************\n\n  /// @dev Similar to Curve https://resources.curve.fi/reward-gauges/boosting-your-crv-rewards#formula\n  function derivedBalance(\n    address stakingToken,\n    address account\n  ) public override view returns (uint) {\n    uint _tokenId = veIds[stakingToken][account];\n    uint _balance = balanceOf[stakingToken][account];\n    uint _derived = _balance * 40 / 100;\n    uint _adjusted = 0;\n    uint _supply = IERC20(ve).totalSupply();\n    if (account == IERC721(ve).ownerOf(_tokenId) && _supply > 0) {\n      _adjusted = (totalSupply[stakingToken] * IVeTetu(ve).balanceOfNFT(_tokenId) / _supply) * 60 / 100;\n    }\n    return Math.min((_derived + _adjusted), _balance);\n  }\n\n  function isStakeToken(address token) public view override returns (bool) {\n    return stakingTokens[token];\n  }\n\n  // *************************************************************\n  //                   REWARDS DISTRIBUTION\n  // *************************************************************\n\n  function notifyRewardAmount(address stakingToken, address token, uint amount) external nonReentrant override {\n    _notifyRewardAmount(stakingToken, token, amount, true);\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override(StakelessMultiPoolBase) returns (bool) {\n    return interfaceId == InterfaceIds.I_GAUGE || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/reward/StakelessMultiPoolBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Math.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IMultiPool.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../lib/InterfaceIds.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Abstract stakeless pool for multiple rewards.\n///        Universal pool for different purposes, cover the most popular use cases.\n/// @author belbix\nabstract contract StakelessMultiPoolBase is TetuERC165, ReentrancyGuard, IMultiPool, ControllableV3 {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant MULTI_POOL_VERSION = \"1.0.0\";\n  /// @dev Precision for internal calculations\n  uint internal constant _PRECISION = 10 ** 27;\n  /// @dev Max reward tokens per 1 staking token\n  uint internal constant _MAX_REWARD_TOKENS = 10;\n\n  // *************************************************************\n  //                        VARIABLES\n  //              Keep names and ordering!\n  //     Add only in the bottom and adjust __gap variable\n  // *************************************************************\n\n  /// @dev Rewards are released over this period\n  uint public duration;\n  /// @dev This token will be always allowed as reward\n  address public defaultRewardToken;\n\n  /// @dev Staking token => Supply adjusted on derived balance logic. Use for rewards boost.\n  mapping(address => uint) public override derivedSupply;\n  /// @dev Staking token => Account => Staking token virtual balance. Can be adjusted regarding rewards boost logic.\n  mapping(address => mapping(address => uint)) public override derivedBalances;\n  /// @dev Staking token => Account => User virtual balance of staking token.\n  mapping(address => mapping(address => uint)) public override balanceOf;\n  /// @dev Staking token => Total amount of attached staking tokens\n  mapping(address => uint) public override totalSupply;\n\n  /// @dev Staking token => Reward token => Reward rate with precision _PRECISION\n  mapping(address => mapping(address => uint)) public rewardRate;\n  /// @dev Staking token => Reward token => Reward finish period in timestamp.\n  mapping(address => mapping(address => uint)) public periodFinish;\n  /// @dev Staking token => Reward token => Last updated time for reward token for internal calculations.\n  mapping(address => mapping(address => uint)) public lastUpdateTime;\n  /// @dev Staking token => Reward token => Part of SNX pool logic. Internal snapshot of reward per token value.\n  mapping(address => mapping(address => uint)) public rewardPerTokenStored;\n\n  /// @dev Staking token => Reward token => Account => amount. Already paid reward amount for snapshot calculation.\n  mapping(address => mapping(address => mapping(address => uint))) public userRewardPerTokenPaid;\n  /// @dev Staking token => Reward token => Account => amount. Snapshot of user's reward per token.\n  mapping(address => mapping(address => mapping(address => uint))) public rewards;\n\n  /// @dev Allowed reward tokens for staking token\n  mapping(address => address[]) public override rewardTokens;\n  /// @dev Allowed reward tokens for staking token stored in map for fast check.\n  mapping(address => mapping(address => bool)) public override isRewardToken;\n  /// @notice account => recipient. All rewards for this account will receive recipient\n  mapping(address => address) public rewardsRedirect;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event BalanceIncreased(address indexed token, address indexed account, uint amount);\n  event BalanceDecreased(address indexed token, address indexed account, uint amount);\n  event NotifyReward(address indexed from, address token, address indexed reward, uint amount);\n  event ClaimRewards(address indexed account, address token, address indexed reward, uint amount, address recepient);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  function __MultiPool_init(\n    address controller_,\n    address _defaultRewardToken,\n    uint _duration\n  ) internal onlyInitializing {\n    __Controllable_init(controller_);\n    _requireERC20(_defaultRewardToken);\n    defaultRewardToken = _defaultRewardToken;\n    require(_duration != 0, \"wrong duration\");\n    duration = _duration;\n  }\n\n  // *************************************************************\n  //                        RESTRICTIONS\n  // *************************************************************\n\n  modifier onlyAllowedContracts() {\n    IController _controller = IController(controller());\n    require(\n      msg.sender == _controller.governance()\n      || msg.sender == _controller.forwarder()\n    , \"Not allowed\");\n    _;\n  }\n\n  // *************************************************************\n  //                            VIEWS\n  // *************************************************************\n\n  /// @dev Should return true for whitelisted reward tokens\n  function isStakeToken(address token) public view override virtual returns (bool);\n\n  /// @dev Length of rewards tokens array for given token\n  function rewardTokensLength(address token) external view override returns (uint) {\n    return rewardTokens[token].length;\n  }\n\n  /// @dev Reward paid for token for the current period.\n  function rewardPerToken(address stakingToken, address rewardToken) public view returns (uint) {\n    uint _derivedSupply = derivedSupply[stakingToken];\n    if (_derivedSupply == 0) {\n      return rewardPerTokenStored[stakingToken][rewardToken];\n    }\n\n    return rewardPerTokenStored[stakingToken][rewardToken]\n    +\n    (lastTimeRewardApplicable(stakingToken, rewardToken) - lastUpdateTime[stakingToken][rewardToken])\n    * rewardRate[stakingToken][rewardToken]\n    / _derivedSupply;\n  }\n\n  /// @dev Returns the last time the reward was modified or periodFinish if the reward has ended\n  function lastTimeRewardApplicable(address stakingToken, address rewardToken) public view returns (uint) {\n    uint _periodFinish = periodFinish[stakingToken][rewardToken];\n    return block.timestamp < _periodFinish ? block.timestamp : _periodFinish;\n  }\n\n  /// @dev Balance of holder adjusted with specific rules for boost calculation.\n  ///      Supposed to be implemented in a parent contract\n  ///      Adjust user balance with some logic, like boost logic.\n  function derivedBalance(address stakingToken, address account) public view virtual override returns (uint) {\n    return balanceOf[stakingToken][account];\n  }\n\n  /// @dev Amount of reward tokens left for the current period\n  function left(address stakingToken, address rewardToken) public view override returns (uint) {\n    uint _periodFinish = periodFinish[stakingToken][rewardToken];\n    if (block.timestamp >= _periodFinish) return 0;\n    uint _remaining = _periodFinish - block.timestamp;\n    return _remaining * rewardRate[stakingToken][rewardToken] / _PRECISION;\n  }\n\n  /// @dev Approximate of earned rewards ready to claim\n  function earned(address stakingToken, address rewardToken, address account) public view override returns (uint) {\n    return derivedBalance(stakingToken, account)\n    * (rewardPerToken(stakingToken, rewardToken) - userRewardPerTokenPaid[stakingToken][rewardToken][account])\n    / _PRECISION\n    + rewards[stakingToken][rewardToken][account];\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override(ControllableV3, TetuERC165) returns (bool) {\n    return interfaceId == InterfaceIds.I_MULTI_POOL || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                  OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev Whitelist reward token for staking token. Only operator can do it.\n  function registerRewardToken(address stakeToken, address rewardToken) external override onlyAllowedContracts {\n    require(rewardTokens[stakeToken].length < _MAX_REWARD_TOKENS, \"Too many reward tokens\");\n    require(!isRewardToken[stakeToken][rewardToken], \"Already registered\");\n    isRewardToken[stakeToken][rewardToken] = true;\n    rewardTokens[stakeToken].push(rewardToken);\n  }\n\n  /// @dev Remove from whitelist reward token for staking token. Only operator can do it.\n  ///      We assume that the first token can not be removed.\n  function removeRewardToken(address stakeToken, address rewardToken) external override onlyAllowedContracts {\n    require(periodFinish[stakeToken][rewardToken] < block.timestamp, \"Rewards not ended\");\n    require(isRewardToken[stakeToken][rewardToken], \"Not reward token\");\n\n    isRewardToken[stakeToken][rewardToken] = false;\n    uint length = rewardTokens[stakeToken].length;\n    uint i = 0;\n    for (; i < length; i++) {\n      address t = rewardTokens[stakeToken][i];\n      if (t == rewardToken) {\n        break;\n      }\n    }\n    // if isRewardToken map and rewardTokens array changed accordingly the token always exist\n    rewardTokens[stakeToken][i] = rewardTokens[stakeToken][length - 1];\n    rewardTokens[stakeToken].pop();\n  }\n\n  /// @dev Account or governance can setup a redirect of all rewards.\n  ///      It needs for 3rd party contracts integrations.\n  function setRewardsRedirect(address account, address recipient) external {\n    require(msg.sender == account || isGovernance(msg.sender), \"Not allowed\");\n    rewardsRedirect[account] = recipient;\n  }\n\n  // *************************************************************\n  //                      BALANCE\n  // *************************************************************\n\n  /// @dev Assume to be called when linked token balance changes.\n  function _registerBalanceIncreasing(\n    address stakingToken,\n    address account,\n    uint amount\n  ) internal virtual nonReentrant {\n    require(isStakeToken(stakingToken), \"Staking token not allowed\");\n    require(amount > 0, \"Zero amount\");\n\n    _increaseBalance(stakingToken, account, amount);\n    emit BalanceIncreased(stakingToken, account, amount);\n  }\n\n  function _increaseBalance(\n    address stakingToken,\n    address account,\n    uint amount\n  ) internal virtual {\n    _updateRewardForAllTokens(stakingToken, account);\n    totalSupply[stakingToken] += amount;\n    balanceOf[stakingToken][account] += amount;\n    _updateDerivedBalance(stakingToken, account);\n  }\n\n  /// @dev Assume to be called when linked token balance changes.\n  function _registerBalanceDecreasing(\n    address stakingToken,\n    address account,\n    uint amount\n  ) internal nonReentrant virtual {\n    require(isStakeToken(stakingToken), \"Staking token not allowed\");\n    _decreaseBalance(stakingToken, account, amount);\n    emit BalanceDecreased(stakingToken, account, amount);\n  }\n\n  function _decreaseBalance(\n    address stakingToken,\n    address account,\n    uint amount\n  ) internal virtual {\n    _updateRewardForAllTokens(stakingToken, account);\n    totalSupply[stakingToken] -= amount;\n    balanceOf[stakingToken][account] -= amount;\n    _updateDerivedBalance(stakingToken, account);\n  }\n\n  function _updateDerivedBalance(address stakingToken, address account) internal {\n    uint __derivedBalance = derivedBalances[stakingToken][account];\n    derivedSupply[stakingToken] -= __derivedBalance;\n    __derivedBalance = derivedBalance(stakingToken, account);\n    derivedBalances[stakingToken][account] = __derivedBalance;\n    derivedSupply[stakingToken] += __derivedBalance;\n  }\n\n  // *************************************************************\n  //                          CLAIM\n  // *************************************************************\n\n  /// @dev Caller should implement restriction checks\n  function _getReward(\n    address stakingToken,\n    address account,\n    address[] memory rewardTokens_,\n    address recipient\n  ) internal nonReentrant virtual {\n    address newRecipient = rewardsRedirect[recipient];\n    if (newRecipient != address(0)) {\n      recipient = newRecipient;\n    }\n    require(recipient == msg.sender, \"Not allowed\");\n\n    _updateDerivedBalance(stakingToken, account);\n\n    for (uint i = 0; i < rewardTokens_.length; i++) {\n      address rewardToken = rewardTokens_[i];\n      _updateReward(stakingToken, rewardToken, account);\n\n      uint _reward = rewards[stakingToken][rewardToken][account];\n      if (_reward > 0) {\n        rewards[stakingToken][rewardToken][account] = 0;\n        IERC20(rewardToken).safeTransfer(recipient, _reward);\n      }\n\n      emit ClaimRewards(account, stakingToken, rewardToken, _reward, recipient);\n    }\n  }\n\n  // *************************************************************\n  //                    REWARDS CALCULATIONS\n  // *************************************************************\n\n  function _updateRewardForAllTokens(address stakingToken, address account) internal {\n    address[] memory rts = rewardTokens[stakingToken];\n    uint length = rts.length;\n    for (uint i; i < length; i++) {\n      _updateReward(stakingToken, rts[i], account);\n    }\n    _updateReward(stakingToken, defaultRewardToken, account);\n  }\n\n  function _updateReward(address stakingToken, address rewardToken, address account) internal {\n    uint _rewardPerTokenStored = rewardPerToken(stakingToken, rewardToken);\n    rewardPerTokenStored[stakingToken][rewardToken] = _rewardPerTokenStored;\n    lastUpdateTime[stakingToken][rewardToken] = lastTimeRewardApplicable(stakingToken, rewardToken);\n    if (account != address(0)) {\n      rewards[stakingToken][rewardToken][account] = earned(stakingToken, rewardToken, account);\n      userRewardPerTokenPaid[stakingToken][rewardToken][account] = _rewardPerTokenStored;\n    }\n  }\n\n  // *************************************************************\n  //                         NOTIFY\n  // *************************************************************\n\n  function _notifyRewardAmount(\n    address stakingToken,\n    address rewardToken,\n    uint amount,\n    bool transferRewards\n  ) internal virtual {\n    require(amount > 0, \"Zero amount\");\n    require(defaultRewardToken == rewardToken || isRewardToken[stakingToken][rewardToken], \"Token not allowed\");\n\n    _updateReward(stakingToken, rewardToken, address(0));\n    uint _duration = duration;\n\n    if (transferRewards) {\n      uint balanceBefore = IERC20(rewardToken).balanceOf(address(this));\n      IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n      // refresh amount if token was taxable\n      amount = IERC20(rewardToken).balanceOf(address(this)) - balanceBefore;\n    }\n    // if transferRewards=false need to wisely use it in implementation!\n\n    if (block.timestamp >= periodFinish[stakingToken][rewardToken]) {\n      rewardRate[stakingToken][rewardToken] = amount * _PRECISION / _duration;\n    } else {\n      uint _remaining = periodFinish[stakingToken][rewardToken] - block.timestamp;\n      uint _left = _remaining * rewardRate[stakingToken][rewardToken];\n      // rewards should not extend period infinity, only higher amount allowed\n      require(amount > _left / _PRECISION, \"Amount should be higher than remaining rewards\");\n      rewardRate[stakingToken][rewardToken] = (amount * _PRECISION + _left) / _duration;\n    }\n\n    lastUpdateTime[stakingToken][rewardToken] = block.timestamp;\n    periodFinish[stakingToken][rewardToken] = block.timestamp + _duration;\n    emit NotifyReward(msg.sender, stakingToken, rewardToken, amount);\n  }\n\n  /**\n* @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[38] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./StrategyLib.sol\";\n\n/// @title Abstract contract for base strategy functionality\n/// @author belbix\nabstract contract StrategyBaseV2 is IStrategyV2, ControllableV3 {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant STRATEGY_BASE_VERSION = \"2.2.5\";\n  /// @dev Denominator for compound ratio\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n  /// @notice 10% of total profit is sent to {performanceReceiver} before compounding\n  uint internal constant DEFAULT_PERFORMANCE_FEE = 10_000;\n  address internal constant DEFAULT_PERF_FEE_RECEIVER = 0x9Cc199D4353b5FB3e6C8EEBC99f5139e0d8eA06b;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Linked splitter\n  address public override splitter;\n  /// @dev Percent of profit for autocompound inside this strategy.\n  uint public override compoundRatio;\n  uint private __deprecatedSlot1;\n\n  /// @notice {performanceFee}% of total profit is sent to {performanceReceiver} before compounding\n  /// @dev governance by default\n  address public override performanceReceiver;\n\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\n  /// @dev {DEFAULT_PERFORMANCE_FEE} by default, FEE_DENOMINATOR is used\n  uint public override performanceFee;\n  /// @dev Represent specific name for this strategy. Should include short strategy name and used assets. Uniq across the vault.\n  string public override strategySpecificName;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event WithdrawAllToSplitter(uint amount);\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\n  event EmergencyExit(address sender, uint amount);\n  event ManualClaim(address sender);\n  event InvestAll(uint balance);\n  event DepositToPool(uint amount);\n  event WithdrawFromPool(uint amount);\n  event WithdrawAllFromPool(uint amount);\n  event Claimed(address token, uint amount);\n  event CompoundRatioChanged(uint oldValue, uint newValue);\n  event StrategySpecificNameChanged(string name);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __StrategyBase_init(\n    address controller_,\n    address _splitter\n  ) internal onlyInitializing {\n    _requireInterface(_splitter, InterfaceIds.I_SPLITTER);\n    __Controllable_init(controller_);\n\n    require(IControllable(_splitter).isController(controller_), StrategyLib.WRONG_VALUE);\n\n    asset = ISplitter(_splitter).asset();\n    splitter = _splitter;\n\n    performanceReceiver = DEFAULT_PERF_FEE_RECEIVER;\n    performanceFee = DEFAULT_PERFORMANCE_FEE;\n  }\n\n  // *************************************************************\n  //                     PERFORMANCE FEE\n  // *************************************************************\n  /// @notice Set performance fee and receiver\n  function setupPerformanceFee(uint fee_, address receiver_) external {\n    StrategyLib.onlyGovernance(controller());\n    require(fee_ <= 100_000, StrategyLib.TOO_HIGH);\n    require(receiver_ != address(0), StrategyLib.WRONG_VALUE);\n\n    performanceFee = fee_;\n    performanceReceiver = receiver_;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of underlying assets under control of this strategy.\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this)) + investedAssets();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_STRATEGY_V2 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                   VOTER ACTIONS\n  // *************************************************************\n\n  /// @dev PlatformVoter can change compound ratio for some strategies.\n  ///      A strategy can implement another logic for some uniq cases.\n  function setCompoundRatio(uint value) external virtual override {\n    StrategyLib.onlyPlatformVoter(controller());\n    require(value <= COMPOUND_DENOMINATOR, StrategyLib.TOO_HIGH);\n    emit CompoundRatioChanged(compoundRatio, value);\n    compoundRatio = value;\n  }\n\n  // *************************************************************\n  //                   OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev The name will be used for UI.\n  function setStrategySpecificName(string memory name) external {\n    StrategyLib.onlyOperators(controller());\n    strategySpecificName = name;\n    emit StrategySpecificNameChanged(name);\n  }\n\n  /// @dev In case of any issue operator can withdraw all from pool.\n  function emergencyExit() external {\n    StrategyLib.onlyOperators(controller());\n\n    _emergencyExitFromPool();\n\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    IERC20(_asset).safeTransfer(splitter, balance);\n    emit EmergencyExit(msg.sender, balance);\n  }\n\n  /// @dev Manual claim rewards.\n  function claim() external {\n    StrategyLib.onlyOperators(controller());\n\n    _claim();\n    emit ManualClaim(msg.sender);\n  }\n\n  // *************************************************************\n  //                    DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function investAll(\n    uint /*amount_*/,\n    bool updateTotalAssetsBeforeInvest_\n  ) external override returns (\n    uint strategyLoss\n  ) {\n    StrategyLib.onlySplitter(splitter);\n\n    uint balance = IERC20(asset).balanceOf(address(this));\n\n    if (balance > 0) {\n      strategyLoss = _depositToPool(balance, updateTotalAssetsBeforeInvest_);\n    }\n    emit InvestAll(balance);\n\n    return strategyLoss;\n  }\n\n  /// @dev Withdraws all underlying assets to the vault\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawAllToSplitter() external override returns (uint strategyLoss) {\n    address _splitter = splitter;\n    address _asset = asset;\n    StrategyLib.onlySplitter(_splitter);\n\n    uint balance = IERC20(_asset).balanceOf(address(this));\n\n    (uint expectedWithdrewUSD, uint assetPrice, uint _strategyLoss) = _withdrawAllFromPool();\n\n    balance = StrategyLib.checkWithdrawImpact(\n      _asset,\n      balance,\n      expectedWithdrewUSD,\n      assetPrice,\n      _splitter\n    );\n\n    if (balance != 0) {\n      IERC20(_asset).safeTransfer(_splitter, balance);\n    }\n    emit WithdrawAllToSplitter(balance);\n\n    return _strategyLoss;\n  }\n\n  /// @dev Withdraws some assets to the splitter\n  /// @return strategyLoss Loss should be covered from Insurance\n  function withdrawToSplitter(uint amount) external override returns (uint strategyLoss) {\n    address _splitter = splitter;\n    address _asset = asset;\n    StrategyLib.onlySplitter(_splitter);\n\n\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (amount > balance) {\n      uint expectedWithdrewUSD;\n      uint assetPrice;\n\n      (expectedWithdrewUSD, assetPrice, strategyLoss) = _withdrawFromPool(amount - balance);\n      balance = StrategyLib.checkWithdrawImpact(\n        _asset,\n        balance,\n        expectedWithdrewUSD,\n        assetPrice,\n        _splitter\n      );\n    }\n\n    uint amountAdjusted = Math.min(amount, balance);\n    if (amountAdjusted != 0) {\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\n    }\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\n\n    return strategyLoss;\n  }\n\n  // *************************************************************\n  //                       VIRTUAL\n  // These functions must be implemented in the strategy contract\n  // *************************************************************\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _depositToPool(\n    uint amount,\n    bool updateTotalAssetsBeforeInvest_\n  ) internal virtual returns (\n    uint strategyLoss\n  );\n\n  /// @dev Withdraw given amount from the pool.\n  /// @return expectedWithdrewUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawFromPool(uint amount) internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  );\n\n  /// @dev Withdraw all from the pool.\n  /// @return expectedWithdrewUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawAllFromPool() internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  );\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  ///      Withdraw assets without impact checking.\n  function _emergencyExitFromPool() internal virtual;\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal virtual returns (address[] memory rewardTokens, uint[] memory amounts);\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  ///      variables without shifting down storage in the inheritance chain.\n  ///      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[43] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\n\nlibrary StrategyLib {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Denominator for fee calculation.\n  uint internal constant FEE_DENOMINATOR = 100_000;\n\n  // *************************************************************\n  //                        ERRORS\n  // *************************************************************\n\n  string internal constant DENIED = \"SB: Denied\";\n  string internal constant TOO_HIGH = \"SB: Too high\";\n  string internal constant WRONG_VALUE = \"SB: Wrong value\";\n\n  // *************************************************************\n  //                     RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Restrict access only for operators\n  function onlyOperators(address controller) external view {\n    require(IController(controller).isOperator(msg.sender), DENIED);\n  }\n\n  /// @dev Restrict access only for governance\n  function onlyGovernance(address controller) external view {\n    require(IController(controller).governance() == msg.sender, DENIED);\n  }\n\n  /// @dev Restrict access only for platform voter\n  function onlyPlatformVoter(address controller) external view {\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\n  }\n\n  /// @dev Restrict access only for splitter\n  function onlySplitter(address splitter) external view {\n    require(splitter == msg.sender, DENIED);\n  }\n\n  // *************************************************************\n  //                       HELPERS\n  // *************************************************************\n\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\n  ///         Revert if the amount is different from expected too much (high price impact)\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\n  /// @param assetPrice Price of the asset, decimals 18\n  /// @return balance Current asset balance of the strategy\n  function checkWithdrawImpact(\n    address _asset,\n    uint balanceBefore,\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    address _splitter\n  ) external view returns (uint balance) {\n    balance = IERC20(_asset).balanceOf(address(this));\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\n\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\n    }\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/ControllerMinimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\ncontract ControllerMinimal is TetuERC165, IController {\n\n  address public override governance;\n  address public override voter;\n  address public override liquidator;\n  address public override forwarder;\n  address public override investFund;\n  address public override veDistributor;\n  address public override platformVoter;\n  address[] public override vaults;\n  mapping(address => bool) public operators;\n\n  constructor (address governance_) {\n    governance = governance_;\n    operators[governance_] = true;\n  }\n\n  function setVoter(address _voter) external {\n    voter = _voter;\n  }\n\n  function setPlatformVoter(address _voter) external {\n    platformVoter = _voter;\n  }\n\n  function setLiquidator(address value) external {\n    liquidator = value;\n  }\n\n  function setInvestFund(address value) external {\n    investFund = value;\n  }\n\n  function setForwarder(address value) external {\n    forwarder = value;\n  }\n\n  function setVeDistributor(address value) external {\n    veDistributor = value;\n  }\n\n  function addVault(address vault) external {\n    vaults.push(vault);\n  }\n\n  function addOperator(address operator) external {\n    operators[operator] = true;\n  }\n\n  function updateProxies(address[] memory proxies, address[] memory newLogics) external {\n    require(proxies.length == newLogics.length, \"Wrong arrays\");\n    for (uint i; i < proxies.length; i++) {\n      IProxyControlled(proxies[i]).upgrade(newLogics[i]);\n    }\n  }\n\n  function vaultsList() external view override returns (address[] memory) {\n    return vaults;\n  }\n\n  function vaultsListLength() external override view returns (uint) {\n    return vaults.length;\n  }\n\n  function isValidVault(address _vault) external view override returns (bool) {\n    for (uint i; i < vaults.length; i++) {\n      if (_vault == vaults[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function isOperator(address _adr) external view override returns (bool) {\n    return operators[_adr];\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLER || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/IMockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IMockToken {\n\n  function decimals() external view returns (uint8);\n\n  function mint(address to, uint amount) external;\n\n  function burn(address from, uint amount) external;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../proxy/ControllableV3.sol\";\n\ncontract MockGauge is ControllableV3 {\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n\n  function handleBalanceChange(address) external {\n    // noop\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_GAUGE || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\n\ncontract MockPool {\n\n  function withdraw(address token, uint amount) external {\n    IERC20(token).transfer(msg.sender, amount);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\ncontract MockSplitter is ISplitter, ControllableV3 {\n\n  address public override asset;\n  address public override vault;\n  uint public slippage;\n  address[] public strategies;\n  uint public constant HARDWORK_DELAY = 12 hours;\n  mapping(address => bool) public pausedStrategies;\n  mapping(address => uint) public lastHardWorks;\n\n  function init(address controller_, address _asset, address _vault) external initializer override {\n    __Controllable_init(controller_);\n    asset = _asset;\n    vault = _vault;\n  }\n\n  function pauseInvesting(address strategy) external {\n    require(!pausedStrategies[strategy], \"SS: Paused\");\n    pausedStrategies[strategy] = true;\n  }\n\n  function continueInvesting(address strategy, uint /*apr*/) external {\n    require(pausedStrategies[strategy], \"SS: Not paused\");\n    pausedStrategies[strategy] = false;\n  }\n\n  function setSlippage(uint value) external {\n    slippage = value;\n  }\n\n  function withdrawAllToVault() external override {\n    withdrawToVault(IERC20(asset).balanceOf(address(this)));\n  }\n\n  function withdrawToVault(uint256 amount) public override {\n    uint toSend = amount - amount * slippage / 1000;\n    if (slippage != 0) {\n      IERC20(asset).transfer(controller(), amount - toSend);\n    }\n    IERC20(asset).transfer(vault, toSend);\n  }\n\n  function doHardWork() external override {\n    // noop\n  }\n\n  function investAll() external override {\n    // noop\n  }\n\n  function totalAssets() external view override returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  function isHardWorking() external pure override returns (bool) {\n    return false;\n  }\n\n  function lost(uint amount) external {\n    IERC20(asset).transfer(msg.sender, amount);\n  }\n\n  function coverLoss(uint amount) external {\n    ITetuVaultV2(vault).coverLoss(amount);\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_SPLITTER || super.supportsInterface(interfaceId);\n  }\n\n  function strategiesLength() external view returns (uint) {\n    return strategies.length;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../strategy/StrategyBaseV2.sol\";\nimport \"./MockPool.sol\";\nimport \"./MockToken.sol\";\n\ncontract MockStrategy is StrategyBaseV2 {\n\n  string public constant override NAME = \"mock strategy\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  bool public override isReadyToHardWork;\n\n  uint internal slippage;\n  uint internal slippageDeposit;\n  uint internal hardWorkSlippage;\n  uint internal lastEarned;\n  uint internal lastLost;\n  uint internal _capacity;\n  int internal _totalAssetsDelta;\n  bool internal useTrueExpectedWithdraw;\n\n  MockPool public pool;\n\n  function init(\n    address controller_,\n    address _splitter\n  ) external initializer {\n    __StrategyBase_init(controller_, _splitter);\n    splitter = _splitter;\n    isReadyToHardWork = true;\n    _capacity = type(uint).max;\n    // unlimited capacity by default\n    pool = new MockPool();\n  }\n\n  function doHardWork() external override returns (uint earned, uint lost) {\n    pool.withdraw(asset, investedAssets());\n    uint _slippage = IERC20(asset).balanceOf(address(this)) * hardWorkSlippage / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n    if (lastEarned != 0) {\n      uint toCompound = lastEarned * compoundRatio / COMPOUND_DENOMINATOR;\n      MockToken(asset).mint(address(this), toCompound);\n      address forwarder = IController(controller()).forwarder();\n      if (forwarder != address(0)) {\n        MockToken(asset).mint(address(this), lastEarned - toCompound);\n\n        address[] memory tokens = new address[](1);\n        tokens[0] = asset;\n        uint[] memory amounts = new uint[](1);\n        amounts[0] = lastEarned - toCompound;\n        IForwarder(forwarder).registerIncome(tokens, amounts, ISplitter(splitter).vault(), true);\n      }\n    }\n    IERC20(asset).transfer(address(pool), IERC20(asset).balanceOf(address(this)));\n    return (lastEarned, Math.max(lastLost, _slippage));\n  }\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(pool));\n  }\n\n  /// @dev Deposit given amount to the pool.\n  function _depositToPool(\n    uint amount,\n    bool /*updateTotalAssetsBeforeInvest_*/\n  ) internal override returns (\n    uint strategyLoss\n  ) {\n    uint _slippage = amount * slippageDeposit / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n    if (amount - _slippage != 0) {\n      IERC20(asset).transfer(address(pool), amount - _slippage);\n    }\n\n    return _slippage;\n  }\n\n  /// @dev Withdraw given amount from the pool.\n  function _withdrawFromPool(uint amount) internal override returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  ) {\n    assetPrice = 1e18;\n    if (useTrueExpectedWithdraw) {\n      expectedWithdrewUSD = amount;\n    } else {\n      expectedWithdrewUSD = 0;\n    }\n\n    pool.withdraw(asset, amount);\n    uint _slippage = amount * slippage / 100_000;\n    strategyLoss = _slippage;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n  }\n\n  /// @dev Withdraw all from the pool.\n  function _withdrawAllFromPool() internal override returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  ) {\n    assetPrice = 1e18;\n    if (useTrueExpectedWithdraw) {\n      expectedWithdrewUSD = investedAssets();\n    } else {\n      expectedWithdrewUSD = 0;\n    }\n\n\n    pool.withdraw(asset, investedAssets());\n    uint _slippage = totalAssets() * slippage / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n\n    return (expectedWithdrewUSD, assetPrice, _slippage);\n  }\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  function _emergencyExitFromPool() internal override {\n    pool.withdraw(asset, investedAssets());\n  }\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal pure override returns (address[] memory rewardTokens, uint[] memory amounts) {\n    return (rewardTokens, amounts);\n  }\n\n  function setLast(uint earned, uint lost) external {\n    lastEarned = earned;\n    lastLost = lost;\n  }\n\n  function setSlippage(uint value) external {\n    slippage = value;\n  }\n\n  function setSlippageDeposit(uint value) external {\n    slippageDeposit = value;\n  }\n\n  function setSlippageHardWork(uint value) external {\n    hardWorkSlippage = value;\n  }\n\n  function setReady(bool value) external {\n    isReadyToHardWork = value;\n  }\n\n  function setCompoundRatioManual(uint ratio) external {\n    compoundRatio = ratio;\n  }\n\n  /// @notice Max amount that can be deposited to the strategy, see SCB-593\n  function capacity() external view override returns (uint) {\n    return _capacity;\n  }\n\n  function setCapacity(uint capacity_) external {\n    _capacity = capacity_;\n  }\n\n  function setTotalAssetsDelta(int totalAssetsDelta_) external {\n    _totalAssetsDelta = totalAssetsDelta_;\n  }\n\n  function setUseTrueExpectedWithdraw(bool value) external {\n    useTrueExpectedWithdraw = value;\n  }\n\n\n  ////////////////////////////////////////////////////////\n  ///           Access to internal functions\n  ////////////////////////////////////////////////////////\n  function checkWithdrawImpactAccessForTests(\n    address _asset,\n    uint balanceBefore,\n    uint investedAssetsUSD,\n    uint assetPrice,\n    address _splitter\n  ) external view returns (uint balance) {\n    return StrategyLib.checkWithdrawImpact(_asset, balanceBefore, investedAssetsUSD, assetPrice, _splitter);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockStrategySimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../proxy/ControllableV3.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract MockStrategySimple is ControllableV3, IStrategyV2 {\n\n  string public constant override NAME = \"mock strategy\";\n  string public override strategySpecificName = \"mock strategy1\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  address public override splitter;\n  address public override asset;\n  bool public override isReadyToHardWork;\n  uint public override compoundRatio;\n\n  uint internal slippage;\n  uint internal lastEarned;\n  uint internal lastLost;\n\n  uint internal _capacity;\n  address public override performanceReceiver;\n  uint public override performanceFee;\n\n  function init(\n    address controller_,\n    address _splitter,\n    address _asset\n  ) external initializer {\n    __Controllable_init(controller_);\n    splitter = _splitter;\n    asset = _asset;\n    isReadyToHardWork = true;\n    _capacity = type(uint).max; // unlimited capacity by default\n    performanceReceiver = IController(controller_).governance();\n    performanceFee = 10_000;\n  }\n\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  function withdrawAllToSplitter() external override returns (uint strategyLoss) {\n    return withdrawToSplitter(totalAssets());\n  }\n\n  function withdrawToSplitter(uint amount) public override returns (uint strategyLoss) {\n    uint _slippage = amount * slippage / 100;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n    IERC20(asset).transfer(splitter, amount - _slippage);\n    return _slippage;\n  }\n\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external pure override returns (\n    uint strategyLoss\n  ) {\n    amount_; // hide warning\n    updateTotalAssetsBeforeInvest_; // hide warning\n    // noop\n    return strategyLoss;\n  }\n\n  function doHardWork() external view override returns (uint earned, uint lost) {\n    return (lastEarned, lastLost);\n  }\n\n  function setLast(uint earned, uint lost) external {\n    lastEarned = earned;\n    lastLost = lost;\n  }\n\n  function setSlippage(uint value) external {\n    slippage = value;\n  }\n\n  function setCompoundRatio(uint value) external override {\n    compoundRatio = value;\n  }\n\n  /// @notice Max amount that can be deposited to the strategy, see SCB-593\n  function capacity() external view override returns (uint) {\n    return _capacity;\n  }\n\n  function setCapacity(uint capacity_) external {\n    _capacity = capacity_;\n  }\n\n  /// @notice Set performance fee and receiver\n  function setupPerformanceFee(uint fee_, address receiver_) external {\n    performanceFee = fee_;\n    performanceReceiver = receiver_;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC20Upgradeable.sol\";\n\ncontract MockToken is ERC20Upgradeable {\n\n  uint8 internal _decimals;\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  )  {\n    _init(name_, symbol_, decimals_);\n  }\n\n  function _init(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) internal initializer {\n    __ERC20_init(name_, symbol_);\n    _decimals = decimals_;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  function mint(address to, uint amount) external {\n    _mint(to, amount);\n  }\n\n  function burn(address from, uint amount) external {\n    _burn(from, amount);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n////// /nix/store/im7ll7dx8gsw2da9k5xwbf8pbjfli2hc-multicall-df1e59d/src/Multicall.sol\n/* pragma solidity >=0.5.0; */\n/* pragma experimental ABIEncoderV2; */\n\n/// @title Multicall - Aggregate results from multiple read-only function calls\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\ncontract Multicall {\n  struct Call {\n    address target;\n    bytes callData;\n  }\n\n  function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\n    blockNumber = block.number;\n    returnData = new bytes[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n      require(success);\n      returnData[i] = ret;\n    }\n  }\n\n  // Helper functions\n  function getEthBalance(address addr) public view returns (uint256 balance) {\n    balance = addr.balance;\n  }\n\n  function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n    blockHash = blockhash(blockNumber);\n  }\n\n  function getLastBlockHash() public view returns (bytes32 blockHash) {\n    blockHash = blockhash(block.number - 1);\n  }\n\n  function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n    timestamp = block.timestamp;\n  }\n\n  function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n    difficulty = block.difficulty;\n  }\n\n  function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n    gaslimit = block.gaslimit;\n  }\n\n  function getCurrentBlockCoinbase() public view returns (address coinbase) {\n    coinbase = block.coinbase;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/tools/TetuERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC165.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\n/// @author bogdoslav\nabstract contract TetuERC165 is ERC165 {\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        HELPER FUNCTIONS\n  // *************************************************************\n  /// @author bogdoslav\n\n  /// @dev Checks what interface with id is supported by contract.\n  /// @return bool. Do not throws\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\n      return isSupported;\n    } catch {\n    }\n    return false;\n  }\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\n    require(_isInterfaceSupported(contractAddress, interfaceId), \"Interface is not supported\");\n  }\n\n  /// @dev Checks what address is ERC20.\n  /// @return bool. Do not throws\n  function _isERC20(address contractAddress) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    bool totalSupplySupported;\n    try IERC20(contractAddress).totalSupply() returns (uint) {\n      totalSupplySupported = true;\n    } catch {\n    }\n\n    bool balanceSupported;\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\n      balanceSupported = true;\n    } catch {\n    }\n\n    return totalSupplySupported && balanceSupported;\n  }\n\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireERC20(address contractAddress) internal view {\n    require(_isERC20(contractAddress), \"Not ERC20\");\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC20PermitUpgradeable.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../interfaces/IERC4626.sol\";\nimport \"../lib/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author belbix - adopted to proxy pattern + added ReentrancyGuard\nabstract contract ERC4626Upgradeable is ERC20PermitUpgradeable, ReentrancyGuard, IERC4626 {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n\n  uint internal constant INITIAL_SHARES = 1000;\n  address internal constant DEAD_ADDRESS = 0xdEad000000000000000000000000000000000000;\n\n  /// @dev The address of the underlying token used for the Vault uses for accounting,\n  ///      depositing, and withdrawing\n  IERC20 internal _asset;\n\n  function __ERC4626_init(\n    IERC20 asset_,\n    string memory _name,\n    string memory _symbol\n  ) internal onlyInitializing {\n    __ERC20_init(_name, _symbol);\n    _asset = asset_;\n  }\n\n  function decimals() public view override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {\n    return IERC20Metadata(address(_asset)).decimals();\n  }\n\n  function asset() external view override returns (address) {\n    return address(_asset);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //             DEPOSIT/WITHDRAWAL LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n  /// @dev Mints vault shares to receiver by depositing exactly amount of assets.\n  function deposit(\n    uint assets,\n    address receiver\n  ) public nonReentrant virtual override returns (uint shares) {\n    require(assets <= maxDeposit(receiver), \"MAX\");\n\n    shares = previewDeposit(assets);\n    // Check for rounding error since we round down in previewDeposit.\n    require(shares != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    if(totalSupply() == 0) {\n      _mint(receiver, shares - INITIAL_SHARES);\n      _mint(DEAD_ADDRESS, INITIAL_SHARES);\n    } else {\n      _mint(receiver, shares);\n    }\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares, receiver);\n  }\n\n  function mint(\n    uint shares,\n    address receiver\n  ) public nonReentrant virtual override returns (uint assets) {\n    require(shares <= maxMint(receiver), \"MAX\");\n\n    assets = previewMint(shares);\n    // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    if(totalSupply() == 0) {\n      _mint(receiver, shares - INITIAL_SHARES);\n      _mint(DEAD_ADDRESS, INITIAL_SHARES);\n    } else {\n      _mint(receiver, shares);\n    }\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares, receiver);\n  }\n\n  function withdraw(\n    uint assets,\n    address receiver,\n    address owner\n  ) public nonReentrant virtual override returns (uint shares) {\n    require(assets <= maxWithdraw(owner), \"MAX\");\n\n    shares = previewWithdraw(assets);\n    // No need to check for rounding error, previewWithdraw rounds up.\n\n    if (msg.sender != owner) {\n      uint allowed = _allowances[owner][msg.sender];\n      // Saves gas for limited approvals.\n      if (allowed != type(uint).max) _allowances[owner][msg.sender] = allowed - shares;\n    }\n\n    beforeWithdraw(assets, shares, receiver);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset.safeTransfer(receiver, assets);\n  }\n\n  /// @dev Redeems shares from owner and sends assets to receiver.\n  function redeem(\n    uint shares,\n    address receiver,\n    address owner\n  ) public nonReentrant virtual override returns (uint assets) {\n    require(shares <= maxRedeem(owner), \"MAX\");\n\n    if (msg.sender != owner) {\n      uint allowed = _allowances[owner][msg.sender];\n      // Saves gas for limited approvals.\n      if (allowed != type(uint).max) _allowances[owner][msg.sender] = allowed - shares;\n    }\n\n    assets = previewRedeem(shares);\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    beforeWithdraw(assets, shares, receiver);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset.safeTransfer(receiver, assets);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //                  ACCOUNTING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n  /// @dev Total amount of the underlying asset that is “managed” by Vault\n  function totalAssets() public view virtual override returns (uint);\n\n  function convertToShares(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n  }\n\n  function convertToAssets(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n  }\n\n  function previewDeposit(uint assets) public view virtual override returns (uint) {\n    return convertToShares(assets);\n  }\n\n  function previewMint(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n  }\n\n  function previewWithdraw(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n  }\n\n  function previewRedeem(uint shares) public view virtual override returns (uint) {\n    return convertToAssets(shares);\n  }\n\n  ///////////////////////////////////////////////////////////////\n  //           DEPOSIT/WITHDRAWAL LIMIT LOGIC\n  ///////////////////////////////////////////////////////////////\n\n  function maxDeposit(address) public view virtual override returns (uint) {\n    return type(uint).max - 1;\n  }\n\n  function maxMint(address) public view virtual override returns (uint) {\n    return type(uint).max - 1;\n  }\n\n  function maxWithdraw(address owner) public view virtual override returns (uint) {\n    return convertToAssets(balanceOf(owner));\n  }\n\n  function maxRedeem(address owner) public view virtual override returns (uint) {\n    return balanceOf(owner);\n  }\n\n  ///////////////////////////////////////////////////////////////\n  //                INTERNAL HOOKS LOGIC\n  ///////////////////////////////////////////////////////////////\n\n  function beforeWithdraw(uint assets, uint shares, address receiver) internal virtual {}\n\n  function afterDeposit(uint assets, uint shares, address receiver) internal virtual {}\n\n  /**\n * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[49] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/StrategySplitterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/EnumerableMap.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Proxy solution for connection a vault with multiple strategies\n///        Version 2 has auto-rebalance logic adopted to strategies with fees.\n/// @author belbix\ncontract StrategySplitterV2 is ControllableV3, ReentrancyGuard, ISplitter {\n  using SafeERC20 for IERC20;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n  // *********************************************\n  //                  CONSTANTS\n  // *********************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant SPLITTER_VERSION = \"2.0.5\";\n  /// @dev APR denominator. Represent 100% APR.\n  uint public constant APR_DENOMINATOR = 100_000;\n  /// @dev Delay between hardwork calls for a strategy.\n  uint public constant HARDWORK_DELAY = 12 hours;\n  /// @dev How much APR history elements will be counted in average APR calculation.\n  uint public constant HISTORY_DEEP = 3;\n  /// @dev Time lock for adding new strategies.\n  uint public constant TIME_LOCK = 18 hours;\n  /// @dev 1% of max loss for strategy TVL\n  uint public constant INVEST_LOSS_TOLERANCE = 1_000;\n  /// @dev 10%  of max loss for strategy TVL\n  uint public constant WITHDRAW_LOSS_TOLERANCE = 10_000;\n  /// @dev 5%  of max loss for strategy TVL\n  uint public constant HARDWORK_LOSS_TOLERANCE = 5_000;\n\n\n  // *********************************************\n  //                 VARIABLES\n  // *********************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Connected vault\n  address public override vault;\n  /// @dev Array of strategies under control\n  address[] public strategies;\n  /// @dev Paused strategies\n  mapping(address => bool) public pausedStrategies;\n  /// @dev Current strategies average APRs. Uses for deposit/withdraw ordering.\n  mapping(address => uint) public strategiesAPR;\n  /// @dev Strategies APR history. Uses for calculate average APR.\n  mapping(address => uint[]) public strategiesAPRHistory;\n  /// @dev Last strategies doHardWork call timestamp. Uses for calls delay.\n  mapping(address => uint) public lastHardWorks;\n  /// @dev Flag represents doHardWork call. Need for not call HW on deposit again in connected vault.\n  bool public override isHardWorking;\n  /// @dev Strategy => timestamp. Strategies scheduled for adding.\n  EnumerableMap.AddressToUintMap internal _scheduledStrategies;\n  /// @dev Changed to true after a strategy adding\n  bool internal inited;\n  /// @dev How much underlying can be invested to the strategy\n  mapping(address => uint) public strategyCapacity;\n\n  // *********************************************\n  //                  EVENTS\n  // *********************************************\n\n  event StrategyAdded(address strategy, uint apr);\n  event StrategyRemoved(address strategy);\n  event Rebalance(\n    address topStrategy,\n    address lowStrategy,\n    uint percent,\n    uint strategyLossOnWithdraw,\n    uint strategyLossOnInvest,\n    uint lowStrategyBalance\n  );\n  event HardWork(\n    address sender,\n    address strategy,\n    uint tvl,\n    uint earned,\n    uint lost,\n    uint apr,\n    uint avgApr\n  );\n  event StrategyScheduled(address strategy, uint startTime, uint timeLock);\n  event ScheduledStrategyRemove(address strategy);\n  event ManualAprChanged(address sender, address strategy, uint newApr, uint oldApr);\n  event Paused(address strategy, address sender);\n  event ContinueInvesting(address strategy, uint apr, address sender);\n  event Loss(address strategy, uint amount);\n  event Invested(address strategy, uint amount);\n  event WithdrawFromStrategy(address strategy);\n  event SetStrategyCapacity(address strategy, uint capacity);\n  event InvestFailed(string error);\n\n  // *********************************************\n  //                 INIT\n  // *********************************************\n\n  /// @dev Initialize contract after setup it as proxy implementation\n  function init(address controller_, address _asset, address _vault) external initializer override {\n    __Controllable_init(controller_);\n    _requireERC20(_asset);\n    asset = _asset;\n    _requireInterface(_vault, InterfaceIds.I_TETU_VAULT_V2);\n    vault = _vault;\n  }\n\n  // *********************************************\n  //                 RESTRICTIONS\n  // *********************************************\n\n  /// @dev Restrict access only for governance\n  function _onlyGov() internal view {\n    require(isGovernance(msg.sender), \"SS: Denied\");\n  }\n\n  /// @dev Restrict access only for operators\n  function _onlyOperators() internal view {\n    require(IController(controller()).isOperator(msg.sender), \"SS: Denied\");\n  }\n\n  /// @dev Restrict access only for vault\n  function _onlyVault() internal view {\n    require(msg.sender == vault, \"SS: Denied\");\n  }\n\n  /// @dev Restrict access only for operators or vault\n  function _onlyOperatorsOrVault() internal view {\n    require(msg.sender == vault || IController(controller()).isOperator(msg.sender), \"SS: Denied\");\n  }\n\n  // *********************************************\n  //                    VIEWS\n  // *********************************************\n\n  /// @dev Amount of underlying assets under control of splitter.\n  function totalAssets() public view override returns (uint256){\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    uint length = strategies.length;\n    for (uint i = 0; i < length; i++) {\n      balance += IStrategyV2(strategies[i]).totalAssets();\n    }\n    return balance;\n  }\n\n  /// @dev Return maximum available balance to withdraw without calling more than 1 strategy\n  function maxCheapWithdraw() external view returns (uint) {\n    address _asset = asset;\n    uint strategyBalance;\n    if (strategies.length != 0) {\n      strategyBalance = IStrategyV2(strategies[0]).totalAssets();\n    }\n    return strategyBalance + IERC20(_asset).balanceOf(address(this));\n  }\n\n  /// @dev Length of strategy array\n  function strategiesLength() external view returns (uint) {\n    return strategies.length;\n  }\n\n  /// @dev Returns strategy array\n  function allStrategies() external view returns (address[] memory) {\n    return strategies;\n  }\n\n  /// @dev Length of APR history for given strategy\n  function strategyAPRHistoryLength(address strategy) external view returns (uint) {\n    return strategiesAPRHistory[strategy].length;\n  }\n\n  /// @dev Return all scheduled strategies with start lock time.\n  function scheduledStrategies() external view returns (address[] memory _strategies, uint[] memory locks) {\n    uint length = _scheduledStrategies.length();\n    _strategies = new address[](length);\n    locks = new uint[](length);\n    for (uint i; i < length; ++i) {\n      (_strategies[i], locks[i]) = _scheduledStrategies.at(i);\n    }\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_SPLITTER || super.supportsInterface(interfaceId);\n  }\n\n  /// @dev There are strategy capacities of two kinds: external (from splitter) and internal (from strategy)\n  ///      We should use minimum value (but: zero external capacity means no capacity)\n  function getStrategyCapacity(address strategy) public view returns (uint capacity) {\n    capacity = strategyCapacity[strategy];\n    if (capacity == 0) {\n      capacity = IStrategyV2(strategy).capacity();\n    } else {\n      capacity = Math.min(capacity, IStrategyV2(strategy).capacity());\n    }\n  }\n\n  // *********************************************\n  //                GOV ACTIONS\n  // *********************************************\n\n  /// @dev Schedule strategy for adding in the splitter.\n  ///      Not inited splitter(without strategies) not require scheduling.\n  function scheduleStrategies(address[] memory _strategies) external {\n    _onlyGov();\n\n    for (uint i; i < _strategies.length; i++) {\n      require(_scheduledStrategies.set(_strategies[i], block.timestamp), \"SS: Exist\");\n      emit StrategyScheduled(_strategies[i], block.timestamp, TIME_LOCK);\n    }\n  }\n\n  /// @dev Remove scheduled strategies.\n  function removeScheduledStrategies(address[] memory _strategies) external {\n    _onlyGov();\n\n    for (uint i; i < _strategies.length; i++) {\n      require(_scheduledStrategies.remove(_strategies[i]), \"SS: Not exist\");\n      emit ScheduledStrategyRemove(_strategies[i]);\n    }\n  }\n\n  /// @dev Add new managed strategy. Should be an uniq address.\n  ///      Strategy should have the same underlying asset with current contract.\n  function addStrategies(address[] memory _strategies, uint[] memory expectedAPR) external {\n    // only initial action will require strict access\n    // already scheduled strategies can be added by anyone\n    require(_strategies.length == expectedAPR.length, \"WRONG_INPUT\");\n\n    bool _inited = inited;\n    address[] memory existStrategies = strategies;\n    address[] memory addedStrategies = new address[](_strategies.length);\n    for (uint i = 0; i < _strategies.length; i++) {\n      address strategy = _strategies[i];\n      uint apr = expectedAPR[i];\n\n      // --- restrictions ----------\n\n      require(IStrategyV2(strategy).asset() == asset, \"SS: Wrong asset\");\n      require(IStrategyV2(strategy).splitter() == address(this), \"SS: Wrong splitter\");\n      require(IControllable(strategy).isController(controller()), \"SS: Wrong controller\");\n      require(!_contains(existStrategies, strategy), \"SS: Already exist\");\n      require(!_contains(addedStrategies, strategy), \"SS: Duplicate\");\n      require(IProxyControlled(strategy).implementation() != address(0), \"SS: Wrong proxy\");\n      // allow add strategies without time lock only for the fist call (assume the splitter is new)\n      if (_inited) {\n        (bool found, uint startTime) = _scheduledStrategies.tryGet(strategy);\n        require(found && startTime != 0 && startTime + TIME_LOCK < block.timestamp, \"SS: Time lock\");\n        _scheduledStrategies.remove(strategy);\n      } else {\n        // only initial action requires strict access\n        _onlyGov();\n      }\n      // ----------------------------\n\n      strategies.push(strategy);\n      _setStrategyAPR(strategy, apr);\n      addedStrategies[i] = strategy;\n      lastHardWorks[strategy] = block.timestamp;\n      emit StrategyAdded(strategy, apr);\n    }\n    _sortStrategiesByAPR();\n    if (!_inited) {\n      inited = true;\n    }\n  }\n\n  /// @dev Remove given strategy, reset APR and withdraw all underlying to this contract\n  function removeStrategies(address[] memory strategies_) external {\n    _onlyGov();\n\n    for (uint i = 0; i < strategies_.length; i++) {\n      _removeStrategy(strategies_[i]);\n    }\n    _sortStrategiesByAPR();\n  }\n\n  function _removeStrategy(address strategy) internal {\n    uint length = strategies.length;\n    require(length > 0, \"SS: Empty strategies\");\n    uint idx;\n    bool found;\n    for (uint256 i = 0; i < length; i++) {\n      if (strategies[i] == strategy) {\n        idx = i;\n        found = true;\n        break;\n      }\n    }\n    require(found, \"SS: Strategy not found\");\n    if (length > 1) {\n      strategies[idx] = strategies[length - 1];\n    }\n    strategies.pop();\n\n    _setStrategyAPR(strategy, 0);\n\n    // for expensive strategies should be called before removing\n    // without loss covering\n    IStrategyV2(strategy).withdrawAllToSplitter();\n    emit StrategyRemoved(strategy);\n  }\n\n  /// @dev Withdraw some percent from strategy with lowest APR and deposit to strategy with highest APR.\n  ///      Strict access because possible losses during deposit/withdraw.\n  /// @param percent Range of 1-100\n  /// @param lossTolerance Range of 0-100_000\n  function rebalance(uint percent, uint lossTolerance) external {\n    _onlyGov();\n\n    uint length = strategies.length;\n    require(length > 1, \"SS: Length\");\n    require(percent <= 100, \"SS: Percent\");\n\n    uint topStrategyWithoutCapacity = type(uint).max;\n\n    for (uint i = 0; i < length; i++) {\n      address strategy = strategies[i];\n      uint capacity = getStrategyCapacity(strategy);\n      if (capacity != 0) {\n        uint strategyBalance = IStrategyV2(strategy).totalAssets();\n        if (strategyBalance < capacity) {\n          topStrategyWithoutCapacity = i;\n          break;\n        }\n      } else {\n        topStrategyWithoutCapacity = i;\n        break;\n      }\n    }\n    require(topStrategyWithoutCapacity != type(uint).max, \"SS: All capped\");\n\n\n    address lowStrategy;\n\n    uint lowStrategyBalance;\n    // loop for all strategies since from top uncapped\n    for (uint i = length; i > topStrategyWithoutCapacity + 1; i--) {\n      lowStrategy = strategies[i - 1];\n      lowStrategyBalance = IStrategyV2(lowStrategy).totalAssets();\n      if (lowStrategyBalance == 0) {\n        continue;\n      }\n      break;\n    }\n\n    // if we are able to withdraw something let's do it\n    uint strategyLossOnWithdraw;\n    if (lowStrategyBalance != 0) {\n      strategyLossOnWithdraw = (percent == 100)\n      ? IStrategyV2(lowStrategy).withdrawAllToSplitter()\n      : IStrategyV2(lowStrategy).withdrawToSplitter(lowStrategyBalance * percent / 100);\n    }\n    // need to emit loss separately\n    if (strategyLossOnWithdraw != 0) {\n      // for withdraw need to use balance before\n      _coverLoss(vault, strategyLossOnWithdraw, lossTolerance, lowStrategyBalance);\n      emit Loss(lowStrategy, strategyLossOnWithdraw);\n    }\n\n    (address topStrategy, uint strategyLossOnInvest, uint strategyBalanceAfterInvest) = _investToTopStrategy(\n      false // we assume here, that total-assets-amount of the strategy was just updated in withdraw above\n    );\n    require(topStrategy != address(0), \"SS: Not invested\");\n    // need to emit loss separately\n    if (strategyLossOnInvest != 0) {\n      // for invest need to use balance after\n      _coverLoss(vault, strategyLossOnInvest, lossTolerance, strategyBalanceAfterInvest);\n      emit Loss(topStrategy, strategyLossOnInvest);\n    }\n\n\n    emit Rebalance(\n      topStrategy,\n      lowStrategy,\n      percent,\n      strategyLossOnWithdraw,\n      strategyLossOnInvest,\n      lowStrategyBalance\n    );\n  }\n\n  // *********************************************\n  //                OPERATOR ACTIONS\n  // *********************************************\n\n  function setAPRs(address[] memory _strategies, uint[] memory aprs) external {\n    _onlyOperators();\n    require(_strategies.length == aprs.length, \"WRONG_INPUT\");\n    for (uint i; i < aprs.length; i++) {\n      address strategy = _strategies[i];\n      require(!pausedStrategies[strategy], \"SS: Paused\");\n      uint oldAPR = strategiesAPR[strategy];\n      _setStrategyAPR(strategy, aprs[i]);\n      emit ManualAprChanged(msg.sender, strategy, aprs[i], oldAPR);\n    }\n    _sortStrategiesByAPR();\n  }\n\n  /// @dev Pause investing. For withdraw need to call emergencyExit() on the strategy.\n  function pauseInvesting(address strategy) external {\n    _onlyOperators();\n    require(!pausedStrategies[strategy], \"SS: Paused\");\n\n    pausedStrategies[strategy] = true;\n    uint oldAPR = strategiesAPR[strategy];\n    _setStrategyAPR(strategy, 0);\n    _sortStrategiesByAPR();\n    emit ManualAprChanged(msg.sender, strategy, 0, oldAPR);\n    emit Paused(strategy, msg.sender);\n  }\n\n  /// @dev Resumes the ability to invest for given strategy.\n  function continueInvesting(address strategy, uint apr) external {\n    _onlyOperators();\n    require(pausedStrategies[strategy], \"SS: Not paused\");\n\n    pausedStrategies[strategy] = false;\n    _setStrategyAPR(strategy, apr);\n    _sortStrategiesByAPR();\n    emit ManualAprChanged(msg.sender, strategy, apr, 0);\n    emit ContinueInvesting(strategy, apr, msg.sender);\n  }\n\n  function setStrategyCapacity(address strategy, uint capacity) external {\n    _onlyOperators();\n    strategyCapacity[strategy] = capacity;\n    emit SetStrategyCapacity(strategy, capacity);\n  }\n\n  // *********************************************\n  //                VAULT ACTIONS\n  // *********************************************\n\n  /// @dev Invest to the first strategy in the array. Assume this strategy has highest APR.\n  function investAll() external override {\n    _onlyVault();\n\n    if (strategies.length != 0) {\n      (address strategy, uint strategyLoss, uint strategyBalanceAfterInvest) = _investToTopStrategy(true);\n      if (strategyLoss > 0) {\n        _coverLoss(msg.sender, strategyLoss, INVEST_LOSS_TOLERANCE, strategyBalanceAfterInvest);\n        emit Loss(strategy, strategyLoss);\n      }\n    }\n  }\n\n  /// @dev Try to withdraw all from all strategies. May be too expensive to handle in one tx.\n  function withdrawAllToVault() external override {\n    _onlyVault();\n\n    address _vault = vault;\n    address _asset = asset;\n    uint length = strategies.length;\n    for (uint i = 0; i < length; i++) {\n      uint strategyBalance = IStrategyV2(strategies[i]).totalAssets();\n      uint strategyLoss = IStrategyV2(strategies[i]).withdrawAllToSplitter();\n      emit WithdrawFromStrategy(strategies[i]);\n\n      // register possible loses\n      if (strategyLoss != 0) {\n        _coverLoss(_vault, strategyLoss, WITHDRAW_LOSS_TOLERANCE, strategyBalance);\n        emit Loss(strategies[i], strategyLoss);\n      }\n    }\n\n    uint balanceAfter = IERC20(_asset).balanceOf(address(this));\n    if (balanceAfter > 0) {\n      IERC20(_asset).safeTransfer(_vault, balanceAfter);\n    }\n  }\n\n  /// @dev Cascade withdraw from strategies start from lower APR until reach the target amount.\n  ///      For large amounts with multiple strategies may not be possible to process this function.\n  function withdrawToVault(uint256 amount) external override {\n    _onlyVault();\n\n    address _asset = asset;\n    address _vault = vault;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (balance < amount) {\n      uint remainingAmount = amount - balance;\n      uint length = strategies.length;\n      for (uint i = length; i > 0; i--) {\n        IStrategyV2 strategy = IStrategyV2(strategies[i - 1]);\n\n        uint strategyBalance = strategy.totalAssets();\n\n        // withdraw from strategy\n        uint strategyLoss = (strategyBalance <= remainingAmount)\n        ? strategy.withdrawAllToSplitter()\n        : strategy.withdrawToSplitter(remainingAmount);\n        emit WithdrawFromStrategy(address(strategy));\n\n        uint currentBalance = IERC20(_asset).balanceOf(address(this));\n        // assume that we can not decrease splitter balance during withdraw process\n        uint withdrew = currentBalance - balance;\n        balance = currentBalance;\n\n        remainingAmount = withdrew < remainingAmount ? remainingAmount - withdrew : 0;\n\n        // if we withdrew less than expected try to cover loss from vault insurance\n        if (strategyLoss != 0) {\n          _coverLoss(_vault, strategyLoss, WITHDRAW_LOSS_TOLERANCE, strategyBalance);\n          emit Loss(address(strategy), strategyLoss);\n        }\n\n        if (balance >= amount) {\n          break;\n        }\n      }\n    }\n\n    if (balance != 0) {\n      IERC20(_asset).safeTransfer(_vault, Math.min(amount, balance));\n    }\n  }\n\n  // *********************************************\n  //                HARD WORKS\n  // *********************************************\n\n  /// @dev Call hard works for all strategies.\n  function doHardWork() external override {\n    _onlyOperatorsOrVault();\n\n    // prevent recursion\n    require(!isHardWorking, \"SS: Already in hard work\");\n    isHardWorking = true;\n    uint length = strategies.length;\n    bool needReorder;\n    for (uint i = 0; i < length; i++) {\n      bool result = _doHardWorkForStrategy(strategies[i], false);\n      if (result) {\n        needReorder = true;\n      }\n    }\n    if (needReorder) {\n      _sortStrategiesByAPR();\n    }\n    isHardWorking = false;\n  }\n\n  /// @dev Call hard work for given strategy.\n  function doHardWorkForStrategy(address strategy, bool push) external {\n    _onlyOperators();\n\n    // prevent recursion\n    require(!isHardWorking, \"SS: Already in hard work\");\n    isHardWorking = true;\n    bool result = _doHardWorkForStrategy(strategy, push);\n    if (result) {\n      _sortStrategiesByAPR();\n    }\n    isHardWorking = false;\n  }\n\n  function _doHardWorkForStrategy(address strategy, bool push) internal returns (bool) {\n    uint lastHardWork = lastHardWorks[strategy];\n\n    if (\n      (\n      lastHardWork + HARDWORK_DELAY < block.timestamp\n      && IStrategyV2(strategy).isReadyToHardWork()\n      && !pausedStrategies[strategy]\n      )\n      || push\n    ) {\n      uint sinceLastHardWork = block.timestamp - lastHardWork;\n      uint tvl = IStrategyV2(strategy).totalAssets();\n      if (tvl != 0) {\n        (uint earned, uint lost) = IStrategyV2(strategy).doHardWork();\n        uint apr;\n        if (earned > lost) {\n          apr = computeApr(tvl, earned - lost, sinceLastHardWork);\n        }\n        uint lostForCovering = lost > earned ? lost - earned : 0;\n        if (lostForCovering > 0) {\n          _coverLoss(vault, lostForCovering, HARDWORK_LOSS_TOLERANCE, tvl);\n        }\n\n        strategiesAPRHistory[strategy].push(apr);\n        uint avgApr = averageApr(strategy);\n        strategiesAPR[strategy] = avgApr;\n        lastHardWorks[strategy] = block.timestamp;\n\n        emit HardWork(\n          msg.sender,\n          strategy,\n          tvl,\n          earned,\n          lost,\n          apr,\n          avgApr\n        );\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function averageApr(address strategy) public view returns (uint) {\n    uint[] storage history = strategiesAPRHistory[strategy];\n    uint aprSum;\n    uint length = history.length;\n    uint count = Math.min(HISTORY_DEEP, length);\n    if (count != 0) {\n      for (uint i; i < count; i++) {\n        aprSum += history[length - i - 1];\n      }\n      return aprSum / count;\n    }\n    return 0;\n  }\n\n  /// @dev https://www.investopedia.com/terms/a/apr.asp\n  ///      TVL and rewards should be in the same currency and with the same decimals\n  function computeApr(uint tvl, uint earned, uint duration) public pure returns (uint) {\n    if (tvl == 0 || duration == 0) {\n      return 0;\n    }\n    return earned * 1e18 * APR_DENOMINATOR * uint(365) / tvl / (duration * 1e18 / 1 days);\n  }\n\n  /// @dev Insertion sorting algorithm for using with arrays fewer than 10 elements.\n  ///      Based on https://medium.com/coinmonks/sorting-in-solidity-without-comparison-4eb47e04ff0d\n  ///      Sort strategies array by APR values from strategiesAPR map. Highest to lowest.\n  function _sortStrategiesByAPR() internal {\n  unchecked {\n    uint length = strategies.length;\n    for (uint i = 1; i < length; i++) {\n      address key = strategies[i];\n      uint j = i - 1;\n      while ((int(j) >= 0) && strategiesAPR[strategies[j]] < strategiesAPR[key]) {\n        strategies[j + 1] = strategies[j];\n        j--;\n      }\n      strategies[j + 1] = key;\n    }\n  }\n  }\n\n  /// @dev Return true if given item found in address array\n  function _contains(address[] memory array, address _item) internal pure returns (bool) {\n    for (uint256 i = 0; i < array.length; i++) {\n      if (array[i] == _item) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _setStrategyAPR(address strategy, uint apr) internal {\n    strategiesAPR[strategy] = apr;\n    // need to override last values of history for properly calculate average apr\n    for (uint i; i < HISTORY_DEEP; i++) {\n      strategiesAPRHistory[strategy].push(apr);\n    }\n  }\n\n  /// @param updateTotalAssetsBeforeInvest TotalAssets of strategy should be updated before investing.\n  /// @return strategy Selected strategy or zero\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _investToTopStrategy(\n    bool updateTotalAssetsBeforeInvest\n  ) internal returns (\n    address strategy,\n    uint strategyLoss,\n    uint strategyBalanceAfterInvest\n  ) {\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    // no actions for zero balance, return empty strategy\n    if (balance != 0) {\n      uint length = strategies.length;\n      for (uint i; i < length; ++i) {\n        strategy = strategies[i];\n        if (pausedStrategies[strategy]) {\n          continue;\n        }\n\n        uint capacity = getStrategyCapacity(strategy);\n\n        uint strategyBalance = IStrategyV2(strategy).totalAssets();\n        uint toInvest;\n        if (capacity > strategyBalance) {\n          toInvest = Math.min(capacity - strategyBalance, balance);\n        } else {\n          continue;\n        }\n\n        if (toInvest != 0) {\n          IERC20(_asset).safeTransfer(strategy, toInvest);\n          strategyLoss = IStrategyV2(strategy).investAll(toInvest, updateTotalAssetsBeforeInvest);\n          strategyBalanceAfterInvest = strategyBalance + toInvest;\n          emit Invested(strategy, toInvest);\n          break;\n        }\n      }\n    }\n\n    return (strategy, strategyLoss, strategyBalanceAfterInvest);\n  }\n\n  function _coverLoss(address _vault, uint amount, uint lossTolerance, uint strategyBalance) internal {\n    if (amount != 0) {\n      ITetuVaultV2(_vault).coverLoss(amount);\n      require(amount * 100_000 / strategyBalance <= lossTolerance, \"SS: Loss too high\");\n    }\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/TetuVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/IGauge.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./ERC4626Upgradeable.sol\";\n\n/// @title Vault for storing underlying tokens and managing them with strategy splitter.\n/// @author belbix\ncontract TetuVaultV2 is ERC4626Upgradeable, ControllableV3, ITetuVaultV2 {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VAULT_VERSION = \"2.1.2\";\n  /// @dev Denominator for buffer calculation. 100% of the buffer amount.\n  uint constant public BUFFER_DENOMINATOR = 100_000;\n  /// @dev Denominator for fee calculation.\n  uint constant public FEE_DENOMINATOR = 100_000;\n  /// @dev Max 1% fee.\n  uint constant public MAX_FEE = FEE_DENOMINATOR / 100;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Strategy splitter. Should be setup after deploy.\n  ISplitter public splitter;\n  /// @dev Connected gauge for stakeless rewards\n  IGauge public gauge;\n  /// @dev Dedicated contract for holding insurance for covering share price loss.\n  IVaultInsurance public override insurance;\n  /// @dev Percent of assets that will always stay in this vault.\n  uint public buffer;\n\n  /// @dev Maximum amount for withdraw. Max UINT256 by default.\n  uint public maxWithdrawAssets;\n  /// @dev Maximum amount for redeem. Max UINT256 by default.\n  uint public maxRedeemShares;\n  /// @dev Maximum amount for deposit. Max UINT256 by default.\n  uint public maxDepositAssets;\n  /// @dev Maximum amount for mint. Max UINT256 by default.\n  uint public maxMintShares;\n  /// @dev Fee for deposit/mint actions. Zero by default.\n  uint public override depositFee;\n  /// @dev Fee for withdraw/redeem actions. Zero by default.\n  uint public override withdrawFee;\n\n  /// @dev Trigger doHardwork on invest action. Enabled by default.\n  bool public doHardWorkOnInvest;\n  /// @dev msg.sender => block when request sent. Should be cleared on deposit/withdraw action\n  ///      For simplification we are setup new withdraw request on each deposit/transfer\n  mapping(address => uint) public withdrawRequests;\n  /// @dev A user should wait this block amounts before able to withdraw.\n  uint public withdrawRequestBlocks;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Init(\n    address controller,\n    address asset,\n    string name,\n    string symbol,\n    address gauge,\n    uint buffer\n  );\n  event SplitterSetup(address splitter);\n  event BufferChanged(uint oldValue, uint newValue);\n  event Invest(address splitter, uint amount);\n  event MaxWithdrawChanged(uint maxAssets, uint maxShares);\n  event MaxDepositChanged(uint maxAssets, uint maxShares);\n  event FeeChanged(uint depositFee, uint withdrawFee);\n  event DoHardWorkOnInvestChanged(bool oldValue, bool newValue);\n  event FeeTransfer(uint amount);\n  event LossCovered(uint amount);\n  event WithdrawRequested(address sender, uint startBlock);\n  event WithdrawRequestBlocks(uint blocks);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(\n    address controller_,\n    IERC20 asset_,\n    string memory _name,\n    string memory _symbol,\n    address _gauge,\n    uint _buffer\n  ) external initializer override {\n    require(_buffer <= BUFFER_DENOMINATOR, \"!BUFFER\");\n    require(_gauge != address(0), \"!GAUGE\");\n    require(IControllable(_gauge).isController(controller_), \"!GAUGE_CONTROLLER\");\n\n    _requireERC20(address(asset_));\n    __ERC4626_init(asset_, _name, _symbol);\n    __Controllable_init(controller_);\n\n    _requireInterface(_gauge, InterfaceIds.I_GAUGE);\n    gauge = IGauge(_gauge);\n    buffer = _buffer;\n\n    // set defaults\n    maxWithdrawAssets = type(uint).max;\n    maxRedeemShares = type(uint).max;\n    maxDepositAssets = type(uint).max - 1;\n    maxMintShares = type(uint).max - 1;\n    doHardWorkOnInvest = true;\n    withdrawRequestBlocks = 5;\n    emit WithdrawRequestBlocks(5);\n\n    emit Init(\n      controller_,\n      address(asset_),\n      _name,\n      _symbol,\n      _gauge,\n      _buffer\n    );\n  }\n\n  function initInsurance(IVaultInsurance _insurance) external override {\n    require(address(insurance) == address(0), \"INITED\");\n    _requireInterface(address(_insurance), InterfaceIds.I_VAULT_INSURANCE);\n\n    require(_insurance.vault() == address(this), \"!VAULT\");\n    require(_insurance.asset() == address(_asset), \"!ASSET\");\n    insurance = _insurance;\n  }\n\n  // *************************************************************\n  //                      GOV ACTIONS\n  // *************************************************************\n\n  /// @dev Set block amount before user will able to withdraw after a request.\n  function setWithdrawRequestBlocks(uint blocks) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n    withdrawRequestBlocks = blocks;\n    emit WithdrawRequestBlocks(blocks);\n  }\n\n  /// @dev Set new buffer value. Should be lower than denominator.\n  function setBuffer(uint _buffer) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n    require(_buffer <= BUFFER_DENOMINATOR, \"BUFFER\");\n\n    emit BufferChanged(buffer, _buffer);\n    buffer = _buffer;\n  }\n\n  /// @dev Set maximum available to deposit amounts.\n  ///      Could be zero values in emergency case when need to pause malicious actions.\n  function setMaxDeposit(uint maxAssets, uint maxShares) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n\n    maxDepositAssets = maxAssets;\n    maxMintShares = maxShares;\n    emit MaxDepositChanged(maxAssets, maxShares);\n  }\n\n  /// @dev Set maximum available to withdraw amounts.\n  ///      Could be zero values in emergency case when need to pause malicious actions.\n  function setMaxWithdraw(uint maxAssets, uint maxShares) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n\n    maxWithdrawAssets = maxAssets;\n    maxRedeemShares = maxShares;\n    emit MaxWithdrawChanged(maxAssets, maxShares);\n  }\n\n  /// @dev Set deposit/withdraw fees\n  function setFees(uint _depositFee, uint _withdrawFee) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n    require(_depositFee <= MAX_FEE && _withdrawFee <= MAX_FEE, \"TOO_HIGH\");\n\n    depositFee = _depositFee;\n    withdrawFee = _withdrawFee;\n    emit FeeChanged(_depositFee, _withdrawFee);\n  }\n\n  /// @dev If activated will call doHardWork on splitter on each invest action.\n  function setDoHardWorkOnInvest(bool value) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n    emit DoHardWorkOnInvestChanged(doHardWorkOnInvest, value);\n    doHardWorkOnInvest = value;\n  }\n\n  /// @dev Set splitter address. Can not change exist splitter.\n  function setSplitter(address _splitter) external override {\n    IERC20 asset_ = _asset;\n    require(address(splitter) == address(0), \"DENIED\");\n    _requireInterface(_splitter, InterfaceIds.I_SPLITTER);\n    require(ISplitter(_splitter).asset() == address(asset_), \"WRONG_UNDERLYING\");\n    require(ISplitter(_splitter).vault() == address(this), \"WRONG_VAULT\");\n    require(IControllable(_splitter).isController(controller()), \"WRONG_CONTROLLER\");\n    asset_.approve(_splitter, type(uint).max);\n    splitter = ISplitter(_splitter);\n    emit SplitterSetup(_splitter);\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of the underlying asset that is “managed” by Vault\n  function totalAssets() public view override returns (uint) {\n    return _asset.balanceOf(address(this)) + splitter.totalAssets();\n  }\n\n  /// @dev Amount of assets under control of strategy splitter.\n  function splitterAssets() external view returns (uint) {\n    return splitter.totalAssets();\n  }\n\n  /// @dev Price of 1 full share\n  function sharePrice() external view returns (uint) {\n    uint units = 10 ** uint256(decimals());\n    uint totalSupply_ = totalSupply();\n    return totalSupply_ == 0\n    ? units\n    : units * totalAssets() / totalSupply_;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_VAULT_V2 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                 DEPOSIT LOGIC\n  // *************************************************************\n\n  function previewDeposit(uint assets) public view virtual override returns (uint) {\n    uint shares = convertToShares(assets);\n    return shares - (shares * depositFee / FEE_DENOMINATOR);\n  }\n\n  function previewMint(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    if (supply != 0) {\n      uint assets = shares.mulDivUp(totalAssets(), supply);\n      return assets * FEE_DENOMINATOR / (FEE_DENOMINATOR - depositFee);\n    } else {\n      return shares * FEE_DENOMINATOR / (FEE_DENOMINATOR - depositFee);\n    }\n  }\n\n  /// @dev Calculate available to invest amount and send this amount to splitter\n  function afterDeposit(uint assets, uint /*shares*/, address receiver) internal override {\n    // reset withdraw request if necessary\n    if (withdrawRequestBlocks != 0) {\n      withdrawRequests[receiver] = block.timestamp;\n    }\n\n    address _splitter = address(splitter);\n    IERC20 asset_ = _asset;\n    uint _depositFee = depositFee;\n    // send fee to insurance contract\n    if (_depositFee != 0) {\n      uint toFees = assets * _depositFee / FEE_DENOMINATOR;\n      asset_.safeTransfer(address(insurance), toFees);\n      emit FeeTransfer(toFees);\n    }\n    uint256 toInvest = _availableToInvest(_splitter, asset_);\n    // invest only when buffer is filled\n    if (toInvest > 0) {\n\n      // need to check recursive hardworks\n      if (doHardWorkOnInvest && !ISplitter(_splitter).isHardWorking()) {\n        ISplitter(_splitter).doHardWork();\n      }\n\n      asset_.safeTransfer(_splitter, toInvest);\n      ISplitter(_splitter).investAll();\n      emit Invest(_splitter, toInvest);\n    }\n  }\n\n  /// @notice Returns amount of assets ready to invest to the splitter\n  function _availableToInvest(address _splitter, IERC20 asset_) internal view returns (uint) {\n    uint _buffer = buffer;\n    if (_splitter == address(0) || _buffer == BUFFER_DENOMINATOR) {\n      return 0;\n    }\n    uint assetsInVault = asset_.balanceOf(address(this));\n    uint assetsInSplitter = ISplitter(_splitter).totalAssets();\n    uint wantInvestTotal = (assetsInVault + assetsInSplitter)\n    * (BUFFER_DENOMINATOR - _buffer) / BUFFER_DENOMINATOR;\n    if (assetsInSplitter >= wantInvestTotal) {\n      return 0;\n    } else {\n      uint remainingToInvest = wantInvestTotal - assetsInSplitter;\n      return remainingToInvest <= assetsInVault ? remainingToInvest : assetsInVault;\n    }\n  }\n\n  // *************************************************************\n  //                 WITHDRAW LOGIC\n  // *************************************************************\n\n  function requestWithdraw() external {\n    withdrawRequests[msg.sender] = block.number;\n    emit WithdrawRequested(msg.sender, block.number);\n  }\n\n  /// @dev Withdraw all available shares for tx sender.\n  ///      The revert is expected if the balance is higher than `maxRedeem`\n  function withdrawAll() external {\n    redeem(balanceOf(msg.sender), msg.sender, msg.sender);\n  }\n\n  function previewWithdraw(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    uint _totalAssets = totalAssets();\n    if (_totalAssets == 0) {\n      return assets;\n    }\n    uint shares = assets.mulDivUp(supply, _totalAssets);\n    shares = shares * FEE_DENOMINATOR / (FEE_DENOMINATOR - withdrawFee);\n    return supply == 0 ? assets : shares;\n  }\n\n  function previewRedeem(uint shares) public view virtual override returns (uint) {\n    shares = shares - (shares * withdrawFee / FEE_DENOMINATOR);\n    return convertToAssets(shares);\n  }\n\n  function maxDeposit(address) public view override returns (uint) {\n    return maxDepositAssets;\n  }\n\n  function maxMint(address) public view override returns (uint) {\n    return maxMintShares;\n  }\n\n  function maxWithdraw(address owner) public view override returns (uint) {\n    uint assets = convertToAssets(balanceOf(owner));\n    assets -= assets.mulDivUp(withdrawFee, FEE_DENOMINATOR);\n    return Math.min(maxWithdrawAssets, assets);\n  }\n\n  function maxRedeem(address owner) public view override returns (uint) {\n    return Math.min(maxRedeemShares, balanceOf(owner));\n  }\n\n  /// @dev Internal hook for getting necessary assets from splitter.\n  function beforeWithdraw(\n    uint assets,\n    uint shares,\n    address receiver\n  ) internal override {\n    // check withdraw request if necessary\n    uint _withdrawRequestBlocks = withdrawRequestBlocks;\n    if (_withdrawRequestBlocks != 0) {\n      uint wr = withdrawRequests[receiver];\n      require(wr != 0 && wr + _withdrawRequestBlocks < block.number, \"NOT_REQUESTED\");\n      withdrawRequests[receiver] = 0;\n    }\n\n    uint _withdrawFee = withdrawFee;\n    uint fromSplitter;\n    if (_withdrawFee != 0) {\n      // add fee amount\n      fromSplitter = assets * FEE_DENOMINATOR / (FEE_DENOMINATOR - _withdrawFee);\n    } else {\n      fromSplitter = assets;\n    }\n\n    IERC20 asset_ = _asset;\n    uint balance = asset_.balanceOf(address(this));\n    // if not enough balance in the vault withdraw from strategies\n    if (balance < fromSplitter) {\n      _processWithdrawFromSplitter(\n        fromSplitter,\n        shares,\n        totalSupply(),\n        buffer,\n        splitter,\n        balance\n      );\n    }\n    balance = asset_.balanceOf(address(this));\n    require(assets <= balance, \"SLIPPAGE\");\n\n    // send fee amount to insurance for keep correct calculations\n    // in case of compensation it will lead to double transfer\n    // but we assume that it will be rare case\n    if (_withdrawFee != 0) {\n      // we should compensate possible slippage from user fee too\n      uint toFees = Math.min(fromSplitter - assets, balance - assets);\n      if (toFees != 0) {\n        asset_.safeTransfer(address(insurance), toFees);\n        emit FeeTransfer(toFees);\n      }\n    }\n  }\n\n  /// @dev Do necessary calculation for withdrawing from splitter and move assets to vault.\n  ///      If splitter not defined must not be called.\n  function _processWithdrawFromSplitter(\n    uint assetsNeed,\n    uint shares,\n    uint totalSupply_,\n    uint _buffer,\n    ISplitter _splitter,\n    uint assetsInVault\n  ) internal {\n    // withdraw everything from the splitter to accurately check the share value\n    if (shares == totalSupply_) {\n      _splitter.withdrawAllToVault();\n    } else {\n      uint assetsInSplitter = _splitter.totalAssets();\n\n      // we should always have buffer amount inside the vault\n      // assume `assetsNeed` can not be higher than entire balance\n      uint expectedBuffer = (assetsInSplitter + assetsInVault - assetsNeed) * _buffer / BUFFER_DENOMINATOR;\n\n      // this code should not be called if `assetsInVault` higher than `assetsNeed`\n      uint missing = Math.min(expectedBuffer + assetsNeed - assetsInVault, assetsInSplitter);\n      // if zero should be resolved on splitter side\n      _splitter.withdrawToVault(missing);\n    }\n  }\n\n  // *************************************************************\n  //                 INSURANCE LOGIC\n  // *************************************************************\n\n  function coverLoss(uint amount) external override {\n    require(msg.sender == address(splitter), \"!SPLITTER\");\n    IVaultInsurance _insurance = insurance;\n    uint balance = _asset.balanceOf(address(_insurance));\n    uint toRecover = Math.min(amount, balance);\n    _insurance.transferToVault(toRecover);\n    emit LossCovered(toRecover);\n  }\n\n  // *************************************************************\n  //                 GAUGE HOOK\n  // *************************************************************\n\n  /// @dev Connect this vault to the gauge for non-contract addresses.\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint\n  ) internal override {\n    // refresh withdraw request if necessary\n    if (withdrawRequestBlocks != 0) {\n      withdrawRequests[from] = block.timestamp;\n      withdrawRequests[to] = block.timestamp;\n    }\n    gauge.handleBalanceChange(from);\n    gauge.handleBalanceChange(to);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../proxy/ProxyControlled.sol\";\nimport \"./VaultInsurance.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Factory for vaults.\n/// @author belbix\ncontract VaultFactory is TetuERC165 {\n\n  // *************************************************************\n  //                        VARIABLES\n  // *************************************************************\n\n  /// @dev Platform controller, need for restrictions.\n  address public immutable controller;\n\n  /// @dev TetuVaultV2 contract address\n  address public vaultImpl;\n  /// @dev VaultInsurance contract address\n  address public vaultInsuranceImpl;\n  /// @dev StrategySplitterV2 contract address\n  address public splitterImpl;\n\n  /// @dev Array of deployed vaults.\n  address[] public deployedVaults;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event VaultDeployed(\n    address sender,\n    address asset,\n    string name,\n    string symbol,\n    address gauge,\n    uint buffer,\n    address vaultProxy,\n    address vaultLogic,\n    address insurance,\n    address splitterProxy,\n    address splitterLogic\n  );\n  event VaultImplChanged(address value);\n  event VaultInsuranceImplChanged(address value);\n  event SplitterImplChanged(address value);\n\n  constructor(\n    address _controller,\n    address _vaultImpl,\n    address _vaultInsuranceImpl,\n    address _splitterImpl\n  ) {\n    _requireInterface(_controller, InterfaceIds.I_CONTROLLER);\n    _requireInterface(_vaultImpl, InterfaceIds.I_TETU_VAULT_V2);\n    _requireInterface(_vaultInsuranceImpl, InterfaceIds.I_VAULT_INSURANCE);\n    _requireInterface(_splitterImpl, InterfaceIds.I_SPLITTER);\n\n    controller = _controller;\n    vaultImpl = _vaultImpl;\n    vaultInsuranceImpl = _vaultInsuranceImpl;\n    splitterImpl = _splitterImpl;\n  }\n\n  function deployedVaultsLength() external view returns (uint) {\n    return deployedVaults.length;\n  }\n\n  // *************************************************************\n  //                        RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Only governance\n  modifier onlyGov() {\n    require(msg.sender == IController(controller).governance(), \"!GOV\");\n    _;\n  }\n\n  /// @dev Only platform operators\n  modifier onlyOperator() {\n    require(IController(controller).isOperator(msg.sender), \"!OPERATOR\");\n    _;\n  }\n\n  // *************************************************************\n  //                        GOV ACTIONS\n  // *************************************************************\n\n  /// @dev Set TetuVaultV2 contract address\n  function setVaultImpl(address value) external onlyGov {\n    _requireInterface(value, InterfaceIds.I_TETU_VAULT_V2);\n    vaultImpl = value;\n    emit VaultImplChanged(value);\n  }\n\n  /// @dev Set VaultInsurance contract address\n  function setVaultInsuranceImpl(address value) external onlyGov {\n    _requireInterface(value, InterfaceIds.I_VAULT_INSURANCE);\n    vaultInsuranceImpl = value;\n    emit VaultInsuranceImplChanged(value);\n  }\n\n  /// @dev Set StrategySplitterV2 contract address\n  function setSplitterImpl(address value) external onlyGov {\n    _requireInterface(value, InterfaceIds.I_SPLITTER);\n    splitterImpl = value;\n    emit SplitterImplChanged(value);\n  }\n\n  // *************************************************************\n  //                    OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev Create and init vault with given attributes.\n  function createVault(\n    IERC20 asset,\n    string memory name,\n    string memory symbol,\n    address gauge,\n    uint buffer\n  ) external onlyOperator {\n    // clone vault implementations\n    address vaultProxy = address(new ProxyControlled());\n    address vaultLogic = vaultImpl;\n    // init proxy\n    IProxyControlled(vaultProxy).initProxy(vaultLogic);\n    // init vault\n    ITetuVaultV2(vaultProxy).init(\n      controller,\n      asset,\n      name,\n      symbol,\n      gauge,\n      buffer\n    );\n    // clone insurance\n    VaultInsurance insurance = new VaultInsurance();\n    // init insurance\n    insurance.init(vaultProxy, address(asset));\n    // set insurance to vault\n    ITetuVaultV2(vaultProxy).initInsurance(insurance);\n\n    // clone splitter\n    address splitterProxy = address(new ProxyControlled());\n    address splitterLogic = splitterImpl;\n    // init proxy\n    IProxyControlled(splitterProxy).initProxy(splitterLogic);\n    // init splitter\n    ISplitter(splitterProxy).init(controller, address(asset), vaultProxy);\n    // set splitter to vault\n    ITetuVaultV2(vaultProxy).setSplitter(splitterProxy);\n\n    deployedVaults.push(vaultProxy);\n\n    emit VaultDeployed(\n      msg.sender,\n      address(asset),\n      name,\n      symbol,\n      gauge,\n      buffer,\n      vaultProxy,\n      vaultLogic,\n      address(insurance),\n      splitterProxy,\n      splitterLogic\n    );\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/VaultInsurance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IVaultInsurance.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Simple dedicated contract for store vault fees\n/// @author belbix\ncontract VaultInsurance is TetuERC165, IVaultInsurance  {\n  using SafeERC20 for IERC20;\n\n  /// @dev Vault address\n  address public override vault;\n  /// @dev Vault underlying asset\n  address public override asset;\n\n  /// @dev Init contract with given attributes.\n  ///      Should be called from factory during creation process.\n  function init(address _vault, address _asset) external override {\n    require(vault == address(0) && asset == address(0), \"INITED\");\n    _requireInterface(_vault, InterfaceIds.I_TETU_VAULT_V2);\n    _requireERC20(_asset);\n\n    vault = _vault;\n    asset = _asset;\n  }\n\n  /// @dev Transfer tokens to vault in case of covering need.\n  function transferToVault(uint amount) external override {\n    require(msg.sender == vault, \"!VAULT\");\n    IERC20(asset).safeTransfer(msg.sender, amount);\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_VAULT_INSURANCE || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/ve/TetuVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../interfaces/IVeTetu.sol\";\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IGauge.sol\";\nimport \"../interfaces/IBribe.sol\";\nimport \"../interfaces/IMultiPool.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Voter for veTETU.\n///        Based on Solidly contract.\n/// @author belbix\ncontract TetuVoter is ReentrancyGuard, ControllableV3, IVoter {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VOTER_VERSION = \"1.0.0\";\n  /// @dev Rewards are released over 7 days\n  uint internal constant _DURATION = 7 days;\n  /// @dev Maximum votes per veNFT\n  uint public constant MAX_VOTES = 10;\n  /// @dev Delay between votes. We need delay for properly bribes distribution between votes.\n  uint public constant VOTE_DELAY = 1 weeks;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev The ve token that governs these contracts\n  address public override ve;\n  address public token;\n  address public gauge;\n  address public bribe;\n\n  // --- VOTES\n\n  /// @dev veID => Last vote timestamp\n  mapping(uint => uint) public lastVote;\n  /// @dev Total voting weight\n  uint public totalWeight;\n  /// @dev vault => weight\n  mapping(address => int256) public weights;\n  /// @dev nft => vault => votes\n  mapping(uint => mapping(address => int256)) public votes;\n  /// @dev nft => vaults addresses voted for\n  mapping(uint => address[]) public vaultsVotes;\n  /// @dev nft => total voting weight of user\n  mapping(uint => uint) public usedWeights;\n\n  // --- ATTACHMENTS\n\n  /// @dev veId => Attached staking token\n  mapping(uint => EnumerableSet.AddressSet) internal _attachedStakingTokens;\n\n  // --- REWARDS\n\n  /// @dev Global index for accumulated distro\n  uint public index;\n  /// @dev vault => Saved global index for accumulated distro\n  mapping(address => uint) public supplyIndex;\n  /// @dev vault => Available to distribute reward amount\n  mapping(address => uint) public claimable;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Voted(address indexed voter, uint tokenId, int256 weight, address vault, int256 userWeight, int256 vePower);\n  event Abstained(uint tokenId, int256 weight, address vault);\n  event NotifyReward(address indexed sender, uint amount);\n  event DistributeReward(address indexed sender, address indexed vault, uint amount);\n  event Attach(address indexed owner, address indexed sender, address indexed stakingToken, uint tokenId);\n  event Detach(address indexed owner, address indexed sender, address indexed stakingToken, uint tokenId);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  function init(\n    address _controller,\n    address _ve,\n    address _rewardToken,\n    address _gauge,\n    address _bribe\n  ) external initializer {\n    __Controllable_init(_controller);\n\n    _requireInterface(_ve, InterfaceIds.I_VE_TETU);\n    _requireERC20(_rewardToken);\n    _requireInterface(_gauge, InterfaceIds.I_GAUGE);\n    _requireInterface(_bribe, InterfaceIds.I_BRIBE);\n\n    ve = _ve;\n    token = _rewardToken;\n    gauge = _gauge;\n    bribe = _bribe;\n\n    // if the gauge will be changed in a new implementation, need to revoke approval and set a new\n    IERC20(_rewardToken).safeApprove(gauge, type(uint).max);\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Returns true for valid vault registered in controller.\n  function isVault(address _vault) public view returns (bool) {\n    return IController(controller()).isValidVault(_vault);\n  }\n\n  /// @dev Returns register in controller vault by id .\n  function validVaults(uint id) public view returns (address) {\n    return IController(controller()).vaults(id);\n  }\n\n  /// @dev Valid vaults registered in controller length.\n  function validVaultsLength() public view returns (uint) {\n    return IController(controller()).vaultsListLength();\n  }\n\n  /// @dev Returns all attached addresses to given veId. Attachments suppose to be gauges.\n  function attachedStakingTokens(uint veId) external view returns (address[] memory) {\n    return _attachedStakingTokens[veId].values();\n  }\n\n  /// @dev Return voted vaults length for given veId.\n  function votedVaultsLength(uint veId) external view returns (uint) {\n    return vaultsVotes[veId].length;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_VOTER || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        VOTES\n  // *************************************************************\n\n  /// @dev Resubmit exist votes for given token.\n  ///      Need to call it for ve that did not renew votes too long.\n  function poke(uint _tokenId) external {\n    address[] memory _vaultVotes = vaultsVotes[_tokenId];\n    uint length = _vaultVotes.length;\n    int256[] memory _weights = new int256[](length);\n\n    for (uint i; i < length; i++) {\n      _weights[i] = votes[_tokenId][_vaultVotes[i]];\n    }\n\n    _vote(_tokenId, _vaultVotes, _weights);\n  }\n\n  /// @dev Remove all votes for given tokenId.\n  ///      Ve token should be able to remove votes on transfer/withdraw\n  function reset(uint tokenId) external {\n    require(IVeTetu(ve).isApprovedOrOwner(msg.sender, tokenId) || msg.sender == ve, \"!owner\");\n    require(lastVote[tokenId] + VOTE_DELAY < block.timestamp, \"delay\");\n    _reset(tokenId);\n  }\n\n  /// @dev Vote for given pools using a vote power of given tokenId. Reset previous votes.\n  function vote(uint tokenId, address[] calldata _vaultVotes, int256[] calldata _weights) external {\n    require(IVeTetu(ve).isApprovedOrOwner(msg.sender, tokenId), \"!owner\");\n    require(lastVote[tokenId] + VOTE_DELAY < block.timestamp, \"delay\");\n    require(_vaultVotes.length == _weights.length, \"!arrays\");\n    _vote(tokenId, _vaultVotes, _weights);\n    lastVote[tokenId] = block.timestamp;\n  }\n\n  function _vote(uint _tokenId, address[] memory _vaultVotes, int256[] memory _weights) internal {\n    _reset(_tokenId);\n    uint length = _vaultVotes.length;\n\n    require(length <= MAX_VOTES, \"Too many votes\");\n\n    int256 _weight = int256(IVeTetu(ve).balanceOfNFT(_tokenId));\n    int256 _totalVoteWeight = 0;\n    int256 _totalWeight = 0;\n    int256 _usedWeight = 0;\n\n    for (uint i = 0; i < length; i++) {\n      _totalVoteWeight += _weights[i] > 0 ? _weights[i] : - _weights[i];\n    }\n\n    for (uint i = 0; i < length; i++) {\n      address _vault = _vaultVotes[i];\n      require(isVault(_vault), \"Invalid vault\");\n\n      int256 _vaultWeight = _weights[i] * _weight / _totalVoteWeight;\n      require(votes[_tokenId][_vault] == 0, \"duplicate vault\");\n      require(_vaultWeight != 0, \"zero power\");\n      _updateFor(_vault);\n\n      vaultsVotes[_tokenId].push(_vault);\n\n      weights[_vault] += _vaultWeight;\n      votes[_tokenId][_vault] += _vaultWeight;\n      if (_vaultWeight > 0) {\n        IBribe(bribe).deposit(_vault, uint(_vaultWeight), _tokenId);\n      } else {\n        _vaultWeight = - _vaultWeight;\n      }\n      _usedWeight += _vaultWeight;\n      _totalWeight += _vaultWeight;\n      emit Voted(msg.sender, _tokenId, _vaultWeight, _vault, _weights[i], _weight);\n    }\n    if (_usedWeight > 0) {\n      IVeTetu(ve).voting(_tokenId);\n    }\n    totalWeight += uint(_totalWeight);\n    usedWeights[_tokenId] = uint(_usedWeight);\n  }\n\n  /// @dev Remove all votes for given veId\n  function _reset(uint _tokenId) internal {\n    address[] storage _vaultsVotes = vaultsVotes[_tokenId];\n    uint length = _vaultsVotes.length;\n    int256 _totalWeight = 0;\n\n    for (uint i = 0; i < length; i ++) {\n      address _vault = _vaultsVotes[i];\n      int256 _votes = votes[_tokenId][_vault];\n      _updateFor(_vault);\n      weights[_vault] -= _votes;\n      votes[_tokenId][_vault] = 0;\n      if (_votes > 0) {\n        IBribe(bribe).withdraw(_vault, uint(_votes), _tokenId);\n        _totalWeight += _votes;\n      } else {\n        _totalWeight -= _votes;\n      }\n      emit Abstained(_tokenId, _votes, _vault);\n    }\n    totalWeight -= uint(_totalWeight);\n    usedWeights[_tokenId] = 0;\n    delete vaultsVotes[_tokenId];\n    if (_totalWeight > 0) {\n      IVeTetu(ve).abstain(_tokenId);\n    }\n  }\n\n  // *************************************************************\n  //                        ATTACH/DETACH\n  // *************************************************************\n\n  /// @dev A gauge should be able to attach a token for preventing transfers/withdraws.\n  function attachTokenToGauge(address stakingToken, uint tokenId, address account) external override {\n    require(gauge == msg.sender, \"!gauge\");\n    IVeTetu(ve).attachToken(tokenId);\n    // no need to check the result - the gauge should send only new values\n    _attachedStakingTokens[tokenId].add(stakingToken);\n    emit Attach(account, msg.sender, stakingToken, tokenId);\n  }\n\n  /// @dev Detach given token.\n  function detachTokenFromGauge(address stakingToken, uint tokenId, address account) external override {\n    require(gauge == msg.sender, \"!gauge\");\n    IVeTetu(ve).detachToken(tokenId);\n    // no need to check the result - the gauge should send only exist values\n    _attachedStakingTokens[tokenId].remove(stakingToken);\n    emit Detach(account, msg.sender, stakingToken, tokenId);\n  }\n\n  /// @dev Detach given token from all gauges and votes\n  ///      It could be pretty expensive call.\n  ///      Need to have restrictions for max attached tokens and votes.\n  function detachTokenFromAll(uint tokenId, address account) external override {\n    require(msg.sender == ve, \"!ve\");\n\n    _reset(tokenId);\n\n    // need to copy addresses to memory, we will change this collection in the loop\n    address[] memory tokens = _attachedStakingTokens[tokenId].values();\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      // no need to check attachments if _attachedStakingTokens properly updated\n      IGauge(gauge).detachVe(tokens[i], account, tokenId);\n    }\n  }\n\n  // *************************************************************\n  //                    UPDATE INDEXES\n  // *************************************************************\n\n  /// @dev Update given vaults.\n  function updateFor(address[] memory _vaults) external {\n    for (uint i = 0; i < _vaults.length; i++) {\n      _updateFor(_vaults[i]);\n    }\n  }\n\n  /// @dev Update vaults by indexes in a range.\n  function updateForRange(uint start, uint end) public {\n    IController c = IController(controller());\n    for (uint i = start; i < end; i++) {\n      _updateFor(c.vaults(i));\n    }\n  }\n\n  /// @dev Update all gauges.\n  function updateAll() external {\n    updateForRange(0, validVaultsLength());\n  }\n\n  function _updateFor(address _vault) internal {\n    int256 _supplied = weights[_vault];\n    if (_supplied > 0) {\n      uint _supplyIndex = supplyIndex[_vault];\n      // get global index for accumulated distro\n      uint _index = index;\n      // update vault current position to global position\n      supplyIndex[_vault] = _index;\n      // see if there is any difference that need to be accrued\n      uint _delta = _index - _supplyIndex;\n      if (_delta > 0) {\n        // add accrued difference for each supplied token\n        uint _share = uint(_supplied) * _delta / 1e18;\n        claimable[_vault] += _share;\n      }\n    } else {\n      // new users are set to the default global state\n      supplyIndex[_vault] = index;\n    }\n  }\n\n  // *************************************************************\n  //                        REWARDS\n  // *************************************************************\n\n  /// @dev Add rewards to this contract. It will be distributed to gauges.\n  function notifyRewardAmount(uint amount) external override {\n    require(amount != 0, \"zero amount\");\n    uint _totalWeight = totalWeight;\n    // without votes rewards can not be added\n    require(_totalWeight != 0, \"!weights\");\n    // transfer the distro in\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    // 1e18 adjustment is removed during claim\n    uint _ratio = amount * 1e18 / _totalWeight;\n    if (_ratio > 0) {\n      index += _ratio;\n    }\n    emit NotifyReward(msg.sender, amount);\n  }\n\n  /// @dev Notify rewards for given vault. Anyone can call\n  function distribute(address _vault) external override {\n    _distribute(_vault);\n  }\n\n  /// @dev Distribute rewards to all valid vaults.\n  function distributeAll() external {\n    uint length = validVaultsLength();\n    IController c = IController(controller());\n    for (uint x; x < length; x++) {\n      _distribute(c.vaults(x));\n    }\n  }\n\n  function distributeFor(uint start, uint finish) external {\n    IController c = IController(controller());\n    for (uint x = start; x < finish; x++) {\n      _distribute(c.vaults(x));\n    }\n  }\n\n  function _distribute(address _vault) internal nonReentrant {\n    _updateFor(_vault);\n    uint _claimable = claimable[_vault];\n    address _token = token;\n    address _gauge = gauge;\n    // rewards should not extend period infinity, only higher amount allowed\n    if (_claimable > IMultiPool(_gauge).left(_vault, _token)\n      && _claimable / _DURATION > 0) {\n      claimable[_vault] = 0;\n      IGauge(_gauge).notifyRewardAmount(_vault, _token, _claimable);\n      emit DistributeReward(msg.sender, _vault, _claimable);\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/ve/VeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IVeTetu.sol\";\nimport \"../interfaces/IVeDistributor.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Contract for distributing rewards to ve holders.\n///        Rewards will be staked to the veNFT without extending lock period.\n///        Based on Solidly contract.\n/// @author belbix\ncontract VeDistributor is ControllableV3, IVeDistributor {\n  using SafeERC20 for IERC20;\n\n  // for contract internal purposes, don't need to store in the interface\n  struct ClaimCalculationResult {\n    uint toDistribute;\n    uint userEpoch;\n    uint weekCursor;\n    uint maxUserEpoch;\n    bool success;\n  }\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VE_DIST_VERSION = \"1.0.0\";\n  uint internal constant WEEK = 7 * 86400;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Voting escrow token address\n  IVeTetu public ve;\n  /// @dev Token for ve rewards\n  address public override rewardToken;\n\n  // --- CHECKPOINT\n\n  /// @dev Cursor for the current epoch\n  uint public activePeriod;\n  /// @dev Tokens per week stored on checkpoint call. Predefined array size = max weeks size\n  uint[1000000000000000] public tokensPerWeek;\n  /// @dev Ve supply checkpoints. Predefined array size = max weeks size\n  uint[1000000000000000] public veSupply;\n  /// @dev Ve supply checkpoint time cursor\n  uint public timeCursor;\n  /// @dev Token balance updated on checkpoint/claim\n  uint public tokenLastBalance;\n  /// @dev Last checkpoint time\n  uint public lastTokenTime;\n\n  // --- CLAIM\n\n  /// @dev Timestamp when this contract was inited\n  uint public startTime;\n  /// @dev veID => week cursor stored on the claim action\n  mapping(uint => uint) public timeCursorOf;\n  /// @dev veID => epoch stored on the claim action\n  mapping(uint => uint) public userEpochOf;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event CheckpointToken(\n    uint time,\n    uint tokens\n  );\n\n  event Claimed(\n    uint tokenId,\n    uint amount,\n    uint claimEpoch,\n    uint maxEpoch\n  );\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(\n    address controller_,\n    address _ve,\n    address _rewardToken\n  ) external initializer {\n    __Controllable_init(controller_);\n    _requireERC20(_rewardToken);\n    _requireInterface(_ve, InterfaceIds.I_VE_TETU);\n\n    uint _t = block.timestamp / WEEK * WEEK;\n    startTime = _t;\n    lastTokenTime = _t;\n    timeCursor = _t;\n\n    rewardToken = _rewardToken;\n    ve = IVeTetu(_ve);\n\n    IERC20(_rewardToken).safeApprove(_ve, type(uint).max);\n  }\n\n  // *************************************************************\n  //                      CHECKPOINT\n  // *************************************************************\n\n  function checkpoint() external override {\n    uint _period = activePeriod;\n    // only trigger if new week\n    if (block.timestamp >= _period + 1 weeks) {\n      // set new period rounded to weeks\n      activePeriod = block.timestamp / 1 weeks * 1 weeks;\n      // checkpoint token balance that was just minted in veDist\n      _checkpointToken();\n      // checkpoint supply\n      _checkpointTotalSupply();\n    }\n  }\n\n  /// @dev Update tokensPerWeek value\n  function _checkpointToken() internal {\n    uint tokenBalance = IERC20(rewardToken).balanceOf(address(this));\n    uint toDistribute = tokenBalance - tokenLastBalance;\n    tokenLastBalance = tokenBalance;\n\n    uint t = lastTokenTime;\n    uint sinceLast = block.timestamp - t;\n    lastTokenTime = block.timestamp;\n    uint thisWeek = t / WEEK * WEEK;\n    uint nextWeek = 0;\n\n    // checkpoint should be called at least once per 20 weeks\n    for (uint i = 0; i < 20; i++) {\n      nextWeek = thisWeek + WEEK;\n      if (block.timestamp < nextWeek) {\n        tokensPerWeek[thisWeek] += adjustToDistribute(toDistribute, block.timestamp, t, sinceLast);\n        break;\n      } else {\n        tokensPerWeek[thisWeek] += adjustToDistribute(toDistribute, nextWeek, t, sinceLast);\n      }\n      t = nextWeek;\n      thisWeek = nextWeek;\n    }\n    emit CheckpointToken(block.timestamp, toDistribute);\n  }\n\n  /// @dev Adjust value based on time since last update\n  function adjustToDistribute(\n    uint toDistribute,\n    uint t0,\n    uint t1,\n    uint sinceLast\n  ) public pure returns (uint) {\n    if (t0 <= t1 || t0 - t1 == 0 || sinceLast == 0) {\n      return toDistribute;\n    }\n    return toDistribute * (t0 - t1) / sinceLast;\n  }\n\n  /// @dev Search in the loop given timestamp through ve points history.\n  ///      Return minimal possible epoch.\n  function findTimestampEpoch(IVeTetu _ve, uint _timestamp) public view returns (uint) {\n    uint _min = 0;\n    uint _max = _ve.epoch();\n    for (uint i = 0; i < 128; i++) {\n      if (_min >= _max) break;\n      uint _mid = (_min + _max + 2) / 2;\n      IVeTetu.Point memory pt = _ve.pointHistory(_mid);\n      if (pt.ts <= _timestamp) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  /// @dev Search in the loop given timestamp through ve user points history.\n  ///      Return minimal possible epoch.\n  function findTimestampUserEpoch(\n    IVeTetu _ve,\n    uint tokenId,\n    uint _timestamp,\n    uint maxUserEpoch\n  ) public view returns (uint) {\n    uint _min = 0;\n    uint _max = maxUserEpoch;\n    for (uint i = 0; i < 128; i++) {\n      if (_min >= _max) break;\n      uint _mid = (_min + _max + 2) / 2;\n      IVeTetu.Point memory pt = _ve.userPointHistory(tokenId, _mid);\n      if (pt.ts <= _timestamp) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  /// @dev Return ve power at given timestamp\n  function veForAt(uint _tokenId, uint _timestamp) external view returns (uint) {\n    IVeTetu _ve = ve;\n    uint maxUserEpoch = _ve.userPointEpoch(_tokenId);\n    uint epoch = findTimestampUserEpoch(_ve, _tokenId, _timestamp, maxUserEpoch);\n    IVeTetu.Point memory pt = _ve.userPointHistory(_tokenId, epoch);\n    return uint(int256(_positiveInt128(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))));\n  }\n\n  /// @dev Call ve checkpoint and write veSupply at the current timeCursor\n  function checkpointTotalSupply() external override {\n    _checkpointTotalSupply();\n  }\n\n  function _checkpointTotalSupply() internal {\n    IVeTetu _ve = ve;\n    uint t = timeCursor;\n    uint roundedTimestamp = block.timestamp / WEEK * WEEK;\n    _ve.checkpoint();\n\n    // assume will be called more frequently than 20 weeks\n    for (uint i = 0; i < 20; i++) {\n      if (t > roundedTimestamp) {\n        break;\n      } else {\n        uint epoch = findTimestampEpoch(_ve, t);\n        IVeTetu.Point memory pt = _ve.pointHistory(epoch);\n        veSupply[t] = adjustVeSupply(t, pt.ts, pt.bias, pt.slope);\n      }\n      t += WEEK;\n    }\n    timeCursor = t;\n  }\n\n  /// @dev Calculate ve supply based on bias and slop for the given timestamp\n  function adjustVeSupply(uint t, uint ptTs, int128 ptBias, int128 ptSlope) public pure returns (uint) {\n    if (t < ptTs) {\n      return 0;\n    }\n    int128 dt = int128(int256(t - ptTs));\n    if (ptBias < ptSlope * dt) {\n      return 0;\n    }\n    return uint(int256(_positiveInt128(ptBias - ptSlope * dt)));\n  }\n\n  // *************************************************************\n  //                      CLAIM\n  // *************************************************************\n\n  /// @dev Return available to claim earned amount\n  function claimable(uint _tokenId) external view returns (uint) {\n    uint _lastTokenTime = lastTokenTime / WEEK * WEEK;\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, ve, _lastTokenTime);\n    return result.toDistribute;\n  }\n\n  /// @dev Claim rewards for given veID\n  function claim(uint _tokenId) external override returns (uint) {\n    IVeTetu _ve = ve;\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n    uint _lastTokenTime = lastTokenTime;\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\n    uint amount = _claim(_tokenId, _ve, _lastTokenTime);\n    if (amount != 0) {\n      _ve.increaseAmount(rewardToken, _tokenId, amount);\n      tokenLastBalance -= amount;\n    }\n    return amount;\n  }\n\n  /// @dev Claim rewards for given veIDs\n  function claimMany(uint[] memory _tokenIds) external returns (bool) {\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n    uint _lastTokenTime = lastTokenTime;\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\n    IVeTetu _votingEscrow = ve;\n    uint total = 0;\n\n    for (uint i = 0; i < _tokenIds.length; i++) {\n      uint _tokenId = _tokenIds[i];\n      if (_tokenId == 0) break;\n      uint amount = _claim(_tokenId, _votingEscrow, _lastTokenTime);\n      if (amount != 0) {\n        _votingEscrow.increaseAmount(rewardToken, _tokenId, amount);\n        total += amount;\n      }\n    }\n    if (total != 0) {\n      tokenLastBalance -= total;\n    }\n\n    return true;\n  }\n\n  function _claim(uint _tokenId, IVeTetu _ve, uint _lastTokenTime) internal returns (uint) {\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, _ve, _lastTokenTime);\n    if (result.success) {\n      userEpochOf[_tokenId] = result.userEpoch;\n      timeCursorOf[_tokenId] = result.weekCursor;\n      emit Claimed(_tokenId, result.toDistribute, result.userEpoch, result.maxUserEpoch);\n    }\n    return result.toDistribute;\n  }\n\n  function _calculateClaim(\n    uint _tokenId,\n    IVeTetu _ve,\n    uint _lastTokenTime\n  ) internal view returns (ClaimCalculationResult memory) {\n    uint userEpoch;\n    uint maxUserEpoch = _ve.userPointEpoch(_tokenId);\n    uint _startTime = startTime;\n\n    if (maxUserEpoch == 0) {\n      return ClaimCalculationResult(0, 0, 0, 0, false);\n    }\n\n    uint weekCursor = timeCursorOf[_tokenId];\n\n    if (weekCursor == 0) {\n      userEpoch = findTimestampUserEpoch(_ve, _tokenId, _startTime, maxUserEpoch);\n    } else {\n      userEpoch = userEpochOf[_tokenId];\n    }\n\n    if (userEpoch == 0) userEpoch = 1;\n\n    IVeTetu.Point memory userPoint = _ve.userPointHistory(_tokenId, userEpoch);\n    if (weekCursor == 0) {\n      weekCursor = (userPoint.ts + WEEK - 1) / WEEK * WEEK;\n    }\n    if (weekCursor >= lastTokenTime) {\n      return ClaimCalculationResult(0, 0, 0, 0, false);\n    }\n    if (weekCursor < _startTime) {\n      weekCursor = _startTime;\n    }\n\n    return calculateToDistribute(\n      _tokenId,\n      weekCursor,\n      _lastTokenTime,\n      userPoint,\n      userEpoch,\n      maxUserEpoch,\n      _ve\n    );\n  }\n\n  function calculateToDistribute(\n    uint _tokenId,\n    uint weekCursor,\n    uint _lastTokenTime,\n    IVeTetu.Point memory userPoint,\n    uint userEpoch,\n    uint maxUserEpoch,\n    IVeTetu _ve\n  ) public view returns (ClaimCalculationResult memory) {\n    IVeTetu.Point memory oldUserPoint;\n    uint toDistribute;\n    for (uint i = 0; i < 50; i++) {\n      if (weekCursor >= _lastTokenTime) {\n        break;\n      }\n      if (weekCursor >= userPoint.ts && userEpoch <= maxUserEpoch) {\n        userEpoch += 1;\n        oldUserPoint = userPoint;\n        if (userEpoch > maxUserEpoch) {\n          userPoint = IVeTetu.Point(0, 0, 0, 0);\n        } else {\n          userPoint = _ve.userPointHistory(_tokenId, userEpoch);\n        }\n      } else {\n        int128 dt = int128(int256(weekCursor - oldUserPoint.ts));\n        uint balanceOf = uint(int256(_positiveInt128(oldUserPoint.bias - dt * oldUserPoint.slope)));\n        if (balanceOf == 0 && userEpoch > maxUserEpoch) {\n          break;\n        }\n        toDistribute += balanceOf * tokensPerWeek[weekCursor] / veSupply[weekCursor];\n        weekCursor += WEEK;\n      }\n    }\n    return ClaimCalculationResult(\n      toDistribute,\n      Math.min(maxUserEpoch, userEpoch - 1),\n      weekCursor,\n      maxUserEpoch,\n      true\n    );\n  }\n\n  function _positiveInt128(int128 value) internal pure returns (int128) {\n    return value < 0 ? int128(0) : value;\n  }\n\n  /// @dev Block timestamp rounded to weeks\n  function timestamp() external view returns (uint) {\n    return block.timestamp / WEEK * WEEK;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_VE_DISTRIBUTOR || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/ve/VeTetu.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"../interfaces/IERC721Metadata.sol\";\nimport \"../interfaces/IVeTetu.sol\";\nimport \"../interfaces/IERC721Receiver.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IPlatformVoter.sol\";\nimport \"../interfaces/ISmartVault.sol\";\nimport \"../lib/FixedPointMathLib.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./VeTetuLogo.sol\";\n\n/// @title Voting escrow NFT for multiple underlying tokens.\n///        Based on Curve/Solidly contract.\n/// @author belbix\ncontract VeTetu is ControllableV3, ReentrancyGuard, IERC721, IERC721Metadata, IVeTetu {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n  using FixedPointMathLib for int128;\n\n  // Only for internal usage\n  struct DepositInfo {\n    address stakingToken;\n    uint tokenId;\n    uint value;\n    uint unlockTime;\n    uint lockedAmount;\n    uint lockedDerivedAmount;\n    uint lockedEnd;\n    DepositType depositType;\n  }\n\n  // Only for internal usage\n  struct CheckpointInfo {\n    uint tokenId;\n    uint oldDerivedAmount;\n    uint newDerivedAmount;\n    uint oldEnd;\n    uint newEnd;\n  }\n\n  enum TimeLockType {\n    UNKNOWN,\n    ADD_TOKEN,\n    WHITELIST_TRANSFER\n  }\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VE_VERSION = \"1.1.1\";\n  uint internal constant WEEK = 1 weeks;\n  uint internal constant MAX_TIME = 16 weeks;\n  int128 internal constant I_MAX_TIME = 16 weeks;\n  uint internal constant MULTIPLIER = 1 ether;\n  uint internal constant WEIGHT_DENOMINATOR = 100e18;\n  uint public constant MAX_ATTACHMENTS = 1;\n  uint public constant GOV_ACTION_TIME_LOCK = 18 hours;\n\n  string constant public override name = \"veTETU\";\n  string constant public override symbol = \"veTETU\";\n\n  /// @dev ERC165 interface ID of ERC165\n  bytes4 internal constant _ERC165_INTERFACE_ID = 0x01ffc9a7;\n  /// @dev ERC165 interface ID of ERC721\n  bytes4 internal constant _ERC721_INTERFACE_ID = 0x80ac58cd;\n  /// @dev ERC165 interface ID of ERC721Metadata\n  bytes4 internal constant _ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n  address internal constant _TETU_USDC_BPT = 0xE2f706EF1f7240b803AAe877C9C762644bb808d8;\n  address internal constant _TETU_USDC_BPT_VAULT = 0x6922201f0d25Aba8368e7806642625879B35aB84;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Underlying tokens info\n  address[] public override tokens;\n  /// @dev token => weight\n  mapping(address => uint) public tokenWeights;\n  /// @dev token => is allowed for deposits\n  mapping(address => bool) public isValidToken;\n  /// @dev Current count of token\n  uint public tokenId;\n  /// @dev veId => stakingToken => Locked amount\n  mapping(uint => mapping(address => uint)) public override lockedAmounts;\n  /// @dev veId => Amount based on weights aka power\n  mapping(uint => uint) public override lockedDerivedAmount;\n  /// @dev veId => Lock end timestamp\n  mapping(uint => uint) public override lockedEnd;\n\n  // --- CHECKPOINTS LOGIC\n\n  /// @dev Epoch counter. Update each week.\n  uint public override epoch;\n  /// @dev epoch -> unsigned point\n  mapping(uint => Point) internal _pointHistory;\n  /// @dev user -> Point[userEpoch]\n  mapping(uint => Point[1000000000]) internal _userPointHistory;\n  /// @dev veId -> Personal epoch counter\n  mapping(uint => uint) public override userPointEpoch;\n  /// @dev time -> signed slope change\n  mapping(uint => int128) public slopeChanges;\n\n  // --- LOCK\n\n  /// @dev veId -> Attachments counter. With positive counter user unable to transfer NFT\n  mapping(uint => uint) public override attachments;\n  /// @dev veId -> votes counter. With votes NFT unable to transfer\n  mapping(uint => uint) public override voted;\n\n  // --- STATISTICS\n\n  /// @dev veId -> Block number when last time NFT owner changed\n  mapping(uint => uint) public ownershipChange;\n  /// @dev Mapping from NFT ID to the address that owns it.\n  mapping(uint => address) internal _idToOwner;\n  /// @dev Mapping from NFT ID to approved address.\n  mapping(uint => address) internal _idToApprovals;\n  /// @dev Mapping from owner address to count of his tokens.\n  mapping(address => uint) internal _ownerToNFTokenCount;\n  /// @dev Mapping from owner address to mapping of index to tokenIds\n  mapping(address => mapping(uint => uint)) internal _ownerToNFTokenIdList;\n  /// @dev Mapping from NFT ID to index of owner\n  mapping(uint => uint) public tokenToOwnerIndex;\n  /// @dev Mapping from owner address to mapping of operator addresses.\n  mapping(address => mapping(address => bool)) public ownerToOperators;\n\n  /// @dev Mapping of interface id to bool about whether or not it's supported\n  mapping(bytes4 => bool) internal _supportedInterfaces;\n\n  // --- PERMISSIONS\n\n  /// @dev Whitelisted contracts will be able to transfer NFTs\n  mapping(address => bool) public isWhitelistedTransfer;\n  /// @dev Time-locks for governance actions. Zero means not announced and should not processed.\n  mapping(TimeLockType => uint) public govActionTimeLock;\n  /// @dev underlying token => true if we can stake token to some place, false if paused\n  mapping(address => bool) internal tokenFarmingStatus;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Deposit(\n    address indexed stakingToken,\n    address indexed provider,\n    uint tokenId,\n    uint value,\n    uint indexed locktime,\n    DepositType depositType,\n    uint ts\n  );\n  event Withdraw(address indexed stakingToken, address indexed provider, uint tokenId, uint value, uint ts);\n  event Merged(address indexed stakingToken, address indexed provider, uint from, uint to);\n  event Split(uint parentTokenId, uint newTokenId, uint percent);\n  event TransferWhitelisted(address value);\n  event StakingTokenAdded(address value, uint weight);\n  event GovActionAnnounced(uint _type, uint timeToExecute);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  /// @param token_ Underlying ERC20 token\n  /// @param controller_ Central contract of the protocol\n  function init(address token_, uint weight, address controller_) external initializer {\n    __Controllable_init(controller_);\n\n    // the first token should have 18 decimals\n    require(IERC20Metadata(token_).decimals() == uint8(18));\n    _addToken(token_, weight);\n\n    _pointHistory[0].blk = block.number;\n    _pointHistory[0].ts = block.timestamp;\n\n    _supportedInterfaces[_ERC165_INTERFACE_ID] = true;\n    _supportedInterfaces[_ERC721_INTERFACE_ID] = true;\n    _supportedInterfaces[_ERC721_METADATA_INTERFACE_ID] = true;\n\n    // mint-ish\n    emit Transfer(address(0), address(this), 0);\n    // burn-ish\n    emit Transfer(address(this), address(0), 0);\n  }\n\n  // *************************************************************\n  //                        GOVERNANCE ACTIONS\n  // *************************************************************\n\n  function announceAction(TimeLockType _type) external {\n    require(isGovernance(msg.sender), \"FORBIDDEN\");\n    require(govActionTimeLock[_type] == 0 && _type != TimeLockType.UNKNOWN, \"WRONG_INPUT\");\n\n    govActionTimeLock[_type] = block.timestamp + GOV_ACTION_TIME_LOCK;\n    emit GovActionAnnounced(uint(_type), block.timestamp + GOV_ACTION_TIME_LOCK);\n  }\n\n  /// @dev Whitelist address for transfers. Removing from whitelist should be forbidden.\n  function whitelistTransferFor(address value) external {\n    require(isGovernance(msg.sender), \"FORBIDDEN\");\n    require(value != address(0), \"WRONG_INPUT\");\n    uint timeLock = govActionTimeLock[TimeLockType.WHITELIST_TRANSFER];\n    require(timeLock != 0 && timeLock < block.timestamp, \"TIME_LOCK\");\n\n    isWhitelistedTransfer[value] = true;\n    govActionTimeLock[TimeLockType.WHITELIST_TRANSFER] = 0;\n\n    emit TransferWhitelisted(value);\n  }\n\n  function addToken(address token, uint weight) external {\n    require(isGovernance(msg.sender), \"FORBIDDEN\");\n    uint timeLock = govActionTimeLock[TimeLockType.ADD_TOKEN];\n    require(timeLock != 0 && timeLock < block.timestamp, \"TIME_LOCK\");\n\n    _addToken(token, weight);\n    govActionTimeLock[TimeLockType.ADD_TOKEN] = 0;\n  }\n\n  function _addToken(address token, uint weight) internal {\n    require(token != address(0) && weight != 0, \"WRONG_INPUT\");\n    _requireERC20(token);\n\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      require(token != tokens[i], \"WRONG_INPUT\");\n    }\n\n    tokens.push(token);\n    tokenWeights[token] = weight;\n    isValidToken[token] = true;\n\n    emit StakingTokenAdded(token, weight);\n  }\n\n  function changeTokenFarmingAllowanceStatus(address _token, bool status) external {\n    require(isGovernance(msg.sender), \"FORBIDDEN\");\n    require(tokenFarmingStatus[_token] != status);\n    tokenFarmingStatus[_token] = status;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Return length of staking tokens.\n  function tokensLength() external view returns (uint) {\n    return tokens.length;\n  }\n\n  /// @dev Current block timestamp\n  function blockTimestamp() external view returns (uint) {\n    return block.timestamp;\n  }\n\n  /// @dev Voter should handle attach/detach and vote actions\n  function voter() public view returns (address) {\n    return IController(controller()).voter();\n  }\n\n  /// @dev Specific voter for control platform attributes.\n  function platformVoter() public view returns (address) {\n    return IController(controller()).platformVoter();\n  }\n\n  /// @dev Interface identification is specified in ERC-165.\n  /// @param _interfaceID Id of the interface\n  function supportsInterface(bytes4 _interfaceID) public view override(ControllableV3, IERC165) returns (bool) {\n    return _supportedInterfaces[_interfaceID]\n    || _interfaceID == InterfaceIds.I_VE_TETU\n    || super.supportsInterface(_interfaceID);\n  }\n\n  /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n  /// @param _tokenId token of the NFT\n  /// @return Value of the slope\n  function getLastUserSlope(uint _tokenId) external view returns (int128) {\n    uint uEpoch = userPointEpoch[_tokenId];\n    return _userPointHistory[_tokenId][uEpoch].slope;\n  }\n\n  /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n  /// @param _tokenId token of the NFT\n  /// @param _idx User epoch number\n  /// @return Epoch time of the checkpoint\n  function userPointHistoryTs(uint _tokenId, uint _idx) external view returns (uint) {\n    return _userPointHistory[_tokenId][_idx].ts;\n  }\n\n  /// @dev Returns the number of NFTs owned by `_owner`.\n  ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n  /// @param _owner Address for whom to query the balance.\n  function _balance(address _owner) internal view returns (uint) {\n    return _ownerToNFTokenCount[_owner];\n  }\n\n  /// @dev Returns the number of NFTs owned by `_owner`.\n  ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n  /// @param _owner Address for whom to query the balance.\n  function balanceOf(address _owner) external view override returns (uint) {\n    return _balance(_owner);\n  }\n\n  /// @dev Returns the address of the owner of the NFT.\n  /// @param _tokenId The identifier for an NFT.\n  function ownerOf(uint _tokenId) public view override returns (address) {\n    return _idToOwner[_tokenId];\n  }\n\n  /// @dev Get the approved address for a single NFT.\n  /// @param _tokenId ID of the NFT to query the approval of.\n  function getApproved(uint _tokenId) external view override returns (address) {\n    return _idToApprovals[_tokenId];\n  }\n\n  /// @dev Checks if `_operator` is an approved operator for `_owner`.\n  /// @param _owner The address that owns the NFTs.\n  /// @param _operator The address that acts on behalf of the owner.\n  function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {\n    return (ownerToOperators[_owner])[_operator];\n  }\n\n  /// @dev  Get token by index\n  function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint) {\n    return _ownerToNFTokenIdList[_owner][_tokenIndex];\n  }\n\n  /// @dev Returns whether the given spender can transfer a given token ID\n  /// @param _spender address of the spender to query\n  /// @param _tokenId uint ID of the token to be transferred\n  /// @return bool whether the msg.sender is approved for the given token ID,\n  ///              is an operator of the owner, or is the owner of the token\n  function isApprovedOrOwner(address _spender, uint _tokenId) public view override returns (bool) {\n    address owner = _idToOwner[_tokenId];\n    bool spenderIsOwner = owner == _spender;\n    bool spenderIsApproved = _spender == _idToApprovals[_tokenId];\n    bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n    return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n  }\n\n  function balanceOfNFT(uint _tokenId) public view override returns (uint) {\n    // flash NFT protection\n    if (ownershipChange[_tokenId] == block.number) {\n      return 0;\n    }\n    return _balanceOfNFT(_tokenId, block.timestamp);\n  }\n\n  function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\n    return _balanceOfNFT(_tokenId, _t);\n  }\n\n  function totalSupply() external view returns (uint) {\n    return totalSupplyAtT(block.timestamp);\n  }\n\n  function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\n    return _balanceOfAtNFT(_tokenId, _block);\n  }\n\n  function userPointHistory(uint _tokenId, uint _loc) external view override returns (Point memory) {\n    return _userPointHistory[_tokenId][_loc];\n  }\n\n  function pointHistory(uint _loc) external view override returns (Point memory) {\n    return _pointHistory[_loc];\n  }\n\n  // *************************************************************\n  //                        VOTER ACTIONS\n  // *************************************************************\n\n  function _onlyVoters() internal view {\n    require(msg.sender == voter() || msg.sender == platformVoter(), \"NOT_VOTER\");\n  }\n\n  /// @dev Increment the votes counter.\n  ///      Should be called only once per any amount of votes from 1 voter contract.\n  function voting(uint _tokenId) external override {\n    _onlyVoters();\n\n    // counter reflects only amount of voter contracts\n    // restrictions for votes should be implemented on voter side\n    voted[_tokenId]++;\n  }\n\n  /// @dev Decrement the votes counter. Call only once per voter.\n  function abstain(uint _tokenId) external override {\n    _onlyVoters();\n\n    voted[_tokenId]--;\n  }\n\n  /// @dev Increment attach counter. Call it for each boosted gauge position.\n  function attachToken(uint _tokenId) external override {\n    // only central voter\n    require(msg.sender == voter(), \"NOT_VOTER\");\n\n    uint count = attachments[_tokenId];\n    require(count < MAX_ATTACHMENTS, \"TOO_MANY_ATTACHMENTS\");\n    attachments[_tokenId] = count + 1;\n  }\n\n  /// @dev Decrement attach counter. Call it for each boosted gauge position.\n  function detachToken(uint _tokenId) external override {\n    // only central voter\n    require(msg.sender == voter(), \"NOT_VOTER\");\n\n    attachments[_tokenId] = attachments[_tokenId] - 1;\n  }\n\n  /// @dev Remove all votes/attachments for given veID.\n  function _detachAll(uint _tokenId, address owner) internal {\n    IVoter(voter()).detachTokenFromAll(_tokenId, owner);\n    IPlatformVoter(platformVoter()).detachTokenFromAll(_tokenId, owner);\n  }\n\n  // *************************************************************\n  //                        NFT LOGIC\n  // *************************************************************\n\n  /// @dev Add a NFT to an index mapping to a given address\n  /// @param _to address of the receiver\n  /// @param _tokenId uint ID Of the token to be added\n  function _addTokenToOwnerList(address _to, uint _tokenId) internal {\n    uint currentCount = _balance(_to);\n\n    _ownerToNFTokenIdList[_to][currentCount] = _tokenId;\n    tokenToOwnerIndex[_tokenId] = currentCount;\n  }\n\n  /// @dev Remove a NFT from an index mapping to a given address\n  /// @param _from address of the sender\n  /// @param _tokenId uint ID Of the token to be removed\n  function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\n    // Delete\n    uint currentCount = _balance(_from) - 1;\n    uint currentIndex = tokenToOwnerIndex[_tokenId];\n\n    if (currentCount == currentIndex) {\n      // update ownerToNFTokenIdList\n      _ownerToNFTokenIdList[_from][currentCount] = 0;\n      // update tokenToOwnerIndex\n      tokenToOwnerIndex[_tokenId] = 0;\n    } else {\n      uint lastTokenId = _ownerToNFTokenIdList[_from][currentCount];\n\n      // Add\n      // update ownerToNFTokenIdList\n      _ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\n      // update tokenToOwnerIndex\n      tokenToOwnerIndex[lastTokenId] = currentIndex;\n\n      // Delete\n      // update ownerToNFTokenIdList\n      _ownerToNFTokenIdList[_from][currentCount] = 0;\n      // update tokenToOwnerIndex\n      tokenToOwnerIndex[_tokenId] = 0;\n    }\n  }\n\n  /// @dev Add a NFT to a given address\n  function _addTokenTo(address _to, uint _tokenId) internal {\n    // assume always call on new tokenId or after _removeTokenFrom() call\n    // Change the owner\n    _idToOwner[_tokenId] = _to;\n    // Update owner token index tracking\n    _addTokenToOwnerList(_to, _tokenId);\n    // Change count tracking\n    _ownerToNFTokenCount[_to] += 1;\n  }\n\n  /// @dev Remove a NFT from a given address\n  ///      Throws if `_from` is not the current owner.\n  function _removeTokenFrom(address _from, uint _tokenId) internal {\n    require(_idToOwner[_tokenId] == _from, \"NOT_OWNER\");\n    // Change the owner\n    _idToOwner[_tokenId] = address(0);\n    // Update owner token index tracking\n    _removeTokenFromOwnerList(_from, _tokenId);\n    // Change count tracking\n    _ownerToNFTokenCount[_from] -= 1;\n  }\n\n  /// @dev Execute transfer of a NFT.\n  ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n  ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n  ///      Throws if `_to` is the zero address.\n  ///      Throws if `_from` is not the current owner.\n  ///      Throws if `_tokenId` is not a valid NFT.\n  function _transferFrom(\n    address _from,\n    address _to,\n    uint _tokenId,\n    address _sender\n  ) internal {\n    require(isApprovedOrOwner(_sender, _tokenId), \"NOT_OWNER\");\n    require(_to != address(0), \"WRONG_INPUT\");\n    // from address will be checked in _removeTokenFrom()\n\n    if (attachments[_tokenId] != 0 || voted[_tokenId] != 0) {\n      _detachAll(_tokenId, _from);\n    }\n\n    if (_idToApprovals[_tokenId] != address(0)) {\n      // Reset approvals\n      _idToApprovals[_tokenId] = address(0);\n    }\n    _removeTokenFrom(_from, _tokenId);\n    _addTokenTo(_to, _tokenId);\n    // Set the block of ownership transfer (for Flash NFT protection)\n    ownershipChange[_tokenId] = block.number;\n    // Log the transfer\n    emit Transfer(_from, _to, _tokenId);\n  }\n\n  /// @dev Transfers forbidden for veTETU\n  function transferFrom(\n    address,\n    address,\n    uint\n  ) external pure override {\n    revert(\"FORBIDDEN\");\n    //    _transferFrom(_from, _to, _tokenId, msg.sender);\n  }\n\n  function _isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n    uint size;\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  /// @dev Transfers the ownership of an NFT from one address to another address.\n  ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n  ///      approved address for this NFT.\n  ///      Throws if `_from` is not the current owner.\n  ///      Throws if `_to` is the zero address.\n  ///      Throws if `_tokenId` is not a valid NFT.\n  ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n  ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n  /// @param _from The current owner of the NFT.\n  /// @param _to The new owner.\n  /// @param _tokenId The NFT to transfer.\n  /// @param _data Additional data with no specified format, sent in call to `_to`.\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId,\n    bytes memory _data\n  ) public override {\n    require(isWhitelistedTransfer[_to] || isWhitelistedTransfer[_from], \"FORBIDDEN\");\n\n    _transferFrom(_from, _to, _tokenId, msg.sender);\n    require(_checkOnERC721Received(_from, _to, _tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n  }\n\n\n  /// @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n  /// The call is not executed if the target address is not a contract.\n  ///\n  /// @param _from address representing the previous owner of the given token ID\n  /// @param _to target address that will receive the tokens\n  /// @param _tokenId uint256 ID of the token to be transferred\n  /// @param _data bytes optional data to send along with the call\n  /// @return bool whether the call correctly returned the expected magic value\n  ///\n  function _checkOnERC721Received(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  ) private returns (bool) {\n    if (_isContract(_to)) {\n      try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4 retval) {\n        return retval == IERC721Receiver.onERC721Received.selector;\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n        } else {\n          /// @solidity memory-safe-assembly\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n\n  /// @dev Transfers the ownership of an NFT from one address to another address.\n  ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n  ///      approved address for this NFT.\n  ///      Throws if `_from` is not the current owner.\n  ///      Throws if `_to` is the zero address.\n  ///      Throws if `_tokenId` is not a valid NFT.\n  ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n  ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n  /// @param _from The current owner of the NFT.\n  /// @param _to The new owner.\n  /// @param _tokenId The NFT to transfer.\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId\n  ) external override {\n    safeTransferFrom(_from, _to, _tokenId, \"\");\n  }\n\n  /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n  ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n  ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n  ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n  /// @param _approved Address to be approved for the given NFT ID.\n  /// @param _tokenId ID of the token to be approved.\n  function approve(address _approved, uint _tokenId) public override {\n    address owner = _idToOwner[_tokenId];\n    // Throws if `_tokenId` is not a valid NFT\n    require(owner != address(0), \"WRONG_INPUT\");\n    // Throws if `_approved` is the current owner\n    require(_approved != owner, \"IDENTICAL_ADDRESS\");\n    // Check requirements\n    bool senderIsOwner = (owner == msg.sender);\n    bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n    require(senderIsOwner || senderIsApprovedForAll, \"NOT_OWNER\");\n    // Set the approval\n    _idToApprovals[_tokenId] = _approved;\n    emit Approval(owner, _approved, _tokenId);\n  }\n\n  /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n  ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n  ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n  /// @notice This works even if sender doesn't own any tokens at the time.\n  /// @param _operator Address to add to the set of authorized operators.\n  /// @param _approved True if the operators is approved, false to revoke approval.\n  function setApprovalForAll(address _operator, bool _approved) external override {\n    // Throws if `_operator` is the `msg.sender`\n    require(_operator != msg.sender, \"IDENTICAL_ADDRESS\");\n    ownerToOperators[msg.sender][_operator] = _approved;\n    emit ApprovalForAll(msg.sender, _operator, _approved);\n  }\n\n  /// @dev Function to mint tokens\n  ///      Throws if `_to` is zero address.\n  ///      Throws if `_tokenId` is owned by someone.\n  /// @param _to The address that will receive the minted tokens.\n  /// @param _tokenId The token id to mint.\n  /// @return A boolean that indicates if the operation was successful.\n  function _mint(address _to, uint _tokenId) internal returns (bool) {\n    // Throws if `_to` is zero address\n    require(_to != address(0), \"WRONG_INPUT\");\n    _addTokenTo(_to, _tokenId);\n    require(_checkOnERC721Received(address(0), _to, _tokenId, ''), \"ERC721: transfer to non ERC721Receiver implementer\");\n    emit Transfer(address(0), _to, _tokenId);\n    return true;\n  }\n\n  /// @notice Record global and per-user data to checkpoint\n  function _checkpoint(CheckpointInfo memory info) internal {\n    Point memory uOld;\n    Point memory uNew;\n    int128 oldDSlope = 0;\n    int128 newDSlope = 0;\n    uint _epoch = epoch;\n\n    if (info.tokenId != 0) {\n      // Calculate slopes and biases\n      // Kept at zero when they have to\n      if (info.oldEnd > block.timestamp && info.oldDerivedAmount > 0) {\n        uOld.slope = int128(uint128(info.oldDerivedAmount)) / I_MAX_TIME;\n        uOld.bias = uOld.slope * int128(int256(info.oldEnd - block.timestamp));\n      }\n      if (info.newEnd > block.timestamp && info.newDerivedAmount > 0) {\n        uNew.slope = int128(uint128(info.newDerivedAmount)) / I_MAX_TIME;\n        uNew.bias = uNew.slope * int128(int256(info.newEnd - block.timestamp));\n      }\n\n      // Read values of scheduled changes in the slope\n      // oldLocked.end can be in the past and in the future\n      // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n      oldDSlope = slopeChanges[info.oldEnd];\n      if (info.newEnd != 0) {\n        if (info.newEnd == info.oldEnd) {\n          newDSlope = oldDSlope;\n        } else {\n          newDSlope = slopeChanges[info.newEnd];\n        }\n      }\n    }\n\n    Point memory lastPoint = Point({bias : 0, slope : 0, ts : block.timestamp, blk : block.number});\n    if (_epoch > 0) {\n      lastPoint = _pointHistory[_epoch];\n    }\n    uint lastCheckpoint = lastPoint.ts;\n    // initialLastPoint is used for extrapolation to calculate block number\n    // (approximately, for *At methods) and save them\n    // as we cannot figure that out exactly from inside the contract\n    Point memory initialLastPoint = lastPoint;\n    uint blockSlope = 0;\n    // dblock/dt\n    if (block.timestamp > lastPoint.ts) {\n      blockSlope = (MULTIPLIER * (block.number - lastPoint.blk)) / (block.timestamp - lastPoint.ts);\n    }\n    // If last point is already recorded in this block, slope=0\n    // But that's ok b/c we know the block in such case\n\n    // Go over weeks to fill history and calculate what the current point is\n    {\n      uint ti = (lastCheckpoint / WEEK) * WEEK;\n      // Hopefully it won't happen that this won't get used in 5 years!\n      // If it does, users will be able to withdraw but vote weight will be broken\n      for (uint i = 0; i < 255; ++i) {\n        ti += WEEK;\n        int128 dSlope = 0;\n        if (ti > block.timestamp) {\n          ti = block.timestamp;\n        } else {\n          dSlope = slopeChanges[ti];\n        }\n        lastPoint.bias = (lastPoint.bias - lastPoint.slope * int128(int256(ti - lastCheckpoint))).positiveInt128();\n        lastPoint.slope = (lastPoint.slope + dSlope).positiveInt128();\n        lastCheckpoint = ti;\n        lastPoint.ts = ti;\n        lastPoint.blk = initialLastPoint.blk + (blockSlope * (ti - initialLastPoint.ts)) / MULTIPLIER;\n        _epoch += 1;\n        if (ti == block.timestamp) {\n          lastPoint.blk = block.number;\n          break;\n        } else {\n          _pointHistory[_epoch] = lastPoint;\n        }\n      }\n    }\n\n    epoch = _epoch;\n    // Now pointHistory is filled until t=now\n\n    if (info.tokenId != 0) {\n      // If last point was in this block, the slope change has been applied already\n      // But in such case we have 0 slope(s)\n      lastPoint.slope = (lastPoint.slope + (uNew.slope - uOld.slope)).positiveInt128();\n      lastPoint.bias = (lastPoint.bias + (uNew.bias - uOld.bias)).positiveInt128();\n    }\n\n    // Record the changed point into history\n    _pointHistory[_epoch] = lastPoint;\n\n    if (info.tokenId != 0) {\n      // Schedule the slope changes (slope is going down)\n      // We subtract newUserSlope from [newLocked.end]\n      // and add old_user_slope to [old_locked.end]\n      if (info.oldEnd > block.timestamp) {\n        // old_dslope was <something> - u_old.slope, so we cancel that\n        oldDSlope += uOld.slope;\n        if (info.newEnd == info.oldEnd) {\n          oldDSlope -= uNew.slope;\n          // It was a new deposit, not extension\n        }\n        slopeChanges[info.oldEnd] = oldDSlope;\n      }\n\n      if (info.newEnd > block.timestamp) {\n        if (info.newEnd > info.oldEnd) {\n          newDSlope -= uNew.slope;\n          // old slope disappeared at this point\n          slopeChanges[info.newEnd] = newDSlope;\n        }\n        // else: we recorded it already in oldDSlope\n      }\n      // Now handle user history\n      uint userEpoch = userPointEpoch[info.tokenId] + 1;\n\n      userPointEpoch[info.tokenId] = userEpoch;\n      uNew.ts = block.timestamp;\n      uNew.blk = block.number;\n      _userPointHistory[info.tokenId][userEpoch] = uNew;\n    }\n  }\n\n  // *************************************************************\n  //                  DEPOSIT/WITHDRAW LOGIC\n  // *************************************************************\n\n  /// @dev Pull tokens to this contract and try to stake\n  function _pullStakingToken(address _token, address _from, uint amount) internal {\n    IERC20(_token).safeTransferFrom(_from, address(this), amount);\n\n    // try to stake tokens if possible\n    _stakeAvailableTokens(_token);\n  }\n\n  /// @dev Anyone can stake whitelisted tokens if they exist on this contract.\n  function stakeAvailableTokens(address _token) external {\n    _stakeAvailableTokens(_token);\n  }\n\n  /// @dev If allowed, stake given token available balance to suitable place for earn some profit\n  function _stakeAvailableTokens(address _token) internal {\n    if (tokenFarmingStatus[_token]) {\n      if (_token == _TETU_USDC_BPT) {\n        uint balance = IERC20(_token).balanceOf(address(this));\n        if (balance != 0) {\n          IERC20(_token).safeApprove(_TETU_USDC_BPT_VAULT, balance);\n          ISmartVault(_TETU_USDC_BPT_VAULT).depositAndInvest(balance);\n        }\n      }\n    }\n  }\n\n  /// @dev Unstake necessary amount, if possible\n  function _unstakeTokens(address _token, uint amount) internal {\n    uint tokenBalance = IERC20(_token).balanceOf(address(this));\n    if (amount != 0 && amount > tokenBalance) {\n      // withdraw only required amount\n      amount -= tokenBalance;\n      // no need to check whitelisting for withdraw\n      if (_token == _TETU_USDC_BPT) {\n        // add gap value for avoid rounding issues\n        uint shares = amount * 1e18 / ISmartVault(_TETU_USDC_BPT_VAULT).getPricePerFullShare() + 1e18;\n        uint sharesBalance = IERC20(_TETU_USDC_BPT_VAULT).balanceOf(address(this));\n        shares = shares > sharesBalance ? sharesBalance : shares;\n        ISmartVault(_TETU_USDC_BPT_VAULT).withdraw(shares);\n      }\n    }\n  }\n\n  /// @dev Anyone can withdraw all staked tokens if farming status = false\n  function emergencyWithdrawStakedTokens(address _token) external {\n    if (!tokenFarmingStatus[_token]) {\n      if (_token == _TETU_USDC_BPT) {\n        ISmartVault(_TETU_USDC_BPT_VAULT).exit();\n      }\n    }\n  }\n\n  /// @dev Transfer underlying token to recipient, unstake if need required amount\n  function _transferUnderlyingToken(address _token, address recipient, uint amount) internal {\n    _unstakeTokens(_token, amount);\n    IERC20(_token).safeTransfer(recipient, amount);\n  }\n\n  /// @notice Deposit and lock tokens for a user\n  function _depositFor(DepositInfo memory info) internal {\n\n    uint newLockedDerivedAmount = info.lockedDerivedAmount;\n    if (info.value != 0) {\n\n      // calculate new amounts\n      uint newAmount = info.lockedAmount + info.value;\n      newLockedDerivedAmount = _calculateDerivedAmount(\n        info.lockedAmount,\n        info.lockedDerivedAmount,\n        newAmount,\n        tokenWeights[info.stakingToken],\n        IERC20Metadata(info.stakingToken).decimals()\n      );\n      // update chain info\n      lockedAmounts[info.tokenId][info.stakingToken] = newAmount;\n      lockedDerivedAmount[info.tokenId] = newLockedDerivedAmount;\n    }\n\n    // Adding to existing lock, or if a lock is expired - creating a new one\n    uint newLockedEnd = info.lockedEnd;\n    if (info.unlockTime != 0) {\n      lockedEnd[info.tokenId] = info.unlockTime;\n      newLockedEnd = info.unlockTime;\n    }\n\n    // update checkpoint\n    _checkpoint(CheckpointInfo(\n        info.tokenId,\n        info.lockedDerivedAmount,\n        newLockedDerivedAmount,\n        info.lockedEnd,\n        newLockedEnd\n      ));\n\n    // move tokens to this contract, if necessary\n    address from = msg.sender;\n    if (info.value != 0 && info.depositType != DepositType.MERGE_TYPE) {\n      _pullStakingToken(info.stakingToken, from, info.value);\n    }\n\n    emit Deposit(info.stakingToken, from, info.tokenId, info.value, newLockedEnd, info.depositType, block.timestamp);\n  }\n\n  function _calculateDerivedAmount(\n    uint currentAmount,\n    uint oldDerivedAmount,\n    uint newAmount,\n    uint weight,\n    uint8 decimals\n  ) internal pure returns (uint) {\n    // subtract current derived balance\n    // rounded to UP for subtracting closer to 0 value\n    if (oldDerivedAmount != 0 && currentAmount != 0) {\n      currentAmount = currentAmount.divWadUp(10 ** decimals);\n      uint currentDerivedAmount = currentAmount.mulDivUp(weight, WEIGHT_DENOMINATOR);\n      if (oldDerivedAmount > currentDerivedAmount) {\n        oldDerivedAmount -= currentDerivedAmount;\n      } else {\n        // in case of wrong rounding better to set to zero than revert\n        oldDerivedAmount = 0;\n      }\n    }\n\n    // recalculate derived amount with new amount\n    // rounded to DOWN\n    // normalize decimals to 18\n    newAmount = newAmount.divWadDown(10 ** decimals);\n    // calculate the final amount based on the weight\n    newAmount = newAmount.mulDivDown(weight, WEIGHT_DENOMINATOR);\n    return oldDerivedAmount + newAmount;\n  }\n\n  /// @notice Record global data to checkpoint\n  function checkpoint() external override {\n    _checkpoint(CheckpointInfo(0, 0, 0, 0, 0));\n  }\n\n  function _lockInfo(address stakingToken, uint veId) internal view returns (\n    uint _lockedAmount,\n    uint _lockedDerivedAmount,\n    uint _lockedEnd\n  ) {\n    _lockedAmount = lockedAmounts[veId][stakingToken];\n    _lockedDerivedAmount = lockedDerivedAmount[veId];\n    _lockedEnd = lockedEnd[veId];\n  }\n\n  function _incrementTokenIdAndGet() internal returns (uint){\n    uint current = tokenId;\n    tokenId = current + 1;\n    return current + 1;\n  }\n\n  /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n  /// @param _token Token for deposit. Should be whitelisted in this contract.\n  /// @param _value Amount to deposit\n  /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n  /// @param _to Address to deposit\n  function _createLock(address _token, uint _value, uint _lockDuration, address _to) internal returns (uint) {\n    require(_value > 0, \"WRONG_INPUT\");\n    // Lock time is rounded down to weeks\n    uint unlockTime = (block.timestamp + _lockDuration) / WEEK * WEEK;\n    require(unlockTime > block.timestamp, \"LOW_LOCK_PERIOD\");\n    require(unlockTime <= block.timestamp + MAX_TIME, \"HIGH_LOCK_PERIOD\");\n    require(isValidToken[_token], \"INVALID_TOKEN\");\n\n    uint _tokenId = _incrementTokenIdAndGet();\n    _mint(_to, _tokenId);\n\n    _depositFor(DepositInfo({\n    stakingToken : _token,\n    tokenId : _tokenId,\n    value : _value,\n    unlockTime : unlockTime,\n    lockedAmount : 0,\n    lockedDerivedAmount : 0,\n    lockedEnd : 0,\n    depositType : DepositType.CREATE_LOCK_TYPE\n    }));\n    return _tokenId;\n  }\n\n  /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n  /// @param _token Token for deposit. Should be whitelisted in this contract.\n  /// @param _value Amount to deposit\n  /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n  /// @param _to Address to deposit\n  function createLockFor(address _token, uint _value, uint _lockDuration, address _to)\n  external nonReentrant override returns (uint) {\n    return _createLock(_token, _value, _lockDuration, _to);\n  }\n\n  /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n  /// @param _value Amount to deposit\n  /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n  function createLock(address _token, uint _value, uint _lockDuration) external nonReentrant returns (uint) {\n    return _createLock(_token, _value, _lockDuration, msg.sender);\n  }\n\n  /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n  /// @dev Anyone (even a smart contract) can deposit for someone else, but\n  ///      cannot extend their locktime and deposit for a brand new user\n  /// @param _token Token for deposit. Should be whitelisted in this contract.\n  /// @param _tokenId ve token ID\n  /// @param _value Amount of tokens to deposit and add to the lock\n  function increaseAmount(address _token, uint _tokenId, uint _value) external nonReentrant override {\n    require(_value > 0, \"WRONG_INPUT\");\n    (uint _lockedAmount, uint _lockedDerivedAmount, uint _lockedEnd) = _lockInfo(_token, _tokenId);\n\n    require(_lockedDerivedAmount > 0, \"NFT_WITHOUT_POWER\");\n    require(_lockedEnd > block.timestamp, \"EXPIRED\");\n    require(isValidToken[_token], \"INVALID_TOKEN\");\n\n    _depositFor(DepositInfo({\n    stakingToken : _token,\n    tokenId : _tokenId,\n    value : _value,\n    unlockTime : 0,\n    lockedAmount : _lockedAmount,\n    lockedDerivedAmount : _lockedDerivedAmount,\n    lockedEnd : _lockedEnd,\n    depositType : DepositType.INCREASE_LOCK_AMOUNT\n    }));\n  }\n\n  /// @notice Extend the unlock time for `_tokenId`\n  /// @param _tokenId ve token ID\n  /// @param _lockDuration New number of seconds until tokens unlock\n  function increaseUnlockTime(uint _tokenId, uint _lockDuration) external nonReentrant returns (\n    uint power,\n    uint unlockDate\n  )  {\n    uint _lockedDerivedAmount = lockedDerivedAmount[_tokenId];\n    uint _lockedEnd = lockedEnd[_tokenId];\n    // Lock time is rounded down to weeks\n    uint unlockTime = (block.timestamp + _lockDuration) / WEEK * WEEK;\n    require(_lockedDerivedAmount > 0, \"NFT_WITHOUT_POWER\");\n    require(_lockedEnd > block.timestamp, \"EXPIRED\");\n    require(unlockTime > _lockedEnd, \"LOW_UNLOCK_TIME\");\n    require(unlockTime <= block.timestamp + MAX_TIME, \"HIGH_LOCK_PERIOD\");\n    require(isApprovedOrOwner(msg.sender, _tokenId), \"NOT_OWNER\");\n\n    _depositFor(DepositInfo({\n    stakingToken : address(0),\n    tokenId : _tokenId,\n    value : 0,\n    unlockTime : unlockTime,\n    lockedAmount : 0,\n    lockedDerivedAmount : _lockedDerivedAmount,\n    lockedEnd : _lockedEnd,\n    depositType : DepositType.INCREASE_UNLOCK_TIME\n    }));\n\n    power = balanceOfNFT(_tokenId);\n    unlockDate = lockedEnd[_tokenId];\n  }\n\n  /// @dev Merge two NFTs union their balances and keep the biggest lock time.\n  function merge(uint _from, uint _to) external nonReentrant {\n    require(attachments[_from] == 0 && voted[_from] == 0, \"ATTACHED\");\n    require(_from != _to, \"IDENTICAL_ADDRESS\");\n    require(_idToOwner[_from] == msg.sender && _idToOwner[_to] == msg.sender, \"NOT_OWNER\");\n\n    uint lockedEndFrom = lockedEnd[_from];\n    uint lockedEndTo = lockedEnd[_to];\n    uint end = lockedEndFrom >= lockedEndTo ? lockedEndFrom : lockedEndTo;\n    uint oldDerivedAmount = lockedDerivedAmount[_from];\n\n    uint length = tokens.length;\n    // we should use the old one for properly calculate checkpoint for the new ve\n    uint newLockedEndTo = lockedEndTo;\n    for (uint i; i < length; i++) {\n      address stakingToken = tokens[i];\n      uint _lockedAmountFrom = lockedAmounts[_from][stakingToken];\n      if (_lockedAmountFrom == 0) {\n        continue;\n      }\n      lockedAmounts[_from][stakingToken] = 0;\n\n      _depositFor(DepositInfo({\n      stakingToken : stakingToken,\n      tokenId : _to,\n      value : _lockedAmountFrom,\n      unlockTime : end,\n      lockedAmount : lockedAmounts[_to][stakingToken],\n      lockedDerivedAmount : lockedDerivedAmount[_to],\n      lockedEnd : newLockedEndTo,\n      depositType : DepositType.MERGE_TYPE\n      }));\n\n      // set new lock time to the current end lock\n      newLockedEndTo = end;\n\n      emit Merged(stakingToken, msg.sender, _from, _to);\n    }\n\n    lockedDerivedAmount[_from] = 0;\n    lockedEnd[_from] = 0;\n\n    // update checkpoint\n    _checkpoint(CheckpointInfo(\n        _from,\n        oldDerivedAmount,\n        0,\n        lockedEndFrom,\n        lockedEndFrom\n      ));\n\n    _burn(_from);\n  }\n\n  /// @dev Split given veNFT. A new NFT will have a given percent of underlying tokens.\n  /// @param _tokenId ve token ID\n  /// @param percent percent of underlying tokens for new NFT with denominator 1e18 (1-(100e18-1)).\n  function split(uint _tokenId, uint percent) external nonReentrant {\n    require(attachments[_tokenId] == 0 && voted[_tokenId] == 0, \"ATTACHED\");\n    require(_idToOwner[_tokenId] == msg.sender, \"NOT_OWNER\");\n    require(percent != 0 && percent < 100e18, \"WRONG_INPUT\");\n\n    uint _lockedDerivedAmount = lockedDerivedAmount[_tokenId];\n    uint oldLockedDerivedAmount = _lockedDerivedAmount;\n    uint _lockedEnd = lockedEnd[_tokenId];\n\n    require(_lockedEnd > block.timestamp, \"EXPIRED\");\n\n    // crete new NFT\n    uint _newTokenId = _incrementTokenIdAndGet();\n    _mint(msg.sender, _newTokenId);\n\n    // migrate percent of locked tokens to the new NFT\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      address stakingToken = tokens[i];\n      uint _lockedAmount = lockedAmounts[_tokenId][stakingToken];\n      if (_lockedAmount == 0) {\n        continue;\n      }\n      uint amountForNewNFT = _lockedAmount * percent / 100e18;\n      require(amountForNewNFT != 0, \"LOW_PERCENT\");\n\n      uint newLockedDerivedAmount = _calculateDerivedAmount(\n        _lockedAmount,\n        _lockedDerivedAmount,\n        _lockedAmount - amountForNewNFT,\n        tokenWeights[stakingToken],\n        IERC20Metadata(stakingToken).decimals()\n      );\n\n      _lockedDerivedAmount = newLockedDerivedAmount;\n\n      lockedAmounts[_tokenId][stakingToken] = _lockedAmount - amountForNewNFT;\n\n      // increase values for new NFT\n      _depositFor(DepositInfo({\n      stakingToken : stakingToken,\n      tokenId : _newTokenId,\n      value : amountForNewNFT,\n      unlockTime : _lockedEnd,\n      lockedAmount : 0,\n      lockedDerivedAmount : lockedDerivedAmount[_newTokenId],\n      lockedEnd : _lockedEnd,\n      depositType : DepositType.MERGE_TYPE\n      }));\n    }\n\n    // update derived amount\n    lockedDerivedAmount[_tokenId] = _lockedDerivedAmount;\n\n    // update checkpoint\n    _checkpoint(CheckpointInfo(\n        _tokenId,\n        oldLockedDerivedAmount,\n        _lockedDerivedAmount,\n        _lockedEnd,\n        _lockedEnd\n      ));\n\n    emit Split(_tokenId, _newTokenId, percent);\n  }\n\n  /// @notice Withdraw all staking tokens for `_tokenId`\n  /// @dev Only possible if the lock has expired\n  function withdrawAll(uint _tokenId) external {\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      address token = tokens[i];\n      if (lockedAmounts[_tokenId][token] != 0) {\n        withdraw(token, _tokenId);\n      }\n    }\n  }\n\n  /// @notice Withdraw given staking token for `_tokenId`\n  /// @dev Only possible if the lock has expired\n  function withdraw(address stakingToken, uint _tokenId) public nonReentrant {\n    require(isApprovedOrOwner(msg.sender, _tokenId), \"NOT_OWNER\");\n    require(attachments[_tokenId] == 0 && voted[_tokenId] == 0, \"ATTACHED\");\n\n    (uint oldLockedAmount, uint oldLockedDerivedAmount, uint oldLockedEnd) =\n    _lockInfo(stakingToken, _tokenId);\n    require(block.timestamp >= oldLockedEnd, \"NOT_EXPIRED\");\n    require(oldLockedAmount > 0, \"ZERO_LOCKED\");\n\n\n    uint newLockedDerivedAmount = _calculateDerivedAmount(\n      oldLockedAmount,\n      oldLockedDerivedAmount,\n      0,\n      tokenWeights[stakingToken],\n      IERC20Metadata(stakingToken).decimals()\n    );\n\n    // if no tokens set lock to zero\n    uint newLockEnd = oldLockedEnd;\n    if (newLockedDerivedAmount == 0) {\n      lockedEnd[_tokenId] = 0;\n      newLockEnd = 0;\n    }\n\n    // update derived amount\n    lockedDerivedAmount[_tokenId] = newLockedDerivedAmount;\n\n    // set locked amount to zero, we will withdraw all\n    lockedAmounts[_tokenId][stakingToken] = 0;\n\n    // update checkpoint\n    _checkpoint(CheckpointInfo(\n        _tokenId,\n        oldLockedDerivedAmount,\n        newLockedDerivedAmount,\n        oldLockedEnd,\n        newLockEnd\n      ));\n\n    // Burn the NFT\n    if (newLockedDerivedAmount == 0) {\n      _burn(_tokenId);\n    }\n\n    _transferUnderlyingToken(stakingToken, msg.sender, oldLockedAmount);\n\n    emit Withdraw(stakingToken, msg.sender, _tokenId, oldLockedAmount, block.timestamp);\n  }\n\n  // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n  // They measure the weights for the purpose of voting, so they don't represent\n  // real coins.\n\n  /// @notice Binary search to estimate timestamp for block number\n  /// @param _block Block to find\n  /// @param maxEpoch Don't go beyond this epoch\n  /// @return Approximate timestamp for block\n  function _findBlockEpoch(uint _block, uint maxEpoch) internal view returns (uint) {\n    // Binary search\n    uint _min = 0;\n    uint _max = maxEpoch;\n    for (uint i = 0; i < 128; ++i) {\n      // Will be always enough for 128-bit numbers\n      if (_min >= _max) {\n        break;\n      }\n      uint _mid = (_min + _max + 1) / 2;\n      if (_pointHistory[_mid].blk <= _block) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  /// @notice Get the current voting power for `_tokenId`\n  /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n  /// @param _tokenId NFT for lock\n  /// @param _t Epoch time to return voting power at\n  /// @return User voting power\n  function _balanceOfNFT(uint _tokenId, uint _t) internal view returns (uint) {\n    uint _epoch = userPointEpoch[_tokenId];\n    if (_epoch == 0) {\n      return 0;\n    } else {\n      Point memory lastPoint = _userPointHistory[_tokenId][_epoch];\n      require(_t >= lastPoint.ts, \"WRONG_INPUT\");\n      lastPoint.bias -= lastPoint.slope * int128(int256(_t) - int256(lastPoint.ts));\n      if (lastPoint.bias < 0) {\n        lastPoint.bias = 0;\n      }\n      return uint(int256(lastPoint.bias));\n    }\n  }\n\n  /// @dev Returns current token URI metadata\n  /// @param _tokenId Token ID to fetch URI for.\n  function tokenURI(uint _tokenId) external view override returns (string memory) {\n    require(_idToOwner[_tokenId] != address(0), \"TOKEN_NOT_EXIST\");\n\n    uint _lockedEnd = lockedEnd[_tokenId];\n    return\n    VeTetuLogo.tokenURI(\n      _tokenId,\n      uint(int256(lockedDerivedAmount[_tokenId])),\n      block.timestamp < _lockedEnd ? _lockedEnd - block.timestamp : 0,\n      _balanceOfNFT(_tokenId, block.timestamp)\n    );\n  }\n\n  /// @notice Measure voting power of `_tokenId` at block height `_block`\n  /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n  /// @param _tokenId User's wallet NFT\n  /// @param _block Block to calculate the voting power at\n  /// @return Voting power\n  function _balanceOfAtNFT(uint _tokenId, uint _block) internal view returns (uint) {\n    // Copying and pasting totalSupply code because Vyper cannot pass by\n    // reference yet\n    require(_block <= block.number, \"WRONG_INPUT\");\n\n    // Binary search\n    uint _min = 0;\n    uint _max = userPointEpoch[_tokenId];\n    for (uint i = 0; i < 128; ++i) {\n      // Will be always enough for 128-bit numbers\n      if (_min >= _max) {\n        break;\n      }\n      uint _mid = (_min + _max + 1) / 2;\n      if (_userPointHistory[_tokenId][_mid].blk <= _block) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n\n    Point memory uPoint = _userPointHistory[_tokenId][_min];\n\n    uint maxEpoch = epoch;\n    uint _epoch = _findBlockEpoch(_block, maxEpoch);\n    Point memory point0 = _pointHistory[_epoch];\n    uint dBlock = 0;\n    uint dt = 0;\n    if (_epoch < maxEpoch) {\n      Point memory point1 = _pointHistory[_epoch + 1];\n      dBlock = point1.blk - point0.blk;\n      dt = point1.ts - point0.ts;\n    } else {\n      dBlock = block.number - point0.blk;\n      dt = block.timestamp - point0.ts;\n    }\n    uint blockTime = point0.ts;\n    if (dBlock != 0 && _block > point0.blk) {\n      blockTime += (dt * (_block - point0.blk)) / dBlock;\n    }\n\n    uPoint.bias -= uPoint.slope * int128(int256(blockTime - uPoint.ts));\n    return uint(uint128(uPoint.bias.positiveInt128()));\n  }\n\n\n\n  /// @notice Calculate total voting power at some point in the past\n  /// @param point The point (bias/slope) to start search from\n  /// @param t Time to calculate the total voting power at\n  /// @return Total voting power at that time\n  function _supplyAt(Point memory point, uint t) internal view returns (uint) {\n    Point memory lastPoint = point;\n    uint ti = (lastPoint.ts / WEEK) * WEEK;\n    for (uint i = 0; i < 255; ++i) {\n      ti += WEEK;\n      int128 dSlope = 0;\n      if (ti > t) {\n        ti = t;\n      } else {\n        dSlope = slopeChanges[ti];\n      }\n      lastPoint.bias -= lastPoint.slope * int128(int256(ti - lastPoint.ts));\n      if (ti == t) {\n        break;\n      }\n      lastPoint.slope += dSlope;\n      lastPoint.ts = ti;\n    }\n    return uint(uint128(lastPoint.bias.positiveInt128()));\n  }\n\n  /// @notice Calculate total voting power\n  /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n  /// @return Total voting power\n  function totalSupplyAtT(uint t) public view returns (uint) {\n    uint _epoch = epoch;\n    Point memory lastPoint = _pointHistory[_epoch];\n    return _supplyAt(lastPoint, t);\n  }\n\n  /// @notice Calculate total voting power at some point in the past\n  /// @param _block Block to calculate the total voting power at\n  /// @return Total voting power at `_block`\n  function totalSupplyAt(uint _block) external view override returns (uint) {\n    require(_block <= block.number, \"WRONG_INPUT\");\n    uint _epoch = epoch;\n    uint targetEpoch = _findBlockEpoch(_block, _epoch);\n\n    Point memory point = _pointHistory[targetEpoch];\n    // it is possible only for a block before the launch\n    // return 0 as more clear answer than revert\n    if (point.blk > _block) {\n      return 0;\n    }\n    uint dt = 0;\n    if (targetEpoch < _epoch) {\n      Point memory pointNext = _pointHistory[targetEpoch + 1];\n      // next point block can not be the same or lower\n      dt = ((_block - point.blk) * (pointNext.ts - point.ts)) / (pointNext.blk - point.blk);\n    } else {\n      if (point.blk != block.number) {\n        dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\n      }\n    }\n    // Now dt contains info on how far are we beyond point\n    return _supplyAt(point, point.ts + dt);\n  }\n\n  function _burn(uint _tokenId) internal {\n    address owner = ownerOf(_tokenId);\n    // Clear approval\n    approve(address(0), _tokenId);\n    // Remove token\n    _removeTokenFrom(owner, _tokenId);\n    emit Transfer(owner, address(0), _tokenId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/ve/VeTetuLogo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../lib/Base64.sol\";\nimport \"./../lib/StringLib.sol\";\n\n/// @title Library for storing SVG image of veNFT.\n/// @author belbix\nlibrary VeTetuLogo {\n\n  /// @dev Return SVG logo of veTETU.\n  function tokenURI(uint _tokenId, uint _balanceOf, uint untilEnd, uint _value) public pure returns (string memory output) {\n    output = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 600 900\"><style>.base{font-size:40px;}</style><rect fill=\"#193180\" width=\"600\" height=\"900\"/><path fill=\"#4899F8\" d=\"M0,900h600V522.2C454.4,517.2,107.4,456.8,60.2,0H0V900z\"/><circle fill=\"#1B184E\" cx=\"385\" cy=\"212\" r=\"180\"/><circle fill=\"#04A8F0\" cx=\"385\" cy=\"142\" r=\"42\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"#686DF1\" d=\"M385.6,208.8c43.1,0,78-34.9,78-78c-1.8-21.1,16.2-21.1,21.1-15.4c0.4,0.3,0.7,0.7,1.1,1.2c16.7,21.5,26.6,48.4,26.6,77.7c0,25.8-24.4,42.2-50.2,42.2H309c-25.8,0-50.2-16.4-50.2-42.2c0-29.3,9.9-56.3,26.6-77.7c0.3-0.4,0.7-0.8,1.1-1.2c4.9-5.7,22.9-5.7,21.1,15.4l0,0C307.6,173.9,342.5,208.8,385.6,208.8z\"/><path fill=\"#04A8F0\" d=\"M372.3,335.9l-35.5-51.2c-7.5-10.8,0.2-25.5,13.3-25.5h35.5h35.5c13.1,0,20.8,14.7,13.3,25.5l-35.5,51.2C392.5,345.2,378.7,345.2,372.3,335.9z\"/>';\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 464)\" fill=\"#EAECFE\" class=\"base\">ID:</text><text transform=\"matrix(1 0 0 1 50 506)\" fill=\"#97D0FF\" class=\"base\">', StringLib._toString(_tokenId), '</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 579)\" fill=\"#EAECFE\" class=\"base\">Balance:</text><text transform=\"matrix(1 0 0 1 50 621)\" fill=\"#97D0FF\" class=\"base\">', StringLib._toString(_balanceOf / 1e18), '</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 695)\" fill=\"#EAECFE\" class=\"base\">Until unlock:</text><text transform=\"matrix(1 0 0 1 50 737)\" fill=\"#97D0FF\" class=\"base\">', StringLib._toString(untilEnd / 60 / 60 / 24), ' days</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 811)\" fill=\"#EAECFE\" class=\"base\">Power:</text><text transform=\"matrix(1 0 0 1 50 853)\" fill=\"#97D0FF\" class=\"base\">', StringLib._toString(_value / 1e18), '</text></svg>'));\n\n    string memory json = Base64.encode(bytes(string(abi.encodePacked('{\"name\": \"veTETU #', StringLib._toString(_tokenId), '\", \"description\": \"Locked TETU tokens\", \"image\": \"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\"}'))));\n    output = string(abi.encodePacked('data:application/json;base64,', json));\n  }\n\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @notice Keep and provide addresses of all application contracts\ninterface IConverterController {\n  function governance() external view returns (address);\n\n  // ********************* Health factor explanation  ****************\n  // For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\n  // For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\n  // We set min-health-factor = 1.1, target-health-factor = 1.3\n  // For collateral 100 we will borrow 100/1.3 = 76.92\n  //\n  // Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\n  // Collateral * LT    85         65.45\n  // Borrow value       65.38      65.38         but borrow value is the same as before\n  // Health factor      1.3        1.001         liquidation almost happens here (!)\n  //\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\n  // and the borrow value won't change at the same time, the liquidation happens at that point.\n  // Min health factor marks the point at which a rebalancing must be made asap.\n  // *****************************************************************\n\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\n  function minHealthFactor2() external view returns (uint16);\n  function setMinHealthFactor2(uint16 value_) external;\n\n  /// @notice target health factor with decimals 2\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\n  ///      or additional borrow and restore the health factor to the given target value\n  function targetHealthFactor2() external view returns (uint16);\n  function setTargetHealthFactor2(uint16 value_) external;\n\n  /// @notice max allowed health factor with decimals 2\n  /// @dev For future versions, currently max health factor is not used\n  function maxHealthFactor2() external view returns (uint16);\n  /// @dev For future versions, currently max health factor is not used\n  function setMaxHealthFactor2(uint16 value_) external;\n\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\n  function blocksPerDay() external view returns (uint);\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\n  /// @notice Check if it's time to call updateBlocksPerDay()\n  /// @param periodInSeconds_ Period of auto-update in seconds\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\n  /// @notice Recalculate blocksPerDay value\n  /// @param periodInSeconds_ Period of auto-update in seconds\n  function updateBlocksPerDay(uint periodInSeconds_) external;\n\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\n  function paused() external view returns (bool);\n\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\n  function isWhitelisted(address user_) external view returns (bool);\n\n  /// @notice The size of the gap by which the debt should be increased upon repayment\n  ///         Such gaps are required by AAVE pool adapters to workaround dust tokens problem\n  ///         and be able to make full repayment.\n  /// @dev Debt gap is applied as following: toPay = debt * (DEBT_GAP_DENOMINATOR + debtGap) / DEBT_GAP_DENOMINATOR\n  function debtGap() external view returns (uint);\n\n  //-----------------------------------------------------\n  //        Core application contracts\n  //-----------------------------------------------------\n\n  function tetuConverter() external view returns (address);\n  function borrowManager() external view returns (address);\n  function debtMonitor() external view returns (address);\n  function tetuLiquidator() external view returns (address);\n  function swapManager() external view returns (address);\n  function priceOracle() external view returns (address);\n\n  //-----------------------------------------------------\n  //        External contracts\n  //-----------------------------------------------------\n  /// @notice A keeper to control health and efficiency of the borrows\n  function keeper() external view returns (address);\n  /// @notice Controller of tetu-contracts-v2, that is allowed to update proxy contracts\n  function proxyUpdater() external view returns (address);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverterControllerProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IConverterControllerProvider {\n  function controller() external view returns (address);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IPriceOracle {\n  /// @notice Return asset price in USD, decimals 18\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IConverterControllerProvider.sol\";\n\n/// @notice Main contract of the TetuConverter application\n/// @dev Borrower (strategy) makes all operations via this contract only.\ninterface ITetuConverter is IConverterControllerProvider {\n\n  /// @notice Find possible borrow strategies and provide \"cost of money\" as interest for the period for each strategy\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param amountIn_  The meaning depends on entryData\n  ///                   For entryKind=0 it's max available amount of collateral\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\n  /// @return converters Array of available converters ordered in ascending order of APR.\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\n  ///                    This address should be passed to borrow-function during conversion.\n  ///                    The length of array is always equal to the count of available lending platforms.\n  ///                    Last items in array can contain zero addresses (it means they are not used)\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\n  /// @return amountToBorrowsOut Amounts that should be borrowed\n  ///                            This amount is not zero if corresponded converter is not zero.\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\n  function findBorrowStrategies(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountToBorrowsOut,\n    int[] memory aprs18\n  );\n\n  /// @notice Find best swap strategy and provide \"cost of money\" as interest for the period\n  /// @dev This is writable function with read-only behavior.\n  ///      It should be writable to be able to simulate real swap and get a real APR.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param amountIn_  The meaning depends on entryData\n  ///                   For entryKind=0 it's max available amount of collateral\n  ///                   This amount must be approved to TetuConverter before the call.\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\n  function findSwapStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_\n  ) external returns (\n    address converter,\n    uint sourceAmountOut,\n    uint targetAmountOut,\n    int apr18\n  );\n\n  /// @notice Find best conversion strategy (swap or borrow) and provide \"cost of money\" as interest for the period.\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\n  /// @dev This is writable function with read-only behavior.\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param amountIn_  The meaning depends on entryData\n  ///                   For entryKind=0 it's max available amount of collateral\n  ///                   This amount must be approved to TetuConverter before the call.\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\n  function findConversionStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external returns (\n    address converter,\n    uint collateralAmountOut,\n    uint amountToBorrowOut,\n    int apr18\n  );\n\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\n  ///      Only whitelisted users are allowed to make borrows\n  /// @param converter_ A converter received from findBestConversionStrategy.\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\n  ///                          This amount must be approved to TetuConverter before the call.\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\n  /// @param receiver_ A receiver of borrowed amount\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\n  function borrow(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_\n  ) external returns (\n    uint borrowedAmountOut\n  );\n\n  /// @notice Full or partial repay of the borrow\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\n  ///        You can know exact total amount of debt using {getStatusCurrent}.\n  ///        if the amount exceed total amount of the debt:\n  ///           - the debt will be fully repaid\n  ///           - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\n  ///        This amount should be calculated with taking into account possible debt gap,\n  ///        You should call getDebtAmountCurrent(debtGap = true) to get this amount.\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\n  ///         If TetuConverter is not able to make the swap, it reverts\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\n  ///                                 This amount is returned back to the collateralReceiver_\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\n  function repay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_\n  ) external returns (\n    uint collateralAmountOut,\n    uint returnedBorrowAmountOut,\n    uint swappedLeftoverCollateralOut,\n    uint swappedLeftoverBorrowOut\n  );\n\n  /// @notice Estimate result amount after making full or partial repay\n  /// @dev It works in exactly same way as repay() but don't make actual repay\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\n  /// @param user_ user whose amount-to-repay will be calculated\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\n  ///        This amount should be calculated without possible debt gap.\n  ///        In this way it's differ from {repay}\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\n  /// @return swappedAmountOut A part of {collateralAmountOut} that were received by direct swap\n  function quoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_\n  ) external returns (\n    uint collateralAmountOut,\n    uint swappedAmountOut\n  );\n\n  /// @notice Update status in all opened positions\n  ///         After this call getDebtAmount will be able to return exact amount to repay\n  /// @param user_ user whose debts will be returned\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\n  function getDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    bool useDebtGap_\n  ) external returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  );\n\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\n  /// @param user_ user whose debts will be returned\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\n  function getDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    bool useDebtGap_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  );\n\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\n  /// @param user_ user whose debts will be returned\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\n  ///                                           even if all borrowed amount will be returned.\n  ///                                           If this amount is not 0, you ask to get too much collateral.\n  function estimateRepay(\n    address user_,\n    address collateralAsset_,\n    uint collateralAmountRequired_,\n    address borrowAsset_\n  ) external view returns (\n    uint borrowAssetAmount,\n    uint unobtainableCollateralAssetAmount\n  );\n\n  /// @notice Transfer all reward tokens to {receiver_}\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\n  function claimRewards(address receiver_) external returns (\n    address[] memory rewardTokensOut,\n    uint[] memory amountsOut\n  );\n\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\n  ///                      It should be transferred on balance of the TetuConverter before the function call\n  /// @param receiver_ Result amount will be sent to this address\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\n  function safeLiquidate(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    address receiver_,\n    uint priceImpactToleranceSource_,\n    uint priceImpactToleranceTarget_\n  ) external returns (\n    uint amountOut\n  );\n\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\n  function isConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    uint priceImpactTolerance_\n  ) external view returns (bool);\n\n  /// @notice Close given borrow and return collateral back to the user, governance only\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\n  /// @param poolAdapter_ The pool adapter that represents the borrow\n  /// @param closePosition Close position after repay\n  ///        Usually it should be true, because the function always tries to repay all debt\n  ///        false can be used if user doesn't have enough amount to pay full debt\n  ///              and we are trying to pay \"as much as possible\"\n  /// @return collateralAmountOut Amount of collateral returned to the user\n  /// @return repaidAmountOut Amount of borrow asset paid to the lending platform\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\n    uint collateralAmountOut,\n    uint repaidAmountOut\n  );\n\n  /// @notice Get active borrows of the user with given collateral/borrowToken\n  /// @dev Simple access to IDebtMonitor.getPositions\n  /// @return poolAdaptersOut The instances of IPoolAdapter\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external view returns (\n    address[] memory poolAdaptersOut\n  );\n\n  /// @notice Save token from TC-balance to {receiver}\n  /// @dev Normally TetuConverter doesn't have any tokens on balance, they can appear there accidentally only\n  function salvage(address receiver, address token, uint amount) external;\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice TetuConverter sends callback notifications to its user via this interface\ninterface ITetuConverterCallback {\n  /// @notice Converters calls this function if user should return some amount back.\n  ///         f.e. when the health factor is unhealthy and the converter needs more tokens to fix it.\n  ///         or when the full repay is required and converter needs to get full amount-to-repay.\n  /// @param asset_ Required asset (either collateral or borrow)\n  /// @param amount_ Required amount of the {asset_}\n  /// @return amountOut Exact amount that borrower has sent to balance of TetuConverter\n  function requirePayAmountBack(address asset_, uint amount_) external returns (uint amountOut);\n\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external;\n}\n"
    },
    "contracts/integrations/balancer/IBalancerGauge.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IBalancerGauge {\n  function decimals() external view returns (uint256);\n\n  function version() external view returns (string memory);\n\n  function last_claim() external view returns (uint256);\n\n  function claimed_reward(address _addr, address _token) external view returns (uint256);\n\n  function claimable_reward(address _addr, address _token) external view returns (uint256);\n\n  function claimable_reward_write(address _addr, address _token) external returns (uint256);\n\n  function reward_contract() external view returns (address);\n\n  function reward_data(address _token) external view returns (\n    address token,\n    address distributor,\n    uint256 period_finish,\n    uint256 rate,\n    uint256 last_update,\n    uint256 integral\n  );\n\n  function reward_tokens(uint256 arg0) external view returns (address);\n\n  function reward_balances(address arg0) external view returns (uint256);\n\n  function rewards_receiver(address arg0) external view returns (address);\n\n  function reward_integral(address arg0) external view returns (uint256);\n\n  function reward_integral_for(address arg0, address arg1) external view returns (uint256);\n\n  function set_rewards_receiver(address _receiver) external;\n\n  function set_rewards(\n    address _reward_contract,\n    bytes32 _claim_sig,\n    address[8] memory _reward_tokens\n  ) external;\n\n  function claim_rewards() external;\n\n  function claim_rewards(address _addr) external;\n\n  function claim_rewards(address _addr, address _receiver) external;\n\n  function deposit(uint256 _value) external;\n\n  function deposit(uint256 _value, address _addr) external;\n\n  function deposit(uint256 _value, address _addr, bool _claim_rewards) external;\n\n  function withdraw(uint256 _value) external;\n\n  function withdraw(uint256 _value, bool _claim_rewards) external;\n\n  function transfer(address _to, uint256 _value) external returns (bool);\n\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address _spender, uint256 _value) external returns (bool);\n\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _value,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (bool);\n\n  function increaseAllowance(address _spender, uint256 _added_value) external returns (bool);\n\n  function decreaseAllowance(address _spender, uint256 _subtracted_value) external returns (bool);\n\n  function initialize(\n    address _lp_token,\n    address _reward_contract,\n    bytes32 _claim_sig\n  ) external;\n\n  function lp_token() external view returns (address);\n\n  function balanceOf(address arg0) external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function nonces(address arg0) external view returns (uint256);\n\n  function claim_sig() external view returns (bytes memory);\n}\n"
    },
    "contracts/integrations/balancer/IBalancerHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IBVault.sol\";\n\ninterface IBalancerHelper {\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    IBVault.ExitPoolRequest memory request\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    IBVault.JoinPoolRequest memory request\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function vault() external view returns (address);\n}\n"
    },
    "contracts/integrations/balancer/IBVault.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\n\ninterface IAsset {\n}\n\ninterface IBVault {\n  // Internal Balance\n  //\n  // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n  // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n  // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n  // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n  //\n  // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n  // operations of different kinds, with different senders and recipients, at once.\n\n  /**\n   * @dev Returns `user`'s Internal Balance for a set of tokens.\n     */\n  function getInternalBalance(address user, IERC20[] calldata tokens) external view returns (uint256[] memory);\n\n  /**\n   * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n  function manageUserBalance(UserBalanceOp[] calldata ops) external payable;\n\n  /**\n   * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n  struct UserBalanceOp {\n    UserBalanceOpKind kind;\n    IAsset asset;\n    uint256 amount;\n    address sender;\n    address payable recipient;\n  }\n\n  // There are four possible operations in `manageUserBalance`:\n  //\n  // - DEPOSIT_INTERNAL\n  // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n  // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n  // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n  // relevant for relayers).\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - WITHDRAW_INTERNAL\n  // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n  // it to the recipient as ETH.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_INTERNAL\n  // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_EXTERNAL\n  // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n  // relayers, as it lets them reuse a user's Vault allowance.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `ExternalBalanceTransfer` event.\n\n  enum UserBalanceOpKind {DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL}\n\n  /**\n   * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n  event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n  /**\n   * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n  event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n  // Pools\n  //\n  // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n  // functionality:\n  //\n  //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n  // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n  // which increase with the number of registered tokens.\n  //\n  //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n  // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n  // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n  // independent of the number of registered tokens.\n  //\n  //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n  // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n  enum PoolSpecialization {GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN}\n\n  /**\n   * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n  function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n  /**\n   * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n  event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n  /**\n   * @dev Returns a Pool's contract address and specialization setting.\n     */\n  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n  /**\n   * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n  function registerTokens(\n    bytes32 poolId,\n    IERC20[] calldata tokens,\n    address[] calldata assetManagers\n  ) external;\n\n  /**\n   * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n  event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n  /**\n   * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n  function deregisterTokens(bytes32 poolId, IERC20[] calldata tokens) external;\n\n  /**\n   * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n  event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n  /**\n   * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n  function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n  external\n  view\n  returns (\n    uint256 cash,\n    uint256 managed,\n    uint256 lastChangeBlock,\n    address assetManager\n  );\n\n  /**\n   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n  function getPoolTokens(bytes32 poolId)\n  external\n  view\n  returns (\n    IERC20[] memory tokens,\n    uint256[] memory balances,\n    uint256 lastChangeBlock\n  );\n\n  /**\n   * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     *\n     * See https://dev.balancer.fi/resources/joins-and-exits/pool-joins\n     */\n  function joinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    JoinPoolRequest calldata request\n  ) external payable;\n\n  enum JoinKind {INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT}\n\n  /// @notice WeightedPool ExitKinds\n  enum ExitKind {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT}\n  /// @notice Composable Stable V2 ExitKinds\n  enum ExitKindComposableStable {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT, EXACT_BPT_IN_FOR_ALL_TOKENS_OUT}\n\n\n  struct JoinPoolRequest {\n    IAsset[] assets;\n    uint256[] maxAmountsIn;\n    bytes userData;\n    bool fromInternalBalance;\n  }\n\n  /**\n   * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n  function exitPool(\n    bytes32 poolId,\n    address sender,\n    address payable recipient,\n    ExitPoolRequest calldata request\n  ) external;\n\n  struct ExitPoolRequest {\n    IAsset[] assets;\n    uint256[] minAmountsOut;\n    bytes userData;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n  event PoolBalanceChanged(\n    bytes32 indexed poolId,\n    address indexed liquidityProvider,\n    IERC20[] tokens,\n    int256[] deltas,\n    uint256[] protocolFeeAmounts\n  );\n\n  enum PoolBalanceChangeKind {JOIN, EXIT}\n\n  // Swaps\n  //\n  // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n  // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n  // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n  //\n  // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n  // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n  // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n  // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n  // individual swaps.\n  //\n  // There are two swap kinds:\n  //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n  // `onSwap` hook) the amount of tokens out (to send to the recipient).\n  //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n  // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n  //\n  // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n  // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n  // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n  // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n  // the final intended token.\n  //\n  // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n  // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n  // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n  // much less gas than they would otherwise.\n  //\n  // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n  // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n  // updating the Pool's internal accounting).\n  //\n  // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n  // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n  // minimum amount of tokens to receive (by passing a negative value) is specified.\n  //\n  // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n  // this point in time (e.g. if the transaction failed to be included in a block promptly).\n  //\n  // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n  // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n  // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n  // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n  //\n  // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n  enum SwapKind {GIVEN_IN, GIVEN_OUT}\n\n  /**\n   * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n  function swap(\n    SingleSwap calldata singleSwap,\n    FundManagement calldata funds,\n    uint256 limit,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  /**\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct SingleSwap {\n    bytes32 poolId;\n    SwapKind kind;\n    IAsset assetIn;\n    IAsset assetOut;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n  function batchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds,\n    int256[] calldata limits,\n    uint256 deadline\n  ) external payable returns (int256[] memory);\n\n  /**\n   * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct BatchSwapStep {\n    bytes32 poolId;\n    uint256 assetInIndex;\n    uint256 assetOutIndex;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n  event Swap(\n    bytes32 indexed poolId,\n    IERC20 indexed tokenIn,\n    IERC20 indexed tokenOut,\n    uint256 amountIn,\n    uint256 amountOut\n  );\n\n  /**\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n  struct FundManagement {\n    address sender;\n    bool fromInternalBalance;\n    address payable recipient;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n  function queryBatchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds\n  ) external returns (int256[] memory assetDeltas);\n\n  // BasePool.sol\n\n  /**\n* @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\n     *\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\n     * data, such as the protocol swap fee percentage and Pool balances.\n     *\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\n     * explicitly use eth_call instead of eth_sendTransaction.\n     */\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n\n}\n"
    },
    "contracts/integrations/balancer/IChildChainLiquidityGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\n/// @notice ChildChainLiquidityGaugeFactory, restored for 0x3b8cA519122CdD8efb272b0D3085453404B25bD0\n/// @dev See https://dev.balancer.fi/resources/vebal-and-gauges/gauges\ninterface IChildChainLiquidityGaugeFactory {\n  event RewardsOnlyGaugeCreated(\n    address indexed gauge,\n    address indexed pool,\n    address streamer\n  );\n\n  function create(address pool) external returns (address);\n\n  function getChildChainStreamerImplementation() external view returns (address);\n\n  function getGaugeImplementation() external view returns (address);\n\n  function getGaugePool(address gauge) external view returns (address);\n\n  function getGaugeStreamer(address gauge) external view returns (address);\n\n  function getPoolGauge(address pool) external view returns (address);\n\n  function getPoolStreamer(address pool) external view returns (address);\n\n  function isGaugeFromFactory(address gauge) external view returns (bool);\n\n  function isStreamerFromFactory(address streamer) external view returns (bool);\n}\n\n"
    },
    "contracts/integrations/balancer/IComposableStablePool.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IComposableStablePool {\n  function balanceOf(address account) external view returns (uint256);\n  function getActualSupply() external view returns (uint256);\n  function getPoolId() external view returns (bytes32);\n  function getBptIndex() external view returns (uint256);\n  function updateTokenRateCache(address token) external;\n}"
    },
    "contracts/integrations/balancer/ILinearPool.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface ILinearPool {\n  function getPoolId() external view returns (bytes32);\n\n  function getMainIndex() external view returns (uint);\n\n  function getMainToken() external view returns (address);\n\n  function getWrappedIndex() external view returns (uint);\n\n  function getWrappedToken() external view returns (address);\n\n  function getWrappedTokenRate() external view returns (uint);\n\n  function getRate() external view returns (uint);\n\n  function getBptIndex() external pure returns (uint);\n\n  function getVirtualSupply() external view returns (uint);\n\n  function getSwapFeePercentage() external view returns (uint);\n\n  function getTargets() external view returns (uint lowerTarget, uint upperTarget);\n\n  function totalSupply() external view returns (uint);\n\n  function getScalingFactors() external view returns (uint[] memory);\n}"
    },
    "contracts/integrations/tetu-v1/ITetuV1Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ITetuV1Controller {\n\n\n  function VERSION() external view returns (string memory);\n\n  function addHardWorker(address _worker) external;\n\n  function addStrategiesToSplitter(\n    address _splitter,\n    address[] memory _strategies\n  ) external;\n\n  function addStrategy(address _strategy) external;\n\n  function addVaultsAndStrategies(\n    address[] memory _vaults,\n    address[] memory _strategies\n  ) external;\n\n  function announcer() external view returns (address);\n\n  function bookkeeper() external view returns (address);\n\n  function changeWhiteListStatus(address[] memory _targets, bool status)\n  external;\n\n  function controllerTokenMove(\n    address _recipient,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function dao() external view returns (address);\n\n  function distributor() external view returns (address);\n\n  function doHardWork(address _vault) external;\n\n  function feeRewardForwarder() external view returns (address);\n\n  function fund() external view returns (address);\n\n  function fundDenominator() external view returns (uint256);\n\n  function fundKeeperTokenMove(\n    address _fund,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function fundNumerator() external view returns (uint256);\n\n  function fundToken() external view returns (address);\n\n  function governance() external view returns (address);\n\n  function hardWorkers(address) external view returns (bool);\n\n  function initialize() external;\n\n  function isAllowedUser(address _adr) external view returns (bool);\n\n  function isDao(address _adr) external view returns (bool);\n\n  function isHardWorker(address _adr) external view returns (bool);\n\n  function isPoorRewardConsumer(address _adr) external view returns (bool);\n\n  function isRewardDistributor(address _adr) external view returns (bool);\n\n  function isValidStrategy(address _strategy) external view returns (bool);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  function mintAndDistribute(uint256 totalAmount, bool mintAllAvailable)\n  external;\n\n  function mintHelper() external view returns (address);\n\n  function psDenominator() external view returns (uint256);\n\n  function psNumerator() external view returns (uint256);\n\n  function psVault() external view returns (address);\n\n  function pureRewardConsumers(address) external view returns (bool);\n\n  function rebalance(address _strategy) external;\n\n  function removeHardWorker(address _worker) external;\n\n  function rewardDistribution(address) external view returns (bool);\n\n  function rewardToken() external view returns (address);\n\n  function setAnnouncer(address _newValue) external;\n\n  function setBookkeeper(address newValue) external;\n\n  function setDao(address newValue) external;\n\n  function setDistributor(address _distributor) external;\n\n  function setFeeRewardForwarder(address _feeRewardForwarder) external;\n\n  function setFund(address _newValue) external;\n\n  function setFundNumeratorDenominator(uint256 numerator, uint256 denominator)\n  external;\n\n  function setFundToken(address _newValue) external;\n\n  function setGovernance(address newValue) external;\n\n  function setMintHelper(address _newValue) external;\n\n  function setPSNumeratorDenominator(uint256 numerator, uint256 denominator)\n  external;\n\n  function setPsVault(address _newValue) external;\n\n  function setPureRewardConsumers(address[] memory _targets, bool _flag)\n  external;\n\n  function setRewardDistribution(\n    address[] memory _newRewardDistribution,\n    bool _flag\n  ) external;\n\n  function setRewardToken(address _newValue) external;\n\n  function setVaultController(address _newValue) external;\n\n  function setVaultStrategyBatch(\n    address[] memory _vaults,\n    address[] memory _strategies\n  ) external;\n\n  function strategies(address) external view returns (bool);\n\n  function strategyTokenMove(\n    address _strategy,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function upgradeTetuProxyBatch(\n    address[] memory _contracts,\n    address[] memory _implementations\n  ) external;\n\n  function vaultController() external view returns (address);\n\n  function vaults(address) external view returns (bool);\n\n  function whiteList(address) external view returns (bool);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n  /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n  /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n  /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n  function uniswapV3MintCallback(\n    uint256 amount0Owed,\n    uint256 amount1Owed,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport './IUniswapV3PoolImmutables.sol';\nimport './IUniswapV3PoolState.sol';\nimport './IUniswapV3PoolDerivedState.sol';\nimport './IUniswapV3PoolActions.sol';\nimport './IUniswapV3PoolOwnerActions.sol';\nimport './IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\nIUniswapV3PoolImmutables,\nIUniswapV3PoolState,\nIUniswapV3PoolDerivedState,\nIUniswapV3PoolActions,\nIUniswapV3PoolOwnerActions,\nIUniswapV3PoolEvents\n{}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n  /// @notice Sets the initial price for the pool\n  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n  /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n  function initialize(uint160 sqrtPriceX96) external;\n\n  /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n  /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n  /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n  /// @param recipient The address for which the liquidity will be created\n  /// @param tickLower The lower tick of the position in which to add liquidity\n  /// @param tickUpper The upper tick of the position in which to add liquidity\n  /// @param amount The amount of liquidity to mint\n  /// @param data Any data that should be passed through to the callback\n  /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount,\n    bytes calldata data\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Collects tokens owed to a position\n  /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n  /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n  /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n  /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n  /// @param recipient The address which should receive the fees collected\n  /// @param tickLower The lower tick of the position for which to collect fees\n  /// @param tickUpper The upper tick of the position for which to collect fees\n  /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n  /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n  /// @return amount0 The amount of fees collected in token0\n  /// @return amount1 The amount of fees collected in token1\n  function collect(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n\n  /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n  /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n  /// @dev Fees must be collected separately via a call to #collect\n  /// @param tickLower The lower tick of the position for which to burn liquidity\n  /// @param tickUpper The upper tick of the position for which to burn liquidity\n  /// @param amount How much liquidity to burn\n  /// @return amount0 The amount of token0 sent to the recipient\n  /// @return amount1 The amount of token1 sent to the recipient\n  function burn(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Swap token0 for token1, or token1 for token0\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n  /// @param recipient The address to receive the output of the swap\n  /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n  /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n  /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n  /// @param data Any data to be passed through to the callback\n  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n  /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n  /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n  /// @param recipient The address which will receive the token0 and token1 amounts\n  /// @param amount0 The amount of token0 to send\n  /// @param amount1 The amount of token1 to send\n  /// @param data Any data to be passed through to the callback\n  function flash(\n    address recipient,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n\n  /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n  /// you must call it with secondsAgos = [3600, 0].\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n  /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n  /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n  /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n  /// timestamp\n  function observe(uint32[] calldata secondsAgos)\n  external\n  view\n  returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n  /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n  /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n  /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n  /// snapshot is taken and the second snapshot is taken.\n  /// @param tickLower The lower tick of the range\n  /// @param tickUpper The upper tick of the range\n  /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n  /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n  /// @return secondsInside The snapshot of seconds per liquidity for the range\n  function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n  external\n  view\n  returns (\n    int56 tickCumulativeInside,\n    uint160 secondsPerLiquidityInsideX128,\n    uint32 secondsInside\n  );\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n  /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n  /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n  /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n  event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n  /// @notice Emitted when liquidity is minted for a given position\n  /// @param sender The address that minted the liquidity\n  /// @param owner The owner of the position and recipient of any minted liquidity\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity minted to the position range\n  /// @param amount0 How much token0 was required for the minted liquidity\n  /// @param amount1 How much token1 was required for the minted liquidity\n  event Mint(\n    address sender,\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted when fees are collected by the owner of a position\n  /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n  /// @param owner The owner of the position for which fees are collected\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount0 The amount of token0 fees collected\n  /// @param amount1 The amount of token1 fees collected\n  event Collect(\n    address indexed owner,\n    address recipient,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount0,\n    uint128 amount1\n  );\n\n  /// @notice Emitted when a position's liquidity is removed\n  /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n  /// @param owner The owner of the position for which liquidity is removed\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity to remove\n  /// @param amount0 The amount of token0 withdrawn\n  /// @param amount1 The amount of token1 withdrawn\n  event Burn(\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted by the pool for any swaps between token0 and token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the output of the swap\n  /// @param amount0 The delta of the token0 balance of the pool\n  /// @param amount1 The delta of the token1 balance of the pool\n  /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n  /// @param liquidity The liquidity of the pool after the swap\n  /// @param tick The log base 1.0001 of price of the pool after the swap\n  event Swap(\n    address indexed sender,\n    address indexed recipient,\n    int256 amount0,\n    int256 amount1,\n    uint160 sqrtPriceX96,\n    uint128 liquidity,\n    int24 tick\n  );\n\n  /// @notice Emitted by the pool for any flashes of token0/token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the tokens from flash\n  /// @param amount0 The amount of token0 that was flashed\n  /// @param amount1 The amount of token1 that was flashed\n  /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n  /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n  event Flash(\n    address indexed sender,\n    address indexed recipient,\n    uint256 amount0,\n    uint256 amount1,\n    uint256 paid0,\n    uint256 paid1\n  );\n\n  /// @notice Emitted by the pool for increases to the number of observations that can be stored\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n  /// just before a mint/swap/burn.\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(\n    uint16 observationCardinalityNextOld,\n    uint16 observationCardinalityNextNew\n  );\n\n  /// @notice Emitted when the protocol fee is changed by the pool\n  /// @param feeProtocol0Old The previous value of the token0 protocol fee\n  /// @param feeProtocol1Old The previous value of the token1 protocol fee\n  /// @param feeProtocol0New The updated value of the token0 protocol fee\n  /// @param feeProtocol1New The updated value of the token1 protocol fee\n  event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n  /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n  /// @param sender The address that collects the protocol fees\n  /// @param recipient The address that receives the collected protocol fees\n  /// @param amount0 The amount of token0 protocol fees that is withdrawn\n  /// @param amount0 The amount of token1 protocol fees that is withdrawn\n  event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n  /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n  /// @return The contract address\n  function factory() external view returns (address);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (address);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (address);\n\n  /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n  /// @return The fee\n  function fee() external view returns (uint24);\n\n  /// @notice The pool tick spacing\n  /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n  /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n  /// This value is an int24 to avoid casting even though it is always positive.\n  /// @return The tick spacing\n  function tickSpacing() external view returns (int24);\n\n  /// @notice The maximum amount of position liquidity that can use any tick in the range\n  /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n  /// @notice Set the denominator of the protocol's % share of the fees\n  /// @param feeProtocol0 new protocol fee for token0 of the pool\n  /// @param feeProtocol1 new protocol fee for token1 of the pool\n  function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n  /// @notice Collect the protocol fee accrued to the pool\n  /// @param recipient The address to which collected protocol fees should be sent\n  /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n  /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n  /// @return amount0 The protocol fee collected in token0\n  /// @return amount1 The protocol fee collected in token1\n  function collectProtocol(\n    address recipient,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n  /// when accessed externally.\n  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n  /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n  /// boundary.\n  /// observationIndex The index of the last oracle observation that was written,\n  /// observationCardinality The current maximum number of observations stored in the pool,\n  /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n  /// feeProtocol The protocol fee for both tokens of the pool.\n  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n  /// unlocked Whether the pool is currently locked to reentrancy\n  function slot0()\n  external\n  view\n  returns (\n    uint160 sqrtPriceX96,\n    int24 tick,\n    uint16 observationIndex,\n    uint16 observationCardinality,\n    uint16 observationCardinalityNext,\n    uint8 feeProtocol,\n    bool unlocked\n  );\n\n  /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal0X128() external view returns (uint256);\n\n  /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal1X128() external view returns (uint256);\n\n  /// @notice The amounts of token0 and token1 that are owed to the protocol\n  /// @dev Protocol fees will never exceed uint128 max in either token\n  function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n  /// @notice The currently in range liquidity available to the pool\n  /// @dev This value has no relationship to the total liquidity across all ticks\n  function liquidity() external view returns (uint128);\n\n  /// @notice Look up information about a specific tick in the pool\n  /// @param tick The tick to look up\n  /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n  /// tick upper,\n  /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n  /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n  /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n  /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n  /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n  /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n  /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n  /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n  /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n  /// a specific position.\n  function ticks(int24 tick)\n  external\n  view\n  returns (\n    uint128 liquidityGross,\n    int128 liquidityNet,\n    uint256 feeGrowthOutside0X128,\n    uint256 feeGrowthOutside1X128,\n    int56 tickCumulativeOutside,\n    uint160 secondsPerLiquidityOutsideX128,\n    uint32 secondsOutside,\n    bool initialized\n  );\n\n  /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n  function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n  /// @notice Returns the information about a position by the position's key\n  /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n  /// @return _liquidity The amount of liquidity in the position,\n  /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n  /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n  /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n  /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n  function positions(bytes32 key)\n  external\n  view\n  returns (\n    uint128 _liquidity,\n    uint256 feeGrowthInside0LastX128,\n    uint256 feeGrowthInside1LastX128,\n    uint128 tokensOwed0,\n    uint128 tokensOwed1\n  );\n\n  /// @notice Returns data about a specific observation index\n  /// @param index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return blockTimestamp The timestamp of the observation,\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\n  function observations(uint256 index)\n  external\n  view\n  returns (\n    uint32 blockTimestamp,\n    int56 tickCumulative,\n    uint160 secondsPerLiquidityCumulativeX128,\n    bool initialized\n  );\n}\n"
    },
    "contracts/interfaces/IRebalancingStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IRebalancingStrategy {\n    function needRebalance() external view returns (bool);\n    function rebalance() external;\n}\n"
    },
    "contracts/libs/AppErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice List of all errors generated by the application\n///         Each error should have unique code TS-XXX and descriptive comment\nlibrary AppErrors {\n  /// @notice Provided address should be not zero\n  string public constant ZERO_ADDRESS = \"TS-1 zero address\";\n\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\n  string public constant UNISWAP_PAIR_NOT_FOUND = \"TS-2 pair not found\";\n\n  /// @notice Lengths not matched\n  string public constant WRONG_LENGTHS = \"TS-4 wrong lengths\";\n\n  /// @notice Unexpected zero balance\n  string public constant ZERO_BALANCE = \"TS-5 zero balance\";\n\n  string public constant ITEM_NOT_FOUND = \"TS-6 not found\";\n\n  string public constant NOT_ENOUGH_BALANCE = \"TS-7 not enough balance\";\n\n  /// @notice Price oracle returns zero price\n  string public constant ZERO_PRICE = \"TS-8 zero price\";\n\n  string public constant WRONG_VALUE = \"TS-9 wrong value\";\n\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\n  string public constant ZERO_AMOUNT_BORROWED = \"TS-10 zero borrowed amount\";\n\n  string public constant WITHDRAW_TOO_MUCH = \"TS-11 try to withdraw too much\";\n\n  string public constant UNKNOWN_ENTRY_KIND = \"TS-12 unknown entry kind\";\n\n  string public constant ONLY_TETU_CONVERTER = \"TS-13 only TetuConverter\";\n\n  string public constant WRONG_ASSET = \"TS-14 wrong asset\";\n\n  string public constant NO_LIQUIDATION_ROUTE = \"TS-15 No liquidation route\";\n\n  string public constant PRICE_IMPACT = \"TS-16 price impact\";\n\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\n  string public constant REPAY_MAKES_SWAP = \"TS-17 can not convert back\";\n\n  string public constant NO_INVESTMENTS = \"TS-18 no investments\";\n\n  string public constant INCORRECT_LENGTHS = \"TS-19 lengths\";\n\n  /// @notice We expect increasing of the balance, but it was decreased\n  string public constant BALANCE_DECREASE = \"TS-20 balance decrease\";\n}\n"
    },
    "contracts/libs/AppLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\n/// @notice Common internal utils\nlibrary AppLib {\n  using SafeERC20 for IERC20;\n\n  /// @notice Unchecked increment for for-cycles\n  function uncheckedInc(uint i) internal pure returns (uint) {\n    unchecked {\n      return i + 1;\n    }\n  }\n\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\n  /// @dev Should NOT be used for third-party pools\n  function approveIfNeeded(address token, uint amount, address spender) internal {\n    if (IERC20(token).allowance(address(this), spender) < amount) {\n      IERC20(token).safeApprove(spender, 0);\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\n      IERC20(token).safeApprove(spender, 2 ** 255);\n    }\n  }\n\n  function balance(address token) internal view returns (uint) {\n    return IERC20(token).balanceOf(address(this));\n  }\n}\n"
    },
    "contracts/libs/AppPlatforms.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nlibrary AppPlatforms {\r\n  string public constant UNIV3 = \"UniswapV3\";\r\n  string public constant BALANCER = \"Balancer\";\r\n}\r\n"
    },
    "contracts/libs/ConverterEntryKinds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\nlibrary ConverterEntryKinds {\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\n\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\n  ///         C2 should be used as collateral to make a borrow B.\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\n\n  /// @notice Borrow given amount using min possible collateral\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\n\n  /// @notice Decode entryData, extract first uint - entry kind\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\n    if (entryData_.length == 0) {\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\n    }\n    return abi.decode(entryData_, (uint));\n  }\n}\n"
    },
    "contracts/libs/TokenAmountsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AppErrors.sol\";\n\n/// @title Library for clearing / joining token addresses & amounts arrays\n/// @author bogdoslav\nlibrary TokenAmountsLib {\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \"1.0.1\";\n\n  function uncheckedInc(uint i) internal pure returns (uint) {\n    unchecked {\n      return i + 1;\n    }\n  }\n\n  function filterZeroAmounts(\n    address[] memory tokens,\n    uint[] memory amounts\n  ) internal pure returns (\n    address[] memory t,\n    uint[] memory a\n  ) {\n    require(tokens.length == amounts.length, AppErrors.INCORRECT_LENGTHS);\n    uint len2 = 0;\n    uint len = tokens.length;\n    for (uint i = 0; i < len; i++) {\n      if (amounts[i] != 0) len2++;\n    }\n\n    t = new address[](len2);\n    a = new uint[](len2);\n\n    uint j = 0;\n    for (uint i = 0; i < len; i++) {\n      uint amount = amounts[i];\n      if (amount != 0) {\n        t[j] = tokens[i];\n        a[j] = amount;\n        j++;\n      }\n    }\n  }\n\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\n  function combineArrays(\n    address[] memory tokens0,\n    uint[] memory amounts0,\n    address[] memory tokens1,\n    uint[] memory amounts1,\n    address[] memory tokens2,\n    uint[] memory amounts2\n  ) internal pure returns (\n    address[] memory allTokens,\n    uint[] memory allAmounts\n  ) {\n    uint[] memory lens = new uint[](3);\n    lens[0] = tokens0.length;\n    lens[1] = tokens1.length;\n    lens[2] = tokens2.length;\n\n    require(\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\n      AppErrors.INCORRECT_LENGTHS\n    );\n\n    uint maxLength = lens[0] + lens[1] + lens[2];\n    address[] memory tokensOut = new address[](maxLength);\n    uint[] memory amountsOut = new uint[](maxLength);\n    uint unitedLength;\n\n    for (uint step; step < 3; ++step) {\n      uint[] memory amounts = step == 0\n        ? amounts0\n        : (step == 1\n          ? amounts1\n          : amounts2);\n      address[] memory tokens = step == 0\n        ? tokens0\n        : (step == 1\n          ? tokens1\n          : tokens2);\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\n        uint amount1 = amounts[i1];\n        address token1 = tokens[i1];\n        bool united = false;\n\n        for (uint i = 0; i < unitedLength; i++) {\n          if (token1 == tokensOut[i]) {\n            amountsOut[i] += amount1;\n            united = true;\n            break;\n          }\n        }\n\n        if (!united) {\n          tokensOut[unitedLength] = token1;\n          amountsOut[unitedLength] = amount1;\n          unitedLength++;\n        }\n      }\n    }\n\n    // copy united tokens to result array\n    allTokens = new address[](unitedLength);\n    allAmounts = new uint[](unitedLength);\n    for (uint i; i < unitedLength; i++) {\n      allTokens[i] = tokensOut[i];\n      allAmounts[i] = amountsOut[i];\n    }\n\n  }\n}\n"
    },
    "contracts/strategies/balancer/BalancerBoostedDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"../DepositorBase.sol\";\nimport \"./BalancerLogicLib.sol\";\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../integrations/balancer/IBalancerHelper.sol\";\nimport \"../../integrations/balancer/IComposableStablePool.sol\";\nimport \"../../integrations/balancer/IChildChainLiquidityGaugeFactory.sol\";\nimport \"../../integrations/balancer/IBalancerGauge.sol\";\n\n\n/// @title Depositor for Composable Stable Pool with several embedded linear pools like \"Balancer Boosted Tetu USD\"\n/// @dev See https://app.balancer.fi/polygon#/polygon/pool/0xb3d658d5b95bf04e2932370dd1ff976fe18dd66a000000000000000000000ace\n///            bb-t-DAI (DAI + tDAI) + bb-t-USDC (USDC + tUSDC) + bb-t-USDT (USDT + tUSDT)\n///      See https://docs.balancer.fi/products/balancer-pools/boosted-pools for explanation of Boosted Pools on BalanceR.\n///      Terms\n///         bb-t-USD = pool bpt\n///         bb-t-DAI, bb-t-USDC, bb-t-USDT = underlying bpt\nabstract contract BalancerBoostedDepositor is DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///region Constants\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant BALANCER_BOOSTED_DEPOSITOR_VERSION = \"1.0.0\";\n\n  /// @dev https://dev.balancer.fi/references/contracts/deployment-addresses\n  IBVault internal constant BALANCER_VAULT = IBVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n  address internal constant BALANCER_HELPER = 0x239e55F427D44C3cc793f49bFB507ebe76638a2b;\n  /// @notice ChildChainLiquidityGaugeFactory allows to get gauge address by pool id\n  /// @dev see https://dev.balancer.fi/resources/vebal-and-gauges/gauges\n  address internal constant CHILD_CHAIN_LIQUIDITY_GAUGE_FACTORY = 0x3b8cA519122CdD8efb272b0D3085453404B25bD0;\n\n  /////////////////////////////////////////////////////////////////////\n  ///endregion Constants\n  /////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////\n  //region Variables\n  //                Keep names and ordering!\n  // Add only in the bottom and don't forget to decrease gap variable\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice i.e. for \"Balancer Boosted Aave USD\": 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b\n  /// @notice i.e. for \"Balancer Boosted Tetu USD\": 0xb3d658d5b95bf04e2932370dd1ff976fe18dd66a000000000000000000000ace\n  bytes32 public poolId;\n  IBalancerGauge public gauge;\n  /////////////////////////////////////////////////////////////////////\n  ///endregion Variables\n  /////////////////////////////////////////////////////////////////////\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  function __BalancerBoostedDepositor_init(address pool_) internal onlyInitializing {\n    poolId = IComposableStablePool(pool_).getPoolId();\n\n    gauge = IBalancerGauge(\n      IChildChainLiquidityGaugeFactory(\n        CHILD_CHAIN_LIQUIDITY_GAUGE_FACTORY\n      ).getPoolGauge(pool_)\n    );\n    // infinite approve of pool-BPT to the gauge todo is it safe for the external gauge?\n    IERC20(pool_).safeApprove(address(gauge), type(uint).max);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    return BalancerLogicLib.depositorPoolAssets(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Returns pool weights\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\n  /// @return totalWeight Total sum of all items of {weights}\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    return BalancerLogicLib.depositorPoolWeights(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of DAI, USDC, USDT\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \"Balancer Boosted Aave USD\" we return:\n  ///                     0: balance DAI + (balance amDAI recalculated to DAI)\n  ///                     1: balance USDC + (amUSDC recalculated to USDC)\n  ///                     2: balance USDT + (amUSDT recalculated to USDT)\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reservesOut) {\n    reservesOut = BalancerLogicLib.depositorPoolReserves(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() override internal virtual view returns (uint liquidityOut) {\n    liquidityOut = gauge.balanceOf(address(this))\n    + IComposableStablePool(BalancerLogicLib.getPoolAddress(poolId)).balanceOf(address(this));\n  }\n\n  //// @notice Total amount of liquidity (LP tokens) in the depositor\n  function _depositorTotalSupply() override internal view returns (uint totalSupplyOut) {\n    totalSupplyOut = IComposableStablePool(BalancerLogicLib.getPoolAddress(poolId)).getActualSupply();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  ///         i.e. for \"Balancer Boosted Aave USD\" we have DAI, USDC, USDT\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    bytes32 _poolId = poolId;\n    IComposableStablePool pool = IComposableStablePool(BalancerLogicLib.getPoolAddress(_poolId));\n\n    // join to the pool, receive pool-BPTs\n    (amountsConsumedOut, liquidityOut) = BalancerLogicLib.depositorEnter(BALANCER_VAULT, _poolId, amountsDesired_);\n\n    // stake all available pool-BPTs to the gauge\n    // we can have pool-BPTs on depositor's balance after previous exit, stake them too\n    gauge.deposit(pool.balanceOf(address(this)));\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then should make full exit\n  /// @param liquidityAmount_ Max amount to withdraw in bpt. Actual withdrawn amount will be less,\n  ///                         so it worth to add a gap to this amount, i.e. 1%\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function _depositorExit(uint liquidityAmount_) override internal virtual returns (\n    uint[] memory amountsOut\n  ) {\n    bytes32 _poolId = poolId;\n    IBalancerGauge __gauge = gauge;\n    IComposableStablePool pool = IComposableStablePool(BalancerLogicLib.getPoolAddress(_poolId));\n\n    // we need to withdraw pool-BPTs from the _gauge\n    // at first, let's try to use exist pool-BPTs on the depositor balance, probably it's enough\n    // we can have pool-BPTs on depositor's balance after previous exit, see BalancerLogicLib.depositorExit\n    uint depositorBalance = pool.balanceOf(address(this));\n    uint gaugeBalance = __gauge.balanceOf(address(this));\n\n    uint liquidityToWithdraw = liquidityAmount_ > depositorBalance\n    ? liquidityAmount_ - depositorBalance\n    : 0;\n\n    // calculate how much pool-BPTs we should withdraw from the gauge\n    if (liquidityToWithdraw > 0) {\n      if (liquidityToWithdraw > gaugeBalance) {\n        liquidityToWithdraw = gaugeBalance;\n      }\n    }\n\n    // un-stake required pool-BPTs from the gauge\n    if (liquidityToWithdraw > 0) {\n      __gauge.withdraw(liquidityToWithdraw);\n    }\n\n    // withdraw the liquidity from the pool\n    amountsOut = (liquidityAmount_ >= depositorBalance + gaugeBalance)\n    ? BalancerLogicLib.depositorExitFull(BALANCER_VAULT, _poolId)\n    : BalancerLogicLib.depositorExit(BALANCER_VAULT, _poolId, liquidityToWithdraw);\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then full exit is required\n  ///      we emulate is at normal exit + conversion of remain BPT directly to the main asset\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function _depositorQuoteExit(uint liquidityAmount_) override internal virtual returns (uint[] memory amountsOut) {\n    uint liquidity = _depositorLiquidity();\n    if (liquidity == 0) {\n      // there is no liquidity, output is zero\n      return new uint[](_depositorPoolAssets().length);\n    } else {\n      // BalancerLogicLib.depositorQuoteExit takes into account the cost of unused BPT\n      // so we don't need a special logic here for the full exit\n      return BalancerLogicLib.depositorQuoteExit(\n        BALANCER_VAULT,\n        IBalancerHelper(BALANCER_HELPER),\n        poolId,\n        liquidityAmount_\n      );\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Claim all possible rewards.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut,\n    uint[] memory depositorBalancesBefore\n  ) {\n    return BalancerLogicLib.depositorClaimRewards(gauge, _depositorPoolAssets(), rewardTokens());\n  }\n\n  /// @dev Returns reward token addresses array.\n  function rewardTokens() public view returns (address[] memory tokens) {\n    uint total;\n    for (; total < 8; ++total) {\n      if (gauge.reward_tokens(total) == address(0)) {\n        break;\n      }\n    }\n    tokens = new address[](total);\n    for (uint i; i < total; ++i) {\n      tokens[i] = gauge.reward_tokens(i);\n    }\n  }\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[50-2] private __gap; // 50 - count of variables\n}\n"
    },
    "contracts/strategies/balancer/BalancerBoostedStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./BalancerBoostedDepositor.sol\";\nimport \"../../libs/AppPlatforms.sol\";\n\n/// @title Delta-neutral converter strategy for Balancer boosted pools\n/// @author a17, dvpublic\ncontract BalancerBoostedStrategy is ConverterStrategyBase, BalancerBoostedDepositor {\n  string public constant override NAME = \"Balancer Boosted Strategy\";\n  string public constant override PLATFORM = AppPlatforms.BALANCER;\n  string public constant override STRATEGY_VERSION = \"1.0.1\";\n\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address pool_\n  ) external initializer {\n    __BalancerBoostedDepositor_init(pool_);\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n  }\n\n  function _handleRewards() internal virtual override returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    uint assetBalanceBefore = AppLib.balance(asset);\n    (address[] memory rewardTokens, uint[] memory amounts) = _claim();\n    _rewardsLiquidation(rewardTokens, amounts);\n    assetBalanceAfterClaim = AppLib.balance(asset);\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(assetBalanceBefore, assetBalanceAfterClaim, earned, lost);\n    return (earned, lost, assetBalanceAfterClaim);\n  }\n}\n"
    },
    "contracts/strategies/balancer/BalancerLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\nimport \"../../libs/AppErrors.sol\";\nimport \"../../libs/AppLib.sol\";\nimport \"../../libs/TokenAmountsLib.sol\";\nimport \"../../integrations/balancer/IComposableStablePool.sol\";\nimport \"../../integrations/balancer/ILinearPool.sol\";\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../integrations/balancer/IBalancerHelper.sol\";\nimport \"../../integrations/balancer/IBalancerGauge.sol\";\n\n/// @notice Functions of BalancerBoostedDepositor\n/// @dev Many of functions are declared as external to reduce contract size\nlibrary BalancerLogicLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Types\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev local vars in getAmountsToDeposit to avoid stack too deep\n  struct LocalGetAmountsToDeposit {\n    /// @notice Decimals of {tokens_}, 0 for BPT\n    uint[] decimals;\n    /// @notice Length of {tokens_} array\n    uint len;\n    /// @notice amountBPT / underlyingAmount, decimals 18, 0 for BPT\n    uint[] rates;\n  }\n\n  /// @notice Local variables required inside _depositorEnter/Exit/QuoteExit, avoid stack too deep\n  struct DepositorLocal {\n    uint bptIndex;\n    uint len;\n    IERC20[] tokens;\n    uint[] balances;\n  }\n\n  /// @notice Used in linear pool quote swap math logic\n  struct LinearPoolParams {\n    uint fee;\n    uint lowerTarget;\n    uint upperTarget;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Asset related utils\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate amounts of {tokens} to be deposited to POOL_ID in proportions according to the {balances}\n  /// @param amountsDesired_ Desired amounts of tokens. The order of the tokens is exactly the same as in {tokens}.\n  ///                        But the array has length 3, not 4, because there is no amount for bb-am-USD here.\n  /// @param tokens_ All bb-am-* tokens (including bb-am-USD) received through getPoolTokens\n  ///                           The order of the tokens is exactly the same as in getPoolTokens-results\n  /// @param balances_ Balances of bb-am-* pools in terms of bb-am-USD tokens (received through getPoolTokens)\n  ///                           The order of the tokens is exactly the same as in {tokens}\n  /// @param totalUnderlying_ Total amounts of underlying assets (DAI, USDC, etc) in embedded linear pools.\n  ///                         The array should have same order of tokens as {tokens_}, value for BPT token is not used\n  /// @param indexBpt_ Index of BPT token inside {balances_}, {tokens_} and {totalUnderlying_} arrays\n  /// @return amountsOut Desired amounts in proper proportions for depositing.\n  ///         The order of the tokens is exactly the same as in results of getPoolTokens, 0 for BPT\n  ///         i.e. DAI, BB-AM-USD, USDC, USDT\n  function getAmountsToDeposit(\n    uint[] memory amountsDesired_,\n    IERC20[] memory tokens_,\n    uint[] memory balances_,\n    uint[] memory totalUnderlying_,\n    uint indexBpt_\n  ) internal view returns (\n    uint[] memory amountsOut\n  ) {\n    LocalGetAmountsToDeposit memory p;\n    // check not zero balances, cache index of bbAmUSD, save 10**decimals to array\n    p.len = tokens_.length;\n    require(p.len == balances_.length, AppErrors.WRONG_LENGTHS);\n    require(p.len == amountsDesired_.length || p.len - 1 == amountsDesired_.length, AppErrors.WRONG_LENGTHS);\n\n    p.decimals = new uint[](p.len);\n    p.rates = new uint[](p.len);\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexBpt_) {\n        require(balances_[i] != 0, AppErrors.ZERO_BALANCE);\n        p.decimals[i] = 10 ** IERC20Metadata(address(tokens_[i])).decimals();\n\n        // Let's calculate a rate: amountBPT / underlyingAmount, decimals 18\n        p.rates[i] = balances_[i] * 1e18 / totalUnderlying_[i];\n      }\n    }\n\n    amountsOut = new uint[](p.len - 1);\n\n    // The balances set proportions of underlying-bpt, i.e. bb-am-DAI : bb-am-USDC : bb-am-USDT\n    // Our task is find amounts of DAI : USDC : USDT that won't change that proportions after deposit.\n    // We have arbitrary desired amounts, i.e. DAI = X, USDC = Y, USDT = Z\n    // For each token: assume that it can be used in full.\n    // If so, what amounts will have other tokens in this case according to the given proportions?\n    // i.e. DAI = X = 100.0 => USDC = 200.0, USDT = 400.0. We need: Y >= 200, Z >= 400\n    // or   USDC = Y = 100.0 => DAI = 50.0, USDT = 200.0. We need: X >= 50, Z >= 200\n    // If any amount is less then expected, the token cannot be used in full.\n    // A token with min amount can be used in full, let's try to find its index.\n    // [0 : len - 1]\n    uint i3;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (indexBpt_ == i) continue;\n\n      uint amountInBpt18 = amountsDesired_[i3] * p.rates[i];\n\n      // [0 : len]\n      uint j;\n      // [0 : len - 1]\n      uint j3;\n      for (; j < p.len; j = AppLib.uncheckedInc(j)) {\n        if (indexBpt_ == j) continue;\n\n        // alpha = balancesDAI / balancesUSDC * decimalsDAI / decimalsUSDC\n        // amountDAI = amountUSDC * alpha * rateUSDC / rateDAI\n        amountsOut[j3] = amountInBpt18 * balances_[j] / p.rates[j] * p.decimals[j] / balances_[i] / p.decimals[i];\n        if (amountsOut[j3] > amountsDesired_[j3]) break;\n        j3++;\n      }\n\n      if (j == p.len) break;\n      i3++;\n    }\n  }\n\n\n  /// @notice Calculate total amount of underlying asset for each token except BPT\n  /// @dev Amount is calculated as MainTokenAmount + WrappedTokenAmount * WrappedTokenRate, see AaveLinearPool src\n  function getTotalAssetAmounts(IBVault vault_, IERC20[] memory tokens_, uint indexBpt_) internal view returns (\n    uint[] memory amountsOut\n  ) {\n    uint len = tokens_.length;\n    amountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexBpt_) {\n        ILinearPool linearPool = ILinearPool(address(tokens_[i]));\n        (, uint[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\n\n        amountsOut[i] =\n        balances[linearPool.getMainIndex()]\n        + balances[linearPool.getWrappedIndex()] * linearPool.getWrappedTokenRate() / 1e18;\n      }\n    }\n  }\n\n  /// @notice Split {liquidityAmount_} by assets according to proportions of their total balances\n  /// @param liquidityAmount_ Amount to withdraw in bpt\n  /// @param balances_ Balances received from getPoolTokens\n  /// @param bptIndex_ Index of pool-pbt inside {balances_}\n  /// @return bptAmountsOut Amounts of underlying-BPT. The array doesn't include an amount for pool-bpt\n  ///         Total amount of {bptAmountsOut}-items is equal to {liquidityAmount_}\n  function getBtpAmountsOut(\n    uint liquidityAmount_,\n    uint[] memory balances_,\n    uint bptIndex_\n  ) internal pure returns (uint[] memory bptAmountsOut) {\n    // we assume here, that len >= 2\n    // we don't check it because StableMath.sol in balancer has _MIN_TOKENS = 2;\n    uint len = balances_.length;\n    bptAmountsOut = new uint[](len - 1);\n\n    // compute total balance, skip pool-bpt\n    uint totalBalances;\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex_) continue;\n      totalBalances += balances_[i];\n      // temporary save incomplete amounts to bptAmountsOut\n      bptAmountsOut[k] = liquidityAmount_ * balances_[i];\n      ++k;\n    }\n\n    // finalize computation of bptAmountsOut using known totalBalances\n    uint total;\n    for (k = 0; k < len - 1; k = AppLib.uncheckedInc(k)) {\n      if (k == len - 2) {\n        // leftovers => last item\n        bptAmountsOut[k] = total > liquidityAmount_\n        ? 0\n        : liquidityAmount_ - total;\n      } else {\n        bptAmountsOut[k] /= totalBalances;\n        total += bptAmountsOut[k];\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Depositor view logic\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of USDT, USDC, DAI\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \"Balancer Boosted Tetu USD\" we return:\n  ///                     0: balance USDT + (tUSDT recalculated to USDT)\n  ///                     1: balance USDC + (tUSDC recalculated to USDC)\n  ///                     2: balance DAI + (balance tDAI recalculated to DAI)\n  function depositorPoolReserves(IBVault vault_, bytes32 poolId_) external view returns (uint[] memory reservesOut) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    uint bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    uint len = tokens.length;\n    // exclude pool-BPT\n    reservesOut = new uint[](len - 1);\n\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex) continue;\n      ILinearPool linearPool = ILinearPool(address(tokens[i]));\n\n      // Each bb-t-* returns (main-token, wrapped-token, bb-t-itself), the order of tokens is arbitrary\n      // i.e. (DAI + tDAI + bb-t-DAI) or (bb-t-USDC, tUSDC, USDC)\n\n      // get balances of all tokens of bb-am-XXX token, i.e. balances of (DAI, amDAI, bb-am-DAI)\n      (, uint[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\n      // DAI\n      uint mainIndex = linearPool.getMainIndex();\n      // tDAI\n      uint wrappedIndex = linearPool.getWrappedIndex();\n\n      reservesOut[k] = balances[mainIndex] + balances[wrappedIndex] * linearPool.getWrappedTokenRate() / 1e18;\n      ++k;\n    }\n  }\n\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\n  function depositorPoolAssets(IBVault vault_, bytes32 poolId_) external view returns (address[] memory poolAssets) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    uint bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    uint len = tokens.length;\n\n    poolAssets = new address[](len - 1);\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex) continue;\n\n      poolAssets[k] = ILinearPool(address(tokens[i])).getMainToken();\n      ++k;\n    }\n  }\n\n  /// @notice Returns pool weights\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\n  /// @return totalWeight Total sum of all items of {weights}\n  function depositorPoolWeights(IBVault vault_, bytes32 poolId_) external view returns (\n    uint[] memory weights,\n    uint totalWeight\n  ) {\n    (IERC20[] memory tokens,uint[] memory balances,) = vault_.getPoolTokens(poolId_);\n    uint len = tokens.length;\n    uint bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    weights = new uint[](len - 1);\n    uint j;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i != bptIndex) {\n        totalWeight += balances[i];\n        weights[j] = balances[i];\n        j = AppLib.uncheckedInc(j);\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Depositor enter, exit logic\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  ///         i.e. for \"Balancer Boosted Aave USD\" we have DAI, USDC, USDT\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\n  function depositorEnter(IBVault vault_, bytes32 poolId_, uint[] memory amountsDesired_) external returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    DepositorLocal memory p;\n\n    // The implementation below assumes, that getPoolTokens returns the assets in following order:\n    //    bb-am-dai, bb-am-usd, bb-am-usdc, bb-am-usdt\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n\n    // temporary save current liquidity\n    liquidityOut = IComposableStablePool(address(p.tokens[p.bptIndex])).balanceOf(address(this));\n\n    // Original amounts can have any values.\n    // But we need amounts in such proportions that won't move the current balances\n    {\n      uint[] memory underlying = BalancerLogicLib.getTotalAssetAmounts(vault_, p.tokens, p.bptIndex);\n      amountsConsumedOut = BalancerLogicLib.getAmountsToDeposit(amountsDesired_, p.tokens, p.balances, underlying, p.bptIndex);\n    }\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n      sender : address(this),\n      fromInternalBalance : false,\n      recipient : payable(address(this)),\n      toInternalBalance : false\n    });\n\n    // swap all tokens XX => bb-am-XX\n    // we need two arrays with same amounts: amountsToDeposit (with 0 for BB-AM-USD) and userDataAmounts (no BB-AM-USD)\n    uint[] memory amountsToDeposit = new uint[](p.len);\n    // no bpt\n    uint[] memory userDataAmounts = new uint[](p.len - 1);\n    uint k;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      amountsToDeposit[i] = BalancerLogicLib.swap(\n        vault_,\n        ILinearPool(address(p.tokens[i])).getPoolId(),\n        ILinearPool(address(p.tokens[i])).getMainToken(),\n        address(p.tokens[i]),\n        amountsConsumedOut[k],\n        funds\n      );\n      userDataAmounts[k] = amountsToDeposit[i];\n      AppLib.approveIfNeeded(address(p.tokens[i]), amountsToDeposit[i], address(vault_));\n      ++k;\n    }\n\n    // add liquidity to balancer\n    vault_.joinPool(\n      poolId_,\n      address(this),\n      address(this),\n      IBVault.JoinPoolRequest({\n        assets : asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\n        maxAmountsIn : amountsToDeposit,\n        userData : abi.encode(IBVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, userDataAmounts, 0),\n        fromInternalBalance : false\n      })\n    );\n\n    uint liquidityAfter = IERC20(address(p.tokens[p.bptIndex])).balanceOf(address(this));\n\n    liquidityOut = liquidityAfter > liquidityOut\n    ? liquidityAfter - liquidityOut\n    : 0;\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @param liquidityAmount_ Amount to withdraw in bpt\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorExit(IBVault vault_, bytes32 poolId_, uint liquidityAmount_) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n\n    require(liquidityAmount_ <= p.tokens[p.bptIndex].balanceOf(address(this)), AppErrors.NOT_ENOUGH_BALANCE);\n\n    // BalancerR can spend a bit less amount of liquidity than {liquidityAmount_}\n    // i.e. we if liquidityAmount_ = 2875841, we can have leftovers = 494 after exit\n    vault_.exitPool(\n      poolId_,\n      address(this),\n      payable(address(this)),\n      IBVault.ExitPoolRequest({\n        assets : asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\n        minAmountsOut : new uint[](p.len), // no limits\n        userData : abi.encode(IBVault.ExitKindComposableStable.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT, liquidityAmount_),\n        toInternalBalance : false\n      })\n    );\n\n    // now we have amBbXXX tokens; swap them to XXX assets\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n    sender : address(this),\n    fromInternalBalance : false,\n    recipient : payable(address(this)),\n    toInternalBalance : false\n    });\n\n    amountsOut = new uint[](p.len - 1);\n    uint k;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      uint amountIn = p.tokens[i].balanceOf(address(this));\n      if (amountIn != 0) {\n        amountsOut[k] = swap(\n          vault_,\n          ILinearPool(address(p.tokens[i])).getPoolId(),\n          address(p.tokens[i]),\n          ILinearPool(address(p.tokens[i])).getMainToken(),\n          amountIn,\n          funds\n        );\n      }\n      ++k;\n    }\n  }\n\n  /// @notice Withdraw all available amount of LP-tokens from the pool\n  ///         BalanceR doesn't allow to withdraw exact amount, so it's allowed to leave dust amount on the balance\n  /// @dev We make at most N attempts to withdraw (not more, each attempt takes a lot of gas).\n  ///      Each attempt reduces available balance at ~1e4 times.\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///                    The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorExitFull(IBVault vault_, bytes32 poolId_) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n    amountsOut = new uint[](p.len - 1);\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n      sender : address(this),\n      fromInternalBalance : false,\n      recipient : payable(address(this)),\n      toInternalBalance : false\n    });\n\n    uint liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\n    if (liquidityAmount > 0) {\n      uint liquidityThreshold = 10 ** IERC20Metadata(address(p.tokens[p.bptIndex])).decimals() / 100;\n\n      // we can make at most N attempts to withdraw amounts from the balanceR pool\n      for (uint i = 0; i < 2; ++i) {\n        vault_.exitPool(\n          poolId_,\n          address(this),\n          payable(address(this)),\n          IBVault.ExitPoolRequest({\n            assets : asIAsset(p.tokens),\n            minAmountsOut : new uint[](p.len), // no limits\n            userData : abi.encode(IBVault.ExitKindComposableStable.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT, liquidityAmount),\n            toInternalBalance : false\n          })\n        );\n        liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\n        if (liquidityAmount < liquidityThreshold || i == 1) {\n          break;\n        }\n        (, p.balances,) = vault_.getPoolTokens(poolId_);\n      }\n\n      // now we have amBbXXX tokens; swap them to XXX assets\n      uint k;\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n        if (i == p.bptIndex) continue;\n\n        uint amountIn = p.tokens[i].balanceOf(address(this));\n        if (amountIn != 0) {\n          amountsOut[k] = swap(\n            vault_,\n            ILinearPool(address(p.tokens[i])).getPoolId(),\n            address(p.tokens[i]),\n            ILinearPool(address(p.tokens[i])).getMainToken(),\n            amountIn,\n            funds\n          );\n        }\n        ++k;\n      }\n    }\n\n    uint depositorBalance = p.tokens[p.bptIndex].balanceOf(address(this));\n    if (depositorBalance > 0) {\n      uint k = 0;\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n        if (i == p.bptIndex) continue;\n\n        // we assume here, that the depositorBalance is small\n        // so we can directly swap it to any single asset without changing of pool resources proportions\n        amountsOut[k] += _convertSmallBptRemainder(vault_, poolId_, p, funds, depositorBalance, i);\n        break;\n      }\n    }\n\n    return amountsOut;\n  }\n\n  /// @notice convert remained SMALL amount of bpt => am-bpt => main token of the am-bpt\n  /// @return amountOut Received amount of am-bpt's main token\n  function _convertSmallBptRemainder(\n    IBVault vault_,\n    bytes32 poolId_,\n    DepositorLocal memory p,\n    IBVault.FundManagement memory funds,\n    uint bptAmountIn_,\n    uint indexTargetAmBpt_\n  ) internal returns (uint amountOut) {\n    uint amountAmBpt = BalancerLogicLib.swap(\n      vault_,\n      poolId_,\n      address(p.tokens[p.bptIndex]),\n      address(p.tokens[indexTargetAmBpt_]),\n      bptAmountIn_,\n      funds\n    );\n    amountOut = swap(\n      vault_,\n      ILinearPool(address(p.tokens[indexTargetAmBpt_])).getPoolId(),\n      address(p.tokens[indexTargetAmBpt_]),\n      ILinearPool(address(p.tokens[indexTargetAmBpt_])).getMainToken(),\n      amountAmBpt,\n      funds\n    );\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorQuoteExit(\n    IBVault vault_,\n    IBalancerHelper helper_,\n    bytes32 poolId_,\n    uint liquidityAmount_\n  ) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n\n    (, uint[] memory amountsBpt) = helper_.queryExit(\n      poolId_,\n      address(this),\n      payable(address(this)),\n      IBVault.ExitPoolRequest({\n        assets : asIAsset(p.tokens),\n        minAmountsOut : new uint[](p.len), // no limits\n        userData : abi.encode(\n          IBVault.ExitKindComposableStable.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT,\n          liquidityAmount_\n        ),\n        toInternalBalance : false\n      })\n    );\n\n    uint k;\n    amountsOut = new uint[](p.len - 1);\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      ILinearPool linearPool = ILinearPool(address(p.tokens[i]));\n      amountsOut[k] = _calcLinearMainOutPerBptIn(vault_, linearPool, amountsBpt[i]);\n      ++k;\n    }\n  }\n\n  /// @notice Swap given {amountIn_} of {assetIn_} to {assetOut_} using the given BalanceR pool\n  function swap(\n    IBVault vault_,\n    bytes32 poolId_,\n    address assetIn_,\n    address assetOut_,\n    uint amountIn_,\n    IBVault.FundManagement memory funds_\n  ) internal returns (uint amountOut) {\n    uint balanceBefore = IERC20(assetOut_).balanceOf(address(this));\n\n    IERC20(assetIn_).approve(address(vault_), amountIn_);\n    vault_.swap(\n      IBVault.SingleSwap({\n    poolId : poolId_,\n    kind : IBVault.SwapKind.GIVEN_IN,\n    assetIn : IAsset(assetIn_),\n    assetOut : IAsset(assetOut_),\n    amount : amountIn_,\n    userData : bytes(\"\")\n    }),\n      funds_,\n      1,\n      block.timestamp\n    );\n\n    // we assume here, that the balance cannot be decreased\n    amountOut = IERC20(assetOut_).balanceOf(address(this)) - balanceBefore;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Rewards\n  /////////////////////////////////////////////////////////////////////\n\n  function depositorClaimRewards(IBalancerGauge gauge_, address[] memory tokens_, address[] memory rewardTokens_) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut,\n    uint[] memory depositorBalancesBefore\n  ) {\n    uint tokensLen = tokens_.length;\n    uint rewardTokensLen = rewardTokens_.length;\n\n    tokensOut = new address[](rewardTokensLen);\n    amountsOut = new uint[](rewardTokensLen);\n    depositorBalancesBefore = new uint[](tokensLen);\n\n    for (uint i; i < tokensLen; i = AppLib.uncheckedInc(i)) {\n      depositorBalancesBefore[i] = IERC20(tokens_[i]).balanceOf(address(this));\n    }\n\n    for (uint i; i < rewardTokensLen; i = AppLib.uncheckedInc(i)) {\n      tokensOut[i] = rewardTokens_[i];\n\n      // temporary store current reward balance\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this));\n    }\n\n    gauge_.claim_rewards();\n\n    for (uint i; i < rewardTokensLen; i = AppLib.uncheckedInc(i)) {\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this)) - amountsOut[i];\n    }\n\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Utils\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Returns the address of a Pool's contract.\n  ///      Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\n  function getPoolAddress(bytes32 id) internal pure returns (address) {\n    // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\n    // since the logical shift already sets the upper bits to zero.\n    return address(uint160(uint(id) >> (12 * 8)));\n  }\n\n  /// @dev see balancer-labs, ERC20Helpers.sol\n  function asIAsset(IERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      assets := tokens\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Linear pool quote swap math logic\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev This logic is needed for hardworks in conditions of lack of funds in linear pools.\n  ///      The lack of funds in linear pools is a typical situation caused by pool rebalancing after deposits from the strategy.\n  ///      Main tokens are leaving linear pools to mint wrapped tokens.\n  function _calcLinearMainOutPerBptIn(IBVault vault, ILinearPool pool, uint amount) internal view returns (uint) {\n    (uint lowerTarget, uint upperTarget) = pool.getTargets();\n    LinearPoolParams memory params = LinearPoolParams(pool.getSwapFeePercentage(), lowerTarget, upperTarget);\n    (,uint[] memory balances,) = vault.getPoolTokens(pool.getPoolId());\n    uint[] memory scalingFactors = pool.getScalingFactors();\n    _upscaleArray(balances, scalingFactors);\n    amount *= scalingFactors[0] / 1e18;\n    uint mainIndex = pool.getMainIndex();\n    uint mainBalance = balances[mainIndex];\n    uint bptSupply = pool.totalSupply() - balances[0];\n    uint previousNominalMain = _toNominal(mainBalance, params);\n    uint invariant = previousNominalMain + balances[pool.getWrappedIndex()];\n    uint deltaNominalMain = invariant * amount / bptSupply;\n    uint afterNominalMain = previousNominalMain > deltaNominalMain ? previousNominalMain - deltaNominalMain : 0;\n    uint newMainBalance = _fromNominal(afterNominalMain, params);\n    return (mainBalance - newMainBalance) * 1e18 / scalingFactors[mainIndex];\n  }\n\n  function _toNominal(uint real, LinearPoolParams memory params) internal pure returns (uint) {\n    if (real < params.lowerTarget) {\n      uint fees = (params.lowerTarget - real) * params.fee / 1e18;\n      return real - fees;\n    } else if (real <= params.upperTarget) {\n      return real;\n    } else {\n      uint fees = (real - params.upperTarget) * params.fee / 1e18;\n      return real - fees;\n    }\n  }\n\n  function _fromNominal(uint nominal, LinearPoolParams memory params) internal pure returns (uint) {\n    if (nominal < params.lowerTarget) {\n      return (nominal + (params.fee * params.lowerTarget / 1e18)) * 1e18 / (1e18 + params.fee);\n    } else if (nominal <= params.upperTarget) {\n      return nominal;\n    } else {\n      return (nominal - (params.fee * params.upperTarget / 1e18)) * 1e18/ (1e18 - params.fee);\n    }\n  }\n\n  function _upscaleArray(uint[] memory amounts, uint[] memory scalingFactors) internal pure {\n    uint length = amounts.length;\n    for (uint i; i < length; ++i) {\n      amounts[i] = amounts[i] * scalingFactors[i] / 1e18;\n    }\n  }\n}\n"
    },
    "contracts/strategies/ConverterStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\";\nimport \"./ConverterStrategyBaseLib.sol\";\nimport \"./ConverterStrategyBaseLib2.sol\";\nimport \"./DepositorBase.sol\";\n\n/////////////////////////////////////////////////////////////////////\n///                        TERMS\n///  Main asset == underlying: the asset deposited to the vault by users\n///  Secondary assets: all assets deposited to the internal pool except the main asset\n/////////////////////////////////////////////////////////////////////\n\n/// @title Abstract contract for base Converter strategy functionality\n/// @notice All depositor assets must be correlated (ie USDC/USDT/DAI)\n/// @author bogdoslav, dvpublic\nabstract contract ConverterStrategyBase is ITetuConverterCallback, DepositorBase, StrategyBaseV2 {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  //region DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n\n  struct WithdrawUniversalLocal {\n    bool all;\n    uint investedAssetsBeforeWithdraw;\n    uint[] reservesBeforeWithdraw;\n    uint totalSupplyBeforeWithdraw;\n    uint depositorLiquidity;\n    uint liquidityAmountToWithdraw;\n    uint assetPrice;\n    uint[] amountsToConvert;\n    uint expectedTotalMainAssetAmount;\n    uint[] expectedMainAssetAmounts;\n    uint investedAssetsAfterWithdraw;\n    uint balanceAfterWithdraw;\n    address[] tokens;\n    address asset;\n  }\n  //endregion DATA TYPES\n\n  /////////////////////////////////////////////////////////////////////\n  //region CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant CONVERTER_STRATEGY_BASE_VERSION = \"1.1.7\";\n\n  /// @notice 1% gap to cover possible liquidation inefficiency\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\n  uint internal constant GAP_CONVERSION = 1_000;\n  uint internal constant DENOMINATOR = 100_000;\n  //endregion CONSTANTS\n\n  /////////////////////////////////////////////////////////////////////\n  //region VARIABLES\n  //                Keep names and ordering!\n  // Add only in the bottom and don't forget to decrease gap variable\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Amount of underlying assets invested to the pool.\n  uint internal _investedAssets;\n\n  /// @dev Linked Tetu Converter\n  ITetuConverter public converter;\n\n  /// @notice Minimum token amounts that can be liquidated\n  mapping(address => uint) public liquidationThresholds;\n\n  /// @notice Percent of asset amount that can be not invested, it's allowed to just keep it on balance\n  ///         decimals = {DENOMINATOR}\n  /// @dev We need this threshold to avoid numerous conversions of small amounts\n  uint public reinvestThresholdPercent;\n  //endregion VARIABLES\n\n  /////////////////////////////////////////////////////////////////////\n  //region Events\n  /////////////////////////////////////////////////////////////////////\n  event LiquidationThresholdChanged(address token, uint amount);\n  event ReinvestThresholdPercentChanged(uint amount);\n  event OnDepositorEnter(uint[] amounts, uint[] consumedAmounts);\n  event OnDepositorExit(uint liquidityAmount, uint[] withdrawnAmounts);\n  event OnDepositorEmergencyExit(uint[] withdrawnAmounts);\n\n  /// @notice Recycle was made\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\n  /// @param amountsToForward Amounts to be sent to forwarder\n  event Recycle(\n    address[] rewardTokens,\n    uint[] amountsToForward,\n    uint toPerf,\n    uint toInsurance\n  );\n  //endregion Events\n\n  /////////////////////////////////////////////////////////////////////\n  //region Initialization and configuration\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __ConverterStrategyBase_init(\n    address controller_,\n    address splitter_,\n    address converter_\n  ) internal onlyInitializing {\n    __StrategyBase_init(controller_, splitter_);\n    converter = ITetuConverter(converter_);\n\n    // 1% by default\n    reinvestThresholdPercent = DENOMINATOR / 100;\n    emit ReinvestThresholdPercentChanged(DENOMINATOR / 100);\n  }\n\n  function setLiquidationThreshold(address token, uint amount) external {\n    StrategyLib.onlyOperators(controller());\n    liquidationThresholds[token] = amount;\n    emit LiquidationThresholdChanged(token, amount);\n  }\n\n  /// @param percent_ New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\n  function setReinvestThresholdPercent(uint percent_) external {\n    StrategyLib.onlyOperators(controller());\n    require(percent_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\n\n    reinvestThresholdPercent = percent_;\n    emit ReinvestThresholdPercentChanged(percent_);\n  }\n  //endregion Initialization and configuration\n\n  /////////////////////////////////////////////////////////////////////\n  //region Deposit to the pool\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Amount of underlying assets converted to pool assets and invested to the pool.\n  function investedAssets() override public view virtual returns (uint) {\n    return _investedAssets;\n  }\n\n  /// @notice Deposit given amount to the pool.\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    uint strategyLoss\n  ){\n    uint updatedInvestedAssets;\n    // we need to compensate difference between last updated invested assets and the current value for do not allow share price fluctuation\n    (updatedInvestedAssets, strategyLoss) = _updateInvestedAssetsAndGetLoss(updateTotalAssetsBeforeInvest_);\n\n    // skip deposit for small amounts\n    if (amount_ > reinvestThresholdPercent * updatedInvestedAssets / DENOMINATOR) {\n      address _asset = asset;\n      uint balanceBefore = AppLib.balance(_asset);\n      (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n\n      // prepare array of amounts ready to deposit, borrow missed amounts\n      uint[] memory amounts = _beforeDeposit(converter, amount_, tokens, indexAsset);\n\n      // make deposit, actually consumed amounts can be different from the desired amounts\n      (uint[] memory consumedAmounts,) = _depositorEnter(amounts);\n      emit OnDepositorEnter(amounts, consumedAmounts);\n\n      // update _investedAssets with new deposited amount\n      uint updatedInvestedAssetsAfterDeposit = _updateInvestedAssets();\n      // after deposit some asset can exist\n      uint balanceAfter = AppLib.balance(_asset);\n\n      // we need to compensate difference if during deposit we lost some assets\n      if ((updatedInvestedAssetsAfterDeposit + balanceAfter) < (updatedInvestedAssets + balanceBefore)) {\n        strategyLoss += (updatedInvestedAssets + balanceBefore) - (updatedInvestedAssetsAfterDeposit + balanceAfter);\n      }\n    }\n  }\n  //endregion Deposit to the pool\n\n  /////////////////////////////////////////////////////////////////////\n  //region Convert amounts before deposit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Prepare {tokenAmounts} to be passed to depositorEnter\n  /// @dev Override this function to customize entry kind\n  /// @param amount_ The amount of main asset that should be invested\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return tokenAmounts Amounts of depositor's assets ready to invest (this array can be passed to depositorEnter)\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) internal virtual returns (\n    uint[] memory tokenAmounts\n  ) {\n    // calculate required collaterals for each token and temporary save them to tokenAmounts\n    (uint[] memory weights, uint totalWeight) = _depositorPoolWeights();\n    // temporary save collateral to tokensAmounts\n    tokenAmounts = ConverterStrategyBaseLib2.getCollaterals(\n      amount_,\n      tokens_,\n      weights,\n      totalWeight,\n      indexAsset_,\n      IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle())\n    );\n\n    // make borrow and save amounts of tokens available for deposit to tokenAmounts, zero result amounts are possible\n    tokenAmounts = ConverterStrategyBaseLib.getTokenAmounts(\n      tetuConverter_,\n      tokens_,\n      indexAsset_,\n      tokenAmounts,\n      liquidationThresholds[tokens_[indexAsset_]]\n    );\n  }\n  //endregion Convert amounts before deposit\n\n  /////////////////////////////////////////////////////////////////////\n  //region Withdraw from the pool\n  /////////////////////////////////////////////////////////////////////\n\n  function _beforeWithdraw(uint /*amount*/) internal virtual {\n    // do nothing\n  }\n\n  /// @notice Withdraw given amount from the pool.\n  /// @param amount Amount to be withdrawn in terms of the asset in addition to the exist balance.\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing (in USD, decimals of the {asset})\n  /// @return assetPrice Price of the {asset} from the price oracle\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawFromPool(uint amount) override internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  ) {\n    (expectedWithdrewUSD, assetPrice, strategyLoss) = _withdrawUniversal(amount);\n  }\n\n  /// @notice Withdraw all from the pool.\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing\n  /// @return assetPrice Price of the {asset} taken from the price oracle\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _withdrawAllFromPool() override internal virtual returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  ) {\n    (expectedWithdrewUSD, assetPrice, strategyLoss) = _withdrawUniversal(type(uint).max);\n  }\n\n  /// @param amount Amount to be trying to withdrawn. Max uint means attempt to withdraw all possible invested assets.\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing in terms of USD value of each asset in the pool\n  /// @return __assetPrice Price of the {asset} taken from the price oracle\n  /// @return strategyLoss Loss before withdrawing: [new-investedAssets - old-investedAssets]\n  function _withdrawUniversal(uint amount) internal returns (\n    uint expectedWithdrewUSD,\n    uint __assetPrice,\n    uint strategyLoss\n  ) {\n    _beforeWithdraw(amount);\n\n    WithdrawUniversalLocal memory v;\n    v.all = amount == type(uint).max;\n    (v.investedAssetsBeforeWithdraw, strategyLoss) = _updateInvestedAssetsAndGetLoss(true);\n\n    if ((v.all || amount != 0) && v.investedAssetsBeforeWithdraw != 0) {\n\n      // --- init variables ---\n      v.tokens = _depositorPoolAssets();\n      v.asset = asset;\n      ITetuConverter _converter = converter;\n      uint indexAsset = ConverterStrategyBaseLib.getAssetIndex(v.tokens, v.asset);\n      uint balanceBefore = AppLib.balance(v.asset);\n\n      v.reservesBeforeWithdraw = _depositorPoolReserves();\n      v.totalSupplyBeforeWithdraw = _depositorTotalSupply();\n      v.depositorLiquidity = _depositorLiquidity();\n      v.assetPrice = ConverterStrategyBaseLib.getAssetPriceFromConverter(_converter, v.asset);\n      // -----------------------\n\n      // calculate how much liquidity we need to withdraw for getting the requested amount\n      (v.liquidityAmountToWithdraw, v.amountsToConvert) = ConverterStrategyBaseLib2.getLiquidityAmount(\n        v.all ? 0 : amount,\n        address(this),\n        v.tokens,\n        indexAsset,\n        _converter,\n        v.investedAssetsBeforeWithdraw,\n        v.depositorLiquidity\n      );\n\n      if (v.liquidityAmountToWithdraw != 0) {\n\n        // =============== WITHDRAW =====================\n        // make withdraw\n        uint[] memory withdrawnAmounts = _depositorExit(v.liquidityAmountToWithdraw);\n        // the depositor is able to use less liquidity than it was asked, i.e. Balancer-depositor leaves some BPT unused\n        // use what exactly was withdrew instead of the expectation\n        // assume that liquidity cannot increase in _depositorExit\n        v.liquidityAmountToWithdraw = v.depositorLiquidity - _depositorLiquidity();\n        emit OnDepositorExit(v.liquidityAmountToWithdraw, withdrawnAmounts);\n        // ==============================================\n\n        // we need to call expectation after withdraw for calculate it based on the real liquidity amount that was withdrew\n        // it should be called BEFORE the converter will touch our positions coz we need to call quote the estimations\n        // amountsToConvert should contains amounts was withdrawn from the pool and amounts received from the converter\n        (v.expectedMainAssetAmounts, v.amountsToConvert) = ConverterStrategyBaseLib.postWithdrawActions(\n          _converter,\n          v.tokens,\n          indexAsset,\n          v.reservesBeforeWithdraw,\n          v.liquidityAmountToWithdraw,\n          v.totalSupplyBeforeWithdraw,\n          v.amountsToConvert,\n          withdrawnAmounts\n        );\n      } else {\n        // we don't need to withdraw any amounts from the pool, available converted amounts are enough for us\n        v.expectedMainAssetAmounts = ConverterStrategyBaseLib.postWithdrawActionsEmpty(\n          _converter,\n          v.tokens,\n          indexAsset,\n          v.amountsToConvert\n        );\n      }\n\n      // convert amounts to main asset\n      // it is safe to use amountsToConvert from expectation - we will try to repay only necessary amounts\n      v.expectedTotalMainAssetAmount += _makeRequestedAmount(\n        v.tokens,\n        indexAsset,\n        v.amountsToConvert,\n        _converter,\n        amount,\n        v.expectedMainAssetAmounts\n      );\n\n      v.investedAssetsAfterWithdraw = _updateInvestedAssets();\n      v.balanceAfterWithdraw = AppLib.balance(v.asset);\n\n      // we need to compensate difference if during withdraw we lost some assets\n      if ((v.investedAssetsAfterWithdraw + v.balanceAfterWithdraw) < (v.investedAssetsBeforeWithdraw + balanceBefore)) {\n        strategyLoss += (v.investedAssetsBeforeWithdraw + balanceBefore) - (v.investedAssetsAfterWithdraw + v.balanceAfterWithdraw);\n      }\n\n      return (\n        v.expectedTotalMainAssetAmount * v.assetPrice / 1e18,\n        v.assetPrice,\n        strategyLoss\n      );\n    }\n    return (0, 0, 0);\n  }\n\n  /// @notice If pool supports emergency withdraw need to call it for emergencyExit()\n  function _emergencyExitFromPool() override internal virtual {\n    uint[] memory withdrawnAmounts = _depositorEmergencyExit();\n    emit OnDepositorEmergencyExit(withdrawnAmounts);\n\n    // convert amounts to main asset\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n    ConverterStrategyBaseLib.closePositionsToGetAmount(\n      converter,\n      _getLiquidator(controller()),\n      indexAsset,\n      liquidationThresholds,\n      type(uint).max,\n      tokens\n    );\n\n    // adjust _investedAssets\n    _updateInvestedAssets();\n  }\n  //endregion Withdraw from the pool\n\n  /////////////////////////////////////////////////////////////////////\n  //region Convert amounts after withdraw\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Convert {amountsToConvert_} to the main {asset}\n  ///         Swap leftovers (if any) to the main asset.\n  ///         If result amount is less than expected, try to close any other available debts (1 repay per block only)\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @param requestedAmount Amount to be withdrawn in terms of the asset in addition to the exist balance.\n  ///        Max uint means attempt to withdraw all possible invested assets.\n  /// @param amountsToConvert_ Amounts available for conversion after withdrawing from the pool\n  /// @param expectedMainAssetAmounts Amounts of main asset that we expect to receive after conversion amountsToConvert_\n  /// @return expectedAmount Expected total amount of main asset after all conversions, swaps and repays\n  function _makeRequestedAmount(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_,\n    ITetuConverter converter_,\n    uint requestedAmount,\n    uint[] memory expectedMainAssetAmounts\n  ) internal returns (\n    uint expectedAmount\n  ) {\n    // get the total expected amount\n    for (uint i; i < tokens_.length; i = AppLib.uncheckedInc(i)) {\n      expectedAmount += expectedMainAssetAmounts[i];\n    }\n\n    // we cannot repay a debt twice\n    // suppose, we have usdt = 1 and we need to convert it to usdc, then get additional usdt=10 and make second repay\n    // But: we cannot make repay(1) and than repay(10). We MUST make single repay(11)\n\n    ITetuLiquidator liquidator = _getLiquidator(controller());\n    if (requestedAmount != type(uint).max\n      && expectedAmount > requestedAmount * (GAP_CONVERSION + DENOMINATOR) / DENOMINATOR\n    ) {\n      // amountsToConvert_ are enough to get requestedAmount\n      ConverterStrategyBaseLib.convertAfterWithdraw(\n        converter_,\n        liquidator,\n        indexAsset_,\n        liquidationThresholds[tokens_[indexAsset_]],\n        tokens_,\n        amountsToConvert_\n      );\n    } else {\n      // amountsToConvert_ are NOT enough to get requestedAmount\n      // We are allowed to make only one repay per block, so, we shouldn't try to convert amountsToConvert_\n      // We should try to close the exist debts instead:\n      //    convert a part of main assets to get amount of secondary assets required to repay the debts\n      // and only then make conversion.\n      expectedAmount = ConverterStrategyBaseLib.closePositionsToGetAmount(\n        converter_,\n        liquidator,\n        indexAsset_,\n        liquidationThresholds,\n        requestedAmount,\n        tokens_\n      ) + expectedMainAssetAmounts[indexAsset_];\n    }\n\n    return expectedAmount;\n  }\n  //endregion Convert amounts after withdraw\n\n  /////////////////////////////////////////////////////////////////////\n  //region Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claim all possible rewards.\n  function _claim() override internal virtual returns (address[] memory rewardTokensOut, uint[] memory amountsOut) {\n    // get rewards from the Depositor\n    (address[] memory rewardTokens, uint[] memory rewardAmounts, uint[] memory balancesBefore) = _depositorClaimRewards();\n\n    (rewardTokensOut, amountsOut) = ConverterStrategyBaseLib2.claimConverterRewards(\n      converter,\n      _depositorPoolAssets(),\n      rewardTokens,\n      rewardAmounts,\n      balancesBefore\n    );\n  }\n\n  /// @dev Call recycle process and send tokens to forwarder.\n  ///      Need to be separated from the claim process - the claim can be called by operator for other purposes.\n  function _rewardsLiquidation(address[] memory rewardTokens, uint[] memory amounts) internal {\n    uint len = rewardTokens.length;\n    if (len > 0) {\n      uint[] memory amountsToForward = _recycle(rewardTokens, amounts);\n\n      // send forwarder-part of the rewards to the forwarder\n      ConverterStrategyBaseLib2.sendTokensToForwarder(controller(), splitter, rewardTokens, amountsToForward);\n    }\n  }\n\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just left on the balance\n  ///   Performance amounts should be liquidate, result underlying should be sent to performance receiver and insurance.\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\n  /// @dev {_recycle} is implemented as separate (inline) function to simplify unit testing\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @return amountsToForward Amounts to be sent to forwarder\n  function _recycle(address[] memory rewardTokens_, uint[] memory rewardAmounts_) internal returns (\n    uint[] memory amountsToForward\n  ) {\n    address _asset = asset; // save gas\n\n    uint amountPerf; // total amount for the performance receiver and insurance\n    (amountsToForward, amountPerf) = ConverterStrategyBaseLib.recycle(\n      converter,\n      _asset,\n      compoundRatio,\n      _depositorPoolAssets(),\n      _getLiquidator(controller()),\n      liquidationThresholds,\n      rewardTokens_,\n      rewardAmounts_,\n      performanceFee\n    );\n\n    // send performance-part of the underlying to the performance receiver and insurance\n    (uint toPerf, uint toInsurance) = ConverterStrategyBaseLib2.sendPerformanceFee(_asset, amountPerf, splitter, performanceReceiver);\n\n    emit Recycle(rewardTokens_, amountsToForward, toPerf, toInsurance);\n  }\n  //endregion Claim rewards\n\n  /////////////////////////////////////////////////////////////////////\n  //region Hardwork\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice A virtual handler to make any action before hardwork\n  function _preHardWork(bool reInvest) internal virtual {}\n\n  /// @notice A virtual handler to make any action after hardwork\n  function _postHardWork() internal virtual {}\n\n  /// @notice Is strategy ready to hard work\n  function isReadyToHardWork() override external virtual view returns (bool) {\n    // check claimable amounts and compare with thresholds\n    return true;\n  }\n\n  /// @notice Do hard work with reinvesting\n  /// @return earned Earned amount in terms of {asset}\n  /// @return lost Lost amount in terms of {asset}\n  function doHardWork() override public returns (uint earned, uint lost) {\n    require(msg.sender == splitter, StrategyLib.DENIED);\n    return _doHardWork(true);\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  function _handleRewards() internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim);\n\n  /// @param reInvest Deposit to pool all available amount if it's greater than the threshold\n  /// @return earned Earned amount in terms of {asset}\n  /// @return lost Lost amount in terms of {asset}\n  function _doHardWork(bool reInvest) internal returns (uint earned, uint lost) {\n    // ATTENTION! splitter will not cover the loss if it is lower than profit\n\n    // register autocompound income or possible lose if assets fluctuated\n    uint investedAssetsBefore = _investedAssets;\n    uint investedAssetsLocal = _updateInvestedAssets();\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(investedAssetsBefore, investedAssetsLocal, 0, 0);\n\n    _preHardWork(reInvest);\n\n    // claim rewards and get current asset balance\n    (uint earnedFromRewards, uint lostFromRewards, uint assetBalance) = _handleRewards();\n    earned += earnedFromRewards;\n    lost += lostFromRewards;\n\n    // re-invest income\n    if (reInvest && assetBalance > reinvestThresholdPercent * investedAssetsLocal / DENOMINATOR) {\n      _depositToPool(assetBalance, false);\n      (earned, lost) = ConverterStrategyBaseLib.registerIncome(\n        investedAssetsLocal + assetBalance, // assets in use before deposit\n        _investedAssets + AppLib.balance(asset), // assets in use after deposit\n        earned,\n        lost\n      );\n    }\n\n    _postHardWork();\n  }\n  //endregion Hardwork\n\n  /////////////////////////////////////////////////////////////////////\n  //region InvestedAssets Calculations\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Updates cached _investedAssets to actual value\n  /// @dev Should be called after deposit / withdraw / claim; virtual - for ut\n  function _updateInvestedAssets() internal returns (uint investedAssetsOut) {\n    investedAssetsOut = _calcInvestedAssets();\n    _investedAssets = investedAssetsOut;\n  }\n\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return Invested asset amount under control (in terms of {asset})\n  function _calcInvestedAssets() internal returns (uint) {\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n    return ConverterStrategyBaseLib.calcInvestedAssets(\n      tokens,\n      // quote exit should check zero liquidity\n      _depositorQuoteExit(_depositorLiquidity()),\n      indexAsset,\n      converter\n    );\n  }\n\n  function calcInvestedAssets() external returns (uint) {\n    StrategyLib.onlyOperators(controller());\n    return _calcInvestedAssets();\n  }\n\n  /// @notice Update invested assets and return possible lose [new-investedAssets - old-investedAssets]\n  /// @param updateTotalAssetsBeforeInvest_ If false - skip update, return delta = 0\n  function _updateInvestedAssetsAndGetLoss(bool updateTotalAssetsBeforeInvest_) internal returns (\n    uint updatedInvestedAssets,\n    uint loss\n  ) {\n    uint __investedAssets = _investedAssets;\n\n    updatedInvestedAssets = updateTotalAssetsBeforeInvest_\n      ? _updateInvestedAssets()\n      : __investedAssets;\n\n    loss = updateTotalAssetsBeforeInvest_\n      ? updatedInvestedAssets < __investedAssets ? __investedAssets - updatedInvestedAssets : 0\n      : uint(0);\n  }\n  //endregion InvestedAssets Calculations\n\n  /////////////////////////////////////////////////////////////////////\n  //region ITetuConverterCallback\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Converters asks to send some amount back.\n  /// @param theAsset_ Required asset (either collateral or borrow)\n  /// @param amount_ Required amount of the {theAsset_}\n  /// @return amountOut Amount sent to balance of TetuConverter, amountOut <= amount_\n  function requirePayAmountBack(address theAsset_, uint amount_) external override returns (uint amountOut) {\n    address __converter = address(converter);\n    require(msg.sender == __converter, StrategyLib.DENIED);\n\n    // detect index of the target asset\n    (address[] memory tokens, uint indexTheAsset) = _getTokens(theAsset_);\n    // get amount of target asset available to be sent\n    uint balance = AppLib.balance(theAsset_);\n\n    // withdraw from the pool if not enough\n    if (balance < amount_) {\n      // the strategy doesn't have enough target asset on balance\n      // withdraw all from the pool but don't convert assets to underlying\n      uint liquidity = _depositorLiquidity();\n      if (liquidity != 0) {\n        uint[] memory withdrawnAmounts = _depositorExit(liquidity);\n        emit OnDepositorExit(liquidity, withdrawnAmounts);\n      }\n    }\n\n    amountOut = ConverterStrategyBaseLib.swapToGivenAmountAndSendToConverter(\n      amount_,\n      indexTheAsset,\n      tokens,\n      __converter,\n      controller(),\n      asset,\n      liquidationThresholds\n    );\n\n    // update invested assets anyway, even if we suppose it will be called in other places\n    _updateInvestedAssets();\n  }\n\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external override {\n    require(msg.sender == address(converter), StrategyLib.DENIED);\n\n    uint len = assets_.length;\n    require(len == amounts_.length, AppErrors.INCORRECT_LENGTHS);\n\n    // TetuConverter is able two call this function in two cases:\n    // 1) rebalancing (the health factor of some borrow is too low)\n    // 2) forcible closing of the borrow\n    // In both cases we update invested assets value here\n    // and avoid fixing any related losses in hardwork\n    _updateInvestedAssets();\n  }\n  //endregion ITetuConverterCallback\n\n  /////////////////////////////////////////////////////////////////////\n  //region Others\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Unlimited capacity by default\n  function capacity() external virtual view returns (uint) {\n    return 2 ** 255;\n    // almost same as type(uint).max but more gas efficient\n  }\n\n  function _getTokens(address asset_) internal view returns (address[] memory tokens, uint indexAsset) {\n    tokens = _depositorPoolAssets();\n    indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, asset_);\n    require(indexAsset != type(uint).max, StrategyLib.WRONG_VALUE);\n  }\n\n  function _getLiquidator(address controller_) internal view returns (ITetuLiquidator) {\n    return ITetuLiquidator(IController(controller_).liquidator());\n  }\n  //endregion Others\n\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[50 - 4] private __gap; // 50 - count of variables\n\n}\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppLib.sol\";\nimport \"../libs/TokenAmountsLib.sol\";\nimport \"../libs/ConverterEntryKinds.sol\";\n\nlibrary ConverterStrategyBaseLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  //region Data types\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\n  struct RecycleLocalParams {\n    /// @notice Compound amount + Performance amount\n    uint amountCP;\n    /// @notice Amount to compound\n    uint amountC;\n    /// @notice Amount to send to performance and insurance\n    uint amountP;\n    /// @notice Amount to forwarder + amount to compound\n    uint amountFC;\n    address rewardToken;\n    uint liquidationThresholdAsset;\n    uint len;\n    uint receivedAmountOut;\n  }\n\n  struct OpenPositionLocal {\n    uint entryKind;\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n  }\n\n  struct OpenPositionEntryKind1Local {\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n    uint c1;\n    uint c3;\n    uint ratio;\n    uint alpha;\n  }\n\n  struct CalcInvestedAssetsLocal {\n    uint len;\n    uint[] prices;\n    uint[] decs;\n    uint[] debts;\n  }\n\n  struct ConvertAfterWithdrawLocal {\n    address asset;\n    uint collateral;\n    uint spent;\n    uint received;\n    uint balance;\n    uint balanceBefore;\n    uint len;\n  }\n\n  struct SwapToGivenAmountInputParams {\n    uint targetAmount;\n    address[] tokens;\n    uint indexTargetAsset;\n    address underlying;\n    uint[] amounts;\n    ITetuConverter converter;\n    ITetuLiquidator liquidator;\n    uint liquidationThresholdForTargetAsset;\n    /// @notice Allow to swap more then required (i.e. 1_000 => +1%)\n    ///         to avoid additional swap if the swap return amount a bit less than we expected\n    uint overswap;\n  }\n\n  struct SwapToGivenAmountLocal {\n    uint len;\n    uint[] availableAmounts;\n    uint i;\n  }\n\n  struct CloseDebtsForRequiredAmountLocal {\n    uint len;\n    address asset;\n    uint collateral;\n    uint spentAmountIn;\n    uint receivedAmount;\n    uint balance;\n    uint[] tokensBalancesBefore;\n\n    uint totalDebt;\n    uint totalCollateral;\n\n    /// @notice Cost of $1 in terms of the assets, decimals 18\n    uint[] prices;\n    /// @notice 10**decimal for the assets\n    uint[] decs;\n\n    uint newBalance;\n  }\n  //endregion Data types\n\n  /////////////////////////////////////////////////////////////////////\n  //region Constants\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice approx one month for average block time 2 sec\n  uint internal constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\n  uint internal constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n  uint internal constant DENOMINATOR = 100_000;\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\n  uint internal constant PRICE_IMPACT_TOLERANCE = 300;\n  /// @notice borrow/collateral amount cannot be less than given number of tokens\n  uint internal constant DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD = 10;\n  /// @notice Allow to swap more then required (i.e. 1_000 => +1%) inside {swapToGivenAmount}\n  ///         to avoid additional swap if the swap will return amount a bit less than we expected\n  uint internal constant OVERSWAP = PRICE_IMPACT_TOLERANCE + _ASSET_LIQUIDATION_SLIPPAGE;\n  /// @dev Absolute value for any token\n  uint internal constant DEFAULT_LIQUIDATION_THRESHOLD = 100_000;\n  /// @notice 1% gap to cover possible liquidation inefficiency\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\n  uint internal constant GAP_CONVERSION = 1_000;\n  //endregion Constants\n\n  /////////////////////////////////////////////////////////////////////\n  //region Events\n  /////////////////////////////////////////////////////////////////////\n  /// @notice A borrow was made\n  event OpenPosition(\n    address converter,\n    address collateralAsset,\n    uint collateralAmount,\n    address borrowAsset,\n    uint borrowedAmount,\n    address recepient\n  );\n\n  /// @notice Some borrow(s) was/were repaid\n  event ClosePosition(\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    address recepient,\n    uint returnedAssetAmountOut,\n    uint returnedBorrowAmountOut\n  );\n\n  /// @notice A liquidation was made\n  event Liquidation(\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint spentAmountIn,\n    uint receivedAmountOut\n  );\n\n  event ReturnAssetToConverter(address asset, uint amount);\n  //endregion Events\n\n  /////////////////////////////////////////////////////////////////////\n  //region View functions\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Get amount of assets that we expect to receive after withdrawing\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\n  ///                  one of assets must be {asset_}\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\n  function getExpectedWithdrawnAmounts(\n    uint[] memory reserves_,\n    uint liquidityAmount_,\n    uint totalSupply_\n  ) internal pure returns (\n    uint[] memory withdrawnAmountsOut\n  ) {\n    uint ratio = totalSupply_ == 0\n      ? 0\n      : (liquidityAmount_ >= totalSupply_\n        ? 1e18\n        : 1e18 * liquidityAmount_ / totalSupply_\n      );\n\n    uint len = reserves_.length;\n    withdrawnAmountsOut = new uint[](len);\n\n    if (ratio != 0) {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\n      }\n    }\n  }\n\n  /// @return prices Asset prices in USD, decimals 18\n  /// @return decs 10**decimals\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\n    uint[] memory prices,\n    uint[] memory decs\n  ) {\n    prices = new uint[](len);\n    decs = new uint[](len);\n    {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\n      }\n    }\n  }\n\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\n    uint len = tokens_.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (tokens_[i] == asset_) {\n        return i;\n      }\n    }\n    return type(uint).max;\n  }\n  //endregion View functions\n\n  /////////////////////////////////////////////////////////////////////\n  //region Borrow and close positions\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  function openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdAmountIn_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return _openPosition(tetuConverter_, entryData_, collateralAsset_, borrowAsset_, amountIn_, thresholdAmountIn_);\n  }\n\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  /// @param thresholdAmountIn_ Min value of amountIn allowed for the second and subsequent conversions.\n  ///        0 - use default min value\n  ///        If amountIn becomes too low, no additional borrows are possible, so\n  ///        the rest amountIn is just added to collateral/borrow amount of previous conversion.\n  function _openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdAmountIn_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    if (thresholdAmountIn_ == 0) {\n      // zero threshold is not allowed because round-issues are possible, see openPosition.dust test\n      // we assume here, that it's useless to borrow amount using collateral/borrow amount\n      // less than given number of tokens (event for BTC)\n      thresholdAmountIn_ = DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD;\n    }\n    if (amountIn_ <= thresholdAmountIn_) {\n      return (0, 0);\n    }\n\n    OpenPositionLocal memory vars;\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\n    vars.entryKind = ConverterEntryKinds.getEntryKind(entryData_);\n    if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\n      return openPositionEntryKind1(\n        tetuConverter_,\n        entryData_,\n        collateralAsset_,\n        borrowAsset_,\n        amountIn_,\n        thresholdAmountIn_\n      );\n    } else {\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n        entryData_,\n        collateralAsset_,\n        amountIn_,\n        borrowAsset_,\n        _LOAN_PERIOD_IN_BLOCKS\n      );\n\n      uint len = vars.converters.length;\n      if (len > 0) {\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\n          vars.collateral;\n          vars.amountToBorrow;\n          if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\n            // we have exact amount of total collateral amount\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\n              ? amountIn_\n              : vars.collateralsRequired[i];\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\n              ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\n              : vars.amountsToBorrow[i];\n            amountIn_ -= vars.collateral;\n          } else {\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\n            // we have exact amount of total amount-to-borrow\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\n              ? amountIn_\n              : vars.amountsToBorrow[i];\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\n              ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\n              : vars.collateralsRequired[i];\n            amountIn_ -= vars.amountToBorrow;\n          }\n\n          if (amountIn_ < thresholdAmountIn_ && amountIn_ != 0) {\n            // dust amount is left, just leave it unused\n            // we cannot add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\n            amountIn_ = 0;\n          }\n\n          if (vars.amountToBorrow != 0) {\n            borrowedAmountOut += tetuConverter_.borrow(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n            collateralAmountOut += vars.collateral;\n            emit OpenPosition(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n          }\n\n          if (amountIn_ == 0) break;\n        }\n      }\n\n      return (collateralAmountOut, borrowedAmountOut);\n    }\n  }\n\n  /// @notice Open position using entry kind 1 - split provided amount on two parts according provided proportions\n  /// @param amountIn_ Amount of collateral to be divided on parts. We assume {amountIn_} > 0\n  /// @param collateralThreshold_ Min allowed collateral amount to be used for new borrow, > 0\n  /// @return collateralAmountOut Total collateral used to borrow {borrowedAmountOut}\n  /// @return borrowedAmountOut Total borrowed amount\n  function openPositionEntryKind1(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint collateralThreshold_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    OpenPositionEntryKind1Local memory vars;\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n      entryData_,\n      collateralAsset_,\n      amountIn_,\n      borrowAsset_,\n      _LOAN_PERIOD_IN_BLOCKS\n    );\n\n    uint len = vars.converters.length;\n    if (len > 0) {\n      // we should split amountIn on two amounts with proportions x:y\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\n      // calculate prices conversion ratio using price oracle, decimals 18\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\n\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\n        // and give us required proportions in result\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\n        // C1 is collateral amount left untouched (x)\n        // C2 is collateral amount converted to B2 (y)\n        // but if lending platform doesn't have enough liquidity\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        vars.ratio = (vars.collateralsRequired[i] + vars.c1) > amountIn_\n          ? 1e18 * amountIn_ / (vars.collateralsRequired[i] + vars.c1)\n          : 1e18;\n\n        vars.collateral = vars.collateralsRequired[i] * vars.ratio / 1e18;\n        vars.amountToBorrow = vars.amountsToBorrow[i] * vars.ratio / 1e18;\n\n        // skip any attempts to borrow zero amount or use too little collateral\n        if (vars.collateral < collateralThreshold_ || vars.amountToBorrow == 0) {\n          if (vars.collateralsRequired[i] + vars.c1 + collateralThreshold_ > amountIn_) {\n            // The lending platform has enough resources to make the borrow but amount of the borrow is too low\n            // Skip the borrow, leave leftover of collateral untouched\n            break;\n          } else {\n            // The lending platform doesn't have enough resources to make the borrow.\n            // We should try to make borrow on the next platform (if any)\n            continue;\n          }\n        }\n\n        require(\n          tetuConverter_.borrow(\n            vars.converters[i],\n            collateralAsset_,\n            vars.collateral,\n            borrowAsset_,\n            vars.amountToBorrow,\n            address(this)\n          ) == vars.amountToBorrow,\n          StrategyLib.WRONG_VALUE\n        );\n        emit OpenPosition(\n          vars.converters[i],\n          collateralAsset_,\n          vars.collateral,\n          borrowAsset_,\n          vars.amountToBorrow,\n          address(this)\n        );\n\n        borrowedAmountOut += vars.amountToBorrow;\n        collateralAmountOut += vars.collateral;\n\n        // calculate amount to be borrowed in the next converter\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        amountIn_ = (amountIn_ > vars.c1 + vars.collateral)\n          ? amountIn_ - (vars.c1 + vars.collateral)\n          : 0;\n\n        // protection against dust amounts, see \"openPosition.dust\", just leave dust amount unused\n        // we CAN NOT add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\n        // we assume here, that collateralThreshold_ != 0, so check amountIn_ != 0 is not required\n        if (amountIn_ < collateralThreshold_) break;\n      }\n    }\n\n    return (collateralAmountOut, borrowedAmountOut);\n  }\n\n  /// @notice Get ratio18 = collateral / borrow\n  function _getCollateralToBorrowRatio(\n    ITetuConverter tetuConverter_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) internal view returns (uint){\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle());\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\n    return 1e18 * priceBorrow * 10 ** IERC20Metadata(collateralAsset_).decimals()\n    / priceCollateral / 10 ** IERC20Metadata(borrowAsset_).decimals();\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  ///         It doesn't repay more than the actual amount of the debt, so it can use less amount than {amountToRepay}\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function _closePosition(\n    ITetuConverter converter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) internal returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\n\n    // We shouldn't try to pay more than we actually need to repay\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\n    // Let's limit amountToRepay by needToRepay-amount\n    (uint needToRepay,) = converter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\n\n    return _closePositionExact(converter_, collateralAsset, borrowAsset, amountRepay, balanceBefore);\n  }\n\n  /// @notice Close the given position, pay {amountRepay} exactly and ensure that all amount was accepted,\n  /// @param amountRepay Amount to repay in terms of {borrowAsset}\n  /// @param balanceBorrowAsset Current balance of the borrow asset\n  /// @return collateralOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function _closePositionExact(\n    ITetuConverter converter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    uint balanceBorrowAsset\n  ) internal returns (\n    uint collateralOut,\n    uint repaidAmountOut\n  ) {\n    // Make full/partial repayment\n    IERC20(borrowAsset).safeTransfer(address(converter_), amountRepay);\n\n    uint notUsedAmount;\n    (collateralOut, notUsedAmount,,) = converter_.repay(collateralAsset, borrowAsset, amountRepay, address(this));\n\n    emit ClosePosition(collateralAsset, borrowAsset, amountRepay, address(this), collateralOut, notUsedAmount);\n    uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\n\n    // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (debt-gap)\n    repaidAmountOut = balanceBorrowAsset > balanceAfter\n      ? balanceBorrowAsset - balanceAfter\n      : 0;\n\n    require(notUsedAmount == 0, StrategyLib.WRONG_VALUE);\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\n  }\n  //endregion Borrow and close positions\n\n  /////////////////////////////////////////////////////////////////////\n  //region Liquidation\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\n  function liquidate(\n    ITetuConverter converter,\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdTokenOut_,\n    bool skipValidation\n  ) external returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    return _liquidate(converter, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdTokenOut_, skipValidation);\n  }\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator (== 0 | amountIn_)\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\n  function _liquidate(\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdForTokenOut_,\n    bool skipValidation\n  ) internal returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\n\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\n\n    // calculate balance in out value for check threshold\n    uint amountOut = liquidator_.getPriceForRoute(route, amountIn_);\n\n    // if the expected value is higher than threshold distribute to destinations\n    return amountOut > liquidationThresholdForTokenOut_\n      ? (amountIn_, _liquidateWithRoute(converter_, route, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, skipValidation))\n      : (0, 0);\n  }\n\n  /// @notice Make liquidation using given route and check correctness using TetuConverter's price oracle\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\n  function _liquidateWithRoute(\n    ITetuConverter converter_,\n    ITetuLiquidator.PoolData[] memory route,\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    bool skipValidation\n  ) internal returns (\n    uint receivedAmountOut\n  ) {\n    // we need to approve each time, liquidator address can be changed in controller\n    AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\n\n    uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\n    liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\n    uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\n\n    require(balanceAfter > balanceBefore, AppErrors.BALANCE_DECREASE);\n    receivedAmountOut = balanceAfter - balanceBefore;\n\n    // Oracle in TetuConverter \"knows\" only limited number of the assets\n    // It may not know prices for reward assets, so for rewards this validation should be skipped to avoid TC-4 error\n    require(skipValidation || converter_.isConversionValid(tokenIn_, amountIn_, tokenOut_, receivedAmountOut, slippage_), AppErrors.PRICE_IMPACT);\n    emit Liquidation(tokenIn_, tokenOut_, amountIn_, amountIn_, receivedAmountOut);\n  }\n  //endregion Liquidation\n\n  /////////////////////////////////////////////////////////////////////\n  //region requirePayAmountBack\n  /////////////////////////////////////////////////////////////////////\n\n  /// @param amount_ Amount of the main asset requested by converter\n  /// @param indexTheAsset Index of the asset required by converter in the {tokens}\n  /// @param asset Main asset or underlying (it can be different from tokens[indexTheAsset])\n  /// @return amountOut Amount of the main asset sent to converter\n  function swapToGivenAmountAndSendToConverter(\n    uint amount_,\n    uint indexTheAsset,\n    address[] memory tokens,\n    address converter,\n    address controller,\n    address asset,\n    mapping(address => uint) storage liquidationThresholds\n  ) external returns (\n    uint amountOut\n  ) {\n    // msg.sender == converter; we assume here that it was checked before the call of this function\n    address theAsset = tokens[indexTheAsset];\n\n    amountOut = IERC20(theAsset).balanceOf(address(this));\n\n    // convert withdrawn assets to the target asset if not enough\n    if (amountOut < amount_) {\n      ConverterStrategyBaseLib.swapToGivenAmount(\n        amount_ - amountOut,\n        tokens,\n        indexTheAsset,\n        asset, // underlying === main asset\n        ITetuConverter(converter),\n        ITetuLiquidator(IController(controller).liquidator()),\n        liquidationThresholds[theAsset],\n        OVERSWAP\n      );\n      amountOut = IERC20(theAsset).balanceOf(address(this));\n    }\n\n    // we should send the asset as is even if it is lower than requested\n    // but shouldn't sent more amount than requested\n    amountOut = Math.min(amount_, amountOut);\n    if (amountOut != 0) {\n      IERC20(theAsset).safeTransfer(converter, amountOut);\n    }\n\n    // There are two cases of calling requirePayAmountBack by converter:\n    // 1) close a borrow: we will receive collateral back and amount of investedAssets almost won't change\n    // 2) rebalancing: we have real loss, it will be taken into account at next hard work\n    emit ReturnAssetToConverter(theAsset, amountOut);\n\n    // let's leave any leftovers un-invested, they will be reinvested at next hardwork\n  }\n\n  /// @notice Swap available amounts of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\n  /// @param targetAmount_ Required amount of tokens[indexTheAsset_] that should be received by swap(s)\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param indexTargetAsset_ Index of target asset in tokens_ array\n  /// @param underlying_ Index of underlying\n  /// @param liquidationThresholdForTargetAsset_ Liquidation thresholds for the target asset\n  /// @param overswap_ Allow to swap more then required (i.e. 1_000 => +1%)\n  ///                  to avoid additional swap if the swap return amount a bit less than we expected\n  /// @return spentAmounts Any amounts spent during the swaps\n  function swapToGivenAmount(\n    uint targetAmount_,\n    address[] memory tokens_,\n    uint indexTargetAsset_,\n    address underlying_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint liquidationThresholdForTargetAsset_,\n    uint overswap_\n  ) internal returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    SwapToGivenAmountLocal memory v;\n    v.len = tokens_.length;\n\n    v.availableAmounts = new uint[](v.len);\n    for (; v.i < v.len; v.i = AppLib.uncheckedInc(v.i)) {\n      v.availableAmounts[v.i] = IERC20(tokens_[v.i]).balanceOf(address(this));\n    }\n\n    (spentAmounts, receivedAmounts) = _swapToGivenAmount(\n      SwapToGivenAmountInputParams({\n        targetAmount: targetAmount_,\n        tokens: tokens_,\n        indexTargetAsset: indexTargetAsset_,\n        underlying: underlying_,\n        amounts: v.availableAmounts,\n        converter: converter_,\n        liquidator: liquidator_,\n        liquidationThresholdForTargetAsset: Math.max(liquidationThresholdForTargetAsset_, DEFAULT_LIQUIDATION_THRESHOLD),\n        overswap: overswap_\n      })\n    );\n  }\n\n  /// @notice Swap available {amounts_} of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\n  /// @return spentAmounts Any amounts spent during the swaps\n  /// @return receivedAmounts Any amounts received during the swaps\n  function _swapToGivenAmount(SwapToGivenAmountInputParams memory p) internal returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = p.tokens.length;\n    receivedAmounts = new uint[](v.len);\n    spentAmounts = new uint[](v.len);\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(p.converter.controller()).priceOracle()),\n      p.tokens,\n      v.len\n    );\n\n    // we need to swap other assets to the asset\n    // at first we should swap NOT underlying.\n    // if it would be not enough, we can swap underlying too.\n\n    // swap NOT underlying, initialize {indexUnderlying}\n    uint indexUnderlying;\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (p.underlying == p.tokens[i]) {\n        indexUnderlying = i;\n        continue;\n      }\n      if (p.indexTargetAsset == i) continue;\n\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, i);\n      spentAmounts[i] += spent;\n      receivedAmounts[p.indexTargetAsset] += received;\n\n      if (receivedAmounts[p.indexTargetAsset] >= p.targetAmount) break;\n    }\n\n    // swap underlying\n    if (receivedAmounts[p.indexTargetAsset] < p.targetAmount && p.indexTargetAsset != indexUnderlying) {\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, indexUnderlying);\n      spentAmounts[indexUnderlying] += spent;\n      receivedAmounts[p.indexTargetAsset] += received;\n    }\n  }\n\n  /// @notice Swap a part of amount of asset {tokens[indexTokenIn]} to {targetAsset} to get {targetAmount} in result\n  /// @param receivedTargetAmount Already received amount of {targetAsset} in previous swaps\n  /// @param indexTokenIn Index of the tokenIn in p.tokens\n  function _swapToGetAmount(\n    uint receivedTargetAmount,\n    SwapToGivenAmountInputParams memory p,\n    CalcInvestedAssetsLocal memory v,\n    uint indexTokenIn\n  ) internal returns (\n    uint amountSpent,\n    uint amountReceived\n  ) {\n    if (p.amounts[indexTokenIn] != 0) {\n      // we assume here, that p.targetAmount > receivedTargetAmount, see _swapToGivenAmount implementation\n\n      // calculate amount that should be swapped\n      // {overswap} allows to swap a bit more\n      // to avoid additional swaps if the swap will give us a bit less amount than expected\n      uint amountIn = (\n        (p.targetAmount - receivedTargetAmount)\n        * v.prices[p.indexTargetAsset] * v.decs[indexTokenIn]\n        / v.prices[indexTokenIn] / v.decs[p.indexTargetAsset]\n      ) * (p.overswap + DENOMINATOR) / DENOMINATOR;\n\n      (amountSpent, amountReceived) = _liquidate(\n        p.converter,\n        p.liquidator,\n        p.tokens[indexTokenIn],\n        p.tokens[p.indexTargetAsset],\n        Math.min(amountIn, p.amounts[indexTokenIn]),\n        _ASSET_LIQUIDATION_SLIPPAGE,\n        p.liquidationThresholdForTargetAsset,\n        false\n      );\n    }\n\n    return (amountSpent, amountReceived);\n  }\n  //endregion requirePayAmountBack\n\n  /////////////////////////////////////////////////////////////////////\n  //region Recycle rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Recycle the amounts: split each amount on tree parts: performance+insurance (P), forwarder (F), compound (C)\n  ///         Liquidate P+C, send F to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just left on the balance\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\n  ///   Performance amounts are liquidated, result amount of underlying is returned in {amountToPerformanceAndInsurance}\n  /// @param asset Underlying asset\n  /// @param compoundRatio Compound ration in the range [0...COMPOUND_DENOMINATOR]\n  /// @param tokens tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @param liquidationThresholds Liquidation thresholds for rewards tokens\n  /// @param performanceFee Performance fee in the range [0...FEE_DENOMINATOR]\n  /// @return amountsToForward Amounts of {rewardTokens} to be sent to forwarder, zero amounts are allowed here\n  /// @return amountToPerformanceAndInsurance Amount of underlying to be sent to performance receiver and insurance\n  function recycle(\n    ITetuConverter converter_,\n    address asset,\n    uint compoundRatio,\n    address[] memory tokens,\n    ITetuLiquidator liquidator,\n    mapping(address => uint) storage liquidationThresholds,\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    uint performanceFee\n  ) external returns (\n    uint[] memory amountsToForward,\n    uint amountToPerformanceAndInsurance\n  ) {\n    RecycleLocalParams memory p;\n\n    p.len = rewardTokens.length;\n    require(p.len == rewardAmounts.length, AppErrors.WRONG_LENGTHS);\n\n    p.liquidationThresholdAsset = Math.max(liquidationThresholds[asset], DEFAULT_LIQUIDATION_THRESHOLD);\n\n    amountsToForward = new uint[](p.len);\n\n    // rewardAmounts => P + F + C, where P - performance + insurance, F - forwarder, C - compound\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      p.amountFC = rewardAmounts[i] * (COMPOUND_DENOMINATOR - performanceFee) / COMPOUND_DENOMINATOR;\n      p.amountC = p.amountFC * compoundRatio / COMPOUND_DENOMINATOR;\n      p.amountP = rewardAmounts[i] - p.amountFC;\n      p.rewardToken = rewardTokens[i];\n      p.amountCP = p.amountC + p.amountP;\n\n      if (p.amountCP > 0) {\n        if (ConverterStrategyBaseLib.getAssetIndex(tokens, p.rewardToken) != type(uint).max) {\n          if (p.rewardToken == asset) {\n            // This is underlying, liquidation of compound part is not allowed; just keep on the balance, should be handled later\n            amountToPerformanceAndInsurance += p.amountP;\n          } else {\n            // This is secondary asset, Liquidation of compound part is not allowed, we should liquidate performance part only\n            if (p.amountP < Math.max(liquidationThresholds[p.rewardToken], DEFAULT_LIQUIDATION_THRESHOLD)) {\n              // performance amount is too small, liquidation is not allowed, we just keep that dust tokens on balance forever\n            } else {\n              (, p.receivedAmountOut) = _liquidate(\n                converter_,\n                liquidator,\n                p.rewardToken,\n                asset,\n                p.amountP,\n                _REWARD_LIQUIDATION_SLIPPAGE,\n                p.liquidationThresholdAsset,\n                false // use conversion validation for these rewards\n              );\n              amountToPerformanceAndInsurance += p.receivedAmountOut;\n            }\n          }\n        } else {\n          if (p.amountCP < Math.max(liquidationThresholds[p.rewardToken], DEFAULT_LIQUIDATION_THRESHOLD)) {\n            // amount is too small, liquidation is not allowed, we just keep that dust tokens on balance forever\n          } else {\n            // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\n            // We assume here, that {token} cannot be equal to {_asset}\n            // because the {_asset} is always included to the list of depositor's assets\n            (, p.receivedAmountOut) = _liquidate(\n              converter_,\n              liquidator,\n              p.rewardToken,\n              asset,\n              p.amountCP,\n              _REWARD_LIQUIDATION_SLIPPAGE,\n              p.liquidationThresholdAsset,\n              true // skip conversion validation for rewards becase we can have arbitrary assets here\n            );\n\n            amountToPerformanceAndInsurance += p.receivedAmountOut * (rewardAmounts[i] - p.amountFC) / p.amountCP;\n          }\n        }\n      }\n      amountsToForward[i] = p.amountFC - p.amountC;\n    }\n    return (amountsToForward, amountToPerformanceAndInsurance);\n  }\n  //endregion Recycle rewards\n\n  /////////////////////////////////////////////////////////////////////\n  //region calcInvestedAssets\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return amountOut Invested asset amount under control (in terms of {asset})\n  function calcInvestedAssets(\n    address[] memory tokens,\n    uint[] memory depositorQuoteExitAmountsOut,\n    uint indexAsset,\n    ITetuConverter converter_\n  ) external returns (\n    uint amountOut\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = tokens.length;\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\n      tokens,\n      v.len\n    );\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\n        amountOut += depositorQuoteExitAmountsOut[i];\n      } else {\n        // available amount to repay\n        uint toRepay = IERC20(tokens[i]).balanceOf(address(this)) + depositorQuoteExitAmountsOut[i];\n\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(\n          address(this),\n          tokens[indexAsset],\n          tokens[i],\n          // investedAssets is calculated using exact debts, debt-gaps are not taken into account\n          false\n        );\n        amountOut += collateral;\n        if (toRepay >= toPay) {\n          amountOut += (toRepay - toPay) * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        } else {\n          // there is not enough amount to pay the debt\n          // let's register a debt and try to resolve it later below\n          if (v.debts.length == 0) {\n            // lazy initialization\n            v.debts = new uint[](v.len);\n          }\n\n          // to pay the following amount we need to swap some other asset at first\n          v.debts[i] = toPay - toRepay;\n        }\n      }\n    }\n    if (v.debts.length == v.len) {\n      // we assume here, that it would be always profitable to save collateral\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n        if (v.debts[i] == 0) continue;\n\n        // estimatedAssets should be reduced on the debt-value\n        // this estimation is approx and do not count price impact on the liquidation\n        // we will able to count the real output only after withdraw process\n        uint debtInAsset = v.debts[i] * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        if (debtInAsset > amountOut) {\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\n          amountOut = 0;\n        } else {\n          amountOut -= debtInAsset;\n        }\n      }\n    }\n\n    return amountOut;\n  }\n  //endregion calcInvestedAssets\n\n  /////////////////////////////////////////////////////////////////////\n  //region getExpectedAmountMainAsset\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate expected amount of the main asset after withdrawing\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\n  /// @return amountsOut Expected amounts of the main asset received after conversion withdrawnAmounts+amountsToConvert\n  function getExpectedAmountMainAsset(\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint[] memory withdrawnAmounts_,\n    uint[] memory amountsToConvert_\n  ) internal returns (\n    uint[] memory amountsOut\n  ) {\n    uint len = tokens.length;\n    amountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        amountsOut[i] = withdrawnAmounts_[i];\n      } else {\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\n        if (amount != 0) {\n          (amountsOut[i],) = converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\n        }\n      }\n    }\n\n    return amountsOut;\n  }\n  //endregion getExpectedAmountMainAsset\n\n  /////////////////////////////////////////////////////////////////////\n  //region Reduce size of ConverterStrategyBase\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make borrow and save amounts of tokens available for deposit to tokenAmounts\n  /// @param thresholdMainAsset_ Min allowed value of collateral in terms of main asset, 0 - use default min value\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\n  /// @param collaterals_ Amounts of main asset that can be used as collateral to borrow {tokens_}\n  /// @param thresholdMainAsset_ Value of liquidation threshold for the main (collateral) asset\n  /// @return tokenAmountsOut Amounts available for deposit\n  function getTokenAmounts(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory collaterals_,\n    uint thresholdMainAsset_\n  ) external returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    // content of tokenAmounts will be modified in place\n    uint len = tokens_.length;\n    tokenAmountsOut = new uint[](len);\n\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexAsset_) {\n        if (collaterals_[i] != 0) {\n          AppLib.approveIfNeeded(tokens_[indexAsset_], collaterals_[i], address(tetuConverter_));\n          _openPosition(\n            tetuConverter_,\n            \"\", // entry kind = 0: fixed collateral amount, max possible borrow amount\n            tokens_[indexAsset_],\n            tokens_[i],\n            collaterals_[i],\n            Math.max(thresholdMainAsset_, DEFAULT_LIQUIDATION_THRESHOLD)\n          );\n\n          // zero borrowed amount is possible here (conversion is not available)\n          // if it's not suitable for depositor, the depositor should check zero amount in other places\n        }\n        tokenAmountsOut[i] = IERC20(tokens_[i]).balanceOf(address(this));\n      }\n    }\n\n    tokenAmountsOut[indexAsset_] = Math.min(\n      collaterals_[indexAsset_],\n      IERC20(tokens_[indexAsset_]).balanceOf(address(this))\n    );\n  }\n  //endregion Reduce size of ConverterStrategyBase\n\n  /////////////////////////////////////////////////////////////////////\n  //region Withdraw helpers\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\n  /// @param amountsToConvert Amounts of {tokens} to be converted, they are located on the balance before withdraw\n  /// @param withdrawnAmounts Amounts of {tokens} that were withdrew from the pool\n  function postWithdrawActions(\n    ITetuConverter converter,\n    address[] memory tokens,\n    uint indexAsset,\n\n    uint[] memory reservesBeforeWithdraw,\n    uint liquidityAmountWithdrew,\n    uint totalSupplyBeforeWithdraw,\n\n    uint[] memory amountsToConvert,\n    uint[] memory withdrawnAmounts\n  ) external returns (\n    uint[] memory expectedMainAssetAmounts,\n    uint[] memory _amountsToConvert\n  ) {\n    // estimate expected amount of assets to be withdrawn\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\n      reservesBeforeWithdraw,\n      liquidityAmountWithdrew,\n      totalSupplyBeforeWithdraw\n    );\n\n    // from received amounts after withdraw calculate how much we receive from converter for them in terms of the underlying asset\n    expectedMainAssetAmounts = getExpectedAmountMainAsset(\n      tokens,\n      indexAsset,\n      converter,\n      expectedWithdrawAmounts,\n      amountsToConvert\n    );\n\n    uint len = tokens.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      amountsToConvert[i] += withdrawnAmounts[i];\n    }\n\n    return (expectedMainAssetAmounts, amountsToConvert);\n  }\n\n  /// @notice return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\n  function postWithdrawActionsEmpty(\n    ITetuConverter converter,\n    address[] memory tokens,\n    uint indexAsset,\n    uint[] memory amountsToConvert_\n  ) external returns (\n    uint[] memory expectedAmountsMainAsset\n  ) {\n    expectedAmountsMainAsset = getExpectedAmountMainAsset(\n      tokens,\n      indexAsset,\n      converter,\n      // there are no withdrawn amounts\n      new uint[](tokens.length), // array with all zero values\n      amountsToConvert_\n    );\n  }\n\n  //endregion Withdraw helpers\n\n  /////////////////////////////////////////////////////////////////////\n  //region convertAfterWithdraw\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Convert {amountsToConvert_} (available on balance) to the main asset\n  ///         Swap leftovers if any.\n  ///         Result amount can be less than requested one, we don't try to close any other debts here\n  /// @param indexAsset Index of the main asset in {tokens}\n  /// @param liquidationThreshold Min allowed amount of main asset to be liquidated in {liquidator}\n  /// @param tokens Tokens received from {_depositorPoolAssets}\n  /// @param amountsToConvert Amounts to convert, the order of asset is same as in {tokens}\n  /// @return collateralOut Total amount of main asset returned after closing positions\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\n  function convertAfterWithdraw(\n    ITetuConverter tetuConverter,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    uint liquidationThreshold,\n    address[] memory tokens,\n    uint[] memory amountsToConvert\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    ConvertAfterWithdrawLocal memory v;\n    v.asset = tokens[indexAsset];\n    v.balanceBefore = IERC20(v.asset).balanceOf(address(this));\n    v.len = tokens.length;\n\n    // Close positions to convert all required amountsToConvert\n    repaidAmountsOut = new uint[](tokens.length);\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset || amountsToConvert[i] == 0) continue;\n      (, repaidAmountsOut[i]) = _closePosition(tetuConverter, v.asset, tokens[i], amountsToConvert[i]);\n    }\n\n    // Manually swap remain leftovers\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset || amountsToConvert[i] == 0) continue;\n      if (amountsToConvert[i] > repaidAmountsOut[i]) {\n        (v.spent, v.received) = _liquidate(\n          tetuConverter,\n          liquidator,\n          tokens[i],\n          v.asset,\n          amountsToConvert[i] - repaidAmountsOut[i],\n          _ASSET_LIQUIDATION_SLIPPAGE,\n          liquidationThreshold,\n          false\n        );\n        collateralOut += v.received;\n        repaidAmountsOut[i] += v.spent;\n      }\n    }\n\n    // Calculate amount of received collateral\n    v.balance = IERC20(v.asset).balanceOf(address(this));\n    collateralOut = v.balance > v.balanceBefore\n      ? v.balance - v.balanceBefore\n      : 0;\n\n    return (collateralOut, repaidAmountsOut);\n  }\n\n  /// @notice Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\n  /// @dev We assume here that this function is called before closing any positions in the current block\n  /// @param liquidationThresholds Min allowed amounts-out for liquidations\n  /// @param requestedAmount Requested amount of main asset that should be added to the current balance\n  /// @return expectedAmount Main asset amount expected to be received on balance after all conversions and swaps\n  function closePositionsToGetAmount(\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    mapping(address => uint) storage liquidationThresholds,\n    uint requestedAmount,\n    address[] memory tokens\n  ) external returns (\n    uint expectedAmount\n  ) {\n    if (requestedAmount != 0) {\n      CloseDebtsForRequiredAmountLocal memory v;\n      v.asset = tokens[indexAsset];\n      v.len = tokens.length;\n      v.balance = IERC20(v.asset).balanceOf(address(this));\n\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n        if (i == indexAsset) continue;\n\n        // we need to increase balance on the following amount: requestedAmount - v.balance;\n        // we have following borrow: amount-to-pay and corresponded collateral\n        (v.totalDebt, v.totalCollateral) = converter_.getDebtAmountCurrent(address(this), v.asset, tokens[i], true);\n\n        uint tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\n\n        if (v.totalDebt != 0 || tokenBalance != 0) {\n          //lazy initialization of the prices and decs\n          if (v.prices.length == 0) {\n            (v.prices, v.decs) = _getPricesAndDecs(\n              IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\n              tokens,\n              v.len\n            );\n          }\n\n          // repay the debt if any\n          if (v.totalDebt != 0) {\n            // what amount of main asset we should sell to pay the debt\n            uint toSell = _getAmountToSell(\n              requestedAmount,\n              v.totalDebt,\n              v.totalCollateral,\n              v.prices,\n              v.decs,\n              indexAsset,\n              i,\n              tokenBalance\n            );\n\n            // convert {toSell} amount of main asset to tokens[i]\n            if (toSell != 0 && v.balance != 0) {\n              toSell = Math.min(toSell, v.balance);\n              (toSell, ) = _liquidate(\n                converter_,\n                liquidator,\n                v.asset,\n                tokens[i],\n                toSell,\n                _ASSET_LIQUIDATION_SLIPPAGE,\n                liquidationThresholds[tokens[i]],\n                false\n              );\n              tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\n            }\n\n            // sell {toSell}, repay the debt, return collateral back; we should receive amount > toSell\n            expectedAmount += _repayDebt(converter_, v.asset, tokens[i], tokenBalance) - toSell;\n\n            // we can have some leftovers after closing the debt\n            tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\n          }\n\n          // directly swap leftovers\n          if (tokenBalance != 0) {\n            (uint spentAmountIn,) = _liquidate(\n              converter_,\n              liquidator,\n              tokens[i],\n              v.asset,\n              tokenBalance,\n              _ASSET_LIQUIDATION_SLIPPAGE,\n              liquidationThresholds[v.asset],\n              false\n            );\n            if (spentAmountIn != 0) {\n              // spentAmountIn can be zero if token balance is less than liquidationThreshold\n              expectedAmount += spentAmountIn * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n            }\n          }\n\n          // reduce of requestedAmount on the balance increment\n          v.newBalance = IERC20(v.asset).balanceOf(address(this));\n          require(v.newBalance >= v.balance, AppErrors.BALANCE_DECREASE);\n\n          if (requestedAmount > v.newBalance - v.balance) {\n            requestedAmount -= (v.newBalance - v.balance);\n            v.balance = v.newBalance;\n          } else {\n            // we get requestedAmount on the balance and don't need to make any other conversions\n            break;\n          }\n        }\n      }\n    }\n\n    return expectedAmount;\n  }\n\n  /// @notice What amount of collateral should be sold to pay the debt and receive {requestedAmount}\n  /// @dev It doesn't allow to sell more than the amount of total debt in the borrow\n  /// @param requestedAmount We need to increase balance (of collateral asset) on this amount\n  /// @param totalDebt Total debt of the borrow in terms of borrow asset\n  /// @param totalCollateral Total collateral of the borrow in terms of collateral asset\n  /// @param prices Cost of $1 in terms of the asset, decimals 18\n  /// @param decs 10**decimals for each asset\n  /// @param indexCollateral Index of the collateral asset in {prices} and {decs}\n  /// @param indexBorrowAsset Index of the borrow asset in {prices} and {decs}\n  /// @param balanceBorrowAsset Available balance of the borrow asset, it will be used to cover the debt\n  function _getAmountToSell(\n    uint requestedAmount,\n    uint totalDebt,\n    uint totalCollateral,\n    uint[] memory prices,\n    uint[] memory decs,\n    uint indexCollateral,\n    uint indexBorrowAsset,\n    uint balanceBorrowAsset\n  ) internal pure returns (\n    uint amountOut\n  ) {\n    if (totalDebt != 0) {\n      if (balanceBorrowAsset != 0) {\n        // there is some borrow asset on balance\n        // it will be used to cover the debt\n        // let's reduce the size of totalDebt/Collateral to exclude balanceBorrowAsset\n        uint sub = Math.min(balanceBorrowAsset, totalDebt);\n        totalCollateral -= totalCollateral * sub / totalDebt;\n        totalDebt -= sub;\n      }\n\n      // for definiteness: usdc - collateral asset, dai - borrow asset\n      // Pc = price of the USDC, Pb = price of the DAI, alpha = Pc / Pb [DAI / USDC]\n      // S [USDC] - amount to sell, R [DAI] = alpha * S - amount to repay\n      // After repaying R we get: alpha * S * C / R\n      // Balance should be increased on: requestedAmount = alpha * S * C / R - S\n      // So, we should sell: S = requestedAmount / (alpha * C / R - 1))\n      // We can lost some amount on liquidation of S => R, so we need to use some gap = {GAP_AMOUNT_TO_SELL}\n      // Same formula: S * h = S + requestedAmount, where h = health factor => s = requestedAmount / (h - 1)\n      // h = alpha * C / R\n      uint alpha18 = prices[indexCollateral] * decs[indexBorrowAsset] * 1e18\n      / prices[indexBorrowAsset] / decs[indexCollateral];\n\n      // if totalCollateral is zero (liquidation happens) we will have zero amount (the debt shouldn't be paid)\n      amountOut = totalDebt != 0 && alpha18 * totalCollateral / totalDebt > 1e18\n        ? Math.min(requestedAmount, totalCollateral) * 1e18 / (alpha18 * totalCollateral / totalDebt - 1e18)\n        : 0;\n\n      if (amountOut != 0) {\n        // we shouldn't try to sell amount greater than amount of totalDebt in terms of collateral asset\n        // but we always asks +1% because liquidation results can be different a bit from expected\n        amountOut = (GAP_CONVERSION + DENOMINATOR) * Math.min(amountOut, totalDebt * 1e18 / alpha18) / DENOMINATOR;\n      }\n    }\n\n    return amountOut;\n  }\n\n  /// @notice Repay {amountIn} and get collateral in return, calculate expected amount\n  ///         Take into account possible debt-gap and the fact that the amount of debt may be less than {amountIn}\n  /// @param amountToRepay Max available amount of borrow asset that we can repay\n  /// @return expectedAmountOut Estimated amount of main asset that should be added to balance = collateral - {toSell}\n  function _repayDebt(\n    ITetuConverter converter,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) internal returns (\n    uint expectedAmountOut\n  ) {\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\n\n    // get amount of debt with debt-gap\n    (uint needToRepay,) = converter.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\n\n    // get expected amount without debt-gap\n    uint swappedAmountOut;\n    (expectedAmountOut, swappedAmountOut) = converter.quoteRepay(address(this), collateralAsset, borrowAsset, amountRepay);\n\n    if (expectedAmountOut > swappedAmountOut) {\n      // Following situation is possible\n      //    needToRepay = 100, needToRepayExact = 90 (debt gap is 10)\n      //    1) amountRepay = 80\n      //       expectedAmountOut is calculated for 80, no problems\n      //    2) amountRepay = 99,\n      //       expectedAmountOut is calculated for 90 + 9 (90 - repay, 9 - direct swap)\n      //       expectedAmountOut must be reduced on 9 here (!)\n      expectedAmountOut -= swappedAmountOut;\n    }\n\n    // close the debt\n    _closePositionExact(converter, collateralAsset, borrowAsset, amountRepay, balanceBefore);\n\n    return expectedAmountOut;\n  }\n  //endregion convertAfterWithdraw\n\n  /////////////////////////////////////////////////////////////////////\n  //region Other helpers\n  /////////////////////////////////////////////////////////////////////\n\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\n    return IPriceOracle(IConverterController(converter.controller()).priceOracle()).getAssetPrice(token);\n  }\n\n  function registerIncome(uint assetBefore, uint assetAfter, uint earned, uint lost) internal pure returns (\n    uint _earned,\n    uint _lost\n  ) {\n    if (assetAfter > assetBefore) {\n      earned += assetAfter - assetBefore;\n    } else {\n      lost += assetBefore - assetAfter;\n    }\n    return (earned, lost);\n  }\n  //endregion Other helpers\n\n}\n\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppLib.sol\";\nimport \"../libs/TokenAmountsLib.sol\";\nimport \"../libs/ConverterEntryKinds.sol\";\n\n/// @notice Continuation of ConverterStrategyBaseLib (workaround for size limits)\nlibrary ConverterStrategyBaseLib2 {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  uint internal constant DENOMINATOR = 100_000;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        MAIN LOGIC\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\n  function getAvailableBalances(\n    address[] memory tokens_,\n    uint indexAsset\n  ) external view returns (uint[] memory) {\n    uint len = tokens_.length;\n    uint[] memory amountsToConvert = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this));\n    }\n    return amountsToConvert;\n  }\n\n  /// @notice Send {amount_} of {asset_} to {receiver_} and insurance\n  /// @param asset_ Underlying asset\n  /// @param amount_ Amount of underlying asset to be sent to\n  /// @param receiver_ Performance receiver\n  function sendPerformanceFee(address asset_, uint amount_, address splitter, address receiver_) external returns (\n    uint toPerf,\n    uint toInsurance\n  ) {\n    // read inside lib for reduce contract space in the main contract\n    address insurance = address(ITetuVaultV2(ISplitter(splitter).vault()).insurance());\n\n    toPerf = amount_ / 2;\n    toInsurance = amount_ - toPerf;\n\n    if (toPerf != 0) {\n      IERC20(asset_).safeTransfer(receiver_, toPerf);\n    }\n    if (toInsurance != 0) {\n      IERC20(asset_).safeTransfer(insurance, toInsurance);\n    }\n  }\n\n  function sendTokensToForwarder(\n    address controller_,\n    address splitter_,\n    address[] memory tokens_,\n    uint[] memory amounts_\n  ) external {\n    uint len = tokens_.length;\n    IForwarder forwarder = IForwarder(IController(controller_).forwarder());\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      AppLib.approveIfNeeded(tokens_[i], amounts_[i], address(forwarder));\n    }\n\n    (tokens_, amounts_) = TokenAmountsLib.filterZeroAmounts(tokens_, amounts_);\n    forwarder.registerIncome(tokens_, amounts_, ISplitter(splitter_).vault(), true);\n  }\n\n  /// @notice For each {token_} calculate a part of {amount_} to be used as collateral according to the weights.\n  ///         I.e. we have 300 USDC, we need to split it on 100 USDC, 100 USDT, 100 DAI\n  ///         USDC is main asset, USDT and DAI should be borrowed. We check amounts of USDT and DAI on the balance\n  ///         and return collaterals reduced on that amounts. For main asset, we return full amount always (100 USDC).\n  function getCollaterals(\n    uint amount_,\n    address[] memory tokens_,\n    uint[] memory weights_,\n    uint totalWeight_,\n    uint indexAsset_,\n    IPriceOracle priceOracle\n  ) external view returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    uint len = tokens_.length;\n    tokenAmountsOut = new uint[](len);\n\n    // get token prices and decimals\n    uint[] memory prices = new uint[](len);\n    uint[] memory decs = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\n      prices[i] = priceOracle.getAssetPrice(tokens_[i]);\n    }\n\n    // split the amount on tokens proportionally to the weights\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      uint amountAssetForToken = amount_ * weights_[i] / totalWeight_;\n\n      if (i == indexAsset_) {\n        tokenAmountsOut[i] = amountAssetForToken;\n      } else {\n        // if we have some tokens on balance then we need to use only a part of the collateral\n        uint tokenAmountToBeBorrowed = amountAssetForToken\n        * prices[indexAsset_]\n        * decs[i]\n        / prices[i]\n        / decs[indexAsset_];\n\n        uint tokenBalance = IERC20(tokens_[i]).balanceOf(address(this));\n        if (tokenBalance < tokenAmountToBeBorrowed) {\n          tokenAmountsOut[i] = amountAssetForToken * (tokenAmountToBeBorrowed - tokenBalance) / tokenAmountToBeBorrowed;\n        }\n      }\n    }\n  }\n\n  /// @notice Calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\n  ///         User needs to withdraw {targetAmount_} in main asset.\n  ///         There are two kinds of available liquidity:\n  ///         1) liquidity in the pool - {depositorLiquidity_}\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\n  ///         To withdraw {targetAmount_} we need\n  ///         1) Reconvert converted amounts back to main asset\n  ///         2) IF result amount is not necessary - withdraw some liquidity from the pool\n  ///            and also convert it to the main asset.\n  /// @dev This is a writable function with read-only behavior (because of the quote-call)\n  /// @param targetAmount_ Required amount of main asset to be withdrawn from the strategy; 0 - withdraw all\n  /// @param strategy_ Address of the strategy\n  /// @return resultAmount Amount of liquidity that should be withdrawn from the pool, cannot exceed depositorLiquidity\n  /// @return amountsToConvertOut Amounts of {tokens} that should be converted to the main asset\n  function getLiquidityAmount(\n    uint targetAmount_,\n    address strategy_,\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint investedAssets,\n    uint depositorLiquidity\n  ) external returns (\n    uint resultAmount,\n    uint[] memory amountsToConvertOut\n  ) {\n    bool all = targetAmount_ == 0;\n\n    uint len = tokens.length;\n    amountsToConvertOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n\n      uint balance = IERC20(tokens[i]).balanceOf(address(this));\n      if (balance != 0) {\n        // let's estimate collateral that we received back after repaying balance-amount\n        (uint expectedCollateral,) = converter.quoteRepay(strategy_, tokens[indexAsset], tokens[i], balance);\n\n        if (all || targetAmount_ != 0) {\n          // We always repay WHOLE available balance-amount even if it gives us much more amount then we need.\n          // We cannot repay a part of it because converter doesn't allow to know\n          // what amount should be repaid to get given amount of collateral.\n          // And it's too dangerous to assume that we can calculate this amount\n          // by reducing balance-amount proportionally to expectedCollateral/targetAmount_\n          amountsToConvertOut[i] = balance;\n        }\n\n        targetAmount_ = targetAmount_ > expectedCollateral\n          ? targetAmount_ - expectedCollateral\n          : 0;\n\n        investedAssets = investedAssets > expectedCollateral\n          ? investedAssets - expectedCollateral\n          : 0;\n      }\n    }\n\n    uint liquidityRatioOut = all || investedAssets == 0\n      ? 1e18\n      : ((targetAmount_ == 0)\n        ? 0\n        : 1e18\n        * 101 // add 1% on top...\n        * targetAmount_ / investedAssets // a part of amount that we are going to withdraw\n        / 100 // .. add 1% on top\n      );\n\n    resultAmount = liquidityRatioOut != 0\n      ? Math.min(liquidityRatioOut * depositorLiquidity / 1e18, depositorLiquidity)\n      : 0;\n  }\n\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\n  /// @dev The post-processing is rewards conversion to the main asset\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens_ List of rewards claimed from the internal pool\n  /// @param rewardTokens_ Amounts of rewards claimed from the internal pool\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\n  /// @param amountsOut Amounts of available rewards\n  function  claimConverterRewards(\n    ITetuConverter converter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_,\n    uint[] memory balancesBefore\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    // Rewards from TetuConverter\n    (address[] memory tokensTC, uint[] memory amountsTC) = converter_.claimRewards(address(this));\n\n    // Join arrays and recycle tokens\n    (tokensOut, amountsOut) = TokenAmountsLib.combineArrays(\n      rewardTokens_, rewardAmounts_,\n      tokensTC, amountsTC,\n      // by default, depositor assets have zero amounts here\n      tokens_, new uint[](tokens_.length)\n    );\n\n    // set fresh balances for depositor tokens\n    uint len = tokensOut.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      for (uint j; j < tokens_.length; j = AppLib.uncheckedInc(j)) {\n        if (tokensOut[i] == tokens_[j]) {\n          amountsOut[i] = IERC20(tokens_[j]).balanceOf(address(this)) - balancesBefore[j];\n        }\n      }\n    }\n\n    // filter zero amounts out\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n}\n\n"
    },
    "contracts/strategies/DepositorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @title Abstract base Depositor contract.\n/// @notice Converter strategies should inherit xDepositor.\n/// @notice All communication with external pools should be done at inherited contract\n/// @author bogdoslav\nabstract contract DepositorBase {\n\n  /// @notice Returns pool assets\n  function _depositorPoolAssets() internal virtual view returns (address[] memory assets);\n\n  /// @notice Returns pool token proportions\n  function _depositorPoolWeights() internal virtual view returns (uint[] memory weights, uint total);\n\n  /// @notice Returns pool token reserves\n  function _depositorPoolReserves() internal virtual view returns (uint[] memory reserves);\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() internal virtual view returns (uint);\n\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() internal view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @dev Depositor must care about tokens approval by itself.\n  function _depositorEnter(uint[] memory amountsDesired_) internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  );\n\n  /// @notice Withdraw given lp amount from the pool.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @notice Quotes output for given lp amount from the pool.\n  /// @dev Write function with read-only behavior. BalanceR's depositor requires not-view.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorQuoteExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @dev If pool supports emergency withdraw need to call it for emergencyExit()\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorEmergencyExit() internal virtual returns (uint[] memory amountsOut) {\n    return _depositorExit(_depositorLiquidity());\n  }\n\n  /// @notice Claim all possible rewards.\n  /// @return rewardTokens Claimed token addresses\n  /// @return rewardAmounts Claimed token amounts\n  /// @return depositorBalancesBefore Must have the same length as _depositorPoolAssets and represent balances before claim in the same order\n  function _depositorClaimRewards() internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    uint[] memory depositorBalancesBefore\n  );\n}\n"
    },
    "contracts/strategies/uniswap/Uni3StrategyErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary Uni3StrategyErrors {\n\n  string public constant NEED_REBALANCE = \"U3S-1 Need rebalance\";\n  string public constant WRONG_BALANCE = \"U3S-2 Wrong balance\";\n  string public constant INCORRECT_TICK_RANGE = \"U3S-3 Incorrect tickRange\";\n  string public constant INCORRECT_REBALANCE_TICK_RANGE = \"U3S-4 Incorrect rebalanceTickRange\";\n  string public constant INCORRECT_ASSET = \"U3S-5 Incorrect asset\";\n  string public constant WRONG_FEE = \"U3S-6 Wrong fee\";\n  string public constant WRONG_LIQUIDITY = \"U3S-7 Wrong liquidity\";\n  string public constant WRONG_FILLUP = \"U3S-8 Wrong fillup\";\n  string public constant NO_REBALANCE_NEEDED = \"U3S-9 No rebalance needed\";\n  string public constant BALANCE_LOWER_THAN_FEE = \"U3S-10 Balance lower than fee\";\n  string public constant NOT_CALLBACK_CALLER = \"U3S-11 Not callback caller\";\n\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3ConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./UniswapV3Depositor.sol\";\nimport \"./UniswapV3ConverterStrategyLogicLib.sol\";\nimport \"../../libs/AppPlatforms.sol\";\nimport \"../../interfaces/IRebalancingStrategy.sol\";\nimport \"./Uni3StrategyErrors.sol\";\n\n/// @title Delta-neutral liquidity hedging converter fill-up/swap rebalancing strategy for UniswapV3\n/// @notice This strategy provides delta-neutral liquidity hedging for Uniswap V3 pools. It rebalances the liquidity\n///         by utilizing fill-up and swap methods depending on the range size of the liquidity provided.\n///         It also attempts to cover rebalancing losses with rewards.\n/// @author a17\ncontract UniswapV3ConverterStrategy is UniswapV3Depositor, ConverterStrategyBase, IRebalancingStrategy {\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  string public constant override NAME = \"UniswapV3 Converter Strategy\";\n  string public constant override PLATFORM = AppPlatforms.UNIV3;\n  string public constant override STRATEGY_VERSION = \"1.2.6\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                INIT\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize the strategy with the given parameters.\n  /// @param controller_ The address of the controller.\n  /// @param splitter_ The address of the splitter.\n  /// @param converter_ The address of the converter.\n  /// @param pool_ The address of the pool.\n  /// @param tickRange_ The tick range for the liquidity position.\n  /// @param rebalanceTickRange_ The tick range for rebalancing.\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address pool_,\n    int24 tickRange_,\n    int24 rebalanceTickRange_\n  ) external initializer {\n    __UniswapV3Depositor_init(ISplitter(splitter_).asset(), pool_, tickRange_, rebalanceTickRange_);\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n    UniswapV3ConverterStrategyLogicLib.initStrategyState(state, controller_, converter_);\n\n    // setup specific name for UI\n    strategySpecificName = UniswapV3ConverterStrategyLogicLib.createSpecificName(state);\n    emit StrategySpecificNameChanged(strategySpecificName);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                OPERATOR ACTIONS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Disable fuse for the strategy.\n  function disableFuse() external {\n    StrategyLib.onlyOperators(controller());\n    state.isFuseTriggered = false;\n    state.lastPrice = UniswapV3ConverterStrategyLogicLib.getOracleAssetsPrice(converter, state.tokenA, state.tokenB);\n\n    UniswapV3ConverterStrategyLogicLib.emitDisableFuse();\n  }\n\n  /// @notice Set the fuse threshold for the strategy.\n  /// @param newFuseThreshold The new fuse threshold value.\n  function setFuseThreshold(uint newFuseThreshold) external {\n    StrategyLib.onlyOperators(controller());\n    state.fuseThreshold = newFuseThreshold;\n\n    UniswapV3ConverterStrategyLogicLib.emitNewFuseThreshold(newFuseThreshold);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   METRIC VIEWS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Check if the strategy is ready for hard work.\n  /// @return A boolean indicating if the strategy is ready for hard work.\n  function isReadyToHardWork() override external virtual view returns (bool) {\n    return UniswapV3ConverterStrategyLogicLib.isReadyToHardWork(state, converter);\n  }\n\n  /// @notice Check if the strategy needs rebalancing.\n  /// @return A boolean indicating if the strategy needs rebalancing.\n  function needRebalance() public view returns (bool) {\n    return UniswapV3ConverterStrategyLogicLib.needRebalance(\n      state.isFuseTriggered,\n      state.pool,\n      state.lowerTick,\n      state.upperTick,\n      state.tickSpacing,\n      state.rebalanceTickRange\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   REBALANCE\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev The rebalancing functionality is the core of this strategy.\n  ///      Depending on the size of the range of liquidity provided, the Fill-up or Swap method is used.\n  ///      There is also an attempt to cover rebalancing losses with rewards.\n  function rebalance() external {\n    address _controller = controller();\n    StrategyLib.onlyOperators(_controller);\n\n    /// withdraw all liquidity from pool with adding calculated fees to rebalanceEarned0, rebalanceEarned1\n    /// after disableFuse() liquidity is zero\n    if (state.totalLiquidity > 0) {\n      _depositorEmergencyExit();\n    }\n\n    (\n    uint[] memory tokenAmounts, // _depositorEnter(tokenAmounts) if length == 2\n    bool isNeedFillup\n    ) = UniswapV3ConverterStrategyLogicLib.rebalance(\n      state,\n      converter,\n      _controller,\n      investedAssets()\n    );\n\n    if (tokenAmounts.length == 2) {\n      _depositorEnter(tokenAmounts);\n\n      //add fill-up liquidity part of fill-up is used\n      if (isNeedFillup) {\n        (state.lowerTickFillup, state.upperTickFillup, state.totalLiquidityFillup) = UniswapV3ConverterStrategyLogicLib.addFillup(\n          state.pool,\n          state.lowerTick,\n          state.upperTick,\n          state.tickSpacing,\n          state.rebalanceEarned0,\n          state.rebalanceEarned1\n        );\n      }\n    }\n\n    //updating investedAssets based on new baseAmounts\n    _updateInvestedAssets();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   INTERNAL LOGIC\n  /////////////////////////////////////////////////////////////////////\n\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory /*tokens_*/,\n    uint /*indexAsset_*/\n  ) override internal virtual returns (\n    uint[] memory tokenAmounts\n  ) {\n    require(!needRebalance(), Uni3StrategyErrors.NEED_REBALANCE);\n\n    tokenAmounts = new uint[](2);\n    uint spentCollateral;\n\n    bytes memory entryData = UniswapV3ConverterStrategyLogicLib.getEntryData(\n      state.pool,\n      state.lowerTick,\n      state.upperTick,\n      state.depositorSwapTokens\n    );\n\n    AppLib.approveIfNeeded(state.tokenA, amount_, address(tetuConverter_));\n    (spentCollateral, tokenAmounts[1]) = ConverterStrategyBaseLib.openPosition(\n      tetuConverter_,\n      entryData,\n      state.tokenA,\n      state.tokenB,\n      amount_,\n      0\n    );\n\n    tokenAmounts[0] = amount_ - spentCollateral;\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  /// @return earned The amount of earned rewards.\n  /// @return lost The amount of lost rewards.\n  /// @return assetBalanceAfterClaim The asset balance after claiming rewards.\n  function _handleRewards() override internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    earned = UniswapV3ConverterStrategyLogicLib.calcEarned(state);\n    (address[] memory rewardTokens, uint[] memory amounts) = _claim();\n    _rewardsLiquidation(rewardTokens, amounts);\n\n    if (state.rebalanceLost > 0) {\n      lost = state.rebalanceLost;\n      state.rebalanceLost = 0;\n    }\n    return (earned, lost, AppLib.balance(asset));\n  }\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amount_ The amount to be deposited.\n  /// @param updateTotalAssetsBeforeInvest_ A boolean indicating if the total assets should be updated before investing.\n  /// @return strategyLoss Loss should be covered from Insurance\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    uint strategyLoss\n  ) {\n    if (state.isFuseTriggered) {\n      uint[] memory tokenAmounts = new uint[](2);\n      tokenAmounts[0] = amount_;\n      emit OnDepositorEnter(tokenAmounts, tokenAmounts);\n      return 0;\n    } else {\n      return super._depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n    }\n  }\n\n  function _beforeWithdraw(uint /*amount*/) internal view override {\n    require(!needRebalance(), Uni3StrategyErrors.NEED_REBALANCE);\n  }\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3ConverterStrategyLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./UniswapV3Lib.sol\";\nimport \"./UniswapV3DebtLib.sol\";\nimport \"./Uni3StrategyErrors.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol\";\n\nlibrary UniswapV3ConverterStrategyLogicLib {\n\n  //////////////////////////////////////////\n  //            CONSTANTS\n  //////////////////////////////////////////\n\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_STABLE = 100;\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE = 500;\n  uint internal constant HARD_WORK_USD_FEE_THRESHOLD = 100;\n  /// @dev 0.5% by default\n  uint public constant DEFAULT_FUSE_THRESHOLD = 5e15;\n\n  //////////////////////////////////////////\n  //            EVENTS\n  //////////////////////////////////////////\n\n  event FuseTriggered();\n  event Rebalanced();\n  event DisableFuse();\n  event NewFuseThreshold(uint newFuseThreshold);\n  event UniV3FeesClaimed(uint fee0, uint fee1);\n\n  //////////////////////////////////////////\n  //            STRUCTURES\n  //////////////////////////////////////////\n\n  struct State {\n    address tokenA;\n    address tokenB;\n    IUniswapV3Pool pool;\n    int24 tickSpacing;\n    bool fillUp;\n    bool isStablePool;\n    int24 lowerTick;\n    int24 upperTick;\n    int24 lowerTickFillup;\n    int24 upperTickFillup;\n    int24 rebalanceTickRange;\n    bool depositorSwapTokens;\n    uint128 totalLiquidity;\n    uint128 totalLiquidityFillup;\n    uint rebalanceEarned0;\n    uint rebalanceEarned1;\n    uint rebalanceLost;\n    bool isFuseTriggered;\n    uint fuseThreshold;\n    uint lastPrice;\n  }\n\n  struct TryCoverLossParams {\n    IUniswapV3Pool pool;\n    address tokenA;\n    address tokenB;\n    bool depositorSwapTokens;\n    uint fee0;\n    uint fee1;\n    uint oldInvestedAssets;\n  }\n\n  struct RebalanceLocalVariables {\n    int24 upperTick;\n    int24 lowerTick;\n    int24 tickSpacing;\n    IUniswapV3Pool pool;\n    address tokenA;\n    address tokenB;\n    uint lastPrice;\n    uint fuseThreshold;\n    bool depositorSwapTokens;\n    uint rebalanceEarned0;\n    uint rebalanceEarned1;\n\n    uint newRebalanceEarned0;\n    uint newRebalanceEarned1;\n    uint notCoveredLoss;\n    int24 newLowerTick;\n    int24 newUpperTick;\n\n    bool fillUp;\n    bool isStablePool;\n    uint newPrice;\n  }\n\n  //////////////////////////////////////////\n  //            HELPERS\n  //////////////////////////////////////////\n\n  function emitDisableFuse() external {\n    emit DisableFuse();\n  }\n\n  function emitNewFuseThreshold(uint value) external {\n    emit NewFuseThreshold(value);\n  }\n\n  /// @dev Gets the liquidator swap slippage based on the pool type (stable or volatile).\n  /// @param pool The IUniswapV3Pool instance.\n  /// @return The liquidator swap slippage percentage.\n  function _getLiquidatorSwapSlippage(IUniswapV3Pool pool) internal view returns (uint) {\n    return isStablePool(pool) ? LIQUIDATOR_SWAP_SLIPPAGE_STABLE : LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE;\n  }\n\n  /// @notice Check if the given pool is a stable pool.\n  /// @param pool The Uniswap V3 pool.\n  /// @return A boolean indicating if the pool is stable.\n  function isStablePool(IUniswapV3Pool pool) public view returns (bool) {\n    return pool.fee() == 100;\n  }\n\n  /// @notice Get the token amounts held by the contract excluding earned parts.\n  /// @param state The state of the pool.\n  /// @return amountA The balance of tokenA.\n  /// @return amountB The balance of tokenB.\n  function getTokenAmounts(State storage state) external view returns (uint amountA, uint amountB) {\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    amountA = AppLib.balance(state.tokenA);\n    amountB = AppLib.balance(state.tokenB);\n\n    uint earned0 = (depositorSwapTokens ? state.rebalanceEarned1 : state.rebalanceEarned0);\n    uint earned1 = (depositorSwapTokens ? state.rebalanceEarned0 : state.rebalanceEarned1);\n\n    require(amountA >= earned0 && amountB >= earned1, Uni3StrategyErrors.WRONG_BALANCE);\n    amountA -= earned0;\n    amountB -= earned1;\n  }\n\n  /// @notice Get the price ratio of the two given tokens from the oracle.\n  /// @param converter The Tetu converter.\n  /// @param tokenA The first token address.\n  /// @param tokenB The second token address.\n  /// @return The price ratio of the two tokens.\n  function getOracleAssetsPrice(ITetuConverter converter, address tokenA, address tokenB) public view returns (uint) {\n    IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n    uint priceA = oracle.getAssetPrice(tokenA);\n    uint priceB = oracle.getAssetPrice(tokenB);\n    return priceB * 1e18 / priceA;\n  }\n\n  /// @notice Check if the fuse is enabled based on the price difference and fuse threshold.\n  /// @param oldPrice The old price.\n  /// @param newPrice The new price.\n  /// @param fuseThreshold The fuse threshold.\n  /// @return A boolean indicating if the fuse is enabled.\n  function isEnableFuse(uint oldPrice, uint newPrice, uint fuseThreshold) internal pure returns (bool) {\n    return oldPrice > newPrice ? (oldPrice - newPrice) > fuseThreshold : (newPrice - oldPrice) > fuseThreshold;\n  }\n\n  function initStrategyState(State storage state, address controller_, address converter) external {\n    address liquidator = IController(controller_).liquidator();\n    IERC20(state.tokenA).approve(liquidator, type(uint).max);\n    IERC20(state.tokenB).approve(liquidator, type(uint).max);\n\n    /// for ultra-wide ranges we use Swap rebalancing strategy and Fill-up for other\n    /// upperTick always greater then lowerTick\n    state.fillUp = state.upperTick - state.lowerTick >= 4 * state.tickSpacing;\n\n    if (isStablePool(state.pool)) {\n      /// for stable pools fuse can be enabled\n      state.isStablePool = true;\n      state.fuseThreshold = DEFAULT_FUSE_THRESHOLD;\n      emit NewFuseThreshold(DEFAULT_FUSE_THRESHOLD);\n      state.lastPrice = getOracleAssetsPrice(ITetuConverter(converter), state.tokenA, state.tokenB);\n    }\n  }\n\n  function createSpecificName(State storage state) external view returns (string memory) {\n    return string(abi.encodePacked(\"UniV3 \", IERC20Metadata(state.tokenA).symbol(), \"/\", IERC20Metadata(state.tokenB).symbol(), \"-\", StringLib._toString(state.pool.fee())));\n  }\n\n  //////////////////////////////////////////\n  //            CALCULATIONS\n  //////////////////////////////////////////\n\n  /// @notice Calculate the initial values for a Uniswap V3 pool Depositor.\n  /// @param pool The Uniswap V3 pool to get the initial values from.\n  /// @param tickRange_ The tick range for the pool.\n  /// @param rebalanceTickRange_ The rebalance tick range for the pool.\n  /// @param asset_ Underlying asset of the depositor.\n  /// @return tickSpacing The tick spacing for the pool.\n  /// @return lowerTick The lower tick value for the pool.\n  /// @return upperTick The upper tick value for the pool.\n  /// @return tokenA The address of the first token in the pool.\n  /// @return tokenB The address of the second token in the pool.\n  /// @return _depositorSwapTokens A boolean representing whether to use reverse tokens for pool.\n  function calcInitialDepositorValues(\n    IUniswapV3Pool pool,\n    int24 tickRange_,\n    int24 rebalanceTickRange_,\n    address asset_\n  ) external view returns (\n    int24 tickSpacing,\n    int24 lowerTick,\n    int24 upperTick,\n    address tokenA,\n    address tokenB,\n    bool _depositorSwapTokens\n  ) {\n    tickSpacing = UniswapV3Lib.getTickSpacing(pool.fee());\n    if (tickRange_ != 0) {\n      require(tickRange_ == tickRange_ / tickSpacing * tickSpacing, Uni3StrategyErrors.INCORRECT_TICK_RANGE);\n      require(rebalanceTickRange_ == rebalanceTickRange_ / tickSpacing * tickSpacing, Uni3StrategyErrors.INCORRECT_REBALANCE_TICK_RANGE);\n    }\n    (lowerTick, upperTick) = UniswapV3DebtLib.calcTickRange(pool, tickRange_, tickSpacing);\n    require(asset_ == pool.token0() || asset_ == pool.token1(), Uni3StrategyErrors.INCORRECT_ASSET);\n    if (asset_ == pool.token0()) {\n      tokenA = pool.token0();\n      tokenB = pool.token1();\n      _depositorSwapTokens = false;\n    } else {\n      tokenA = pool.token1();\n      tokenB = pool.token0();\n      _depositorSwapTokens = true;\n    }\n  }\n\n  /// @dev Calculates the new fee amounts and the not covered loss, if any, after attempting to cover losses.\n  /// @param p The TryCoverLossParams instance containing required parameters.\n  /// @param collateralAmount The current collateral amount.\n  /// @return newFee0 The new fee amount for tokenA.\n  /// @return newFee1 The new fee amount for tokenB.\n  /// @return notCoveredLoss The amount of loss that could not be covered by fees.\n  function _calculateCoverLoss(\n    TryCoverLossParams memory p,\n    uint collateralAmount\n  ) internal view returns (uint newFee0, uint newFee1, uint notCoveredLoss) {\n    notCoveredLoss = 0;\n\n    newFee0 = p.fee0;\n    newFee1 = p.fee1;\n    uint feeA = p.depositorSwapTokens ? newFee1 : newFee0;\n    uint feeB = p.depositorSwapTokens ? newFee0 : newFee1;\n\n    uint newInvestedAssets = collateralAmount + AppLib.balance(p.tokenA) - feeA;\n    if (newInvestedAssets < p.oldInvestedAssets) {\n      // we have lost\n      uint lost = p.oldInvestedAssets - newInvestedAssets;\n\n      if (lost <= feeA) {\n        // feeA is enough to cover lost\n        if (p.depositorSwapTokens) {\n          newFee1 -= lost;\n        } else {\n          newFee0 -= lost;\n        }\n      } else {\n        // feeA is not enough to cover lost\n\n        if (p.depositorSwapTokens) {\n          newFee1 = 0;\n        } else {\n          newFee0 = 0;\n        }\n\n        uint feeBinTermOfA;\n        if (feeB > 0) {\n\n          feeBinTermOfA = UniswapV3Lib.getPrice(address(p.pool), p.tokenB) * feeB / 10 ** IERC20Metadata(p.tokenB).decimals();\n\n          if (feeA + feeBinTermOfA > lost) {\n            if (p.depositorSwapTokens) {\n              newFee0 = (feeA + feeBinTermOfA - lost) * UniswapV3Lib.getPrice(address(p.pool), p.tokenA) / 10 ** IERC20Metadata(p.tokenA).decimals();\n            } else {\n              newFee1 = (feeA + feeBinTermOfA - lost) * UniswapV3Lib.getPrice(address(p.pool), p.tokenA) / 10 ** IERC20Metadata(p.tokenA).decimals();\n            }\n          } else {\n            notCoveredLoss = lost - feeA - feeBinTermOfA;\n            if (p.depositorSwapTokens) {\n              newFee0 = 0;\n            } else {\n              newFee1 = 0;\n            }\n          }\n        } else {\n          notCoveredLoss = lost - feeA;\n        }\n      }\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Pool info\n  //////////////////////////////////////////\n\n  /// @notice Retrieve the reserves of a Uniswap V3 pool managed by this contract.\n  /// @param state The State storage containing the pool's information.\n  /// @return reserves An array containing the reserve amounts of the contract owned liquidity.\n  function getPoolReserves(State storage state) external view returns (uint[] memory reserves) {\n    reserves = new uint[](2);\n    (uint160 sqrtRatioX96, , , , , ,) = state.pool.slot0();\n\n    (reserves[0], reserves[1]) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTick,\n      state.upperTick,\n      state.totalLiquidity\n    );\n\n    (uint amount0CurrentFillup, uint amount1CurrentFillup) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTickFillup,\n      state.upperTickFillup,\n      state.totalLiquidityFillup\n    );\n\n    reserves[0] += amount0CurrentFillup;\n    reserves[1] += amount1CurrentFillup;\n\n    if (state.depositorSwapTokens) {\n      (reserves[0], reserves[1]) = (reserves[1], reserves[0]);\n    }\n  }\n\n  /// @notice Retrieve the fees generated by a Uniswap V3 pool managed by this contract.\n  /// @param state The State storage containing the pool's information.\n  /// @return fee0 The fees generated for the first token in the pool.\n  /// @return fee1 The fees generated for the second token in the pool.\n  function getFees(State storage state) public view returns (uint fee0, uint fee1) {\n    UniswapV3Lib.PoolPosition memory position = UniswapV3Lib.PoolPosition(address(state.pool), state.lowerTick, state.upperTick, state.totalLiquidity, address(this));\n    (fee0, fee1) = UniswapV3Lib.getFees(position);\n    UniswapV3Lib.PoolPosition memory positionFillup = UniswapV3Lib.PoolPosition(address(state.pool), state.lowerTickFillup, state.upperTickFillup, state.totalLiquidityFillup, address(this));\n    (uint fee0Fillup, uint fee1Fillup) = UniswapV3Lib.getFees(positionFillup);\n    fee0 += fee0Fillup;\n    fee1 += fee1Fillup;\n  }\n\n  /// @notice Estimate the exit amounts for a given liquidity amount in a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool to quote the exit amounts for.\n  /// @param lowerTick The lower tick value for the pool.\n  /// @param upperTick The upper tick value for the pool.\n  /// @param lowerTickFillup The lower tick value for the fillup range in the pool.\n  /// @param upperTickFillup The upper tick value for the fillup range in the pool.\n  /// @param liquidity The current liquidity in the pool.\n  /// @param liquidityFillup The current liquidity in the fillup range.\n  /// @param liquidityAmountToExit The amount of liquidity to exit.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsOut An array containing the estimated exit amounts for each token in the pool.\n  function quoteExit(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 lowerTickFillup,\n    int24 upperTickFillup,\n    uint128 liquidity,\n    uint128 liquidityFillup,\n    uint128 liquidityAmountToExit,\n    bool _depositorSwapTokens\n  ) external view returns (uint[] memory amountsOut) {\n    amountsOut = new uint[](2);\n    (uint160 sqrtRatioX96, , , , , ,) = pool.slot0();\n\n    (amountsOut[0], amountsOut[1]) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      lowerTick,\n      upperTick,\n      liquidityAmountToExit\n    );\n\n    if (liquidity > 0 && liquidityFillup > 0) {\n      (uint amountOut0Fillup, uint amountOut1Fillup) = UniswapV3Lib.getAmountsForLiquidity(\n        sqrtRatioX96,\n        lowerTickFillup,\n        upperTickFillup,\n        uint128(uint(liquidityFillup) * uint(liquidityAmountToExit) / uint(liquidity))\n      );\n\n      amountsOut[0] += amountOut0Fillup;\n      amountsOut[1] += amountOut1Fillup;\n    }\n\n    if (_depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  /// @notice Determine if the pool needs to be rebalanced.\n  /// @return A boolean indicating if the pool needs to be rebalanced.\n  function needRebalance(\n    bool isFuseTriggered,\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing,\n    int24 rebalanceTickRange\n  ) public view returns (bool) {\n    if (isFuseTriggered) {\n      return false;\n    }\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (upperTick - lowerTick == tickSpacing) {\n      return tick < lowerTick || tick >= upperTick;\n    } else {\n      int24 halfRange = (upperTick - lowerTick) / 2;\n      int24 oldMedianTick = lowerTick + halfRange;\n      if (tick > oldMedianTick) {\n        return tick - oldMedianTick >= rebalanceTickRange;\n      }\n      return oldMedianTick - tick > rebalanceTickRange;\n    }\n  }\n\n  /// @notice Get entry data for a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool instance.\n  /// @param lowerTick The lower tick of the pool's main range.\n  /// @param upperTick The upper tick of the pool's main range.\n  /// @param depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return entryData A byte array containing the entry data for the pool.\n  function getEntryData(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    bool depositorSwapTokens\n  ) public view returns (bytes memory entryData) {\n    return UniswapV3DebtLib.getEntryData(pool, lowerTick, upperTick, depositorSwapTokens);\n  }\n\n  //////////////////////////////////////////\n  //            Joins to the pool\n  //////////////////////////////////////////\n\n  /// @notice Enter the pool and provide liquidity with desired token amounts.\n  /// @param pool The Uniswap V3 pool to provide liquidity to.\n  /// @param lowerTick The lower tick value for the pool.\n  /// @param upperTick The upper tick value for the pool.\n  /// @param amountsDesired_ An array containing the desired amounts of tokens to provide liquidity.\n  /// @param totalLiquidity The current total liquidity in the pool.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsConsumed An array containing the consumed amounts for each token in the pool.\n  /// @return liquidityOut The amount of liquidity added to the pool.\n  /// @return totalLiquidityNew The updated total liquidity after providing liquidity.\n  function enter(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    uint[] memory amountsDesired_,\n    uint128 totalLiquidity,\n    bool _depositorSwapTokens\n  ) external returns (uint[] memory amountsConsumed, uint liquidityOut, uint128 totalLiquidityNew) {\n    amountsConsumed = new uint[](2);\n\n    if (amountsDesired_[1] > 0) {\n      if (_depositorSwapTokens) {\n        (amountsDesired_[0], amountsDesired_[1]) = (amountsDesired_[1], amountsDesired_[0]);\n      }\n      uint128 newLiquidity;\n      (amountsConsumed[0], amountsConsumed[1], newLiquidity) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTick, upperTick, amountsDesired_[0], amountsDesired_[1]);\n      pool.mint(address(this), lowerTick, upperTick, newLiquidity, \"\");\n      liquidityOut = uint(newLiquidity);\n      totalLiquidityNew = totalLiquidity + newLiquidity;\n      if (_depositorSwapTokens) {\n        (amountsConsumed[0], amountsConsumed[1]) = (amountsConsumed[1], amountsConsumed[0]);\n      }\n    }\n\n    return (amountsConsumed, liquidityOut, totalLiquidityNew);\n  }\n\n  /// @notice Add liquidity to a Uniswap V3 pool in a specified tick range according fill up rules.\n  /// @param pool The Uniswap V3 pool to add liquidity to.\n  /// @param lowerTick The current lower tick value for the pool.\n  /// @param upperTick The current upper tick value for the pool.\n  /// @param tickSpacing The tick spacing for the pool.\n  /// @param fee0 The fee amount for the first token in the pool.\n  /// @param fee1 The fee amount for the second token in the pool.\n  /// @return lowerTickFillup The lower tick value for the new liquidity range.\n  /// @return upperTickFillup The upper tick value for the new liquidity range.\n  /// @return liquidityOutFillup The liquidity amount added to the new range.\n  function addFillup(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing,\n    uint fee0,\n    uint fee1\n  ) external returns (int24 lowerTickFillup, int24 upperTickFillup, uint128 liquidityOutFillup) {\n    uint balance0 = AppLib.balance(pool.token0());\n    uint balance1 = AppLib.balance(pool.token1());\n\n    require(balance0 >= fee0 && balance1 >= fee1, Uni3StrategyErrors.WRONG_FEE);\n    balance0 -= fee0;\n    balance1 -= fee1;\n\n    if (balance0 > 0 || balance1 > 0) {\n      (, int24 tick, , , , ,) = pool.slot0();\n      if (balance0 > balance1 * UniswapV3Lib.getPrice(address(pool), pool.token1()) / 10 ** IERC20Metadata(pool.token1()).decimals()) {\n        // add token0 to half range\n        lowerTickFillup = tick / tickSpacing * tickSpacing + tickSpacing;\n        upperTickFillup = upperTick;\n        (,, liquidityOutFillup) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTickFillup, upperTickFillup, balance0, 0);\n        pool.mint(address(this), lowerTickFillup, upperTickFillup, liquidityOutFillup, \"\");\n      } else {\n        lowerTickFillup = lowerTick;\n        upperTickFillup = tick / tickSpacing * tickSpacing - tickSpacing;\n        (,, liquidityOutFillup) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTickFillup, upperTickFillup, 0, balance1);\n        pool.mint(address(this), lowerTickFillup, upperTickFillup, liquidityOutFillup, \"\");\n      }\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Exit from the pool\n  //////////////////////////////////////////\n\n\n  /// @notice Exit the pool and collect tokens proportional to the liquidity amount to exit.\n  /// @param pool The Uniswap V3 pool to exit from.\n  /// @param lowerTick The lower tick value for the pool.\n  /// @param upperTick The upper tick value for the pool.\n  /// @param lowerTickFillup The lower tick value for the fillup range in the pool.\n  /// @param upperTickFillup The upper tick value for the fillup range in the pool.\n  /// @param liquidity The current liquidity in the pool.\n  /// @param liquidityFillup The current liquidity in the fillup range.\n  /// @param liquidityAmountToExit The amount of liquidity to exit.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsOut An array containing the collected amounts for each token in the pool.\n  /// @return totalLiquidity The updated total liquidity after the exit.\n  /// @return totalLiquidityFillup The updated total liquidity in the fillup range after the exit.\n  function exit(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 lowerTickFillup,\n    int24 upperTickFillup,\n    uint128 liquidity,\n    uint128 liquidityFillup,\n    uint128 liquidityAmountToExit,\n    bool _depositorSwapTokens\n  ) external returns (uint[] memory amountsOut, uint128 totalLiquidity, uint128 totalLiquidityFillup) {\n    totalLiquidityFillup = 0;\n\n    require(liquidity >= liquidityAmountToExit, Uni3StrategyErrors.WRONG_LIQUIDITY);\n\n    amountsOut = new uint[](2);\n    (amountsOut[0], amountsOut[1]) = pool.burn(lowerTick, upperTick, liquidityAmountToExit);\n    // all fees will be collected but not returned in amountsOut\n    pool.collect(\n      address(this),\n      lowerTick,\n      upperTick,\n      type(uint128).max,\n      type(uint128).max\n    );\n\n    // remove proportional part of fillup liquidity\n    if (liquidityFillup != 0) {\n      uint128 toRemoveFillUpAmount = uint128(uint(liquidityFillup) * uint(liquidityAmountToExit) / uint(liquidity));\n      (uint amountsOutFillup0, uint amountsOutFillup1) = pool.burn(lowerTickFillup, upperTickFillup, toRemoveFillUpAmount);\n      pool.collect(\n        address(this),\n        lowerTickFillup,\n        upperTickFillup,\n        type(uint128).max,\n        type(uint128).max\n      );\n      amountsOut[0] += amountsOutFillup0;\n      amountsOut[1] += amountsOutFillup1;\n\n      require(liquidityFillup >= toRemoveFillUpAmount, Uni3StrategyErrors.WRONG_FILLUP);\n      totalLiquidityFillup = liquidityFillup - toRemoveFillUpAmount;\n    }\n\n    totalLiquidity = liquidity - liquidityAmountToExit;\n\n    if (_depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Claim\n  //////////////////////////////////////////\n\n  /// @notice Claim rewards from the Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool instance.\n  /// @param lowerTick The lower tick of the pool's main range.\n  /// @param upperTick The upper tick of the pool's main range.\n  /// @param lowerTickFillup The lower tick of the pool's fill-up range.\n  /// @param upperTickFillup The upper tick of the pool's fill-up range.\n  /// @param rebalanceEarned0 The amount of token0 earned from rebalancing.\n  /// @param rebalanceEarned1 The amount of token1 earned from rebalancing.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsOut An array containing the amounts of token0 and token1 claimed as rewards.\n  function claimRewards(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 lowerTickFillup,\n    int24 upperTickFillup,\n    uint rebalanceEarned0,\n    uint rebalanceEarned1,\n    bool _depositorSwapTokens,\n    address[] memory tokensOut,\n    uint128 liquidity,\n    uint128 liquidityFillup\n  ) external returns (uint[] memory amountsOut, uint[] memory balancesBefore) {\n\n    balancesBefore = new uint[](2);\n    for (uint i = 0; i < tokensOut.length; i++) {\n      balancesBefore[i] = IERC20(tokensOut[i]).balanceOf(address(this));\n    }\n\n    amountsOut = new uint[](2);\n    if (liquidity > 0) {\n      pool.burn(lowerTick, upperTick, 0);\n      (amountsOut[0], amountsOut[1]) = pool.collect(\n        address(this),\n        lowerTick,\n        upperTick,\n        type(uint128).max,\n        type(uint128).max\n      );\n    }\n    if (liquidityFillup > 0) {\n      pool.burn(lowerTickFillup, upperTickFillup, 0);\n      (uint fillup0, uint fillup1) = pool.collect(\n        address(this),\n        lowerTickFillup,\n        upperTickFillup,\n        type(uint128).max,\n        type(uint128).max\n      );\n      amountsOut[0] += fillup0;\n      amountsOut[1] += fillup1;\n    }\n\n    emit UniV3FeesClaimed(amountsOut[0], amountsOut[1]);\n\n    amountsOut[0] += rebalanceEarned0;\n    amountsOut[1] += rebalanceEarned1;\n    if (_depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  function isReadyToHardWork(State storage state, ITetuConverter converter) external view returns (bool isReady) {\n    // check claimable amounts and compare with thresholds\n    (uint fee0, uint fee1) = getFees(state);\n    fee0 += state.rebalanceEarned0;\n    fee1 += state.rebalanceEarned1;\n\n    if (state.depositorSwapTokens) {\n      (fee0, fee1) = (fee1, fee0);\n    }\n\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n    uint priceA = oracle.getAssetPrice(tokenA);\n    uint priceB = oracle.getAssetPrice(tokenB);\n\n    uint fee0USD = fee0 * priceA / 1e18;\n    uint fee1USD = fee1 * priceB / 1e18;\n\n    return fee0USD > HARD_WORK_USD_FEE_THRESHOLD || fee1USD > HARD_WORK_USD_FEE_THRESHOLD;\n  }\n\n  //////////////////////////////////////////\n  //            Rebalance\n  //////////////////////////////////////////\n\n  /// @dev Rebalances the current position, adjusts the tick range, and attempts to cover loss with pool rewards.\n  /// @param state The State storage object.\n  /// @param converter The TetuConverter contract.\n  /// @param controller The Tetu controller address.\n  /// @param oldInvestedAssets The amount of invested assets before rebalancing.\n  /// @return tokenAmounts The token amounts for deposit (if length != 2 then do nothing).\n  /// @return isNeedFillup Indicates if fill-up is required after rebalancing.\n  function rebalance(\n    State storage state,\n    ITetuConverter converter,\n    address controller,\n    uint oldInvestedAssets\n  ) external returns (\n    uint[] memory tokenAmounts, // _depositorEnter(tokenAmounts) if length == 2\n    bool isNeedFillup\n  ) {\n    tokenAmounts = new uint[](0);\n    isNeedFillup = false;\n\n    RebalanceLocalVariables memory vars = RebalanceLocalVariables({\n      upperTick: state.upperTick,\n      lowerTick: state.lowerTick,\n      tickSpacing: state.tickSpacing,\n      pool: state.pool,\n      tokenA: state.tokenA,\n      tokenB: state.tokenB,\n      lastPrice: state.lastPrice,\n      fuseThreshold: state.fuseThreshold,\n      depositorSwapTokens: state.depositorSwapTokens,\n      rebalanceEarned0: state.rebalanceEarned0,\n      rebalanceEarned1: state.rebalanceEarned1,\n    // setup initial values\n      newRebalanceEarned0: 0,\n      newRebalanceEarned1: 0,\n      notCoveredLoss: 0,\n      newLowerTick: 0,\n      newUpperTick: 0,\n      fillUp: state.fillUp,\n      isStablePool: state.isStablePool,\n      newPrice: 0\n    });\n\n    require(needRebalance(\n      state.isFuseTriggered,\n      vars.pool,\n      vars.lowerTick,\n      vars.upperTick,\n      vars.tickSpacing,\n      state.rebalanceTickRange\n    ), Uni3StrategyErrors.NO_REBALANCE_NEEDED);\n\n    vars.newPrice = getOracleAssetsPrice(converter, vars.tokenA, vars.tokenB);\n\n    // for rebalance after emergencyExit() case\n    uint b0 = AppLib.balance(vars.depositorSwapTokens ? vars.tokenB : vars.tokenA);\n    uint b1 = AppLib.balance(vars.depositorSwapTokens ? vars.tokenA : vars.tokenB);\n    if (b0 < vars.rebalanceEarned0) {\n      vars.rebalanceEarned0 = b0;\n      state.rebalanceEarned0 = b0;\n    }\n    if (b1 < vars.rebalanceEarned1) {\n      vars.rebalanceEarned1 = b1;\n      state.rebalanceEarned1 = b1;\n    }\n\n    if (vars.isStablePool && isEnableFuse(vars.lastPrice, vars.newPrice, vars.fuseThreshold)) {\n      /// enabling fuse: close debt and stop providing liquidity\n      state.isFuseTriggered = true;\n      emit FuseTriggered();\n\n      UniswapV3DebtLib.closeDebt(\n        converter,\n        controller,\n        vars.pool,\n        vars.tokenA,\n        vars.tokenB,\n        vars.depositorSwapTokens,\n        vars.rebalanceEarned0,\n        vars.rebalanceEarned1,\n        _getLiquidatorSwapSlippage(vars.pool)\n      );\n    } else {\n      /// rebalancing debt with passing rebalanceEarned0, rebalanceEarned1 that will remain untouched\n      /// setting new tick range\n      UniswapV3DebtLib.rebalanceDebt(\n        converter,\n        controller,\n        state,\n        _getLiquidatorSwapSlippage(vars.pool)\n      );\n\n      /// trying to cover rebalance loss (IL + not hedged part of tokenB + swap cost) by pool rewards\n      (vars.newRebalanceEarned0, vars.newRebalanceEarned1, vars.notCoveredLoss) = _calculateCoverLoss(\n        TryCoverLossParams(\n          vars.pool,\n          vars.tokenA,\n          vars.tokenB,\n          vars.depositorSwapTokens,\n          vars.rebalanceEarned0,\n          vars.rebalanceEarned1,\n          oldInvestedAssets\n        ),\n        UniswapV3DebtLib.getDebtTotalCollateralAmountOut(converter, vars.tokenA, vars.tokenB)\n      );\n      state.rebalanceEarned0 = vars.newRebalanceEarned0;\n      state.rebalanceEarned1 = vars.newRebalanceEarned1;\n      if (vars.notCoveredLoss != 0) {\n        state.rebalanceLost += vars.notCoveredLoss;\n      }\n\n      tokenAmounts = new uint[](2);\n      tokenAmounts[0] = AppLib.balance(vars.tokenA) - (vars.depositorSwapTokens ? vars.newRebalanceEarned1 : vars.newRebalanceEarned0);\n      tokenAmounts[1] = AppLib.balance(vars.tokenB) - (vars.depositorSwapTokens ? vars.newRebalanceEarned0 : vars.newRebalanceEarned1);\n\n      if (vars.fillUp) {\n        isNeedFillup = true;\n      }\n    }\n\n    // need to update last price only for stables coz only stables have fuse mechanic\n    if (vars.isStablePool) {\n      state.lastPrice = vars.newPrice;\n    }\n\n    emit Rebalanced();\n  }\n\n  function calcEarned(State storage state) external view returns (uint) {\n    address tokenB = state.tokenB;\n\n    (uint fee0, uint fee1) = getFees(state);\n    fee0 += state.rebalanceEarned0;\n    fee1 += state.rebalanceEarned1;\n\n    if (state.depositorSwapTokens) {\n      (fee0, fee1) = (fee1, fee0);\n    }\n\n    uint feeBinTermOfA = UniswapV3Lib.getPrice(address(state.pool), tokenB) * fee1 / 10 ** IERC20Metadata(tokenB).decimals();\n\n    return fee0 + feeBinTermOfA;\n  }\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3DebtLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBaseLib.sol\";\nimport \"./UniswapV3Lib.sol\";\nimport \"./Uni3StrategyErrors.sol\";\nimport \"./UniswapV3ConverterStrategyLogicLib.sol\";\n\nlibrary UniswapV3DebtLib {\n\n  //////////////////////////////////////////\n  //            CONSTANTS\n  //////////////////////////////////////////\n\n  uint internal constant SELL_GAP = 100;\n  /// @dev should be placed local, probably will be adjusted later\n  uint internal constant BORROW_PERIOD_ESTIMATION = 30 days / 2;\n\n  //////////////////////////////////////////\n  //            STRUCTURES\n  //////////////////////////////////////////\n\n  struct RebalanceDebtFillUpLocalVariables {\n    uint debtAmount;\n    uint availableBalanceTokenA;\n    uint availableBalanceTokenB;\n    uint needToBorrowOrFreeFromBorrow;\n  }\n\n  //////////////////////////////////////////\n  //            MAIN LOGIC\n  //////////////////////////////////////////\n\n  /// @dev Returns the total collateral amount out for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  /// @return totalCollateralAmountOut The total collateral amount out for the token pair.\n  function getDebtTotalCollateralAmountOut(ITetuConverter tetuConverter, address tokenA, address tokenB) internal returns (uint totalCollateralAmountOut) {\n    (, totalCollateralAmountOut) = tetuConverter.getDebtAmountCurrent(address(this), tokenA, tokenB, false);\n  }\n\n  /// @dev Returns the total debt amount out for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  /// @return totalDebtAmountOut The total debt amount out for the token pair.\n  function getDebtTotalDebtAmountOut(ITetuConverter tetuConverter, address tokenA, address tokenB) internal returns (uint totalDebtAmountOut) {\n    (totalDebtAmountOut,) = tetuConverter.getDebtAmountCurrent(address(this), tokenA, tokenB, true);\n  }\n\n  /// @dev Closes the debt positions for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param controller The controller address.\n  /// @param pool The IUniswapV3Pool instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  /// @param depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @param fee0 The fee amount for tokenA.\n  /// @param fee1 The fee amount for tokenB.\n  function closeDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    IUniswapV3Pool pool,\n    address tokenA,\n    address tokenB,\n    bool depositorSwapTokens,\n    uint fee0,\n    uint fee1,\n    uint liquidatorSwapSlippage\n  ) internal {\n    uint tokenAFee = depositorSwapTokens ? fee1 : fee0;\n    uint tokenBFee = depositorSwapTokens ? fee0 : fee1;\n    _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, tokenAFee, tokenBFee, liquidatorSwapSlippage);\n  }\n\n  /// @dev Rebalances the debt by either filling up or closing and reopening debt positions. Sets new tick range.\n  function rebalanceDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    UniswapV3ConverterStrategyLogicLib.State storage state,\n    uint liquidatorSwapSlippage\n  ) external {\n    IUniswapV3Pool pool = state.pool;\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    (uint tokenAFee, uint tokenBFee) = depositorSwapTokens ? (state.rebalanceEarned1, state.rebalanceEarned0) : (state.rebalanceEarned0, state.rebalanceEarned1);\n    if (state.fillUp) {\n      _rebalanceDebtFillup(tetuConverter, controller, pool, tokenA, tokenB, tokenAFee, tokenBFee, liquidatorSwapSlippage);\n      (state.lowerTick, state.upperTick) = _calcNewTickRange(pool, state.lowerTick, state.upperTick, state.tickSpacing);\n    } else {\n      _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, tokenAFee, tokenBFee, liquidatorSwapSlippage);\n      (int24 newLowerTick, int24 newUpperTick) = _calcNewTickRange(pool, state.lowerTick, state.upperTick, state.tickSpacing);\n      bytes memory entryData = getEntryData(pool, newLowerTick, newUpperTick, depositorSwapTokens);\n      _openDebt(tetuConverter, tokenA, tokenB, entryData, tokenAFee);\n      state.lowerTick = newLowerTick;\n      state.upperTick = newUpperTick;\n    }\n  }\n\n  function getEntryData(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    bool depositorSwapTokens\n  ) public view returns (bytes memory entryData) {\n    address token1 = pool.token1();\n    uint token1Price = UniswapV3Lib.getPrice(address(pool), token1);\n\n    uint token1Decimals = IERC20Metadata(token1).decimals();\n\n    uint token0Desired = token1Price;\n    uint token1Desired = 10 ** token1Decimals;\n\n    // calculate proportions\n    (uint consumed0, uint consumed1,) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTick, upperTick, token0Desired, token1Desired);\n\n    if (depositorSwapTokens) {\n      entryData = abi.encode(1, consumed1 * token1Price / token1Desired, consumed0);\n    } else {\n      entryData = abi.encode(1, consumed0, consumed1 * token1Price / token1Desired);\n    }\n  }\n\n  function calcTickRange(IUniswapV3Pool pool, int24 tickRange, int24 tickSpacing) public view returns (int24 lowerTick, int24 upperTick) {\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (tick < 0 && tick / tickSpacing * tickSpacing != tick) {\n      lowerTick = ((tick - tickRange) / tickSpacing - 1) * tickSpacing;\n    } else {\n      lowerTick = (tick - tickRange) / tickSpacing * tickSpacing;\n    }\n    upperTick = tickRange == 0 ? lowerTick + tickSpacing : lowerTick + tickRange * 2;\n  }\n\n  /// @notice Calculate the new tick range for a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool to calculate the new tick range for.\n  /// @param lowerTick The current lower tick value for the pool.\n  /// @param upperTick The current upper tick value for the pool.\n  /// @param tickSpacing The tick spacing for the pool.\n  /// @return lowerTickNew The new lower tick value for the pool.\n  /// @return upperTickNew The new upper tick value for the pool.\n  function _calcNewTickRange(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing\n  ) internal view returns (int24 lowerTickNew, int24 upperTickNew) {\n    int24 fullTickRange = upperTick - lowerTick;\n    (lowerTickNew, upperTickNew) = calcTickRange(pool, fullTickRange == tickSpacing ? int24(0) : fullTickRange / 2, tickSpacing);\n  }\n\n  /// @notice Closes debt by liquidating tokens as necessary.\n  ///         This function helps ensure that the converter strategy maintains the appropriate balances\n  ///         and debt positions for token A and token B, while accounting for fees and potential price impacts.\n  function _closeDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    IUniswapV3Pool pool,\n    address tokenA,\n    address tokenB,\n    uint feeA,\n    uint feeB,\n    uint liquidatorSwapSlippage\n  ) internal {\n    uint debtAmount = getDebtTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter.controller()).priceOracle());\n\n    /// after disableFuse() debt can be zero\n    /// we close debt only if it is more than $0.1\n    if (debtAmount * priceOracle.getAssetPrice(tokenB) / 10 ** IERC20Metadata(tokenB).decimals() > 1e17) {\n      uint availableBalanceTokenA = AppLib.balance(tokenA);\n      uint availableBalanceTokenB = AppLib.balance(tokenB);\n\n      // exclude fees if it is possible\n      if(availableBalanceTokenA > feeA) {\n        availableBalanceTokenA -= feeA;\n      }\n      if(availableBalanceTokenB > feeB) {\n        availableBalanceTokenB -= feeB;\n      }\n\n      if (availableBalanceTokenB < debtAmount) {\n        uint tokenBprice = UniswapV3Lib.getPrice(address(pool), tokenB);\n        uint needToSellTokenA = tokenBprice * (debtAmount - availableBalanceTokenB) / 10 ** IERC20Metadata(tokenB).decimals();\n        // add 1% gap for price impact\n        needToSellTokenA += needToSellTokenA / SELL_GAP;\n\n        ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, Math.min(needToSellTokenA, availableBalanceTokenA), liquidatorSwapSlippage, 0, false);\n        availableBalanceTokenB = AppLib.balance(tokenB);\n        if(availableBalanceTokenB > feeB) {\n          availableBalanceTokenB -= feeB;\n        }\n      }\n\n      ConverterStrategyBaseLib.closePosition(\n        tetuConverter,\n        tokenA,\n        tokenB,\n        Math.min(debtAmount, availableBalanceTokenB)\n      );\n\n      availableBalanceTokenB = AppLib.balance(tokenB);\n      if(availableBalanceTokenB > feeB) {\n        availableBalanceTokenB -= feeB;\n      }\n      ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenB, tokenA, availableBalanceTokenB, liquidatorSwapSlippage, 0, false);\n    }\n  }\n\n  /// @dev Opens a new debt position using entry data.\n  /// @param tetuConverter The TetuConverter contract.\n  /// @param tokenA The address of token A.\n  /// @param tokenB The address of token B.\n  /// @param entryData The data required to open a position.\n  /// @param feeA The fee associated with token A.\n  function _openDebt(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    bytes memory entryData,\n    uint feeA\n  ) internal {\n    ConverterStrategyBaseLib.openPosition(\n      tetuConverter,\n      entryData,\n      tokenA,\n      tokenB,\n      AppLib.balance(tokenA) - feeA,\n      0\n    );\n  }\n\n  /// @dev Rebalances the debt to reach the optimal ratio between token A and token B.\n  function _rebalanceDebtFillup(\n    ITetuConverter tetuConverter,\n    address controller,\n    IUniswapV3Pool pool,\n    address tokenA,\n    address tokenB,\n    uint tokenAFee,\n    uint tokenBFee,\n    uint liquidatorSwapSlippage\n  ) internal {\n    RebalanceDebtFillUpLocalVariables memory vars;\n    vars.debtAmount = getDebtTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n\n    vars.availableBalanceTokenA = getBalanceWithoutFees(tokenA, tokenAFee);\n    vars.availableBalanceTokenB = getBalanceWithoutFees(tokenB, tokenBFee);\n\n    if (vars.debtAmount > 0) {\n      if (vars.availableBalanceTokenB > vars.debtAmount) {\n        vars.needToBorrowOrFreeFromBorrow = vars.availableBalanceTokenB - vars.debtAmount;\n\n        if (_getCollateralAmountForBorrow(tetuConverter, tokenA, tokenB, vars.needToBorrowOrFreeFromBorrow) < vars.availableBalanceTokenA) {\n          ConverterStrategyBaseLib.openPosition(\n            tetuConverter,\n            abi.encode(2),\n            tokenA,\n            tokenB,\n            vars.needToBorrowOrFreeFromBorrow,\n            0\n          );\n        } else {\n          ConverterStrategyBaseLib.closePosition(\n            tetuConverter,\n            tokenA,\n            tokenB,\n            vars.debtAmount\n          );\n\n          vars.availableBalanceTokenB = getBalanceWithoutFees(tokenB, tokenBFee);\n\n          ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenB, tokenA, vars.availableBalanceTokenB, liquidatorSwapSlippage, 0, false);\n\n          vars.availableBalanceTokenA = getBalanceWithoutFees(tokenA, tokenAFee);\n\n          ConverterStrategyBaseLib.openPosition(\n            tetuConverter,\n            abi.encode(1, 1, 1),\n            tokenA,\n            tokenB,\n            vars.availableBalanceTokenA,\n            0\n          );\n        }\n      } else {\n        vars.needToBorrowOrFreeFromBorrow = vars.debtAmount - vars.availableBalanceTokenB;\n        if (vars.availableBalanceTokenB > vars.needToBorrowOrFreeFromBorrow) {\n          ConverterStrategyBaseLib.closePosition(\n            tetuConverter,\n            tokenA,\n            tokenB,\n            vars.needToBorrowOrFreeFromBorrow\n          );\n        } else {\n          uint needToSellTokenA = UniswapV3Lib.getPrice(address(pool), tokenB) * vars.needToBorrowOrFreeFromBorrow / 10 ** IERC20Metadata(tokenB).decimals();\n          // add % gap for price impact\n          needToSellTokenA += needToSellTokenA / SELL_GAP;\n\n          if (needToSellTokenA <= vars.availableBalanceTokenA) {\n            ConverterStrategyBaseLib.liquidate(tetuConverter, ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, needToSellTokenA, liquidatorSwapSlippage, 0, false);\n\n            vars.availableBalanceTokenB = getBalanceWithoutFees(tokenB, tokenBFee);\n\n            ConverterStrategyBaseLib.closePosition(\n              tetuConverter,\n              tokenA,\n              tokenB,\n              vars.debtAmount < vars.availableBalanceTokenB ? vars.debtAmount : vars.availableBalanceTokenB\n            );\n\n            vars.availableBalanceTokenA = getBalanceWithoutFees(tokenA, tokenAFee);\n\n            ConverterStrategyBaseLib.openPosition(\n              tetuConverter,\n              abi.encode(1, 1, 1),\n              tokenA,\n              tokenB,\n              vars.availableBalanceTokenA,\n              0\n            );\n          }\n        }\n      }\n    }\n  }\n\n  /// @dev Calculates the collateral amount required for borrowing a specified amount.\n  /// @param tetuConverter The TetuConverter contract.\n  /// @param tokenA The address of token A.\n  /// @param tokenB The address of token B.\n  /// @param needToBorrow The amount that needs to be borrowed.\n  /// @return collateralAmount The amount of collateral required for borrowing the specified amount.\n  function _getCollateralAmountForBorrow(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    uint needToBorrow\n  ) internal view returns (uint collateralAmount) {\n    ConverterStrategyBaseLib.OpenPositionLocal memory vars;\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter.findBorrowStrategies(\n      abi.encode(2),\n      tokenA,\n      needToBorrow,\n      tokenB,\n      BORROW_PERIOD_ESTIMATION\n    );\n\n    uint len = vars.converters.length;\n    if (len > 0) {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        vars.amountToBorrow = needToBorrow < vars.amountsToBorrow[i]\n        ? needToBorrow\n        : vars.amountsToBorrow[i];\n        vars.collateral = needToBorrow < vars.amountsToBorrow[i]\n        ? vars.collateralsRequired[i] * needToBorrow / vars.amountsToBorrow[i]\n        : vars.collateralsRequired[i];\n        needToBorrow -= vars.amountToBorrow;\n        if (needToBorrow == 0) break;\n      }\n    }\n    return vars.collateral;\n  }\n\n  /// @dev Gets the token balance without fees.\n  /// @param token The token address.\n  /// @param fee The fee amount to be subtracted from the balance.\n  /// @return balanceWithoutFees The token balance without the specified fee amount.\n  function getBalanceWithoutFees(address token, uint fee) internal view returns (uint balanceWithoutFees) {\n    balanceWithoutFees = AppLib.balance(token);\n    require(balanceWithoutFees >= fee, Uni3StrategyErrors.BALANCE_LOWER_THAN_FEE);\n    balanceWithoutFees -= fee;\n  }\n\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3Depositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"../DepositorBase.sol\";\nimport \"./Uni3StrategyErrors.sol\";\nimport \"../../integrations/uniswap/IUniswapV3MintCallback.sol\";\nimport \"./UniswapV3ConverterStrategyLogicLib.sol\";\n\n/// @title UniswapV3Depositor\n/// @dev Abstract contract that is designed to interact with Uniswap V3 pools and manage liquidity.\n///      Inherits from IUniswapV3MintCallback, DepositorBase, and Initializable.\nabstract contract UniswapV3Depositor is IUniswapV3MintCallback, DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant UNISWAPV3_DEPOSITOR_VERSION = \"1.0.2\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                VARIABLES\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev State variable to store the current state of the whole strategy\n  UniswapV3ConverterStrategyLogicLib.State internal state;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                INIT\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Initializes the contract with the provided parameters.\n  /// @param asset_ The address of the asset.\n  /// @param pool_ The address of the Uniswap V3 pool.\n  /// @param tickRange_ The tick range for the positions.\n  /// @param rebalanceTickRange_ The tick range for rebalancing.\n  function __UniswapV3Depositor_init(\n    address asset_,\n    address pool_,\n    int24 tickRange_,\n    int24 rebalanceTickRange_\n  ) internal onlyInitializing {\n    require(pool_ != address(0), AppErrors.ZERO_ADDRESS);\n    state.pool = IUniswapV3Pool(pool_);\n    state.rebalanceTickRange = rebalanceTickRange_;\n    (\n    state.tickSpacing,\n    state.lowerTick,\n    state.upperTick,\n    state.tokenA,\n    state.tokenB,\n    state.depositorSwapTokens\n    ) = UniswapV3ConverterStrategyLogicLib.calcInitialDepositorValues(\n      state.pool,\n      tickRange_,\n      rebalanceTickRange_,\n      asset_\n    );\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns the current state of the contract.\n  function getState() external view returns (\n    address tokenA,\n    address tokenB,\n    IUniswapV3Pool pool,\n    int24 tickSpacing,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 rebalanceTickRange,\n    uint128 totalLiquidity,\n    bool isFuseTriggered,\n    uint fuseThreshold,\n    uint[] memory rebalanceResults\n  ) {\n    tokenA = state.tokenA;\n    tokenB = state.tokenB;\n    pool = state.pool;\n    tickSpacing = state.tickSpacing;\n    lowerTick = state.lowerTick;\n    upperTick = state.upperTick;\n    rebalanceTickRange = state.rebalanceTickRange;\n    totalLiquidity = state.totalLiquidity;\n    isFuseTriggered = state.isFuseTriggered;\n    fuseThreshold = state.fuseThreshold;\n\n    rebalanceResults = new uint[](3);\n    rebalanceResults[0] = state.rebalanceEarned0;\n    rebalanceResults[1] = state.rebalanceEarned1;\n    rebalanceResults[2] = state.rebalanceLost;\n  }\n\n  /// @notice Returns the fees for the current state.\n  /// @return fee0 and fee1.\n  function getFees() public view returns (uint fee0, uint fee1) {\n    return UniswapV3ConverterStrategyLogicLib.getFees(state);\n  }\n\n  /// @notice Returns the pool assets.\n  /// @return poolAssets An array containing the addresses of the pool assets.\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    poolAssets = new address[](2);\n    poolAssets[0] = state.tokenA;\n    poolAssets[1] = state.tokenB;\n  }\n\n  /// @notice Returns the pool weights and the total weight.\n  /// @return weights An array containing the weights of the pool assets, and totalWeight the sum of the weights.\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    weights = new uint[](2);\n    weights[0] = 1;\n    weights[1] = 1;\n    totalWeight = 2;\n  }\n\n  /// @notice Returns the pool reserves.\n  /// @return reserves An array containing the reserves of the pool assets.\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    return UniswapV3ConverterStrategyLogicLib.getPoolReserves(state);\n  }\n\n  /// @notice Returns the current liquidity of the depositor.\n  /// @return The current liquidity of the depositor.\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return uint(state.totalLiquidity);\n  }\n\n  /// @notice Returns the total supply of the depositor.\n  /// @return In UniV3 we can not calculate the total supply of the wgole pool. Return only ourself value.\n  function _depositorTotalSupply() override internal view virtual returns (uint) {\n    return uint(state.totalLiquidity);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CALLBACK\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Callback function called by Uniswap V3 pool on mint operation.\n  /// @param amount0Owed The amount of token0 owed to the pool.\n  /// @param amount1Owed The amount of token1 owed to the pool.\n  function uniswapV3MintCallback(\n    uint amount0Owed,\n    uint amount1Owed,\n    bytes calldata /*_data*/\n  ) external override {\n    require(msg.sender == address(state.pool), Uni3StrategyErrors.NOT_CALLBACK_CALLER);\n    if (amount0Owed > 0) IERC20(state.depositorSwapTokens ? state.tokenB : state.tokenA).safeTransfer(msg.sender, amount0Owed);\n    if (amount1Owed > 0) IERC20(state.depositorSwapTokens ? state.tokenA : state.tokenB).safeTransfer(msg.sender, amount1Owed);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Handles the deposit operation.\n  function _depositorEnter(\n    uint[] memory amountsDesired_\n  ) override internal virtual returns (uint[] memory amountsConsumed, uint liquidityOut) {\n    (amountsConsumed, liquidityOut, state.totalLiquidity) = UniswapV3ConverterStrategyLogicLib.enter(state.pool, state.lowerTick, state.upperTick, amountsDesired_, state.totalLiquidity, state.depositorSwapTokens);\n  }\n\n  /// @notice Handles the withdrawal operation.\n  /// @param liquidityAmount The amount of liquidity to be withdrawn.\n  /// @return amountsOut The amounts of the tokens withdrawn.\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    (uint fee0, uint fee1) = getFees();\n    state.rebalanceEarned0 += fee0;\n    state.rebalanceEarned1 += fee1;\n    (amountsOut, state.totalLiquidity, state.totalLiquidityFillup) = UniswapV3ConverterStrategyLogicLib.exit(state.pool, state.lowerTick, state.upperTick, state.lowerTickFillup, state.upperTickFillup, state.totalLiquidity, state.totalLiquidityFillup, uint128(liquidityAmount), state.depositorSwapTokens);\n  }\n\n  /// @notice Returns the amount of tokens that would be withdrawn based on the provided liquidity amount.\n  /// @param liquidityAmount The amount of liquidity to quote the withdrawal for.\n  /// @return amountsOut The amounts of the tokens that would be withdrawn.\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    amountsOut = UniswapV3ConverterStrategyLogicLib.quoteExit(state.pool, state.lowerTick, state.upperTick, state.lowerTickFillup, state.upperTickFillup, state.totalLiquidity, state.totalLiquidityFillup, uint128(liquidityAmount), state.depositorSwapTokens);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claims all possible rewards.\n  /// @return tokensOut An array containing the addresses of the reward tokens,\n  /// @return amountsOut An array containing the amounts of the reward tokens.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut,\n    uint[] memory balancesBefore\n  ) {\n\n    tokensOut = new address[](2);\n    tokensOut[0] = state.tokenA;\n    tokensOut[1] = state.tokenB;\n\n    (amountsOut, balancesBefore) = UniswapV3ConverterStrategyLogicLib.claimRewards(\n      state.pool,\n      state.lowerTick,\n      state.upperTick,\n      state.lowerTickFillup,\n      state.upperTickFillup,\n      state.rebalanceEarned0,\n      state.rebalanceEarned1,\n      state.depositorSwapTokens,\n      tokensOut,\n      state.totalLiquidity,\n      state.totalLiquidityFillup\n    );\n    state.rebalanceEarned0 = 0;\n    state.rebalanceEarned1 = 0;\n  }\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[50-1] private __gap; // 50 - count of variables\n\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/uniswap/IUniswapV3Pool.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\n\n/// @title Uniswap V3 liquidity management helper\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary UniswapV3Lib {\n  uint8 internal constant RESOLUTION = 96;\n  uint internal constant Q96 = 0x1000000000000000000000000;\n  uint private constant TWO_96 = 2 ** 96;\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n  int24 internal constant MIN_TICK = - 887272;\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n  int24 internal constant MAX_TICK = - MIN_TICK;\n\n  struct PoolPosition {\n    address pool;\n    int24 lowerTick;\n    int24 upperTick;\n    uint128 liquidity;\n    address owner;\n  }\n\n  function getTickSpacing(uint24 fee) external pure returns (int24) {\n    if (fee == 10000) {\n      return 200;\n    }\n    if (fee == 3000) {\n      return 60;\n    }\n    if (fee == 500) {\n      return 10;\n    }\n    return 1;\n  }\n\n  function getFees(PoolPosition memory position) public view returns (uint fee0, uint fee1) {\n    bytes32 positionId = _getPositionId(position);\n    IUniswapV3Pool pool = IUniswapV3Pool(position.pool);\n    (, int24 tick, , , , ,) = pool.slot0();\n    (, uint feeGrowthInside0Last, uint feeGrowthInside1Last, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(positionId);\n    fee0 = _computeFeesEarned(position, true, feeGrowthInside0Last, tick) + uint(tokensOwed0);\n    fee1 = _computeFeesEarned(position, false, feeGrowthInside1Last, tick) + uint(tokensOwed1);\n  }\n\n  function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\n    IUniswapV3Pool pool = IUniswapV3Pool(pool_);\n    (uint160 sqrtRatioX96, , , , , ,) = pool.slot0();\n    liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\n    (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\n  }\n\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n  /// pool prices and the prices at the tick boundaries\n  function getLiquidityForAmounts(\n    uint160 sqrtRatioX96,\n    int24 lowerTick,\n    int24 upperTick,\n    uint amount0,\n    uint amount1\n  ) public pure returns (uint128 liquidity) {\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n      uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n    } else {\n      liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n    }\n  }\n\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n  /// pool prices and the prices at the tick boundaries\n  function getAmountsForLiquidity(\n    uint160 sqrtRatioX96,\n    int24 lowerTick,\n    int24 upperTick,\n    uint128 liquidity\n  ) public pure returns (uint amount0, uint amount1) {\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n    } else {\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    }\n  }\n\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(\n    uint a,\n    uint b,\n    uint denominator\n  ) public pure returns (uint result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = a * b\n    // Compute the product mod 2**256 and mod 2**256 - 1\n    // then use the Chinese Remainder Theorem to reconstruct\n    // the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2**256 + prod0\n    uint prod0;\n    // Least significant 256 bits of the product\n    uint prod1;\n    // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(a, b, not(0))\n      prod0 := mul(a, b)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division\n    if (prod1 == 0) {\n      require(denominator > 0);\n      assembly {\n        result := div(prod0, denominator)\n      }\n      return result;\n    }\n\n    // Make sure the result is less than 2**256.\n    // Also prevents denominator == 0\n    require(denominator > prod1);\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0]\n    // Compute remainder using mulmod\n    uint remainder;\n    assembly {\n      remainder := mulmod(a, b, denominator)\n    }\n    // Subtract 256 bit number from 512 bit number\n    assembly {\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator\n    // Compute largest power of two divisor of denominator.\n    // Always >= 1.\n    // EDIT for 0.8 compatibility:\n    // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\n    uint twos = denominator & (~denominator + 1);\n\n    // Divide denominator by power of two\n    assembly {\n      denominator := div(denominator, twos)\n    }\n\n    // Divide [prod1 prod0] by the factors of two\n    assembly {\n      prod0 := div(prod0, twos)\n    }\n    // Shift in bits from prod1 into prod0. For this we need\n    // to flip `twos` such that it is 2**256 / twos.\n    // If twos is zero, then it becomes one\n    assembly {\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2**256\n    // Now that denominator is an odd number, it has an inverse\n    // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n    // Compute the inverse by starting with a seed that is correct\n    // correct for four bits. That is, denominator * inv = 1 mod 2**4\n    uint inv = (3 * denominator) ^ 2;\n    // Now use Newton-Raphson iteration to improve the precision.\n    // Thanks to Hensel's lifting lemma, this also works in modular\n    // arithmetic, doubling the correct bits in each step.\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**8\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**16\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**32\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**64\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**128\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**256\n\n    // Because the division is now exact we can divide by multiplying\n    // with the modular inverse of denominator. This will give us the\n    // correct result modulo 2**256. Since the precoditions guarantee\n    // that the outcome is less than 2**256, this is the final result.\n    // We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inv;\n    return result;\n  }\n  }\n\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(\n    uint a,\n    uint b,\n    uint denominator\n  ) internal pure returns (uint result) {\n    result = mulDiv(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      require(result < type(uint).max);\n      result++;\n    }\n  }\n\n  /// @notice Calculates price in pool\n  function getPrice(address pool_, address tokenIn) public view returns (uint) {\n    IUniswapV3Pool pool = IUniswapV3Pool(pool_);\n    address token0 = pool.token0();\n    address token1 = pool.token1();\n\n    uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    (uint160 sqrtPriceX96,,,,,,) = pool.slot0();\n\n    uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\n\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\n    uint purePrice;\n    uint precision;\n    if (tokenIn == token0) {\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\n      purePrice = part * part;\n    } else {\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\n      purePrice = part * part;\n    }\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount0 The amount0 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\n    return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount1 The amount1 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount0 The amount0\n  function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\n  }\n\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount1 The amount1\n  function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\n  }\n\n  function _computeFeesEarned(\n    PoolPosition memory position,\n    bool isZero,\n    uint feeGrowthInsideLast,\n    int24 tick\n  ) internal view returns (uint fee) {\n    IUniswapV3Pool pool = IUniswapV3Pool(position.pool);\n    uint feeGrowthOutsideLower;\n    uint feeGrowthOutsideUpper;\n    uint feeGrowthGlobal;\n    if (isZero) {\n      feeGrowthGlobal = pool.feeGrowthGlobal0X128();\n      (,, feeGrowthOutsideLower,,,,,) = pool.ticks(position.lowerTick);\n      (,, feeGrowthOutsideUpper,,,,,) = pool.ticks(position.upperTick);\n    } else {\n      feeGrowthGlobal = pool.feeGrowthGlobal1X128();\n      (,,, feeGrowthOutsideLower,,,,) = pool.ticks(position.lowerTick);\n      (,,, feeGrowthOutsideUpper,,,,) = pool.ticks(position.upperTick);\n    }\n\n  unchecked {\n    // calculate fee growth below\n    uint feeGrowthBelow;\n    if (tick >= position.lowerTick) {\n      feeGrowthBelow = feeGrowthOutsideLower;\n    } else {\n      feeGrowthBelow = feeGrowthGlobal - feeGrowthOutsideLower;\n    }\n\n    // calculate fee growth above\n    uint feeGrowthAbove;\n    if (tick < position.upperTick) {\n      feeGrowthAbove = feeGrowthOutsideUpper;\n    } else {\n      feeGrowthAbove = feeGrowthGlobal - feeGrowthOutsideUpper;\n    }\n\n    uint feeGrowthInside =\n    feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove;\n    fee = mulDiv(\n      position.liquidity,\n      feeGrowthInside - feeGrowthInsideLast,\n      0x100000000000000000000000000000000\n    );\n  }\n  }\n\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\n  /// @dev Throws if |tick| > max tick\n  /// @param tick The input tick for the above formula\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n  /// at the given tick\n  function _getSqrtRatioAtTick(int24 tick)\n  internal\n  pure\n  returns (uint160 sqrtPriceX96)\n  {\n    uint256 absTick =\n    tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\n\n    // EDIT: 0.8 compatibility\n    require(absTick <= uint256(int256(MAX_TICK)), \"T\");\n\n    uint256 ratio =\n    absTick & 0x1 != 0\n    ? 0xfffcb933bd6fad37aa2d162d1a594001\n    : 0x100000000000000000000000000000000;\n    if (absTick & 0x2 != 0)\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n    if (absTick & 0x4 != 0)\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n    if (absTick & 0x8 != 0)\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n    if (absTick & 0x10 != 0)\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n    if (absTick & 0x20 != 0)\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n    if (absTick & 0x40 != 0)\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n    if (absTick & 0x80 != 0)\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n    if (absTick & 0x100 != 0)\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n    if (absTick & 0x200 != 0)\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n    if (absTick & 0x400 != 0)\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n    if (absTick & 0x800 != 0)\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n    if (absTick & 0x1000 != 0)\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n    if (absTick & 0x2000 != 0)\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n    if (absTick & 0x4000 != 0)\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n    if (absTick & 0x8000 != 0)\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n    if (absTick & 0x10000 != 0)\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n    if (absTick & 0x20000 != 0)\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n    if (absTick & 0x40000 != 0)\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n    if (absTick & 0x80000 != 0)\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n    if (tick > 0) ratio = type(uint256).max / ratio;\n\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n    sqrtPriceX96 = uint160(\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\n    );\n  }\n\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n  /// ever return.\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n  function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    // second inequality must be < because the price can never reach the price at the max tick\n    require(\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\n      \"R\"\n    );\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n    uint256 r = ratio;\n    uint256 msb = 0;\n\n    assembly {\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(5, gt(r, 0xFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(4, gt(r, 0xFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(3, gt(r, 0xFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(2, gt(r, 0xF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(1, gt(r, 0x3))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := gt(r, 0x1)\n      msb := or(msb, f)\n    }\n\n    if (msb >= 128) r = ratio >> (msb - 127);\n    else r = ratio << (127 - msb);\n\n    int256 log_2 = (int256(msb) - 128) << 64;\n\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(63, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(62, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(61, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(60, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(59, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(58, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(57, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(56, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(55, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(54, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(53, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(52, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(51, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(50, f))\n    }\n\n    tick = _getFinalTick(log_2, sqrtPriceX96);\n  }\n\n  function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    // 128.128 number\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\n\n    int24 tickLow =\n    int24(\n      (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\n    );\n    int24 tickHi =\n    int24(\n      (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\n    );\n\n    tick = (tickLow == tickHi)\n    ? tickLow\n    : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\n    ? tickHi\n    : tickLow);\n  }\n\n  function _getPositionId(PoolPosition memory position) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(position.owner, position.lowerTick, position.upperTick));\n  }\n\n  function _countDigits(uint n) internal pure returns (uint) {\n    if (n == 0) {\n      return 0;\n    }\n    uint count = 0;\n    while (n != 0) {\n      n = n / 10;\n      ++count;\n    }\n    return count;\n  }\n\n  function _min(uint a, uint b) internal pure returns (uint) {\n    return a < b ? a : b;\n  }\n\n  function _max(uint a, uint b) internal pure returns (uint) {\n    return a > b ? a : b;\n  }\n\n  function _toUint128(uint x) private pure returns (uint128 y) {\n    require((y = uint128(x)) == x);\n  }\n}\n"
    },
    "contracts/test/BalancerBoostedStrategyAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/balancer/BalancerBoostedStrategy.sol\";\n\n/// @notice Provide direct access to BalancerBoostedStrategy internal functions\ncontract BalancerBoostedStrategyAccess is BalancerBoostedStrategy {\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  ///  Access to internal functions\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function _depositToPoolAccess(uint amount_, bool updateTotalAssetsBeforeInvest_) external returns (\n    uint loss\n  ) {\n    return _depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n  }\n\n  function _withdrawFromPoolAccess(uint amount) external returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    uint loss\n  ) {\n    return _withdrawFromPool(amount);\n  }\n\n  function _withdrawAllFromPoolAccess() external returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    uint loss\n  ) {\n    return _withdrawAllFromPool();\n  }\n}\n"
    },
    "contracts/test/facades/ConverterStrategyBaseLibFacade.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\n\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"../../strategies/ConverterStrategyBaseLib.sol\";\nimport \"../../strategies/ConverterStrategyBaseLib2.sol\";\nimport \"../../integrations/tetu-v1/ITetuV1Controller.sol\";\n\n/// @notice Provide public access to internal functions of ConverterStrategyBaseLib and ConverterStrategyBaseLib2\ncontract ConverterStrategyBaseLibFacade {\n  mapping (address => uint) public liquidationThresholds;\n\n  function setLiquidationThreshold(address asset, uint values) external {\n    liquidationThresholds[asset] = values;\n  }\n\n  function getExpectedWithdrawnAmounts(\n    uint[] memory reserves_,\n    uint liquidityAmount_,\n    uint totalSupply_\n  ) external pure returns (\n    uint[] memory withdrawnAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.getExpectedWithdrawnAmounts(reserves_, liquidityAmount_, totalSupply_);\n  }\n\n  function getLiquidityAmount(\n    uint targetAmount_,\n    address strategy_,\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint investedAssets,\n    uint depositorLiquidity\n  ) external returns (\n    uint resultAmount,\n    uint[] memory amountsToConvertOut\n  ) {\n    return ConverterStrategyBaseLib2.getLiquidityAmount(\n      targetAmount_,\n      strategy_,\n      tokens,\n      indexAsset,\n      converter,\n      investedAssets,\n      depositorLiquidity\n    );\n  }\n\n  function getCollaterals(\n    uint amount_,\n    address[] memory tokens_,\n    uint[] memory weights_,\n    uint totalWeight_,\n    uint indexAsset_,\n    IPriceOracle priceOracle\n  ) external view returns (uint[] memory tokenAmountsOut) {\n    return ConverterStrategyBaseLib2.getCollaterals(\n      amount_,\n      tokens_,\n      weights_,\n      totalWeight_,\n      indexAsset_,\n      priceOracle\n    );\n  }\n\n  function openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdMainAsset_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.openPosition(\n      tetuConverter_,\n      entryData_,\n      collateralAsset_,\n      borrowAsset_,\n      amountIn_,\n      thresholdMainAsset_\n    );\n  }\n\n  function openPositionEntryKind1(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint collateralThreshold_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.openPositionEntryKind1(\n      tetuConverter_,\n      entryData_,\n      collateralAsset_,\n      borrowAsset_,\n      amountIn_,\n      collateralThreshold_\n    );\n  }\n\n  function closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint leftoverOut\n  ) {\n    return ConverterStrategyBaseLib.closePosition(\n      tetuConverter_,\n      collateralAsset,\n      borrowAsset,\n      amountToRepay\n    );\n  }\n\n  function liquidate(\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint slippage,\n    uint rewardLiquidationThresholdForTokenOut,\n    bool skipValidation\n  ) external returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.liquidate(\n      converter_,\n      liquidator_,\n      tokenIn,\n      tokenOut,\n      amountIn,\n      slippage,\n      rewardLiquidationThresholdForTokenOut,\n      skipValidation\n    );\n  }\n\n  function getAssetIndex(address[] memory tokens_, address asset_) external pure returns (uint) {\n    return ConverterStrategyBaseLib.getAssetIndex(tokens_, asset_);\n  }\n\n  function getAvailableBalances(\n    address[] memory tokens_,\n    uint indexAsset\n  ) external view returns (uint[] memory) {\n    return ConverterStrategyBaseLib2.getAvailableBalances(tokens_, indexAsset);\n  }\n\n  function calcInvestedAssets(\n    address[] memory tokens,\n    uint[] memory amountsOut,\n    uint indexAsset,\n    ITetuConverter converter_\n  ) external returns (\n    uint amountOut\n  ) {\n    return ConverterStrategyBaseLib.calcInvestedAssets(\n      tokens,\n      amountsOut,\n      indexAsset,\n      converter_\n    );\n  }\n\n  function sendPerformanceFee(address asset_, uint amount_, address splitter, address receiver_) external returns (\n    uint toPerf,\n    uint toInsurance\n  ) {\n    return ConverterStrategyBaseLib2.sendPerformanceFee(asset_, amount_, splitter, receiver_);\n  }\n\n  function swapToGivenAmountAccess(\n    uint targetAmount_,\n    address[] memory tokens_,\n    uint indexTargetAsset_,\n    address underlying_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint liquidationThresholdForTargetAsset_,\n    uint overswap_\n  ) external returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    return ConverterStrategyBaseLib.swapToGivenAmount(\n      targetAmount_,\n      tokens_,\n      indexTargetAsset_,\n      underlying_,\n      converter_,\n      liquidator_,\n      liquidationThresholdForTargetAsset_,\n      overswap_\n    );\n  }\n\n  function _swapToGivenAmountAccess(ConverterStrategyBaseLib.SwapToGivenAmountInputParams memory p) external returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    return ConverterStrategyBaseLib._swapToGivenAmount(p);\n  }\n\n  function swapToGetAmountAccess(\n    uint receivedTargetAmount,\n    ConverterStrategyBaseLib.SwapToGivenAmountInputParams memory p,\n    ConverterStrategyBaseLib.CalcInvestedAssetsLocal memory v,\n    uint indexTokenIn\n  ) external returns (\n    uint amountSpent,\n    uint amountReceived\n  ) {\n    return ConverterStrategyBaseLib._swapToGetAmount(receivedTargetAmount, p, v, indexTokenIn);\n  }\n\n  function convertAfterWithdraw(\n    ITetuConverter tetuConverter,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    uint liquidationThreshold,\n    address[] memory tokens,\n    uint[] memory amountsToConvert\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.convertAfterWithdraw(\n      tetuConverter,\n      liquidator,\n      indexAsset,\n      liquidationThreshold,\n      tokens,\n      amountsToConvert\n    );\n  }\n\n  function closePositionsToGetAmount(\n    ITetuConverter tetuConverter,\n    ITetuLiquidator liquidator,\n    uint indexAsset,\n    uint requestedAmount,\n    address[] memory tokens\n  ) external returns (\n    uint expectedAmountMainAssetOut\n  ) {\n    return ConverterStrategyBaseLib.closePositionsToGetAmount(\n      tetuConverter,\n      liquidator,\n      indexAsset,\n      liquidationThresholds,\n      requestedAmount,\n      tokens\n    );\n  }\n\n  function _getAmountToSell(\n    uint remainingRequestedAmount,\n    uint totalDebt,\n    uint totalCollateral,\n    uint[] memory prices,\n    uint[] memory decs,\n    uint indexCollateral,\n    uint indexBorrowAsset,\n    uint balanceBorrowAsset\n  ) external pure returns (\n    uint amountOut\n  ) {\n    return ConverterStrategyBaseLib._getAmountToSell(\n      remainingRequestedAmount,\n      totalDebt,\n      totalCollateral,\n      prices,\n      decs,\n      indexCollateral,\n      indexBorrowAsset,\n      balanceBorrowAsset\n    );\n  }\n\n  function registerIncome(uint assetBefore, uint assetAfter, uint earned, uint lost) external pure returns (\n    uint _earned,\n    uint _lost\n  ) {\n    return ConverterStrategyBaseLib.registerIncome(assetBefore, assetAfter, earned, lost);\n  }\n\n  function sendTokensToForwarder(\n    address controller_,\n    address splitter_,\n    address[] memory tokens_,\n    uint[] memory amounts_\n  ) external {\n    return ConverterStrategyBaseLib2.sendTokensToForwarder(controller_, splitter_, tokens_, amounts_);\n  }\n\n  function recycle(\n    ITetuConverter converter_,\n    address asset,\n    uint compoundRatio,\n    address[] memory tokens,\n    ITetuLiquidator liquidator,\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    uint performanceFee\n  ) external returns (\n    uint[] memory amountsToForward,\n    uint amountToPerformanceAndInsurance\n  ) {\n    return ConverterStrategyBaseLib.recycle(\n      converter_,\n      asset,\n      compoundRatio,\n      tokens,\n      liquidator,\n      liquidationThresholds,\n      rewardTokens,\n      rewardAmounts,\n      performanceFee\n    );\n  }\n\n  function claimConverterRewards(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_,\n    uint[] memory balancesBefore\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    return ConverterStrategyBaseLib2.claimConverterRewards(\n      tetuConverter_,\n      tokens_,\n      rewardTokens_,\n      rewardAmounts_,\n      balancesBefore\n    );\n  }\n\n  function getTokenAmounts(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory collaterals_,\n    uint thresholdMainAsset_\n  ) external returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.getTokenAmounts(\n      tetuConverter_,\n      tokens_,\n      indexAsset_,\n      collaterals_,\n      thresholdMainAsset_\n    );\n  }\n\n  function _closePositionExact(\n    ITetuConverter converter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    uint balanceBorrowAsset\n  ) external returns (\n    uint collateralOut,\n    uint repaidAmountOut\n  ) {\n    return ConverterStrategyBaseLib._closePositionExact(\n      converter_,\n      collateralAsset,\n      borrowAsset,\n      amountRepay,\n      balanceBorrowAsset\n    );\n  }\n\n  function _closePosition(\n    ITetuConverter converter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n    return ConverterStrategyBaseLib._closePosition(converter_, collateralAsset, borrowAsset, amountToRepay);\n  }\n\n  function postWithdrawActions(\n    ITetuConverter converter,\n    address[] memory tokens,\n    uint indexAsset,\n\n    uint[] memory reservesBeforeWithdraw,\n    uint liquidityAmountWithdrew,\n    uint totalSupplyBeforeWithdraw,\n\n    uint[] memory amountsToConvert,\n    uint[] memory withdrawnAmounts\n  ) external returns (\n    uint[] memory expectedMainAssetAmounts,\n    uint[] memory _amountsToConvert\n  ) {\n    return ConverterStrategyBaseLib.postWithdrawActions(\n      converter,\n      tokens,\n      indexAsset,\n      reservesBeforeWithdraw,\n      liquidityAmountWithdrew,\n      totalSupplyBeforeWithdraw,\n      amountsToConvert,\n      withdrawnAmounts\n    );\n  }\n\n  function postWithdrawActionsEmpty(\n    ITetuConverter converter,\n    address[] memory tokens,\n    uint indexAsset,\n    uint[] memory amountsToConvert_\n  ) external returns (\n    uint[] memory expectedAmountsMainAsset\n  ) {\n      return ConverterStrategyBaseLib.postWithdrawActionsEmpty(converter, tokens, indexAsset, amountsToConvert_);\n  }\n}\n"
    },
    "contracts/test/MockConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../strategies/ConverterStrategyBase.sol\";\nimport \"./mocks/MockDepositor.sol\";\n\n/// @title Mock Converter Strategy with MockDepositor\n/// @author bogdoslav\ncontract MockConverterStrategy is ConverterStrategyBase, MockDepositor {\n\n  string public constant override NAME = \"mock converter strategy\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address[] memory depositorTokens_,\n    uint[] memory depositorWeights_,\n    uint[] memory depositorReserves_\n  ) external initializer {\n\n    __MockDepositor_init(\n      depositorTokens_,\n      depositorWeights_,\n      depositorReserves_\n    );\n\n    __ConverterStrategyBase_init(\n      controller_,\n      splitter_,\n      converter_\n    );\n  }\n\n  function init2(address controller_, address splitter_, address converter_) external {\n    __ConverterStrategyBase_init(\n      controller_,\n      splitter_,\n      converter_\n    );\n  }\n  //////////////////////////////////////////////////////////////////////\n  ///    Provide direct access to internal functions for tests\n  //////////////////////////////////////////////////////////////////////\n  function closePositionTestAccess(address collateralAsset, address borrowAsset, uint amountToRepay) external returns (\n    uint returnedAssetAmount,\n    uint leftover\n  ) {\n    return ConverterStrategyBaseLib.closePosition(converter, collateralAsset, borrowAsset, amountToRepay);\n  }\n\n  function updateInvestedAssetsTestAccess() external {\n    _updateInvestedAssets();\n  }\n\n  function withdrawUniversalTestAccess(uint amount, bool all) external returns (\n    uint expectedWithdrewUSD,\n    uint assetPrice,\n    uint strategyLoss\n  ) {\n    return _withdrawUniversal(all ? type(uint).max : amount);\n  }\n\n  function _doHardWorkAccess(bool reInvest) external returns (uint earned, uint lost) {\n    return _doHardWork(reInvest);\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// _handleRewards, mocked version + accessor\n  /////////////////////////////////////////////////////////////////////////////////////\n  function _handleRewards() internal override returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    if (handleRewardsParams.initialized) {\n      //      console.log(\"_handleRewards.mocked-version is called\");\n      if (handleRewardsParams.assetBalanceChange > 0) {\n        IERC20(asset).transferFrom(\n          handleRewardsParams.providerBalanceChange,\n          address(this),\n          uint(handleRewardsParams.assetBalanceChange)\n        );\n      } else if (handleRewardsParams.assetBalanceChange < 0) {\n        IERC20(asset).transfer(\n          handleRewardsParams.providerBalanceChange,\n          uint(- handleRewardsParams.assetBalanceChange)\n        );\n      }\n      return (handleRewardsParams.earned, handleRewardsParams.lost, AppLib.balance(asset));\n    } else {\n      return __handleRewards();\n    }\n  }\n\n  function __handleRewards() internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    uint assetBalanceBefore = AppLib.balance(asset);\n    (address[] memory rewardTokens, uint[] memory amounts) = _claim();\n    _rewardsLiquidation(rewardTokens, amounts);\n    assetBalanceAfterClaim = AppLib.balance(asset);\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(assetBalanceBefore, assetBalanceAfterClaim, earned, lost);\n    return (earned, lost, assetBalanceAfterClaim);\n  }\n\n  struct MockedHandleRewardsParams {\n    bool initialized;\n    uint earned;\n    uint lost;\n    int assetBalanceChange;\n    address providerBalanceChange;\n  }\n\n  MockedHandleRewardsParams private handleRewardsParams;\n\n  function setMockedHandleRewardsResults(\n    uint earned,\n    uint lost,\n    int assetBalanceChange,\n    address providerBalanceChange\n  ) external {\n    handleRewardsParams = MockedHandleRewardsParams({\n      initialized: true,\n      earned: earned,\n      lost: lost,\n      assetBalanceChange: assetBalanceChange,\n      providerBalanceChange: providerBalanceChange\n    });\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// _depositToPool mock\n  /////////////////////////////////////////////////////////////////////////////////////\n  struct MockedDepositToPoolParams {\n    bool initialized;\n    int balanceChange;\n    address providerBalanceChange;\n    uint loss;\n  }\n\n  MockedDepositToPoolParams internal depositToPoolParams;\n\n  function _depositToPoolAccess(uint amount_, bool updateTotalAssetsBeforeInvest_) external returns (\n    uint loss\n  ) {\n    return _depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n  }\n\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    uint loss\n  ){\n    if (depositToPoolParams.initialized) {\n      //      console.log(\"_depositToPool.mocked-version is called\");\n      if (depositToPoolParams.balanceChange > 0) {\n        IERC20(asset).transferFrom(\n          depositToPoolParams.providerBalanceChange,\n          address(this),\n          uint(depositToPoolParams.balanceChange)\n        );\n      } else if (depositToPoolParams.balanceChange < 0) {\n        IERC20(asset).transfer(\n          depositToPoolParams.providerBalanceChange,\n          uint(- depositToPoolParams.balanceChange)\n        );\n      }\n      loss = depositToPoolParams.loss;\n    } else {\n      loss = super._depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n    }\n  }\n\n  function setMockedDepositToPool(int balanceChange, address providerBalanceChange, uint loss) external {\n    depositToPoolParams = MockedDepositToPoolParams({\n      initialized: true,\n      balanceChange: balanceChange,\n      providerBalanceChange: providerBalanceChange,\n      loss: loss\n    });\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// Others\n  /////////////////////////////////////////////////////////////////////////////////////\n\n  function _beforeDepositAccess(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) external returns (\n    uint[] memory tokenAmounts\n  ) {\n    return _beforeDeposit(\n      tetuConverter_,\n      amount_,\n      tokens_,\n      indexAsset_\n    );\n  }\n\n  function _emergencyExitFromPoolAccess() external {\n    _emergencyExitFromPool();\n  }\n\n  function _prepareRewardsListAccess(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    return ConverterStrategyBaseLib2.claimConverterRewards(tetuConverter_, tokens_, rewardTokens_, rewardAmounts_, new uint[](0));\n  }\n\n  function _recycleAccess(address[] memory tokens, uint[] memory amounts) external returns (\n    uint[] memory amountsToForward\n  ) {\n    return _recycle(tokens, amounts);\n  }\n\n  function _makeRequestedAmountAccess(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_,\n    ITetuConverter converter_,\n    uint requestedAmount,\n    uint[] memory expectedMainAssetAmounts\n  ) external returns (\n    uint expectedTotalAmountMainAsset\n  ) {\n    return _makeRequestedAmount(tokens_, indexAsset_, amountsToConvert_, converter_, requestedAmount, expectedMainAssetAmounts);\n  }\n}\n"
    },
    "contracts/test/mocks/MockDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../strategies/DepositorBase.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/IMockToken.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\n// import \"hardhat/console.sol\";\n\n/// @title Mock contract for base Depositor.\ncontract MockDepositor is DepositorBase, Initializable {\n\n  uint[] private _depositorReserves;\n  uint[] private _depositorWeights;\n\n  address[] private _depositorAssets;\n\n  /// @notice total amount of active LP tokens.\n  uint public totalSupply;\n  uint private depositorLiquidity;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  // @notice tokens must be MockTokens\n  function __MockDepositor_init(\n    address[] memory tokens_,\n    uint[] memory depositorWeights_,\n    uint[] memory depositorReserves_\n  ) internal onlyInitializing {\n    uint tokensLength = tokens_.length;\n    for (uint i = 0; i < tokensLength; ++i) {\n      _depositorAssets.push(tokens_[i]);\n      _depositorWeights.push(depositorWeights_[i]);\n      _depositorReserves.push(depositorReserves_[i]);\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorTotalSupply\n  /////////////////////////////////////////////////////////////////////\n  function setTotalSupply(uint totalSupply_) external {\n    totalSupply = totalSupply_;\n  }\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() override internal view returns (uint) {\n    return totalSupply;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorLiquidity\n  /////////////////////////////////////////////////////////////////////\n\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return depositorLiquidity;\n  }\n\n  function setDepositorLiquidity(uint depositorLiquidity_) external {\n    depositorLiquidity = depositorLiquidity_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Misc\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Returns pool assets\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory) {\n    //    console.log(\"_depositorPoolAssets\");\n    return _depositorAssets;\n  }\n\n  /// @dev Returns pool weights\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    //    console.log(\"_depositorPoolWeights\", _depositorWeights.length);\n    weights = _depositorWeights;\n    uint len = weights.length;\n    totalWeight = 0;\n    for (uint i; i < len; i++) {\n      totalWeight += weights[i];\n    }\n  }\n\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    reserves = _depositorReserves;\n  }\n\n  function setDepositorPoolReserves(uint[] memory depositorReserves_) external {\n    _depositorReserves = depositorReserves_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorEnter\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorEnterParams {\n    uint[] amountsDesired;\n    uint[] amountsConsumed;\n    uint liquidityOut;\n  }\n\n  DepositorEnterParams internal depositorEnterParams;\n\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  ) {\n    require(_depositorAssets.length == amountsDesired_.length);\n\n    uint len = amountsDesired_.length;\n    amountsConsumed = depositorEnterParams.amountsConsumed;\n\n    for (uint i = 0; i < len; ++i) {\n      require(amountsDesired_[i] == depositorEnterParams.amountsDesired[i], \"!depositorEnter\");\n      IMockToken token = IMockToken(_depositorAssets[i]);\n      token.burn(address(this), depositorEnterParams.amountsConsumed[i]);\n    }\n\n    liquidityOut = depositorEnterParams.liquidityOut;\n    depositorLiquidity += liquidityOut;\n  }\n\n  function setDepositorEnter(uint[] memory amountsDesired_, uint[] memory amountsConsumed_, uint liquidityOut_) external {\n    depositorEnterParams.liquidityOut = liquidityOut_;\n    depositorEnterParams.amountsDesired = amountsDesired_;\n    depositorEnterParams.amountsConsumed = amountsConsumed_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorExit\n  /////////////////////////////////////////////////////////////////////\n\n  struct DepositorExitParams {\n    uint liquidityAmount;\n    uint[] amountsOut;\n  }\n\n  DepositorExitParams internal depositorExitParams;\n\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    require(liquidityAmount == depositorExitParams.liquidityAmount, \"!depositorExit\");\n\n    uint len = _depositorAssets.length;\n    amountsOut = depositorExitParams.amountsOut;\n\n    for (uint i = 0; i < len; ++i) {\n      IMockToken token = IMockToken(_depositorAssets[i]);\n      token.mint(address(this), depositorExitParams.amountsOut[i]);\n    }\n\n    // we need to modify depositorLiquidity for tests with _updateInvestedAssets\n    if (depositorLiquidity >= liquidityAmount) {\n      depositorLiquidity -= liquidityAmount;\n    }\n  }\n\n  function setDepositorExit(uint liquidityAmount_, uint[] memory amountsOut_) external {\n    //    console.log(\"MockDepositor.setDepositorExit liquidityAmount\", liquidityAmount_);\n    depositorExitParams.liquidityAmount = liquidityAmount_;\n    depositorExitParams.amountsOut = amountsOut_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorQuoteExit\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorQuoteExitParams {\n    uint liquidityAmount;\n    uint[] amountsOut;\n  }\n  /// @notice keccak256(liquidityAmount + 1) => results\n  mapping(bytes32 => DepositorQuoteExitParams) internal depositorQuoteExitParams;\n\n  /// @dev Quotes output for given lp amount from the pool.\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual view returns (uint[] memory amountsOut) {\n    bytes32 key = keccak256(abi.encodePacked(liquidityAmount + 1));\n    DepositorQuoteExitParams memory p = depositorQuoteExitParams[key];\n    if (p.liquidityAmount == liquidityAmount) {\n      amountsOut = p.amountsOut;\n    } else {\n      //console.log(\"_depositorQuoteExit.missed liquidityAmount\", liquidityAmount);\n      revert(\"MockDepositor.!liquidityAmount\");\n    }\n\n    return amountsOut;\n  }\n\n  function setDepositorQuoteExit(uint liquidityAmount_, uint[] memory amountsOut_) external {\n    //    console.log(\"setDepositorQuoteExit, liquidityAmount_\", liquidityAmount_);\n    bytes32 key = keccak256(abi.encodePacked(liquidityAmount_ + 1));\n\n    DepositorQuoteExitParams memory p = DepositorQuoteExitParams({\n    liquidityAmount : liquidityAmount_,\n    amountsOut : amountsOut_\n    });\n\n    depositorQuoteExitParams[key] = p;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorClaimRewards\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorClaimRewardsParams {\n    address[] rewardTokens;\n    uint[] rewardAmounts;\n  }\n\n  DepositorClaimRewardsParams internal depositorClaimRewardsParams;\n\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    uint[] memory balancesBefore\n  ) {\n    uint len = depositorClaimRewardsParams.rewardTokens.length;\n    rewardTokens = depositorClaimRewardsParams.rewardTokens;\n    rewardAmounts = depositorClaimRewardsParams.rewardAmounts;\n\n    for (uint i = 0; i < len; ++i) {\n      IMockToken token = IMockToken(depositorClaimRewardsParams.rewardTokens[i]);\n      token.mint(address(this), depositorClaimRewardsParams.rewardAmounts[i]);\n    }\n    return (rewardTokens, rewardAmounts, balancesBefore);\n  }\n\n  function setDepositorClaimRewards(address[] memory rewardTokens_, uint[] memory rewardAmounts_) external {\n    depositorClaimRewardsParams.rewardTokens = rewardTokens_;\n    depositorClaimRewardsParams.rewardAmounts = rewardAmounts_;\n  }\n}\n"
    },
    "contracts/test/mocks/MockTetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\";\nimport \"../../libs/AppErrors.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @notice Mock of ITetuConverter, each function saves input params and has customizable output value\n///         Some functions can be not implemented\n/// @dev We assume, that in each test only single function is called, so we can setup behavior before the call\n///      and check results after the call on the side of the script\ncontract MockTetuConverter is ITetuConverter {\n  //////////////////////////////////////////////////////////\n  ///  Controller\n  //////////////////////////////////////////////////////////\n  address public _controller;\n\n  function controller() external view returns (address) {\n    return _controller;\n  }\n\n  function setController(address controller_) external {\n    _controller = controller_;\n  }\n\n\n  //////////////////////////////////////////////////////////\n  ///  findBorrowStrategy\n  //////////////////////////////////////////////////////////\n  struct FindBorrowStrategyOutputParams {\n    bytes entryData;\n    address[] converters;\n    uint[] collateralAmountsOut;\n    uint[] amountsToBorrowOut;\n    int[] aprs18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n    uint periodInBlocks;\n  }\n  /// @notice keccak256(entryData, sourceToken, targetToken) => results\n  mapping(bytes32 => FindBorrowStrategyOutputParams) public findBorrowStrategyOutputParams;\n\n  function findBorrowStrategies(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountsToBorrowOut,\n    int[] memory aprs18\n  ) {\n    periodInBlocks_;\n    console.log(\"MockTetuConverter.findBorrowStrategies token,amountIn\", sourceToken_, amountIn_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindBorrowStrategyOutputParams memory p = findBorrowStrategyOutputParams[key];\n    console.log(\"MockTetuConverter.p.sourceToken\", p.sourceToken);\n    if (sourceToken_ == p.sourceToken) {\n      return (\n      p.converters,\n      p.collateralAmountsOut,\n      p.amountsToBorrowOut,\n      p.aprs18\n      );\n    } else {\n      console.log(\"findBorrowStrategy.missed\", _tokenName(sourceToken_), amountIn_, _tokenName(targetToken_));\n      return (converters, collateralAmountsOut, amountsToBorrowOut, aprs18);\n    }\n  }\n\n  function setFindBorrowStrategyOutputParams(\n    bytes memory entryData_,\n    address[] memory converters_,\n    uint[] memory collateralAmountsOut_,\n    uint[] memory amountToBorrowsOut_,\n    int[] memory aprs18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external {\n    console.log(\"setFindBorrowStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    findBorrowStrategyOutputParams[key] = FindBorrowStrategyOutputParams({\n    entryData : entryData_,\n    converters : converters_,\n    collateralAmountsOut : collateralAmountsOut_,\n    amountsToBorrowOut : amountToBorrowsOut_,\n    aprs18 : aprs18_,\n    sourceAmount : sourceAmount_,\n    sourceToken : sourceToken_,\n    targetToken : targetToken_,\n    periodInBlocks : periodInBlocks_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  findSwapStrategy\n  //////////////////////////////////////////////////////////\n  struct FindSwapStrategyOutputParams {\n    bytes entryData;\n    address converter;\n    uint sourceAmountOut;\n    uint targetAmountOut;\n    int apr18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n  }\n  /// @notice keccak256(entryData_, sourceToken, targetToken) => results\n  mapping(bytes32 => FindSwapStrategyOutputParams) public findSwapStrategyOutputParams;\n\n  function findSwapStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external view returns (\n    address converter,\n    uint sourceAmountOut,\n    uint targetAmountOut,\n    int apr18\n  ) {\n    console.log(\"MockTetuConverter.findSwapStrategy token,amount\", sourceToken_, sourceAmount_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindSwapStrategyOutputParams memory p = findSwapStrategyOutputParams[key];\n    if (sourceToken_ == p.sourceToken) {\n      return (p.converter, p.sourceAmountOut, p.targetAmountOut, p.apr18);\n    } else {\n      console.log(\"findSwapStrategy.missed\", _tokenName(sourceToken_), sourceAmount_, _tokenName(targetToken_));\n      return (converter, sourceAmountOut, targetAmountOut, apr18);\n    }\n  }\n\n  function setFindSwapStrategyOutputParams(\n    bytes memory entryData_,\n    address converter_,\n    uint sourceAmountOut_,\n    uint targetAmountOut_,\n    int apr18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external {\n    console.log(\"setFindSwapStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(sourceToken_, targetToken_));\n    findSwapStrategyOutputParams[key] = FindSwapStrategyOutputParams({\n    entryData : entryData_,\n    converter : converter_,\n    sourceAmountOut : sourceAmountOut_,\n    targetAmountOut : targetAmountOut_,\n    apr18 : apr18_,\n    sourceToken : sourceToken_,\n    sourceAmount : sourceAmount_,\n    targetToken : targetToken_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  findConversionStrategy\n  //////////////////////////////////////////////////////////\n  struct FindConversionStrategyOutputParams {\n    bytes entryData;\n    address converter;\n    uint amountToBorrowOut;\n    uint collateralAmountOut;\n    int apr18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n    uint periodInBlocks;\n  }\n  /// @notice keccak256(entryData, sourceToken, targetToken) => results\n  mapping(bytes32 => FindConversionStrategyOutputParams) public findConversionStrategyOutputParams;\n\n  function findConversionStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address converter,\n    uint collateralAmountOut,\n    uint amountToBorrowOut,\n    int apr18\n  ) {\n    periodInBlocks_;\n    console.log(\"MockTetuConverter.findConversionStrategy token,amount\", sourceToken_, sourceAmount_);\n\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindConversionStrategyOutputParams memory p = findConversionStrategyOutputParams[key];\n    if (sourceToken_ == p.sourceToken) {\n      return (p.converter, p.collateralAmountOut, p.amountToBorrowOut, p.apr18);\n    } else {\n      console.log(\"findConversionStrategy.missed\", _tokenName(sourceToken_), sourceAmount_, _tokenName(targetToken_));\n      return (converter, collateralAmountOut, amountToBorrowOut, apr18);\n    }\n  }\n\n  function setFindConversionStrategyOutputParams(\n    bytes memory entryData_,\n    address converter_,\n    uint collateralAmountOut_,\n    uint amountToBorrowOut_,\n    int apr18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external {\n    console.log(\"setFindConversionStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    findConversionStrategyOutputParams[key] = FindConversionStrategyOutputParams({\n    entryData : entryData_,\n    converter : converter_,\n    collateralAmountOut : collateralAmountOut_,\n    amountToBorrowOut : amountToBorrowOut_,\n    apr18 : apr18_,\n    sourceAmount : sourceAmount_,\n    sourceToken : sourceToken_,\n    targetToken : targetToken_,\n    periodInBlocks : periodInBlocks_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  borrow\n  //////////////////////////////////////////////////////////\n  struct BorrowParams {\n    uint borrowedAmountOut;\n\n    address converter;\n    address collateralAsset;\n    uint collateralAmount;\n    address borrowAsset;\n    uint amountToBorrow;\n    address receiver;\n  }\n  /// @notice keccak256(converter_, collateralAsset_, collateralAmount_, borrowAsset_) => results\n  mapping(bytes32 => BorrowParams) public borrowParams;\n\n  function borrow(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_\n  ) external returns (\n    uint borrowedAmountOut\n  ) {\n    console.log(\"MockTetuConverter.borrow token,amount\", _tokenName(collateralAsset_), collateralAmount_);\n    bytes32 key = keccak256(abi.encodePacked(converter_, collateralAsset_, collateralAmount_, borrowAsset_));\n    BorrowParams memory p = borrowParams[key];\n    if (converter_ == p.converter\n    && collateralAsset_ == p.collateralAsset\n    && collateralAmount_ == p.collateralAmount\n      && borrowAsset_ == p.borrowAsset\n    ) {\n      IERC20Metadata(collateralAsset_).transferFrom(msg.sender, address(this), collateralAmount_);\n\n      uint balance = IERC20Metadata(borrowAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverter.borrow.balance, amountToBorrow_\", balance, amountToBorrow_);\n      require(balance >= amountToBorrow_, \"MockTetuConverter.borrow.balance\");\n      IERC20Metadata(borrowAsset_).transfer(receiver_, amountToBorrow_);\n\n      return p.borrowedAmountOut;\n    } else {\n      console.log(\"MockTetuConverter.borrow.missed.collateralAsset_\", _tokenName(collateralAsset_));\n      console.log(\"MockTetuConverter.borrow.missed.collateralAmount_\", collateralAmount_);\n      console.log(\"MockTetuConverter.borrow.missed.borrowAsset_\", _tokenName(borrowAsset_));\n      console.log(\"MockTetuConverter.borrow.missed.amountToBorrow_\", amountToBorrow_);\n      return 0;\n    }\n  }\n\n  function setBorrowParams(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_,\n    uint borrowedAmountOut_\n  ) external {\n    console.log(\"setBorrowParams\", collateralAsset_, collateralAmount_, borrowAsset_);\n    bytes32 key = keccak256(abi.encodePacked(converter_, collateralAsset_, collateralAmount_, borrowAsset_));\n    borrowParams[key] = BorrowParams({\n    converter : converter_,\n    collateralAsset : collateralAsset_,\n    collateralAmount : collateralAmount_,\n    borrowAsset : borrowAsset_,\n    amountToBorrow : amountToBorrow_,\n    receiver : receiver_,\n    borrowedAmountOut : borrowedAmountOut_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  repay\n  //////////////////////////////////////////////////////////\n  struct RepayParams {\n    address collateralAsset;\n    address borrowAsset;\n    uint amountToRepay;\n    address receiver;\n    uint collateralAmountOut;\n    uint returnedBorrowAmountOut;\n    uint swappedLeftoverCollateralOut;\n    uint swappedLeftoverBorrowOut;\n    uint debtGapValue;\n  }\n  /// @notice keccak256(collateralAsset_, borrowAsset_, amountToRepay_) => results\n  mapping(bytes32 => RepayParams) public repayParams;\n\n  function repay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_\n  ) external returns (\n    uint collateralAmountOut,\n    uint returnedBorrowAmountOut,\n    uint swappedLeftoverCollateralOut,\n    uint swappedLeftoverBorrowOut\n  ) {\n    console.log(\"MockTetuConverter.repay collateral,borrow,amount\", _tokenName(collateralAsset_), _tokenName(borrowAsset_), amountToRepay_);\n\n    require(IERC20Metadata(borrowAsset_).balanceOf(address(this)) == amountToRepay_, \"MockTetuConverter.repay.amountToRepay_\");\n\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    RepayParams memory p = repayParams[key];\n    if (collateralAsset_ == p.collateralAsset && borrowAsset_ == p.borrowAsset && amountToRepay_ == p.amountToRepay) {\n      // transfer collateral back to the strategy\n      uint balanceCollateral = IERC20Metadata(collateralAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverter.repay balanceCollateral, collateralAmountOut\", balanceCollateral, p.collateralAmountOut);\n      require(balanceCollateral >= p.collateralAmountOut, \"MockTetuConverter.repay.collateralAmountOut\");\n      IERC20Metadata(collateralAsset_).transfer(receiver_, p.collateralAmountOut);\n\n      // return debtGap if any\n      uint balanceBorrow = IERC20Metadata(borrowAsset_).balanceOf(address(this));\n      if (p.debtGapValue != 0) {\n        require(balanceBorrow >= p.debtGapValue, \"MockTetuConverter.repay.debtGapValue\");\n        IERC20Metadata(borrowAsset_).transfer(receiver_, p.debtGapValue);\n      }\n\n      // needToRepay was bigger than amountRepaid, we need to return the leftover back to the strategy\n      balanceBorrow = IERC20Metadata(borrowAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverter.repay balanceBorrow, returnedBorrowAmountOut\", balanceBorrow, p.returnedBorrowAmountOut);\n      if (p.returnedBorrowAmountOut != 0) {\n        require(balanceBorrow >= p.returnedBorrowAmountOut, \"MockTetuConverter.repay.returnedBorrowAmountOut\");\n        IERC20Metadata(borrowAsset_).transfer(receiver_, p.returnedBorrowAmountOut);\n      }\n\n      return (\n        p.collateralAmountOut,\n        p.returnedBorrowAmountOut,\n        p.swappedLeftoverCollateralOut,\n        p.swappedLeftoverBorrowOut\n      );\n    } else {\n      console.log(\"MockTetuConverter.repay.missed collateral,borrow,amountToRepay\", _tokenName(collateralAsset_), _tokenName(borrowAsset_), amountToRepay_);\n      return (collateralAmountOut, returnedBorrowAmountOut, swappedLeftoverCollateralOut, swappedLeftoverBorrowOut);\n    }\n  }\n\n  function setRepay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_,\n    uint collateralAmountOut_,\n    uint returnedBorrowAmountOut_,\n    uint swappedLeftoverCollateralOut_,\n    uint swappedLeftoverBorrowOut_,\n    uint debtGapValue\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    repayParams[key] = RepayParams({\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      amountToRepay: amountToRepay_,\n      receiver: receiver_,\n      collateralAmountOut: collateralAmountOut_,\n      returnedBorrowAmountOut: returnedBorrowAmountOut_,\n      swappedLeftoverCollateralOut: swappedLeftoverCollateralOut_,\n      swappedLeftoverBorrowOut: swappedLeftoverBorrowOut_,\n      debtGapValue: debtGapValue\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  quoteRepay\n  //////////////////////////////////////////////////////////\n  struct QuoteRepayParams {\n    address user;\n    address collateralAsset;\n    address borrowAsset;\n    uint amountToRepay;\n    uint collateralAmountOut;\n    uint swappedAmountOut;\n  }\n  /// @notice keccak256(collateralAsset_, borrowAsset_, amountToRepay_) => results\n  mapping(bytes32 => QuoteRepayParams) public quoteRepayParams;\n\n  function quoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_\n  ) external view returns (\n    uint collateralAmountOut,\n    uint swappedAmountOut\n  ) {\n    user_;\n    // hide warning\n    console.log(\"MockTetuConverter.quoteRepay collateral,borrow,amount\", _tokenName(collateralAsset_), _tokenName(borrowAsset_), amountToRepay_);\n\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    QuoteRepayParams memory p = quoteRepayParams[key];\n    if (p.collateralAsset == collateralAsset_) {\n      return (p.collateralAmountOut, p.swappedAmountOut);\n    } else {\n      console.log(\"MockTetuConverter.quoteRepay.missed amountToRepay_,collateralAsset_,borrowAsset_\", amountToRepay_, _tokenName(collateralAsset_), _tokenName(borrowAsset_));\n      return (0, 0);\n    }\n  }\n\n  function setQuoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    uint collateralAmountOut,\n    uint swappedAmountOut\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    quoteRepayParams[key] = QuoteRepayParams({\n      user: user_,\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      amountToRepay: amountToRepay_,\n      collateralAmountOut: collateralAmountOut,\n      swappedAmountOut: swappedAmountOut\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  getDebtAmountCurrent\n  //////////////////////////////////////////////////////////\n  struct GetDebtAmountParams {\n    address user;\n    address collateralAsset;\n    address borrowAsset;\n    uint totalDebtAmountOut;\n    uint totalCollateralAmountOut;\n    bool useDebtGap;\n  }\n\n  /// @notice keccak256(user_, collateralAsset_, borrowAsset_, useDebtGap_) => results\n  mapping(bytes32 => GetDebtAmountParams) public getDebtAmountCurrentParams;\n\n  function getDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    bool useDebtGap_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) {\n    console.log(\"MockTetuConverter.getDebtAmountCurrent user,collateral,borrow\", user_, _tokenName(collateralAsset_), _tokenName(borrowAsset_));\n\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_, useDebtGap_));\n    GetDebtAmountParams memory p = getDebtAmountCurrentParams[key];\n    if (\n      p.user == user_\n      && p.collateralAsset == collateralAsset_\n      && p.borrowAsset == borrowAsset_\n    ) {\n      console.log(\"MockTetuConverter.getDebtAmountCurrent totalDebtAmountOut,totalCollateralAmountOut\",\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut\n      );\n      return (\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut\n      );\n    } else {\n      console.log(\"MockTetuConverter.getDebtAmountCurrent.missed user,collateral,borrow\", user_, _tokenName(collateralAsset_), _tokenName(borrowAsset_));\n      console.log(\"MockTetuConverter.getDebtAmountCurrent.missed useDebtGap\", useDebtGap_);\n      return (0, 0);\n    }\n  }\n\n  function setGetDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut,\n    bool useDebtGap\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_, useDebtGap));\n    getDebtAmountCurrentParams[key] = GetDebtAmountParams({\n      user: user_,\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      totalCollateralAmountOut: totalCollateralAmountOut,\n      totalDebtAmountOut: totalDebtAmountOut,\n      useDebtGap: useDebtGap\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  getDebtAmountStored\n  //////////////////////////////////////////////////////////\n  /// @notice keccak256(user_, collateralAsset_, borrowAsset_, useDebtGap_) => results\n  mapping(bytes32 => GetDebtAmountParams) public getDebtAmountStoredParams;\n\n  function getDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    bool useDebtGap_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) {\n    console.log(\"MockTetuConverter.getDebtAmountStored user,collateral,borrow\", user_, _tokenName(collateralAsset_), _tokenName(borrowAsset_));\n\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_, useDebtGap_));\n    GetDebtAmountParams memory p = getDebtAmountCurrentParams[key];\n    if (p.user == user_) {\n      console.log(\"MockTetuConverter.getDebtAmountStored totalDebtAmountOut,totalCollateralAmountOut,useDebtGap_\",\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut,\n        useDebtGap_\n      );\n      return (\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut\n      );\n    } else {\n      console.log(\"MockTetuConverter.getDebtAmountStored.missed user,collateral,borrow\", user_, _tokenName(collateralAsset_), _tokenName(borrowAsset_));\n      console.log(\"MockTetuConverter.getDebtAmountStored.missed useDebtGap_\", useDebtGap_);\n      return (0, 0);\n    }\n  }\n\n  function setGetDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut,\n    bool useDebtGap\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_, useDebtGap));\n    getDebtAmountStoredParams[key] = GetDebtAmountParams({\n      user: user_,\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      totalCollateralAmountOut: totalCollateralAmountOut,\n      totalDebtAmountOut: totalDebtAmountOut,\n      useDebtGap: useDebtGap\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  estimateRepay\n  //////////////////////////////////////////////////////////\n  function estimateRepay(\n    address user_,\n    address collateralAsset_,\n    uint collateralAmountRequired_,\n    address borrowAsset_\n  ) external pure returns (\n    uint borrowAssetAmount,\n    uint unobtainableCollateralAssetAmount\n  ) {\n    user_;\n    collateralAsset_;\n    collateralAmountRequired_;\n    borrowAsset_;\n    borrowAssetAmount;\n    unobtainableCollateralAssetAmount;\n    revert (\"estimateRepay is not implemented\");\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  claimRewards\n  //////////////////////////////////////////////////////////\n  struct ClaimRewardsParams {\n    address[] rewardTokensOut;\n    uint[] amountsOut;\n  }\n\n  ClaimRewardsParams private claimRewardsParams;\n\n  function claimRewards(address receiver_) external returns (\n    address[] memory rewardTokensOut,\n    uint[] memory amountsOut\n  ) {\n    for (uint i = 0; i < claimRewardsParams.rewardTokensOut.length; ++i) {\n      uint balance = IERC20Metadata(claimRewardsParams.rewardTokensOut[i]).balanceOf(address(this));\n      console.log(\"claimRewards asset, balance, amountOut\", claimRewardsParams.rewardTokensOut[i], balance, claimRewardsParams.amountsOut[i]);\n      IERC20Metadata(claimRewardsParams.rewardTokensOut[i]).transfer(receiver_, claimRewardsParams.amountsOut[i]);\n    }\n    return (claimRewardsParams.rewardTokensOut, claimRewardsParams.amountsOut);\n  }\n\n  function setClaimRewards(address[] memory rewardTokensOut, uint[] memory amountsOut) external {\n    claimRewardsParams = ClaimRewardsParams({\n    rewardTokensOut : rewardTokensOut,\n    amountsOut : amountsOut\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  Safe liquidation\n  //////////////////////////////////////////////////////////\n  function safeLiquidate(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    address receiver_,\n    uint priceImpactToleranceSource_,\n    uint priceImpactToleranceTarget_\n  ) external pure returns (\n    uint amountOut\n  ) {\n    assetIn_;\n    amountIn_;\n    assetOut_;\n    receiver_;\n    priceImpactToleranceSource_;\n    priceImpactToleranceTarget_;\n    amountOut;\n    revert(\"safeLiquidate is not implemented\");\n  }\n\n  //region ----------------------------------------------  isConversionValid\n  enum SetIsConversionValidResult {\n    FAILED_0,\n    SUCCESS_1,\n    PRICE_ZERO_ERROR_2\n  }\n\n  struct IsConversionValidParams {\n    address assetIn;\n    uint amountIn;\n    address assetOut;\n    uint amountOut;\n    SetIsConversionValidResult result;\n  }\n  /// @notice keccak256(assetIn_, amountIn_, assetOut_, amountOut_) => results\n  mapping(bytes32 => IsConversionValidParams) public isConversionValidParams;\n\n  function isConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    uint priceImpactTolerance_\n  ) external view returns (bool) {\n    bytes32 key = keccak256(abi.encodePacked(assetIn_, amountIn_, assetOut_, amountOut_));\n    priceImpactTolerance_;\n    IsConversionValidParams memory p = isConversionValidParams[key];\n    if (p.assetIn == assetIn_) {\n      if (p.result == SetIsConversionValidResult.FAILED_0) {\n        return false;\n      } else if (p.result == SetIsConversionValidResult.SUCCESS_1) {\n        return true;\n      } else {\n        revert(AppErrors.ZERO_PRICE);\n      }\n    } else {\n      console.log(\"isConversionValid assetIn\", _tokenName(assetIn_), amountIn_);\n      console.log(\"isConversionValid assetOut\", _tokenName(assetOut_), amountOut_);\n      revert(\"isConversionValid is missed\");\n    }\n  }\n\n  function setIsConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    SetIsConversionValidResult result_\n  ) external {\n    console.log(\"setIsConversionValid assetIn\", assetIn_, amountIn_);\n    console.log(\"setIsConversionValid assetOut\", assetOut_, amountOut_);\n    bytes32 key = keccak256(abi.encodePacked(assetIn_, amountIn_, assetOut_, amountOut_));\n    isConversionValidParams[key] = IsConversionValidParams({\n      assetIn: assetIn_,\n      amountIn: amountIn_,\n      assetOut: assetOut_,\n      amountOut: amountOut_,\n      result: result_\n    });\n  }\n  //endregion ----------------------------------------------  isConversionValid\n\n\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external pure returns (\n    uint collateralAmountOut,\n    uint repaidAmountOut\n  ) {\n    poolAdapter_;\n    closePosition;\n    return (collateralAmountOut, repaidAmountOut);\n  }\n\n  function _tokenName(address token) internal view returns (string memory) {\n    return IERC20Metadata(token).symbol();\n  }\n\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external pure returns (\n    address[] memory poolAdaptersOut\n  ) {\n    user_; // hide warning\n    collateralToken_; // hide warning\n    borrowedToken_; // hide warning\n\n    return poolAdaptersOut;\n  }\n\n  function salvage(address receiver, address token, uint amount) external pure {\n    receiver;\n    token;\n    amount;\n    // not implemented\n  }\n\n}\n"
    },
    "contracts/test/Typechain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// import contracts here from node_moules to include it in to typechain\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockToken.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/proxy/ProxyControlled.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/Multicall.sol\";\n\n// for hardhat chain quick tests\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/ControllerMinimal.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockGauge.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockStrategy.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockStrategySimple.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockSplitter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/TetuVaultV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/VaultInsurance.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/StrategySplitterV2.sol\";\n\n// for TokenUtils / Tests\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeTetu.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IPlatformVoter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeDistributor.sol\";\n\n//\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/VaultFactory.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/infrastructure/ForwarderV3.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/infrastructure/ControllerV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/infrastructure/PlatformVoter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/infrastructure/InvestFundV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/ve/VeTetu.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/ve/VeDistributor.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/ve/TetuVoter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/reward/MultiGauge.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/reward/MultiBribe.sol\";\n\n\ncontract ___typechain___ {}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 150
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "storageLayout",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}