{
  "language": "Solidity",
  "sources": {
    "@tetu_io/tetu-contracts-v2/contracts/infrastructure/ControllerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/EnumerableMap.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title A central contract of the TETU platform.\n///        Holds all important contract addresses.\n///        Able to upgrade proxies with time-lock.\n/// @author belbix\ncontract ControllerV2 is ControllableV3, IController {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using EnumerableMap for EnumerableMap.UintToUintMap;\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n  enum AddressType {\n    UNKNOWN, // 0\n    GOVERNANCE, // 1\n    TETU_VOTER, // 2\n    PLATFORM_VOTER, // 3\n    LIQUIDATOR, // 4\n    FORWARDER, // 5\n    INVEST_FUND, // 6\n    VE_DIST // 7\n  }\n\n  struct AddressAnnounce {\n    uint _type;\n    address newAddress;\n    uint timeLockAt;\n  }\n\n  struct ProxyAnnounce {\n    address proxy;\n    address implementation;\n    uint timeLockAt;\n  }\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant CONTROLLER_VERSION = \"2.0.1\";\n  uint public constant TIME_LOCK = 18 hours;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  // --- restrictions\n\n  /// @dev Gnosis safe multi signature wallet with maximum power under the platform.\n  address public override governance;\n  /// @dev Operators can execute not-critical functions of the platform.\n  EnumerableSet.AddressSet internal _operators;\n\n  // --- dependency\n\n  /// @dev Voter for distribute TETU to gauges.\n  address public override voter;\n  /// @dev External solution for sell any tokens with minimal gas usage.\n  address public override liquidator;\n  /// @dev Accumulate performance fees and distribute them properly.\n  address public override forwarder;\n  /// @dev Contract for holding assets for the Second Stage\n  address public override investFund;\n  /// @dev Contract for accumulate TETU rewards for veTETU and weekly distribute them.\n  address public override veDistributor;\n  /// @dev Special voter for platform attributes.\n  address public override platformVoter;\n\n  // --- elements\n\n  /// @dev Set of valid vaults\n  EnumerableSet.AddressSet internal _vaults;\n\n  // --- time locks\n\n  EnumerableMap.UintToUintMap internal _addressTimeLocks;\n  EnumerableMap.UintToAddressMap internal _addressAnnounces;\n\n  EnumerableMap.AddressToUintMap internal _proxyTimeLocks;\n  mapping(address => address) public proxyAnnounces;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event AddressChangeAnnounced(uint _type, address value);\n  event AddressChanged(uint _type, address oldAddress, address newAddress);\n  event AddressAnnounceRemove(uint _type);\n  event ProxyUpgradeAnnounced(address proxy, address implementation);\n  event ProxyUpgraded(address proxy, address implementation);\n  event ProxyAnnounceRemoved(address proxy);\n  event RegisterVault(address vault);\n  event VaultRemoved(address vault);\n  event OperatorAdded(address operator);\n  event OperatorRemoved(address operator);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(address _governance) external initializer {\n    require(_governance != address(0), \"WRONG_INPUT\");\n    governance = _governance;\n    __Controllable_init(address(this));\n    _operators.add(_governance);\n  }\n\n  // *************************************************************\n  //                     RESTRICTIONS\n  // *************************************************************\n\n  function _onlyGovernance() internal view {\n    require(msg.sender == governance, \"DENIED\");\n  }\n\n  function _onlyOperators() internal view {\n    require(_operators.contains(msg.sender), \"DENIED\");\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Return all announced address changes.\n  function addressAnnouncesList() external view returns (AddressAnnounce[] memory announces) {\n    uint length = _addressTimeLocks.length();\n    announces = new AddressAnnounce[](length);\n    for (uint i; i < length; ++i) {\n      (uint _type, uint timeLock) = _addressTimeLocks.at(i);\n      address newAddress = _addressAnnounces.get(_type);\n      announces[i] = AddressAnnounce(_type, newAddress, timeLock);\n    }\n  }\n\n  /// @dev Return all announced proxy upgrades.\n  function proxyAnnouncesList() external view returns (ProxyAnnounce[] memory announces) {\n    uint length = _proxyTimeLocks.length();\n    announces = new ProxyAnnounce[](length);\n    for (uint i; i < length; ++i) {\n      (address proxy, uint timeLock) = _proxyTimeLocks.at(i);\n      address implementation = proxyAnnounces[proxy];\n      announces[i] = ProxyAnnounce(proxy, implementation, timeLock);\n    }\n  }\n\n  /// @dev Return true if the value exist in the operator set.\n  function isOperator(address value) external view override returns (bool) {\n    return _operators.contains(value);\n  }\n\n  /// @dev Return all operators. Expect the array will have reasonable size.\n  function operatorsList() external view returns (address[] memory) {\n    return _operators.values();\n  }\n\n  /// @dev Return all vaults. Array can be too big for use this function.\n  function vaultsList() external view override returns (address[] memory) {\n    return _vaults.values();\n  }\n\n  /// @dev Vault set size.\n  function vaultsListLength() external view override returns (uint) {\n    return _vaults.length();\n  }\n\n  /// @dev Return vault with given id. Ordering can be changed with time!\n  function vaults(uint id) external view override returns (address) {\n    return _vaults.at(id);\n  }\n\n  /// @dev Return true if the vault valid.\n  function isValidVault(address _vault) external view override returns (bool) {\n    return _vaults.contains(_vault);\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLER || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //          SET ADDRESSES WITH TIME-LOCK PROTECTION\n  // *************************************************************\n\n  /// @dev Add announce information for given address type.\n  function announceAddressChange(AddressType _type, address value) external {\n    _onlyGovernance();\n    require(value != address(0), \"ZERO_VALUE\");\n    require(_addressAnnounces.set(uint(_type), value), \"ANNOUNCED\");\n    _addressTimeLocks.set(uint(_type), block.timestamp + TIME_LOCK);\n\n    emit AddressChangeAnnounced(uint(_type), value);\n  }\n\n  /// @dev Change time-locked address and remove lock info.\n  ///      Less strict for reduce governance actions.\n  function changeAddress(AddressType _type) external {\n    _onlyOperators();\n\n    address newAddress = _addressAnnounces.get(uint(_type));\n    uint timeLock = _addressTimeLocks.get(uint(_type));\n    // no need to check values - get for non-exist values will be reverted\n    address oldAddress;\n\n    if (_type == AddressType.GOVERNANCE) {\n      oldAddress = governance;\n      governance = newAddress;\n\n    } else if (_type == AddressType.TETU_VOTER) {\n      oldAddress = voter;\n      voter = newAddress;\n\n    } else if (_type == AddressType.LIQUIDATOR) {\n      oldAddress = liquidator;\n      liquidator = newAddress;\n\n    } else if (_type == AddressType.FORWARDER) {\n      _requireInterface(newAddress, InterfaceIds.I_FORWARDER);\n      oldAddress = forwarder;\n      forwarder = newAddress;\n\n    } else if (_type == AddressType.INVEST_FUND) {\n      oldAddress = investFund;\n      investFund = newAddress;\n\n    } else if (_type == AddressType.VE_DIST) {\n      _requireInterface(newAddress, InterfaceIds.I_VE_DISTRIBUTOR);\n      oldAddress = veDistributor;\n      veDistributor = newAddress;\n\n    } else if (_type == AddressType.PLATFORM_VOTER) {\n      _requireInterface(newAddress, InterfaceIds.I_PLATFORM_VOTER);\n      oldAddress = platformVoter;\n      platformVoter = newAddress;\n    } else {\n      revert(\"UNKNOWN\");\n    }\n\n    // skip time-lock for initialization\n    if (oldAddress != address(0)) {\n      require(timeLock < block.timestamp, \"LOCKED\");\n    }\n\n    _addressAnnounces.remove(uint(_type));\n    _addressTimeLocks.remove(uint(_type));\n\n    emit AddressChanged(uint(_type), oldAddress, newAddress);\n  }\n\n  /// @dev Remove announced address change.\n  function removeAddressAnnounce(AddressType _type) external {\n    _onlyOperators();\n\n    _addressAnnounces.remove(uint(_type));\n    _addressTimeLocks.remove(uint(_type));\n\n    emit AddressAnnounceRemove(uint(_type));\n  }\n\n  // *************************************************************\n  //          UPGRADE PROXIES WITH TIME-LOCK PROTECTION\n  // *************************************************************\n\n  function announceProxyUpgrade(\n    address[] memory proxies,\n    address[] memory implementations\n  ) external {\n    _onlyGovernance();\n    require(proxies.length == implementations.length, \"WRONG_INPUT\");\n\n    for (uint i; i < proxies.length; i++) {\n      address proxy = proxies[i];\n      address implementation = implementations[i];\n\n      require(implementation != address(0), \"ZERO_IMPL\");\n      require(_proxyTimeLocks.set(proxy, block.timestamp + TIME_LOCK), \"ANNOUNCED\");\n      proxyAnnounces[proxy] = implementation;\n\n      emit ProxyUpgradeAnnounced(proxy, implementation);\n    }\n  }\n\n  /// @dev Upgrade proxy. Less strict for reduce governance actions.\n  function upgradeProxy(address[] memory proxies) external {\n    _onlyOperators();\n\n    for (uint i; i < proxies.length; i++) {\n      address proxy = proxies[i];\n      uint timeLock = _proxyTimeLocks.get(proxy);\n      // Map get will revert on not exist key, no need to check to zero\n      address implementation = proxyAnnounces[proxy];\n\n      require(timeLock < block.timestamp, \"LOCKED\");\n\n      IProxyControlled(proxy).upgrade(implementation);\n\n      _proxyTimeLocks.remove(proxy);\n      delete proxyAnnounces[proxy];\n\n      emit ProxyUpgraded(proxy, implementation);\n    }\n  }\n\n  function removeProxyAnnounce(address proxy) external {\n    _onlyOperators();\n\n    _proxyTimeLocks.remove(proxy);\n    delete proxyAnnounces[proxy];\n\n    emit ProxyAnnounceRemoved(proxy);\n  }\n\n  // *************************************************************\n  //                     REGISTER ACTIONS\n  // *************************************************************\n\n  /// @dev Register vault in the system.\n  ///      Operator should do it as part of deployment process.\n  function registerVault(address vault) external {\n    _onlyOperators();\n\n    require(_vaults.add(vault), \"EXIST\");\n    emit RegisterVault(vault);\n  }\n\n  /// @dev Remove vault from the system. Only for critical cases.\n  function removeVault(address vault) external {\n    _onlyGovernance();\n\n    require(_vaults.remove(vault), \"NOT_EXIST\");\n    emit VaultRemoved(vault);\n  }\n\n  /// @dev Register new operator.\n  function registerOperator(address value) external {\n    _onlyGovernance();\n\n    require(_operators.add(value), \"EXIST\");\n    emit OperatorAdded(value);\n  }\n\n  /// @dev Remove operator.\n  function removeOperator(address value) external {\n    _onlyGovernance();\n\n    require(_operators.remove(value), \"NOT_EXIST\");\n    emit OperatorRemoved(value);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/infrastructure/ForwarderV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/ITetuLiquidator.sol\";\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../interfaces/IMultiPool.sol\";\nimport \"../interfaces/IBribe.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title This contract should contains a buffer of fees from strategies.\n///        Periodically sell rewards and distribute to their destinations.\n/// @author belbix\ncontract ForwarderV3 is ReentrancyGuard, ControllableV3, IForwarder {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant FORWARDER_VERSION = \"3.0.0\";\n  /// @dev Denominator for different ratios. It is default for the whole platform.\n  uint public constant RATIO_DENOMINATOR = 100_000;\n  /// @dev If slippage not defined for concrete token will be used 5% tolerance.\n  uint public constant DEFAULT_SLIPPAGE = 5_000;\n  /// @dev Max handled destinations from queue per call.\n  uint public constant MAX_DESTINATIONS = 50;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  // -- ratios\n\n  /// @dev Percent of tokens for Invest Fund\n  uint public toInvestFundRatio;\n  /// @dev Percent of tokens for gauges.\n  uint public toGaugesRatio;\n\n  // -- convert options\n\n  /// @dev We will convert all tokens to TETU and distribute to destinations.\n  address public tetu;\n  /// @dev Contract for bribes distribution\n  address public bribe;\n  /// @dev Minimum amount of TETU tokens for distribution.\n  uint public tetuThreshold;\n  /// @dev Specific slippages for volatile tokens.\n  mapping(address => uint) public tokenSlippage;\n\n  // -- registered destinations\n\n  /// @dev Tokens ready for distribution\n  ///      This Set need for easy handle tokens off-chain, can be removed for gas optimisation.\n  EnumerableSet.AddressSet internal _queuedTokens;\n  /// @dev Token => Set of destinations with positive balances for the given token\n  mapping(address => EnumerableSet.AddressSet) internal _destinationQueue;\n  /// @dev Destination => Tokens ready to distribute\n  mapping(address => EnumerableSet.AddressSet) internal _tokensPerDestination;\n  /// @dev Token => Destination => Registered amount\n  mapping(address => mapping(address => uint)) public amountPerDestination;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Distributed(\n    address sender,\n    address incomeToken,\n    uint queuedBalance,\n    uint tetuValue,\n    uint tetuBalance,\n    uint toInvestFund,\n    uint toGauges,\n    uint toBribes\n  );\n  event InvestFundRatioChanged(uint oldValue, uint newValue);\n  event GaugeRatioChanged(uint oldValue, uint newValue);\n  event TetuThresholdChanged(uint oldValue, uint newValue);\n  event SlippageChanged(address token, uint value);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(address controller_, address _tetu, address _bribe) external initializer {\n    _requireInterface(_bribe, InterfaceIds.I_BRIBE);\n    _requireERC20(_tetu);\n    __Controllable_init(controller_);\n    tetu = _tetu;\n    bribe = _bribe;\n    // 10k TETU by default\n    tetuThreshold = 10_000 * 1e18;\n  }\n\n  // *************************************************************\n  //                      GOV ACTIONS\n  // *************************************************************\n\n  /// @dev Check that sender is governance.\n  function _onlyGov() internal view {\n    require(isGovernance(msg.sender), \"DENIED\");\n  }\n\n  /// @dev Set specific token slippage for given token.\n  function setSlippage(address token, uint value) external {\n    _onlyGov();\n    require(value < RATIO_DENOMINATOR, \"TOO_HIGH\");\n\n    tokenSlippage[token] = value;\n    emit SlippageChanged(token, value);\n  }\n\n  /// @dev Set TETU threshold for distribution.\n  function setTetuThreshold(uint value) external {\n    _onlyGov();\n\n    emit TetuThresholdChanged(tetuThreshold, value);\n    tetuThreshold = value;\n  }\n\n  // *************************************************************\n  //                     VOTER ACTIONS\n  // *************************************************************\n\n  /// @dev Check that sender is platform voter.\n  function _onlyPlatformVoter() internal view {\n    require(msg.sender == IController(controller()).platformVoter(), \"DENIED\");\n  }\n\n  /// @dev veTETU holders can change proportion via special voter.\n  function setInvestFundRatio(uint value) external override {\n    _onlyPlatformVoter();\n    require(value <= RATIO_DENOMINATOR, \"TOO_HIGH\");\n\n    emit InvestFundRatioChanged(toInvestFundRatio, value);\n    toInvestFundRatio = value;\n  }\n\n  /// @dev veTETU holders can change proportion via special voter.\n  function setGaugesRatio(uint value) external override {\n    _onlyPlatformVoter();\n    require(value <= RATIO_DENOMINATOR, \"TOO_HIGH\");\n\n    emit GaugeRatioChanged(toGaugesRatio, value);\n    toGaugesRatio = value;\n  }\n\n  // *************************************************************\n  //                         VIEWS\n  // *************************************************************\n\n  /// @dev Size of array of tokens ready for distribution.\n  function queuedTokensLength() external view returns (uint) {\n    return _queuedTokens.length();\n  }\n\n  /// @dev Return queued token address for given id. Ordering can be changed between calls!\n  function queuedTokenAt(uint i) external view returns (address) {\n    return _queuedTokens.at(i);\n  }\n\n  /// @dev Size of array of tokens ready for distribution for given destination.\n  function tokenPerDestinationLength(address destination) public view override returns (uint) {\n    return _tokensPerDestination[destination].length();\n  }\n\n  /// @dev Return queued token address for given id and destination. Ordering can be changed between calls!\n  function tokenPerDestinationAt(address destination, uint i) external view override returns (address) {\n    return _tokensPerDestination[destination].at(i);\n  }\n\n  /// @dev Size of array of destinations for distribution for given token.\n  function destinationsLength(address incomeToken) external view returns (uint) {\n    return _destinationQueue[incomeToken].length();\n  }\n\n  /// @dev Return destination for given income token. Ordering can be changed between calls!\n  function destinationAt(address incomeToken, uint i) external view returns (address) {\n    return _destinationQueue[incomeToken].at(i);\n  }\n\n  /// @dev In case of too many queued destinations `targetTokenThreshold` should be lowered to reasonable value.\n  function getQueuedDestinations(address token) public view returns (\n    address[] memory queuedDestinations,\n    uint[] memory queuedAmounts,\n    uint balance\n  ){\n    EnumerableSet.AddressSet storage destinations = _destinationQueue[token];\n    mapping(address => uint) storage tokenPerDst = amountPerDestination[token];\n    uint length = Math.min(destinations.length(), MAX_DESTINATIONS);\n\n    queuedDestinations = new address[](length);\n    queuedAmounts = new uint[](length);\n    balance = 0;\n    for (uint i; i < length; ++i) {\n      address destination = destinations.at(i);\n      queuedDestinations[i] = destination;\n      uint amount = tokenPerDst[destination];\n      balance += amount;\n      queuedAmounts[i] = amount;\n    }\n  }\n\n  // *************************************************************\n  //                     REGISTER INCOME\n  // *************************************************************\n\n  /// @dev Strategy should call this on reward liquidation after compound part.\n  ///      Register tokens for the given destination.\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vaults,\n    bool isDistribute\n  ) external nonReentrant override {\n\n    for (uint i; i < tokens.length; ++i) {\n      address token = tokens[i];\n      uint amount = amounts[i];\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n      amountPerDestination[token][vaults] += amount;\n      // suppose to be not unique, relatively cheap\n      _destinationQueue[token].add(vaults);\n      _tokensPerDestination[vaults].add(token);\n      _queuedTokens.add(token);\n    }\n\n    // call it on cheap network\n    if (isDistribute) {\n      _distributeAll(vaults);\n    }\n  }\n\n  // *************************************************************\n  //                      DISTRIBUTE\n  // *************************************************************\n\n  function distributeAll(address destination) external nonReentrant override {\n    _distributeAll(destination);\n  }\n\n  function _distributeAll(address destination) internal {\n    address[] memory tokens = _tokensPerDestination[destination].values();\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      _distribute(tokens[i]);\n    }\n  }\n\n  /// @dev Try to distribute given income token using  a target token from converter.\n  ///      No strict access.\n  ///      We assume that amount will be distributed before accumulate huge value reasonable for arbitrage attack.\n  function distribute(address incomeToken) external nonReentrant override {\n    _distribute(incomeToken);\n  }\n\n  function _distribute(address incomeToken) internal {\n\n    (address[] memory vaults, uint[] memory queuedAmounts, uint queuedBalance)\n    = getQueuedDestinations(incomeToken);\n\n    IController controller_ = IController(controller());\n    address _tetu = tetu;\n\n    (uint tetuBalance, uint tetuValue) = _liquidate(controller_, incomeToken, _tetu, queuedBalance);\n\n    if (tetuBalance != 0) {\n      uint toInvestFund = tetuBalance * toInvestFundRatio / RATIO_DENOMINATOR;\n      uint toGauges = (tetuBalance - toInvestFund) * toGaugesRatio / RATIO_DENOMINATOR;\n      uint toBribes = (tetuBalance - toInvestFund) - toGauges;\n\n      if (toInvestFund != 0) {\n        IERC20(_tetu).safeTransfer(controller_.investFund(), toInvestFund);\n      }\n\n      if (toGauges != 0) {\n        address voter = controller_.voter();\n        IERC20(_tetu).safeApprove(voter, toGauges);\n        IVoter(voter).notifyRewardAmount(toGauges);\n      }\n\n      if (toBribes != 0) {\n        _distributeToBribes(\n          incomeToken,\n          _tetu,\n          vaults,\n          queuedAmounts,\n          queuedBalance,\n          toBribes\n        );\n      }\n\n      emit Distributed(\n        msg.sender,\n        incomeToken,\n        queuedBalance,\n        tetuValue,\n        tetuBalance,\n        toInvestFund,\n        toGauges,\n        toBribes\n      );\n    }\n  }\n\n  function _liquidate(\n    IController controller_,\n    address tokenIn,\n    address _tetu,\n    uint amount\n  ) internal returns (uint boughtTetu, uint tetuValue) {\n\n    if (tokenIn == _tetu) {\n      return (amount, amount);\n    }\n\n    boughtTetu = 0;\n    ITetuLiquidator _liquidator = ITetuLiquidator(controller_.liquidator());\n\n    (ITetuLiquidator.PoolData[] memory route, string memory error)\n    = _liquidator.buildRoute(tokenIn, _tetu);\n\n    if (route.length == 0) {\n      revert(error);\n    }\n\n    // calculate balance in tetu value for check threshold\n    tetuValue = _liquidator.getPriceForRoute(route, amount);\n\n    // if the value higher than threshold distribute to destinations\n    if (tetuValue > tetuThreshold) {\n\n      uint slippage = tokenSlippage[tokenIn];\n      if (slippage == 0) {\n        slippage = DEFAULT_SLIPPAGE;\n      }\n\n      uint tetuBalanceBefore = IERC20(_tetu).balanceOf(address(this));\n\n      _approveIfNeed(tokenIn, address(_liquidator), amount);\n      _liquidator.liquidateWithRoute(route, amount, slippage);\n\n      boughtTetu = IERC20(_tetu).balanceOf(address(this)) - tetuBalanceBefore;\n    }\n  }\n\n  // *************************************************************\n  //                      INTERNAL LOGIC\n  // *************************************************************\n\n\n  function _distributeToBribes(\n    address incomeToken,\n    address tokenToDistribute,\n    address[] memory vaults,\n    uint[] memory queuedAmounts,\n    uint queuedBalance,\n    uint toDistribute\n  ) internal {\n    address _bribe = bribe;\n    uint _epoch = IBribe(_bribe).epoch();\n    _approveIfNeed(tokenToDistribute, _bribe, toDistribute);\n\n    uint remaining = toDistribute;\n    for (uint i; i < vaults.length; i++) {\n      uint toSend = toDistribute * queuedAmounts[i] / queuedBalance;\n      // for avoid rounding issue send all remaining amount\n      if (i == vaults.length - 1) {\n        toSend = remaining;\n      } else {\n        remaining -= toSend;\n      }\n\n      _registerRewardInBribe(_bribe, vaults[i], tokenToDistribute);\n      IBribe(_bribe).notifyForNextEpoch(vaults[i], tokenToDistribute, toSend);\n      IBribe(_bribe).notifyDelayedRewards(vaults[i], tokenToDistribute, _epoch);\n\n      // clear queued data\n      _destinationQueue[incomeToken].remove(vaults[i]);\n      delete amountPerDestination[incomeToken][vaults[i]];\n      _tokensPerDestination[vaults[i]].remove(incomeToken);\n    }\n\n    if (IERC20(incomeToken).balanceOf(address(this)) == 0) {\n      _queuedTokens.remove(incomeToken);\n    }\n  }\n\n  function _registerRewardInBribe(address _bribe, address stakingToken, address rewardToken) internal {\n    if (!IMultiPool(_bribe).isRewardToken(stakingToken, rewardToken)) {\n      IMultiPool(_bribe).registerRewardToken(stakingToken, rewardToken);\n    }\n  }\n\n  function _approveIfNeed(address token, address dst, uint amount) internal {\n    if (IERC20(token).allowance(address(this), dst) < amount) {\n      IERC20(token).safeApprove(dst, 0);\n      IERC20(token).safeApprove(dst, type(uint).max);\n    }\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_FORWARDER || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/infrastructure/InvestFundV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../proxy/ControllableV3.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\n\n/// @title Upgradable contract with assets for invest in different places under control of Tetu platform.\n/// @author belbix\ncontract InvestFundV2 is ControllableV3 {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant INVEST_FUND_VERSION = \"2.0.0\";\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  EnumerableSet.AddressSet internal _tokens;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event FundDeposit(address indexed token, uint256 amount);\n  event FundWithdrawn(address indexed token, uint256 amount);\n\n  // *************************************************************\n  //                         INIT\n  // *************************************************************\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function init(address __controller) external initializer {\n    __Controllable_init(__controller);\n  }\n\n  // *************************************************************\n  //                      RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Allow operation only for Controller\n  modifier onlyGov() {\n    require(isGovernance(msg.sender), \"!gov\");\n    _;\n  }\n\n  // *************************************************************\n  //                         VIEWS\n  // *************************************************************\n\n  function tokens() external view returns (address[] memory) {\n    return _tokens.values();\n  }\n\n  // *************************************************************\n  //                     GOVERNANCE ACTIONS\n  // *************************************************************\n\n  /// @dev Move tokens to governance gnosis safe\n  function withdraw(address _token, uint256 amount) external onlyGov {\n    IERC20(_token).safeTransfer(msg.sender, amount);\n    emit FundWithdrawn(_token, amount);\n  }\n\n  /// @dev Transfer any token to this contract. The token will be added in the token list.\n  function deposit(address _token, uint256 amount) external onlyGov {\n    _tokens.add(_token);\n    if (amount != 0) {\n      IERC20(_token).safeTransferFrom(msg.sender, address(this), amount);\n    }\n    emit FundDeposit(_token, amount);\n  }\n\n  // *************************************************************\n  //                      FUND CONTROL\n  // *************************************************************\n\n  // TBD - implement invest strategy\n  // implementation highly depends on the Tetu Second Stage\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/infrastructure/PlatformVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../interfaces/IPlatformVoter.sol\";\nimport \"../interfaces/IVeTetu.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Ve holders can vote for platform attributes values.\n/// @author belbix\ncontract PlatformVoter is ControllableV3, IPlatformVoter {\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant PLATFORM_VOTER_VERSION = \"1.0.0\";\n  /// @dev Denominator for different ratios. It is default for the whole platform.\n  uint public constant RATIO_DENOMINATOR = 100_000;\n  /// @dev Delay between votes.\n  uint public constant VOTE_DELAY = 1 weeks;\n  /// @dev Maximum votes per veNFT\n  uint public constant MAX_VOTES = 20;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev The ve token that governs these contracts\n  address public ve;\n\n  // --- VOTES\n  /// @dev veId => votes\n  mapping(uint => Vote[]) public votes;\n  /// @dev Attribute => Target(zero for not-strategy) => sum of votes weights\n  mapping(AttributeType => mapping(address => uint)) public attributeWeights;\n  /// @dev Attribute => Target(zero for not-strategy) => sum of weights multiple on values\n  mapping(AttributeType => mapping(address => uint)) public attributeValues;\n\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event AttributeChanged(uint _type, uint value);\n  event Voted(\n    uint tokenId,\n    uint _type,\n    uint value,\n    address target,\n    uint veWeight,\n    uint veWeightedValue,\n    uint totalAttributeWeight,\n    uint totalAttributeValue,\n    uint newValue\n  );\n  event VoteReset(\n    uint tokenId,\n    uint _type,\n    address target,\n    uint weight,\n    uint weightedValue,\n    uint timestamp\n  );\n  event VoteRemoved(uint tokenId, uint _type, uint newValue, address target);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(address controller_, address _ve) external initializer {\n    __Controllable_init(controller_);\n    _requireInterface(_ve, InterfaceIds.I_VE_TETU);\n    ve = _ve;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Array of votes. Safe to return the whole array until we have MAX_VOTES restriction.\n  function veVotes(uint veId) external view returns (Vote[] memory) {\n    return votes[veId];\n  }\n\n  /// @dev Length of votes array for given id\n  function veVotesLength(uint veId) external view returns (uint) {\n    return votes[veId].length;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_PLATFORM_VOTER || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        VOTES\n  // *************************************************************\n\n  /// @dev Resubmit exist votes for given token.\n  ///      Need to call it for ve that did not renew votes too long.\n  function poke(uint tokenId) external {\n    Vote[] memory _votes = votes[tokenId];\n    for (uint i; i < _votes.length; ++i) {\n      Vote memory v = _votes[i];\n      _vote(tokenId, v._type, v.weightedValue / v.weight, v.target);\n    }\n  }\n\n  /// @dev Vote for multiple attributes in one call.\n  function voteBatch(\n    uint tokenId,\n    AttributeType[] memory types,\n    uint[] memory values,\n    address[] memory targets\n  ) external {\n    require(IVeTetu(ve).isApprovedOrOwner(msg.sender, tokenId), \"!owner\");\n    for (uint i; i < types.length; ++i) {\n      _vote(tokenId, types[i], values[i], targets[i]);\n    }\n  }\n\n  /// @dev Vote for given parameter using a vote power of given tokenId. Reset previous vote.\n  function vote(uint tokenId, AttributeType _type, uint value, address target) external {\n    require(IVeTetu(ve).isApprovedOrOwner(msg.sender, tokenId), \"!owner\");\n    _vote(tokenId, _type, value, target);\n  }\n\n  function _vote(uint tokenId, AttributeType _type, uint value, address target) internal {\n    require(value <= RATIO_DENOMINATOR, \"!value\");\n\n    // load maps for reduce gas usage\n    mapping(address => uint) storage _attributeWeights = attributeWeights[_type];\n    mapping(address => uint) storage _attributeValues = attributeValues[_type];\n    Vote[] storage _votes = votes[tokenId];\n\n    uint totalAttributeWeight;\n    uint totalAttributeValue;\n\n    //remove votes optimised\n    {\n      uint oldVeWeight;\n      uint oldVeValue;\n\n      uint length = _votes.length;\n      if (length != 0) {\n        uint i;\n        bool found;\n        for (; i < length; ++i) {\n          Vote memory v = _votes[i];\n          if (v._type == _type && v.target == target) {\n            require(v.timestamp + VOTE_DELAY < block.timestamp, \"delay\");\n            oldVeWeight = v.weight;\n            oldVeValue = v.weightedValue;\n            found = true;\n            break;\n          }\n        }\n        if (found) {\n          if (i != length - 1) {\n            _votes[i] = _votes[length - 1];\n          }\n          _votes.pop();\n        } else {\n          // it is a new type of vote\n          // need to check MAX votes in this case\n          require(length < MAX_VOTES, \"max\");\n        }\n      }\n\n      totalAttributeWeight = _attributeWeights[target] - oldVeWeight;\n      totalAttributeValue = _attributeValues[target] - oldVeValue;\n    }\n\n\n    // get new values for ve\n    uint veWeight = IVeTetu(ve).balanceOfNFT(tokenId);\n    uint veWeightedValue = veWeight * value;\n\n    if (veWeight != 0) {\n\n      // add ve values to total values\n      totalAttributeWeight += veWeight;\n      totalAttributeValue += veWeightedValue;\n\n      // store new total values\n      _attributeWeights[target] = totalAttributeWeight;\n      _attributeValues[target] = totalAttributeValue;\n\n      // set new attribute value\n      _setAttribute(_type, totalAttributeValue / totalAttributeWeight, target);\n\n      // write attachments\n      IVeTetu(ve).voting(tokenId);\n      _votes.push(Vote(_type, target, veWeight, veWeightedValue, block.timestamp));\n\n      emit Voted(\n        tokenId,\n        uint(_type),\n        value,\n        target,\n        veWeight,\n        veWeightedValue,\n        totalAttributeWeight,\n        totalAttributeValue,\n        totalAttributeValue / totalAttributeWeight\n      );\n    }\n  }\n\n  /// @dev Change attribute value for given type.\n  function _setAttribute(AttributeType _type, uint newValue, address target) internal {\n    if (_type == AttributeType.INVEST_FUND_RATIO) {\n      require(target == address(0), \"!target\");\n      IForwarder(IController(controller()).forwarder()).setInvestFundRatio(newValue);\n    } else if (_type == AttributeType.GAUGE_RATIO) {\n      require(target == address(0), \"!target\");\n      IForwarder(IController(controller()).forwarder()).setGaugesRatio(newValue);\n    } else if (_type == AttributeType.STRATEGY_COMPOUND) {\n      IStrategyV2(target).setCompoundRatio(newValue);\n    } else {\n      revert(\"!type\");\n    }\n    emit AttributeChanged(uint(_type), newValue);\n  }\n\n  /// @dev Remove all votes for given tokenId.\n  function reset(uint tokenId, uint[] memory types, address[] memory targets) external {\n    require(IVeTetu(ve).isApprovedOrOwner(msg.sender, tokenId) || msg.sender == ve, \"!owner\");\n\n    Vote[] storage _votes = votes[tokenId];\n    uint length = _votes.length;\n    for (uint i = length; i > 0; --i) {\n\n      Vote memory v = _votes[i - 1];\n      bool found;\n      for (uint j; j < types.length; ++j) {\n        uint _type = types[j];\n        address target = targets[j];\n        if (uint(v._type) == _type && v.target == target) {\n          found = true;\n          break;\n        }\n      }\n\n      if (found) {\n        require(v.timestamp + VOTE_DELAY < block.timestamp, \"delay\");\n        _removeVote(tokenId, v._type, v.target, v.weight, v.weightedValue);\n        // with descent loop we remove one by one last elements\n        _votes.pop();\n\n        IVeTetu(ve).abstain(tokenId);\n        emit VoteReset(\n          tokenId,\n          uint(v._type),\n          v.target,\n          v.weight,\n          v.weightedValue,\n          v.timestamp\n        );\n      }\n    }\n  }\n\n  function _removeVote(uint tokenId, AttributeType _type, address target, uint weight, uint veValue) internal {\n    uint totalWeights = attributeWeights[_type][target] - weight;\n    uint totalValues = attributeValues[_type][target] - veValue;\n    attributeWeights[_type][target] = totalWeights;\n    if (veValue != 0) {\n      attributeValues[_type][target] = totalValues;\n    }\n    uint newValue;\n    if (totalWeights != 0) {\n      newValue = totalValues / totalWeights;\n    }\n    _setAttribute(_type, newValue, target);\n    emit VoteRemoved(tokenId, uint(_type), newValue, target);\n  }\n\n  function detachTokenFromAll(uint tokenId, address) external override {\n    require(msg.sender == ve, \"!ve\");\n\n    Vote[] storage _votes = votes[tokenId];\n    uint length = _votes.length;\n    for (uint i = length; i > 0; --i) {\n      Vote memory v = _votes[i - 1];\n      _removeVote(tokenId, v._type, v.target, v.weight, v.weightedValue);\n      _votes.pop();\n    }\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IBribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IBribe {\n\n  function epoch() external view returns (uint);\n\n  function getReward(\n    address vault,\n    uint veId,\n    address[] memory tokens\n  ) external;\n\n  function getAllRewards(\n    address vault,\n    uint veId\n  ) external;\n\n  function getAllRewardsForTokens(\n    address[] memory vaults,\n    uint veId\n  ) external;\n\n  function deposit(address vault, uint amount, uint tokenId) external;\n\n  function withdraw(address vault, uint amount, uint tokenId) external;\n\n  function notifyRewardAmount(address vault, address token, uint amount) external;\n\n  function notifyForNextEpoch(address vault, address token, uint amount) external;\n\n  function notifyDelayedRewards(address vault, address token, uint _epoch) external;\n\n  function increaseEpoch() external;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IControllable {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IController {\n\n  // --- DEPENDENCY ADDRESSES\n  function governance() external view returns (address);\n\n  function voter() external view returns (address);\n\n  function liquidator() external view returns (address);\n\n  function forwarder() external view returns (address);\n\n  function investFund() external view returns (address);\n\n  function veDistributor() external view returns (address);\n\n  function platformVoter() external view returns (address);\n\n  // --- VAULTS\n\n  function vaults(uint id) external view returns (address);\n\n  function vaultsList() external view returns (address[] memory);\n\n  function vaultsListLength() external view returns (uint);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  // --- restrictions\n\n  function isOperator(address _adr) external view returns (bool);\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n     */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n     */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n  event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n  event Withdraw(\n    address indexed sender,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  /**\n   * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n  function asset() external view returns (address assetTokenAddress);\n\n  /**\n   * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n  function totalAssets() external view returns (uint256 totalManagedAssets);\n\n  /**\n   * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n  function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n  /**\n   * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n  function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n  /**\n   * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n  function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n  function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n  /**\n   * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n  function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n  /**\n   * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n  function maxMint(address receiver) external view returns (uint256 maxShares);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n  function previewMint(uint256 shares) external view returns (uint256 assets);\n\n  /**\n   * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n  function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n  /**\n   * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n  function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n  function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n  /**\n   * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) external returns (uint256 shares);\n\n  /**\n   * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n  function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n  function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n  /**\n   * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) external returns (uint256 assets);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n  /**\n   * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n  /**\n   * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n   */\n  event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n  /**\n   * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n   */\n  event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n  /**\n   * @dev Returns the number of tokens in ``owner``'s account.\n   */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n   * @dev Returns the owner of the `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function ownerOf(uint256 tokenId) external view returns (address owner);\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n   * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @dev Transfers `tokenId` token from `from` to `to`.\n   *\n   * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 tokenId\n  ) external;\n\n  /**\n   * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n   * The approval is cleared when the token is transferred.\n   *\n   * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n   *\n   * Requirements:\n   *\n   * - The caller must own the token or be an approved operator.\n   * - `tokenId` must exist.\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address to, uint256 tokenId) external;\n\n  /**\n   * @dev Returns the account approved for `tokenId` token.\n   *\n   * Requirements:\n   *\n   * - `tokenId` must exist.\n   */\n  function getApproved(uint256 tokenId) external view returns (address operator);\n\n  /**\n   * @dev Approve or remove `operator` as an operator for the caller.\n   * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n   *\n   * Requirements:\n   *\n   * - The `operator` cannot be the caller.\n   *\n   * Emits an {ApprovalForAll} event.\n   */\n  function setApprovalForAll(address operator, bool _approved) external;\n\n  /**\n   * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n   *\n   * See {setApprovalForAll}\n   */\n  function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n  /**\n   * @dev Safely transfers `tokenId` token from `from` to `to`.\n   *\n   * Requirements:\n   *\n   * - `from` cannot be the zero address.\n   * - `to` cannot be the zero address.\n   * - `tokenId` token must exist and be owned by `from`.\n   * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n   * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n   *\n   * Emits a {Transfer} event.\n   */\n  function safeTransferFrom(\n    address from,\n    address to,\n    uint256 tokenId,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IERC721.sol\";\n\n/**\n* @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n* @dev See https://eips.ethereum.org/EIPS/eip-721\n*/\ninterface IERC721Metadata is IERC721 {\n  /**\n  * @dev Returns the token collection name.\n  */\n  function name() external view returns (string memory);\n\n  /**\n  * @dev Returns the token collection symbol.\n  */\n  function symbol() external view returns (string memory);\n\n  /**\n  * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n  */\n  function tokenURI(uint tokenId) external view returns (string memory);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n  /**\n   * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n   * by `operator` from `from`, this function is called.\n   *\n   * It must return its Solidity selector to confirm the token transfer.\n   * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n   *\n   * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n   */\n  function onERC721Received(\n    address operator,\n    address from,\n    uint256 tokenId,\n    bytes calldata data\n  ) external returns (bytes4);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IForwarder {\n\n  function tokenPerDestinationLength(address destination) external view returns (uint);\n\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\n\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vault,\n    bool isDistribute\n  ) external;\n\n  function distributeAll(address destination) external;\n\n  function distribute(address token) external;\n\n  function setInvestFundRatio(uint value) external;\n\n  function setGaugesRatio(uint value) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IGauge {\n\n  function veIds(address stakingToken, address account) external view returns (uint);\n\n  function getReward(\n    address stakingToken,\n    address account,\n    address[] memory tokens\n  ) external;\n\n  function getAllRewards(\n    address stakingToken,\n    address account\n  ) external;\n\n  function getAllRewardsForTokens(\n    address[] memory stakingTokens,\n    address account\n  ) external;\n\n  function attachVe(address stakingToken, address account, uint veId) external;\n\n  function detachVe(address stakingToken, address account, uint veId) external;\n\n  function handleBalanceChange(address account) external;\n\n  function notifyRewardAmount(address stakingToken, address token, uint amount) external;\n\n  function addStakingToken(address token) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IMultiPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IMultiPool {\n\n  function totalSupply(address stakingToken) external view returns (uint);\n\n  function derivedSupply(address stakingToken) external view returns (uint);\n\n  function derivedBalances(address stakingToken, address account) external view returns (uint);\n\n  function balanceOf(address stakingToken, address account) external view returns (uint);\n\n  function rewardTokens(address stakingToken, uint id) external view returns (address);\n\n  function isRewardToken(address stakingToken, address token) external view returns (bool);\n\n  function rewardTokensLength(address stakingToken) external view returns (uint);\n\n  function derivedBalance(address stakingToken, address account) external view returns (uint);\n\n  function left(address stakingToken, address token) external view returns (uint);\n\n  function earned(address stakingToken, address token, address account) external view returns (uint);\n\n  function registerRewardToken(address stakingToken, address token) external;\n\n  function removeRewardToken(address stakingToken, address token) external;\n\n  function isStakeToken(address token) external view returns (bool);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IPlatformVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IPlatformVoter {\n\n  enum AttributeType {\n    UNKNOWN,\n    INVEST_FUND_RATIO,\n    GAUGE_RATIO,\n    STRATEGY_COMPOUND\n  }\n\n  struct Vote {\n    AttributeType _type;\n    address target;\n    uint weight;\n    uint weightedValue;\n    uint timestamp;\n  }\n\n  function detachTokenFromAll(uint tokenId, address owner) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IProxyControlled {\n\n  function initProxy(address _logic) external;\n\n  function upgrade(address _newImplementation) external;\n\n  function implementation() external view returns (address);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ISmartVault.sol": {
      "content": "// SPDX-License-Identifier: ISC\n/**\n* By using this software, you understand, acknowledge and accept that Tetu\n* and/or the underlying software are provided “as is” and “as available”\n* basis and without warranties or representations of any kind either expressed\n* or implied. Any use of this open source software released under the ISC\n* Internet Systems Consortium license is done at your own risk to the fullest\n* extent permissible pursuant to applicable law any and all liability as well\n* as all warranties, including any fitness for a particular purpose with respect\n* to Tetu and/or the underlying software and the use thereof are disclaimed.\n*/\n\npragma solidity 0.8.17;\n\ninterface ISmartVault {\n\n  function DEPOSIT_FEE_DENOMINATOR() external view returns (uint256);\n\n  function LOCK_PENALTY_DENOMINATOR() external view returns (uint256);\n\n  function TO_INVEST_DENOMINATOR() external view returns (uint256);\n\n  function VERSION() external view returns (string memory);\n\n  function active() external view returns (bool);\n\n  function addRewardToken(address rt) external;\n\n  function alwaysInvest() external view returns (bool);\n\n  function availableToInvestOut() external view returns (uint256);\n\n  function changeActivityStatus(bool _active) external;\n\n  function changeAlwaysInvest(bool _active) external;\n\n  function changeDoHardWorkOnInvest(bool _active) external;\n\n  function changePpfsDecreaseAllowed(bool _value) external;\n\n  function changeProtectionMode(bool _active) external;\n\n  function deposit(uint256 amount) external;\n\n  function depositAndInvest(uint256 amount) external;\n\n  function depositFeeNumerator() external view returns (uint256);\n\n  function depositFor(uint256 amount, address holder) external;\n\n  function doHardWork() external;\n\n  function doHardWorkOnInvest() external view returns (bool);\n\n  function duration() external view returns (uint256);\n\n  function earned(address rt, address account)\n  external\n  view\n  returns (uint256);\n\n  function earnedWithBoost(address rt, address account)\n  external\n  view\n  returns (uint256);\n\n  function exit() external;\n\n  function getAllRewards() external;\n\n  function getAllRewardsAndRedirect(address owner) external;\n\n  function getPricePerFullShare() external view returns (uint256);\n\n  function getReward(address rt) external;\n\n  function getRewardTokenIndex(address rt) external view returns (uint256);\n\n  function initializeSmartVault(\n    string memory _name,\n    string memory _symbol,\n    address _controller,\n    address __underlying,\n    uint256 _duration,\n    bool _lockAllowed,\n    address _rewardToken,\n    uint256 _depositFee\n  ) external;\n\n  function lastTimeRewardApplicable(address rt)\n  external\n  view\n  returns (uint256);\n\n  function lastUpdateTimeForToken(address) external view returns (uint256);\n\n  function lockAllowed() external view returns (bool);\n\n  function lockPenalty() external view returns (uint256);\n\n  function notifyRewardWithoutPeriodChange(\n    address _rewardToken,\n    uint256 _amount\n  ) external;\n\n  function notifyTargetRewardAmount(address _rewardToken, uint256 amount)\n  external;\n\n  function overrideName(string memory value) external;\n\n  function overrideSymbol(string memory value) external;\n\n  function periodFinishForToken(address) external view returns (uint256);\n\n  function ppfsDecreaseAllowed() external view returns (bool);\n\n  function protectionMode() external view returns (bool);\n\n  function rebalance() external;\n\n  function removeRewardToken(address rt) external;\n\n  function rewardPerToken(address rt) external view returns (uint256);\n\n  function rewardPerTokenStoredForToken(address)\n  external\n  view\n  returns (uint256);\n\n  function rewardRateForToken(address) external view returns (uint256);\n\n  function rewardTokens() external view returns (address[] memory);\n\n  function rewardTokensLength() external view returns (uint256);\n\n  function rewardsForToken(address, address) external view returns (uint256);\n\n  function setLockPenalty(uint256 _value) external;\n\n  function setRewardsRedirect(address owner, address receiver) external;\n\n  function setLockPeriod(uint256 _value) external;\n\n  function setStrategy(address newStrategy) external;\n\n  function setToInvest(uint256 _value) external;\n\n  function stop() external;\n\n  function strategy() external view returns (address);\n\n  function toInvest() external view returns (uint256);\n\n  function underlying() external view returns (address);\n\n  function underlyingBalanceInVault() external view returns (uint256);\n\n  function underlyingBalanceWithInvestment() external view returns (uint256);\n\n  function underlyingBalanceWithInvestmentForHolder(address holder)\n  external\n  view\n  returns (uint256);\n\n  function underlyingUnit() external view returns (uint256);\n\n  function userBoostTs(address) external view returns (uint256);\n\n  function userLastDepositTs(address) external view returns (uint256);\n\n  function userLastWithdrawTs(address) external view returns (uint256);\n\n  function userLockTs(address) external view returns (uint256);\n\n  function userRewardPerTokenPaidForToken(address, address)\n  external\n  view\n  returns (uint256);\n\n  function withdraw(uint256 numberOfShares) external;\n\n  function withdrawAllToVault() external;\n\n  function getAllRewardsFor(address rewardsReceiver) external;\n\n  function lockPeriod() external view returns (uint256);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISplitter {\n\n  function init(address controller_, address _asset, address _vault) external;\n\n  // *************** ACTIONS **************\n\n  function withdrawAllToVault() external;\n\n  function withdrawToVault(uint256 amount) external;\n\n  function doHardWork() external;\n\n  function investAll() external;\n\n  // **************** VIEWS ***************\n\n  function asset() external view returns (address);\n\n  function vault() external view returns (address);\n\n  function totalAssets() external view returns (uint256);\n\n  function isHardWorking() external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyStrict.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IStrategyStrict {\n\n  function NAME() external view returns (string memory);\n\n  function PLATFORM() external view returns (string memory);\n\n  function STRATEGY_VERSION() external view returns (string memory);\n\n  function asset() external view returns (address);\n\n  function vault() external view returns (address);\n\n  function compoundRatio() external view returns (uint);\n\n  function totalAssets() external view returns (uint);\n\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\n  function isReadyToHardWork() external view returns (bool);\n\n  function withdrawAllToVault() external;\n\n  function withdrawToVault(uint amount) external;\n\n  function investAll() external;\n\n  function doHardWork() external returns (uint earned, uint lost);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IStrategyV2 {\n\n  function NAME() external view returns (string memory);\n\n  function PLATFORM() external view returns (string memory);\n\n  function STRATEGY_VERSION() external view returns (string memory);\n\n  function asset() external view returns (address);\n\n  function splitter() external view returns (address);\n\n  function compoundRatio() external view returns (uint);\n\n  function totalAssets() external view returns (uint);\n\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\n  function isReadyToHardWork() external view returns (bool);\n\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-withdrawAllToSplitter]\n  function withdrawAllToSplitter() external returns (int totalAssetsDelta);\n\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-withdrawToSplitter]\n  function withdrawToSplitter(uint amount) external returns (int totalAssetsDelta);\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external returns (\n    int totalAssetsDelta\n  );\n\n  function doHardWork() external returns (uint earned, uint lost);\n\n  function setCompoundRatio(uint value) external;\n\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\n  ///         0 means no deposit is allowed at this moment\n  function capacity() external view returns (uint);\n\n  /// @notice {performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\n  function performanceReceiver() external view returns (address);\n\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\n  /// @dev use FEE_DENOMINATOR\n  function performanceFee() external view returns (uint);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ITetuLiquidator {\n\n  struct PoolData {\n    address pool;\n    address swapper;\n    address tokenIn;\n    address tokenOut;\n  }\n\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\n\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\n\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\n\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint slippage\n  ) external;\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint slippage\n  ) external;\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IVaultInsurance.sol\";\nimport \"./IERC20.sol\";\n\ninterface ITetuVaultV2 {\n\n  function depositFee() external view returns (uint);\n\n  function withdrawFee() external view returns (uint);\n\n  function init(\n    address controller_,\n    IERC20 _asset,\n    string memory _name,\n    string memory _symbol,\n    address _gauge,\n    uint _buffer\n  ) external;\n\n  function setSplitter(address _splitter) external;\n\n  function coverLoss(uint amount) external;\n\n  function initInsurance(IVaultInsurance _insurance) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVaultInsurance {\n\n  function init(address _vault, address _asset) external;\n\n  function vault() external view returns (address);\n\n  function asset() external view returns (address);\n\n  function transferToVault(uint amount) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVeDistributor {\n\n  function rewardToken() external view returns (address);\n\n  function checkpoint() external;\n\n  function checkpointTotalSupply() external;\n\n  function claim(uint _tokenId) external returns (uint);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeTetu.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVeTetu {\n\n  enum DepositType {\n    DEPOSIT_FOR_TYPE,\n    CREATE_LOCK_TYPE,\n    INCREASE_LOCK_AMOUNT,\n    INCREASE_UNLOCK_TIME,\n    MERGE_TYPE\n  }\n\n  struct Point {\n    int128 bias;\n    int128 slope; // # -dweight / dt\n    uint ts;\n    uint blk; // block\n  }\n  /* We cannot really do block numbers per se b/c slope is per time, not per block\n  * and per block could be fairly bad b/c Ethereum changes blocktimes.\n  * What we can do is to extrapolate ***At functions */\n\n  function attachments(uint tokenId) external view returns (uint);\n\n  function lockedAmounts(uint veId, address stakingToken) external view returns (uint);\n\n  function lockedDerivedAmount(uint veId) external view returns (uint);\n\n  function lockedEnd(uint veId) external view returns (uint);\n\n  function voted(uint tokenId) external view returns (uint);\n\n  function tokens(uint idx) external view returns (address);\n\n  function balanceOfNFT(uint) external view returns (uint);\n\n  function isApprovedOrOwner(address, uint) external view returns (bool);\n\n  function createLockFor(address _token, uint _value, uint _lockDuration, address _to) external returns (uint);\n\n  function userPointEpoch(uint tokenId) external view returns (uint);\n\n  function epoch() external view returns (uint);\n\n  function userPointHistory(uint tokenId, uint loc) external view returns (Point memory);\n\n  function pointHistory(uint loc) external view returns (Point memory);\n\n  function checkpoint() external;\n\n  function increaseAmount(address _token, uint _tokenId, uint _value) external;\n\n  function attachToken(uint tokenId) external;\n\n  function detachToken(uint tokenId) external;\n\n  function voting(uint tokenId) external;\n\n  function abstain(uint tokenId) external;\n\n  function totalSupplyAt(uint _block) external view returns (uint);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVoter {\n\n  function ve() external view returns (address);\n\n  function attachTokenToGauge(address stakingToken, uint _tokenId, address account) external;\n\n  function detachTokenFromGauge(address stakingToken, uint _tokenId, address account) external;\n\n  function distribute(address stakingToken) external;\n\n  function notifyRewardAmount(uint amount) external;\n\n  function detachTokenFromAll(uint tokenId, address account) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Base64\n/// @notice Provides a function for encoding some bytes in base64\n/// @author Brecht Devos <brecht@loopring.org>\nlibrary Base64 {\n  bytes internal constant TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  /// @notice Encodes some bytes to the base64 representation\n  function encode(bytes memory data) internal pure returns (string memory) {\n    uint len = data.length;\n    if (len == 0) return \"\";\n\n    // multiply by 4/3 rounded up\n    uint encodedLen = 4 * ((len + 2) / 3);\n\n    // Add some extra buffer at the end\n    bytes memory result = new bytes(encodedLen + 32);\n\n    bytes memory table = TABLE;\n\n    assembly {\n      let tablePtr := add(table, 1)\n      let resultPtr := add(result, 32)\n\n      for {\n        let i := 0\n      } lt(i, len) {\n\n      } {\n        i := add(i, 3)\n        let input := and(mload(add(data, i)), 0xffffff)\n\n        let out := mload(add(tablePtr, and(shr(18, input), 0x3F)))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(12, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(shr(6, input), 0x3F))), 0xFF))\n        out := shl(8, out)\n        out := add(out, and(mload(add(tablePtr, and(input, 0x3F))), 0xFF))\n        out := shl(224, out)\n\n        mstore(resultPtr, out)\n\n        resultPtr := add(resultPtr, 4)\n      }\n\n      switch mod(len, 3)\n      case 1 {\n        mstore(sub(resultPtr, 2), shl(240, 0x3d3d))\n      }\n      case 2 {\n        mstore(sub(resultPtr, 1), shl(248, 0x3d))\n      }\n\n      mstore(result, encodedLen)\n    }\n\n    return string(result);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n  /*//////////////////////////////////////////////////////////////\n  //SIMPLIFIED FIXED POINT OPERATIONS\n  //////////////////////////////////////////////////////////////*/\n\n  uint internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n  function mulWadDown(uint x, uint y) internal pure returns (uint) {\n    return mulDivDown(x, y, WAD);\n    // Equivalent to (x * y) / WAD rounded down.\n  }\n\n  function mulWadUp(uint x, uint y) internal pure returns (uint) {\n    return mulDivUp(x, y, WAD);\n    // Equivalent to (x * y) / WAD rounded up.\n  }\n\n  function divWadDown(uint x, uint y) internal pure returns (uint) {\n    return mulDivDown(x, WAD, y);\n    // Equivalent to (x * WAD) / y rounded down.\n  }\n\n  function divWadUp(uint x, uint y) internal pure returns (uint) {\n    return mulDivUp(x, WAD, y);\n    // Equivalent to (x * WAD) / y rounded up.\n  }\n\n  function positiveInt128(int128 value) internal pure returns (int128) {\n    return value < 0 ? int128(0) : value;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //LOW LEVEL FIXED POINT OPERATIONS\n  //////////////////////////////////////////////////////////////*/\n\n  function mulDivDown(\n    uint x,\n    uint y,\n    uint denominator\n  ) internal pure returns (uint z) {\n    assembly {\n    // Store x * y in z for now.\n      z := mul(x, y)\n\n    // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n        revert(0, 0)\n      }\n\n    // Divide z by the denominator.\n      z := div(z, denominator)\n    }\n  }\n\n  function mulDivUp(\n    uint x,\n    uint y,\n    uint denominator\n  ) internal pure returns (uint z) {\n    assembly {\n    // Store x * y in z for now.\n      z := mul(x, y)\n\n    // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n        revert(0, 0)\n      }\n\n    // First, divide z - 1 by the denominator and add 1.\n    // We allow z - 1 to underflow if z is 0, because we multiply the\n    // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n      z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n    }\n  }\n\n  function rpow(\n    uint x,\n    uint n,\n    uint scalar\n  ) internal pure returns (uint z) {\n    assembly {\n      switch x\n      case 0 {\n        switch n\n        case 0 {\n        // 0 ** 0 = 1\n          z := scalar\n        }\n        default {\n        // 0 ** n = 0\n          z := 0\n        }\n      }\n      default {\n        switch mod(n, 2)\n        case 0 {\n        // If n is even, store scalar in z for now.\n          z := scalar\n        }\n        default {\n        // If n is odd, store x in z for now.\n          z := x\n        }\n\n      // Shifting right by 1 is like dividing by 2.\n        let half := shr(1, scalar)\n\n        for {\n        // Shift n right by 1 before looping to halve it.\n          n := shr(1, n)\n        } n {\n        // Shift n right by 1 each iteration to halve it.\n          n := shr(1, n)\n        } {\n        // Revert immediately if x ** 2 would overflow.\n        // Equivalent to iszero(eq(div(xx, x), x)) here.\n          if shr(128, x) {\n            revert(0, 0)\n          }\n\n        // Store x squared.\n          let xx := mul(x, x)\n\n        // Round to the nearest number.\n          let xxRound := add(xx, half)\n\n        // Revert if xx + half overflowed.\n          if lt(xxRound, xx) {\n            revert(0, 0)\n          }\n\n        // Set x to scaled xxRound.\n          x := div(xxRound, scalar)\n\n        // If n is even:\n          if mod(n, 2) {\n          // Compute z * x.\n            let zx := mul(z, x)\n\n          // If z * x overflowed:\n            if iszero(eq(div(zx, x), z)) {\n            // Revert if x is non-zero.\n              if iszero(iszero(x)) {\n                revert(0, 0)\n              }\n            }\n\n          // Round to the nearest number.\n            let zxRound := add(zx, half)\n\n          // Revert if zx + half overflowed.\n            if lt(zxRound, zx) {\n              revert(0, 0)\n            }\n\n          // Return properly scaled zxRound.\n            z := div(zxRound, scalar)\n          }\n        }\n      }\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  // GENERAL NUMBER UTILITIES\n  //////////////////////////////////////////////////////////////*/\n\n  function sqrt(uint x) internal pure returns (uint z) {\n    assembly {\n    // Start off with z at 1.\n      z := 1\n\n    // Used below to help find a nearby power of 2.\n      let y := x\n\n    // Find the lowest power of 2 that is at least sqrt(x).\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\n        y := shr(128, y) // Like dividing by 2 ** 128.\n        z := shl(64, z) // Like multiplying by 2 ** 64.\n      }\n      if iszero(lt(y, 0x10000000000000000)) {\n        y := shr(64, y) // Like dividing by 2 ** 64.\n        z := shl(32, z) // Like multiplying by 2 ** 32.\n      }\n      if iszero(lt(y, 0x100000000)) {\n        y := shr(32, y) // Like dividing by 2 ** 32.\n        z := shl(16, z) // Like multiplying by 2 ** 16.\n      }\n      if iszero(lt(y, 0x10000)) {\n        y := shr(16, y) // Like dividing by 2 ** 16.\n        z := shl(8, z) // Like multiplying by 2 ** 8.\n      }\n      if iszero(lt(y, 0x100)) {\n        y := shr(8, y) // Like dividing by 2 ** 8.\n        z := shl(4, z) // Like multiplying by 2 ** 4.\n      }\n      if iszero(lt(y, 0x10)) {\n        y := shr(4, y) // Like dividing by 2 ** 4.\n        z := shl(2, z) // Like multiplying by 2 ** 2.\n      }\n      if iszero(lt(y, 0x8)) {\n      // Equivalent to 2 ** z.\n        z := shl(1, z)\n      }\n\n    // Shifting right by 1 is like dividing by 2.\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n\n    // Compute a rounded down version of z.\n      let zRoundDown := div(x, z)\n\n    // If zRoundDown is smaller, use it.\n      if lt(zRoundDown, z) {\n        z := zRoundDown\n      }\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/InterfaceIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for interface IDs\n/// @author bogdoslav\nlibrary InterfaceIds {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant INTERFACE_IDS_LIB_VERSION = \"1.0.0\";\n\n  /// default notation:\n  /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\n\n  /// As type({Interface}).interfaceId can be changed,\n  /// when some functions changed at the interface,\n  /// so used hardcoded interface identifiers\n\n  bytes4 public constant I_VOTER = bytes4(keccak256(\"IVoter\"));\n  bytes4 public constant I_BRIBE = bytes4(keccak256(\"IBribe\"));\n  bytes4 public constant I_GAUGE = bytes4(keccak256(\"IGauge\"));\n  bytes4 public constant I_VE_TETU = bytes4(keccak256(\"IVeTetu\"));\n  bytes4 public constant I_SPLITTER = bytes4(keccak256(\"ISplitter\"));\n  bytes4 public constant I_FORWARDER = bytes4(keccak256(\"IForwarder\"));\n  bytes4 public constant I_MULTI_POOL = bytes4(keccak256(\"IMultiPool\"));\n  bytes4 public constant I_CONTROLLER = bytes4(keccak256(\"IController\"));\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\"ITetuERC165\"));\n  bytes4 public constant I_STRATEGY_V2 = bytes4(keccak256(\"IStrategyV2\"));\n  bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\"IControllable\"));\n  bytes4 public constant I_TETU_VAULT_V2 = bytes4(keccak256(\"ITetuVaultV2\"));\n  bytes4 public constant I_PLATFORM_VOTER = bytes4(keccak256(\"IPlatformVoter\"));\n  bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\"IVeDistributor\"));\n  bytes4 public constant I_TETU_CONVERTER = bytes4(keccak256(\"ITetuConverter\"));\n  bytes4 public constant I_VAULT_INSURANCE = bytes4(keccak256(\"IVaultInsurance\"));\n  bytes4 public constant I_STRATEGY_STRICT = bytes4(keccak256(\"IStrategyStrict\"));\n  bytes4 public constant I_ERC4626 = bytes4(keccak256(\"IERC4626\"));\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  /// @dev Gets a slot array by index as uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  // ************* ARRAY SETTERS *******************\n\n  /// @dev Sets a slot array at index with address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, address value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets a slot array at index with uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, uint value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets an array length\n  function setLength(bytes32 slot, uint length) internal {\n    assembly {\n      sstore(slot, length)\n    }\n  }\n\n  /// @dev Pushes an address to the array\n  function push(bytes32 slot, address value) internal {\n    uint length = arrayLength(slot);\n    setAt(slot, length, value);\n    setLength(slot, length + 1);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity 0.8.17;\nimport \"./Initializable.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/utils/ContextUpgradeable.sol\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n  function __Context_init() internal onlyInitializing {\n  }\n\n  function __Context_init_unchained() internal onlyInitializing {\n  }\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[50] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n  unchecked {\n    counter._value += 1;\n  }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n  unchecked {\n    counter._value = value - 1;\n  }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS,\n    InvalidSignatureV // Deprecated in v4.8\n  }\n\n  function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert(\"ECDSA: invalid signature\");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert(\"ECDSA: invalid signature length\");\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert(\"ECDSA: invalid signature 's' value\");\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength);\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n  function tryRecover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address, RecoverError) {\n    bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n  function recover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n  function tryRecover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address, RecoverError) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      return (address(0), RecoverError.InvalidSignatureS);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature);\n    }\n\n    return (signer, RecoverError.NoError);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n  function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n  function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity 0.8.17;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n  /* solhint-disable var-name-mixedcase */\n  bytes32 private _HASHED_NAME;\n  bytes32 private _HASHED_VERSION;\n  bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n  /* solhint-enable var-name-mixedcase */\n\n  /**\n   * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n  function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n    __EIP712_init_unchained(name, version);\n  }\n\n  function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n  }\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n     */\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n  }\n\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 nameHash,\n    bytes32 versionHash\n  ) private view returns (bytes32) {\n    return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n  function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n    return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n\n  /**\n   * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n  function _EIP712NameHash() internal virtual view returns (bytes32) {\n    return _HASHED_NAME;\n  }\n\n  /**\n   * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n  function _EIP712VersionHash() internal virtual view returns (bytes32) {\n    return _HASHED_VERSION;\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint256[50] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity 0.8.17;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Map type with\n  // bytes32 keys and values.\n  // The Map implementation uses private functions, and user-facing\n  // implementations (such as Uint256ToAddressMap) are just wrappers around\n  // the underlying Map.\n  // This means that we can only create new EnumerableMaps for types that fit\n  // in bytes32.\n\n  struct Bytes32ToBytes32Map {\n    // Storage of keys\n    EnumerableSet.Bytes32Set _keys;\n    mapping(bytes32 => bytes32) _values;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    bytes32 value\n  ) internal returns (bool) {\n    map._values[key] = value;\n    return map._keys.add(key);\n  }\n\n  /**\n   * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n    delete map._values[key];\n    return map._keys.remove(key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n    return map._keys.contains(key);\n  }\n\n  /**\n   * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n    return map._keys.length();\n  }\n\n  /**\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n    bytes32 key = map._keys.at(index);\n    return (key, map._values[key]);\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n    bytes32 value = map._values[key];\n    if (value == bytes32(0)) {\n      return (contains(map, key), bytes32(0));\n    } else {\n      return (true, value);\n    }\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n    return value;\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    string memory errorMessage\n  ) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), errorMessage);\n    return value;\n  }\n\n  // UintToUintMap\n\n  struct UintToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    UintToUintMap storage map,\n    uint256 key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(UintToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(key)));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    UintToUintMap storage map,\n    uint256 key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(key), errorMessage));\n  }\n\n  // UintToAddressMap\n\n  struct UintToAddressMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    UintToAddressMap storage map,\n    uint256 key,\n    address value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    UintToAddressMap storage map,\n    uint256 key,\n    string memory errorMessage\n  ) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n  }\n\n  // AddressToUintMap\n\n  struct AddressToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    AddressToUintMap storage map,\n    address key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n    return remove(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n    return contains(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (address(uint160(uint256(key))), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    AddressToUintMap storage map,\n    address key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n  }\n\n  // Bytes32ToUintMap\n\n  struct Bytes32ToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    Bytes32ToUintMap storage map,\n    bytes32 key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, key, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n    return remove(map._inner, key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n    return contains(map._inner, key);\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (key, uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, key);\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n    return uint256(get(map._inner, key));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    Bytes32ToUintMap storage map,\n    bytes32 key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, key, errorMessage));\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity 0.8.17;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n     */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    bytes32[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n     */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./ERC20.sol\";\nimport \"./ECDSA.sol\";\nimport \"./EIP712.sol\";\nimport \"./Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity 0.8.17;\n\nimport \"./ERC20Upgradeable.sol\";\nimport \"./ECDSAUpgradeable.sol\";\nimport \"./EIP712Upgradeable.sol\";\nimport \"./CountersUpgradeable.sol\";\nimport \"./Initializable.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable {\n  using CountersUpgradeable for CountersUpgradeable.Counter;\n\n  mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 private constant _PERMIT_TYPEHASH =\n  keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  /**\n   * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n  /**\n   * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n  function __ERC20Permit_init(string memory name) internal onlyInitializing {\n    __EIP712_init_unchained(name, \"1\");\n  }\n\n  function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n  /**\n   * @dev See {IERC20Permit-permit}.\n     */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual override {\n    require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n    bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n    bytes32 hash = _hashTypedDataV4(structHash);\n\n    address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n    require(signer == owner, \"ERC20Permit: invalid signature\");\n\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev See {IERC20Permit-nonces}.\n     */\n  function nonces(address owner) public view virtual override returns (uint256) {\n    return _nonces[owner].current();\n  }\n\n  /**\n   * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n  function _useNonce(address owner) internal virtual returns (uint256 current) {\n    CountersUpgradeable.Counter storage nonce = _nonces[owner];\n    current = nonce.current();\n    nonce.increment();\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint256[49] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"./ContextUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata {\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) internal _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n  function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n    __ERC20_init_unchained(name_, symbol_);\n  }\n\n  function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n     */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n     */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n  function transfer(address to, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n     */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    uint256 currentAllowance = allowance(owner, spender);\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n  unchecked {\n    _approve(owner, spender, currentAllowance - subtractedValue);\n  }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n  unchecked {\n    _balances[from] = fromBalance - amount;\n    // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n    // decrementing then incrementing.\n    _balances[to] += amount;\n  }\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n  unchecked {\n    // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n    _balances[account] += amount;\n  }\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n  unchecked {\n    _balances[account] = accountBalance - amount;\n    // Overflow not possible: amount <= accountBalance <= totalSupply.\n    _totalSupply -= amount;\n  }\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - amount);\n    }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint256[45] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n  uint8 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n     */\n  bool private _initializing;\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n  event Initialized(uint8 version);\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n      \"Initializable: contract is already initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n      emit Initialized(1);\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier reinitializer(uint8 version) {\n    require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n    emit Initialized(version);\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n  modifier onlyInitializing() {\n    require(_initializing, \"Initializable: contract is not initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Initializable: contract is initializing\");\n    if (_initialized != type(uint8).max) {\n      _initialized = type(uint8).max;\n      emit Initialized(type(uint8).max);\n    }\n  }\n\n  /**\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n  function _getInitializedVersion() internal view returns (uint8) {\n    return _initialized;\n  }\n\n  /**\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n  function _isInitializing() internal view returns (bool) {\n    return _initializing;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n     */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n     */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(x, y, not(0))\n      prod0 := mul(x, y)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n      return prod0 / denominator;\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    require(denominator > prod1, \"Math: mulDiv overflow\");\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly {\n    // Compute remainder using mulmod.\n      remainder := mulmod(x, y, denominator)\n\n    // Subtract 256 bit number from 512 bit number.\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n    // See https://cs.stackexchange.com/q/138556/92363.\n\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\n    uint256 twos = denominator & (~denominator + 1);\n    assembly {\n    // Divide denominator by twos.\n      denominator := div(denominator, twos)\n\n    // Divide [prod1 prod0] by twos.\n      prod0 := div(prod0, twos)\n\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n\n    // Shift in bits from prod1 into prod0.\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n    // four bits. That is, denominator * inv = 1 mod 2^4.\n    uint256 inverse = (3 * denominator) ^ 2;\n\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n    // in modular arithmetic, doubling the correct bits in each step.\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inverse;\n    return result;\n  }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator,\n    Rounding rounding\n  ) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n  unchecked {\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    return min(result, a / result);\n  }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = sqrt(a);\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 128;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 64;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 32;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 16;\n    }\n    if (value >> 8 > 0) {\n      value >>= 8;\n      result += 8;\n    }\n    if (value >> 4 > 0) {\n      value >>= 4;\n      result += 4;\n    }\n    if (value >> 2 > 0) {\n      value >>= 2;\n      result += 2;\n    }\n    if (value >> 1 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log2(value);\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >= 10**64) {\n      value /= 10**64;\n      result += 64;\n    }\n    if (value >= 10**32) {\n      value /= 10**32;\n      result += 32;\n    }\n    if (value >= 10**16) {\n      value /= 10**16;\n      result += 16;\n    }\n    if (value >= 10**8) {\n      value /= 10**8;\n      result += 8;\n    }\n    if (value >= 10**4) {\n      value /= 10**4;\n      result += 4;\n    }\n    if (value >= 10**2) {\n      value /= 10**2;\n      result += 2;\n    }\n    if (value >= 10**1) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log10(value);\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 16;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 8;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 4;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 2;\n    }\n    if (value >> 8 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log256(value);\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n  }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n    // Copy msg.data. We take full control of memory in this inline assembly\n    // block because it will not return to Solidity code. We overwrite the\n    // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n    // Call the implementation.\n    // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n    // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return (0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n  // Booleans are more expensive than uint256 or any type that takes up a full\n  // word because each write operation emits an extra SLOAD to first read the\n  // slot's contents, replace the bits taken up by the boolean, and then write\n  // back. This is the compiler's defense against contract upgrades and\n  // pointer aliasing, and it cannot be disabled.\n\n  // The values being non-zero value makes deployment a bit more expensive,\n  // but in exchange the refund on every call to nonReentrant will be lower in\n  // amount. Since refunds are capped to a percentage of the total\n  // transaction's gas, it is best to keep them low in cases like this one, to\n  // increase the likelihood of the full refund coming into effect.\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor() {\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n  modifier nonReentrant() {\n    _nonReentrantBefore();\n    _;\n    _nonReentrantAfter();\n  }\n\n  function _nonReentrantBefore() private {\n    // On the first call to nonReentrant, _status will be _NOT_ENTERED\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n  }\n\n  function _nonReentrantAfter() private {\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n  function _reentrancyGuardEntered() internal view returns (bool) {\n    return _status == _ENTERED;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n  unchecked {\n    uint256 oldAllowance = token.allowance(address(this), spender);\n    require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n    uint256 newAllowance = oldAllowance - value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n  function toString(uint256 value) internal pure returns (string memory) {\n  unchecked {\n    uint256 length = Math.log10(value) + 1;\n    string memory buffer = new string(length);\n    uint256 ptr;\n    /// @solidity memory-safe-assembly\n    assembly {\n      ptr := add(buffer, add(32, length))\n    }\n    while (true) {\n      ptr--;\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n      }\n      value /= 10;\n      if (value == 0) break;\n    }\n    return buffer;\n  }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n  unchecked {\n    return toHexString(value, Math.log256(value) + 1);\n  }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/ControllableV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/SlotsLib.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"3.0.0\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  /// @dev Prevent implementation init\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) internal onlyInitializing {\n    require(controller_ != address(0), \"Zero controller\");\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\n    require(IController(controller_).governance() != address(0), \"Zero governance\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address _value) public override view returns (bool) {\n    return _value == controller();\n  }\n\n  /// @notice Return true if given address is setup as governance in Controller\n  function isGovernance(address _value) public override view returns (bool) {\n    return IController(controller()).governance() == _value;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view returns (uint){\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view returns (address){\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return controller address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/ProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"./UpgradeableProxy.sol\";\nimport \"../interfaces/IERC165.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title EIP1967 Upgradable proxy implementation.\n/// @dev Only Controller has access and should implement time-lock for upgrade action.\n/// @author belbix\ncontract ProxyControlled is UpgradeableProxy, IProxyControlled {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant PROXY_CONTROLLED_VERSION = \"1.0.1\";\n\n  /// @dev Initialize proxy implementation. Need to call after deploy new proxy.\n  function initProxy(address _logic) external override {\n    //make sure that given logic is controllable and not inited\n    require(IERC165(_logic).supportsInterface(InterfaceIds.I_CONTROLLABLE), \"Proxy: Wrong implementation\");\n    _init(_logic);\n  }\n\n  /// @notice Upgrade contract logic\n  /// @dev Upgrade allowed only for Controller and should be done only after time-lock period\n  /// @param _newImplementation Implementation address\n  function upgrade(address _newImplementation) external override {\n    require(IERC165(_newImplementation).supportsInterface(InterfaceIds.I_CONTROLLABLE), \"Proxy: Wrong implementation\");\n    require(IControllable(address(this)).isController(msg.sender), \"Proxy: Forbidden\");\n    IControllable(address(this)).increaseRevision(_implementation());\n    _upgradeTo(_newImplementation);\n    // the new contract must have the same ABI and you must have the power to change it again\n    require(IControllable(address(this)).isController(msg.sender), \"Proxy: Wrong implementation\");\n  }\n\n  /// @notice Return current logic implementation\n  function implementation() external override view returns (address) {\n    return _implementation();\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Proxy.sol\";\nimport \"../openzeppelin/Address.sol\";\n\n/// @title OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/proxy/UpgradeableProxy.sol\n/// @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n///      implementation address that can be changed. This address is stored in storage in the location specified by\n///      https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n///      implementation behind the proxy.\n///      Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n///      {TransparentUpgradeableProxy}.\nabstract contract UpgradeableProxy is Proxy {\n\n  /// @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n  ///      If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n  ///      function call, and allows initializating the storage of the proxy like a Solidity constructor.\n  constructor() payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n  }\n\n  /// @dev Emitted when the implementation is upgraded.\n  event Upgraded(address indexed implementation);\n\n  ///@dev Storage slot with the address of the current implementation.\n  ///     This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n  ///     validated in the constructor.\n  bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /// @dev Post deploy initialisation for compatability with EIP-1167 factory\n  function _init(address _logic) internal {\n    require(_implementation() == address(0), \"Already inited\");\n    _setImplementation(_logic);\n  }\n\n  /// @dev Returns the current implementation address.\n  function _implementation() internal view virtual override returns (address impl) {\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /// @dev Upgrades the proxy to a new implementation.\n  ///      Emits an {Upgraded} event.\n  function _upgradeTo(address newImplementation) internal virtual {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /// @dev Stores a new address in the EIP1967 implementation slot.\n  function _setImplementation(address newImplementation) private {\n    require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/reward/MultiBribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IBribe.sol\";\nimport \"./StakelessMultiPoolBase.sol\";\nimport \"../interfaces/IForwarder.sol\";\n\n/// @title Stakeless pool for ve token\n/// @author belbix\ncontract MultiBribe is StakelessMultiPoolBase, IBribe {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant MULTI_BRIBE_VERSION = \"1.0.0\";\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev The ve token used for gauges\n  address public ve;\n  /// @dev vault => rt => epoch => amount\n  mapping(address => mapping(address => mapping(uint => uint))) public rewardsQueue;\n  /// @dev Current epoch for delayed rewards\n  uint public override epoch;\n  address public epochOperator;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event BribeDeposit(address indexed vault, uint indexed veId, uint amount);\n  event BribeWithdraw(address indexed vault, uint indexed veId, uint amount);\n  event RewardsForNextEpoch(address vault, address token, uint epoch, uint amount);\n  event DelayedRewardsNotified(address vault, address token, uint epoch, uint amount);\n  event EpochOperatorChanged(address value);\n  event EpochIncreased(uint epoch);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  function init(\n    address controller_,\n    address _ve,\n    address _defaultReward\n  ) external initializer {\n    __MultiPool_init(controller_, _defaultReward, 1);\n    _requireInterface(_ve, InterfaceIds.I_VE_TETU);\n    ve = _ve;\n  }\n\n  function voter() public view returns (address) {\n    return IController(controller()).voter();\n  }\n\n  // *************************************************************\n  //                      GOV ACTIONS\n  // *************************************************************\n\n  function setEpochOperator(address value) external {\n    require(isGovernance(msg.sender), \"!gov\");\n    epochOperator = value;\n    emit EpochOperatorChanged(value);\n  }\n\n  // *************************************************************\n  //                        CLAIMS\n  // *************************************************************\n\n  function getReward(\n    address _vault,\n    uint veId,\n    address[] memory tokens\n  ) external override {\n    _getReward(_vault, veId, tokens, IERC721(ve).ownerOf(veId));\n  }\n\n  function getAllRewards(\n    address _vault,\n    uint veId\n  ) external override {\n    _getAllRewards(_vault, veId, IERC721(ve).ownerOf(veId));\n  }\n\n  function _getAllRewards(\n    address _vault,\n    uint veId,\n    address recipient\n  ) internal {\n    address[] storage rts = rewardTokens[_vault];\n    uint length = rts.length;\n    address[] memory tokens = new address[](length + 1);\n    for (uint i; i < length; ++i) {\n      tokens[i] = rts[i];\n    }\n    tokens[length] = defaultRewardToken;\n    _getReward(_vault, veId, tokens, recipient);\n  }\n\n  function getAllRewardsForTokens(\n    address[] memory _vaults,\n    uint veId\n  ) external override {\n    address recipient = IERC721(ve).ownerOf(veId);\n    for (uint i; i < _vaults.length; i++) {\n      _getAllRewards(_vaults[i], veId, recipient);\n    }\n  }\n\n  function _getReward(\n    address _vault,\n    uint veId,\n    address[] memory _rewardTokens,\n    address recipient\n  ) internal {\n    IForwarder(IController(controller()).forwarder()).distributeAll(_vault);\n    uint _epoch = epoch;\n    for (uint i; i < _rewardTokens.length; ++i) {\n      _notifyDelayedRewards(_vault, _rewardTokens[i], _epoch);\n    }\n    _getReward(_vault, tokenIdToAddress(veId), _rewardTokens, recipient);\n  }\n\n  // *************************************************************\n  //                   DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  /// @dev Only voter can call it when a user vote for the vault\n  function deposit(address vault, uint amount, uint veId) external override {\n    require(msg.sender == voter(), \"Not voter\");\n    _registerBalanceIncreasing(vault, tokenIdToAddress(veId), amount);\n    emit BribeDeposit(vault, veId, amount);\n  }\n\n  /// @dev Only voter can call it when a user reset the vote for the vault.\n  function withdraw(address vault, uint amount, uint veId) external override {\n    require(msg.sender == voter(), \"Not voter\");\n    _registerBalanceDecreasing(vault, tokenIdToAddress(veId), amount);\n    emit BribeWithdraw(vault, veId, amount);\n  }\n\n  // *************************************************************\n  //                   REWARDS DISTRIBUTION\n  // *************************************************************\n\n  /// @dev Add rewards to the current users\n  function notifyRewardAmount(address vault, address token, uint amount) external nonReentrant override {\n    _notifyRewardAmount(vault, token, amount, true);\n  }\n\n  /// @dev Add delayed rewards for the next epoch\n  function notifyForNextEpoch(address vault, address token, uint amount) external nonReentrant override {\n    require(defaultRewardToken == token || isRewardToken[vault][token], \"Token not allowed\");\n\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n    uint _epoch = epoch + 1;\n    rewardsQueue[vault][token][_epoch] = amount;\n\n    emit RewardsForNextEpoch(vault, token, _epoch, amount);\n  }\n\n  /// @dev Notify delayed rewards\n  function notifyDelayedRewards(address vault, address token, uint _epoch) external nonReentrant override {\n    require(epoch == _epoch, \"!epoch\");\n    _notifyDelayedRewards(vault, token, _epoch);\n  }\n\n  function _notifyDelayedRewards(address vault, address token, uint _epoch) internal {\n    uint amount = rewardsQueue[vault][token][_epoch];\n    if (amount != 0 && amount > left(vault, token)) {\n      _notifyRewardAmount(vault, token, amount, false);\n      delete rewardsQueue[vault][token][_epoch];\n      emit DelayedRewardsNotified(vault, token, epoch, amount);\n    }\n  }\n\n  /// @dev Increase the current epoch by one, Epoch operator should increase it weekly.\n  function increaseEpoch() external override {\n    require(msg.sender == epochOperator, \"!operator\");\n    epoch++;\n    emit EpochIncreased(epoch);\n  }\n\n  // *************************************************************\n  //                   INTERNAL LOGIC\n  // *************************************************************\n\n  function isStakeToken(address token) public view override returns (bool) {\n    return IController(controller()).isValidVault(token);\n  }\n\n  function addressToTokenId(address adr) public pure returns (uint) {\n    return uint(uint160(adr));\n  }\n\n  function tokenIdToAddress(uint tokenId) public pure returns (address) {\n    address adr = address(uint160(tokenId));\n    require(addressToTokenId(adr) == tokenId, \"Wrong convert\");\n    return adr;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override(StakelessMultiPoolBase) returns (bool) {\n    return interfaceId == InterfaceIds.I_BRIBE || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/reward/MultiGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IERC721.sol\";\nimport \"../interfaces/IVeTetu.sol\";\nimport \"../interfaces/IGauge.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./StakelessMultiPoolBase.sol\";\n\n/// @title Stakeless pool for vaults\n/// @author belbix\ncontract MultiGauge is StakelessMultiPoolBase, IGauge {\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant MULTI_GAUGE_VERSION = \"1.0.0\";\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev The ve token used for gauges\n  address public ve;\n  /// @dev staking token => ve owner => veId\n  mapping(address => mapping(address => uint)) public override veIds;\n  /// @dev Staking token => whitelist status\n  mapping(address => bool) public stakingTokens;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event AddStakingToken(address token);\n  event Deposit(address indexed stakingToken, address indexed account, uint amount);\n  event Withdraw(address indexed stakingToken, address indexed account, uint amount, bool full, uint veId);\n  event VeTokenLocked(address indexed stakingToken, address indexed account, uint tokenId);\n  event VeTokenUnlocked(address indexed stakingToken, address indexed account, uint tokenId);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  function init(\n    address controller_,\n    address _ve,\n    address _defaultRewardToken\n  ) external initializer {\n    __MultiPool_init(controller_, _defaultRewardToken, 7 days);\n    _requireInterface(_ve, InterfaceIds.I_VE_TETU);\n    ve = _ve;\n  }\n\n  function voter() public view returns (IVoter) {\n    return IVoter(IController(controller()).voter());\n  }\n\n  // *************************************************************\n  //                    OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev Allowed contracts can whitelist token. Removing is forbidden.\n  function addStakingToken(address token) external override onlyAllowedContracts {\n    stakingTokens[token] = true;\n    emit AddStakingToken(token);\n  }\n\n  // *************************************************************\n  //                        CLAIMS\n  // *************************************************************\n\n  function getReward(\n    address stakingToken,\n    address account,\n    address[] memory tokens\n  ) external override {\n    _getReward(stakingToken, account, tokens);\n  }\n\n  function getAllRewards(\n    address stakingToken,\n    address account\n  ) external override {\n    _getAllRewards(stakingToken, account);\n  }\n\n  function _getAllRewards(\n    address stakingToken,\n    address account\n  ) internal {\n    address[] storage rts = rewardTokens[stakingToken];\n    uint length = rts.length;\n    address[] memory tokens = new address[](length + 1);\n    for (uint i; i < length; ++i) {\n      tokens[i] = rts[i];\n    }\n    tokens[length] = defaultRewardToken;\n    _getReward(stakingToken, account, tokens);\n  }\n\n  function getAllRewardsForTokens(\n    address[] memory _stakingTokens,\n    address account\n  ) external override {\n    for (uint i; i < _stakingTokens.length; i++) {\n      _getAllRewards(_stakingTokens[i], account);\n    }\n  }\n\n  function _getReward(address stakingToken, address account, address[] memory tokens) internal {\n    voter().distribute(stakingToken);\n    _getReward(stakingToken, account, tokens, account);\n  }\n\n  // *************************************************************\n  //                   VIRTUAL DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  function attachVe(address stakingToken, address account, uint veId) external override {\n    require(IERC721(ve).ownerOf(veId) == account && account == msg.sender, \"Not ve token owner\");\n    require(isStakeToken(stakingToken), \"Wrong staking token\");\n\n    if (veIds[stakingToken][account] == 0) {\n      veIds[stakingToken][account] = veId;\n      voter().attachTokenToGauge(stakingToken, veId, account);\n    }\n    require(veIds[stakingToken][account] == veId, \"Wrong ve\");\n\n    _updateDerivedBalance(stakingToken, account);\n    _updateRewardForAllTokens(stakingToken, account);\n    emit VeTokenLocked(stakingToken, account, veId);\n  }\n\n  function detachVe(address stakingToken, address account, uint veId) external override {\n    require((IERC721(ve).ownerOf(veId) == account && msg.sender == account)\n      || msg.sender == address(voter()), \"Not ve token owner or voter\");\n    require(isStakeToken(stakingToken), \"Wrong staking token\");\n\n    _unlockVeToken(stakingToken, account, veId);\n    _updateDerivedBalance(stakingToken, account);\n    _updateRewardForAllTokens(stakingToken, account);\n  }\n\n  /// @dev Must be called from stakingToken when user balance changed.\n  function handleBalanceChange(address account) external override {\n    address stakingToken = msg.sender;\n    require(isStakeToken(stakingToken), \"Wrong staking token\");\n\n    uint stakedBalance = balanceOf[stakingToken][account];\n    uint actualBalance = IERC20(stakingToken).balanceOf(account);\n    if (stakedBalance < actualBalance) {\n      _deposit(stakingToken, account, actualBalance - stakedBalance);\n    } else if (stakedBalance > actualBalance) {\n      _withdraw(stakingToken, account, stakedBalance - actualBalance, actualBalance == 0);\n    }\n  }\n\n  function _deposit(\n    address stakingToken,\n    address account,\n    uint amount\n  ) internal {\n    _registerBalanceIncreasing(stakingToken, account, amount);\n    emit Deposit(stakingToken, account, amount);\n  }\n\n  function _withdraw(\n    address stakingToken,\n    address account,\n    uint amount,\n    bool fullWithdraw\n  ) internal {\n    uint veId = 0;\n    if (fullWithdraw) {\n      veId = veIds[stakingToken][account];\n    }\n    if (veId > 0) {\n      _unlockVeToken(stakingToken, account, veId);\n    }\n    _registerBalanceDecreasing(stakingToken, account, amount);\n    emit Withdraw(\n      stakingToken,\n      account,\n      amount,\n      fullWithdraw,\n      veId\n    );\n  }\n\n  /// @dev Balance should be recalculated after the unlock\n  function _unlockVeToken(address stakingToken, address account, uint veId) internal {\n    require(veId == veIds[stakingToken][account], \"Wrong ve\");\n    veIds[stakingToken][account] = 0;\n    voter().detachTokenFromGauge(stakingToken, veId, account);\n    emit VeTokenUnlocked(stakingToken, account, veId);\n  }\n\n  // *************************************************************\n  //                   LOGIC OVERRIDES\n  // *************************************************************\n\n  /// @dev Similar to Curve https://resources.curve.fi/reward-gauges/boosting-your-crv-rewards#formula\n  function derivedBalance(\n    address stakingToken,\n    address account\n  ) public override view returns (uint) {\n    uint _tokenId = veIds[stakingToken][account];\n    uint _balance = balanceOf[stakingToken][account];\n    uint _derived = _balance * 40 / 100;\n    uint _adjusted = 0;\n    uint _supply = IERC20(ve).totalSupply();\n    if (account == IERC721(ve).ownerOf(_tokenId) && _supply > 0) {\n      _adjusted = (totalSupply[stakingToken] * IVeTetu(ve).balanceOfNFT(_tokenId) / _supply) * 60 / 100;\n    }\n    return Math.min((_derived + _adjusted), _balance);\n  }\n\n  function isStakeToken(address token) public view override returns (bool) {\n    return stakingTokens[token];\n  }\n\n  // *************************************************************\n  //                   REWARDS DISTRIBUTION\n  // *************************************************************\n\n  function notifyRewardAmount(address stakingToken, address token, uint amount) external nonReentrant override {\n    _notifyRewardAmount(stakingToken, token, amount, true);\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override(StakelessMultiPoolBase) returns (bool) {\n    return interfaceId == InterfaceIds.I_GAUGE || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/reward/StakelessMultiPoolBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Math.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IMultiPool.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../lib/InterfaceIds.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Abstract stakeless pool for multiple rewards.\n///        Universal pool for different purposes, cover the most popular use cases.\n/// @author belbix\nabstract contract StakelessMultiPoolBase is TetuERC165, ReentrancyGuard, IMultiPool, ControllableV3 {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant MULTI_POOL_VERSION = \"1.0.0\";\n  /// @dev Precision for internal calculations\n  uint internal constant _PRECISION = 10 ** 27;\n  /// @dev Max reward tokens per 1 staking token\n  uint internal constant _MAX_REWARD_TOKENS = 10;\n\n  // *************************************************************\n  //                        VARIABLES\n  //              Keep names and ordering!\n  //     Add only in the bottom and adjust __gap variable\n  // *************************************************************\n\n  /// @dev Rewards are released over this period\n  uint public duration;\n  /// @dev This token will be always allowed as reward\n  address public defaultRewardToken;\n\n  /// @dev Staking token => Supply adjusted on derived balance logic. Use for rewards boost.\n  mapping(address => uint) public override derivedSupply;\n  /// @dev Staking token => Account => Staking token virtual balance. Can be adjusted regarding rewards boost logic.\n  mapping(address => mapping(address => uint)) public override derivedBalances;\n  /// @dev Staking token => Account => User virtual balance of staking token.\n  mapping(address => mapping(address => uint)) public override balanceOf;\n  /// @dev Staking token => Total amount of attached staking tokens\n  mapping(address => uint) public override totalSupply;\n\n  /// @dev Staking token => Reward token => Reward rate with precision _PRECISION\n  mapping(address => mapping(address => uint)) public rewardRate;\n  /// @dev Staking token => Reward token => Reward finish period in timestamp.\n  mapping(address => mapping(address => uint)) public periodFinish;\n  /// @dev Staking token => Reward token => Last updated time for reward token for internal calculations.\n  mapping(address => mapping(address => uint)) public lastUpdateTime;\n  /// @dev Staking token => Reward token => Part of SNX pool logic. Internal snapshot of reward per token value.\n  mapping(address => mapping(address => uint)) public rewardPerTokenStored;\n\n  /// @dev Staking token => Reward token => Account => amount. Already paid reward amount for snapshot calculation.\n  mapping(address => mapping(address => mapping(address => uint))) public userRewardPerTokenPaid;\n  /// @dev Staking token => Reward token => Account => amount. Snapshot of user's reward per token.\n  mapping(address => mapping(address => mapping(address => uint))) public rewards;\n\n  /// @dev Allowed reward tokens for staking token\n  mapping(address => address[]) public override rewardTokens;\n  /// @dev Allowed reward tokens for staking token stored in map for fast check.\n  mapping(address => mapping(address => bool)) public override isRewardToken;\n  /// @notice account => recipient. All rewards for this account will receive recipient\n  mapping(address => address) public rewardsRedirect;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event BalanceIncreased(address indexed token, address indexed account, uint amount);\n  event BalanceDecreased(address indexed token, address indexed account, uint amount);\n  event NotifyReward(address indexed from, address token, address indexed reward, uint amount);\n  event ClaimRewards(address indexed account, address token, address indexed reward, uint amount, address recepient);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  function __MultiPool_init(\n    address controller_,\n    address _defaultRewardToken,\n    uint _duration\n  ) internal onlyInitializing {\n    __Controllable_init(controller_);\n    _requireERC20(_defaultRewardToken);\n    defaultRewardToken = _defaultRewardToken;\n    require(_duration != 0, \"wrong duration\");\n    duration = _duration;\n  }\n\n  // *************************************************************\n  //                        RESTRICTIONS\n  // *************************************************************\n\n  modifier onlyAllowedContracts() {\n    IController _controller = IController(controller());\n    require(\n      msg.sender == _controller.governance()\n      || msg.sender == _controller.forwarder()\n    , \"Not allowed\");\n    _;\n  }\n\n  // *************************************************************\n  //                            VIEWS\n  // *************************************************************\n\n  /// @dev Should return true for whitelisted reward tokens\n  function isStakeToken(address token) public view override virtual returns (bool);\n\n  /// @dev Length of rewards tokens array for given token\n  function rewardTokensLength(address token) external view override returns (uint) {\n    return rewardTokens[token].length;\n  }\n\n  /// @dev Reward paid for token for the current period.\n  function rewardPerToken(address stakingToken, address rewardToken) public view returns (uint) {\n    uint _derivedSupply = derivedSupply[stakingToken];\n    if (_derivedSupply == 0) {\n      return rewardPerTokenStored[stakingToken][rewardToken];\n    }\n\n    return rewardPerTokenStored[stakingToken][rewardToken]\n    +\n    (lastTimeRewardApplicable(stakingToken, rewardToken) - lastUpdateTime[stakingToken][rewardToken])\n    * rewardRate[stakingToken][rewardToken]\n    / _derivedSupply;\n  }\n\n  /// @dev Returns the last time the reward was modified or periodFinish if the reward has ended\n  function lastTimeRewardApplicable(address stakingToken, address rewardToken) public view returns (uint) {\n    uint _periodFinish = periodFinish[stakingToken][rewardToken];\n    return block.timestamp < _periodFinish ? block.timestamp : _periodFinish;\n  }\n\n  /// @dev Balance of holder adjusted with specific rules for boost calculation.\n  ///      Supposed to be implemented in a parent contract\n  ///      Adjust user balance with some logic, like boost logic.\n  function derivedBalance(address stakingToken, address account) public view virtual override returns (uint) {\n    return balanceOf[stakingToken][account];\n  }\n\n  /// @dev Amount of reward tokens left for the current period\n  function left(address stakingToken, address rewardToken) public view override returns (uint) {\n    uint _periodFinish = periodFinish[stakingToken][rewardToken];\n    if (block.timestamp >= _periodFinish) return 0;\n    uint _remaining = _periodFinish - block.timestamp;\n    return _remaining * rewardRate[stakingToken][rewardToken] / _PRECISION;\n  }\n\n  /// @dev Approximate of earned rewards ready to claim\n  function earned(address stakingToken, address rewardToken, address account) public view override returns (uint) {\n    return derivedBalance(stakingToken, account)\n    * (rewardPerToken(stakingToken, rewardToken) - userRewardPerTokenPaid[stakingToken][rewardToken][account])\n    / _PRECISION\n    + rewards[stakingToken][rewardToken][account];\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override(ControllableV3, TetuERC165) returns (bool) {\n    return interfaceId == InterfaceIds.I_MULTI_POOL || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                  OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev Whitelist reward token for staking token. Only operator can do it.\n  function registerRewardToken(address stakeToken, address rewardToken) external override onlyAllowedContracts {\n    require(rewardTokens[stakeToken].length < _MAX_REWARD_TOKENS, \"Too many reward tokens\");\n    require(!isRewardToken[stakeToken][rewardToken], \"Already registered\");\n    isRewardToken[stakeToken][rewardToken] = true;\n    rewardTokens[stakeToken].push(rewardToken);\n  }\n\n  /// @dev Remove from whitelist reward token for staking token. Only operator can do it.\n  ///      We assume that the first token can not be removed.\n  function removeRewardToken(address stakeToken, address rewardToken) external override onlyAllowedContracts {\n    require(periodFinish[stakeToken][rewardToken] < block.timestamp, \"Rewards not ended\");\n    require(isRewardToken[stakeToken][rewardToken], \"Not reward token\");\n\n    isRewardToken[stakeToken][rewardToken] = false;\n    uint length = rewardTokens[stakeToken].length;\n    uint i = 0;\n    for (; i < length; i++) {\n      address t = rewardTokens[stakeToken][i];\n      if (t == rewardToken) {\n        break;\n      }\n    }\n    // if isRewardToken map and rewardTokens array changed accordingly the token always exist\n    rewardTokens[stakeToken][i] = rewardTokens[stakeToken][length - 1];\n    rewardTokens[stakeToken].pop();\n  }\n\n  /// @dev Account or governance can setup a redirect of all rewards.\n  ///      It needs for 3rd party contracts integrations.\n  function setRewardsRedirect(address account, address recipient) external {\n    require(msg.sender == account || isGovernance(msg.sender), \"Not allowed\");\n    rewardsRedirect[account] = recipient;\n  }\n\n  // *************************************************************\n  //                      BALANCE\n  // *************************************************************\n\n  /// @dev Assume to be called when linked token balance changes.\n  function _registerBalanceIncreasing(\n    address stakingToken,\n    address account,\n    uint amount\n  ) internal virtual nonReentrant {\n    require(isStakeToken(stakingToken), \"Staking token not allowed\");\n    require(amount > 0, \"Zero amount\");\n\n    _increaseBalance(stakingToken, account, amount);\n    emit BalanceIncreased(stakingToken, account, amount);\n  }\n\n  function _increaseBalance(\n    address stakingToken,\n    address account,\n    uint amount\n  ) internal virtual {\n    _updateRewardForAllTokens(stakingToken, account);\n    totalSupply[stakingToken] += amount;\n    balanceOf[stakingToken][account] += amount;\n    _updateDerivedBalance(stakingToken, account);\n  }\n\n  /// @dev Assume to be called when linked token balance changes.\n  function _registerBalanceDecreasing(\n    address stakingToken,\n    address account,\n    uint amount\n  ) internal nonReentrant virtual {\n    require(isStakeToken(stakingToken), \"Staking token not allowed\");\n    _decreaseBalance(stakingToken, account, amount);\n    emit BalanceDecreased(stakingToken, account, amount);\n  }\n\n  function _decreaseBalance(\n    address stakingToken,\n    address account,\n    uint amount\n  ) internal virtual {\n    _updateRewardForAllTokens(stakingToken, account);\n    totalSupply[stakingToken] -= amount;\n    balanceOf[stakingToken][account] -= amount;\n    _updateDerivedBalance(stakingToken, account);\n  }\n\n  function _updateDerivedBalance(address stakingToken, address account) internal {\n    uint __derivedBalance = derivedBalances[stakingToken][account];\n    derivedSupply[stakingToken] -= __derivedBalance;\n    __derivedBalance = derivedBalance(stakingToken, account);\n    derivedBalances[stakingToken][account] = __derivedBalance;\n    derivedSupply[stakingToken] += __derivedBalance;\n  }\n\n  // *************************************************************\n  //                          CLAIM\n  // *************************************************************\n\n  /// @dev Caller should implement restriction checks\n  function _getReward(\n    address stakingToken,\n    address account,\n    address[] memory rewardTokens_,\n    address recipient\n  ) internal nonReentrant virtual {\n    address newRecipient = rewardsRedirect[recipient];\n    if (newRecipient != address(0)) {\n      recipient = newRecipient;\n    }\n    require(recipient == msg.sender, \"Not allowed\");\n\n    _updateDerivedBalance(stakingToken, account);\n\n    for (uint i = 0; i < rewardTokens_.length; i++) {\n      address rewardToken = rewardTokens_[i];\n      _updateReward(stakingToken, rewardToken, account);\n\n      uint _reward = rewards[stakingToken][rewardToken][account];\n      if (_reward > 0) {\n        rewards[stakingToken][rewardToken][account] = 0;\n        IERC20(rewardToken).safeTransfer(recipient, _reward);\n      }\n\n      emit ClaimRewards(account, stakingToken, rewardToken, _reward, recipient);\n    }\n  }\n\n  // *************************************************************\n  //                    REWARDS CALCULATIONS\n  // *************************************************************\n\n  function _updateRewardForAllTokens(address stakingToken, address account) internal {\n    address[] memory rts = rewardTokens[stakingToken];\n    uint length = rts.length;\n    for (uint i; i < length; i++) {\n      _updateReward(stakingToken, rts[i], account);\n    }\n    _updateReward(stakingToken, defaultRewardToken, account);\n  }\n\n  function _updateReward(address stakingToken, address rewardToken, address account) internal {\n    uint _rewardPerTokenStored = rewardPerToken(stakingToken, rewardToken);\n    rewardPerTokenStored[stakingToken][rewardToken] = _rewardPerTokenStored;\n    lastUpdateTime[stakingToken][rewardToken] = lastTimeRewardApplicable(stakingToken, rewardToken);\n    if (account != address(0)) {\n      rewards[stakingToken][rewardToken][account] = earned(stakingToken, rewardToken, account);\n      userRewardPerTokenPaid[stakingToken][rewardToken][account] = _rewardPerTokenStored;\n    }\n  }\n\n  // *************************************************************\n  //                         NOTIFY\n  // *************************************************************\n\n  function _notifyRewardAmount(\n    address stakingToken,\n    address rewardToken,\n    uint amount,\n    bool transferRewards\n  ) internal virtual {\n    require(amount > 0, \"Zero amount\");\n    require(defaultRewardToken == rewardToken || isRewardToken[stakingToken][rewardToken], \"Token not allowed\");\n\n    _updateReward(stakingToken, rewardToken, address(0));\n    uint _duration = duration;\n\n    if (transferRewards) {\n      uint balanceBefore = IERC20(rewardToken).balanceOf(address(this));\n      IERC20(rewardToken).safeTransferFrom(msg.sender, address(this), amount);\n      // refresh amount if token was taxable\n      amount = IERC20(rewardToken).balanceOf(address(this)) - balanceBefore;\n    }\n    // if transferRewards=false need to wisely use it in implementation!\n\n    if (block.timestamp >= periodFinish[stakingToken][rewardToken]) {\n      rewardRate[stakingToken][rewardToken] = amount * _PRECISION / _duration;\n    } else {\n      uint _remaining = periodFinish[stakingToken][rewardToken] - block.timestamp;\n      uint _left = _remaining * rewardRate[stakingToken][rewardToken];\n      // rewards should not extend period infinity, only higher amount allowed\n      require(amount > _left / _PRECISION, \"Amount should be higher than remaining rewards\");\n      rewardRate[stakingToken][rewardToken] = (amount * _PRECISION + _left) / _duration;\n    }\n\n    lastUpdateTime[stakingToken][rewardToken] = block.timestamp;\n    periodFinish[stakingToken][rewardToken] = block.timestamp + _duration;\n    emit NotifyReward(msg.sender, stakingToken, rewardToken, amount);\n  }\n\n  /**\n* @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[38] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./StrategyLib.sol\";\n\n/// @title Abstract contract for base strategy functionality\n/// @author belbix\nabstract contract StrategyBaseV2 is IStrategyV2, ControllableV3 {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant STRATEGY_BASE_VERSION = \"2.1.1\";\n  /// @dev Denominator for compound ratio\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n  /// @notice 10% of total profit is sent to {performanceReceiver} before compounding\n  uint internal constant DEFAULT_PERFORMANCE_FEE = 10_000;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Linked splitter\n  address public override splitter;\n  /// @dev Percent of profit for autocompound inside this strategy.\n  uint public override compoundRatio;\n  /// @notice Balances of not-reward amounts\n  /// @dev Any amounts transferred to the strategy for investing or withdrawn back are registered here\n  ///      As result it's possible to distinct invested amounts from rewards, airdrops and other profits\n  mapping(address => uint) public baseAmounts;\n\n  /// @notice {performanceFee}% of total profit is sent to {performanceReceiver} before compounding\n  /// @dev governance by default\n  address public override performanceReceiver;\n\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\n  /// @dev {DEFAULT_PERFORMANCE_FEE} by default, FEE_DENOMINATOR is used\n  uint public override performanceFee;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event WithdrawAllToSplitter(uint amount);\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\n  event EmergencyExit(address sender, uint amount);\n  event ManualClaim(address sender);\n  event InvestAll(uint balance);\n  event DepositToPool(uint amount);\n  event WithdrawFromPool(uint amount);\n  event WithdrawAllFromPool(uint amount);\n  event Claimed(address token, uint amount);\n  event CompoundRatioChanged(uint oldValue, uint newValue);\n  /// @notice {baseAmounts} of {asset} is changed on the {amount} value\n  event UpdateBaseAmounts(address asset, int amount);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __StrategyBase_init(\n    address controller_,\n    address _splitter\n  ) internal onlyInitializing {\n    _requireInterface(_splitter, InterfaceIds.I_SPLITTER);\n    __Controllable_init(controller_);\n\n    require(IControllable(_splitter).isController(controller_), StrategyLib.WRONG_VALUE);\n\n    asset = ISplitter(_splitter).asset();\n    splitter = _splitter;\n\n    performanceReceiver = IController(controller_).governance();\n    performanceFee = DEFAULT_PERFORMANCE_FEE;\n  }\n\n  // *************************************************************\n  //                     PERFORMANCE FEE\n  // *************************************************************\n  /// @notice Set performance fee and receiver\n  function setupPerformanceFee(uint fee_, address receiver_) external {\n    StrategyLib.onlyGovernance(controller());\n    require(fee_ <= DEFAULT_PERFORMANCE_FEE, StrategyLib.TOO_HIGH);\n    require(receiver_ != address(0), StrategyLib.WRONG_VALUE);\n\n    performanceFee = fee_;\n    performanceReceiver = receiver_;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of underlying assets under control of this strategy.\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this)) + investedAssets();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_STRATEGY_V2 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                   VOTER ACTIONS\n  // *************************************************************\n\n  /// @dev PlatformVoter can change compound ratio for some strategies.\n  ///      A strategy can implement another logic for some uniq cases.\n  function setCompoundRatio(uint value) external virtual override {\n    StrategyLib.onlyPlatformVoter(controller());\n    require(value <= COMPOUND_DENOMINATOR, StrategyLib.TOO_HIGH);\n    emit CompoundRatioChanged(compoundRatio, value);\n    compoundRatio = value;\n  }\n\n  // *************************************************************\n  //                   OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev In case of any issue operator can withdraw all from pool.\n  function emergencyExit() external {\n    StrategyLib.onlyOperators(controller());\n\n    _emergencyExitFromPool();\n\n    address _asset = asset;\n    // gas saving\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    _decreaseBaseAmount(_asset, baseAmounts[_asset]);\n    // reset base amount\n    IERC20(_asset).safeTransfer(splitter, balance);\n    emit EmergencyExit(msg.sender, balance);\n  }\n\n  /// @dev Manual claim rewards.\n  function claim() external {\n    StrategyLib.onlyOperators(controller());\n\n    _claim();\n    emit ManualClaim(msg.sender);\n  }\n\n  // *************************************************************\n  //                    DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external override returns (\n    int totalAssetsDelta\n  ) {\n    StrategyLib.onlySplitter(splitter);\n\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n\n    _increaseBaseAmount(_asset, amount_, balance);\n\n    if (balance > 0) {\n      totalAssetsDelta = _depositToPool(balance, updateTotalAssetsBeforeInvest_);\n    }\n    emit InvestAll(balance);\n\n    return totalAssetsDelta;\n  }\n\n  /// @dev Withdraws all underlying assets to the vault\n  /// @return Return [totalAssets-before-withdraw - totalAssets-before-call-of-withdrawAllToSplitter]\n  function withdrawAllToSplitter() external override returns (int) {\n    address _splitter = splitter;\n    address _asset = asset;\n    StrategyLib.onlySplitter(_splitter);\n\n    uint balance = IERC20(_asset).balanceOf(address(this));\n\n    (uint investedAssetsUSD, uint assetPrice, int totalAssetsDelta) = _withdrawAllFromPool();\n\n    balance = StrategyLib.checkWithdrawImpact(\n      _asset,\n      balance,\n      investedAssetsUSD,\n      assetPrice,\n      _splitter\n    );\n\n    {\n      // we cannot withdraw more than the base amount value\n      // if any additional amount exist on the balance (i.e. airdrops)\n      // it should be processed by hardwork at first (split on compound/forwarder)\n      uint baseAmount = baseAmounts[_asset];\n      if (balance > baseAmount) {\n        balance = baseAmount;\n      }\n    }\n\n    if (balance != 0) {\n      _decreaseBaseAmount(_asset, balance);\n      IERC20(_asset).safeTransfer(_splitter, balance);\n    }\n    emit WithdrawAllToSplitter(balance);\n\n    return totalAssetsDelta;\n  }\n\n  /// @dev Withdraws some assets to the splitter\n  /// @return totalAssetsDelta =[totalAssets-before-withdraw - totalAssets-before-call-of-withdrawAllToSplitter]\n  function withdrawToSplitter(uint amount) external override returns (int totalAssetsDelta) {\n    address _splitter = splitter;\n    address _asset = asset;\n    StrategyLib.onlySplitter(_splitter);\n\n\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (amount > balance) {\n      uint investedAssetsUSD;\n      uint assetPrice;\n\n      (investedAssetsUSD, assetPrice, totalAssetsDelta) = _withdrawFromPool(amount - balance);\n      balance = StrategyLib.checkWithdrawImpact(\n        _asset,\n        balance,\n        investedAssetsUSD,\n        assetPrice,\n        _splitter\n      );\n    }\n\n    uint amountAdjusted = Math.min(amount, balance);\n    if (amountAdjusted != 0) {\n      _decreaseBaseAmount(_asset, amountAdjusted);\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\n    }\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\n\n    return totalAssetsDelta;\n  }\n\n\n  // *************************************************************\n  //                  baseAmounts modifications\n  // *************************************************************\n\n  /// @notice Decrease {baseAmounts} of the {asset} on {amount_}\n  ///         The {amount_} can be greater then total base amount value because it can includes rewards.\n  ///         We assume here, that base amounts are spent first, then rewards and any other profit-amounts\n  function _decreaseBaseAmount(address asset_, uint amount_) internal {\n    uint baseAmount = baseAmounts[asset_];\n    require(baseAmount >= amount_, StrategyLib.WRONG_VALUE);\n    baseAmounts[asset_] = baseAmount - amount_;\n    emit UpdateBaseAmounts(asset_, - int(baseAmount));\n  }\n\n  /// @notice Increase {baseAmounts} of the {asset} on {amount_}, ensure that current {assetBalance_} >= {amount_}\n  /// @param assetBalance_ Current balance of the {asset} to check if {amount_} > the balance. Pass 0 to skip the check\n  function _increaseBaseAmount(address asset_, uint amount_, uint assetBalance_) internal {\n    baseAmounts[asset_] += amount_;\n    emit UpdateBaseAmounts(asset_, int(amount_));\n    require(assetBalance_ >= amount_, StrategyLib.WRONG_VALUE);\n  }\n\n  // *************************************************************\n  //                       VIRTUAL\n  // These functions must be implemented in the strategy contract\n  // *************************************************************\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function _depositToPool(\n    uint amount,\n    bool updateTotalAssetsBeforeInvest_\n  ) internal virtual returns (\n    int totalAssetsDelta\n  );\n\n  /// @dev Withdraw given amount from the pool.\n  /// @return investedAssetsUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawFromPool(uint amount) internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  );\n\n  /// @dev Withdraw all from the pool.\n  /// @return investedAssetsUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawAllFromPool]\n  function _withdrawAllFromPool() internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  );\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  ///      Withdraw assets without impact checking.\n  function _emergencyExitFromPool() internal virtual;\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal virtual;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\n\nlibrary StrategyLib {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Denominator for fee calculation.\n  uint internal constant FEE_DENOMINATOR = 100_000;\n\n  // *************************************************************\n  //                        ERRORS\n  // *************************************************************\n\n  string internal constant DENIED = \"SB: Denied\";\n  string internal constant TOO_HIGH = \"SB: Too high\";\n  string internal constant WRONG_VALUE = \"SB: Wrong value\";\n\n  // *************************************************************\n  //                     RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Restrict access only for operators\n  function onlyOperators(address controller) external view {\n    require(IController(controller).isOperator(msg.sender), DENIED);\n  }\n\n  /// @dev Restrict access only for governance\n  function onlyGovernance(address controller) external view {\n    require(IController(controller).governance() == msg.sender, DENIED);\n  }\n\n  /// @dev Restrict access only for platform voter\n  function onlyPlatformVoter(address controller) external view {\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\n  }\n\n  /// @dev Restrict access only for splitter\n  function onlySplitter(address splitter) external view {\n    require(splitter == msg.sender, DENIED);\n  }\n\n  // *************************************************************\n  //                       HELPERS\n  // *************************************************************\n\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\n  ///         Revert if the amount is different from expected too much (high price impact)\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\n  /// @param investedAssetsUSD Expected amount in USD, decimals are same to {_asset}\n  /// @param assetPrice Price of the asset, decimals 18\n  /// @return balance Current asset balance of the strategy\n  function checkWithdrawImpact(\n    address _asset,\n    uint balanceBefore,\n    uint investedAssetsUSD,\n    uint assetPrice,\n    address _splitter\n  ) external view returns (uint balance) {\n    balance = IERC20(_asset).balanceOf(address(this));\n    if (assetPrice != 0 && investedAssetsUSD != 0) {\n\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\n      uint difference = investedAssetsUSD > withdrewUSD ? investedAssetsUSD - withdrewUSD : 0;\n\n      require(difference * FEE_DENOMINATOR / investedAssetsUSD <= priceChangeTolerance, TOO_HIGH);\n    }\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyStrictBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../interfaces/IERC4626.sol\";\nimport \"../interfaces/IStrategyStrict.sol\";\nimport \"../tools/TetuERC165.sol\";\n\n/// @title Abstract contract for base strict strategy functionality\n/// @author AlehNat\nabstract contract StrategyStrictBase is IStrategyStrict, TetuERC165 {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant STRICT_STRATEGY_BASE_VERSION = \"1.0.0\";\n\n  // *************************************************************\n  //                        ERRORS\n  // *************************************************************\n\n  string internal constant WRONG_CONTROLLER = \"SB: Wrong controller\";\n  string internal constant DENIED = \"SB: Denied\";\n  string internal constant TOO_HIGH = \"SB: Too high\";\n  string internal constant IMPACT_TOO_HIGH = \"SB: Impact too high\";\n  string internal constant WRONG_AMOUNT = \"SB: Wrong amount\";\n  string internal constant ALREADY_INITIALIZED = \"SB: Already initialized\";\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Linked vault\n  address public override vault;\n  /// @dev Percent of profit for autocompound inside this strategy.\n  uint public override compoundRatio;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event WithdrawAllToVault(uint amount);\n  event WithdrawToVault(uint amount, uint sent, uint balance);\n  event EmergencyExit(address sender, uint amount);\n  event ManualClaim(address sender);\n  event InvestAll(uint balance);\n  event DepositToPool(uint amount);\n  event WithdrawFromPool(uint amount);\n  event WithdrawAllFromPool(uint amount);\n  event Claimed(address token, uint amount);\n  event CompoundRatioChanged(uint oldValue, uint newValue);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Initialize with the vault. Can be called only once.\n  function init(address _vault) external {\n    require(vault == address(0), ALREADY_INITIALIZED);\n    _requireInterface(_vault, InterfaceIds.I_ERC4626);\n    asset = IERC4626(_vault).asset();\n    vault = _vault;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of underlying assets under control of this strategy.\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this)) + investedAssets();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_STRATEGY_STRICT || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                    DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  /// @dev Stakes everything the strategy holds into the reward pool.\n  function investAll() external override {\n    require(msg.sender == vault, DENIED);\n    address _asset = asset; // gas saving\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (balance > 0) {\n      _depositToPool(balance);\n    }\n    emit InvestAll(balance);\n  }\n\n  /// @dev Withdraws all underlying assets to the vault\n  function withdrawAllToVault() external override {\n    address _vault = vault;\n    address _asset = asset; // gas saving\n    require(msg.sender == _vault, DENIED);\n    _withdrawAllFromPool();\n    uint balance = IERC20(_asset).balanceOf(address(this));\n\n    if (balance != 0) {\n      IERC20(_asset).safeTransfer(_vault, balance);\n    }\n    emit WithdrawAllToVault(balance);\n  }\n\n  /// @dev Withdraws some assets to the vault\n  function withdrawToVault(uint amount) external override {\n    address _vault = vault;\n    address _asset = asset; // gas saving\n    require(msg.sender == _vault, DENIED);\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (amount > balance) {\n      _withdrawFromPool(amount - balance);\n      balance = IERC20(_asset).balanceOf(address(this));\n    }\n\n    uint amountAdjusted = Math.min(amount, balance);\n    if (amountAdjusted != 0) {\n      IERC20(_asset).safeTransfer(_vault, amountAdjusted);\n    }\n    emit WithdrawToVault(amount, amountAdjusted, balance);\n  }\n\n  // *************************************************************\n  //                       VIRTUAL\n  // These functions must be implemented in the strategy contract\n  // *************************************************************\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view virtual returns (uint);\n\n  /// @dev Deposit given amount to the pool.\n  function _depositToPool(uint amount) internal virtual;\n\n  /// @dev Withdraw given amount from the pool.\n  /// @return investedAssetsUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  function _withdrawFromPool(uint amount) internal virtual returns (uint investedAssetsUSD, uint assetPrice);\n\n  /// @dev Withdraw all from the pool.\n  /// @return investedAssetsUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  function _withdrawAllFromPool() internal virtual returns (uint investedAssetsUSD, uint assetPrice);\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  ///      Withdraw assets without impact checking.\n  function _emergencyExitFromPool() internal virtual;\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal virtual;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/ControllerMinimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\ncontract ControllerMinimal is TetuERC165, IController {\n\n  address public override governance;\n  address public override voter;\n  address public override liquidator;\n  address public override forwarder;\n  address public override investFund;\n  address public override veDistributor;\n  address public override platformVoter;\n  address[] public override vaults;\n  mapping(address => bool) public operators;\n\n  constructor (address governance_) {\n    governance = governance_;\n    operators[governance_] = true;\n  }\n\n  function setVoter(address _voter) external {\n    voter = _voter;\n  }\n\n  function setPlatformVoter(address _voter) external {\n    platformVoter = _voter;\n  }\n\n  function setLiquidator(address value) external {\n    liquidator = value;\n  }\n\n  function setInvestFund(address value) external {\n    investFund = value;\n  }\n\n  function setForwarder(address value) external {\n    forwarder = value;\n  }\n\n  function setVeDistributor(address value) external {\n    veDistributor = value;\n  }\n\n  function addVault(address vault) external {\n    vaults.push(vault);\n  }\n\n  function updateProxies(address[] memory proxies, address[] memory newLogics) external {\n    require(proxies.length == newLogics.length, \"Wrong arrays\");\n    for (uint i; i < proxies.length; i++) {\n      IProxyControlled(proxies[i]).upgrade(newLogics[i]);\n    }\n  }\n\n  function vaultsList() external view override returns (address[] memory) {\n    return vaults;\n  }\n\n  function vaultsListLength() external override view returns (uint) {\n    return vaults.length;\n  }\n\n  function isValidVault(address _vault) external view override returns (bool) {\n    for (uint i; i < vaults.length; i++) {\n      if (_vault == vaults[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function isOperator(address _adr) external view override returns (bool) {\n    return operators[_adr];\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLER || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/IMockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IMockToken {\n\n  function decimals() external view returns (uint8);\n\n  function mint(address to, uint amount) external;\n\n  function burn(address from, uint amount) external;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../proxy/ControllableV3.sol\";\n\ncontract MockGauge is ControllableV3 {\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n\n  function handleBalanceChange(address) external {\n    // noop\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_GAUGE || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\n\ncontract MockPool {\n\n  function withdraw(address token, uint amount) external {\n    IERC20(token).transfer(msg.sender, amount);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\ncontract MockSplitter is ISplitter, ControllableV3 {\n\n  address public override asset;\n  address public override vault;\n  uint public slippage;\n\n  function init(address controller_, address _asset, address _vault) external initializer override {\n    __Controllable_init(controller_);\n    asset = _asset;\n    vault = _vault;\n  }\n\n  function setSlippage(uint value) external {\n    slippage = value;\n  }\n\n  function withdrawAllToVault() external override {\n    withdrawToVault(IERC20(asset).balanceOf(address(this)));\n  }\n\n  function withdrawToVault(uint256 amount) public override {\n    uint toSend = amount - amount * slippage / 1000;\n    if (slippage != 0) {\n      IERC20(asset).transfer(controller(), amount - toSend);\n    }\n    IERC20(asset).transfer(vault, toSend);\n  }\n\n  function doHardWork() external override {\n    // noop\n  }\n\n  function investAll() external override {\n    // noop\n  }\n\n  function totalAssets() external view override returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  function isHardWorking() external pure override returns (bool) {\n    return false;\n  }\n\n  function lost(uint amount) external {\n    IERC20(asset).transfer(msg.sender, amount);\n  }\n\n  function coverLoss(uint amount) external {\n    ITetuVaultV2(vault).coverLoss(amount);\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_SPLITTER || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../strategy/StrategyBaseV2.sol\";\nimport \"./MockPool.sol\";\nimport \"./MockToken.sol\";\n\ncontract MockStrategy is StrategyBaseV2 {\n\n  string public constant override NAME = \"mock strategy\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  bool public override isReadyToHardWork;\n\n  uint internal slippage;\n  uint internal slippageDeposit;\n  uint internal hardWorkSlippage;\n  uint internal lastEarned;\n  uint internal lastLost;\n  uint internal _capacity;\n  int internal _totalAssetsDelta;\n\n  MockPool public pool;\n\n  function init(\n    address controller_,\n    address _splitter\n  ) external initializer {\n    __StrategyBase_init(controller_, _splitter);\n    splitter = _splitter;\n    isReadyToHardWork = true;\n    _capacity = type(uint).max; // unlimited capacity by default\n    pool = new MockPool();\n  }\n\n  function doHardWork() external override returns (uint earned, uint lost) {\n    pool.withdraw(asset, investedAssets());\n    uint _slippage = IERC20(asset).balanceOf(address(this)) * hardWorkSlippage / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n    if (lastEarned != 0) {\n      uint toCompound = lastEarned * compoundRatio / COMPOUND_DENOMINATOR;\n      MockToken(asset).mint(address(this), toCompound);\n      address forwarder = IController(controller()).forwarder();\n      if (forwarder != address(0)) {\n        MockToken(asset).mint(address(this), lastEarned - toCompound);\n\n        address[] memory tokens = new address[](1);\n        tokens[0] = asset;\n        uint[] memory amounts = new uint[](1);\n        amounts[0] = lastEarned - toCompound;\n        IForwarder(forwarder).registerIncome(tokens, amounts, ISplitter(splitter).vault(), true);\n      }\n    }\n    IERC20(asset).transfer(address(pool), IERC20(asset).balanceOf(address(this)));\n    return (lastEarned, Math.max(lastLost, _slippage));\n  }\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(pool));\n  }\n\n  /// @dev Deposit given amount to the pool.\n  function _depositToPool(\n    uint amount,\n    bool updateTotalAssetsBeforeInvest_\n  ) internal override returns (\n    int totalAssetsDelta\n  ) {\n    uint _slippage = amount * slippageDeposit / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n    if (amount - _slippage != 0) {\n      IERC20(asset).transfer(address(pool), amount - _slippage);\n    }\n\n    return updateTotalAssetsBeforeInvest_\n      ? _totalAssetsDelta\n      : int(0);\n  }\n\n  /// @dev Withdraw given amount from the pool.\n  function _withdrawFromPool(uint amount) internal override returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    assetPrice = 1e18;\n    investedAssetsUSD = amount;\n    totalAssetsDelta = _totalAssetsDelta;\n\n    pool.withdraw(asset, amount);\n    uint _slippage = amount * slippage / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n  }\n\n  /// @dev Withdraw all from the pool.\n  function _withdrawAllFromPool() internal override returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    assetPrice = 1e18;\n    investedAssetsUSD = 0; // investedAssets();\n    totalAssetsDelta = _totalAssetsDelta;\n\n    pool.withdraw(asset, investedAssets());\n    uint _slippage = totalAssets() * slippage / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n\n    return (investedAssetsUSD, assetPrice, _totalAssetsDelta);\n  }\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  function _emergencyExitFromPool() internal override {\n    pool.withdraw(asset, investedAssets());\n  }\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal override {\n    // noop\n  }\n\n  function setLast(uint earned, uint lost) external {\n    lastEarned = earned;\n    lastLost = lost;\n  }\n\n  function setSlippage(uint value) external {\n    slippage = value;\n  }\n\n  function setSlippageDeposit(uint value) external {\n    slippageDeposit = value;\n  }\n\n  function setSlippageHardWork(uint value) external {\n    hardWorkSlippage = value;\n  }\n\n  function setReady(bool value) external {\n    isReadyToHardWork = value;\n  }\n\n  function setCompoundRatioManual(uint ratio) external {\n    compoundRatio = ratio;\n  }\n\n  function setBaseAmount(address asset_, uint amount_) external {\n    baseAmounts[asset_] = amount_;\n  }\n\n  /// @notice Max amount that can be deposited to the strategy, see SCB-593\n  function capacity() external view override returns (uint) {\n    return _capacity;\n  }\n\n  function setCapacity(uint capacity_) external {\n    _capacity = capacity_;\n  }\n\n  function setTotalAssetsDelta(int totalAssetsDelta_) external {\n    _totalAssetsDelta = totalAssetsDelta_;\n  }\n\n\n  ////////////////////////////////////////////////////////\n  ///           Access to internal functions\n  ////////////////////////////////////////////////////////\n  function checkWithdrawImpactAccessForTests(\n    address _asset,\n    uint balanceBefore,\n    uint investedAssetsUSD,\n    uint assetPrice,\n    address _splitter\n  ) external view returns (uint balance) {\n    return StrategyLib.checkWithdrawImpact(_asset, balanceBefore, investedAssetsUSD, assetPrice, _splitter);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockStrategySimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../proxy/ControllableV3.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract MockStrategySimple is ControllableV3, IStrategyV2 {\n\n  string public constant override NAME = \"mock strategy\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  address public override splitter;\n  address public override asset;\n  bool public override isReadyToHardWork;\n  uint public override compoundRatio;\n\n  uint internal slippage;\n  uint internal lastEarned;\n  uint internal lastLost;\n\n  uint internal _capacity;\n  address public override performanceReceiver;\n  uint public override performanceFee;\n\n  function init(\n    address controller_,\n    address _splitter,\n    address _asset\n  ) external initializer {\n    __Controllable_init(controller_);\n    splitter = _splitter;\n    asset = _asset;\n    isReadyToHardWork = true;\n    _capacity = type(uint).max; // unlimited capacity by default\n    performanceReceiver = IController(controller_).governance();\n    performanceFee = 10_000;\n  }\n\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  function withdrawAllToSplitter() external override returns (int totalAssetsDelta) {\n    return withdrawToSplitter(totalAssets());\n  }\n\n  function withdrawToSplitter(uint amount) public override returns (int totalAssetsDelta) {\n    uint _slippage = amount * slippage / 100;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n    IERC20(asset).transfer(splitter, amount - _slippage);\n    return 0;\n  }\n\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external pure override returns (\n    int totalAssetsDelta\n  ) {\n    amount_; // hide warning\n    updateTotalAssetsBeforeInvest_; // hide warning\n    // noop\n    return totalAssetsDelta;\n  }\n\n  function doHardWork() external view override returns (uint earned, uint lost) {\n    return (lastEarned, lastLost);\n  }\n\n  function setLast(uint earned, uint lost) external {\n    lastEarned = earned;\n    lastLost = lost;\n  }\n\n  function setSlippage(uint value) external {\n    slippage = value;\n  }\n\n  function setCompoundRatio(uint value) external override {\n    compoundRatio = value;\n  }\n\n  /// @notice Max amount that can be deposited to the strategy, see SCB-593\n  function capacity() external view override returns (uint) {\n    return _capacity;\n  }\n\n  function setCapacity(uint capacity_) external {\n    _capacity = capacity_;\n  }\n\n  /// @notice Set performance fee and receiver\n  function setupPerformanceFee(uint fee_, address receiver_) external {\n    performanceFee = fee_;\n    performanceReceiver = receiver_;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC20Upgradeable.sol\";\n\ncontract MockToken is ERC20Upgradeable {\n\n  uint8 internal _decimals;\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  )  {\n    _init(name_, symbol_, decimals_);\n  }\n\n  function _init(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) internal initializer {\n    __ERC20_init(name_, symbol_);\n    _decimals = decimals_;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  function mint(address to, uint amount) external {\n    _mint(to, amount);\n  }\n\n  function burn(address from, uint amount) external {\n    _burn(from, amount);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n////// /nix/store/im7ll7dx8gsw2da9k5xwbf8pbjfli2hc-multicall-df1e59d/src/Multicall.sol\n/* pragma solidity >=0.5.0; */\n/* pragma experimental ABIEncoderV2; */\n\n/// @title Multicall - Aggregate results from multiple read-only function calls\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\ncontract Multicall {\n  struct Call {\n    address target;\n    bytes callData;\n  }\n\n  function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\n    blockNumber = block.number;\n    returnData = new bytes[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n      require(success);\n      returnData[i] = ret;\n    }\n  }\n\n  // Helper functions\n  function getEthBalance(address addr) public view returns (uint256 balance) {\n    balance = addr.balance;\n  }\n\n  function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n    blockHash = blockhash(blockNumber);\n  }\n\n  function getLastBlockHash() public view returns (bytes32 blockHash) {\n    blockHash = blockhash(block.number - 1);\n  }\n\n  function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n    timestamp = block.timestamp;\n  }\n\n  function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n    difficulty = block.difficulty;\n  }\n\n  function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n    gaslimit = block.gaslimit;\n  }\n\n  function getCurrentBlockCoinbase() public view returns (address coinbase) {\n    coinbase = block.coinbase;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/tools/TetuERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC165.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\n/// @author bogdoslav\nabstract contract TetuERC165 is ERC165 {\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        HELPER FUNCTIONS\n  // *************************************************************\n  /// @author bogdoslav\n\n  /// @dev Checks what interface with id is supported by contract.\n  /// @return bool. Do not throws\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\n      return isSupported;\n    } catch {\n    }\n    return false;\n  }\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\n    require(_isInterfaceSupported(contractAddress, interfaceId), \"Interface is not supported\");\n  }\n\n  /// @dev Checks what address is ERC20.\n  /// @return bool. Do not throws\n  function _isERC20(address contractAddress) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    bool totalSupplySupported;\n    try IERC20(contractAddress).totalSupply() returns (uint) {\n      totalSupplySupported = true;\n    } catch {\n    }\n\n    bool balanceSupported;\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\n      balanceSupported = true;\n    } catch {\n    }\n\n    return totalSupplySupported && balanceSupported;\n  }\n\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireERC20(address contractAddress) internal view {\n    require(_isERC20(contractAddress), \"Not ERC20\");\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC20Permit.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../interfaces/IERC4626.sol\";\nimport \"../lib/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author belbix - adopted to proxy pattern + added ReentrancyGuard\n/// @author AlehNat - removed upgradeable logic\nabstract contract ERC4626 is ERC20Permit, ReentrancyGuard, IERC4626 {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n\n  /// @dev The address of the underlying token used for the Vault uses for accounting,\n  ///      depositing, and withdrawing\n  IERC20 internal _asset;\n\n  constructor(\n    IERC20 asset_,\n    string memory _name,\n    string memory _symbol\n  ) ERC20(_name, _symbol) ERC20Permit(_name) {\n    _asset = asset_;\n  }\n\n\n  function decimals() public view override(IERC20Metadata, ERC20) returns (uint8) {\n    return IERC20Metadata(address(_asset)).decimals();\n  }\n\n  function asset() external view override returns (address) {\n    return address(_asset);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //             DEPOSIT/WITHDRAWAL LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n  /// @dev Mints vault shares to receiver by depositing exactly amount of assets.\n  function deposit(\n    uint assets,\n    address receiver\n  ) public nonReentrant virtual override returns (uint shares) {\n    require(assets <= maxDeposit(receiver), \"MAX\");\n\n    shares = previewDeposit(assets);\n    // Check for rounding error since we round down in previewDeposit.\n    require(shares != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function mint(\n    uint shares,\n    address receiver\n  ) public nonReentrant virtual override returns (uint assets) {\n    require(shares <= maxMint(receiver), \"MAX\");\n\n    assets = previewMint(shares);\n    // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function withdraw(\n    uint assets,\n    address receiver,\n    address owner\n  ) public nonReentrant virtual override returns (uint shares) {\n    require(assets <= maxWithdraw(owner), \"MAX\");\n\n    shares = previewWithdraw(assets);\n    // No need to check for rounding error, previewWithdraw rounds up.\n\n    if (msg.sender != owner) {\n      uint allowed = _allowances[owner][msg.sender];\n      // Saves gas for limited approvals.\n      if (allowed != type(uint).max) _allowances[owner][msg.sender] = allowed - shares;\n    }\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset.safeTransfer(receiver, assets);\n  }\n\n  /// @dev Redeems shares from owner and sends assets to receiver.\n  function redeem(\n    uint shares,\n    address receiver,\n    address owner\n  ) public nonReentrant virtual override returns (uint assets) {\n    require(shares <= maxRedeem(owner), \"MAX\");\n\n    if (msg.sender != owner) {\n      uint allowed = _allowances[owner][msg.sender];\n      // Saves gas for limited approvals.\n      if (allowed != type(uint).max) _allowances[owner][msg.sender] = allowed - shares;\n    }\n\n    assets = previewRedeem(shares);\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset.safeTransfer(receiver, assets);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //                  ACCOUNTING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n  /// @dev Total amount of the underlying asset that is “managed” by Vault\n  function totalAssets() public view virtual override returns (uint);\n\n  function convertToShares(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n  }\n\n  function convertToAssets(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n  }\n\n  function previewDeposit(uint assets) public view virtual override returns (uint) {\n    return convertToShares(assets);\n  }\n\n  function previewMint(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n  }\n\n  function previewWithdraw(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n  }\n\n  function previewRedeem(uint shares) public view virtual override returns (uint) {\n    return convertToAssets(shares);\n  }\n\n  ///////////////////////////////////////////////////////////////\n  //           DEPOSIT/WITHDRAWAL LIMIT LOGIC\n  ///////////////////////////////////////////////////////////////\n\n  function maxDeposit(address) public view virtual override returns (uint) {\n    return type(uint).max - 1;\n  }\n\n  function maxMint(address) public view virtual override returns (uint) {\n    return type(uint).max - 1;\n  }\n\n  function maxWithdraw(address owner) public view virtual override returns (uint) {\n    return convertToAssets(balanceOf(owner));\n  }\n\n  function maxRedeem(address owner) public view virtual override returns (uint) {\n    return balanceOf(owner);\n  }\n\n  ///////////////////////////////////////////////////////////////\n  //                INTERNAL HOOKS LOGIC\n  ///////////////////////////////////////////////////////////////\n\n  function beforeWithdraw(uint assets, uint shares) internal virtual {}\n\n  function afterDeposit(uint assets, uint shares) internal virtual {}\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/ERC4626Strict.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./ERC4626.sol\";\nimport \"../interfaces/IStrategyStrict.sol\";\nimport \"../tools/TetuERC165.sol\";\n\ncontract ERC4626Strict is ERC4626, TetuERC165 {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VAULT_VERSION = \"1.0.0\";\n  /// @dev Denominator for buffer calculation. 100% of the buffer amount.\n  uint constant public BUFFER_DENOMINATOR = 100_000;\n\n  // *************************************************************\n  //                        VARIABLES\n  // *************************************************************\n\n  /// @dev Connected strategy. Can not be changed.\n  IStrategyStrict public immutable strategy;\n  /// @dev Percent of assets that will always stay in this vault.\n  uint public immutable buffer;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Invest(address splitter, uint amount);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  constructor(\n    IERC20 asset_,\n    string memory _name,\n    string memory _symbol,\n    address _strategy,\n    uint _buffer\n  ) ERC4626(asset_, _name, _symbol){\n    // buffer is 5% max\n    require(_buffer <= BUFFER_DENOMINATOR / 20, \"!BUFFER\");\n    _requireERC20(address(asset_));\n    buffer = _buffer;\n    _requireInterface(_strategy, InterfaceIds.I_STRATEGY_STRICT);\n    strategy = IStrategyStrict(_strategy);\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of the underlying asset that is “managed” by Vault\n  function totalAssets() public view override returns (uint) {\n    return _asset.balanceOf(address(this)) + strategy.totalAssets();\n  }\n\n  /// @dev Amount of assets under control of strategy.\n  function strategyAssets() external view returns (uint) {\n    return strategy.totalAssets();\n  }\n\n  /// @dev Price of 1 full share\n  function sharePrice() external view returns (uint) {\n    uint units = 10 ** uint256(decimals());\n    uint totalSupply_ = totalSupply();\n    return totalSupply_ == 0\n    ? units\n    : units * totalAssets() / totalSupply_;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_ERC4626 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                 DEPOSIT LOGIC\n  // *************************************************************\n\n  /// @dev Calculate available to invest amount and send this amount to strategy\n  function afterDeposit(uint /*assets*/, uint /*shares*/) internal override {\n    IStrategyStrict _strategy = strategy;\n    IERC20 asset_ = _asset;\n\n    uint256 toInvest = _availableToInvest(_strategy, asset_);\n    // invest only when buffer is filled\n    if (toInvest > 0) {\n      asset_.safeTransfer(address(_strategy), toInvest);\n      _strategy.investAll();\n      emit Invest(address(_strategy), toInvest);\n    }\n  }\n\n  /// @notice Returns amount of assets ready to invest to the strategy\n  function _availableToInvest(IStrategyStrict _strategy, IERC20 asset_) internal view returns (uint) {\n    uint _buffer = buffer;\n    uint assetsInVault = asset_.balanceOf(address(this));\n    uint assetsInStrategy = _strategy.totalAssets();\n    uint wantInvestTotal = (assetsInVault + assetsInStrategy)\n    * (BUFFER_DENOMINATOR - _buffer) / BUFFER_DENOMINATOR;\n    if (assetsInStrategy >= wantInvestTotal) {\n      return 0;\n    } else {\n      uint remainingToInvest = wantInvestTotal - assetsInStrategy;\n      return remainingToInvest <= assetsInVault ? remainingToInvest : assetsInVault;\n    }\n  }\n\n\n  // *************************************************************\n  //                 WITHDRAW LOGIC\n  // *************************************************************\n\n  /// @dev Withdraw all available shares for tx sender.\n  ///      The revert is expected if the balance is higher than `maxRedeem`\n  ///      It suppose to be used only on UI - for on-chain interactions withdraw concrete amount with properly checks.\n  function withdrawAll() external {\n    redeem(balanceOf(msg.sender), msg.sender, msg.sender);\n  }\n\n  /// @dev Internal hook for getting necessary assets from strategy.\n  function beforeWithdraw(uint assets, uint shares) internal override {\n    uint balance = _asset.balanceOf(address(this));\n    // if not enough balance in the vault withdraw from strategies\n    if (balance < assets) {\n      _processWithdrawFromStrategy(\n        assets,\n        shares,\n        totalSupply(),\n        buffer,\n        strategy,\n        balance\n      );\n    }\n  }\n\n  /// @dev Do necessary calculation for withdrawing from strategy and move assets to vault.\n  function _processWithdrawFromStrategy(\n    uint assetsNeed,\n    uint shares,\n    uint totalSupply_,\n    uint _buffer,\n    IStrategyStrict _strategy,\n    uint assetsInVault\n  ) internal {\n    // withdraw everything from the strategy to accurately check the share value\n    if (shares == totalSupply_) {\n      _strategy.withdrawAllToVault();\n    } else {\n      uint assetsInStrategy = _strategy.totalAssets();\n\n      // we should always have buffer amount inside the vault\n      // assume `assetsNeed` can not be higher than entire balance\n      uint expectedBuffer = (assetsInStrategy + assetsInVault - assetsNeed) * _buffer / BUFFER_DENOMINATOR;\n\n      // this code should not be called if `assetsInVault` higher than `assetsNeed`\n      uint missing = Math.min(expectedBuffer + assetsNeed - assetsInVault, assetsInStrategy);\n      // if zero should be resolved on strategy side\n      _strategy.withdrawToVault(missing);\n    }\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC20PermitUpgradeable.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../interfaces/IERC4626.sol\";\nimport \"../lib/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author belbix - adopted to proxy pattern + added ReentrancyGuard\nabstract contract ERC4626Upgradeable is ERC20PermitUpgradeable, ReentrancyGuard, IERC4626 {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n\n  /// @dev The address of the underlying token used for the Vault uses for accounting,\n  ///      depositing, and withdrawing\n  IERC20 internal _asset;\n\n  function __ERC4626_init(\n    IERC20 asset_,\n    string memory _name,\n    string memory _symbol\n  ) internal onlyInitializing {\n    __ERC20_init(_name, _symbol);\n    _asset = asset_;\n  }\n\n  function decimals() public view override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {\n    return IERC20Metadata(address(_asset)).decimals();\n  }\n\n  function asset() external view override returns (address) {\n    return address(_asset);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //             DEPOSIT/WITHDRAWAL LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n  /// @dev Mints vault shares to receiver by depositing exactly amount of assets.\n  function deposit(\n    uint assets,\n    address receiver\n  ) public nonReentrant virtual override returns (uint shares) {\n    require(assets <= maxDeposit(receiver), \"MAX\");\n\n    shares = previewDeposit(assets);\n    // Check for rounding error since we round down in previewDeposit.\n    require(shares != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function mint(\n    uint shares,\n    address receiver\n  ) public nonReentrant virtual override returns (uint assets) {\n    require(shares <= maxMint(receiver), \"MAX\");\n\n    assets = previewMint(shares);\n    // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function withdraw(\n    uint assets,\n    address receiver,\n    address owner\n  ) public nonReentrant virtual override returns (uint shares) {\n    require(assets <= maxWithdraw(owner), \"MAX\");\n\n    shares = previewWithdraw(assets);\n    // No need to check for rounding error, previewWithdraw rounds up.\n\n    if (msg.sender != owner) {\n      uint allowed = _allowances[owner][msg.sender];\n      // Saves gas for limited approvals.\n      if (allowed != type(uint).max) _allowances[owner][msg.sender] = allowed - shares;\n    }\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset.safeTransfer(receiver, assets);\n  }\n\n  /// @dev Redeems shares from owner and sends assets to receiver.\n  function redeem(\n    uint shares,\n    address receiver,\n    address owner\n  ) public nonReentrant virtual override returns (uint assets) {\n    require(shares <= maxRedeem(owner), \"MAX\");\n\n    if (msg.sender != owner) {\n      uint allowed = _allowances[owner][msg.sender];\n      // Saves gas for limited approvals.\n      if (allowed != type(uint).max) _allowances[owner][msg.sender] = allowed - shares;\n    }\n\n    assets = previewRedeem(shares);\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset.safeTransfer(receiver, assets);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //                  ACCOUNTING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n  /// @dev Total amount of the underlying asset that is “managed” by Vault\n  function totalAssets() public view virtual override returns (uint);\n\n  function convertToShares(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n  }\n\n  function convertToAssets(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n  }\n\n  function previewDeposit(uint assets) public view virtual override returns (uint) {\n    return convertToShares(assets);\n  }\n\n  function previewMint(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n  }\n\n  function previewWithdraw(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n  }\n\n  function previewRedeem(uint shares) public view virtual override returns (uint) {\n    return convertToAssets(shares);\n  }\n\n  ///////////////////////////////////////////////////////////////\n  //           DEPOSIT/WITHDRAWAL LIMIT LOGIC\n  ///////////////////////////////////////////////////////////////\n\n  function maxDeposit(address) public view virtual override returns (uint) {\n    return type(uint).max - 1;\n  }\n\n  function maxMint(address) public view virtual override returns (uint) {\n    return type(uint).max - 1;\n  }\n\n  function maxWithdraw(address owner) public view virtual override returns (uint) {\n    return convertToAssets(balanceOf(owner));\n  }\n\n  function maxRedeem(address owner) public view virtual override returns (uint) {\n    return balanceOf(owner);\n  }\n\n  ///////////////////////////////////////////////////////////////\n  //                INTERNAL HOOKS LOGIC\n  ///////////////////////////////////////////////////////////////\n\n  function beforeWithdraw(uint assets, uint shares) internal virtual {}\n\n  function afterDeposit(uint assets, uint shares) internal virtual {}\n\n  /**\n * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[49] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/StrategySplitterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/EnumerableMap.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Proxy solution for connection a vault with multiple strategies\n///        Version 2 has auto-rebalance logic adopted to strategies with fees.\n/// @author belbix\ncontract StrategySplitterV2 is ControllableV3, ReentrancyGuard, ISplitter {\n  using SafeERC20 for IERC20;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n  // *********************************************\n  //                  CONSTANTS\n  // *********************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant SPLITTER_VERSION = \"2.0.3\";\n  /// @dev APR denominator. Represent 100% APR.\n  uint public constant APR_DENOMINATOR = 100_000;\n  /// @dev Delay between hardwork calls for a strategy.\n  uint public constant HARDWORK_DELAY = 12 hours;\n  /// @dev How much APR history elements will be counted in average APR calculation.\n  uint public constant HISTORY_DEEP = 3;\n  /// @dev Time lock for adding new strategies.\n  uint public constant TIME_LOCK = 18 hours;\n\n\n  // *********************************************\n  //                 VARIABLES\n  // *********************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Connected vault\n  address public override vault;\n  /// @dev Array of strategies under control\n  address[] public strategies;\n  /// @dev Paused strategies\n  mapping(address => bool) public pausedStrategies;\n  /// @dev Current strategies average APRs. Uses for deposit/withdraw ordering.\n  mapping(address => uint) public strategiesAPR;\n  /// @dev Strategies APR history. Uses for calculate average APR.\n  mapping(address => uint[]) public strategiesAPRHistory;\n  /// @dev Last strategies doHardWork call timestamp. Uses for calls delay.\n  mapping(address => uint) public lastHardWorks;\n  /// @dev Flag represents doHardWork call. Need for not call HW on deposit again in connected vault.\n  bool public override isHardWorking;\n  /// @dev Strategy => timestamp. Strategies scheduled for adding.\n  EnumerableMap.AddressToUintMap internal _scheduledStrategies;\n  /// @dev Changed to true after a strategy adding\n  bool internal inited;\n  /// @dev How much underlying can be invested to the strategy\n  mapping(address => uint) public strategyCapacity;\n\n  // *********************************************\n  //                  EVENTS\n  // *********************************************\n\n  event StrategyAdded(address strategy, uint apr);\n  event StrategyRemoved(address strategy);\n  event Rebalance(\n    address topStrategy,\n    address lowStrategy,\n    uint percent,\n    uint slippageTolerance,\n    uint slippage,\n    uint lowStrategyBalance\n  );\n  event HardWork(\n    address sender,\n    address strategy,\n    uint tvl,\n    uint earned,\n    uint lost,\n    uint apr,\n    uint avgApr\n  );\n  event StrategyScheduled(address strategy, uint startTime, uint timeLock);\n  event ScheduledStrategyRemove(address strategy);\n  event ManualAprChanged(address sender, address strategy, uint newApr, uint oldApr);\n  event Paused(address strategy, address sender);\n  event ContinueInvesting(address strategy, uint apr, address sender);\n  event Loss(address strategy, uint amount);\n  event Invested(address strategy, uint amount);\n  event WithdrawFromStrategy(address strategy);\n  event SetStrategyCapacity(address strategy, uint capacity);\n\n  // *********************************************\n  //                 INIT\n  // *********************************************\n\n  /// @dev Initialize contract after setup it as proxy implementation\n  function init(address controller_, address _asset, address _vault) external initializer override {\n    __Controllable_init(controller_);\n    _requireERC20(_asset);\n    asset = _asset;\n    _requireInterface(_vault, InterfaceIds.I_TETU_VAULT_V2);\n    vault = _vault;\n  }\n\n  // *********************************************\n  //                 RESTRICTIONS\n  // *********************************************\n\n  /// @dev Restrict access only for governance\n  function _onlyGov() internal view {\n    require(isGovernance(msg.sender), \"SS: Denied\");\n  }\n\n  /// @dev Restrict access only for operators\n  function _onlyOperators() internal view {\n    require(IController(controller()).isOperator(msg.sender), \"SS: Denied\");\n  }\n\n  /// @dev Restrict access only for vault\n  function _onlyVault() internal view {\n    require(msg.sender == vault, \"SS: Denied\");\n  }\n\n  /// @dev Restrict access only for operators or vault\n  function _onlyOperatorsOrVault() internal view {\n    require(msg.sender == vault || IController(controller()).isOperator(msg.sender), \"SS: Denied\");\n  }\n\n  // *********************************************\n  //                    VIEWS\n  // *********************************************\n\n  /// @dev Amount of underlying assets under control of splitter.\n  function totalAssets() public view override returns (uint256){\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    uint length = strategies.length;\n    for (uint i = 0; i < length; i++) {\n      balance += IStrategyV2(strategies[i]).totalAssets();\n    }\n    return balance;\n  }\n\n  /// @dev Return maximum available balance to withdraw without calling more than 1 strategy\n  function maxCheapWithdraw() external view returns (uint) {\n    address _asset = asset;\n    uint strategyBalance;\n    if (strategies.length != 0) {\n      strategyBalance = IStrategyV2(strategies[0]).totalAssets();\n    }\n    return strategyBalance + IERC20(_asset).balanceOf(address(this));\n  }\n\n  /// @dev Length of strategy array\n  function strategiesLength() external view returns (uint) {\n    return strategies.length;\n  }\n\n  /// @dev Returns strategy array\n  function allStrategies() external view returns (address[] memory) {\n    return strategies;\n  }\n\n  /// @dev Length of APR history for given strategy\n  function strategyAPRHistoryLength(address strategy) external view returns (uint) {\n    return strategiesAPRHistory[strategy].length;\n  }\n\n  /// @dev Return all scheduled strategies with start lock time.\n  function scheduledStrategies() external view returns (address[] memory _strategies, uint[] memory locks) {\n    uint length = _scheduledStrategies.length();\n    _strategies = new address[](length);\n    locks = new uint[](length);\n    for (uint i; i < length; ++i) {\n      (_strategies[i], locks[i]) = _scheduledStrategies.at(i);\n    }\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_SPLITTER || super.supportsInterface(interfaceId);\n  }\n\n  // *********************************************\n  //                GOV ACTIONS\n  // *********************************************\n\n  /// @dev Schedule strategy for adding in the splitter.\n  ///      Not inited splitter(without strategies) not require scheduling.\n  function scheduleStrategies(address[] memory _strategies) external {\n    _onlyGov();\n\n    for (uint i; i < _strategies.length; i++) {\n      require(_scheduledStrategies.set(_strategies[i], block.timestamp), \"SS: Exist\");\n      emit StrategyScheduled(_strategies[i], block.timestamp, TIME_LOCK);\n    }\n  }\n\n  /// @dev Remove scheduled strategies.\n  function removeScheduledStrategies(address[] memory _strategies) external {\n    _onlyGov();\n\n    for (uint i; i < _strategies.length; i++) {\n      require(_scheduledStrategies.remove(_strategies[i]), \"SS: Not exist\");\n      emit ScheduledStrategyRemove(_strategies[i]);\n    }\n  }\n\n  /// @dev Add new managed strategy. Should be an uniq address.\n  ///      Strategy should have the same underlying asset with current contract.\n  function addStrategies(address[] memory _strategies, uint[] memory expectedAPR) external {\n    // only initial action will require strict access\n    // already scheduled strategies can be added by anyone\n    require(_strategies.length == expectedAPR.length, \"WRONG_INPUT\");\n\n    bool _inited = inited;\n    address[] memory existStrategies = strategies;\n    address[] memory addedStrategies = new address[](_strategies.length);\n    for (uint i = 0; i < _strategies.length; i++) {\n      address strategy = _strategies[i];\n      uint apr = expectedAPR[i];\n\n      // --- restrictions ----------\n\n      require(IStrategyV2(strategy).asset() == asset, \"SS: Wrong asset\");\n      require(IStrategyV2(strategy).splitter() == address(this), \"SS: Wrong splitter\");\n      require(IControllable(strategy).isController(controller()), \"SS: Wrong controller\");\n      require(!_contains(existStrategies, strategy), \"SS: Already exist\");\n      require(!_contains(addedStrategies, strategy), \"SS: Duplicate\");\n      require(IProxyControlled(strategy).implementation() != address(0), \"SS: Wrong proxy\");\n      // allow add strategies without time lock only for the fist call (assume the splitter is new)\n      if (_inited) {\n        (bool found, uint startTime) = _scheduledStrategies.tryGet(strategy);\n        require(found && startTime != 0 && startTime + TIME_LOCK < block.timestamp, \"SS: Time lock\");\n        _scheduledStrategies.remove(strategy);\n      } else {\n        // only initial action requires strict access\n        _onlyGov();\n      }\n      // ----------------------------\n\n      strategies.push(strategy);\n      _setStrategyAPR(strategy, apr);\n      addedStrategies[i] = strategy;\n      lastHardWorks[strategy] = block.timestamp;\n      emit StrategyAdded(strategy, apr);\n    }\n    _sortStrategiesByAPR();\n    if (!_inited) {\n      inited = true;\n    }\n  }\n\n  /// @dev Remove given strategy, reset APR and withdraw all underlying to this contract\n  function removeStrategies(address[] memory strategies_) external {\n    _onlyGov();\n\n    for (uint i = 0; i < strategies_.length; i++) {\n      _removeStrategy(strategies_[i]);\n    }\n    _sortStrategiesByAPR();\n  }\n\n  function _removeStrategy(address strategy) internal {\n    uint length = strategies.length;\n    require(length > 0, \"SS: Empty strategies\");\n    uint idx;\n    bool found;\n    for (uint256 i = 0; i < length; i++) {\n      if (strategies[i] == strategy) {\n        idx = i;\n        found = true;\n        break;\n      }\n    }\n    require(found, \"SS: Strategy not found\");\n    if (length > 1) {\n      strategies[idx] = strategies[length - 1];\n    }\n    strategies.pop();\n\n    _setStrategyAPR(strategy, 0);\n\n    // for expensive strategies should be called before removing\n    IStrategyV2(strategy).withdrawAllToSplitter();\n    emit StrategyRemoved(strategy);\n  }\n\n  /// @dev Withdraw some percent from strategy with lowest APR and deposit to strategy with highest APR.\n  ///      Strict access because possible losses during deposit/withdraw.\n  /// @param percent Range of 1-100\n  /// @param slippageTolerance Range of 0-100_000\n  function rebalance(uint percent, uint slippageTolerance) external {\n    _onlyGov();\n\n    uint balance = totalAssets();\n    uint length = strategies.length;\n    require(length > 1, \"SS: Length\");\n    require(percent <= 100, \"SS: Percent\");\n\n\n    address lowStrategy;\n\n    uint lowStrategyBalance;\n    for (uint i = length; i > 1; i--) {\n      lowStrategy = strategies[i - 1];\n      lowStrategyBalance = IStrategyV2(lowStrategy).totalAssets();\n      if (lowStrategyBalance == 0) {\n        continue;\n      }\n      break;\n    }\n    require(lowStrategyBalance != 0, \"SS: No strategies\");\n\n    int totalAssetsDelta = (percent == 100)\n      ? IStrategyV2(lowStrategy).withdrawAllToSplitter()\n      : IStrategyV2(lowStrategy).withdrawToSplitter(lowStrategyBalance * percent / 100);\n    if (totalAssetsDelta != 0) {\n      balance = _fixTotalAssets(balance, totalAssetsDelta);\n    }\n    uint balanceAfterWithdraw = totalAssets();\n\n    (address topStrategy,) = _investToTopStrategy(\n      false // we assume here, that total-assets-amount of the strategy was just updated in withdraw above\n    );\n\n    uint balanceAfterInvest = totalAssets();\n    uint slippage;\n    // slippage for withdraw\n    if (balanceAfterWithdraw < balance) {\n      uint loss = balance - balanceAfterWithdraw;\n      ITetuVaultV2(vault).coverLoss(loss);\n      emit Loss(lowStrategy, loss);\n      slippage = loss * 100_000 / balance;\n      require(slippage <= slippageTolerance, \"SS: Slippage withdraw\");\n    }\n    // slippage for invest\n    if (balanceAfterInvest < balanceAfterWithdraw) {\n      uint loss = balanceAfterWithdraw - balanceAfterInvest;\n      ITetuVaultV2(vault).coverLoss(loss);\n      emit Loss(topStrategy, loss);\n      slippage += loss * 100_000 / balanceAfterWithdraw;\n      require(slippage <= slippageTolerance, \"SS: Slippage deposit\");\n    }\n\n    emit Rebalance(\n      topStrategy,\n      lowStrategy,\n      percent,\n      slippageTolerance,\n      slippage,\n      lowStrategyBalance\n    );\n  }\n\n  // *********************************************\n  //                OPERATOR ACTIONS\n  // *********************************************\n\n  function setAPRs(address[] memory _strategies, uint[] memory aprs) external {\n    _onlyOperators();\n    require(_strategies.length == aprs.length, \"WRONG_INPUT\");\n    for (uint i; i < aprs.length; i++) {\n      address strategy = _strategies[i];\n      require(!pausedStrategies[strategy], \"SS: Paused\");\n      uint oldAPR = strategiesAPR[strategy];\n      _setStrategyAPR(strategy, aprs[i]);\n      emit ManualAprChanged(msg.sender, strategy, aprs[i], oldAPR);\n    }\n    _sortStrategiesByAPR();\n  }\n\n  /// @dev Pause investing. For withdraw need to call emergencyExit() on the strategy.\n  function pauseInvesting(address strategy) external {\n    _onlyOperators();\n    require(!pausedStrategies[strategy], \"SS: Paused\");\n\n    pausedStrategies[strategy] = true;\n    uint oldAPR = strategiesAPR[strategy];\n    _setStrategyAPR(strategy, 0);\n    _sortStrategiesByAPR();\n    emit ManualAprChanged(msg.sender, strategy, 0, oldAPR);\n    emit Paused(strategy, msg.sender);\n  }\n\n  /// @dev Resumes the ability to invest for given strategy.\n  function continueInvesting(address strategy, uint apr) external {\n    _onlyOperators();\n    require(pausedStrategies[strategy], \"SS: Not paused\");\n\n    pausedStrategies[strategy] = false;\n    _setStrategyAPR(strategy, apr);\n    _sortStrategiesByAPR();\n    emit ManualAprChanged(msg.sender, strategy, apr, 0);\n    emit ContinueInvesting(strategy, apr, msg.sender);\n  }\n\n  function setStrategyCapacity(address strategy, uint capacity) external {\n    _onlyOperators();\n    strategyCapacity[strategy] = capacity;\n    emit SetStrategyCapacity(strategy, capacity);\n  }\n\n  // *********************************************\n  //                VAULT ACTIONS\n  // *********************************************\n\n  /// @dev Invest to the first strategy in the array. Assume this strategy has highest APR.\n  function investAll() external override {\n    _onlyVault();\n\n    if (strategies.length != 0) {\n      // calculate total-assets of all strategies\n      uint totalAssetsBefore = totalAssets();\n\n      (address strategy, int totalAssetsDelta) = _investToTopStrategy(true);\n      if (totalAssetsDelta != 0) {\n        totalAssetsBefore = _fixTotalAssets(totalAssetsBefore, totalAssetsDelta);\n      }\n\n      uint totalAssetsAfter = totalAssets();\n      if (totalAssetsAfter < totalAssetsBefore) {\n        ITetuVaultV2(msg.sender).coverLoss(totalAssetsBefore - totalAssetsAfter);\n        emit Loss(strategy, totalAssetsBefore - totalAssetsAfter);\n      }\n    }\n  }\n\n  /// @dev Try to withdraw all from all strategies. May be too expensive to handle in one tx.\n  function withdrawAllToVault() external override {\n    _onlyVault();\n\n    address _asset = asset;\n    uint balance = totalAssets();\n    uint balanceBefore = balance;\n    uint balanceAfter;\n    uint totalLoss;\n\n    uint length = strategies.length;\n    for (uint i = 0; i < length; i++) {\n      int totalAssetsDelta = IStrategyV2(strategies[i]).withdrawAllToSplitter();\n      emit WithdrawFromStrategy(strategies[i]);\n      if (totalAssetsDelta != 0) {\n        balanceBefore = _fixTotalAssets(balanceBefore, totalAssetsDelta);\n      }\n\n      // register possible loses\n      balanceAfter = totalAssets();\n      if (balanceAfter < balanceBefore) {\n        emit Loss(strategies[i], balanceBefore - balanceAfter);\n        totalLoss += balanceBefore - balanceAfter;\n      }\n      balanceBefore = balanceAfter;\n    }\n\n    balanceAfter = IERC20(_asset).balanceOf(address(this));\n\n    address _vault = vault;\n    // if we withdrew less than expected try to cover loss from vault insurance\n    if (totalLoss != 0) {\n      ITetuVaultV2(_vault).coverLoss(totalLoss);\n    }\n\n    if (balanceAfter > 0) {\n      IERC20(_asset).safeTransfer(_vault, balanceAfter);\n    }\n  }\n\n  /// @dev Cascade withdraw from strategies start from lower APR until reach the target amount.\n  ///      For large amounts with multiple strategies may not be possible to process this function.\n  function withdrawToVault(uint256 amount) external override {\n    _onlyVault();\n\n    uint totalLoss;\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (balance < amount) {\n      uint remainingAmount = amount - balance;\n      uint length = strategies.length;\n      for (uint i = length; i > 0; i--) {\n        IStrategyV2 strategy = IStrategyV2(strategies[i - 1]);\n\n        uint strategyBalance = strategy.totalAssets();\n        uint balanceBefore = strategyBalance + balance;\n\n        // withdraw from strategy\n        int totalAssetsDelta = (strategyBalance <= remainingAmount)\n          ? strategy.withdrawAllToSplitter()\n          : strategy.withdrawToSplitter(remainingAmount);\n        if (totalAssetsDelta != 0) {\n          balanceBefore = _fixTotalAssets(balanceBefore, totalAssetsDelta);\n        }\n        emit WithdrawFromStrategy(address(strategy));\n\n        uint currentBalance = IERC20(_asset).balanceOf(address(this));\n        // assume that we can not decrease splitter balance during withdraw process\n        uint withdrew = currentBalance - balance;\n        balance = currentBalance;\n\n        remainingAmount = withdrew <= remainingAmount ? remainingAmount - withdrew : 0;\n\n        uint balanceAfter = strategy.totalAssets() + balance;\n\n        // register loss\n        if (balanceAfter < balanceBefore) {\n          emit Loss(address(strategy), balanceBefore - balanceAfter);\n          totalLoss += balanceBefore - balanceAfter;\n        }\n\n        if (balance >= amount) {\n          break;\n        }\n      }\n    }\n\n    address _vault = vault;\n    // if we withdrew less than expected try to cover loss from vault insurance\n    if (totalLoss != 0) {\n      ITetuVaultV2(_vault).coverLoss(totalLoss);\n    }\n\n    if (balance != 0) {\n      IERC20(_asset).safeTransfer(_vault, Math.min(amount, balance));\n    }\n  }\n\n  /// @notice Calculate totalAssets-before-deposit/withdraw as {totalAssets_} + {delta}\n  ///         Insurance covers losses during deposit/withdraw but doesn't cover losses because of price changes.\n  ///         The selected strategy updates totalAssets before the depositing/withdrawing,\n  ///         we need to use updated value to calculate the losses.\n  ///             Looses-to-cover = [totalAssets-after-deposit/withdraw - totalAssets-before-deposit/withdraw]\n  /// @param totalAssets_ totalAssets-before-call-of-deposit/withdraw-function\n  /// @param delta_ [totalAssets-before-deposit/withdraw - totalAssets-before-call-of-deposit/withdraw-function]\n  /// @return totalAssetsOut totalAssets-before-deposit/withdraw\n  function _fixTotalAssets(uint totalAssets_, int delta_) internal pure returns (uint totalAssetsOut) {\n    if (delta_ > 0) {\n      totalAssetsOut = totalAssets_ + uint(delta_);\n    } else {\n      require(totalAssets_ >= uint(- delta_), \"SS: patch\"); // protection from mistakes in strategy\n      totalAssetsOut = totalAssets_ - uint(- delta_);\n    }\n  }\n\n  // *********************************************\n  //                HARD WORKS\n  // *********************************************\n\n  /// @dev Call hard works for all strategies.\n  function doHardWork() external override {\n    _onlyOperatorsOrVault();\n\n    // prevent recursion\n    isHardWorking = true;\n    uint length = strategies.length;\n    bool needReorder;\n    for (uint i = 0; i < length; i++) {\n      bool result = _doHardWorkForStrategy(strategies[i], false);\n      if (result) {\n        needReorder = true;\n      }\n    }\n    if (needReorder) {\n      _sortStrategiesByAPR();\n    }\n    isHardWorking = false;\n  }\n\n  /// @dev Call hard work for given strategy.\n  function doHardWorkForStrategy(address strategy, bool push) external {\n    _onlyOperators();\n\n    // prevent recursion\n    isHardWorking = true;\n    bool result = _doHardWorkForStrategy(strategy, push);\n    if (result) {\n      _sortStrategiesByAPR();\n    }\n    isHardWorking = false;\n  }\n\n  function _doHardWorkForStrategy(address strategy, bool push) internal returns (bool) {\n    uint lastHardWork = lastHardWorks[strategy];\n\n    if (\n      (\n      lastHardWork + HARDWORK_DELAY < block.timestamp\n      && IStrategyV2(strategy).isReadyToHardWork()\n      && !pausedStrategies[strategy]\n      )\n      || push\n    ) {\n      uint sinceLastHardWork = block.timestamp - lastHardWork;\n      uint tvl = IStrategyV2(strategy).totalAssets();\n      if (tvl != 0) {\n        (uint earned, uint lost) = IStrategyV2(strategy).doHardWork();\n        uint apr;\n        if (earned > lost) {\n          apr = computeApr(tvl, earned - lost, sinceLastHardWork);\n        }\n        uint lostForCovering = lost > earned ? lost - earned : 0;\n        if (lostForCovering > 0) {\n          ITetuVaultV2(vault).coverLoss(lostForCovering);\n        }\n\n        strategiesAPRHistory[strategy].push(apr);\n        uint avgApr = averageApr(strategy);\n        strategiesAPR[strategy] = avgApr;\n        lastHardWorks[strategy] = block.timestamp;\n\n        emit HardWork(\n          msg.sender,\n          strategy,\n          tvl,\n          earned,\n          lost,\n          apr,\n          avgApr\n        );\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function averageApr(address strategy) public view returns (uint) {\n    uint[] storage history = strategiesAPRHistory[strategy];\n    uint aprSum;\n    uint length = history.length;\n    uint count = Math.min(HISTORY_DEEP, length);\n    if (count != 0) {\n      for (uint i; i < count; i++) {\n        aprSum += history[length - i - 1];\n      }\n      return aprSum / count;\n    }\n    return 0;\n  }\n\n  /// @dev https://www.investopedia.com/terms/a/apr.asp\n  ///      TVL and rewards should be in the same currency and with the same decimals\n  function computeApr(uint tvl, uint earned, uint duration) public pure returns (uint) {\n    if (tvl == 0 || duration == 0) {\n      return 0;\n    }\n    return earned * 1e18 * APR_DENOMINATOR * uint(365) / tvl / (duration * 1e18 / 1 days);\n  }\n\n  /// @dev Insertion sorting algorithm for using with arrays fewer than 10 elements.\n  ///      Based on https://medium.com/coinmonks/sorting-in-solidity-without-comparison-4eb47e04ff0d\n  ///      Sort strategies array by APR values from strategiesAPR map. Highest to lowest.\n  function _sortStrategiesByAPR() internal {\n  unchecked {\n    uint length = strategies.length;\n    for (uint i = 1; i < length; i++) {\n      address key = strategies[i];\n      uint j = i - 1;\n      while ((int(j) >= 0) && strategiesAPR[strategies[j]] < strategiesAPR[key]) {\n        strategies[j + 1] = strategies[j];\n        j--;\n      }\n      strategies[j + 1] = key;\n    }\n  }\n  }\n\n  /// @dev Return true if given item found in address array\n  function _contains(address[] memory array, address _item) internal pure returns (bool) {\n    for (uint256 i = 0; i < array.length; i++) {\n      if (array[i] == _item) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _setStrategyAPR(address strategy, uint apr) internal {\n    strategiesAPR[strategy] = apr;\n    // need to override last values of history for properly calculate average apr\n    for (uint i; i < HISTORY_DEEP; i++) {\n      strategiesAPRHistory[strategy].push(apr);\n    }\n  }\n\n  /// @param updateTotalAssetsBeforeInvest TotalAssets of strategy should be updated before investing.\n  ///                                      The increment of {TotalAssets} should be returned as {totalAssetsDelta}\n  /// @return strategy Selected strategy or zero\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function _investToTopStrategy(\n    bool updateTotalAssetsBeforeInvest\n  ) internal returns (\n    address strategy,\n    int totalAssetsDelta\n  ) {\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    // no actions for zero balance, return empty strategy\n    if (balance != 0) {\n      uint length = strategies.length;\n      for (uint i; i < length; ++i) {\n        strategy = strategies[i];\n        if (pausedStrategies[strategy]) {\n          continue;\n        }\n\n        // There are strategy capacities of two kinds: external (from splitter) and internal (from strategy)\n        // We should use minimum value (but: zero external capacity means no capacity)\n        uint capacity = strategyCapacity[strategy];\n        if (capacity == 0) {\n          capacity = IStrategyV2(strategies[i]).capacity();\n        } else {\n          capacity = Math.min(capacity, IStrategyV2(strategies[i]).capacity());\n        }\n\n        uint strategyBalance = IStrategyV2(strategy).totalAssets();\n        uint toInvest;\n        if (capacity > strategyBalance) {\n          toInvest = Math.min(capacity - strategyBalance, balance);\n        }\n\n        IERC20(_asset).safeTransfer(strategy, toInvest);\n        totalAssetsDelta = IStrategyV2(strategy).investAll(toInvest, updateTotalAssetsBeforeInvest);\n        emit Invested(strategy, toInvest);\n      }\n    }\n\n    return (strategy, totalAssetsDelta);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/TetuVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/IGauge.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./ERC4626Upgradeable.sol\";\n\n/// @title Vault for storing underlying tokens and managing them with strategy splitter.\n/// @author belbix\ncontract TetuVaultV2 is ERC4626Upgradeable, ControllableV3, ITetuVaultV2 {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VAULT_VERSION = \"2.0.1\";\n  /// @dev Denominator for buffer calculation. 100% of the buffer amount.\n  uint constant public BUFFER_DENOMINATOR = 100_000;\n  /// @dev Denominator for fee calculation.\n  uint constant public FEE_DENOMINATOR = 100_000;\n  /// @dev Max 1% fee.\n  uint constant public MAX_FEE = FEE_DENOMINATOR / 100;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Strategy splitter. Should be setup after deploy.\n  ISplitter public splitter;\n  /// @dev Connected gauge for stakeless rewards\n  IGauge public gauge;\n  /// @dev Dedicated contract for holding insurance for covering share price loss.\n  IVaultInsurance public insurance;\n  /// @dev Percent of assets that will always stay in this vault.\n  uint public buffer;\n\n  /// @dev Maximum amount for withdraw. Max UINT256 by default.\n  uint public maxWithdrawAssets;\n  /// @dev Maximum amount for redeem. Max UINT256 by default.\n  uint public maxRedeemShares;\n  /// @dev Maximum amount for deposit. Max UINT256 by default.\n  uint public maxDepositAssets;\n  /// @dev Maximum amount for mint. Max UINT256 by default.\n  uint public maxMintShares;\n  /// @dev Fee for deposit/mint actions. Zero by default.\n  uint public override depositFee;\n  /// @dev Fee for withdraw/redeem actions. Zero by default.\n  uint public override withdrawFee;\n\n  /// @dev Trigger doHardwork on invest action. Enabled by default.\n  bool public doHardWorkOnInvest;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Init(\n    address controller,\n    address asset,\n    string name,\n    string symbol,\n    address gauge,\n    uint buffer\n  );\n  event SplitterSetup(address splitter);\n  event BufferChanged(uint oldValue, uint newValue);\n  event Invest(address splitter, uint amount);\n  event MaxWithdrawChanged(uint maxAssets, uint maxShares);\n  event MaxDepositChanged(uint maxAssets, uint maxShares);\n  event FeeChanged(uint depositFee, uint withdrawFee);\n  event DoHardWorkOnInvestChanged(bool oldValue, bool newValue);\n  event FeeTransfer(uint amount);\n  event LossCovered(uint amount);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(\n    address controller_,\n    IERC20 asset_,\n    string memory _name,\n    string memory _symbol,\n    address _gauge,\n    uint _buffer\n  ) external initializer override {\n    require(_buffer <= BUFFER_DENOMINATOR, \"!BUFFER\");\n    require(_gauge != address(0), \"!GAUGE\");\n    require(IControllable(_gauge).isController(controller_), \"!GAUGE_CONTROLLER\");\n\n    _requireERC20(address(asset_));\n    __ERC4626_init(asset_, _name, _symbol);\n    __Controllable_init(controller_);\n\n    _requireInterface(_gauge, InterfaceIds.I_GAUGE);\n    gauge = IGauge(_gauge);\n    buffer = _buffer;\n\n    // set defaults\n    maxWithdrawAssets = type(uint).max;\n    maxRedeemShares = type(uint).max;\n    maxDepositAssets = type(uint).max - 1;\n    maxMintShares = type(uint).max - 1;\n    doHardWorkOnInvest = true;\n\n    emit Init(\n      controller_,\n      address(asset_),\n      _name,\n      _symbol,\n      _gauge,\n      _buffer\n    );\n  }\n\n  function initInsurance(IVaultInsurance _insurance) external override {\n    require(address(insurance) == address(0), \"INITED\");\n    _requireInterface(address(_insurance), InterfaceIds.I_VAULT_INSURANCE);\n\n    require(_insurance.vault() == address(this), \"!VAULT\");\n    require(_insurance.asset() == address(_asset), \"!ASSET\");\n    insurance = _insurance;\n  }\n\n  // *************************************************************\n  //                      GOV ACTIONS\n  // *************************************************************\n\n  /// @dev Set new buffer value. Should be lower than denominator.\n  function setBuffer(uint _buffer) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n    require(_buffer <= BUFFER_DENOMINATOR, \"BUFFER\");\n\n    emit BufferChanged(buffer, _buffer);\n    buffer = _buffer;\n  }\n\n  /// @dev Set maximum available to deposit amounts.\n  ///      Could be zero values in emergency case when need to pause malicious actions.\n  function setMaxDeposit(uint maxAssets, uint maxShares) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n\n    maxDepositAssets = maxAssets;\n    maxMintShares = maxShares;\n    emit MaxDepositChanged(maxAssets, maxShares);\n  }\n\n  /// @dev Set maximum available to withdraw amounts.\n  ///      Could be zero values in emergency case when need to pause malicious actions.\n  function setMaxWithdraw(uint maxAssets, uint maxShares) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n\n    maxWithdrawAssets = maxAssets;\n    maxRedeemShares = maxShares;\n    emit MaxWithdrawChanged(maxAssets, maxShares);\n  }\n\n  /// @dev Set deposit/withdraw fees\n  function setFees(uint _depositFee, uint _withdrawFee) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n    require(_depositFee <= MAX_FEE && _withdrawFee <= MAX_FEE, \"TOO_HIGH\");\n\n    depositFee = _depositFee;\n    withdrawFee = _withdrawFee;\n    emit FeeChanged(_depositFee, _withdrawFee);\n  }\n\n  /// @dev If activated will call doHardWork on splitter on each invest action.\n  function setDoHardWorkOnInvest(bool value) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n    emit DoHardWorkOnInvestChanged(doHardWorkOnInvest, value);\n    doHardWorkOnInvest = value;\n  }\n\n  /// @dev Set splitter address. Can not change exist splitter.\n  function setSplitter(address _splitter) external override {\n    IERC20 asset_ = _asset;\n    require(address(splitter) == address(0), \"DENIED\");\n    _requireInterface(_splitter, InterfaceIds.I_SPLITTER);\n    require(ISplitter(_splitter).asset() == address(asset_), \"WRONG_UNDERLYING\");\n    require(ISplitter(_splitter).vault() == address(this), \"WRONG_VAULT\");\n    require(IControllable(_splitter).isController(controller()), \"WRONG_CONTROLLER\");\n    asset_.approve(_splitter, type(uint).max);\n    splitter = ISplitter(_splitter);\n    emit SplitterSetup(_splitter);\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of the underlying asset that is “managed” by Vault\n  function totalAssets() public view override returns (uint) {\n    return _asset.balanceOf(address(this)) + splitter.totalAssets();\n  }\n\n  /// @dev Amount of assets under control of strategy splitter.\n  function splitterAssets() external view returns (uint) {\n    return splitter.totalAssets();\n  }\n\n  /// @dev Price of 1 full share\n  function sharePrice() external view returns (uint) {\n    uint units = 10 ** uint256(decimals());\n    uint totalSupply_ = totalSupply();\n    return totalSupply_ == 0\n    ? units\n    : units * totalAssets() / totalSupply_;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_VAULT_V2 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                 DEPOSIT LOGIC\n  // *************************************************************\n\n  function previewDeposit(uint assets) public view virtual override returns (uint) {\n    uint shares = convertToShares(assets);\n    return shares - (shares * depositFee / FEE_DENOMINATOR);\n  }\n\n  function previewMint(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    if (supply != 0) {\n      uint assets = shares.mulDivUp(totalAssets(), supply);\n      return assets * FEE_DENOMINATOR / (FEE_DENOMINATOR - depositFee);\n    } else {\n      return shares * FEE_DENOMINATOR / (FEE_DENOMINATOR - depositFee);\n    }\n  }\n\n  /// @dev Calculate available to invest amount and send this amount to splitter\n  function afterDeposit(uint assets, uint) internal override {\n    address _splitter = address(splitter);\n    IERC20 asset_ = _asset;\n    uint _depositFee = depositFee;\n    // send fee to insurance contract\n    if (_depositFee != 0) {\n      uint toFees = assets * _depositFee / FEE_DENOMINATOR;\n      asset_.safeTransfer(address(insurance), toFees);\n      emit FeeTransfer(toFees);\n    }\n    uint256 toInvest = _availableToInvest(_splitter, asset_);\n    // invest only when buffer is filled\n    if (toInvest > 0) {\n\n      // need to check recursive hardworks\n      if (doHardWorkOnInvest && !ISplitter(_splitter).isHardWorking()) {\n        ISplitter(_splitter).doHardWork();\n      }\n\n      asset_.safeTransfer(_splitter, toInvest);\n      ISplitter(_splitter).investAll();\n      emit Invest(_splitter, toInvest);\n    }\n  }\n\n  /// @notice Returns amount of assets ready to invest to the splitter\n  function _availableToInvest(address _splitter, IERC20 asset_) internal view returns (uint) {\n    uint _buffer = buffer;\n    if (_splitter == address(0) || _buffer == BUFFER_DENOMINATOR) {\n      return 0;\n    }\n    uint assetsInVault = asset_.balanceOf(address(this));\n    uint assetsInSplitter = ISplitter(_splitter).totalAssets();\n    uint wantInvestTotal = (assetsInVault + assetsInSplitter)\n    * (BUFFER_DENOMINATOR - _buffer) / BUFFER_DENOMINATOR;\n    if (assetsInSplitter >= wantInvestTotal) {\n      return 0;\n    } else {\n      uint remainingToInvest = wantInvestTotal - assetsInSplitter;\n      return remainingToInvest <= assetsInVault ? remainingToInvest : assetsInVault;\n    }\n  }\n\n  // *************************************************************\n  //                 WITHDRAW LOGIC\n  // *************************************************************\n\n  /// @dev Withdraw all available shares for tx sender.\n  ///      The revert is expected if the balance is higher than `maxRedeem`\n  function withdrawAll() external {\n    redeem(balanceOf(msg.sender), msg.sender, msg.sender);\n  }\n\n  function previewWithdraw(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    uint _totalAssets = totalAssets();\n    if (_totalAssets == 0) {\n      return assets;\n    }\n    uint shares = assets.mulDivUp(supply, _totalAssets);\n    shares = shares * FEE_DENOMINATOR / (FEE_DENOMINATOR - withdrawFee);\n    return supply == 0 ? assets : shares;\n  }\n\n  function previewRedeem(uint shares) public view virtual override returns (uint) {\n    shares = shares - (shares * withdrawFee / FEE_DENOMINATOR);\n    return convertToAssets(shares);\n  }\n\n  function maxDeposit(address) public view override returns (uint) {\n    return maxDepositAssets;\n  }\n\n  function maxMint(address) public view override returns (uint) {\n    return maxMintShares;\n  }\n\n  function maxWithdraw(address owner) public view override returns (uint) {\n    uint assets = convertToAssets(balanceOf(owner));\n    assets -= assets * withdrawFee / FEE_DENOMINATOR;\n    return Math.min(maxWithdrawAssets, assets);\n  }\n\n  function maxRedeem(address owner) public view override returns (uint) {\n    return Math.min(maxRedeemShares, balanceOf(owner));\n  }\n\n  /// @dev Internal hook for getting necessary assets from splitter.\n  function beforeWithdraw(\n    uint assets,\n    uint shares\n  ) internal override {\n    uint _withdrawFee = withdrawFee;\n    uint fromSplitter;\n    if (_withdrawFee != 0) {\n      // add fee amount\n      fromSplitter = assets * FEE_DENOMINATOR / (FEE_DENOMINATOR - _withdrawFee);\n    } else {\n      fromSplitter = assets;\n    }\n\n    IERC20 asset_ = _asset;\n    uint balance = asset_.balanceOf(address(this));\n    // if not enough balance in the vault withdraw from strategies\n    if (balance < fromSplitter) {\n      _processWithdrawFromSplitter(\n        fromSplitter,\n        shares,\n        totalSupply(),\n        buffer,\n        splitter,\n        balance\n      );\n    }\n    balance = asset_.balanceOf(address(this));\n    require(assets <= balance, \"SLIPPAGE\");\n\n    // send fee amount to insurance for keep correct calculations\n    // in case of compensation it will lead to double transfer\n    // but we assume that it will be rare case\n    if (_withdrawFee != 0) {\n      // we should compensate possible slippage from user fee too\n      uint toFees = Math.min(fromSplitter - assets, balance - assets);\n      if (toFees != 0) {\n        asset_.safeTransfer(address(insurance), toFees);\n        emit FeeTransfer(toFees);\n      }\n    }\n  }\n\n  /// @dev Do necessary calculation for withdrawing from splitter and move assets to vault.\n  ///      If splitter not defined must not be called.\n  function _processWithdrawFromSplitter(\n    uint assetsNeed,\n    uint shares,\n    uint totalSupply_,\n    uint _buffer,\n    ISplitter _splitter,\n    uint assetsInVault\n  ) internal {\n    // withdraw everything from the splitter to accurately check the share value\n    if (shares == totalSupply_) {\n      _splitter.withdrawAllToVault();\n    } else {\n      uint assetsInSplitter = _splitter.totalAssets();\n\n      // we should always have buffer amount inside the vault\n      // assume `assetsNeed` can not be higher than entire balance\n      uint expectedBuffer = (assetsInSplitter + assetsInVault - assetsNeed) * _buffer / BUFFER_DENOMINATOR;\n\n      // this code should not be called if `assetsInVault` higher than `assetsNeed`\n      uint missing = Math.min(expectedBuffer + assetsNeed - assetsInVault, assetsInSplitter);\n      // if zero should be resolved on splitter side\n      _splitter.withdrawToVault(missing);\n    }\n  }\n\n  // *************************************************************\n  //                 INSURANCE LOGIC\n  // *************************************************************\n\n  function coverLoss(uint amount) external override {\n    require(msg.sender == address(splitter), \"!SPLITTER\");\n    IVaultInsurance _insurance = insurance;\n    uint balance = _asset.balanceOf(address(_insurance));\n    uint fromFees = Math.min(amount, balance);\n    _insurance.transferToVault(fromFees);\n    emit LossCovered(fromFees);\n  }\n\n  // *************************************************************\n  //                 GAUGE HOOK\n  // *************************************************************\n\n  /// @dev Connect this vault to the gauge for non-contract addresses.\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint\n  ) internal override {\n    gauge.handleBalanceChange(from);\n    gauge.handleBalanceChange(to);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../proxy/ProxyControlled.sol\";\nimport \"./VaultInsurance.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Factory for vaults.\n/// @author belbix\ncontract VaultFactory is TetuERC165 {\n\n  // *************************************************************\n  //                        VARIABLES\n  // *************************************************************\n\n  /// @dev Platform controller, need for restrictions.\n  address public immutable controller;\n\n  /// @dev TetuVaultV2 contract address\n  address public vaultImpl;\n  /// @dev VaultInsurance contract address\n  address public vaultInsuranceImpl;\n  /// @dev StrategySplitterV2 contract address\n  address public splitterImpl;\n\n  /// @dev Array of deployed vaults.\n  address[] public deployedVaults;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event VaultDeployed(\n    address sender,\n    address asset,\n    string name,\n    string symbol,\n    address gauge,\n    uint buffer,\n    address vaultProxy,\n    address vaultLogic,\n    address insurance,\n    address splitterProxy,\n    address splitterLogic\n  );\n  event VaultImplChanged(address value);\n  event VaultInsuranceImplChanged(address value);\n  event SplitterImplChanged(address value);\n\n  constructor(\n    address _controller,\n    address _vaultImpl,\n    address _vaultInsuranceImpl,\n    address _splitterImpl\n  ) {\n    _requireInterface(_controller, InterfaceIds.I_CONTROLLER);\n    _requireInterface(_vaultImpl, InterfaceIds.I_TETU_VAULT_V2);\n    _requireInterface(_vaultInsuranceImpl, InterfaceIds.I_VAULT_INSURANCE);\n    _requireInterface(_splitterImpl, InterfaceIds.I_SPLITTER);\n\n    controller = _controller;\n    vaultImpl = _vaultImpl;\n    vaultInsuranceImpl = _vaultInsuranceImpl;\n    splitterImpl = _splitterImpl;\n  }\n\n  function deployedVaultsLength() external view returns (uint) {\n    return deployedVaults.length;\n  }\n\n  // *************************************************************\n  //                        RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Only governance\n  modifier onlyGov() {\n    require(msg.sender == IController(controller).governance(), \"!GOV\");\n    _;\n  }\n\n  /// @dev Only platform operators\n  modifier onlyOperator() {\n    require(IController(controller).isOperator(msg.sender), \"!OPERATOR\");\n    _;\n  }\n\n  // *************************************************************\n  //                        GOV ACTIONS\n  // *************************************************************\n\n  /// @dev Set TetuVaultV2 contract address\n  function setVaultImpl(address value) external onlyGov {\n    _requireInterface(value, InterfaceIds.I_TETU_VAULT_V2);\n    vaultImpl = value;\n    emit VaultImplChanged(value);\n  }\n\n  /// @dev Set VaultInsurance contract address\n  function setVaultInsuranceImpl(address value) external onlyGov {\n    _requireInterface(value, InterfaceIds.I_VAULT_INSURANCE);\n    vaultInsuranceImpl = value;\n    emit VaultInsuranceImplChanged(value);\n  }\n\n  /// @dev Set StrategySplitterV2 contract address\n  function setSplitterImpl(address value) external onlyGov {\n    _requireInterface(value, InterfaceIds.I_SPLITTER);\n    splitterImpl = value;\n    emit SplitterImplChanged(value);\n  }\n\n  // *************************************************************\n  //                    OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev Create and init vault with given attributes.\n  function createVault(\n    IERC20 asset,\n    string memory name,\n    string memory symbol,\n    address gauge,\n    uint buffer\n  ) external onlyOperator {\n    // clone vault implementations\n    address vaultProxy = address(new ProxyControlled());\n    address vaultLogic = vaultImpl;\n    // init proxy\n    IProxyControlled(vaultProxy).initProxy(vaultLogic);\n    // init vault\n    ITetuVaultV2(vaultProxy).init(\n      controller,\n      asset,\n      name,\n      symbol,\n      gauge,\n      buffer\n    );\n    // clone insurance\n    VaultInsurance insurance = new VaultInsurance();\n    // init insurance\n    insurance.init(vaultProxy, address(asset));\n    // set insurance to vault\n    ITetuVaultV2(vaultProxy).initInsurance(insurance);\n\n    // clone splitter\n    address splitterProxy = address(new ProxyControlled());\n    address splitterLogic = splitterImpl;\n    // init proxy\n    IProxyControlled(splitterProxy).initProxy(splitterLogic);\n    // init splitter\n    ISplitter(splitterProxy).init(controller, address(asset), vaultProxy);\n    // set splitter to vault\n    ITetuVaultV2(vaultProxy).setSplitter(splitterProxy);\n\n    deployedVaults.push(vaultProxy);\n\n    emit VaultDeployed(\n      msg.sender,\n      address(asset),\n      name,\n      symbol,\n      gauge,\n      buffer,\n      vaultProxy,\n      vaultLogic,\n      address(insurance),\n      splitterProxy,\n      splitterLogic\n    );\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/VaultInsurance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IVaultInsurance.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Simple dedicated contract for store vault fees\n/// @author belbix\ncontract VaultInsurance is TetuERC165, IVaultInsurance  {\n  using SafeERC20 for IERC20;\n\n  /// @dev Vault address\n  address public override vault;\n  /// @dev Vault underlying asset\n  address public override asset;\n\n  /// @dev Init contract with given attributes.\n  ///      Should be called from factory during creation process.\n  function init(address _vault, address _asset) external override {\n    require(vault == address(0) && asset == address(0), \"INITED\");\n    _requireInterface(_vault, InterfaceIds.I_TETU_VAULT_V2);\n    _requireERC20(_asset);\n\n    vault = _vault;\n    asset = _asset;\n  }\n\n  /// @dev Transfer tokens to vault in case of covering need.\n  function transferToVault(uint amount) external override {\n    require(msg.sender == vault, \"!VAULT\");\n    IERC20(asset).safeTransfer(msg.sender, amount);\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_VAULT_INSURANCE || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/ve/TetuVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../interfaces/IVeTetu.sol\";\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IGauge.sol\";\nimport \"../interfaces/IBribe.sol\";\nimport \"../interfaces/IMultiPool.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Voter for veTETU.\n///        Based on Solidly contract.\n/// @author belbix\ncontract TetuVoter is ReentrancyGuard, ControllableV3, IVoter {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VOTER_VERSION = \"1.0.0\";\n  /// @dev Rewards are released over 7 days\n  uint internal constant _DURATION = 7 days;\n  /// @dev Maximum votes per veNFT\n  uint public constant MAX_VOTES = 10;\n  /// @dev Delay between votes. We need delay for properly bribes distribution between votes.\n  uint public constant VOTE_DELAY = 1 weeks;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev The ve token that governs these contracts\n  address public override ve;\n  address public token;\n  address public gauge;\n  address public bribe;\n\n  // --- VOTES\n\n  /// @dev veID => Last vote timestamp\n  mapping(uint => uint) public lastVote;\n  /// @dev Total voting weight\n  uint public totalWeight;\n  /// @dev vault => weight\n  mapping(address => int256) public weights;\n  /// @dev nft => vault => votes\n  mapping(uint => mapping(address => int256)) public votes;\n  /// @dev nft => vaults addresses voted for\n  mapping(uint => address[]) public vaultsVotes;\n  /// @dev nft => total voting weight of user\n  mapping(uint => uint) public usedWeights;\n\n  // --- ATTACHMENTS\n\n  /// @dev veId => Attached staking token\n  mapping(uint => EnumerableSet.AddressSet) internal _attachedStakingTokens;\n\n  // --- REWARDS\n\n  /// @dev Global index for accumulated distro\n  uint public index;\n  /// @dev vault => Saved global index for accumulated distro\n  mapping(address => uint) public supplyIndex;\n  /// @dev vault => Available to distribute reward amount\n  mapping(address => uint) public claimable;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Voted(address indexed voter, uint tokenId, int256 weight, address vault, int256 userWeight, int256 vePower);\n  event Abstained(uint tokenId, int256 weight, address vault);\n  event NotifyReward(address indexed sender, uint amount);\n  event DistributeReward(address indexed sender, address indexed vault, uint amount);\n  event Attach(address indexed owner, address indexed sender, address indexed stakingToken, uint tokenId);\n  event Detach(address indexed owner, address indexed sender, address indexed stakingToken, uint tokenId);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  function init(\n    address _controller,\n    address _ve,\n    address _rewardToken,\n    address _gauge,\n    address _bribe\n  ) external initializer {\n    __Controllable_init(_controller);\n\n    _requireInterface(_ve, InterfaceIds.I_VE_TETU);\n    _requireERC20(_rewardToken);\n    _requireInterface(_gauge, InterfaceIds.I_GAUGE);\n    _requireInterface(_bribe, InterfaceIds.I_BRIBE);\n\n    ve = _ve;\n    token = _rewardToken;\n    gauge = _gauge;\n    bribe = _bribe;\n\n    // if the gauge will be changed in a new implementation, need to revoke approval and set a new\n    IERC20(_rewardToken).safeApprove(gauge, type(uint).max);\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Returns true for valid vault registered in controller.\n  function isVault(address _vault) public view returns (bool) {\n    return IController(controller()).isValidVault(_vault);\n  }\n\n  /// @dev Returns register in controller vault by id .\n  function validVaults(uint id) public view returns (address) {\n    return IController(controller()).vaults(id);\n  }\n\n  /// @dev Valid vaults registered in controller length.\n  function validVaultsLength() public view returns (uint) {\n    return IController(controller()).vaultsListLength();\n  }\n\n  /// @dev Returns all attached addresses to given veId. Attachments suppose to be gauges.\n  function attachedStakingTokens(uint veId) external view returns (address[] memory) {\n    return _attachedStakingTokens[veId].values();\n  }\n\n  /// @dev Return voted vaults length for given veId.\n  function votedVaultsLength(uint veId) external view returns (uint) {\n    return vaultsVotes[veId].length;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_VOTER || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        VOTES\n  // *************************************************************\n\n  /// @dev Resubmit exist votes for given token.\n  ///      Need to call it for ve that did not renew votes too long.\n  function poke(uint _tokenId) external {\n    address[] memory _vaultVotes = vaultsVotes[_tokenId];\n    uint length = _vaultVotes.length;\n    int256[] memory _weights = new int256[](length);\n\n    for (uint i; i < length; i++) {\n      _weights[i] = votes[_tokenId][_vaultVotes[i]];\n    }\n\n    _vote(_tokenId, _vaultVotes, _weights);\n  }\n\n  /// @dev Remove all votes for given tokenId.\n  ///      Ve token should be able to remove votes on transfer/withdraw\n  function reset(uint tokenId) external {\n    require(IVeTetu(ve).isApprovedOrOwner(msg.sender, tokenId) || msg.sender == ve, \"!owner\");\n    require(lastVote[tokenId] + VOTE_DELAY < block.timestamp, \"delay\");\n    _reset(tokenId);\n  }\n\n  /// @dev Vote for given pools using a vote power of given tokenId. Reset previous votes.\n  function vote(uint tokenId, address[] calldata _vaultVotes, int256[] calldata _weights) external {\n    require(IVeTetu(ve).isApprovedOrOwner(msg.sender, tokenId), \"!owner\");\n    require(lastVote[tokenId] + VOTE_DELAY < block.timestamp, \"delay\");\n    require(_vaultVotes.length == _weights.length, \"!arrays\");\n    _vote(tokenId, _vaultVotes, _weights);\n    lastVote[tokenId] = block.timestamp;\n  }\n\n  function _vote(uint _tokenId, address[] memory _vaultVotes, int256[] memory _weights) internal {\n    _reset(_tokenId);\n    uint length = _vaultVotes.length;\n\n    require(length <= MAX_VOTES, \"Too many votes\");\n\n    int256 _weight = int256(IVeTetu(ve).balanceOfNFT(_tokenId));\n    int256 _totalVoteWeight = 0;\n    int256 _totalWeight = 0;\n    int256 _usedWeight = 0;\n\n    for (uint i = 0; i < length; i++) {\n      _totalVoteWeight += _weights[i] > 0 ? _weights[i] : - _weights[i];\n    }\n\n    for (uint i = 0; i < length; i++) {\n      address _vault = _vaultVotes[i];\n      require(isVault(_vault), \"Invalid vault\");\n\n      int256 _vaultWeight = _weights[i] * _weight / _totalVoteWeight;\n      require(votes[_tokenId][_vault] == 0, \"duplicate vault\");\n      require(_vaultWeight != 0, \"zero power\");\n      _updateFor(_vault);\n\n      vaultsVotes[_tokenId].push(_vault);\n\n      weights[_vault] += _vaultWeight;\n      votes[_tokenId][_vault] += _vaultWeight;\n      if (_vaultWeight > 0) {\n        IBribe(bribe).deposit(_vault, uint(_vaultWeight), _tokenId);\n      } else {\n        _vaultWeight = - _vaultWeight;\n      }\n      _usedWeight += _vaultWeight;\n      _totalWeight += _vaultWeight;\n      emit Voted(msg.sender, _tokenId, _vaultWeight, _vault, _weights[i], _weight);\n    }\n    if (_usedWeight > 0) {\n      IVeTetu(ve).voting(_tokenId);\n    }\n    totalWeight += uint(_totalWeight);\n    usedWeights[_tokenId] = uint(_usedWeight);\n  }\n\n  /// @dev Remove all votes for given veId\n  function _reset(uint _tokenId) internal {\n    address[] storage _vaultsVotes = vaultsVotes[_tokenId];\n    uint length = _vaultsVotes.length;\n    int256 _totalWeight = 0;\n\n    for (uint i = 0; i < length; i ++) {\n      address _vault = _vaultsVotes[i];\n      int256 _votes = votes[_tokenId][_vault];\n      _updateFor(_vault);\n      weights[_vault] -= _votes;\n      votes[_tokenId][_vault] = 0;\n      if (_votes > 0) {\n        IBribe(bribe).withdraw(_vault, uint(_votes), _tokenId);\n        _totalWeight += _votes;\n      } else {\n        _totalWeight -= _votes;\n      }\n      emit Abstained(_tokenId, _votes, _vault);\n    }\n    totalWeight -= uint(_totalWeight);\n    usedWeights[_tokenId] = 0;\n    delete vaultsVotes[_tokenId];\n    if (_totalWeight > 0) {\n      IVeTetu(ve).abstain(_tokenId);\n    }\n  }\n\n  // *************************************************************\n  //                        ATTACH/DETACH\n  // *************************************************************\n\n  /// @dev A gauge should be able to attach a token for preventing transfers/withdraws.\n  function attachTokenToGauge(address stakingToken, uint tokenId, address account) external override {\n    require(gauge == msg.sender, \"!gauge\");\n    IVeTetu(ve).attachToken(tokenId);\n    // no need to check the result - the gauge should send only new values\n    _attachedStakingTokens[tokenId].add(stakingToken);\n    emit Attach(account, msg.sender, stakingToken, tokenId);\n  }\n\n  /// @dev Detach given token.\n  function detachTokenFromGauge(address stakingToken, uint tokenId, address account) external override {\n    require(gauge == msg.sender, \"!gauge\");\n    IVeTetu(ve).detachToken(tokenId);\n    // no need to check the result - the gauge should send only exist values\n    _attachedStakingTokens[tokenId].remove(stakingToken);\n    emit Detach(account, msg.sender, stakingToken, tokenId);\n  }\n\n  /// @dev Detach given token from all gauges and votes\n  ///      It could be pretty expensive call.\n  ///      Need to have restrictions for max attached tokens and votes.\n  function detachTokenFromAll(uint tokenId, address account) external override {\n    require(msg.sender == ve, \"!ve\");\n\n    _reset(tokenId);\n\n    // need to copy addresses to memory, we will change this collection in the loop\n    address[] memory tokens = _attachedStakingTokens[tokenId].values();\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      // no need to check attachments if _attachedStakingTokens properly updated\n      IGauge(gauge).detachVe(tokens[i], account, tokenId);\n    }\n  }\n\n  // *************************************************************\n  //                    UPDATE INDEXES\n  // *************************************************************\n\n  /// @dev Update given vaults.\n  function updateFor(address[] memory _vaults) external {\n    for (uint i = 0; i < _vaults.length; i++) {\n      _updateFor(_vaults[i]);\n    }\n  }\n\n  /// @dev Update vaults by indexes in a range.\n  function updateForRange(uint start, uint end) public {\n    IController c = IController(controller());\n    for (uint i = start; i < end; i++) {\n      _updateFor(c.vaults(i));\n    }\n  }\n\n  /// @dev Update all gauges.\n  function updateAll() external {\n    updateForRange(0, validVaultsLength());\n  }\n\n  function _updateFor(address _vault) internal {\n    int256 _supplied = weights[_vault];\n    if (_supplied > 0) {\n      uint _supplyIndex = supplyIndex[_vault];\n      // get global index for accumulated distro\n      uint _index = index;\n      // update vault current position to global position\n      supplyIndex[_vault] = _index;\n      // see if there is any difference that need to be accrued\n      uint _delta = _index - _supplyIndex;\n      if (_delta > 0) {\n        // add accrued difference for each supplied token\n        uint _share = uint(_supplied) * _delta / 1e18;\n        claimable[_vault] += _share;\n      }\n    } else {\n      // new users are set to the default global state\n      supplyIndex[_vault] = index;\n    }\n  }\n\n  // *************************************************************\n  //                        REWARDS\n  // *************************************************************\n\n  /// @dev Add rewards to this contract. It will be distributed to gauges.\n  function notifyRewardAmount(uint amount) external override {\n    require(amount != 0, \"zero amount\");\n    uint _totalWeight = totalWeight;\n    // without votes rewards can not be added\n    require(_totalWeight != 0, \"!weights\");\n    // transfer the distro in\n    IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n    // 1e18 adjustment is removed during claim\n    uint _ratio = amount * 1e18 / _totalWeight;\n    if (_ratio > 0) {\n      index += _ratio;\n    }\n    emit NotifyReward(msg.sender, amount);\n  }\n\n  /// @dev Notify rewards for given vault. Anyone can call\n  function distribute(address _vault) external override {\n    _distribute(_vault);\n  }\n\n  /// @dev Distribute rewards to all valid vaults.\n  function distributeAll() external {\n    uint length = validVaultsLength();\n    IController c = IController(controller());\n    for (uint x; x < length; x++) {\n      _distribute(c.vaults(x));\n    }\n  }\n\n  function distributeFor(uint start, uint finish) external {\n    IController c = IController(controller());\n    for (uint x = start; x < finish; x++) {\n      _distribute(c.vaults(x));\n    }\n  }\n\n  function _distribute(address _vault) internal nonReentrant {\n    _updateFor(_vault);\n    uint _claimable = claimable[_vault];\n    address _token = token;\n    address _gauge = gauge;\n    // rewards should not extend period infinity, only higher amount allowed\n    if (_claimable > IMultiPool(_gauge).left(_vault, _token)\n      && _claimable / _DURATION > 0) {\n      claimable[_vault] = 0;\n      IGauge(_gauge).notifyRewardAmount(_vault, _token, _claimable);\n      emit DistributeReward(msg.sender, _vault, _claimable);\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/ve/VeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IVeTetu.sol\";\nimport \"../interfaces/IVeDistributor.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Contract for distributing rewards to ve holders.\n///        Rewards will be staked to the veNFT without extending lock period.\n///        Based on Solidly contract.\n/// @author belbix\ncontract VeDistributor is ControllableV3, IVeDistributor {\n  using SafeERC20 for IERC20;\n\n  // for contract internal purposes, don't need to store in the interface\n  struct ClaimCalculationResult {\n    uint toDistribute;\n    uint userEpoch;\n    uint weekCursor;\n    uint maxUserEpoch;\n    bool success;\n  }\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VE_DIST_VERSION = \"1.0.0\";\n  uint internal constant WEEK = 7 * 86400;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Voting escrow token address\n  IVeTetu public ve;\n  /// @dev Token for ve rewards\n  address public override rewardToken;\n\n  // --- CHECKPOINT\n\n  /// @dev Cursor for the current epoch\n  uint public activePeriod;\n  /// @dev Tokens per week stored on checkpoint call. Predefined array size = max weeks size\n  uint[1000000000000000] public tokensPerWeek;\n  /// @dev Ve supply checkpoints. Predefined array size = max weeks size\n  uint[1000000000000000] public veSupply;\n  /// @dev Ve supply checkpoint time cursor\n  uint public timeCursor;\n  /// @dev Token balance updated on checkpoint/claim\n  uint public tokenLastBalance;\n  /// @dev Last checkpoint time\n  uint public lastTokenTime;\n\n  // --- CLAIM\n\n  /// @dev Timestamp when this contract was inited\n  uint public startTime;\n  /// @dev veID => week cursor stored on the claim action\n  mapping(uint => uint) public timeCursorOf;\n  /// @dev veID => epoch stored on the claim action\n  mapping(uint => uint) public userEpochOf;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event CheckpointToken(\n    uint time,\n    uint tokens\n  );\n\n  event Claimed(\n    uint tokenId,\n    uint amount,\n    uint claimEpoch,\n    uint maxEpoch\n  );\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(\n    address controller_,\n    address _ve,\n    address _rewardToken\n  ) external initializer {\n    __Controllable_init(controller_);\n    _requireERC20(_rewardToken);\n    _requireInterface(_ve, InterfaceIds.I_VE_TETU);\n\n    uint _t = block.timestamp / WEEK * WEEK;\n    startTime = _t;\n    lastTokenTime = _t;\n    timeCursor = _t;\n\n    rewardToken = _rewardToken;\n    ve = IVeTetu(_ve);\n\n    IERC20(_rewardToken).safeApprove(_ve, type(uint).max);\n  }\n\n  // *************************************************************\n  //                      CHECKPOINT\n  // *************************************************************\n\n  function checkpoint() external override {\n    uint _period = activePeriod;\n    // only trigger if new week\n    if (block.timestamp >= _period + 1 weeks) {\n      // set new period rounded to weeks\n      activePeriod = block.timestamp / 1 weeks * 1 weeks;\n      // checkpoint token balance that was just minted in veDist\n      _checkpointToken();\n      // checkpoint supply\n      _checkpointTotalSupply();\n    }\n  }\n\n  /// @dev Update tokensPerWeek value\n  function _checkpointToken() internal {\n    uint tokenBalance = IERC20(rewardToken).balanceOf(address(this));\n    uint toDistribute = tokenBalance - tokenLastBalance;\n    tokenLastBalance = tokenBalance;\n\n    uint t = lastTokenTime;\n    uint sinceLast = block.timestamp - t;\n    lastTokenTime = block.timestamp;\n    uint thisWeek = t / WEEK * WEEK;\n    uint nextWeek = 0;\n\n    // checkpoint should be called at least once per 20 weeks\n    for (uint i = 0; i < 20; i++) {\n      nextWeek = thisWeek + WEEK;\n      if (block.timestamp < nextWeek) {\n        tokensPerWeek[thisWeek] += adjustToDistribute(toDistribute, block.timestamp, t, sinceLast);\n        break;\n      } else {\n        tokensPerWeek[thisWeek] += adjustToDistribute(toDistribute, nextWeek, t, sinceLast);\n      }\n      t = nextWeek;\n      thisWeek = nextWeek;\n    }\n    emit CheckpointToken(block.timestamp, toDistribute);\n  }\n\n  /// @dev Adjust value based on time since last update\n  function adjustToDistribute(\n    uint toDistribute,\n    uint t0,\n    uint t1,\n    uint sinceLast\n  ) public pure returns (uint) {\n    if (t0 <= t1 || t0 - t1 == 0 || sinceLast == 0) {\n      return toDistribute;\n    }\n    return toDistribute * (t0 - t1) / sinceLast;\n  }\n\n  /// @dev Search in the loop given timestamp through ve points history.\n  ///      Return minimal possible epoch.\n  function findTimestampEpoch(IVeTetu _ve, uint _timestamp) public view returns (uint) {\n    uint _min = 0;\n    uint _max = _ve.epoch();\n    for (uint i = 0; i < 128; i++) {\n      if (_min >= _max) break;\n      uint _mid = (_min + _max + 2) / 2;\n      IVeTetu.Point memory pt = _ve.pointHistory(_mid);\n      if (pt.ts <= _timestamp) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  /// @dev Search in the loop given timestamp through ve user points history.\n  ///      Return minimal possible epoch.\n  function findTimestampUserEpoch(\n    IVeTetu _ve,\n    uint tokenId,\n    uint _timestamp,\n    uint maxUserEpoch\n  ) public view returns (uint) {\n    uint _min = 0;\n    uint _max = maxUserEpoch;\n    for (uint i = 0; i < 128; i++) {\n      if (_min >= _max) break;\n      uint _mid = (_min + _max + 2) / 2;\n      IVeTetu.Point memory pt = _ve.userPointHistory(tokenId, _mid);\n      if (pt.ts <= _timestamp) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  /// @dev Return ve power at given timestamp\n  function veForAt(uint _tokenId, uint _timestamp) external view returns (uint) {\n    IVeTetu _ve = ve;\n    uint maxUserEpoch = _ve.userPointEpoch(_tokenId);\n    uint epoch = findTimestampUserEpoch(_ve, _tokenId, _timestamp, maxUserEpoch);\n    IVeTetu.Point memory pt = _ve.userPointHistory(_tokenId, epoch);\n    return uint(int256(_positiveInt128(pt.bias - pt.slope * (int128(int256(_timestamp - pt.ts))))));\n  }\n\n  /// @dev Call ve checkpoint and write veSupply at the current timeCursor\n  function checkpointTotalSupply() external override {\n    _checkpointTotalSupply();\n  }\n\n  function _checkpointTotalSupply() internal {\n    IVeTetu _ve = ve;\n    uint t = timeCursor;\n    uint roundedTimestamp = block.timestamp / WEEK * WEEK;\n    _ve.checkpoint();\n\n    // assume will be called more frequently than 20 weeks\n    for (uint i = 0; i < 20; i++) {\n      if (t > roundedTimestamp) {\n        break;\n      } else {\n        uint epoch = findTimestampEpoch(_ve, t);\n        IVeTetu.Point memory pt = _ve.pointHistory(epoch);\n        veSupply[t] = adjustVeSupply(t, pt.ts, pt.bias, pt.slope);\n      }\n      t += WEEK;\n    }\n    timeCursor = t;\n  }\n\n  /// @dev Calculate ve supply based on bias and slop for the given timestamp\n  function adjustVeSupply(uint t, uint ptTs, int128 ptBias, int128 ptSlope) public pure returns (uint) {\n    if (t < ptTs) {\n      return 0;\n    }\n    int128 dt = int128(int256(t - ptTs));\n    if (ptBias < ptSlope * dt) {\n      return 0;\n    }\n    return uint(int256(_positiveInt128(ptBias - ptSlope * dt)));\n  }\n\n  // *************************************************************\n  //                      CLAIM\n  // *************************************************************\n\n  /// @dev Return available to claim earned amount\n  function claimable(uint _tokenId) external view returns (uint) {\n    uint _lastTokenTime = lastTokenTime / WEEK * WEEK;\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, ve, _lastTokenTime);\n    return result.toDistribute;\n  }\n\n  /// @dev Claim rewards for given veID\n  function claim(uint _tokenId) external override returns (uint) {\n    IVeTetu _ve = ve;\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n    uint _lastTokenTime = lastTokenTime;\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\n    uint amount = _claim(_tokenId, _ve, _lastTokenTime);\n    if (amount != 0) {\n      _ve.increaseAmount(rewardToken, _tokenId, amount);\n      tokenLastBalance -= amount;\n    }\n    return amount;\n  }\n\n  /// @dev Claim rewards for given veIDs\n  function claimMany(uint[] memory _tokenIds) external returns (bool) {\n    if (block.timestamp >= timeCursor) _checkpointTotalSupply();\n    uint _lastTokenTime = lastTokenTime;\n    _lastTokenTime = _lastTokenTime / WEEK * WEEK;\n    IVeTetu _votingEscrow = ve;\n    uint total = 0;\n\n    for (uint i = 0; i < _tokenIds.length; i++) {\n      uint _tokenId = _tokenIds[i];\n      if (_tokenId == 0) break;\n      uint amount = _claim(_tokenId, _votingEscrow, _lastTokenTime);\n      if (amount != 0) {\n        _votingEscrow.increaseAmount(rewardToken, _tokenId, amount);\n        total += amount;\n      }\n    }\n    if (total != 0) {\n      tokenLastBalance -= total;\n    }\n\n    return true;\n  }\n\n  function _claim(uint _tokenId, IVeTetu _ve, uint _lastTokenTime) internal returns (uint) {\n    ClaimCalculationResult memory result = _calculateClaim(_tokenId, _ve, _lastTokenTime);\n    if (result.success) {\n      userEpochOf[_tokenId] = result.userEpoch;\n      timeCursorOf[_tokenId] = result.weekCursor;\n      emit Claimed(_tokenId, result.toDistribute, result.userEpoch, result.maxUserEpoch);\n    }\n    return result.toDistribute;\n  }\n\n  function _calculateClaim(\n    uint _tokenId,\n    IVeTetu _ve,\n    uint _lastTokenTime\n  ) internal view returns (ClaimCalculationResult memory) {\n    uint userEpoch;\n    uint maxUserEpoch = _ve.userPointEpoch(_tokenId);\n    uint _startTime = startTime;\n\n    if (maxUserEpoch == 0) {\n      return ClaimCalculationResult(0, 0, 0, 0, false);\n    }\n\n    uint weekCursor = timeCursorOf[_tokenId];\n\n    if (weekCursor == 0) {\n      userEpoch = findTimestampUserEpoch(_ve, _tokenId, _startTime, maxUserEpoch);\n    } else {\n      userEpoch = userEpochOf[_tokenId];\n    }\n\n    if (userEpoch == 0) userEpoch = 1;\n\n    IVeTetu.Point memory userPoint = _ve.userPointHistory(_tokenId, userEpoch);\n    if (weekCursor == 0) {\n      weekCursor = (userPoint.ts + WEEK - 1) / WEEK * WEEK;\n    }\n    if (weekCursor >= lastTokenTime) {\n      return ClaimCalculationResult(0, 0, 0, 0, false);\n    }\n    if (weekCursor < _startTime) {\n      weekCursor = _startTime;\n    }\n\n    return calculateToDistribute(\n      _tokenId,\n      weekCursor,\n      _lastTokenTime,\n      userPoint,\n      userEpoch,\n      maxUserEpoch,\n      _ve\n    );\n  }\n\n  function calculateToDistribute(\n    uint _tokenId,\n    uint weekCursor,\n    uint _lastTokenTime,\n    IVeTetu.Point memory userPoint,\n    uint userEpoch,\n    uint maxUserEpoch,\n    IVeTetu _ve\n  ) public view returns (ClaimCalculationResult memory) {\n    IVeTetu.Point memory oldUserPoint;\n    uint toDistribute;\n    for (uint i = 0; i < 50; i++) {\n      if (weekCursor >= _lastTokenTime) {\n        break;\n      }\n      if (weekCursor >= userPoint.ts && userEpoch <= maxUserEpoch) {\n        userEpoch += 1;\n        oldUserPoint = userPoint;\n        if (userEpoch > maxUserEpoch) {\n          userPoint = IVeTetu.Point(0, 0, 0, 0);\n        } else {\n          userPoint = _ve.userPointHistory(_tokenId, userEpoch);\n        }\n      } else {\n        int128 dt = int128(int256(weekCursor - oldUserPoint.ts));\n        uint balanceOf = uint(int256(_positiveInt128(oldUserPoint.bias - dt * oldUserPoint.slope)));\n        if (balanceOf == 0 && userEpoch > maxUserEpoch) {\n          break;\n        }\n        toDistribute += balanceOf * tokensPerWeek[weekCursor] / veSupply[weekCursor];\n        weekCursor += WEEK;\n      }\n    }\n    return ClaimCalculationResult(\n      toDistribute,\n      Math.min(maxUserEpoch, userEpoch - 1),\n      weekCursor,\n      maxUserEpoch,\n      true\n    );\n  }\n\n  function _positiveInt128(int128 value) internal pure returns (int128) {\n    return value < 0 ? int128(0) : value;\n  }\n\n  /// @dev Block timestamp rounded to weeks\n  function timestamp() external view returns (uint) {\n    return block.timestamp / WEEK * WEEK;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_VE_DISTRIBUTOR || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/ve/VeTetu.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"../interfaces/IERC721Metadata.sol\";\nimport \"../interfaces/IVeTetu.sol\";\nimport \"../interfaces/IERC721Receiver.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IPlatformVoter.sol\";\nimport \"../interfaces/ISmartVault.sol\";\nimport \"../lib/FixedPointMathLib.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./VeTetuLogo.sol\";\n\n/// @title Voting escrow NFT for multiple underlying tokens.\n///        Based on Curve/Solidly contract.\n/// @author belbix\ncontract VeTetu is ControllableV3, ReentrancyGuard, IERC721, IERC721Metadata, IVeTetu {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n  using FixedPointMathLib for int128;\n\n  // Only for internal usage\n  struct DepositInfo {\n    address stakingToken;\n    uint tokenId;\n    uint value;\n    uint unlockTime;\n    uint lockedAmount;\n    uint lockedDerivedAmount;\n    uint lockedEnd;\n    DepositType depositType;\n  }\n\n  // Only for internal usage\n  struct CheckpointInfo {\n    uint tokenId;\n    uint oldDerivedAmount;\n    uint newDerivedAmount;\n    uint oldEnd;\n    uint newEnd;\n  }\n\n  enum TimeLockType {\n    UNKNOWN,\n    ADD_TOKEN,\n    WHITELIST_TRANSFER\n  }\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VE_VERSION = \"1.1.1\";\n  uint internal constant WEEK = 1 weeks;\n  uint internal constant MAX_TIME = 16 weeks;\n  int128 internal constant I_MAX_TIME = 16 weeks;\n  uint internal constant MULTIPLIER = 1 ether;\n  uint internal constant WEIGHT_DENOMINATOR = 100e18;\n  uint public constant MAX_ATTACHMENTS = 1;\n  uint public constant GOV_ACTION_TIME_LOCK = 18 hours;\n\n  string constant public override name = \"veTETU\";\n  string constant public override symbol = \"veTETU\";\n\n  /// @dev ERC165 interface ID of ERC165\n  bytes4 internal constant _ERC165_INTERFACE_ID = 0x01ffc9a7;\n  /// @dev ERC165 interface ID of ERC721\n  bytes4 internal constant _ERC721_INTERFACE_ID = 0x80ac58cd;\n  /// @dev ERC165 interface ID of ERC721Metadata\n  bytes4 internal constant _ERC721_METADATA_INTERFACE_ID = 0x5b5e139f;\n\n  address internal constant _TETU_USDC_BPT = 0xE2f706EF1f7240b803AAe877C9C762644bb808d8;\n  address internal constant _TETU_USDC_BPT_VAULT = 0x6922201f0d25Aba8368e7806642625879B35aB84;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Underlying tokens info\n  address[] public override tokens;\n  /// @dev token => weight\n  mapping(address => uint) public tokenWeights;\n  /// @dev token => is allowed for deposits\n  mapping(address => bool) public isValidToken;\n  /// @dev Current count of token\n  uint public tokenId;\n  /// @dev veId => stakingToken => Locked amount\n  mapping(uint => mapping(address => uint)) public override lockedAmounts;\n  /// @dev veId => Amount based on weights aka power\n  mapping(uint => uint) public override lockedDerivedAmount;\n  /// @dev veId => Lock end timestamp\n  mapping(uint => uint) public override lockedEnd;\n\n  // --- CHECKPOINTS LOGIC\n\n  /// @dev Epoch counter. Update each week.\n  uint public override epoch;\n  /// @dev epoch -> unsigned point\n  mapping(uint => Point) internal _pointHistory;\n  /// @dev user -> Point[userEpoch]\n  mapping(uint => Point[1000000000]) internal _userPointHistory;\n  /// @dev veId -> Personal epoch counter\n  mapping(uint => uint) public override userPointEpoch;\n  /// @dev time -> signed slope change\n  mapping(uint => int128) public slopeChanges;\n\n  // --- LOCK\n\n  /// @dev veId -> Attachments counter. With positive counter user unable to transfer NFT\n  mapping(uint => uint) public override attachments;\n  /// @dev veId -> votes counter. With votes NFT unable to transfer\n  mapping(uint => uint) public override voted;\n\n  // --- STATISTICS\n\n  /// @dev veId -> Block number when last time NFT owner changed\n  mapping(uint => uint) public ownershipChange;\n  /// @dev Mapping from NFT ID to the address that owns it.\n  mapping(uint => address) internal _idToOwner;\n  /// @dev Mapping from NFT ID to approved address.\n  mapping(uint => address) internal _idToApprovals;\n  /// @dev Mapping from owner address to count of his tokens.\n  mapping(address => uint) internal _ownerToNFTokenCount;\n  /// @dev Mapping from owner address to mapping of index to tokenIds\n  mapping(address => mapping(uint => uint)) internal _ownerToNFTokenIdList;\n  /// @dev Mapping from NFT ID to index of owner\n  mapping(uint => uint) public tokenToOwnerIndex;\n  /// @dev Mapping from owner address to mapping of operator addresses.\n  mapping(address => mapping(address => bool)) public ownerToOperators;\n\n  /// @dev Mapping of interface id to bool about whether or not it's supported\n  mapping(bytes4 => bool) internal _supportedInterfaces;\n\n  // --- PERMISSIONS\n\n  /// @dev Whitelisted contracts will be able to transfer NFTs\n  mapping(address => bool) public isWhitelistedTransfer;\n  /// @dev Time-locks for governance actions. Zero means not announced and should not processed.\n  mapping(TimeLockType => uint) public govActionTimeLock;\n  /// @dev underlying token => true if we can stake token to some place, false if paused\n  mapping(address => bool) internal tokenFarmingStatus;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Deposit(\n    address indexed stakingToken,\n    address indexed provider,\n    uint tokenId,\n    uint value,\n    uint indexed locktime,\n    DepositType depositType,\n    uint ts\n  );\n  event Withdraw(address indexed stakingToken, address indexed provider, uint tokenId, uint value, uint ts);\n  event Merged(address indexed stakingToken, address indexed provider, uint from, uint to);\n  event Split(uint parentTokenId, uint newTokenId, uint percent);\n  event TransferWhitelisted(address value);\n  event StakingTokenAdded(address value, uint weight);\n  event GovActionAnnounced(uint _type, uint timeToExecute);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  /// @param token_ Underlying ERC20 token\n  /// @param controller_ Central contract of the protocol\n  function init(address token_, uint weight, address controller_) external initializer {\n    __Controllable_init(controller_);\n\n    // the first token should have 18 decimals\n    require(IERC20Metadata(token_).decimals() == uint8(18));\n    _addToken(token_, weight);\n\n    _pointHistory[0].blk = block.number;\n    _pointHistory[0].ts = block.timestamp;\n\n    _supportedInterfaces[_ERC165_INTERFACE_ID] = true;\n    _supportedInterfaces[_ERC721_INTERFACE_ID] = true;\n    _supportedInterfaces[_ERC721_METADATA_INTERFACE_ID] = true;\n\n    // mint-ish\n    emit Transfer(address(0), address(this), 0);\n    // burn-ish\n    emit Transfer(address(this), address(0), 0);\n  }\n\n  // *************************************************************\n  //                        GOVERNANCE ACTIONS\n  // *************************************************************\n\n  function announceAction(TimeLockType _type) external {\n    require(isGovernance(msg.sender), \"FORBIDDEN\");\n    require(govActionTimeLock[_type] == 0 && _type != TimeLockType.UNKNOWN, \"WRONG_INPUT\");\n\n    govActionTimeLock[_type] = block.timestamp + GOV_ACTION_TIME_LOCK;\n    emit GovActionAnnounced(uint(_type), block.timestamp + GOV_ACTION_TIME_LOCK);\n  }\n\n  /// @dev Whitelist address for transfers. Removing from whitelist should be forbidden.\n  function whitelistTransferFor(address value) external {\n    require(isGovernance(msg.sender), \"FORBIDDEN\");\n    require(value != address(0), \"WRONG_INPUT\");\n    uint timeLock = govActionTimeLock[TimeLockType.WHITELIST_TRANSFER];\n    require(timeLock != 0 && timeLock < block.timestamp, \"TIME_LOCK\");\n\n    isWhitelistedTransfer[value] = true;\n    govActionTimeLock[TimeLockType.WHITELIST_TRANSFER] = 0;\n\n    emit TransferWhitelisted(value);\n  }\n\n  function addToken(address token, uint weight) external {\n    require(isGovernance(msg.sender), \"FORBIDDEN\");\n    uint timeLock = govActionTimeLock[TimeLockType.ADD_TOKEN];\n    require(timeLock != 0 && timeLock < block.timestamp, \"TIME_LOCK\");\n\n    _addToken(token, weight);\n    govActionTimeLock[TimeLockType.ADD_TOKEN] = 0;\n  }\n\n  function _addToken(address token, uint weight) internal {\n    require(token != address(0) && weight != 0, \"WRONG_INPUT\");\n    _requireERC20(token);\n\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      require(token != tokens[i], \"WRONG_INPUT\");\n    }\n\n    tokens.push(token);\n    tokenWeights[token] = weight;\n    isValidToken[token] = true;\n\n    emit StakingTokenAdded(token, weight);\n  }\n\n  function changeTokenFarmingAllowanceStatus(address _token, bool status) external {\n    require(isGovernance(msg.sender), \"FORBIDDEN\");\n    require(tokenFarmingStatus[_token] != status);\n    tokenFarmingStatus[_token] = status;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Return length of staking tokens.\n  function tokensLength() external view returns (uint) {\n    return tokens.length;\n  }\n\n  /// @dev Current block timestamp\n  function blockTimestamp() external view returns (uint) {\n    return block.timestamp;\n  }\n\n  /// @dev Voter should handle attach/detach and vote actions\n  function voter() public view returns (address) {\n    return IController(controller()).voter();\n  }\n\n  /// @dev Specific voter for control platform attributes.\n  function platformVoter() public view returns (address) {\n    return IController(controller()).platformVoter();\n  }\n\n  /// @dev Interface identification is specified in ERC-165.\n  /// @param _interfaceID Id of the interface\n  function supportsInterface(bytes4 _interfaceID) public view override(ControllableV3, IERC165) returns (bool) {\n    return _supportedInterfaces[_interfaceID]\n    || _interfaceID == InterfaceIds.I_VE_TETU\n    || super.supportsInterface(_interfaceID);\n  }\n\n  /// @notice Get the most recently recorded rate of voting power decrease for `_tokenId`\n  /// @param _tokenId token of the NFT\n  /// @return Value of the slope\n  function getLastUserSlope(uint _tokenId) external view returns (int128) {\n    uint uEpoch = userPointEpoch[_tokenId];\n    return _userPointHistory[_tokenId][uEpoch].slope;\n  }\n\n  /// @notice Get the timestamp for checkpoint `_idx` for `_tokenId`\n  /// @param _tokenId token of the NFT\n  /// @param _idx User epoch number\n  /// @return Epoch time of the checkpoint\n  function userPointHistoryTs(uint _tokenId, uint _idx) external view returns (uint) {\n    return _userPointHistory[_tokenId][_idx].ts;\n  }\n\n  /// @dev Returns the number of NFTs owned by `_owner`.\n  ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n  /// @param _owner Address for whom to query the balance.\n  function _balance(address _owner) internal view returns (uint) {\n    return _ownerToNFTokenCount[_owner];\n  }\n\n  /// @dev Returns the number of NFTs owned by `_owner`.\n  ///      Throws if `_owner` is the zero address. NFTs assigned to the zero address are considered invalid.\n  /// @param _owner Address for whom to query the balance.\n  function balanceOf(address _owner) external view override returns (uint) {\n    return _balance(_owner);\n  }\n\n  /// @dev Returns the address of the owner of the NFT.\n  /// @param _tokenId The identifier for an NFT.\n  function ownerOf(uint _tokenId) public view override returns (address) {\n    return _idToOwner[_tokenId];\n  }\n\n  /// @dev Get the approved address for a single NFT.\n  /// @param _tokenId ID of the NFT to query the approval of.\n  function getApproved(uint _tokenId) external view override returns (address) {\n    return _idToApprovals[_tokenId];\n  }\n\n  /// @dev Checks if `_operator` is an approved operator for `_owner`.\n  /// @param _owner The address that owns the NFTs.\n  /// @param _operator The address that acts on behalf of the owner.\n  function isApprovedForAll(address _owner, address _operator) external view override returns (bool) {\n    return (ownerToOperators[_owner])[_operator];\n  }\n\n  /// @dev  Get token by index\n  function tokenOfOwnerByIndex(address _owner, uint _tokenIndex) external view returns (uint) {\n    return _ownerToNFTokenIdList[_owner][_tokenIndex];\n  }\n\n  /// @dev Returns whether the given spender can transfer a given token ID\n  /// @param _spender address of the spender to query\n  /// @param _tokenId uint ID of the token to be transferred\n  /// @return bool whether the msg.sender is approved for the given token ID,\n  ///              is an operator of the owner, or is the owner of the token\n  function isApprovedOrOwner(address _spender, uint _tokenId) public view override returns (bool) {\n    address owner = _idToOwner[_tokenId];\n    bool spenderIsOwner = owner == _spender;\n    bool spenderIsApproved = _spender == _idToApprovals[_tokenId];\n    bool spenderIsApprovedForAll = (ownerToOperators[owner])[_spender];\n    return spenderIsOwner || spenderIsApproved || spenderIsApprovedForAll;\n  }\n\n  function balanceOfNFT(uint _tokenId) public view override returns (uint) {\n    // flash NFT protection\n    if (ownershipChange[_tokenId] == block.number) {\n      return 0;\n    }\n    return _balanceOfNFT(_tokenId, block.timestamp);\n  }\n\n  function balanceOfNFTAt(uint _tokenId, uint _t) external view returns (uint) {\n    return _balanceOfNFT(_tokenId, _t);\n  }\n\n  function totalSupply() external view returns (uint) {\n    return totalSupplyAtT(block.timestamp);\n  }\n\n  function balanceOfAtNFT(uint _tokenId, uint _block) external view returns (uint) {\n    return _balanceOfAtNFT(_tokenId, _block);\n  }\n\n  function userPointHistory(uint _tokenId, uint _loc) external view override returns (Point memory) {\n    return _userPointHistory[_tokenId][_loc];\n  }\n\n  function pointHistory(uint _loc) external view override returns (Point memory) {\n    return _pointHistory[_loc];\n  }\n\n  // *************************************************************\n  //                        VOTER ACTIONS\n  // *************************************************************\n\n  function _onlyVoters() internal view {\n    require(msg.sender == voter() || msg.sender == platformVoter(), \"NOT_VOTER\");\n  }\n\n  /// @dev Increment the votes counter.\n  ///      Should be called only once per any amount of votes from 1 voter contract.\n  function voting(uint _tokenId) external override {\n    _onlyVoters();\n\n    // counter reflects only amount of voter contracts\n    // restrictions for votes should be implemented on voter side\n    voted[_tokenId]++;\n  }\n\n  /// @dev Decrement the votes counter. Call only once per voter.\n  function abstain(uint _tokenId) external override {\n    _onlyVoters();\n\n    voted[_tokenId]--;\n  }\n\n  /// @dev Increment attach counter. Call it for each boosted gauge position.\n  function attachToken(uint _tokenId) external override {\n    // only central voter\n    require(msg.sender == voter(), \"NOT_VOTER\");\n\n    uint count = attachments[_tokenId];\n    require(count < MAX_ATTACHMENTS, \"TOO_MANY_ATTACHMENTS\");\n    attachments[_tokenId] = count + 1;\n  }\n\n  /// @dev Decrement attach counter. Call it for each boosted gauge position.\n  function detachToken(uint _tokenId) external override {\n    // only central voter\n    require(msg.sender == voter(), \"NOT_VOTER\");\n\n    attachments[_tokenId] = attachments[_tokenId] - 1;\n  }\n\n  /// @dev Remove all votes/attachments for given veID.\n  function _detachAll(uint _tokenId, address owner) internal {\n    IVoter(voter()).detachTokenFromAll(_tokenId, owner);\n    IPlatformVoter(platformVoter()).detachTokenFromAll(_tokenId, owner);\n  }\n\n  // *************************************************************\n  //                        NFT LOGIC\n  // *************************************************************\n\n  /// @dev Add a NFT to an index mapping to a given address\n  /// @param _to address of the receiver\n  /// @param _tokenId uint ID Of the token to be added\n  function _addTokenToOwnerList(address _to, uint _tokenId) internal {\n    uint currentCount = _balance(_to);\n\n    _ownerToNFTokenIdList[_to][currentCount] = _tokenId;\n    tokenToOwnerIndex[_tokenId] = currentCount;\n  }\n\n  /// @dev Remove a NFT from an index mapping to a given address\n  /// @param _from address of the sender\n  /// @param _tokenId uint ID Of the token to be removed\n  function _removeTokenFromOwnerList(address _from, uint _tokenId) internal {\n    // Delete\n    uint currentCount = _balance(_from) - 1;\n    uint currentIndex = tokenToOwnerIndex[_tokenId];\n\n    if (currentCount == currentIndex) {\n      // update ownerToNFTokenIdList\n      _ownerToNFTokenIdList[_from][currentCount] = 0;\n      // update tokenToOwnerIndex\n      tokenToOwnerIndex[_tokenId] = 0;\n    } else {\n      uint lastTokenId = _ownerToNFTokenIdList[_from][currentCount];\n\n      // Add\n      // update ownerToNFTokenIdList\n      _ownerToNFTokenIdList[_from][currentIndex] = lastTokenId;\n      // update tokenToOwnerIndex\n      tokenToOwnerIndex[lastTokenId] = currentIndex;\n\n      // Delete\n      // update ownerToNFTokenIdList\n      _ownerToNFTokenIdList[_from][currentCount] = 0;\n      // update tokenToOwnerIndex\n      tokenToOwnerIndex[_tokenId] = 0;\n    }\n  }\n\n  /// @dev Add a NFT to a given address\n  function _addTokenTo(address _to, uint _tokenId) internal {\n    // assume always call on new tokenId or after _removeTokenFrom() call\n    // Change the owner\n    _idToOwner[_tokenId] = _to;\n    // Update owner token index tracking\n    _addTokenToOwnerList(_to, _tokenId);\n    // Change count tracking\n    _ownerToNFTokenCount[_to] += 1;\n  }\n\n  /// @dev Remove a NFT from a given address\n  ///      Throws if `_from` is not the current owner.\n  function _removeTokenFrom(address _from, uint _tokenId) internal {\n    require(_idToOwner[_tokenId] == _from, \"NOT_OWNER\");\n    // Change the owner\n    _idToOwner[_tokenId] = address(0);\n    // Update owner token index tracking\n    _removeTokenFromOwnerList(_from, _tokenId);\n    // Change count tracking\n    _ownerToNFTokenCount[_from] -= 1;\n  }\n\n  /// @dev Execute transfer of a NFT.\n  ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\n  ///      address for this NFT. (NOTE: `msg.sender` not allowed in internal function so pass `_sender`.)\n  ///      Throws if `_to` is the zero address.\n  ///      Throws if `_from` is not the current owner.\n  ///      Throws if `_tokenId` is not a valid NFT.\n  function _transferFrom(\n    address _from,\n    address _to,\n    uint _tokenId,\n    address _sender\n  ) internal {\n    require(isApprovedOrOwner(_sender, _tokenId), \"NOT_OWNER\");\n    require(_to != address(0), \"WRONG_INPUT\");\n    // from address will be checked in _removeTokenFrom()\n\n    if (attachments[_tokenId] != 0 || voted[_tokenId] != 0) {\n      _detachAll(_tokenId, _from);\n    }\n\n    if (_idToApprovals[_tokenId] != address(0)) {\n      // Reset approvals\n      _idToApprovals[_tokenId] = address(0);\n    }\n    _removeTokenFrom(_from, _tokenId);\n    _addTokenTo(_to, _tokenId);\n    // Set the block of ownership transfer (for Flash NFT protection)\n    ownershipChange[_tokenId] = block.number;\n    // Log the transfer\n    emit Transfer(_from, _to, _tokenId);\n  }\n\n  /// @dev Transfers forbidden for veTETU\n  function transferFrom(\n    address,\n    address,\n    uint\n  ) external pure override {\n    revert(\"FORBIDDEN\");\n    //    _transferFrom(_from, _to, _tokenId, msg.sender);\n  }\n\n  function _isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize, which returns 0 for contracts in\n    // construction, since the code is only stored at the end of the\n    // constructor execution.\n    uint size;\n    assembly {\n      size := extcodesize(account)\n    }\n    return size > 0;\n  }\n\n  /// @dev Transfers the ownership of an NFT from one address to another address.\n  ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n  ///      approved address for this NFT.\n  ///      Throws if `_from` is not the current owner.\n  ///      Throws if `_to` is the zero address.\n  ///      Throws if `_tokenId` is not a valid NFT.\n  ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n  ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n  /// @param _from The current owner of the NFT.\n  /// @param _to The new owner.\n  /// @param _tokenId The NFT to transfer.\n  /// @param _data Additional data with no specified format, sent in call to `_to`.\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId,\n    bytes memory _data\n  ) public override {\n    require(isWhitelistedTransfer[_to] || isWhitelistedTransfer[_from], \"FORBIDDEN\");\n\n    _transferFrom(_from, _to, _tokenId, msg.sender);\n    require(_checkOnERC721Received(_from, _to, _tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n  }\n\n\n  /// @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n  /// The call is not executed if the target address is not a contract.\n  ///\n  /// @param _from address representing the previous owner of the given token ID\n  /// @param _to target address that will receive the tokens\n  /// @param _tokenId uint256 ID of the token to be transferred\n  /// @param _data bytes optional data to send along with the call\n  /// @return bool whether the call correctly returned the expected magic value\n  ///\n  function _checkOnERC721Received(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes memory _data\n  ) private returns (bool) {\n    if (_isContract(_to)) {\n      try IERC721Receiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) returns (bytes4 retval) {\n        return retval == IERC721Receiver.onERC721Received.selector;\n      } catch (bytes memory reason) {\n        if (reason.length == 0) {\n          revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n        } else {\n          /// @solidity memory-safe-assembly\n          assembly {\n            revert(add(32, reason), mload(reason))\n          }\n        }\n      }\n    } else {\n      return true;\n    }\n  }\n\n  /// @dev Transfers the ownership of an NFT from one address to another address.\n  ///      Throws unless `msg.sender` is the current owner, an authorized operator, or the\n  ///      approved address for this NFT.\n  ///      Throws if `_from` is not the current owner.\n  ///      Throws if `_to` is the zero address.\n  ///      Throws if `_tokenId` is not a valid NFT.\n  ///      If `_to` is a smart contract, it calls `onERC721Received` on `_to` and throws if\n  ///      the return value is not `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`.\n  /// @param _from The current owner of the NFT.\n  /// @param _to The new owner.\n  /// @param _tokenId The NFT to transfer.\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint _tokenId\n  ) external override {\n    safeTransferFrom(_from, _to, _tokenId, \"\");\n  }\n\n  /// @dev Set or reaffirm the approved address for an NFT. The zero address indicates there is no approved address.\n  ///      Throws unless `msg.sender` is the current NFT owner, or an authorized operator of the current owner.\n  ///      Throws if `_tokenId` is not a valid NFT. (NOTE: This is not written the EIP)\n  ///      Throws if `_approved` is the current owner. (NOTE: This is not written the EIP)\n  /// @param _approved Address to be approved for the given NFT ID.\n  /// @param _tokenId ID of the token to be approved.\n  function approve(address _approved, uint _tokenId) public override {\n    address owner = _idToOwner[_tokenId];\n    // Throws if `_tokenId` is not a valid NFT\n    require(owner != address(0), \"WRONG_INPUT\");\n    // Throws if `_approved` is the current owner\n    require(_approved != owner, \"IDENTICAL_ADDRESS\");\n    // Check requirements\n    bool senderIsOwner = (owner == msg.sender);\n    bool senderIsApprovedForAll = (ownerToOperators[owner])[msg.sender];\n    require(senderIsOwner || senderIsApprovedForAll, \"NOT_OWNER\");\n    // Set the approval\n    _idToApprovals[_tokenId] = _approved;\n    emit Approval(owner, _approved, _tokenId);\n  }\n\n  /// @dev Enables or disables approval for a third party (\"operator\") to manage all of\n  ///      `msg.sender`'s assets. It also emits the ApprovalForAll event.\n  ///      Throws if `_operator` is the `msg.sender`. (NOTE: This is not written the EIP)\n  /// @notice This works even if sender doesn't own any tokens at the time.\n  /// @param _operator Address to add to the set of authorized operators.\n  /// @param _approved True if the operators is approved, false to revoke approval.\n  function setApprovalForAll(address _operator, bool _approved) external override {\n    // Throws if `_operator` is the `msg.sender`\n    require(_operator != msg.sender, \"IDENTICAL_ADDRESS\");\n    ownerToOperators[msg.sender][_operator] = _approved;\n    emit ApprovalForAll(msg.sender, _operator, _approved);\n  }\n\n  /// @dev Function to mint tokens\n  ///      Throws if `_to` is zero address.\n  ///      Throws if `_tokenId` is owned by someone.\n  /// @param _to The address that will receive the minted tokens.\n  /// @param _tokenId The token id to mint.\n  /// @return A boolean that indicates if the operation was successful.\n  function _mint(address _to, uint _tokenId) internal returns (bool) {\n    // Throws if `_to` is zero address\n    require(_to != address(0), \"WRONG_INPUT\");\n    _addTokenTo(_to, _tokenId);\n    require(_checkOnERC721Received(address(0), _to, _tokenId, ''), \"ERC721: transfer to non ERC721Receiver implementer\");\n    emit Transfer(address(0), _to, _tokenId);\n    return true;\n  }\n\n  /// @notice Record global and per-user data to checkpoint\n  function _checkpoint(CheckpointInfo memory info) internal {\n    Point memory uOld;\n    Point memory uNew;\n    int128 oldDSlope = 0;\n    int128 newDSlope = 0;\n    uint _epoch = epoch;\n\n    if (info.tokenId != 0) {\n      // Calculate slopes and biases\n      // Kept at zero when they have to\n      if (info.oldEnd > block.timestamp && info.oldDerivedAmount > 0) {\n        uOld.slope = int128(uint128(info.oldDerivedAmount)) / I_MAX_TIME;\n        uOld.bias = uOld.slope * int128(int256(info.oldEnd - block.timestamp));\n      }\n      if (info.newEnd > block.timestamp && info.newDerivedAmount > 0) {\n        uNew.slope = int128(uint128(info.newDerivedAmount)) / I_MAX_TIME;\n        uNew.bias = uNew.slope * int128(int256(info.newEnd - block.timestamp));\n      }\n\n      // Read values of scheduled changes in the slope\n      // oldLocked.end can be in the past and in the future\n      // newLocked.end can ONLY by in the FUTURE unless everything expired: than zeros\n      oldDSlope = slopeChanges[info.oldEnd];\n      if (info.newEnd != 0) {\n        if (info.newEnd == info.oldEnd) {\n          newDSlope = oldDSlope;\n        } else {\n          newDSlope = slopeChanges[info.newEnd];\n        }\n      }\n    }\n\n    Point memory lastPoint = Point({bias : 0, slope : 0, ts : block.timestamp, blk : block.number});\n    if (_epoch > 0) {\n      lastPoint = _pointHistory[_epoch];\n    }\n    uint lastCheckpoint = lastPoint.ts;\n    // initialLastPoint is used for extrapolation to calculate block number\n    // (approximately, for *At methods) and save them\n    // as we cannot figure that out exactly from inside the contract\n    Point memory initialLastPoint = lastPoint;\n    uint blockSlope = 0;\n    // dblock/dt\n    if (block.timestamp > lastPoint.ts) {\n      blockSlope = (MULTIPLIER * (block.number - lastPoint.blk)) / (block.timestamp - lastPoint.ts);\n    }\n    // If last point is already recorded in this block, slope=0\n    // But that's ok b/c we know the block in such case\n\n    // Go over weeks to fill history and calculate what the current point is\n    {\n      uint ti = (lastCheckpoint / WEEK) * WEEK;\n      // Hopefully it won't happen that this won't get used in 5 years!\n      // If it does, users will be able to withdraw but vote weight will be broken\n      for (uint i = 0; i < 255; ++i) {\n        ti += WEEK;\n        int128 dSlope = 0;\n        if (ti > block.timestamp) {\n          ti = block.timestamp;\n        } else {\n          dSlope = slopeChanges[ti];\n        }\n        lastPoint.bias = (lastPoint.bias - lastPoint.slope * int128(int256(ti - lastCheckpoint))).positiveInt128();\n        lastPoint.slope = (lastPoint.slope + dSlope).positiveInt128();\n        lastCheckpoint = ti;\n        lastPoint.ts = ti;\n        lastPoint.blk = initialLastPoint.blk + (blockSlope * (ti - initialLastPoint.ts)) / MULTIPLIER;\n        _epoch += 1;\n        if (ti == block.timestamp) {\n          lastPoint.blk = block.number;\n          break;\n        } else {\n          _pointHistory[_epoch] = lastPoint;\n        }\n      }\n    }\n\n    epoch = _epoch;\n    // Now pointHistory is filled until t=now\n\n    if (info.tokenId != 0) {\n      // If last point was in this block, the slope change has been applied already\n      // But in such case we have 0 slope(s)\n      lastPoint.slope = (lastPoint.slope + (uNew.slope - uOld.slope)).positiveInt128();\n      lastPoint.bias = (lastPoint.bias + (uNew.bias - uOld.bias)).positiveInt128();\n    }\n\n    // Record the changed point into history\n    _pointHistory[_epoch] = lastPoint;\n\n    if (info.tokenId != 0) {\n      // Schedule the slope changes (slope is going down)\n      // We subtract newUserSlope from [newLocked.end]\n      // and add old_user_slope to [old_locked.end]\n      if (info.oldEnd > block.timestamp) {\n        // old_dslope was <something> - u_old.slope, so we cancel that\n        oldDSlope += uOld.slope;\n        if (info.newEnd == info.oldEnd) {\n          oldDSlope -= uNew.slope;\n          // It was a new deposit, not extension\n        }\n        slopeChanges[info.oldEnd] = oldDSlope;\n      }\n\n      if (info.newEnd > block.timestamp) {\n        if (info.newEnd > info.oldEnd) {\n          newDSlope -= uNew.slope;\n          // old slope disappeared at this point\n          slopeChanges[info.newEnd] = newDSlope;\n        }\n        // else: we recorded it already in oldDSlope\n      }\n      // Now handle user history\n      uint userEpoch = userPointEpoch[info.tokenId] + 1;\n\n      userPointEpoch[info.tokenId] = userEpoch;\n      uNew.ts = block.timestamp;\n      uNew.blk = block.number;\n      _userPointHistory[info.tokenId][userEpoch] = uNew;\n    }\n  }\n\n  // *************************************************************\n  //                  DEPOSIT/WITHDRAW LOGIC\n  // *************************************************************\n\n  /// @dev Pull tokens to this contract and try to stake\n  function _pullStakingToken(address _token, address _from, uint amount) internal {\n    IERC20(_token).safeTransferFrom(_from, address(this), amount);\n\n    // try to stake tokens if possible\n    _stakeAvailableTokens(_token);\n  }\n\n  /// @dev Anyone can stake whitelisted tokens if they exist on this contract.\n  function stakeAvailableTokens(address _token) external {\n    _stakeAvailableTokens(_token);\n  }\n\n  /// @dev If allowed, stake given token available balance to suitable place for earn some profit\n  function _stakeAvailableTokens(address _token) internal {\n    if (tokenFarmingStatus[_token]) {\n      if (_token == _TETU_USDC_BPT) {\n        uint balance = IERC20(_token).balanceOf(address(this));\n        if (balance != 0) {\n          IERC20(_token).safeApprove(_TETU_USDC_BPT_VAULT, balance);\n          ISmartVault(_TETU_USDC_BPT_VAULT).depositAndInvest(balance);\n        }\n      }\n    }\n  }\n\n  /// @dev Unstake necessary amount, if possible\n  function _unstakeTokens(address _token, uint amount) internal {\n    uint tokenBalance = IERC20(_token).balanceOf(address(this));\n    if (amount != 0 && amount > tokenBalance) {\n      // withdraw only required amount\n      amount -= tokenBalance;\n      // no need to check whitelisting for withdraw\n      if (_token == _TETU_USDC_BPT) {\n        // add gap value for avoid rounding issues\n        uint shares = amount * 1e18 / ISmartVault(_TETU_USDC_BPT_VAULT).getPricePerFullShare() + 1e18;\n        uint sharesBalance = IERC20(_TETU_USDC_BPT_VAULT).balanceOf(address(this));\n        shares = shares > sharesBalance ? sharesBalance : shares;\n        ISmartVault(_TETU_USDC_BPT_VAULT).withdraw(shares);\n      }\n    }\n  }\n\n  /// @dev Anyone can withdraw all staked tokens if farming status = false\n  function emergencyWithdrawStakedTokens(address _token) external {\n    if (!tokenFarmingStatus[_token]) {\n      if (_token == _TETU_USDC_BPT) {\n        ISmartVault(_TETU_USDC_BPT_VAULT).exit();\n      }\n    }\n  }\n\n  /// @dev Transfer underlying token to recipient, unstake if need required amount\n  function _transferUnderlyingToken(address _token, address recipient, uint amount) internal {\n    _unstakeTokens(_token, amount);\n    IERC20(_token).safeTransfer(recipient, amount);\n  }\n\n  /// @notice Deposit and lock tokens for a user\n  function _depositFor(DepositInfo memory info) internal {\n\n    uint newLockedDerivedAmount = info.lockedDerivedAmount;\n    if (info.value != 0) {\n\n      // calculate new amounts\n      uint newAmount = info.lockedAmount + info.value;\n      newLockedDerivedAmount = _calculateDerivedAmount(\n        info.lockedAmount,\n        info.lockedDerivedAmount,\n        newAmount,\n        tokenWeights[info.stakingToken],\n        IERC20Metadata(info.stakingToken).decimals()\n      );\n      // update chain info\n      lockedAmounts[info.tokenId][info.stakingToken] = newAmount;\n      lockedDerivedAmount[info.tokenId] = newLockedDerivedAmount;\n    }\n\n    // Adding to existing lock, or if a lock is expired - creating a new one\n    uint newLockedEnd = info.lockedEnd;\n    if (info.unlockTime != 0) {\n      lockedEnd[info.tokenId] = info.unlockTime;\n      newLockedEnd = info.unlockTime;\n    }\n\n    // update checkpoint\n    _checkpoint(CheckpointInfo(\n        info.tokenId,\n        info.lockedDerivedAmount,\n        newLockedDerivedAmount,\n        info.lockedEnd,\n        newLockedEnd\n      ));\n\n    // move tokens to this contract, if necessary\n    address from = msg.sender;\n    if (info.value != 0 && info.depositType != DepositType.MERGE_TYPE) {\n      _pullStakingToken(info.stakingToken, from, info.value);\n    }\n\n    emit Deposit(info.stakingToken, from, info.tokenId, info.value, newLockedEnd, info.depositType, block.timestamp);\n  }\n\n  function _calculateDerivedAmount(\n    uint currentAmount,\n    uint oldDerivedAmount,\n    uint newAmount,\n    uint weight,\n    uint8 decimals\n  ) internal pure returns (uint) {\n    // subtract current derived balance\n    // rounded to UP for subtracting closer to 0 value\n    if (oldDerivedAmount != 0 && currentAmount != 0) {\n      currentAmount = currentAmount.divWadUp(10 ** decimals);\n      uint currentDerivedAmount = currentAmount.mulDivUp(weight, WEIGHT_DENOMINATOR);\n      if (oldDerivedAmount > currentDerivedAmount) {\n        oldDerivedAmount -= currentDerivedAmount;\n      } else {\n        // in case of wrong rounding better to set to zero than revert\n        oldDerivedAmount = 0;\n      }\n    }\n\n    // recalculate derived amount with new amount\n    // rounded to DOWN\n    // normalize decimals to 18\n    newAmount = newAmount.divWadDown(10 ** decimals);\n    // calculate the final amount based on the weight\n    newAmount = newAmount.mulDivDown(weight, WEIGHT_DENOMINATOR);\n    return oldDerivedAmount + newAmount;\n  }\n\n  /// @notice Record global data to checkpoint\n  function checkpoint() external override {\n    _checkpoint(CheckpointInfo(0, 0, 0, 0, 0));\n  }\n\n  function _lockInfo(address stakingToken, uint veId) internal view returns (\n    uint _lockedAmount,\n    uint _lockedDerivedAmount,\n    uint _lockedEnd\n  ) {\n    _lockedAmount = lockedAmounts[veId][stakingToken];\n    _lockedDerivedAmount = lockedDerivedAmount[veId];\n    _lockedEnd = lockedEnd[veId];\n  }\n\n  function _incrementTokenIdAndGet() internal returns (uint){\n    uint current = tokenId;\n    tokenId = current + 1;\n    return current + 1;\n  }\n\n  /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n  /// @param _token Token for deposit. Should be whitelisted in this contract.\n  /// @param _value Amount to deposit\n  /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n  /// @param _to Address to deposit\n  function _createLock(address _token, uint _value, uint _lockDuration, address _to) internal returns (uint) {\n    require(_value > 0, \"WRONG_INPUT\");\n    // Lock time is rounded down to weeks\n    uint unlockTime = (block.timestamp + _lockDuration) / WEEK * WEEK;\n    require(unlockTime > block.timestamp, \"LOW_LOCK_PERIOD\");\n    require(unlockTime <= block.timestamp + MAX_TIME, \"HIGH_LOCK_PERIOD\");\n    require(isValidToken[_token], \"INVALID_TOKEN\");\n\n    uint _tokenId = _incrementTokenIdAndGet();\n    _mint(_to, _tokenId);\n\n    _depositFor(DepositInfo({\n    stakingToken : _token,\n    tokenId : _tokenId,\n    value : _value,\n    unlockTime : unlockTime,\n    lockedAmount : 0,\n    lockedDerivedAmount : 0,\n    lockedEnd : 0,\n    depositType : DepositType.CREATE_LOCK_TYPE\n    }));\n    return _tokenId;\n  }\n\n  /// @notice Deposit `_value` tokens for `_to` and lock for `_lock_duration`\n  /// @param _token Token for deposit. Should be whitelisted in this contract.\n  /// @param _value Amount to deposit\n  /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n  /// @param _to Address to deposit\n  function createLockFor(address _token, uint _value, uint _lockDuration, address _to)\n  external nonReentrant override returns (uint) {\n    return _createLock(_token, _value, _lockDuration, _to);\n  }\n\n  /// @notice Deposit `_value` tokens for `msg.sender` and lock for `_lock_duration`\n  /// @param _value Amount to deposit\n  /// @param _lockDuration Number of seconds to lock tokens for (rounded down to nearest week)\n  function createLock(address _token, uint _value, uint _lockDuration) external nonReentrant returns (uint) {\n    return _createLock(_token, _value, _lockDuration, msg.sender);\n  }\n\n  /// @notice Deposit `_value` additional tokens for `_tokenId` without modifying the unlock time\n  /// @dev Anyone (even a smart contract) can deposit for someone else, but\n  ///      cannot extend their locktime and deposit for a brand new user\n  /// @param _token Token for deposit. Should be whitelisted in this contract.\n  /// @param _tokenId ve token ID\n  /// @param _value Amount of tokens to deposit and add to the lock\n  function increaseAmount(address _token, uint _tokenId, uint _value) external nonReentrant override {\n    require(_value > 0, \"WRONG_INPUT\");\n    (uint _lockedAmount, uint _lockedDerivedAmount, uint _lockedEnd) = _lockInfo(_token, _tokenId);\n\n    require(_lockedDerivedAmount > 0, \"NFT_WITHOUT_POWER\");\n    require(_lockedEnd > block.timestamp, \"EXPIRED\");\n    require(isValidToken[_token], \"INVALID_TOKEN\");\n\n    _depositFor(DepositInfo({\n    stakingToken : _token,\n    tokenId : _tokenId,\n    value : _value,\n    unlockTime : 0,\n    lockedAmount : _lockedAmount,\n    lockedDerivedAmount : _lockedDerivedAmount,\n    lockedEnd : _lockedEnd,\n    depositType : DepositType.INCREASE_LOCK_AMOUNT\n    }));\n  }\n\n  /// @notice Extend the unlock time for `_tokenId`\n  /// @param _tokenId ve token ID\n  /// @param _lockDuration New number of seconds until tokens unlock\n  function increaseUnlockTime(uint _tokenId, uint _lockDuration) external nonReentrant returns (\n    uint power,\n    uint unlockDate\n  )  {\n    uint _lockedDerivedAmount = lockedDerivedAmount[_tokenId];\n    uint _lockedEnd = lockedEnd[_tokenId];\n    // Lock time is rounded down to weeks\n    uint unlockTime = (block.timestamp + _lockDuration) / WEEK * WEEK;\n    require(_lockedDerivedAmount > 0, \"NFT_WITHOUT_POWER\");\n    require(_lockedEnd > block.timestamp, \"EXPIRED\");\n    require(unlockTime > _lockedEnd, \"LOW_UNLOCK_TIME\");\n    require(unlockTime <= block.timestamp + MAX_TIME, \"HIGH_LOCK_PERIOD\");\n    require(isApprovedOrOwner(msg.sender, _tokenId), \"NOT_OWNER\");\n\n    _depositFor(DepositInfo({\n    stakingToken : address(0),\n    tokenId : _tokenId,\n    value : 0,\n    unlockTime : unlockTime,\n    lockedAmount : 0,\n    lockedDerivedAmount : _lockedDerivedAmount,\n    lockedEnd : _lockedEnd,\n    depositType : DepositType.INCREASE_UNLOCK_TIME\n    }));\n\n    power = balanceOfNFT(_tokenId);\n    unlockDate = lockedEnd[_tokenId];\n  }\n\n  /// @dev Merge two NFTs union their balances and keep the biggest lock time.\n  function merge(uint _from, uint _to) external nonReentrant {\n    require(attachments[_from] == 0 && voted[_from] == 0, \"ATTACHED\");\n    require(_from != _to, \"IDENTICAL_ADDRESS\");\n    require(_idToOwner[_from] == msg.sender && _idToOwner[_to] == msg.sender, \"NOT_OWNER\");\n\n    uint lockedEndFrom = lockedEnd[_from];\n    uint lockedEndTo = lockedEnd[_to];\n    uint end = lockedEndFrom >= lockedEndTo ? lockedEndFrom : lockedEndTo;\n    uint oldDerivedAmount = lockedDerivedAmount[_from];\n\n    uint length = tokens.length;\n    // we should use the old one for properly calculate checkpoint for the new ve\n    uint newLockedEndTo = lockedEndTo;\n    for (uint i; i < length; i++) {\n      address stakingToken = tokens[i];\n      uint _lockedAmountFrom = lockedAmounts[_from][stakingToken];\n      if (_lockedAmountFrom == 0) {\n        continue;\n      }\n      lockedAmounts[_from][stakingToken] = 0;\n\n      _depositFor(DepositInfo({\n      stakingToken : stakingToken,\n      tokenId : _to,\n      value : _lockedAmountFrom,\n      unlockTime : end,\n      lockedAmount : lockedAmounts[_to][stakingToken],\n      lockedDerivedAmount : lockedDerivedAmount[_to],\n      lockedEnd : newLockedEndTo,\n      depositType : DepositType.MERGE_TYPE\n      }));\n\n      // set new lock time to the current end lock\n      newLockedEndTo = end;\n\n      emit Merged(stakingToken, msg.sender, _from, _to);\n    }\n\n    lockedDerivedAmount[_from] = 0;\n    lockedEnd[_from] = 0;\n\n    // update checkpoint\n    _checkpoint(CheckpointInfo(\n        _from,\n        oldDerivedAmount,\n        0,\n        lockedEndFrom,\n        lockedEndFrom\n      ));\n\n    _burn(_from);\n  }\n\n  /// @dev Split given veNFT. A new NFT will have a given percent of underlying tokens.\n  /// @param _tokenId ve token ID\n  /// @param percent percent of underlying tokens for new NFT with denominator 1e18 (1-(100e18-1)).\n  function split(uint _tokenId, uint percent) external nonReentrant {\n    require(attachments[_tokenId] == 0 && voted[_tokenId] == 0, \"ATTACHED\");\n    require(_idToOwner[_tokenId] == msg.sender, \"NOT_OWNER\");\n    require(percent != 0 && percent < 100e18, \"WRONG_INPUT\");\n\n    uint _lockedDerivedAmount = lockedDerivedAmount[_tokenId];\n    uint oldLockedDerivedAmount = _lockedDerivedAmount;\n    uint _lockedEnd = lockedEnd[_tokenId];\n\n    require(_lockedEnd > block.timestamp, \"EXPIRED\");\n\n    // crete new NFT\n    uint _newTokenId = _incrementTokenIdAndGet();\n    _mint(msg.sender, _newTokenId);\n\n    // migrate percent of locked tokens to the new NFT\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      address stakingToken = tokens[i];\n      uint _lockedAmount = lockedAmounts[_tokenId][stakingToken];\n      if (_lockedAmount == 0) {\n        continue;\n      }\n      uint amountForNewNFT = _lockedAmount * percent / 100e18;\n      require(amountForNewNFT != 0, \"LOW_PERCENT\");\n\n      uint newLockedDerivedAmount = _calculateDerivedAmount(\n        _lockedAmount,\n        _lockedDerivedAmount,\n        _lockedAmount - amountForNewNFT,\n        tokenWeights[stakingToken],\n        IERC20Metadata(stakingToken).decimals()\n      );\n\n      _lockedDerivedAmount = newLockedDerivedAmount;\n\n      lockedAmounts[_tokenId][stakingToken] = _lockedAmount - amountForNewNFT;\n\n      // increase values for new NFT\n      _depositFor(DepositInfo({\n      stakingToken : stakingToken,\n      tokenId : _newTokenId,\n      value : amountForNewNFT,\n      unlockTime : _lockedEnd,\n      lockedAmount : 0,\n      lockedDerivedAmount : lockedDerivedAmount[_newTokenId],\n      lockedEnd : _lockedEnd,\n      depositType : DepositType.MERGE_TYPE\n      }));\n    }\n\n    // update derived amount\n    lockedDerivedAmount[_tokenId] = _lockedDerivedAmount;\n\n    // update checkpoint\n    _checkpoint(CheckpointInfo(\n        _tokenId,\n        oldLockedDerivedAmount,\n        _lockedDerivedAmount,\n        _lockedEnd,\n        _lockedEnd\n      ));\n\n    emit Split(_tokenId, _newTokenId, percent);\n  }\n\n  /// @notice Withdraw all staking tokens for `_tokenId`\n  /// @dev Only possible if the lock has expired\n  function withdrawAll(uint _tokenId) external {\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      address token = tokens[i];\n      if (lockedAmounts[_tokenId][token] != 0) {\n        withdraw(token, _tokenId);\n      }\n    }\n  }\n\n  /// @notice Withdraw given staking token for `_tokenId`\n  /// @dev Only possible if the lock has expired\n  function withdraw(address stakingToken, uint _tokenId) public nonReentrant {\n    require(isApprovedOrOwner(msg.sender, _tokenId), \"NOT_OWNER\");\n    require(attachments[_tokenId] == 0 && voted[_tokenId] == 0, \"ATTACHED\");\n\n    (uint oldLockedAmount, uint oldLockedDerivedAmount, uint oldLockedEnd) =\n    _lockInfo(stakingToken, _tokenId);\n    require(block.timestamp >= oldLockedEnd, \"NOT_EXPIRED\");\n    require(oldLockedAmount > 0, \"ZERO_LOCKED\");\n\n\n    uint newLockedDerivedAmount = _calculateDerivedAmount(\n      oldLockedAmount,\n      oldLockedDerivedAmount,\n      0,\n      tokenWeights[stakingToken],\n      IERC20Metadata(stakingToken).decimals()\n    );\n\n    // if no tokens set lock to zero\n    uint newLockEnd = oldLockedEnd;\n    if (newLockedDerivedAmount == 0) {\n      lockedEnd[_tokenId] = 0;\n      newLockEnd = 0;\n    }\n\n    // update derived amount\n    lockedDerivedAmount[_tokenId] = newLockedDerivedAmount;\n\n    // set locked amount to zero, we will withdraw all\n    lockedAmounts[_tokenId][stakingToken] = 0;\n\n    // update checkpoint\n    _checkpoint(CheckpointInfo(\n        _tokenId,\n        oldLockedDerivedAmount,\n        newLockedDerivedAmount,\n        oldLockedEnd,\n        newLockEnd\n      ));\n\n    // Burn the NFT\n    if (newLockedDerivedAmount == 0) {\n      _burn(_tokenId);\n    }\n\n    _transferUnderlyingToken(stakingToken, msg.sender, oldLockedAmount);\n\n    emit Withdraw(stakingToken, msg.sender, _tokenId, oldLockedAmount, block.timestamp);\n  }\n\n  // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n  // They measure the weights for the purpose of voting, so they don't represent\n  // real coins.\n\n  /// @notice Binary search to estimate timestamp for block number\n  /// @param _block Block to find\n  /// @param maxEpoch Don't go beyond this epoch\n  /// @return Approximate timestamp for block\n  function _findBlockEpoch(uint _block, uint maxEpoch) internal view returns (uint) {\n    // Binary search\n    uint _min = 0;\n    uint _max = maxEpoch;\n    for (uint i = 0; i < 128; ++i) {\n      // Will be always enough for 128-bit numbers\n      if (_min >= _max) {\n        break;\n      }\n      uint _mid = (_min + _max + 1) / 2;\n      if (_pointHistory[_mid].blk <= _block) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n    return _min;\n  }\n\n  /// @notice Get the current voting power for `_tokenId`\n  /// @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n  /// @param _tokenId NFT for lock\n  /// @param _t Epoch time to return voting power at\n  /// @return User voting power\n  function _balanceOfNFT(uint _tokenId, uint _t) internal view returns (uint) {\n    uint _epoch = userPointEpoch[_tokenId];\n    if (_epoch == 0) {\n      return 0;\n    } else {\n      Point memory lastPoint = _userPointHistory[_tokenId][_epoch];\n      require(_t >= lastPoint.ts, \"WRONG_INPUT\");\n      lastPoint.bias -= lastPoint.slope * int128(int256(_t) - int256(lastPoint.ts));\n      if (lastPoint.bias < 0) {\n        lastPoint.bias = 0;\n      }\n      return uint(int256(lastPoint.bias));\n    }\n  }\n\n  /// @dev Returns current token URI metadata\n  /// @param _tokenId Token ID to fetch URI for.\n  function tokenURI(uint _tokenId) external view override returns (string memory) {\n    require(_idToOwner[_tokenId] != address(0), \"TOKEN_NOT_EXIST\");\n\n    uint _lockedEnd = lockedEnd[_tokenId];\n    return\n    VeTetuLogo.tokenURI(\n      _tokenId,\n      uint(int256(lockedDerivedAmount[_tokenId])),\n      block.timestamp < _lockedEnd ? _lockedEnd - block.timestamp : 0,\n      _balanceOfNFT(_tokenId, block.timestamp)\n    );\n  }\n\n  /// @notice Measure voting power of `_tokenId` at block height `_block`\n  /// @dev Adheres to MiniMe `balanceOfAt` interface: https://github.com/Giveth/minime\n  /// @param _tokenId User's wallet NFT\n  /// @param _block Block to calculate the voting power at\n  /// @return Voting power\n  function _balanceOfAtNFT(uint _tokenId, uint _block) internal view returns (uint) {\n    // Copying and pasting totalSupply code because Vyper cannot pass by\n    // reference yet\n    require(_block <= block.number, \"WRONG_INPUT\");\n\n    // Binary search\n    uint _min = 0;\n    uint _max = userPointEpoch[_tokenId];\n    for (uint i = 0; i < 128; ++i) {\n      // Will be always enough for 128-bit numbers\n      if (_min >= _max) {\n        break;\n      }\n      uint _mid = (_min + _max + 1) / 2;\n      if (_userPointHistory[_tokenId][_mid].blk <= _block) {\n        _min = _mid;\n      } else {\n        _max = _mid - 1;\n      }\n    }\n\n    Point memory uPoint = _userPointHistory[_tokenId][_min];\n\n    uint maxEpoch = epoch;\n    uint _epoch = _findBlockEpoch(_block, maxEpoch);\n    Point memory point0 = _pointHistory[_epoch];\n    uint dBlock = 0;\n    uint dt = 0;\n    if (_epoch < maxEpoch) {\n      Point memory point1 = _pointHistory[_epoch + 1];\n      dBlock = point1.blk - point0.blk;\n      dt = point1.ts - point0.ts;\n    } else {\n      dBlock = block.number - point0.blk;\n      dt = block.timestamp - point0.ts;\n    }\n    uint blockTime = point0.ts;\n    if (dBlock != 0 && _block > point0.blk) {\n      blockTime += (dt * (_block - point0.blk)) / dBlock;\n    }\n\n    uPoint.bias -= uPoint.slope * int128(int256(blockTime - uPoint.ts));\n    return uint(uint128(uPoint.bias.positiveInt128()));\n  }\n\n\n\n  /// @notice Calculate total voting power at some point in the past\n  /// @param point The point (bias/slope) to start search from\n  /// @param t Time to calculate the total voting power at\n  /// @return Total voting power at that time\n  function _supplyAt(Point memory point, uint t) internal view returns (uint) {\n    Point memory lastPoint = point;\n    uint ti = (lastPoint.ts / WEEK) * WEEK;\n    for (uint i = 0; i < 255; ++i) {\n      ti += WEEK;\n      int128 dSlope = 0;\n      if (ti > t) {\n        ti = t;\n      } else {\n        dSlope = slopeChanges[ti];\n      }\n      lastPoint.bias -= lastPoint.slope * int128(int256(ti - lastPoint.ts));\n      if (ti == t) {\n        break;\n      }\n      lastPoint.slope += dSlope;\n      lastPoint.ts = ti;\n    }\n    return uint(uint128(lastPoint.bias.positiveInt128()));\n  }\n\n  /// @notice Calculate total voting power\n  /// @dev Adheres to the ERC20 `totalSupply` interface for Aragon compatibility\n  /// @return Total voting power\n  function totalSupplyAtT(uint t) public view returns (uint) {\n    uint _epoch = epoch;\n    Point memory lastPoint = _pointHistory[_epoch];\n    return _supplyAt(lastPoint, t);\n  }\n\n  /// @notice Calculate total voting power at some point in the past\n  /// @param _block Block to calculate the total voting power at\n  /// @return Total voting power at `_block`\n  function totalSupplyAt(uint _block) external view override returns (uint) {\n    require(_block <= block.number, \"WRONG_INPUT\");\n    uint _epoch = epoch;\n    uint targetEpoch = _findBlockEpoch(_block, _epoch);\n\n    Point memory point = _pointHistory[targetEpoch];\n    // it is possible only for a block before the launch\n    // return 0 as more clear answer than revert\n    if (point.blk > _block) {\n      return 0;\n    }\n    uint dt = 0;\n    if (targetEpoch < _epoch) {\n      Point memory pointNext = _pointHistory[targetEpoch + 1];\n      // next point block can not be the same or lower\n      dt = ((_block - point.blk) * (pointNext.ts - point.ts)) / (pointNext.blk - point.blk);\n    } else {\n      if (point.blk != block.number) {\n        dt = ((_block - point.blk) * (block.timestamp - point.ts)) / (block.number - point.blk);\n      }\n    }\n    // Now dt contains info on how far are we beyond point\n    return _supplyAt(point, point.ts + dt);\n  }\n\n  function _burn(uint _tokenId) internal {\n    address owner = ownerOf(_tokenId);\n    // Clear approval\n    approve(address(0), _tokenId);\n    // Remove token\n    _removeTokenFrom(owner, _tokenId);\n    emit Transfer(owner, address(0), _tokenId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/ve/VeTetuLogo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../lib/Base64.sol\";\n\n/// @title Library for storing SVG image of veNFT.\n/// @author belbix\nlibrary VeTetuLogo {\n\n  /// @dev Return SVG logo of veTETU.\n  function tokenURI(uint _tokenId, uint _balanceOf, uint untilEnd, uint _value) public pure returns (string memory output) {\n    output = '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 600 900\"><style>.base{font-size:40px;}</style><rect fill=\"#193180\" width=\"600\" height=\"900\"/><path fill=\"#4899F8\" d=\"M0,900h600V522.2C454.4,517.2,107.4,456.8,60.2,0H0V900z\"/><circle fill=\"#1B184E\" cx=\"385\" cy=\"212\" r=\"180\"/><circle fill=\"#04A8F0\" cx=\"385\" cy=\"142\" r=\"42\"/><path fill-rule=\"evenodd\" clip-rule=\"evenodd\" fill=\"#686DF1\" d=\"M385.6,208.8c43.1,0,78-34.9,78-78c-1.8-21.1,16.2-21.1,21.1-15.4c0.4,0.3,0.7,0.7,1.1,1.2c16.7,21.5,26.6,48.4,26.6,77.7c0,25.8-24.4,42.2-50.2,42.2H309c-25.8,0-50.2-16.4-50.2-42.2c0-29.3,9.9-56.3,26.6-77.7c0.3-0.4,0.7-0.8,1.1-1.2c4.9-5.7,22.9-5.7,21.1,15.4l0,0C307.6,173.9,342.5,208.8,385.6,208.8z\"/><path fill=\"#04A8F0\" d=\"M372.3,335.9l-35.5-51.2c-7.5-10.8,0.2-25.5,13.3-25.5h35.5h35.5c13.1,0,20.8,14.7,13.3,25.5l-35.5,51.2C392.5,345.2,378.7,345.2,372.3,335.9z\"/>';\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 464)\" fill=\"#EAECFE\" class=\"base\">ID:</text><text transform=\"matrix(1 0 0 1 50 506)\" fill=\"#97D0FF\" class=\"base\">', _toString(_tokenId), '</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 579)\" fill=\"#EAECFE\" class=\"base\">Balance:</text><text transform=\"matrix(1 0 0 1 50 621)\" fill=\"#97D0FF\" class=\"base\">', _toString(_balanceOf / 1e18), '</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 695)\" fill=\"#EAECFE\" class=\"base\">Until unlock:</text><text transform=\"matrix(1 0 0 1 50 737)\" fill=\"#97D0FF\" class=\"base\">', _toString(untilEnd / 60 / 60 / 24), ' days</text>'));\n    output = string(abi.encodePacked(output, '<text transform=\"matrix(1 0 0 1 50 811)\" fill=\"#EAECFE\" class=\"base\">Power:</text><text transform=\"matrix(1 0 0 1 50 853)\" fill=\"#97D0FF\" class=\"base\">', _toString(_value / 1e18), '</text></svg>'));\n\n    string memory json = Base64.encode(bytes(string(abi.encodePacked('{\"name\": \"veTETU #', _toString(_tokenId), '\", \"description\": \"Locked TETU tokens\", \"image\": \"data:image/svg+xml;base64,', Base64.encode(bytes(output)), '\"}'))));\n    output = string(abi.encodePacked('data:application/json;base64,', json));\n  }\n\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n  function _toString(uint value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint temp = value;\n    uint digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n}\n"
    },
    "@tetu_io/tetu-converter/contracts/core/BorrowManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppDataTypes.sol\";\r\nimport \"../libs/AppErrors.sol\";\r\nimport \"../libs/AppUtils.sol\";\r\nimport \"../openzeppelin/Clones.sol\";\r\nimport \"../openzeppelin/IERC20.sol\";\r\nimport \"../openzeppelin/SafeERC20.sol\";\r\nimport \"../openzeppelin/EnumerableSet.sol\";\r\nimport \"../openzeppelin/EnumerableMap.sol\";\r\nimport \"../openzeppelin/IERC20Metadata.sol\";\r\nimport \"../interfaces/IPlatformAdapter.sol\";\r\nimport \"../interfaces/IBorrowManager.sol\";\r\nimport \"../interfaces/IPriceOracle.sol\";\r\nimport \"../interfaces/IConverterController.sol\";\r\nimport \"../interfaces/IDebtMonitor.sol\";\r\nimport \"../interfaces/ITetuConverter.sol\";\r\nimport \"../integrations/market/ICErc20.sol\";\r\n\r\n/// @notice Contains list of lending pools. Allow to select most efficient pool for the given collateral/borrow pair\r\ncontract BorrowManager is IBorrowManager {\r\n  using SafeERC20 for IERC20;\r\n  using AppUtils for uint;\r\n  using Clones for address;\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n  using EnumerableSet for EnumerableSet.UintSet;\r\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n\r\n  /// @notice Reward APR is taken into account with given factor\r\n  ///         Result APR = borrow-apr - supply-apr - Factor/Denominator * rewards-APR\r\n  uint constant public REWARDS_FACTOR_DENOMINATOR_18 = 1e18;\r\n\r\n  IConverterController public immutable controller;\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///                Structs and enums\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Pair of two assets. Asset 1 can be converted to asset 2 and vice versa.\r\n  /// @dev There are no restrictions for {assetLeft} and {assertRight}. Each can be smaller than the other.\r\n  struct AssetPair {\r\n    address assetLeft;\r\n    address assetRight;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///                    Members\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Reward APR is taken into account with given factor\r\n  /// @dev decimals 18. The value is divided on {REWARDS_FACTOR_DENOMINATOR_18}\r\n  uint public rewardsFactor;\r\n\r\n  /// @notice all registered platform adapters\r\n  EnumerableSet.AddressSet private _platformAdapters;\r\n\r\n  /// @notice all asset pairs registered for the platform adapter\r\n  /// @dev PlatformAdapter : [key of asset pair]\r\n  mapping(address => EnumerableSet.UintSet) private _platformAdapterPairs;\r\n\r\n  /// @notice all platform adapters for which the asset pair is registered\r\n  /// @dev Key of pair asset => [list of platform adapters]\r\n  mapping(uint => EnumerableSet.AddressSet) private _pairsList;\r\n\r\n  /// @notice Key of pair asset => Asset pair\r\n  mapping(uint => AssetPair) private _assetPairs;\r\n\r\n  /// @notice Default health factors (HF) for assets. Default HF is used if user hasn't provided HF value, decimals 2\r\n  /// @dev asset => Health factor (== collateral / minimum collateral. It should be greater then MIN_HEALTH_FACTOR)\r\n  mapping(address => uint16) public targetHealthFactorsForAssets;\r\n\r\n  /// @notice Converter : platform adapter\r\n  mapping(address => address) public converterToPlatformAdapter;\r\n\r\n  /// @notice List of pool adapters ready to borrow, i.e. with not-dirty state.\r\n  ///         Any pool adapter with state DIRTY is removed from this list as soon as its dirty-state is detected.\r\n  /// @dev user => PoolAdapterKey(== keccak256(converter, collateral, borrowToken)) => address of the pool adapter\r\n  mapping (address => EnumerableMap.UintToAddressMap) private _poolAdapters;\r\n\r\n  /// @notice Pool adapter => (1 + index of the pool adapter in {listPoolAdapters})\r\n  /// @dev This list contains info for all ever created pool adapters (both for not-dirty and dirty ones).\r\n  mapping (address => uint) public poolAdaptersRegistered;\r\n\r\n  /// @notice List of addresses of all ever created pool adapters (both for not-dirty and dirty ones).\r\n  /// @dev Allow to get full list of the pool adapter and then filter it by any criteria (asset, user, state, etc)\r\n  address[] public listPoolAdapters;\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Events\r\n  ///////////////////////////////////////////////////////\r\n  event OnSetTargetHealthFactors(address[] assets, uint16[] healthFactors2);\r\n  event OnSetRewardsFactor(uint rewardsFactor);\r\n  event OnAddAssetPairs(address platformAdapter, address[] leftAssets, address[] rightAssets);\r\n  event OnRemoveAssetPairs(address platformAdapter, address[] leftAssets, address[] rightAssets);\r\n  event OnUnregisterPlatformAdapter(address platformAdapter);\r\n  event OnRegisterPoolAdapter(address poolAdapter, address converter, address user, address collateralAsset, address borrowAsset);\r\n  event OnMarkPoolAdapterAsDirty(address poolAdapter);\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Initialization\r\n  ///////////////////////////////////////////////////////\r\n\r\n  constructor (address controller_, uint rewardsFactor_) {\r\n    require(controller_ != address(0), AppErrors.ZERO_ADDRESS);\r\n    controller = IConverterController(controller_);\r\n\r\n    // we assume rewards amount should be downgraded in calcs coz liquidation gaps\r\n    require(rewardsFactor_ < REWARDS_FACTOR_DENOMINATOR_18, AppErrors.INCORRECT_VALUE);\r\n    rewardsFactor = rewardsFactor_;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Access rights\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Ensure that msg.sender is registered pool adapter\r\n  function _onlyTetuConverterOrUser(address user_) internal view {\r\n    require(\r\n      msg.sender == controller.tetuConverter()\r\n      || msg.sender == user_, // second condition is required by tests; it looks safe enough for the production\r\n      AppErrors.TETU_CONVERTER_ONLY\r\n    );\r\n  }\r\n\r\n  /// @notice Ensure that msg.sender is registered pool adapter\r\n  function _onlyGovernance() internal view {\r\n    require(msg.sender == controller.governance(), AppErrors.GOVERNANCE_ONLY);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Configuration\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Set target health factors for the assets.\r\n  ///         If target health factor is not assigned to the asset, target-health-factor from controller is used.\r\n  /// @param healthFactors2_ Health factor must be greater then 1, decimals 2\r\n  function setTargetHealthFactors(address[] calldata assets_, uint16[] calldata healthFactors2_) external override {\r\n    _onlyGovernance();\r\n    uint countItems = assets_.length;\r\n    require(countItems == healthFactors2_.length, AppErrors.WRONG_LENGTHS);\r\n\r\n    for (uint i = 0; i < countItems; i = i.uncheckedInc()) {\r\n      require(healthFactors2_[i] >= controller.minHealthFactor2(), AppErrors.WRONG_HEALTH_FACTOR);\r\n      targetHealthFactorsForAssets[assets_[i]] = healthFactors2_[i];\r\n    }\r\n\r\n    emit OnSetTargetHealthFactors(assets_, healthFactors2_);\r\n  }\r\n\r\n  /// @notice Reward APR is taken into account with given factor\r\n  ///         Result APR = borrow-apr - supply-apr - [REWARD-FACTOR]/Denominator * rewards-APR\r\n  function setRewardsFactor(uint rewardsFactor_) external override {\r\n    _onlyGovernance();\r\n    require(rewardsFactor_ < REWARDS_FACTOR_DENOMINATOR_18, AppErrors.INCORRECT_VALUE);\r\n    rewardsFactor = rewardsFactor_;\r\n\r\n    emit OnSetRewardsFactor(rewardsFactor_);\r\n  }\r\n\r\n  /// @notice Register new lending platform with available pairs of assets\r\n  ///         OR add new pairs of assets to the exist lending platform\r\n  /// @param platformAdapter_ Implementation of IPlatformAdapter attached to the specified pool\r\n  /// @param leftAssets_  Supported pairs of assets. The pairs are set using two arrays: left and right\r\n  /// @param rightAssets_  Supported pairs of assets. The pairs are set using two arrays: left and right\r\n  function addAssetPairs(\r\n    address platformAdapter_,\r\n    address[] calldata leftAssets_,\r\n    address[] calldata rightAssets_\r\n  ) external override {\r\n    _onlyGovernance();\r\n\r\n    uint lenAssets = rightAssets_.length;\r\n    require(leftAssets_.length == lenAssets, AppErrors.WRONG_LENGTHS);\r\n\r\n    // register new platform adapter if necessary\r\n    _platformAdapters.add(platformAdapter_);\r\n\r\n    // register all available template pool adapters\r\n    address[] memory paConverters = IPlatformAdapter(platformAdapter_).converters();\r\n    uint lenConverters = paConverters.length;\r\n    for (uint i = 0; i < lenConverters; i = i.uncheckedInc()) {\r\n      // the relation \"platform adapter - converter\" is invariant\r\n      address platformAdapterForConverter = converterToPlatformAdapter[paConverters[i]];\r\n      if (platformAdapter_ != platformAdapterForConverter) {\r\n        require(platformAdapterForConverter == address(0), AppErrors.ONLY_SINGLE_PLATFORM_ADAPTER_CAN_USE_CONVERTER);\r\n        converterToPlatformAdapter[paConverters[i]] = platformAdapter_;\r\n      }\r\n    }\r\n\r\n    // register all provided asset pairs\r\n    for (uint i = 0; i < lenAssets; i = i.uncheckedInc()) {\r\n      uint assetPairKey = getAssetPairKey(leftAssets_[i], rightAssets_[i]);\r\n      if (_assetPairs[assetPairKey].assetLeft == address(0)) {\r\n        _assetPairs[assetPairKey] = AssetPair({\r\n          assetLeft: leftAssets_[i],\r\n          assetRight: rightAssets_[i]\r\n        });\r\n      }\r\n      _pairsList[assetPairKey].add(platformAdapter_);\r\n      _platformAdapterPairs[platformAdapter_].add(assetPairKey);\r\n    }\r\n\r\n    emit OnAddAssetPairs(platformAdapter_, leftAssets_, rightAssets_);\r\n  }\r\n\r\n  /// @notice Remove available pairs of asset from the platform adapter.\r\n  ///         The platform adapter will be unregistered after removing last supported pair of assets\r\n  function removeAssetPairs(\r\n    address platformAdapter_,\r\n    address[] calldata leftAssets_,\r\n    address[] calldata rightAssets_\r\n  ) external override {\r\n    _onlyGovernance();\r\n\r\n    uint lenAssets = rightAssets_.length;\r\n    require(leftAssets_.length == lenAssets, AppErrors.WRONG_LENGTHS);\r\n    require(_platformAdapters.contains(platformAdapter_), AppErrors.PLATFORM_ADAPTER_NOT_FOUND);\r\n    IDebtMonitor debtMonitor = IDebtMonitor(controller.debtMonitor());\r\n\r\n    // unregister the asset pairs\r\n    for (uint i = 0; i < lenAssets; i = i.uncheckedInc()) {\r\n      uint assetPairKey = getAssetPairKey(leftAssets_[i], rightAssets_[i]);\r\n      _pairsList[assetPairKey].remove(platformAdapter_);\r\n      _platformAdapterPairs[platformAdapter_].remove(assetPairKey);\r\n    }\r\n\r\n    // if platform adapter doesn't have any asset pairs, we unregister it\r\n    if (_platformAdapterPairs[platformAdapter_].length() == 0) {\r\n      // unregister all template pool adapters\r\n      address[] memory paConverters = IPlatformAdapter(platformAdapter_).converters();\r\n      uint lenConverters = paConverters.length;\r\n      for (uint i = 0; i < lenConverters; i = i.uncheckedInc()) {\r\n        // If there is active pool adapter for the platform adapter, we cannot unregister the platform adapter\r\n        require(!debtMonitor.isConverterInUse(paConverters[i]), AppErrors.PLATFORM_ADAPTER_IS_IN_USE);\r\n        converterToPlatformAdapter[paConverters[i]] = address(0);\r\n      }\r\n\r\n      // unregister platform adapter\r\n      _platformAdapters.remove(platformAdapter_);\r\n      emit OnUnregisterPlatformAdapter(platformAdapter_);\r\n    }\r\n\r\n    emit OnRemoveAssetPairs(platformAdapter_, leftAssets_, rightAssets_);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///           Find best pool for borrowing\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Find lending pool capable of providing {targetAmount} and having best normalized borrow rate\r\n  ///         Results are ordered in ascending order of APR, so the best available converter is first one.\r\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\r\n  ///                  See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\r\n  /// @param amountIn_ The meaning depends on entryData kind, see EntryKinds library for details.\r\n  ///         For entry kind = 0: Amount of {sourceToken} to be converted to {targetToken}\r\n  ///         For entry kind = 1: Available amount of {sourceToken}\r\n  ///         For entry kind = 2: Amount of {targetToken} that should be received after conversion\r\n  /// @return convertersOut Result template-pool-adapters\r\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\r\n  /// @return amountsToBorrowOut Amounts that should be borrowed\r\n  /// @return aprs18Out Annual Percentage Rates == (total cost - total income) / amount of collateral, decimals 18\r\n  function findConverter(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    address targetToken_,\r\n    uint amountIn_,\r\n    uint periodInBlocks_\r\n  ) external view override returns (\r\n    address[] memory convertersOut,\r\n    uint[] memory collateralAmountsOut,\r\n    uint[] memory amountsToBorrowOut,\r\n    int[] memory aprs18Out\r\n  ) {\r\n    AppDataTypes.InputConversionParams memory params = AppDataTypes.InputConversionParams({\r\n    collateralAsset: sourceToken_,\r\n    borrowAsset: targetToken_,\r\n    amountIn: amountIn_,\r\n    countBlocks: periodInBlocks_,\r\n    entryData: entryData_\r\n    });\r\n    return _findConverter(params);\r\n  }\r\n\r\n  /// @notice Find lending pool capable of providing {targetAmount} and having best normalized borrow rate\r\n  ///         Results are ordered in ascending order of APR, so the best available converter is first one.\r\n  /// @return convertersOut Result template-pool-adapters\r\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\r\n  /// @return amountsToBorrowOut Amounts that should be borrowed\r\n  /// @return aprs18Out Annual Percentage Rates == (total cost - total income) / amount of collateral, decimals 18\r\n  function _findConverter(AppDataTypes.InputConversionParams memory p_) internal view returns (\r\n    address[] memory convertersOut,\r\n    uint[] memory collateralAmountsOut,\r\n    uint[] memory amountsToBorrowOut,\r\n    int[] memory aprs18Out\r\n  ) {\r\n    // get all platform adapters that support required pair of assets\r\n    EnumerableSet.AddressSet storage pas = _pairsList[getAssetPairKey(p_.collateralAsset, p_.borrowAsset)];\r\n\r\n    address[] memory converters;\r\n    uint[] memory collateralAmounts;\r\n    uint[] memory amountsToBorrow;\r\n    int[] memory aprs18;\r\n    uint countFoundItems;\r\n    if (pas.length() != 0) {\r\n      (converters, collateralAmounts, amountsToBorrow, aprs18, countFoundItems) = _findPool(\r\n        pas,\r\n        p_,\r\n        getTargetHealthFactor2(p_.borrowAsset)\r\n      );\r\n    }\r\n\r\n    if (countFoundItems > 0) {\r\n      // shrink output arrays to {countFoundItems} items and order results in ascending order of APR\r\n      return AppUtils.shrinkAndOrder(countFoundItems, converters, collateralAmounts, amountsToBorrow, aprs18);\r\n    } else {\r\n      return (convertersOut, collateralAmountsOut, amountsToBorrowOut, aprs18Out);\r\n    }\r\n  }\r\n\r\n  /// @notice Enumerate all pools suitable for borrowing and enough liquidity.\r\n  /// General explanation how max-target-amount is calculated in all pool adapters:\r\n  /// Health factor = HF [-], Collateral amount = C [USD]\r\n  /// Source amount that can be used for the collateral = SA [SA], Borrow amount = BS [USD]\r\n  /// Price of the source amount = PS [USD/SA] (1 [SA] = PS[USD])\r\n  /// Price of the target amount = PT [USD/TA] (1 [TA] = PT[USD])\r\n  /// Pool params: Collateral factor of the pool = PCF [-], Available cash in the pool = PTA [TA]\r\n  ///\r\n  /// C = SA * PS, BS = C / HF * PCF\r\n  /// Max target amount capable to be borrowed: ResultTA = BS / PT [TA].\r\n  /// We can use the pool only if ResultTA >= PTA >= required-target-amount\r\n  /// @dev We cannot make this function public because storage-param is used\r\n  /// @return converters All found converters without ordering.\r\n  ///                    The size of array is always equal to the count of available lending platforms.\r\n  ///                    The array is sparse, unused items are zero.\r\n  function _findPool(\r\n    EnumerableSet.AddressSet storage platformAdapters_,\r\n    AppDataTypes.InputConversionParams memory p_,\r\n    uint16 healthFactor2_\r\n  ) internal view returns (\r\n    address[] memory converters,\r\n    uint[] memory collateralAmountsOut,\r\n    uint[] memory amountsToBorrowOut,\r\n    int[] memory aprs18,\r\n    uint countFoundItems\r\n  ) {\r\n    uint lenPools = platformAdapters_.length();\r\n\r\n    converters = new address[](lenPools);\r\n    collateralAmountsOut = new uint[](lenPools);\r\n    amountsToBorrowOut = new uint[](lenPools);\r\n    aprs18 = new int[](lenPools);\r\n\r\n    for (uint i; i < lenPools; i = i.uncheckedInc()) {\r\n      AppDataTypes.ConversionPlan memory plan = IPlatformAdapter(platformAdapters_.at(i)).getConversionPlan(\r\n        p_,\r\n        healthFactor2_\r\n      );\r\n\r\n      if (\r\n        plan.converter != address(0)\r\n        // check if we are able to supply required collateral\r\n        && plan.maxAmountToSupply > p_.amountIn\r\n      ) {\r\n        // combine all costs and incomes and calculate result APR. Rewards are taken with the given weight.\r\n        // Positive value means cost, negative - income\r\n        // APR = (cost - income) / collateralAmount, decimals 18, all amounts are given in terms of borrow asset.\r\n        int planApr18 = (\r\n          int(plan.borrowCost36)\r\n          - int(plan.supplyIncomeInBorrowAsset36)\r\n          - int(plan.rewardsAmountInBorrowAsset36 * rewardsFactor / REWARDS_FACTOR_DENOMINATOR_18)\r\n        )\r\n        * int(1e18)\r\n        / int(plan.amountCollateralInBorrowAsset36);\r\n\r\n        if (\r\n          // take only the pool with enough liquidity\r\n          plan.maxAmountToBorrow >= plan.amountToBorrow\r\n        ) {\r\n          converters[countFoundItems] = plan.converter;\r\n          amountsToBorrowOut[countFoundItems] = plan.amountToBorrow;\r\n          collateralAmountsOut[countFoundItems] = plan.collateralAmount;\r\n          aprs18[countFoundItems] = planApr18;\r\n          ++countFoundItems;\r\n        }\r\n      }\r\n    }\r\n\r\n    return (converters, collateralAmountsOut, amountsToBorrowOut, aprs18, countFoundItems);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///         Minimal proxy creation\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Register a pool adapter for (pool, user, collateral) if the adapter wasn't created before\r\n  /// @param user_ Address of the caller contract who requires access to the pool adapter\r\n  /// @return Address of registered pool adapter\r\n  function registerPoolAdapter(\r\n    address converter_,\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_\r\n  ) external override returns (address) {\r\n    _onlyTetuConverterOrUser(user_);\r\n\r\n    uint poolAdapterKey = getPoolAdapterKey(converter_, collateralAsset_, borrowAsset_);\r\n    (bool found, address dest) = _poolAdapters[user_].tryGet(poolAdapterKey);\r\n    if (! found) {\r\n      // pool adapter is not yet registered\r\n      // create a new instance of the pool adapter using minimal proxy pattern, initialize newly created contract\r\n      dest = converter_.clone();\r\n      IPlatformAdapter(getPlatformAdapter(converter_)).initializePoolAdapter(\r\n        converter_,\r\n        dest,\r\n        user_,\r\n        collateralAsset_,\r\n        borrowAsset_\r\n      );\r\n\r\n      // register newly created pool adapter in the list of the pool adapters\r\n      _poolAdapters[user_].set(poolAdapterKey, dest);\r\n      uint index = listPoolAdapters.length;\r\n      poolAdaptersRegistered[dest] = index + 1;\r\n      listPoolAdapters.push(dest);\r\n\r\n      emit OnRegisterPoolAdapter(dest, converter_, user_, collateralAsset_, borrowAsset_);\r\n    }\r\n\r\n    return dest;\r\n  }\r\n\r\n  /// @notice Notify borrow manager that the pool adapter with the given params is \"dirty\".\r\n  ///         The pool adapter should be excluded from the list of ready-to-borrow pool adapters.\r\n  /// @dev \"Dirty\" means that a liquidation happens inside. The borrow position should be closed during health checking.\r\n  function markPoolAdapterAsDirty(\r\n    address converter_,\r\n    address user_,\r\n    address collateral_,\r\n    address borrowToken_\r\n  ) external override {\r\n    require(\r\n      msg.sender == controller.tetuConverter() || msg.sender == controller.debtMonitor(),\r\n      AppErrors.ACCESS_DENIED\r\n    );\r\n    uint key = getPoolAdapterKey(converter_, collateral_, borrowToken_);\r\n\r\n    (bool found, address poolAdapter) = _poolAdapters[user_].tryGet(key);\r\n    require(found, AppErrors.POOL_ADAPTER_NOT_FOUND);\r\n\r\n    // Dirty pool adapter is removed from _poolAdapters, so it will never be used for new borrows\r\n    _poolAdapters[user_].remove(key);\r\n\r\n    emit OnMarkPoolAdapterAsDirty(poolAdapter);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///         Getters - pool adapters\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @dev Returns true for NORMAL pool adapters and for active DIRTY pool adapters (=== borrow position is opened).\r\n  function isPoolAdapter(address poolAdapter_) external view override returns (bool) {\r\n    return poolAdaptersRegistered[poolAdapter_] != 0;\r\n  }\r\n\r\n  /// @notice Get pool adapter or 0 if the pool adapter is not registered\r\n  function getPoolAdapter(\r\n    address converter_,\r\n    address user_,\r\n    address collateral_,\r\n    address borrowToken_\r\n  ) external view override returns (address) {\r\n    (bool found, address dest) = _poolAdapters[user_].tryGet(getPoolAdapterKey(converter_, collateral_, borrowToken_));\r\n    return found ? dest : address(0);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///         Getters - platform adapters\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Get platformAdapter to which the converter belongs\r\n  function getPlatformAdapter(address converter_) public view override returns (address) {\r\n    address platformAdapter = converterToPlatformAdapter[converter_];\r\n    require(platformAdapter != address(0), AppErrors.PLATFORM_ADAPTER_NOT_FOUND);\r\n    return platformAdapter;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///         Getters - health factor\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Return target health factor with decimals 2 for the asset\r\n  ///         If there is no custom value for asset, target health factor from the controller should be used\r\n  function getTargetHealthFactor2(address asset_) public view override returns (uint16) {\r\n    uint16 dest = targetHealthFactorsForAssets[asset_];\r\n    return dest == 0\r\n      ? controller.targetHealthFactor2()\r\n      : dest;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///                 keccak256 keys\r\n  ///////////////////////////////////////////////////////\r\n\r\n  function getPoolAdapterKey(address converter_,\r\n    address collateral_,\r\n    address borrowToken_\r\n  ) public pure returns (uint){\r\n    return uint(keccak256(abi.encodePacked(converter_, collateral_, borrowToken_)));\r\n  }\r\n\r\n  function getAssetPairKey(address assetLeft_, address assetRight_) public pure returns (uint) {\r\n    return assetLeft_ < assetRight_\r\n      ? uint(keccak256(abi.encodePacked(assetLeft_, assetRight_)))\r\n      : uint(keccak256(abi.encodePacked(assetRight_, assetLeft_)));\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///                 Access to arrays\r\n  ///////////////////////////////////////////////////////\r\n\r\n  function platformAdaptersLength() public view returns (uint) {\r\n    return _platformAdapters.length();\r\n  }\r\n\r\n  function platformAdaptersAt(uint index) public view returns (address) {\r\n    return _platformAdapters.at(index);\r\n  }\r\n\r\n  function pairsListLength(address token1, address token2) public view returns (uint) {\r\n    return _pairsList[getAssetPairKey(token1, token2)].length();\r\n  }\r\n\r\n  function pairsListAt(address token1, address token2, uint index) public view returns (address) {\r\n    return _pairsList[getAssetPairKey(token1, token2)].at(index);\r\n  }\r\n\r\n  function platformAdapterPairsLength(address platformAdapter_) public view returns (uint) {\r\n    return _platformAdapterPairs[platformAdapter_].length();\r\n  }\r\n\r\n  function platformAdapterPairsAt(address platformAdapter_, uint index) public view returns (AssetPair memory) {\r\n    return _assetPairs[_platformAdapterPairs[platformAdapter_].at(index)];\r\n  }\r\n\r\n  function listPoolAdaptersLength() public view returns (uint) {\r\n    return listPoolAdapters.length;\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/core/ConverterController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppErrors.sol\";\r\nimport \"../openzeppelin/Initializable.sol\";\r\nimport \"../interfaces/IConverterController.sol\";\r\n\r\n/// @notice Keep and provide addresses of all application contracts\r\ncontract ConverterController is IConverterController, Initializable {\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///        Constants and immutable vars\r\n  ///////////////////////////////////////////////////////\r\n  uint16 constant MIN_ALLOWED_MIN_HEALTH_FACTOR = 100;\r\n\r\n  /// @notice Allow to swap assets\r\n  address public immutable override tetuLiquidator;\r\n  /// @notice Price oracle, required by SwapManager\r\n  address public immutable override priceOracle;\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Variables\r\n  ///   We cannot use immutable variables for the below contracts,\r\n  ///   because each contract requires address of the controller as a parameter of the constructor\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Main application contract, strategy works only with it\r\n  address public override tetuConverter;\r\n\r\n  /// @notice Contains list of lending pools. Allow to select most efficient pool for the given collateral/borrow pair\r\n  address public override borrowManager;\r\n\r\n  /// @notice Contains list of opened borrows, check healths of the borrows\r\n  address public override debtMonitor;\r\n\r\n  /// @notice A keeper to control health of the borrows\r\n  address public override keeper;\r\n\r\n  /// @notice Wrapper around tetu-liquidator\r\n  address public override swapManager;\r\n\r\n  /// @notice Current governance. It can be changed by offer/accept scheme\r\n  address public override governance;\r\n  /// @notice New governance suggested by exist governance\r\n  address public pendingGovernance;\r\n\r\n  /// @notice Min allowed health factor = collateral / min allowed collateral, decimals 2\r\n  ///         If a health factor is below given value, we need to repay a part of borrow back\r\n  /// @dev Health factor < 1 produces liquidation immediately\r\n  uint16 public override minHealthFactor2;\r\n\r\n  /// @notice target health factor with decimals 2\r\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\r\n  ///      or additional borrow and restore the health factor to the given target value\r\n  uint16 public override targetHealthFactor2;\r\n\r\n  /// @notice max allowed health factor with decimals 2\r\n  /// @dev If a health factor is above given value, we CAN make additional borrow\r\n  ///      using exist collateral\r\n  uint16 public override maxHealthFactor2;\r\n\r\n  /// @notice Count of blocks per day, updatable\r\n  uint public override blocksPerDay;\r\n\r\n  /// @notice When blocksPerDay was updated last time\r\n  ///         0 - auto-update is disabled\r\n  uint public lastBlockNumber;\r\n  uint public lastBlockTimestamp;\r\n\r\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\r\n  bool private _paused;\r\n\r\n  /// @notice users who are allowed to make borrow using the TetuConverter\r\n  mapping (address => bool) public whitelist;\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Events\r\n  ///////////////////////////////////////////////////////\r\n  event OnSetBlocksPerDay(uint blocksPerDay, bool enableAutoUpdate);\r\n  event OnAutoUpdateBlocksPerDay(uint blocksPerDay);\r\n  event OnSetMinHealthFactor2(uint16 value);\r\n  event OnSetTargetHealthFactor2(uint16 value);\r\n  event OnSetMaxHealthFactor2(uint16 value);\r\n  event OnSetGovernance(address newGovernance);\r\n  event OnAcceptGovernance(address pendingGovernance);\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///        Constructor and Initialization\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @dev Constructor is used to assign immutable addresses only (these contracts don't depend on controller).\r\n  ///      All other addresses are initialized in initialize()\r\n  ///      because the corresponded contracts require controller's address in their constructors.\r\n  constructor(\r\n    address tetuLiquidator_,\r\n    address priceOracle_\r\n  ) {\r\n    require(\r\n      tetuLiquidator_ != address(0)\r\n      && priceOracle_ != address(0),\r\n      AppErrors.ZERO_ADDRESS\r\n    );\r\n\r\n    tetuLiquidator = tetuLiquidator_;\r\n    priceOracle = priceOracle_;\r\n  }\r\n\r\n  function initialize(\r\n    address governance_,\r\n    uint blocksPerDay_,\r\n    uint16 minHealthFactor_,\r\n    uint16 targetHealthFactor_,\r\n    uint16 maxHealthFactor_,\r\n    address tetuConverter_,\r\n    address borrowManager_,\r\n    address debtMonitor_,\r\n    address keeper_,\r\n    address swapManager_\r\n  ) external initializer {\r\n    require(blocksPerDay_ != 0, AppErrors.INCORRECT_VALUE);\r\n    require(minHealthFactor_ >= MIN_ALLOWED_MIN_HEALTH_FACTOR, AppErrors.WRONG_HEALTH_FACTOR);\r\n    require(minHealthFactor_ < targetHealthFactor_, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);\r\n    require(targetHealthFactor_ < maxHealthFactor_, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);\r\n    require(\r\n      governance_ != address(0)\r\n      && tetuConverter_ != address(0)\r\n      && borrowManager_ != address(0)\r\n      && debtMonitor_ != address(0)\r\n      && keeper_ != address(0)\r\n      && swapManager_ != address(0),\r\n      AppErrors.ZERO_ADDRESS\r\n    );\r\n    governance = governance_;\r\n    tetuConverter = tetuConverter_;\r\n    borrowManager = borrowManager_;\r\n    debtMonitor = debtMonitor_;\r\n    keeper = keeper_;\r\n    swapManager = swapManager_;\r\n\r\n    blocksPerDay = blocksPerDay_;\r\n    // by default auto-update of blocksPerDay is disabled\r\n    // it's necessary to call setBlocksPerDay to enable it\r\n\r\n    minHealthFactor2 = minHealthFactor_;\r\n    maxHealthFactor2 = maxHealthFactor_;\r\n    targetHealthFactor2 = targetHealthFactor_;\r\n  }\r\n\r\n  function _onlyGovernance() internal view {\r\n    require (msg.sender == governance, AppErrors.GOVERNANCE_ONLY);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Blocks per day\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Manually set value of blocksPerDay and enable/disable its auto-update\r\n  ///         If the update is enabled, the first update will happen in BLOCKS_PER_DAY_AUTO_UPDATE_PERIOD_SECS seconds\r\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external override {\r\n    require(blocksPerDay_ != 0, AppErrors.INCORRECT_VALUE);\r\n    _onlyGovernance();\r\n    blocksPerDay = blocksPerDay_;\r\n    if (enableAutoUpdate_) {\r\n      lastBlockNumber = block.number;\r\n      lastBlockTimestamp = block.timestamp;\r\n    } else {\r\n      lastBlockNumber = 0;\r\n      lastBlockTimestamp = 0;\r\n    }\r\n    emit OnSetBlocksPerDay(blocksPerDay_, enableAutoUpdate_);\r\n  }\r\n\r\n  /// @notice Check if blocksPerDay should be updated. The keeper should do it periodically\r\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view override returns (bool) {\r\n    return lastBlockNumber != 0 && block.timestamp - lastBlockTimestamp > periodInSeconds_;\r\n  }\r\n\r\n  /// @notice Calculate new value of blocksPerDay as COUNT PASSED BLOCKS / COUNT PASSED DAYS (since prev auto-update)\r\n  function updateBlocksPerDay(uint periodInSeconds_) external override {\r\n    require(msg.sender == keeper, AppErrors.KEEPER_ONLY);\r\n    require(lastBlockNumber != 0,\r\n      // && lastBlockNumber != block.number       // this check is unnecessary\r\n      AppErrors.INCORRECT_OPERATION               // setBlocksPerDay is called by governance\r\n    );                                            // but updateBlocksPerDay is called by keeper\r\n                                                  // so, they cannot be called in the same block\r\n    require(\r\n      periodInSeconds_ != 0\r\n      && lastBlockTimestamp + periodInSeconds_ <= block.timestamp,\r\n      AppErrors.INCORRECT_VALUE\r\n    );\r\n    // blocks-per-day = count passed blocks / count passed days\r\n    // count passed days = count passed seconds / count seconds per day\r\n    blocksPerDay = (block.number - lastBlockNumber) * (24 * 60 * 60) / (block.timestamp - lastBlockTimestamp);\r\n\r\n    lastBlockNumber = block.number;\r\n    lastBlockTimestamp = block.timestamp;\r\n\r\n    emit OnAutoUpdateBlocksPerDay(blocksPerDay);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///             Set up health factors\r\n  ///  min/max thresholds and a target value for reconversion\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice min allowed health factor with decimals 2\r\n  function setMinHealthFactor2(uint16 value_) external override {\r\n    require(value_ >= MIN_ALLOWED_MIN_HEALTH_FACTOR, AppErrors.WRONG_HEALTH_FACTOR);\r\n    require(value_ < targetHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);\r\n    _onlyGovernance();\r\n    minHealthFactor2 = value_;\r\n    emit OnSetMinHealthFactor2(value_);\r\n  }\r\n\r\n  /// @notice target health factor with decimals 2\r\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\r\n  ///      or additional borrow and restore the health factor to the given target value\r\n  function setTargetHealthFactor2(uint16 value_) external override {\r\n    require(value_ > minHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);\r\n    require(value_ < maxHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);\r\n    _onlyGovernance();\r\n    targetHealthFactor2 = value_;\r\n    emit OnSetTargetHealthFactor2(value_);\r\n  }\r\n\r\n  /// @notice max allowed health factor with decimals 2\r\n  function setMaxHealthFactor2(uint16 value_) external override {\r\n    require(value_ > targetHealthFactor2, AppErrors.WRONG_HEALTH_FACTOR_CONFIG);\r\n    _onlyGovernance();\r\n    maxHealthFactor2 = value_;\r\n    emit OnSetMaxHealthFactor2(value_);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Governance\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Suggest to change governance\r\n  function setGovernance(address newGovernance_) external {\r\n    _onlyGovernance();\r\n    require(newGovernance_ != address(0), AppErrors.ZERO_ADDRESS);\r\n\r\n    pendingGovernance = newGovernance_;\r\n    emit OnSetGovernance(newGovernance_);\r\n  }\r\n\r\n  /// @notice Old governance has suggested to change governance.\r\n  ///         Newly suggested governance must accept the change to actually change the governance.\r\n  function acceptGovernance() external {\r\n    require(pendingGovernance == msg.sender, AppErrors.NOT_PENDING_GOVERNANCE);\r\n\r\n    governance = pendingGovernance;\r\n    emit OnAcceptGovernance(pendingGovernance);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Paused\r\n  ///////////////////////////////////////////////////////\r\n  function paused() external view override returns (bool) {\r\n    return _paused;\r\n  }\r\n  function setPaused(bool paused_) external {\r\n    _onlyGovernance();\r\n    _paused = paused_;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Whitelist\r\n  ///////////////////////////////////////////////////////\r\n  function isWhitelisted(address user_) external view override returns (bool) {\r\n    return whitelist[user_];\r\n  }\r\n  function setWhitelistValues(address[] memory users_, bool isWhite) external {\r\n    _onlyGovernance();\r\n    uint len = users_.length;\r\n    for (uint i; i < len; ++i) {\r\n      whitelist[users_[i]] = isWhite;\r\n    }\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/core/DebtMonitor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppErrors.sol\";\r\nimport \"../libs/AppUtils.sol\";\r\nimport \"../openzeppelin/IERC20Metadata.sol\";\r\nimport \"../openzeppelin/EnumerableSet.sol\";\r\nimport \"../interfaces/IPoolAdapter.sol\";\r\nimport \"../interfaces/IConverterController.sol\";\r\nimport \"../interfaces/IDebtMonitor.sol\";\r\nimport \"../interfaces/IPriceOracle.sol\";\r\nimport \"../interfaces/IBorrowManager.sol\";\r\nimport \"../interfaces/ITetuConverter.sol\";\r\n\r\n/// @notice Manage list of open borrow positions\r\ncontract DebtMonitor is IDebtMonitor {\r\n  using AppUtils for uint;\r\n  using EnumerableSet for EnumerableSet.AddressSet;\r\n\r\n  struct CheckHealthFactorInputParams {\r\n    uint startIndex0;\r\n    uint maxCountToCheck;\r\n    uint maxCountToReturn;\r\n    uint healthFactorThreshold18;\r\n  }\r\n\r\n  IConverterController public immutable controller;\r\n  /// @notice Same as controller.borrowManager()\r\n  /// @dev Cached for the gas optimization\r\n  IBorrowManager public immutable borrowManager;\r\n\r\n  /// @notice Pool adapters with active borrow positions\r\n  /// @dev All these pool adapters should be enumerated during health-checking\r\n  address[] public positions;\r\n\r\n  /// @notice Pool adapter => block number of last call of onOpenPosition\r\n  mapping(address => uint) public positionLastAccess;\r\n\r\n  /// @notice List of opened positions for the given set (user, collateral, borrowToken)\r\n  /// @dev PoolAdapterKey(== keccak256(user, collateral, borrowToken)) => poolAdapters\r\n  mapping(uint => address[]) public poolAdapters;\r\n\r\n  /// @notice List of opened positions for the given user\r\n  /// @dev User => List of pool adapters\r\n  mapping(address => EnumerableSet.AddressSet) private _poolAdaptersForUser;\r\n\r\n  /// @notice Template pool adapter => list of ACTIVE pool adapters created on the base of the template\r\n  /// @dev We need it to prevent removing a pool from the borrow manager when the pool is in use\r\n  mapping(address => EnumerableSet.AddressSet) private _poolAdaptersForConverters;\r\n\r\n// Future versions\r\n//  /// @notice threshold for APRs difference, i.e. _thresholdApr100 = 20 for (apr0-apr1)/apr0 > 20%\r\n//  ///         0 - disable the limitation by value of APR difference\r\n//  uint public thresholdAPR;\r\n//\r\n//  /// @notice best-way reconversion is allowed only after passing specified count of blocks since last reconversion\r\n//  ///         0 - disable the limitation by count of blocks passed since last onOpenPosition call\r\n//  uint public thresholdCountBlocks;\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Events\r\n  ///////////////////////////////////////////////////////\r\n//  event OnSetThresholdAPR(uint value100);\r\n//  event OnSetThresholdCountBlocks(uint counbBlocks);\r\n  event OnOpenPosition(address poolAdapter);\r\n  event OnClosePosition(address poolAdapter);\r\n  event OnCloseLiquidatedPosition(address poolAdapter, uint amountToPay);\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Constructor and initialization\r\n  ///////////////////////////////////////////////////////\r\n\r\n  constructor(\r\n    address controller_,\r\n    address borrowManager_\r\n//    uint thresholdAPR_,\r\n//    uint thresholdCountBlocks_\r\n  ) {\r\n    require(\r\n      controller_ != address(0)\r\n      && borrowManager_ != address(0),\r\n      AppErrors.ZERO_ADDRESS\r\n    );\r\n    controller = IConverterController(controller_);\r\n    borrowManager = IBorrowManager(borrowManager_);\r\n\r\n// Future versions:\r\n//    require(thresholdAPR_ < 100, AppErrors.INCORRECT_VALUE);\r\n//    thresholdAPR = thresholdAPR_;\r\n//\r\n//    // we don't need any restriction for countBlocks_\r\n//    // 0 - means, that the threshold is disabled\r\n//    thresholdCountBlocks = thresholdCountBlocks_;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Access rights\r\n  ///////////////////////////////////////////////////////\r\n\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Operations with positions\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Check if the pool-adapter-caller has an opened position\r\n  function isPositionOpened() external override view returns (bool) {\r\n    return positionLastAccess[msg.sender] != 0;\r\n  }\r\n\r\n  /// @notice Register new borrow position if it's not yet registered\r\n  /// @dev This function is called from a pool adapter after any borrow\r\n  function onOpenPosition() external override {\r\n    require(borrowManager.isPoolAdapter(msg.sender), AppErrors.POOL_ADAPTER_ONLY);\r\n\r\n    if (positionLastAccess[msg.sender] == 0) {\r\n      positionLastAccess[msg.sender] = block.number;\r\n      positions.push(msg.sender);\r\n\r\n      (address origin,\r\n       address user,\r\n       address collateralAsset,\r\n       address borrowAsset\r\n      ) = IPoolAdapter(msg.sender).getConfig();\r\n\r\n      poolAdapters[getPoolAdapterKey(user, collateralAsset, borrowAsset)].push(msg.sender);\r\n      _poolAdaptersForUser[user].add(msg.sender);\r\n\r\n      _poolAdaptersForConverters[origin].add(msg.sender);\r\n      emit OnOpenPosition(msg.sender);\r\n    }\r\n  }\r\n\r\n  /// @notice Unregister the borrow position if it's completely repaid\r\n  /// @dev This function is called from a pool adapter when the borrow is completely repaid\r\n  function onClosePosition() external override {\r\n    // This method should be called by pool adapters only\r\n    // we check it through positionLastAccess\r\n    require(\r\n      positionLastAccess[msg.sender] != 0,\r\n      AppErrors.BORROW_POSITION_IS_NOT_REGISTERED\r\n    );\r\n\r\n    (uint collateralAmount, uint amountToPay,,,) = IPoolAdapter(msg.sender).getStatus();\r\n    require(collateralAmount == 0 && amountToPay == 0, AppErrors.ATTEMPT_TO_CLOSE_NOT_EMPTY_BORROW_POSITION);\r\n\r\n    _closePosition(msg.sender, false);\r\n    emit OnClosePosition(msg.sender);\r\n  }\r\n\r\n  /// @notice Remove the pool adapter from all lists of the opened positions\r\n  /// @param poolAdapter_ Pool adapter to be closed\r\n  /// @param markAsDirty_ Mark the pool adapter as \"dirty\" in borrow manager\r\n  ///                     to exclude the pool adapter from any new borrows\r\n  function _closePosition(address poolAdapter_, bool markAsDirty_) internal {\r\n    positionLastAccess[poolAdapter_] = 0;\r\n    AppUtils.removeItemFromArray(positions, poolAdapter_);\r\n    (address origin, address user, address collateralAsset, address borrowAsset) = IPoolAdapter(poolAdapter_).getConfig();\r\n\r\n    AppUtils.removeItemFromArray(poolAdapters[getPoolAdapterKey(user, collateralAsset, borrowAsset)], poolAdapter_);\r\n    _poolAdaptersForUser[user].remove(poolAdapter_);\r\n    _poolAdaptersForConverters[origin].remove(poolAdapter_);\r\n\r\n    if (markAsDirty_) {\r\n      // We have dropped away the pool adapter. It cannot be used any more for new borrows\r\n      // Mark the pool adapter as dirty in borrow manager to exclude the pool adapter from any new borrows\r\n      if (poolAdapter_ == borrowManager.getPoolAdapter(origin, user, collateralAsset, borrowAsset)) {\r\n        borrowManager.markPoolAdapterAsDirty(origin, user, collateralAsset, borrowAsset);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Pool adapter has opened borrow, but full liquidation happens and we've lost all collateral\r\n  ///         Close position without paying the debt and never use the pool adapter again.\r\n  function closeLiquidatedPosition(address poolAdapter_) external override {\r\n    require(msg.sender == controller.tetuConverter(), AppErrors.TETU_CONVERTER_ONLY);\r\n\r\n    (uint collateralAmount, uint amountToPay,,,) = IPoolAdapter(poolAdapter_).getStatus();\r\n    require(collateralAmount == 0, AppErrors.CANNOT_CLOSE_LIVE_POSITION);\r\n    _closePosition(poolAdapter_, true);\r\n\r\n    emit OnCloseLiquidatedPosition(poolAdapter_, amountToPay);\r\n  }\r\n  ///////////////////////////////////////////////////////\r\n  ///           Detect unhealthy positions\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Enumerate {maxCountToCheck} pool adapters starting from {index0} and return unhealthy pool-adapters\r\n  ///         i.e. adapters with health factor below min allowed value\r\n  ///         It calculates two amounts: amount of borrow asset and amount of collateral asset\r\n  ///         To fix the health factor it's necessary to send EITHER one amount OR another one.\r\n  ///         There is special case: a liquidation happens inside the pool adapter.\r\n  ///         It means, that this is \"dirty\" pool adapter and this position must be closed and never used again.\r\n  ///         In this case, both amounts are zero (we need to make FULL repay)\r\n  /// @return nextIndexToCheck0 Index of next pool-adapter to check; 0: all pool-adapters were checked\r\n  /// @return outPoolAdapters List of pool adapters that should be reconverted\r\n  /// @return outAmountBorrowAsset What borrow-asset amount should be send to pool adapter to fix health factor\r\n  /// @return outAmountCollateralAsset What collateral-asset amount should be send to pool adapter to fix health factor\r\n  function checkHealth(\r\n    uint startIndex0,\r\n    uint maxCountToCheck,\r\n    uint maxCountToReturn\r\n  ) external view override returns (\r\n    uint nextIndexToCheck0,\r\n    address[] memory outPoolAdapters,\r\n    uint[] memory outAmountBorrowAsset,\r\n    uint[] memory outAmountCollateralAsset\r\n  ) {\r\n    return _checkHealthFactor(\r\n      CheckHealthFactorInputParams({\r\n        startIndex0: startIndex0,\r\n        maxCountToCheck: maxCountToCheck,\r\n        maxCountToReturn: maxCountToReturn,\r\n        healthFactorThreshold18: uint(controller.minHealthFactor2()) * 10**(18-2)\r\n      })\r\n    );\r\n  }\r\n\r\n  function _checkHealthFactor (\r\n    CheckHealthFactorInputParams memory p\r\n  ) internal view returns (\r\n    uint nextIndexToCheck0,\r\n    address[] memory outPoolAdapters,\r\n    uint[] memory outAmountBorrowAsset,\r\n    uint[] memory outAmountCollateralAsset\r\n  ) {\r\n    uint countFoundItems = 0;\r\n    nextIndexToCheck0 = p.startIndex0;\r\n\r\n    outPoolAdapters = new address[](p.maxCountToReturn);\r\n    outAmountBorrowAsset = new uint[](p.maxCountToReturn);\r\n    outAmountCollateralAsset = new uint[](p.maxCountToReturn);\r\n\r\n    if (p.startIndex0 + p.maxCountToCheck > positions.length) {\r\n      p.maxCountToCheck = positions.length - p.startIndex0;\r\n    }\r\n\r\n    // enumerate all pool adapters\r\n    for (uint i = 0; i < p.maxCountToCheck; i = i.uncheckedInc()) {\r\n      nextIndexToCheck0 += 1;\r\n\r\n      // check if we need to make reconversion because the health factor is too low/high\r\n      IPoolAdapter pa = IPoolAdapter(positions[p.startIndex0 + i]);\r\n\r\n      (uint collateralAmount, uint amountToPay, uint healthFactor18,,) = pa.getStatus();\r\n      // If full liquidation happens we will have collateralAmount = 0 and amountToPay > 0\r\n      // In this case the open position should be just closed (we lost all collateral)\r\n      // We cannot do it here because it's read-only function.\r\n      // We should call a IKeeperCallback in the same way as for rebalancing, but with requiredAmountCollateralAsset=0\r\n\r\n      (,,, address borrowAsset) = pa.getConfig();\r\n      uint healthFactorTarget18 = uint(borrowManager.getTargetHealthFactor2(borrowAsset)) * 10**(18-2);\r\n      if (\r\n        (p.healthFactorThreshold18 < healthFactorTarget18 && healthFactor18 < p.healthFactorThreshold18) // unhealthy\r\n        || (!(p.healthFactorThreshold18 < healthFactorTarget18) && healthFactor18 > p.healthFactorThreshold18) // too healthy\r\n      ) {\r\n        outPoolAdapters[countFoundItems] = positions[p.startIndex0 + i];\r\n        // Health Factor = Collateral Factor * CollateralAmount * Price_collateral\r\n        //                 -------------------------------------------------\r\n        //                               BorrowAmount * Price_borrow\r\n        // => requiredAmountBorrowAsset = BorrowAmount * (HealthFactorCurrent/HealthFactorTarget - 1)\r\n        // => requiredAmountCollateralAsset = CollateralAmount * (HealthFactorTarget/HealthFactorCurrent - 1)\r\n        outAmountBorrowAsset[countFoundItems] = p.healthFactorThreshold18 < healthFactorTarget18\r\n            ? (amountToPay - amountToPay * healthFactor18 / healthFactorTarget18) // unhealthy\r\n            : (amountToPay * healthFactor18 / healthFactorTarget18 - amountToPay); // too healthy\r\n        outAmountCollateralAsset[countFoundItems] = p.healthFactorThreshold18 < healthFactorTarget18\r\n            ? (collateralAmount * healthFactorTarget18 / healthFactor18 - collateralAmount) // unhealthy\r\n            : (collateralAmount - collateralAmount * healthFactorTarget18 / healthFactor18); // too healthy\r\n        countFoundItems += 1;\r\n\r\n        if (countFoundItems == p.maxCountToReturn) {\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (nextIndexToCheck0 == positions.length) {\r\n      nextIndexToCheck0 = 0; // all items were checked\r\n    }\r\n\r\n    // we need to keep only found items in result array and remove others\r\n    return (nextIndexToCheck0,\r\n      countFoundItems == 0\r\n        ? new address[](0)\r\n        : AppUtils.removeLastItems(outPoolAdapters, countFoundItems),\r\n      countFoundItems == 0\r\n        ? new uint[](0)\r\n        : AppUtils.removeLastItems(outAmountBorrowAsset, countFoundItems),\r\n      countFoundItems == 0\r\n        ? new uint[](0)\r\n        : AppUtils.removeLastItems(outAmountCollateralAsset, countFoundItems)\r\n    );\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///                   Views\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Get active borrows of the user with given collateral/borrowToken\r\n  /// @return poolAdaptersOut The instances of IPoolAdapter\r\n  function getPositions (\r\n    address user_,\r\n    address collateralToken_,\r\n    address borrowedToken_\r\n  ) external view override returns (\r\n    address[] memory poolAdaptersOut\r\n  ) {\r\n    address[] memory adapters = poolAdapters[getPoolAdapterKey(user_, collateralToken_, borrowedToken_)];\r\n    uint countAdapters = adapters.length;\r\n\r\n    poolAdaptersOut = new address[](countAdapters);\r\n\r\n    for (uint i = 0; i < countAdapters; i = i.uncheckedInc()) {\r\n      poolAdaptersOut[i] = adapters[i];\r\n    }\r\n\r\n    return poolAdaptersOut;\r\n  }\r\n\r\n  /// @notice Get active borrows of the given user\r\n  /// @return poolAdaptersOut The instances of IPoolAdapter\r\n  function getPositionsForUser(address user_) external view override returns(\r\n    address[] memory poolAdaptersOut\r\n  ) {\r\n    EnumerableSet.AddressSet storage set = _poolAdaptersForUser[user_];\r\n    uint countAdapters = set.length();\r\n\r\n    poolAdaptersOut = new address[](countAdapters);\r\n\r\n    for (uint i = 0; i < countAdapters; i = i.uncheckedInc()) {\r\n      poolAdaptersOut[i] = set.at(i);\r\n    }\r\n\r\n    return poolAdaptersOut;\r\n  }\r\n\r\n  /// @notice Return true if there is a least once active pool adapter created on the base of the {converter_}\r\n  function isConverterInUse(address converter_) external view override returns (bool) {\r\n    return _poolAdaptersForConverters[converter_].length() != 0;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///                     Utils\r\n  ///////////////////////////////////////////////////////\r\n  function getPoolAdapterKey(\r\n    address user_,\r\n    address collateral_,\r\n    address borrowToken_\r\n  ) public pure returns (uint){\r\n    return uint(keccak256(abi.encodePacked(user_, collateral_, borrowToken_)));\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Access to arrays\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Get total count of pool adapters with opened positions\r\n  function getCountPositions() external view override returns (uint) {\r\n    return positions.length;\r\n  }\r\n\r\n  function poolAdaptersLength(\r\n    address user_,\r\n    address collateral_,\r\n    address borrowToken_\r\n  ) external view returns (uint) {\r\n    return poolAdapters[getPoolAdapterKey(user_, collateral_, borrowToken_)].length;\r\n  }\r\n}\r\n\r\n\r\n\r\n///////////////////////////////////////////////////////\r\n///     Features for NEXT versions of the app\r\n///         Detect not-optimal positions\r\n///         Check too healthy factor\r\n///////////////////////////////////////////////////////\r\n\r\n//  function checkAdditionalBorrow(\r\n//    uint startIndex0,\r\n//    uint maxCountToCheck,\r\n//    uint maxCountToReturn\r\n//  ) external view override returns (\r\n//    uint nextIndexToCheck0,\r\n//    address[] memory outPoolAdapters,\r\n//    uint[] memory outAmountsToBorrow\r\n//  ) {\r\n//    uint16 maxHealthFactor2 = IConverterController(controller).maxHealthFactor2();\r\n//\r\n//    return _checkHealthFactor(startIndex0\r\n//      , maxCountToCheck\r\n//      , maxCountToReturn\r\n//      , uint(maxHealthFactor2) * 10**(18-2)\r\n//    );\r\n//  }\r\n\r\n//  function checkBetterBorrowExists(\r\n//    uint startIndex0,\r\n//    uint maxCountToCheck,\r\n//    uint maxCountToReturn,\r\n//    uint periodInBlocks // TODO: this period is set individually for each borrow...\r\n//  ) external view override returns (\r\n//    uint nextIndexToCheck0,\r\n//    address[] memory outPoolAdapters\r\n//  ) {\r\n//    uint countFoundItems = 0;\r\n//    nextIndexToCheck0 = startIndex0;\r\n//\r\n//    ITetuConverter tc = ITetuConverter(controller.tetuConverter());\r\n//    outPoolAdapters = new address[](maxCountToReturn);\r\n//\r\n//    if (startIndex0 + maxCountToCheck > positions.length) {\r\n//      maxCountToCheck = positions.length - startIndex0;\r\n//    }\r\n//\r\n//    // enumerate all pool adapters\r\n//    for (uint i = 0; i < maxCountToCheck; i = i.uncheckedInc()) {\r\n//      nextIndexToCheck0 += 1;\r\n//\r\n//      // check if we need to make reconversion because a MUCH better borrow way exists\r\n//      IPoolAdapter pa = IPoolAdapter(positions[startIndex0 + i]);\r\n//      (uint collateralAmount,,,) = pa.getStatus();\r\n//\r\n//      if (_findBetterBorrowWay(tc, pa, collateralAmount, periodInBlocks)) {\r\n//        outPoolAdapters[countFoundItems] = positions[startIndex0 + i];\r\n//        countFoundItems += 1;\r\n//        if (countFoundItems == maxCountToReturn) {\r\n//          break;\r\n//        }\r\n//      }\r\n//    }\r\n//\r\n//    if (nextIndexToCheck0 == positions.length) {\r\n//      nextIndexToCheck0 = 0; // all items were checked\r\n//    }\r\n//\r\n//    // we need to keep only found items in result array and remove others\r\n//    return (nextIndexToCheck0\r\n//    , countFoundItems == 0\r\n//      ? new address[](0)\r\n//      : AppUtils.removeLastItems(outPoolAdapters, countFoundItems)\r\n//    );\r\n//  }\r\n//\r\n//  function _findBetterBorrowWay(\r\n//    ITetuConverter tc_,\r\n//    IPoolAdapter pa_,\r\n//    uint sourceAmount_,\r\n//    uint periodInBlocks_\r\n//  ) internal view returns (bool) {\r\n//\r\n//    // check if we can re-borrow the asset in different place with higher profit\r\n//    (address origin,, address sourceToken, address targetToken) = pa_.getConfig();\r\n//    (address converter,, int apr18) = tc_.findConversionStrategy(\r\n//      sourceToken, sourceAmount_, targetToken, periodInBlocks_, ITetuConverter.ConversionMode.AUTO_0\r\n//    );\r\n//    int currentApr18 = pa_.getAPR18() * int(periodInBlocks_);\r\n//\r\n//    // make decision if the new conversion-strategy is worth to be used instead current one\r\n//    if (origin != converter) {\r\n//      //1) threshold for APRs difference exceeds threshold, i.e. (apr0-apr1)/apr0 > 20%\r\n//      if (currentApr18 > apr18\r\n//         && (thresholdAPR == 0 || currentApr18 - apr18 > currentApr18 * int(thresholdAPR) / 100)\r\n//      ) {\r\n//        //2) threshold for block number: count blocks since prev rebalancing should exceed the threshold.\r\n//        if (thresholdCountBlocks == 0 || block.number - positionLastAccess[address(pa_)] > thresholdCountBlocks) {\r\n//          return true;\r\n//        }\r\n//      }\r\n//    }\r\n//    return false;\r\n//  }\r\n//\r\n//  function setThresholdAPR(uint value100_) external {\r\n//    _onlyGovernance();\r\n//    require(value100_ < 100, AppErrors.INCORRECT_VALUE);\r\n//    thresholdAPR = value100_;\r\n//    emit OnSetThresholdAPR(value100_);\r\n//  }\r\n//\r\n//  function setThresholdCountBlocks(uint countBlocks_) external {\r\n//    _onlyGovernance();\r\n//    // we don't need any restriction for countBlocks_\r\n//    // 0 - means, that the threshold is disabled\r\n//    thresholdCountBlocks = countBlocks_;\r\n//    emit OnSetThresholdCountBlocks(countBlocks_);\r\n//  }\r\n"
    },
    "@tetu_io/tetu-converter/contracts/core/Keeper.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppErrors.sol\";\r\nimport \"../libs/AppUtils.sol\";\r\nimport \"../interfaces/IHealthKeeperCallback.sol\";\r\nimport \"../interfaces/IConverterController.sol\";\r\nimport \"../interfaces/IDebtMonitor.sol\";\r\nimport \"../interfaces/IKeeperCallback.sol\";\r\nimport \"../integrations/gelato/IResolver.sol\";\r\nimport \"../integrations/gelato/OpsReady.sol\";\r\n\r\n/// @notice Executor + Resolver for Gelato\r\n///         to check health of opened positions and call requireRepay for unhealthy pool adapters\r\n///         Same keeper is also responsible for updating block-per-day value in controller.\r\ncontract Keeper is OpsReady, IHealthKeeperCallback, IResolver {\r\n  using AppUtils for uint;\r\n\r\n  /// @notice Max count of opened positions to be checked in single request\r\n  uint constant public maxCountToCheck = 500;\r\n\r\n  /// @notice Max count of unhealthy positions to be returned in single request\r\n  uint constant public maxCountToReturn = 1;\r\n\r\n  /// @notice Period of auto-update of the blocksPerDay-value in seconds\r\n  ///         0 - auto-update checking is disabled\r\n  uint public immutable blocksPerDayAutoUpdatePeriodSecs; // i.e. 2 * 7 * 24 * 60 * 60 for 2 weeks\r\n\r\n\r\n  /// @notice Start index of pool adapter for next checkHealth-request\r\n  ///         We store here result of previous call of IDebtMonitor.checkHealth\r\n  uint256 public override nextIndexToCheck0;\r\n  IConverterController immutable public controller;\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Events\r\n  ///////////////////////////////////////////////////////\r\n  event OnFixHealth(uint nextIndexToCheck0, address[] poolAdapters, uint[] amountBorrowAsset, uint[] amountCollateralAsset);\r\n\r\n  ///////////////////////////////////////////////////////////////////\r\n  ///              Initialization and configuration\r\n  ///////////////////////////////////////////////////////////////////\r\n  constructor(\r\n    address controller_,\r\n    address payable ops_,\r\n    uint blocksPerDayAutoUpdatePeriodSecs_\r\n  ) OpsReady(ops_) {\r\n    require(controller_ != address(0), AppErrors.ZERO_ADDRESS);\r\n    controller = IConverterController(controller_);\r\n    blocksPerDayAutoUpdatePeriodSecs = blocksPerDayAutoUpdatePeriodSecs_;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////\r\n  ///              Read-only gelato-resolver\r\n  ///////////////////////////////////////////////////////////////////\r\n\r\n  /// @notice Check health of opened positions starting from nth-position, where n = nextIndexToCheck0\r\n  /// @dev Read-only checker function called by Gelato.\r\n  /// @return canExecOut True if it's necessary to call rebalancing write-function\r\n  /// @return execPayloadOut Wrapped call of the rebalancing function (it will be called by Gelato)\r\n  function checker()\r\n  external\r\n  view\r\n  override\r\n  returns (\r\n    bool canExecOut,\r\n    bytes memory execPayloadOut\r\n  ) {\r\n    IDebtMonitor debtMonitor = IDebtMonitor(controller.debtMonitor());\r\n\r\n    // IHealthKeeperCallback is implemented inside this class\r\n    // but we access it through controller to be able to split checker and executor in unit tests\r\n    IHealthKeeperCallback keeper = IHealthKeeperCallback(controller.keeper());\r\n    uint startIndex = keeper.nextIndexToCheck0();\r\n\r\n    (\r\n      uint newNextIndexToCheck0,\r\n      address[] memory outPoolAdapters,\r\n      uint[] memory outAmountBorrowAsset,\r\n      uint[] memory outAmountCollateralAsset\r\n    ) = debtMonitor.checkHealth(\r\n      startIndex,\r\n      maxCountToCheck,\r\n      maxCountToReturn\r\n    );\r\n\r\n    // it's necessary to run writable fixHealth() ...\r\n    canExecOut =\r\n      // ... if there is unhealthy pool adapter\r\n      outPoolAdapters.length != 0\r\n\r\n      // ... if we cannot check all adapters in one pass; we've checked a one portion, now we need to check the other portions\r\n      || newNextIndexToCheck0 != startIndex\r\n\r\n      /// ... if it's the time to recalculate blocksPerDay value\r\n      || (blocksPerDayAutoUpdatePeriodSecs != 0\r\n          && controller.isBlocksPerDayAutoUpdateRequired(blocksPerDayAutoUpdatePeriodSecs)\r\n         );\r\n\r\n    execPayloadOut = abi.encodeWithSelector(\r\n      IHealthKeeperCallback.fixHealth.selector,\r\n      newNextIndexToCheck0,\r\n      outPoolAdapters,\r\n      outAmountBorrowAsset,\r\n      outAmountCollateralAsset\r\n    );\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////\r\n  ///            Executor to fix unhealthy pool adapters\r\n  ///////////////////////////////////////////////////////////////////\r\n\r\n  /// @notice Make rebalancing of the given unhealthy positions (a position == pool adapter)\r\n  ///         Call TetuConverter.requireRepay for each position\r\n  function fixHealth(\r\n    uint nextIndexToCheck0_,\r\n    address[] calldata poolAdapters_,\r\n    uint[] calldata amountBorrowAsset_,\r\n    uint[] calldata amountCollateralAsset_\r\n  ) external override onlyOps {\r\n    uint countPoolAdapters = poolAdapters_.length;\r\n    require(\r\n      countPoolAdapters == amountBorrowAsset_.length\r\n      && countPoolAdapters == amountCollateralAsset_.length,\r\n      AppErrors.WRONG_LENGTHS\r\n    );\r\n\r\n    nextIndexToCheck0 = nextIndexToCheck0_;\r\n\r\n    if (countPoolAdapters != 0) {\r\n      IKeeperCallback keeperCallback = IKeeperCallback(controller.tetuConverter());\r\n      for (uint i = 0; i < countPoolAdapters; i = i.uncheckedInc()) {\r\n        keeperCallback.requireRepay(\r\n          amountBorrowAsset_[i],\r\n          amountCollateralAsset_[i],\r\n          poolAdapters_[i]\r\n        );\r\n      }\r\n    }\r\n\r\n    if (blocksPerDayAutoUpdatePeriodSecs != 0\r\n        && controller.isBlocksPerDayAutoUpdateRequired(blocksPerDayAutoUpdatePeriodSecs)\r\n    ) {\r\n      controller.updateBlocksPerDay(blocksPerDayAutoUpdatePeriodSecs);\r\n    }\r\n\r\n    emit OnFixHealth(\r\n      nextIndexToCheck0_,\r\n      poolAdapters_,\r\n      amountBorrowAsset_,\r\n      amountCollateralAsset_\r\n    );\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/core/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppErrors.sol\";\r\nimport \"../interfaces/IPriceOracle.sol\";\r\nimport \"../integrations/aave3/IAavePriceOracle.sol\";\r\n\r\n/// @notice Trivial implementation of a price oracle as a wrapper of AAVE3 price oracle\r\ncontract PriceOracle is IPriceOracle {\r\n  IAavePriceOracle public immutable priceOracle;\r\n\r\n  constructor(address aave3priceOracle_) {\r\n    require(aave3priceOracle_ != address(0), AppErrors.ZERO_ADDRESS);\r\n    priceOracle = IAavePriceOracle(aave3priceOracle_);\r\n  }\r\n\r\n  /// @notice Return asset price in USD, decimals 18\r\n  function getAssetPrice(address asset) external view override returns (uint256) {\r\n    // AAVE3 price oracle returns price with decimals 1e8, we need decimals 18\r\n    try priceOracle.getAssetPrice(asset) returns (uint value) {\r\n      return value * 1e10;\r\n    } catch {}\r\n\r\n    return 0; // unknown asset or unknown price\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/core/SwapManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppErrors.sol\";\r\nimport \"../libs/AppDataTypes.sol\";\r\nimport \"../libs/SwapLib.sol\";\r\nimport \"../openzeppelin/IERC20Metadata.sol\";\r\nimport \"../openzeppelin/IERC20.sol\";\r\nimport \"../openzeppelin/SafeERC20.sol\";\r\nimport \"../interfaces/ISwapManager.sol\";\r\nimport \"../interfaces/IConverterController.sol\";\r\nimport \"../interfaces/ISwapConverter.sol\";\r\nimport \"../interfaces/IPriceOracle.sol\";\r\nimport \"../interfaces/ISimulateProvider.sol\";\r\nimport \"../interfaces/ISwapSimulator.sol\";\r\nimport \"../interfaces/IRequireAmountBySwapManagerCallback.sol\";\r\nimport \"../integrations/tetu/ITetuLiquidator.sol\";\r\n\r\n/// @title Contract to find the best swap and make the swap\r\n/// @notice Combines Manager and Converter\r\n/// @author bogdoslav\r\ncontract SwapManager is ISwapManager, ISwapConverter, ISimulateProvider, ISwapSimulator {\r\n  using SafeERC20 for IERC20;\r\n\r\n  IConverterController public immutable controller;\r\n  /// @notice Same as controller.priceOracle()\r\n  /// @dev Cached for the gas optimization\r\n  IPriceOracle public immutable priceOracle;\r\n  /// @notice Same as controller.tetuLiquidator()\r\n  /// @dev Cached for the gas optimization\r\n  ITetuLiquidator public immutable tetuLiquidator;\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Constants\r\n  ///////////////////////////////////////////////////////\r\n\r\n  int public constant APR_NUMERATOR = 10**18;\r\n\r\n  uint public constant PRICE_IMPACT_NUMERATOR = SwapLib.PRICE_IMPACT_NUMERATOR;\r\n  uint public constant PRICE_IMPACT_TOLERANCE_DEFAULT = SwapLib.PRICE_IMPACT_TOLERANCE_DEFAULT;\r\n\r\n  /// @notice Optional price impact tolerance for assets. If not set, PRICE_IMPACT_TOLERANCE_DEFAULT is used.\r\n  ///         asset => price impact tolerance (decimals are set by PRICE_IMPACT_NUMERATOR)\r\n  mapping (address => uint) public priceImpactTolerances;\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Events\r\n  ///////////////////////////////////////////////////////\r\n  event OnSwap(address sourceToken,\r\n    uint sourceAmount,\r\n    address targetToken,\r\n    address receiver,\r\n    uint outputAmount\r\n  );\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Initialization\r\n  ///////////////////////////////////////////////////////\r\n\r\n  constructor (\r\n    address controller_,\r\n    address tetuLiquidator_,\r\n    address priceOracle_\r\n  ) {\r\n    require(\r\n      controller_ != address(0)\r\n      && tetuLiquidator_ != address(0)\r\n      && priceOracle_ != address(0),\r\n      AppErrors.ZERO_ADDRESS\r\n    );\r\n    controller = IConverterController(controller_);\r\n    tetuLiquidator = ITetuLiquidator(tetuLiquidator_);\r\n    priceOracle = IPriceOracle(priceOracle_);\r\n  }\r\n\r\n  /// @notice Set custom price impact tolerance for the asset\r\n  /// @param priceImpactTolerance Set 0 to use default price impact tolerance for the {asset}.\r\n  ///                             Decimals = PRICE_IMPACT_NUMERATOR\r\n  function setPriceImpactTolerance(address asset_, uint priceImpactTolerance) external {\r\n    require(msg.sender == controller.governance(), AppErrors.GOVERNANCE_ONLY);\r\n    require(priceImpactTolerance <= PRICE_IMPACT_NUMERATOR, AppErrors.INCORRECT_VALUE);\r\n\r\n    priceImpactTolerances[asset_] = priceImpactTolerance;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///           Return best amount for swap\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Find a way to convert collateral asset to borrow asset in most efficient way\r\n  ///         The algo to convert source amount S1:\r\n  ///         - make real swap in static-call, get result max-target-amount\r\n  ///         - recalculate max-target-amount to source amount using prices from a PriceOracle = S2\r\n  ///         Result APR = 2 * (S1 - S2) / S1\r\n  /// @dev This is a writable function with read-only behavior\r\n  ///      because to simulate real swap the function should be writable.\r\n  /// @param sourceAmountApprover_ A contract which has approved {sourceAmount_} to TetuConverter\r\n  /// @param sourceAmount_ Amount in terms of {sourceToken_} to be converter to {targetToken_}\r\n  ///                      This amount must be approved by {sourceAmountApprover_} to TetuConverter before the call\r\n  /// @return converter Address of ISwapConverter\r\n  ///         If SwapManager cannot find a conversion way,\r\n  ///         it returns converter == 0 (in the same way as ITetuConverter)\r\n  function getConverter(\r\n    address sourceAmountApprover_,\r\n    address sourceToken_,\r\n    uint sourceAmount_,\r\n    address targetToken_\r\n  ) external override returns (\r\n    address converter,\r\n    uint maxTargetAmount\r\n  ) {\r\n    // there are no restrictions for the msg.sender\r\n\r\n    // Simulate real swap of source amount to max target amount\r\n    // We call SwapManager.simulateSwap() here as an external call\r\n    // and than revert all changes back\r\n    // We need additional try because !PRICE error can happen if a price impact is too high\r\n    try ISimulateProvider(address(this)).simulate(\r\n      address(this),\r\n      abi.encodeWithSelector(\r\n        ISwapSimulator.simulateSwap.selector,\r\n        sourceAmountApprover_,\r\n        sourceToken_,\r\n        sourceAmount_,\r\n        targetToken_\r\n      )\r\n    ) returns (bytes memory response) {\r\n      maxTargetAmount = abi.decode(response, (uint));\r\n    } catch {\r\n      // we can have i.e. !PRICE error (the price impact is too high)\r\n      // it means, there is no way to make the conversion with acceptable price impact\r\n      return (address(0), 0);\r\n    }\r\n\r\n    return maxTargetAmount == 0\r\n      ? (address(0), 0)\r\n      : (address(this), maxTargetAmount);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///           ISwapConverter Implementation\r\n  ///////////////////////////////////////////////////////\r\n\r\n  function getConversionKind() override external pure returns (AppDataTypes.ConversionKind) {\r\n    return AppDataTypes.ConversionKind.SWAP_1;\r\n  }\r\n\r\n  /// @notice Swap {amountIn_} of {sourceToken_} to {targetToken_} and send result amount to {receiver_}\r\n  ///         The swapping is made using TetuLiquidator.\r\n  /// @return amountOut The amount that has been sent to the receiver\r\n  function swap(\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_,\r\n    address receiver_\r\n  ) override external returns (uint amountOut) {\r\n    // there are no restrictions for the msg.sender\r\n    uint targetTokenBalanceBefore = IERC20(targetToken_).balanceOf(address(this));\r\n\r\n    IERC20(sourceToken_).safeApprove(address(tetuLiquidator), amountIn_);\r\n\r\n    // If price impact is too big, getConverter will return high APR\r\n    // So TetuConverter will select borrow, not swap.\r\n    // If the swap was selected anyway, it is wrong case.\r\n    // liquidate() will revert here and it's ok.\r\n\r\n    tetuLiquidator.liquidate(sourceToken_, targetToken_, amountIn_, _getPriceImpactTolerance(sourceToken_));\r\n    amountOut = IERC20(targetToken_).balanceOf(address(this)) - targetTokenBalanceBefore;\r\n\r\n    IERC20(targetToken_).safeTransfer(receiver_, amountOut);\r\n\r\n    // The result amount cannot be too different from the value calculated directly using price oracle prices\r\n    require(\r\n      SwapLib.isConversionValid(\r\n        priceOracle,\r\n        sourceToken_,\r\n        amountIn_,\r\n        targetToken_,\r\n        amountOut,\r\n        _getPriceImpactTolerance(targetToken_)\r\n      ),\r\n      AppErrors.TOO_HIGH_PRICE_IMPACT\r\n    );\r\n    emit OnSwap(sourceToken_, amountIn_, targetToken_, receiver_, amountOut);\r\n  }\r\n\r\n  /// @notice Make real swap to know result amount\r\n  ///         but exclude any additional operations\r\n  ///         like \"sending the result amount to a receiver\" or \"emitting any events\".\r\n  /// @dev This function should be called only inside static call to know result amount.\r\n  /// @param sourceAmountApprover_ A contract which has approved source amount to TetuConverter\r\n  ///                              and called a function findSwapStrategy\r\n  /// @param sourceAmount_ Amount in terms of {sourceToken_} to be converter to {targetToken_}\r\n  /// @return amountOut Result amount in terms of {targetToken_} after conversion\r\n  function simulateSwap(\r\n    address sourceAmountApprover_,\r\n    address sourceToken_,\r\n    uint sourceAmount_,\r\n    address targetToken_\r\n  ) external override returns (uint) {\r\n    require(msg.sender == controller.swapManager(), AppErrors.ONLY_SWAP_MANAGER);\r\n\r\n    IRequireAmountBySwapManagerCallback(controller.tetuConverter()).onRequireAmountBySwapManager(\r\n      sourceAmountApprover_,\r\n      sourceToken_,\r\n      sourceAmount_\r\n    );\r\n\r\n    uint targetTokenBalanceBefore = IERC20(targetToken_).balanceOf(address(this));\r\n\r\n    IERC20(sourceToken_).safeApprove(address(tetuLiquidator), sourceAmount_);\r\n    tetuLiquidator.liquidate(sourceToken_, targetToken_, sourceAmount_, _getPriceImpactTolerance(sourceToken_));\r\n    return IERC20(targetToken_).balanceOf(address(this)) - targetTokenBalanceBefore;\r\n  }\r\n\r\n  /// @notice Calculate APR using known {sourceToken_} and known {targetAmount_}\r\n  ///         as 2 * loss / sourceAmount\r\n  ///         loss - conversion loss, we use 2 multiplier to take into account losses for there and back conversions.\r\n  /// @param sourceAmount_ Source amount before conversion, in terms of {sourceToken_}\r\n  /// @param targetAmount_ Result of conversion. The amount is in terms of {targetToken_}\r\n  function getApr18(\r\n    address sourceToken_,\r\n    uint sourceAmount_,\r\n    address targetToken_,\r\n    uint targetAmount_\r\n  ) external view override returns (int) {\r\n    uint targetAmountInSourceTokens = SwapLib.convertUsingPriceOracle(\r\n      priceOracle,\r\n      targetToken_,\r\n      targetAmount_,\r\n      sourceToken_\r\n    );\r\n\r\n    // calculate result APR\r\n    // we need to multiple one-way-loss on to to get loss for there-and-back conversion\r\n    return 2 * (int(sourceAmount_) - int(targetAmountInSourceTokens)) * APR_NUMERATOR / int(sourceAmount_);\r\n  }\r\n\r\n  /// @notice Return custom or default price impact tolerance for the asset\r\n  function getPriceImpactTolerance(address asset_) external view override returns (uint priceImpactTolerance) {\r\n    return _getPriceImpactTolerance(asset_);\r\n  }\r\n\r\n  //////////////////////////////////////////////////////////////////////////////\r\n  ///           View functions\r\n  //////////////////////////////////////////////////////////////////////////////\r\n  /// @notice Return custom or default price impact tolerance for the asset\r\n  function _getPriceImpactTolerance(address asset_) internal view returns (uint priceImpactTolerance) {\r\n    priceImpactTolerance = priceImpactTolerances[asset_];\r\n    if (priceImpactTolerance == 0) {\r\n      priceImpactTolerance = PRICE_IMPACT_TOLERANCE_DEFAULT;\r\n    }\r\n  }\r\n\r\n  //////////////////////////////////////////////////////////////////////////////\r\n  ///           Simulate real swap\r\n  ///           using gnosis simulate() and simulateAndRevert() functions\r\n  ///           They are slightly more efficient than try/catch approach\r\n  ///           see SimulateTesterTest.ts\r\n  /////////////////////////////////////////////////////////////////////////////\r\n\r\n  /// Source: https://github.com/gnosis/util-contracts/blob/main/contracts/storage/StorageSimulation.sol\r\n  ///\r\n  /// @dev Performs a delegetecall on a targetContract in the context of self.\r\n  /// Internally reverts execution to avoid side effects (making it static).\r\n  ///\r\n  /// This method reverts with data equal to `abi.encode(bool(success), bytes(response))`.\r\n  /// Specifically, the `returndata` after a call to this method will be:\r\n  /// `success:bool || response.length:uint256 || response:bytes`.\r\n  ///\r\n  /// @param targetContract Address of the contract containing the code to execute.\r\n  /// @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\r\n  function simulateAndRevert(\r\n    address targetContract,\r\n    bytes memory calldataPayload\r\n  ) public {\r\n    // there are no restrictions for the msg.sender\r\n\r\n    assembly {\r\n      let success := delegatecall(\r\n        gas(),\r\n        targetContract,\r\n        add(calldataPayload, 0x20),\r\n        mload(calldataPayload),\r\n        0,\r\n        0\r\n      )\r\n\r\n      mstore(0x00, success)\r\n      mstore(0x20, returndatasize())\r\n      returndatacopy(0x40, 0, returndatasize())\r\n      revert(0, add(returndatasize(), 0x40))\r\n    }\r\n  }\r\n\r\n  ///  Source: https://github.com/gnosis/util-contracts/blob/main/contracts/storage/StorageAccessible.sol\r\n  ///  @dev Simulates a delegate call to a target contract in the context of self.\r\n  ///\r\n  ///  Internally reverts execution to avoid side effects (making it static).\r\n  ///  Catches revert and returns encoded result as bytes.\r\n  ///\r\n  ///  @param targetContract Address of the contract containing the code to execute.\r\n  ///  @param calldataPayload Calldata that should be sent to the target contract (encoded method name and arguments).\r\n  function simulate(\r\n    address targetContract,\r\n    bytes calldata calldataPayload\r\n  ) external override returns (bytes memory response) {\r\n    // there are no restrictions for the msg.sender\r\n\r\n    // Suppress compiler warnings about not using parameters, while allowing\r\n    // parameters to keep names for documentation purposes. This does not\r\n    // generate code.\r\n    targetContract;\r\n    calldataPayload;\r\n\r\n    assembly {\r\n      let internalCalldata := mload(0x40)\r\n    // Store `simulateAndRevert.selector`.\r\n      mstore(internalCalldata, \"\\xb4\\xfa\\xba\\x09\")\r\n    // Abuse the fact that both this and the internal methods have the\r\n    // same signature, and differ only in symbol name (and therefore,\r\n    // selector) and copy calldata directly. This saves us approximately\r\n    // 250 bytes of code and 300 gas at runtime over the\r\n    // `abi.encodeWithSelector` builtin.\r\n      calldatacopy(\r\n        add(internalCalldata, 0x04),\r\n        0x04,\r\n        sub(calldatasize(), 0x04)\r\n      )\r\n\r\n    // `pop` is required here by the compiler, as top level expressions\r\n    // can't have return values in inline assembly. `call` typically\r\n    // returns a 0 or 1 value indicated whether or not it reverted, but\r\n    // since we know it will always revert, we can safely ignore it.\r\n      pop(call(\r\n        gas(),\r\n        address(),\r\n        0,\r\n        internalCalldata,\r\n        calldatasize(),\r\n        // The `simulateAndRevert` call always reverts, and instead\r\n        // encodes whether or not it was successful in the return data.\r\n        // The first 32-byte word of the return data contains the\r\n        // `success` value, so write it to memory address 0x00 (which is\r\n        // reserved Solidity scratch space and OK to use).\r\n        0x00,\r\n        0x20\r\n      ))\r\n\r\n\r\n    // Allocate and copy the response bytes, making sure to increment\r\n    // the free memory pointer accordingly (in case this method is\r\n    // called as an internal function). The remaining `returndata[0x20:]`\r\n    // contains the ABI encoded response bytes, so we can just write it\r\n    // as is to memory.\r\n      let responseSize := sub(returndatasize(), 0x20)\r\n      response := mload(0x40)\r\n      mstore(0x40, add(response, responseSize))\r\n      returndatacopy(response, 0x20, responseSize)\r\n\r\n      if iszero(mload(0x00)) {\r\n        revert(add(response, 0x20), mload(response))\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/core/TetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppDataTypes.sol\";\r\nimport \"../libs/AppErrors.sol\";\r\nimport \"../libs/AppUtils.sol\";\r\nimport \"../libs/EntryKinds.sol\";\r\nimport \"../libs/SwapLib.sol\";\r\nimport \"../openzeppelin/IERC20Metadata.sol\";\r\nimport \"../openzeppelin/SafeERC20.sol\";\r\nimport \"../openzeppelin/IERC20.sol\";\r\nimport \"../openzeppelin/ReentrancyGuard.sol\";\r\nimport \"../interfaces/IBorrowManager.sol\";\r\nimport \"../interfaces/ISwapManager.sol\";\r\nimport \"../interfaces/ITetuConverter.sol\";\r\nimport \"../interfaces/IPlatformAdapter.sol\";\r\nimport \"../interfaces/IPoolAdapter.sol\";\r\nimport \"../interfaces/IConverterController.sol\";\r\nimport \"../interfaces/IDebtMonitor.sol\";\r\nimport \"../interfaces/IConverter.sol\";\r\nimport \"../interfaces/ISwapConverter.sol\";\r\nimport \"../interfaces/IKeeperCallback.sol\";\r\nimport \"../interfaces/ITetuConverterCallback.sol\";\r\nimport \"../interfaces/IRequireAmountBySwapManagerCallback.sol\";\r\nimport \"../interfaces/IPriceOracle.sol\";\r\nimport \"../integrations/tetu/ITetuLiquidator.sol\";\r\n\r\n/// @notice Main application contract\r\ncontract TetuConverter is ITetuConverter, IKeeperCallback, IRequireAmountBySwapManagerCallback, ReentrancyGuard {\r\n  using SafeERC20 for IERC20;\r\n  using AppUtils for uint;\r\n\r\n  /// @notice After additional borrow result health factor should be near to target value, the difference is limited.\r\n  uint constant public ADDITIONAL_BORROW_DELTA_DENOMINATOR = 1;\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///                Members\r\n  ///////////////////////////////////////////////////////\r\n\r\n  IConverterController public immutable override controller;\r\n\r\n  /// We cache immutable addresses here to avoid exceed calls to the controller\r\n  IBorrowManager public immutable borrowManager;\r\n  IDebtMonitor public immutable debtMonitor;\r\n  ISwapManager public immutable swapManager;\r\n  address public immutable keeper;\r\n  IPriceOracle public immutable priceOracle;\r\n\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///                Data types\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Local vars for {findConversionStrategy}\r\n  struct FindConversionStrategyLocal {\r\n    address[] borrowConverters;\r\n    uint[] borrowSourceAmounts;\r\n    uint[] borrowTargetAmounts;\r\n    int[] borrowAprs18;\r\n    address swapConverter;\r\n    uint swapSourceAmount;\r\n    uint swapTargetAmount;\r\n    int swapApr18;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///               Events\r\n  ///////////////////////////////////////////////////////\r\n  event OnSwap(\r\n    address signer,\r\n    address converter,\r\n    address sourceAsset,\r\n    uint sourceAmount,\r\n    address targetAsset,\r\n    address receiver,\r\n    uint targetAmountOut\r\n  );\r\n\r\n  event OnBorrow(\r\n    address poolAdapter,\r\n    uint collateralAmount,\r\n    uint amountToBorrow,\r\n    address receiver,\r\n    uint borrowedAmountOut\r\n  );\r\n\r\n  event OnRepayBorrow(\r\n    address poolAdapter,\r\n    uint amountToRepay,\r\n    address receiver,\r\n    bool closePosition\r\n  );\r\n\r\n  /// @notice A part of target amount cannot be repaid or swapped\r\n  ///         so it was just returned back to receiver as is\r\n  event OnRepayReturn(\r\n    address asset,\r\n    address receiver,\r\n    uint amount\r\n  );\r\n\r\n  event OnRequireRepayCloseLiquidatedPosition(\r\n    address poolAdapter,\r\n    uint statusAmountToPay\r\n  );\r\n\r\n  event OnRequireRepayRebalancing(\r\n    address poolAdapter,\r\n    uint amount,\r\n    bool isCollateral,\r\n    uint statusAmountToPay,\r\n    uint healthFactorAfterRepay18\r\n  );\r\n\r\n  event OnClaimRewards(\r\n    address poolAdapter,\r\n    address rewardsToken,\r\n    uint amount,\r\n    address receiver\r\n  );\r\n\r\n  event OnSafeLiquidate(\r\n    address sourceToken,\r\n    uint sourceAmount,\r\n    address targetToken,\r\n    address receiver,\r\n    uint outputAmount\r\n  );\r\n\r\n  event OnRepayTheBorrow(\r\n    address poolAdapter,\r\n    uint collateralOut,\r\n    uint repaidAmountOut\r\n  );\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///                Initialization\r\n  ///////////////////////////////////////////////////////\r\n\r\n  constructor(\r\n    address controller_,\r\n    address borrowManager_,\r\n    address debtMonitor_,\r\n    address swapManager_,\r\n    address keeper_,\r\n    address priceOracle_\r\n  ) {\r\n    require(\r\n      controller_ != address(0)\r\n      && borrowManager_ != address(0)\r\n      && debtMonitor_ != address(0)\r\n      && swapManager_ != address(0)\r\n      && keeper_ != address(0)\r\n      && priceOracle_ != address(0),\r\n      AppErrors.ZERO_ADDRESS\r\n    );\r\n\r\n    controller = IConverterController(controller_);\r\n    borrowManager = IBorrowManager(borrowManager_);\r\n    debtMonitor = IDebtMonitor(debtMonitor_);\r\n    swapManager = ISwapManager(swapManager_);\r\n    keeper = keeper_;\r\n    priceOracle = IPriceOracle(priceOracle_);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Find best strategy for conversion\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Find best conversion strategy (swap or borrow) and provide \"cost of money\" as interest for the period.\r\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\r\n  /// @dev This is writable function with read-only behavior.\r\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\r\n  /// @param amountIn_  The meaning depends on entryData\r\n  ///                   For entryKind=0 it's max available amount of collateral\r\n  ///                   This amount must be approved to TetuConverter before the call.\r\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\r\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\r\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\r\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\r\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\r\n  ///                            It can be different from the {sourceAmount_} for some entry kinds.\r\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\r\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\r\n  function findConversionStrategy(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_,\r\n    uint periodInBlocks_\r\n  ) external override returns (\r\n    address converter,\r\n    uint collateralAmountOut,\r\n    uint amountToBorrowOut,\r\n    int apr18\r\n  ) {\r\n    require(amountIn_ != 0, AppErrors.ZERO_AMOUNT);\r\n    require(periodInBlocks_ != 0, AppErrors.INCORRECT_VALUE);\r\n\r\n    FindConversionStrategyLocal memory p;\r\n    if (!controller.paused()) {\r\n      (p.borrowConverters,\r\n       p.borrowSourceAmounts,\r\n       p.borrowTargetAmounts,\r\n       p.borrowAprs18\r\n      ) = borrowManager.findConverter(entryData_, sourceToken_, targetToken_, amountIn_, periodInBlocks_);\r\n\r\n      (p.swapConverter,\r\n       p.swapSourceAmount,\r\n       p.swapTargetAmount,\r\n       p.swapApr18) = _findSwapStrategy(entryData_, sourceToken_, amountIn_, targetToken_);\r\n    }\r\n\r\n    if (p.borrowConverters.length == 0) {\r\n      return (p.swapConverter == address(0))\r\n        ? (address(0), uint(0), uint(0), int(0))\r\n        : (p.swapConverter, p.swapSourceAmount, p.swapTargetAmount, p.swapApr18);\r\n    } else {\r\n      if (p.swapConverter == address(0)) {\r\n        return (p.borrowConverters[0], p.borrowSourceAmounts[0], p.borrowTargetAmounts[0], p.borrowAprs18[0]);\r\n      } else {\r\n        return (p.swapApr18 > p.borrowAprs18[0])\r\n          ? (p.borrowConverters[0], p.borrowSourceAmounts[0], p.borrowTargetAmounts[0], p.borrowAprs18[0])\r\n          : (p.swapConverter, p.swapSourceAmount, p.swapTargetAmount, p.swapApr18);\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Find possible borrow strategies and provide \"cost of money\" as interest for the period for each strategy\r\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\r\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\r\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\r\n  ///                   0 is used by default\r\n  /// @param amountIn_  The meaning depends on entryData\r\n  ///                   For entryKind=0 it's max available amount of collateral\r\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\r\n  /// @return converters Array of available converters ordered in ascending order of APR.\r\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\r\n  ///                    This address should be passed to borrow-function during conversion.\r\n  ///                    The length of array is always equal to the count of available lending platforms.\r\n  ///                    Last items in array can contain zero addresses (it means they are not used)\r\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\r\n  /// @return amountToBorrowsOut Amounts that should be borrowed\r\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\r\n  function findBorrowStrategies(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_,\r\n    uint periodInBlocks_\r\n  ) external view override returns (\r\n    address[] memory converters,\r\n    uint[] memory collateralAmountsOut,\r\n    uint[] memory amountToBorrowsOut,\r\n    int[] memory aprs18\r\n  ) {\r\n    require(amountIn_ != 0, AppErrors.ZERO_AMOUNT);\r\n    require(periodInBlocks_ != 0, AppErrors.INCORRECT_VALUE);\r\n\r\n    return controller.paused()\r\n      ? (converters, collateralAmountsOut, amountToBorrowsOut, aprs18) // no conversion is available\r\n      : borrowManager.findConverter(entryData_, sourceToken_, targetToken_, amountIn_, periodInBlocks_);\r\n  }\r\n\r\n  /// @notice Find best swap strategy and provide \"cost of money\" as interest for the period\r\n  /// @dev This is writable function with read-only behavior.\r\n  ///      It should be writable to be able to simulate real swap and get a real APR.\r\n  /// @param amountIn_  The meaning depends on entryData\r\n  ///                   For entryKind=0 it's max available amount of collateral\r\n  ///                   This amount must be approved to TetuConverter before the call.\r\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\r\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\r\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\r\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\r\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\r\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\r\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\r\n  function findSwapStrategy(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_\r\n  ) external override returns (\r\n    address converter,\r\n    uint sourceAmountOut,\r\n    uint targetAmountOut,\r\n    int apr18\r\n  ) {\r\n    require(amountIn_ != 0, AppErrors.ZERO_AMOUNT);\r\n\r\n    return controller.paused()\r\n      ? (converter, sourceAmountOut, targetAmountOut, apr18) // no conversion is available\r\n      : _findSwapStrategy(entryData_, sourceToken_, amountIn_, targetToken_);\r\n  }\r\n\r\n  /// @notice Calculate amount to swap according to the given {entryData_} and estimate result amount of {targetToken_}\r\n  function _findSwapStrategy(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_\r\n  ) internal returns (\r\n    address converter,\r\n    uint sourceAmountOut,\r\n    uint targetAmountOut,\r\n    int apr18\r\n  ) {\r\n    uint entryKind = EntryKinds.getEntryKind(entryData_);\r\n    if (entryKind == EntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\r\n      // Split {sourceAmount_} on two parts: C1 and C2. Swap C2 => {targetAmountOut}\r\n      // Result cost of {targetAmountOut} and C1 should be equal or almost equal\r\n      // For simplicity we assume here that swap doesn't have any lost:\r\n      // if S1 is swapped to S2 then costs of S1 and S2 are equal\r\n      sourceAmountOut = EntryKinds.getCollateralAmountToConvert(entryData_, amountIn_, 1, 1);\r\n    } else {\r\n      sourceAmountOut = amountIn_;\r\n    }\r\n\r\n    (converter, targetAmountOut) = swapManager.getConverter(\r\n      msg.sender,\r\n      sourceToken_,\r\n      sourceAmountOut,\r\n      targetToken_\r\n    );\r\n    if (converter != address(0)) {\r\n      apr18 = swapManager.getApr18(sourceToken_, sourceAmountOut, targetToken_, targetAmountOut);\r\n    }\r\n\r\n    return (converter, sourceAmountOut, targetAmountOut, apr18);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Make conversion, open position\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\r\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\r\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\r\n  ///      Only whitelisted users are allowed to make borrows\r\n  /// @param converter_ A converter received from findBestConversionStrategy.\r\n  /// @param collateralAmount_ Amount of {collateralAsset_}.\r\n  ///                          This amount must be approved to TetuConverter before the call.\r\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\r\n  /// @param receiver_ A receiver of borrowed amount\r\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\r\n  function borrow(\r\n    address converter_,\r\n    address collateralAsset_,\r\n    uint collateralAmount_,\r\n    address borrowAsset_,\r\n    uint amountToBorrow_,\r\n    address receiver_\r\n  ) external override nonReentrant returns (\r\n    uint borrowedAmountOut\r\n  ) {\r\n    require(controller.isWhitelisted(msg.sender), AppErrors.OUT_OF_WHITE_LIST);\r\n    return _convert(\r\n      converter_,\r\n      collateralAsset_,\r\n      collateralAmount_,\r\n      borrowAsset_,\r\n      amountToBorrow_,\r\n      receiver_\r\n    );\r\n  }\r\n\r\n  function _convert(\r\n    address converter_,\r\n    address collateralAsset_,\r\n    uint collateralAmount_,\r\n    address borrowAsset_,\r\n    uint amountToBorrow_,\r\n    address receiver_\r\n  ) internal returns (\r\n    uint borrowedAmountOut\r\n  ) {\r\n    require(receiver_ != address(0) && converter_ != address(0), AppErrors.ZERO_ADDRESS);\r\n    require(collateralAmount_ != 0 && amountToBorrow_ != 0, AppErrors.ZERO_AMOUNT);\r\n\r\n    IERC20(collateralAsset_).safeTransferFrom(msg.sender, address(this), collateralAmount_);\r\n\r\n    AppDataTypes.ConversionKind conversionKind = IConverter(converter_).getConversionKind();\r\n    if (conversionKind == AppDataTypes.ConversionKind.BORROW_2) {\r\n      // make borrow\r\n      // get exist or register new pool adapter\r\n      address poolAdapter = borrowManager.getPoolAdapter(converter_, msg.sender, collateralAsset_, borrowAsset_);\r\n\r\n      if (poolAdapter != address(0)) {\r\n        // the pool adapter can have three possible states:\r\n        // - healthy (normal), it's ok to make new borrow using the pool adapter\r\n        // - unhealthy, health factor is less 1. It means that liquidation happens and the pool adapter is not usable.\r\n        // - unhealthy, health factor is greater 1 but it's less min-allowed-value.\r\n        //              It means, that because of some reasons keeper doesn't make rebalance\r\n        (,, uint healthFactor18,,) = IPoolAdapter(poolAdapter).getStatus();\r\n        if (healthFactor18 < 1e18) {\r\n          // the pool adapter is unhealthy, we should mark it as dirty and create new pool adapter for the borrow\r\n          borrowManager.markPoolAdapterAsDirty(converter_, msg.sender, collateralAsset_, borrowAsset_);\r\n          poolAdapter = address(0);\r\n        } else if (healthFactor18 <= (uint(controller.minHealthFactor2()) * 10**(18-2))) {\r\n          // this is not normal situation\r\n          // keeper doesn't work? it's too risky to make new borrow\r\n          revert(AppErrors.REBALANCING_IS_REQUIRED);\r\n        }\r\n      }\r\n\r\n      // create new pool adapter if we don't have ready-to-borrow one\r\n      if (poolAdapter == address(0)) {\r\n        poolAdapter = borrowManager.registerPoolAdapter(\r\n          converter_,\r\n          msg.sender,\r\n          collateralAsset_,\r\n          borrowAsset_\r\n        );\r\n\r\n        // TetuConverter doesn't keep assets on its balance, so it's safe to use infinity approve\r\n        // All approves replaced by infinity-approve were commented in the code below\r\n        IERC20(collateralAsset_).safeApprove(poolAdapter, 2**255); // 2*255 is more gas-efficient than type(uint).max\r\n        IERC20(borrowAsset_).safeApprove(poolAdapter, 2**255); // 2*255 is more gas-efficient than type(uint).max\r\n      }\r\n\r\n      // replaced by infinity approve: IERC20(collateralAsset_).safeApprove(poolAdapter, collateralAmount_);\r\n\r\n      // borrow target-amount and transfer borrowed amount to the receiver\r\n      borrowedAmountOut = IPoolAdapter(poolAdapter).borrow(collateralAmount_, amountToBorrow_, receiver_);\r\n      emit OnBorrow(poolAdapter, collateralAmount_, amountToBorrow_, receiver_, borrowedAmountOut);\r\n    } else if (conversionKind == AppDataTypes.ConversionKind.SWAP_1) {\r\n      require(converter_ == address(swapManager), AppErrors.INCORRECT_CONVERTER_TO_SWAP);\r\n      borrowedAmountOut = _makeSwap(\r\n        converter_,\r\n        collateralAsset_,\r\n        collateralAmount_,\r\n        borrowAsset_,\r\n        receiver_\r\n      );\r\n    } else {\r\n      revert(AppErrors.UNSUPPORTED_CONVERSION_KIND);\r\n    }\r\n  }\r\n\r\n  /// @notice Transfer {sourceAmount_} to swap-converter, make swap, return result target amount\r\n  function _makeSwap(\r\n    address swapConverter_,\r\n    address sourceAsset_,\r\n    uint sourceAmount_,\r\n    address targetAsset_,\r\n    address receiver_\r\n  ) internal returns (uint amountOut) {\r\n    IERC20(sourceAsset_).safeTransfer(swapConverter_, sourceAmount_);\r\n    amountOut = ISwapConverter(swapConverter_).swap(\r\n      sourceAsset_,\r\n      sourceAmount_,\r\n      targetAsset_,\r\n      receiver_\r\n    );\r\n\r\n    emit OnSwap(msg.sender, swapConverter_, sourceAsset_, sourceAmount_, targetAsset_, receiver_, amountOut);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Make repay, close position\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Full or partial repay of the borrow\r\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\r\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\r\n  ///                       You can know exact total amount of debt using {getStatusCurrent}.\r\n  ///                       if the amount exceed total amount of the debt:\r\n  ///                       - the debt will be fully repaid\r\n  ///                       - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\r\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\r\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\r\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\r\n  ///         If TetuConverter is not able to make the swap, it reverts\r\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\r\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\r\n  ///                                 This amount is returned back to the collateralReceiver_\r\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\r\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\r\n  function repay(\r\n    address collateralAsset_,\r\n    address borrowAsset_,\r\n    uint amountToRepay_,\r\n    address receiver_\r\n  ) external override nonReentrant returns (\r\n    uint collateralAmountOut,\r\n    uint returnedBorrowAmountOut,\r\n    uint swappedLeftoverCollateralOut,\r\n    uint swappedLeftoverBorrowOut\r\n  ) {\r\n    require(receiver_ != address(0), AppErrors.ZERO_ADDRESS);\r\n\r\n    // ensure that we have received required amount\r\n    require(amountToRepay_ <= IERC20(borrowAsset_).balanceOf(address(this)), AppErrors.WRONG_AMOUNT_RECEIVED);\r\n\r\n    // we will decrease amountToRepay_ in the code (to avoid creation additional variable)\r\n    // it shows how much is left to convert from borrow asset to collateral asset\r\n\r\n    // we need to repay exact amount using any pool adapters\r\n    // simplest strategy: use first available pool adapter\r\n    address[] memory poolAdapters = debtMonitor.getPositions(msg.sender, collateralAsset_, borrowAsset_);\r\n    uint lenPoolAdapters = poolAdapters.length;\r\n\r\n    // at first repay debts for any opened positions\r\n    // repay don't make any rebalancing here\r\n    for (uint i = 0; i < lenPoolAdapters; i = i.uncheckedInc()) {\r\n      if (amountToRepay_ == 0) {\r\n        break;\r\n      }\r\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\r\n      pa.updateStatus();\r\n\r\n      (,uint totalDebtForPoolAdapter,,,) = pa.getStatus();\r\n      uint amountToPayToPoolAdapter = amountToRepay_ >= totalDebtForPoolAdapter\r\n        ? totalDebtForPoolAdapter\r\n        : amountToRepay_;\r\n\r\n      // replaced by infinity approve: IERC20(borrowAsset_).safeApprove(address(pa), amountToPayToPoolAdapter);\r\n\r\n      // make repayment\r\n      bool closePosition = amountToPayToPoolAdapter == totalDebtForPoolAdapter;\r\n      collateralAmountOut += pa.repay(amountToPayToPoolAdapter, receiver_, closePosition);\r\n      amountToRepay_ -= amountToPayToPoolAdapter;\r\n\r\n      emit OnRepayBorrow(address(pa), amountToPayToPoolAdapter, receiver_, closePosition);\r\n    }\r\n\r\n    // if all debts were paid but we still have some amount of borrow asset\r\n    // let's swap it to collateral asset and send to collateral-receiver\r\n    if (amountToRepay_ > 0) {\r\n      // getConverter requires the source amount be approved to TetuConverter, but a contract doesn't need to approve itself\r\n      (address converter,) = swapManager.getConverter(address(this), borrowAsset_, amountToRepay_, collateralAsset_);\r\n\r\n      if (converter == address(0)) {\r\n        // there is no swap-strategy to convert remain {amountToPay} to {collateralAsset_}\r\n        // let's return this amount back to the {receiver_}\r\n        returnedBorrowAmountOut = amountToRepay_;\r\n        IERC20(borrowAsset_).safeTransfer(receiver_, amountToRepay_);\r\n        emit OnRepayReturn(borrowAsset_, receiver_, amountToRepay_);\r\n      } else {\r\n        // conversion strategy is found\r\n        // let's convert all remaining {amountToPay} to {collateralAsset}\r\n        swappedLeftoverCollateralOut = _makeSwap(converter, borrowAsset_, amountToRepay_, collateralAsset_, receiver_);\r\n        swappedLeftoverBorrowOut = amountToRepay_;\r\n\r\n        collateralAmountOut += swappedLeftoverCollateralOut;\r\n      }\r\n    }\r\n\r\n    return (collateralAmountOut, returnedBorrowAmountOut, swappedLeftoverCollateralOut, swappedLeftoverBorrowOut);\r\n  }\r\n\r\n  /// @notice Estimate result amount after making full or partial repay\r\n  /// @dev It works in exactly same way as repay() but don't make actual repay\r\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\r\n  /// @param user_ user whose amount-to-repay will be calculated\r\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\r\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\r\n  function quoteRepay(\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_,\r\n    uint amountToRepay_\r\n  ) external override returns (\r\n    uint collateralAmountOut\r\n  ) {\r\n    address[] memory poolAdapters = debtMonitor.getPositions(\r\n      user_,\r\n      collateralAsset_,\r\n      borrowAsset_\r\n    );\r\n    uint lenPoolAdapters = poolAdapters.length;\r\n    for (uint i = 0; i < lenPoolAdapters; i = i.uncheckedInc()) {\r\n      if (amountToRepay_ == 0) {\r\n        break;\r\n      }\r\n\r\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\r\n\r\n      pa.updateStatus();\r\n      (, uint totalDebtForPoolAdapter,,,) = pa.getStatus();\r\n\r\n      bool closePosition = totalDebtForPoolAdapter <= amountToRepay_;\r\n      uint currentAmountToRepay = closePosition ? totalDebtForPoolAdapter : amountToRepay_;\r\n      uint collateralAmountToReceive = pa.getCollateralAmountToReturn(currentAmountToRepay, closePosition);\r\n\r\n      amountToRepay_ -= currentAmountToRepay;\r\n      collateralAmountOut += collateralAmountToReceive;\r\n    }\r\n\r\n    if (amountToRepay_ > 0) {\r\n      uint priceBorrowAsset = priceOracle.getAssetPrice(borrowAsset_);\r\n      uint priceCollateralAsset = priceOracle.getAssetPrice(collateralAsset_);\r\n      require(priceCollateralAsset != 0 && priceBorrowAsset != 0, AppErrors.ZERO_PRICE);\r\n\r\n      collateralAmountOut += amountToRepay_\r\n        * 10**IERC20Metadata(collateralAsset_).decimals()\r\n        * priceBorrowAsset\r\n        / priceCollateralAsset\r\n        / 10**IERC20Metadata(borrowAsset_).decimals();\r\n    }\r\n\r\n    return collateralAmountOut;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       IKeeperCallback\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice This function is called by a keeper if there is unhealthy borrow\r\n  ///         The called contract should send either collateral-amount or borrowed-amount to TetuConverter\r\n  /// @param requiredBorrowedAmount_ The borrower should return given borrowed amount back to TetuConverter\r\n  ///                                in order to restore health factor to target value\r\n  /// @param requiredCollateralAmount_ The borrower should send given amount of collateral to TetuConverter\r\n  ///                                  in order to restore health factor to target value\r\n  /// @param poolAdapter_ Address of the pool adapter that has problem health factor\r\n  function requireRepay(\r\n    uint requiredBorrowedAmount_,\r\n    uint requiredCollateralAmount_,\r\n    address poolAdapter_\r\n  ) external nonReentrant override {\r\n    require(keeper == msg.sender, AppErrors.KEEPER_ONLY);\r\n    require(requiredBorrowedAmount_ != 0, AppErrors.INCORRECT_VALUE);\r\n\r\n    IPoolAdapter pa = IPoolAdapter(poolAdapter_);\r\n    (,address user, address collateralAsset,) = pa.getConfig();\r\n    pa.updateStatus();\r\n    (, uint amountToPay,,,) = pa.getStatus();\r\n\r\n    if (requiredCollateralAmount_ == 0) {\r\n      // Full liquidation happens, we have lost all collateral amount\r\n      // We need to close the position as is and drop away the pool adapter without paying any debt\r\n      debtMonitor.closeLiquidatedPosition(address(pa));\r\n      emit OnRequireRepayCloseLiquidatedPosition(address(pa), amountToPay);\r\n    } else {\r\n      // rebalancing\r\n      require(amountToPay != 0 && requiredBorrowedAmount_ < amountToPay, AppErrors.REPAY_TO_REBALANCE_NOT_ALLOWED);\r\n\r\n      // for borrowers it's much easier to return collateral asset than borrow asset\r\n      // so ask the borrower to send us collateral asset\r\n      uint balanceBefore = IERC20(collateralAsset).balanceOf(address(this));\r\n      ITetuConverterCallback(user).requirePayAmountBack(collateralAsset, requiredCollateralAmount_);\r\n      uint balanceAfter = IERC20(collateralAsset).balanceOf(address(this));\r\n\r\n      // ensure that we have received any amount .. and use it for repayment\r\n      // probably we've received less then expected - it's ok, just let's use as much as possible\r\n      // DebtMonitor will ask to make rebalancing once more if necessary\r\n      require(\r\n        balanceAfter > balanceBefore // smth is wrong\r\n        && balanceAfter - balanceBefore <= requiredCollateralAmount_, // we can receive less amount (partial rebalancing)\r\n        AppErrors.WRONG_AMOUNT_RECEIVED\r\n      );\r\n      uint amount = balanceAfter - balanceBefore;\r\n      // replaced by infinity approve: IERC20(collateralAsset).safeApprove(poolAdapter_, requiredAmountCollateralAsset_);\r\n\r\n      uint resultHealthFactor18 = pa.repayToRebalance(amount, true);\r\n      emit OnRequireRepayRebalancing(address(pa), amount, true, amountToPay, resultHealthFactor18);\r\n    }\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Close borrow forcibly by governance\r\n  ///////////////////////////////////////////////////////\r\n  /// @notice Close given borrow and return collateral back to the user, governance only\r\n  /// @dev The pool adapter asks required amount-to-repay from the user internally.\r\n  ///      It notifies the user about any amounts transferred to the user on borrow closing.\r\n  /// @param poolAdapter_ The pool adapter that represents the borrow\r\n  /// @param closePosition Close position after repay\r\n  ///        Usually it should be true, because the function always tries to repay all debt\r\n  ///        false can be used if user doesn't have enough amount to pay full debt\r\n  ///              and we are trying to pay \"as much as possible\"\r\n  /// @return collateralAmountOut Amount of collateral returned to the user\r\n  /// @return repaidAmountOut Amount of borrow asset repaid to the lending platform\r\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\r\n    uint collateralAmountOut,\r\n    uint repaidAmountOut\r\n  ) {\r\n    require(msg.sender == controller.governance(), AppErrors.GOVERNANCE_ONLY);\r\n\r\n    // update internal debts and get actual amount to repay\r\n    IPoolAdapter pa = IPoolAdapter(poolAdapter_);\r\n    (,address user, address collateralAsset, address borrowAsset) = pa.getConfig();\r\n    pa.updateStatus();\r\n    (collateralAmountOut, repaidAmountOut,,,) = pa.getStatus();\r\n\r\n    require(\r\n      collateralAmountOut != 0 && repaidAmountOut != 0,\r\n      AppErrors.REPAY_FAILED\r\n    );\r\n\r\n    // ask the user for the amount-to-repay\r\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\r\n    ITetuConverterCallback(user).requirePayAmountBack(borrowAsset, repaidAmountOut);\r\n    uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\r\n\r\n    // ensure that we have received full required amount\r\n    if (closePosition) {\r\n      require(balanceAfter == balanceBefore + repaidAmountOut, AppErrors.WRONG_AMOUNT_RECEIVED);\r\n    } else {\r\n      require(\r\n        balanceAfter > balanceBefore && balanceAfter - balanceBefore <= repaidAmountOut,\r\n        AppErrors.ZERO_BALANCE\r\n      );\r\n      repaidAmountOut = balanceAfter - balanceBefore;\r\n    }\r\n\r\n    // make full repay and close the position\r\n    // repay is able to return small amount of borrow-asset back to the user, we should pass it to onTransferAmounts\r\n    balanceBefore = IERC20(borrowAsset).balanceOf(user);\r\n    // replaced by infinity approve: IERC20(borrowAsset).safeApprove(address(pa), repaidAmountOut);\r\n    collateralAmountOut = pa.repay(repaidAmountOut, user, closePosition);\r\n    emit OnRepayTheBorrow(poolAdapter_, collateralAmountOut, repaidAmountOut);\r\n    balanceAfter = IERC20(borrowAsset).balanceOf(user);\r\n\r\n    if (collateralAmountOut != 0) {\r\n      address[] memory assets = new address[](2);\r\n      assets[0] = borrowAsset;\r\n      assets[1] = collateralAsset;\r\n      uint[] memory amounts = new uint[](2);\r\n      amounts[0] = balanceAfter > balanceBefore\r\n        ? balanceAfter - balanceBefore\r\n        : 0; // for simplicity, we send zero amount to user too.. the user will just ignore it\r\n      amounts[1] = collateralAmountOut;\r\n      ITetuConverterCallback(user).onTransferAmounts(assets, amounts);\r\n    }\r\n\r\n    return (collateralAmountOut, repaidAmountOut);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Get debt/repay info\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Update status in all opened positions\r\n  ///         After this call getDebtAmount will be able to return exact amount to repay\r\n  /// @param user_ user whose debts will be returned\r\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\r\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\r\n  function getDebtAmountCurrent(\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_\r\n  ) external override nonReentrant returns (\r\n    uint totalDebtAmountOut,\r\n    uint totalCollateralAmountOut\r\n  ) {\r\n    address[] memory poolAdapters = debtMonitor.getPositions(\r\n      user_,\r\n      collateralAsset_,\r\n      borrowAsset_\r\n    );\r\n    uint lenPoolAdapters = poolAdapters.length;\r\n\r\n    for (uint i = 0; i < lenPoolAdapters; i = i.uncheckedInc()) {\r\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\r\n      pa.updateStatus();\r\n      (uint collateralAmount, uint totalDebtForPoolAdapter,,,) = pa.getStatus();\r\n      totalDebtAmountOut += totalDebtForPoolAdapter;\r\n      totalCollateralAmountOut += collateralAmount;\r\n    }\r\n\r\n    return (totalDebtAmountOut, totalCollateralAmountOut);\r\n  }\r\n\r\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\r\n  /// @dev Actual debt amount can be a little LESS then the amount returned by this function.\r\n  ///      I.e. AAVE's pool adapter returns (amount of debt + tiny addon ~ 1 cent)\r\n  ///      The addon is required to workaround dust-tokens problem.\r\n  ///      After repaying the remaining amount is transferred back on the balance of the caller strategy.\r\n  /// @param user_ user whose debts will be returned\r\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\r\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\r\n  function getDebtAmountStored(\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_\r\n  ) external view override returns (\r\n    uint totalDebtAmountOut,\r\n    uint totalCollateralAmountOut\r\n  ) {\r\n    address[] memory poolAdapters = debtMonitor.getPositions(\r\n      user_,\r\n      collateralAsset_,\r\n      borrowAsset_\r\n    );\r\n    uint lenPoolAdapters = poolAdapters.length;\r\n\r\n    for (uint i = 0; i < lenPoolAdapters; i = i.uncheckedInc()) {\r\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\r\n      (uint collateralAmount, uint totalDebtForPoolAdapter,,,) = pa.getStatus();\r\n      totalDebtAmountOut += totalDebtForPoolAdapter;\r\n      totalCollateralAmountOut += collateralAmount;\r\n    }\r\n\r\n    return (totalDebtAmountOut, totalCollateralAmountOut);\r\n  }\r\n\r\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\r\n  /// @param collateralAmountToRedeem_ Amount of collateral required by the user\r\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\r\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\r\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\r\n  ///                                           even if all borrowed amount will be returned.\r\n  ///                                           If this amount is not 0, you ask to get too much collateral.\r\n  function estimateRepay(\r\n    address user_,\r\n    address collateralAsset_,\r\n    uint collateralAmountToRedeem_,\r\n    address borrowAsset_\r\n  ) external view override returns (\r\n    uint borrowAssetAmount,\r\n    uint unobtainableCollateralAssetAmount\r\n  ) {\r\n    address[] memory poolAdapters = debtMonitor.getPositions(\r\n      user_,\r\n      collateralAsset_,\r\n      borrowAsset_\r\n    );\r\n    uint lenPoolAdapters = poolAdapters.length;\r\n\r\n    uint collateralAmountRemained = collateralAmountToRedeem_;\r\n    for (uint i = 0; i < lenPoolAdapters; i = i.uncheckedInc()) {\r\n      if (collateralAmountRemained == 0) {\r\n        break;\r\n      }\r\n\r\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\r\n      (uint collateralAmount, uint borrowedAmount,,,) = pa.getStatus();\r\n\r\n      if (collateralAmountRemained >= collateralAmount) {\r\n        collateralAmountRemained -= collateralAmount;\r\n        borrowAssetAmount += borrowedAmount;\r\n      } else {\r\n        borrowAssetAmount += borrowedAmount * collateralAmountRemained / collateralAmount;\r\n        collateralAmountRemained = 0;\r\n      }\r\n    }\r\n\r\n    return (borrowAssetAmount, collateralAmountRemained);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Check and claim rewards\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Transfer all reward tokens to {receiver_}\r\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\r\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\r\n  function claimRewards(address receiver_) external override nonReentrant returns (\r\n    address[] memory rewardTokensOut,\r\n    uint[] memory amountsOut\r\n  ) {\r\n    // The sender is able to claim his own rewards only, so no need to check sender\r\n    address[] memory poolAdapters = debtMonitor.getPositionsForUser(msg.sender);\r\n\r\n    uint lenPoolAdapters = poolAdapters.length;\r\n    address[] memory rewardTokens = new address[](lenPoolAdapters);\r\n    uint[] memory amounts = new uint[](lenPoolAdapters);\r\n    uint countPositions = 0;\r\n    for (uint i = 0; i < lenPoolAdapters; i = i.uncheckedInc()) {\r\n      IPoolAdapter pa = IPoolAdapter(poolAdapters[i]);\r\n      (rewardTokens[countPositions], amounts[countPositions]) = pa.claimRewards(receiver_);\r\n      if (amounts[countPositions] != 0) {\r\n        emit OnClaimRewards(address(pa), rewardTokens[countPositions], amounts[countPositions], receiver_);\r\n        ++countPositions;\r\n      }\r\n    }\r\n\r\n    if (countPositions != 0) {\r\n      rewardTokensOut = AppUtils.removeLastItems(rewardTokens, countPositions);\r\n      amountsOut = AppUtils.removeLastItems(amounts, countPositions);\r\n    }\r\n\r\n    return (rewardTokensOut, amountsOut);\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Simulate swap\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Transfer {sourceAmount_} approved by {sourceAmountApprover_} to swap manager\r\n  function onRequireAmountBySwapManager(\r\n    address sourceAmountApprover_,\r\n    address sourceToken_,\r\n    uint sourceAmount_\r\n  ) external override {\r\n    require(address(swapManager) == msg.sender, AppErrors.ONLY_SWAP_MANAGER);\r\n\r\n    if (sourceAmountApprover_ == address(this)) {\r\n      IERC20(sourceToken_).safeTransfer(address(swapManager), sourceAmount_);\r\n    } else {\r\n      IERC20(sourceToken_).safeTransferFrom(sourceAmountApprover_, address(swapManager), sourceAmount_);\r\n    }\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Liquidate with checking\r\n  ///////////////////////////////////////////////////////\r\n\r\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\r\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\r\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\r\n  ///                      It should be transferred on balance of the TetuConverter before the function call\r\n  /// @param receiver_ Result amount will be sent to this address\r\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\r\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\r\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\r\n  function safeLiquidate(\r\n    address assetIn_,\r\n    uint amountIn_,\r\n    address assetOut_,\r\n    address receiver_,\r\n    uint priceImpactToleranceSource_,\r\n    uint priceImpactToleranceTarget_\r\n  ) override external returns (\r\n    uint amountOut\r\n  ) { // there are no restrictions for the msg.sender, anybody can make liquidation\r\n    ITetuLiquidator tetuLiquidator = ITetuLiquidator(controller.tetuLiquidator());\r\n    uint targetTokenBalanceBefore = IERC20(assetOut_).balanceOf(address(this));\r\n\r\n    IERC20(assetIn_).safeApprove(address(tetuLiquidator), amountIn_);\r\n    tetuLiquidator.liquidate(assetIn_, assetOut_, amountIn_, priceImpactToleranceSource_);\r\n\r\n    amountOut = IERC20(assetOut_).balanceOf(address(this)) - targetTokenBalanceBefore;\r\n    IERC20(assetOut_).safeTransfer(receiver_, amountOut);\r\n    // The result amount shouldn't be too different from the value calculated directly using price oracle prices\r\n    require(\r\n      SwapLib.isConversionValid(\r\n        priceOracle,\r\n        assetIn_,\r\n        amountIn_,\r\n        assetOut_,\r\n        amountOut,\r\n        priceImpactToleranceTarget_\r\n      ),\r\n      AppErrors.TOO_HIGH_PRICE_IMPACT\r\n    );\r\n    emit OnSafeLiquidate(assetIn_, amountIn_, assetOut_, receiver_, amountOut);\r\n  }\r\n\r\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\r\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\r\n  function isConversionValid(\r\n    address assetIn_,\r\n    uint amountIn_,\r\n    address assetOut_,\r\n    uint amountOut_,\r\n    uint priceImpactTolerance_\r\n  ) external override view returns (bool) {\r\n    return SwapLib.isConversionValid(\r\n      priceOracle,\r\n      assetIn_,\r\n      amountIn_,\r\n      assetOut_,\r\n      amountOut_,\r\n      priceImpactTolerance_\r\n    );\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///       Next version features\r\n  ///////////////////////////////////////////////////////\r\n//  function requireAdditionalBorrow(\r\n//    uint amountToBorrow_,\r\n//    address poolAdapter_\r\n//  ) external override {\r\n//    onlyKeeper();\r\n//\r\n//    IPoolAdapter pa = IPoolAdapter(poolAdapter_);\r\n//\r\n//    (, address user, address collateralAsset, address borrowAsset) = pa.getConfig();\r\n//\r\n//    // make rebalancing\r\n//    (uint resultHealthFactor18, uint borrowedAmountOut) = pa.borrowToRebalance(amountToBorrow_, user);\r\n//    _ensureApproxSameToTargetHealthFactor(borrowAsset, resultHealthFactor18);\r\n//\r\n//    // notify the borrower about new available borrowed amount\r\n//    ITetuConverterCallback(user).onTransferBorrowedAmount(collateralAsset, borrowAsset, borrowedAmountOut);\r\n//  }\r\n//\r\n//  function requireReconversion(\r\n//    address poolAdapter_,\r\n//    uint periodInBlocks_\r\n//  ) external override {\r\n//    onlyKeeper();\r\n//\r\n//    //TODO: draft (not tested) implementation\r\n//\r\n//    IPoolAdapter pa = IPoolAdapter(poolAdapter_);\r\n//    (address originConverter, address user, address collateralAsset, address borrowAsset) = pa.getConfig();\r\n//    (,uint amountToPay,,) = pa.getStatus();\r\n//\r\n//    // require borrowed amount back\r\n//    uint balanceBorrowedAsset = IERC20(borrowAsset).balanceOf(address(this));\r\n//    ITetuConverterCallback(user).requireAmountBack(\r\n//      collateralAsset,\r\n//      borrowAsset,\r\n//      amountToPay,\r\n//      0 // TODO if we allow to pass 0 as collateral amount it means that borrow amount MUST be returned\r\n//    // TODO but currently it's not implemented\r\n//    );\r\n//    require(\r\n//      IERC20(borrowAsset).balanceOf(address(this)) - balanceBorrowedAsset == amountToPay,\r\n//      AppErrors.WRONG_AMOUNT_RECEIVED\r\n//    );\r\n//\r\n//    //make repay and close position\r\n//    uint balanceCollateralAsset = IERC20(collateralAsset).balanceOf(address(this));\r\n//    pa.syncBalance(false, false);\r\n//    IERC20(borrowAsset).safeTransfer(poolAdapter_, amountToPay);\r\n//    pa.repay(amountToPay, address(this), true);\r\n//    uint collateralAmount = IERC20(collateralAsset).balanceOf(address(this)) - balanceCollateralAsset;\r\n//\r\n//    // find new plan\r\n//    (address converter, uint maxTargetAmount,) = _findConversionStrategy(\r\n//      collateralAsset,\r\n//      collateralAmount,\r\n//      borrowAsset,\r\n//      periodInBlocks_,\r\n//      ITetuConverter.ConversionMode.AUTO_0\r\n//    );\r\n//    require(converter != originConverter, AppErrors.RECONVERSION_WITH_SAME_CONVERTER_FORBIDDEN);\r\n//    require(converter != address(0), AppErrors.CONVERTER_NOT_FOUND);\r\n//\r\n//    // make conversion using new pool adapter, transfer borrowed amount back to user\r\n//    uint newBorrowedAmount = _convert(\r\n//      converter,\r\n//      collateralAsset,\r\n//      collateralAmount,\r\n//      borrowAsset,\r\n//      maxTargetAmount,\r\n//      user\r\n//    );\r\n//    ITetuConverterCallback(user).onTransferBorrowedAmount(collateralAsset, borrowAsset, newBorrowedAmount);\r\n//  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/aave3/IAavePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/// @notice Restored from 0x69FA688f1Dc47d4B5d8029D5a35FB7a548310654 (events were removed)\r\ninterface IAavePriceOracle {\r\n  /**\r\n   * @notice Returns the PoolAddressesProvider\r\n   * @return The address of the PoolAddressesProvider contract\r\n   */\r\n  function ADDRESSES_PROVIDER() external view returns (address);\r\n  /**\r\n   * @notice Returns the base currency address\r\n   * @dev Address 0x0 is reserved for USD as base currency.\r\n   * @return Returns the base currency address.\r\n   **/\r\n  function BASE_CURRENCY() external view returns (address);\r\n  /**\r\n   * @notice Returns the base currency unit\r\n   * @dev 1 ether for ETH, 1e8 for USD.\r\n   * @return Returns the base currency unit.\r\n   **/\r\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\r\n  /**\r\n   * @notice Returns the asset price in the base currency\r\n   * @param asset The address of the asset\r\n   * @return The price of the asset\r\n   **/\r\n  function getAssetPrice(address asset) external view returns (uint256);\r\n  /**\r\n   * @notice Returns a list of prices from a list of assets addresses\r\n   * @param assets The list of assets addresses\r\n   * @return The prices of the given assets\r\n   */\r\n  function getAssetsPrices(address[] memory assets) external view returns (uint256[] memory);\r\n  /**\r\n   * @notice Returns the address of the fallback oracle\r\n   * @return The address of the fallback oracle\r\n   */\r\n  function getFallbackOracle() external view returns (address);\r\n  /**\r\n   * @notice Returns the address of the source for an asset address\r\n   * @param asset The address of the asset\r\n   * @return The address of the source\r\n   */\r\n  function getSourceOfAsset(address asset) external view returns (address);\r\n  function setAssetSources(address[] memory assets, address[] memory sources) external;\r\n  function setFallbackOracle(address fallbackOracle) external;\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/gelato/IResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\ninterface IResolver {\r\n    function checker()\r\n        external\r\n        view\r\n        returns (bool canExec, bytes memory execPayload);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/gelato/OpsReady.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\nimport \"../../openzeppelin/SafeERC20.sol\";\r\ninterface IOps {\r\n    function gelato() external view returns (address payable);\r\n    function taskTreasury() external view returns (address);\r\n}\r\n\r\nabstract contract OpsReady {\r\n    address public immutable ops;\r\n    address payable public immutable gelato;\r\n    address public constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    modifier onlyOps() {\r\n        require(msg.sender == ops, \"OpsReady: onlyOps\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _ops) {\r\n        ops = _ops;\r\n        gelato = IOps(_ops).gelato();\r\n    }\r\n\r\n    function _transfer(uint256 _amount, address _paymentToken) internal {\r\n        if (_paymentToken == ETH) {\r\n            (bool success, ) = gelato.call{value: _amount}(\"\");\r\n            require(success, \"_transfer: ETH transfer failed\");\r\n        } else {\r\n            SafeERC20.safeTransfer(IERC20(_paymentToken), gelato, _amount);\r\n        }\r\n    }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/market/ICErc20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity 0.8.17;\r\n\r\ninterface ICErc20 {\r\n  function _acceptAdmin (  ) external returns ( uint );\r\n  function _addReserves ( uint addAmount ) external returns ( uint );\r\n  function _reduceReserves ( uint reduceAmount ) external returns ( uint );\r\n  function _setComptroller ( address newComptroller ) external returns ( uint );\r\n  function _setInterestRateModel ( address newInterestRateModel ) external returns ( uint );\r\n  function _setPendingAdmin ( address newPendingAdmin ) external returns ( uint );\r\n  function _setReserveFactor ( uint newReserveFactorMantissa ) external returns ( uint );\r\n  function accrualBlockNumber (  ) external view returns ( uint );\r\n  function accrueInterest (  ) external returns ( uint );\r\n  function admin (  ) external view returns ( address );\r\n  function allowance ( address owner, address spender ) external view returns ( uint );\r\n  function approve ( address spender, uint amount ) external returns ( bool );\r\n  function balanceOf ( address owner ) external view returns ( uint );\r\n  function balanceOfUnderlying ( address owner ) external returns ( uint );\r\n  function borrow ( uint borrowAmount ) external returns ( uint );\r\n  function borrowBalanceCurrent ( address account ) external returns ( uint );\r\n  function borrowBalanceStored ( address account ) external view returns ( uint );\r\n  function borrowIndex (  ) external view returns ( uint );\r\n  function borrowRatePerBlock (  ) external view returns ( uint );\r\n  function comptroller (  ) external view returns ( address );\r\n  function decimals (  ) external view returns ( uint8 );\r\n  function exchangeRateCurrent (  ) external returns ( uint );\r\n  function exchangeRateStored (  ) external view returns ( uint );\r\n  function getAccountSnapshot ( address account ) external view returns ( uint, uint, uint, uint );\r\n  function getCash (  ) external view returns ( uint );\r\n  function interestRateModel (  ) external view returns ( address );\r\n  function isCToken (  ) external view returns ( bool );\r\n  function liquidateBorrow ( address borrower, uint repayAmount, address cTokenCollateral ) external returns ( uint );\r\n  function mint ( uint mintAmount ) external returns ( uint );\r\n  function name (  ) external view returns ( string memory);\r\n  function pendingAdmin (  ) external view returns ( address );\r\n  function redeem ( uint redeemTokens ) external returns ( uint );\r\n  function redeemUnderlying ( uint redeemAmount ) external returns ( uint );\r\n  function repayBorrow ( uint repayAmount ) external returns ( uint );\r\n  function repayBorrowBehalf ( address borrower, uint repayAmount ) external returns ( uint );\r\n  function reserveFactorMantissa (  ) external view returns ( uint );\r\n  function seize ( address liquidator, address borrower, uint seizeTokens ) external returns ( uint );\r\n  function supplyRatePerBlock (  ) external view returns ( uint );\r\n  function sweepToken ( address token ) external;\r\n  function symbol (  ) external view returns ( string memory);\r\n  function totalBorrows (  ) external view returns ( uint );\r\n  function totalBorrowsCurrent (  ) external returns ( uint );\r\n  function totalReserves (  ) external view returns ( uint );\r\n  function totalSupply (  ) external view returns ( uint );\r\n  function transfer ( address dst, uint amount ) external returns ( bool );\r\n  function transferFrom ( address src, address dst, uint amount ) external returns ( bool );\r\n  function underlying (  ) external view returns ( address );\r\n\r\n  function adminFeeMantissa() external view returns (uint256);\r\n  function fuseFeeMantissa() external view returns (uint256);\r\n  function totalAdminFees() external view returns (uint256);\r\n  function totalFuseFees() external view returns (uint256);\r\n\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/integrations/tetu/ITetuLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface ITetuLiquidator {\r\n\r\n  struct PoolData {\r\n    address pool;\r\n    address swapper;\r\n    address tokenIn;\r\n    address tokenOut;\r\n  }\r\n\r\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\r\n\r\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\r\n\r\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\r\n\r\n  function buildRoute(\r\n    address tokenIn,\r\n    address tokenOut\r\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\r\n\r\n  function liquidate(\r\n    address tokenIn,\r\n    address tokenOut,\r\n    uint amount,\r\n    uint priceImpactTolerance\r\n  ) external;\r\n\r\n  function liquidateWithRoute(\r\n    PoolData[] memory route,\r\n    uint amount,\r\n    uint priceImpactTolerance\r\n  ) external;\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IBorrowManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppDataTypes.sol\";\r\n\r\n/// @notice Manage list of available lending platforms\r\n///         Manager of pool-adapters.\r\n///         Pool adapter is an instance of a converter provided by the lending platform\r\n///         linked to one of platform's pools, address of user contract, collateral and borrow tokens.\r\n///         The pool adapter is real borrower of funds for AAVE, Compound and other lending protocols.\r\n///         Pool adapters are created using minimal-proxy pattern, see\r\n///         https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\r\ninterface IBorrowManager {\r\n\r\n  /// @notice Register a pool adapter for (pool, user, collateral) if the adapter wasn't created before\r\n  /// @param user_ Address of the caller contract who requires access to the pool adapter\r\n  /// @return Address of registered pool adapter\r\n  function registerPoolAdapter(\r\n    address converter_,\r\n    address user_,\r\n    address collateral_,\r\n    address borrowToken_\r\n  ) external returns (address);\r\n\r\n  /// @notice Get pool adapter or 0 if the pool adapter is not registered\r\n  function getPoolAdapter(\r\n    address converter_,\r\n    address user_,\r\n    address collateral_,\r\n    address borrowToken_\r\n  ) external view returns (address);\r\n\r\n  /// @dev Returns true for NORMAL pool adapters and for active DIRTY pool adapters (=== borrow position is opened).\r\n  function isPoolAdapter(address poolAdapter_) external view returns (bool);\r\n\r\n  /// @notice Notify borrow manager that the pool adapter with the given params is \"dirty\".\r\n  ///         The pool adapter should be excluded from the list of ready-to-borrow pool adapters.\r\n  /// @dev \"Dirty\" means that a liquidation happens inside. The borrow position should be closed during health checking.\r\n  function markPoolAdapterAsDirty (\r\n    address converter_,\r\n    address user_,\r\n    address collateral_,\r\n    address borrowToken_\r\n  ) external;\r\n\r\n  /// @notice Register new lending platform with available pairs of assets\r\n  ///         OR add new pairs of assets to the exist lending platform\r\n  /// @param platformAdapter_ Implementation of IPlatformAdapter attached to the specified pool\r\n  /// @param leftAssets_  Supported pairs of assets. The pairs are set using two arrays: left and right\r\n  /// @param rightAssets_  Supported pairs of assets. The pairs are set using two arrays: left and right\r\n  function addAssetPairs(\r\n    address platformAdapter_,\r\n    address[] calldata leftAssets_,\r\n    address[] calldata rightAssets_\r\n  ) external;\r\n\r\n  /// @notice Remove available pairs of asset from the platform adapter.\r\n  ///         The platform adapter will be unregistered after removing last supported pair of assets\r\n  function removeAssetPairs(\r\n    address platformAdapter_,\r\n    address[] calldata leftAssets_,\r\n    address[] calldata rightAssets_\r\n  ) external;\r\n\r\n  /// @notice Set target health factors for the assets.\r\n  ///         If target health factor is not assigned to the asset, target-health-factor from controller is used.\r\n  ///         See explanation of health factor value in IConverterController\r\n  /// @param healthFactors2_ Health factor must be greater or equal then 1, decimals 2\r\n  function setTargetHealthFactors(address[] calldata assets_, uint16[] calldata healthFactors2_) external;\r\n\r\n  /// @notice Return target health factor with decimals 2 for the asset\r\n  ///         If there is no custom value for asset, target health factor from the controller should be used\r\n  function getTargetHealthFactor2(address asset) external view returns (uint16);\r\n\r\n  /// @notice Reward APR is taken into account with given factor\r\n  ///         Result APR = borrow-apr - supply-apr - [REWARD-FACTOR]/Denominator * rewards-APR\r\n  function setRewardsFactor(uint rewardsFactor_) external;\r\n\r\n  /// @notice Find lending pool capable of providing {targetAmount} and having best normalized borrow rate\r\n  ///         Results are ordered in ascending order of APR, so the best available converter is first one.\r\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\r\n  ///                  See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\r\n  /// @param amountIn_ The meaning depends on entryData kind, see EntryKinds library for details.\r\n  ///         For entry kind = 0: Amount of {sourceToken} to be converted to {targetToken}\r\n  ///         For entry kind = 1: Available amount of {sourceToken}\r\n  ///         For entry kind = 2: Amount of {targetToken} that should be received after conversion\r\n  /// @return converters Result template-pool-adapters\r\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\r\n  /// @return amountsToBorrowOut Amounts that should be borrowed\r\n  /// @return aprs18 Annual Percentage Rates == (total cost - total income) / amount of collateral, decimals 18\r\n  function findConverter(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    address targetToken_,\r\n    uint amountIn_,\r\n    uint periodInBlocks_\r\n  ) external view returns (\r\n    address[] memory converters,\r\n    uint[] memory collateralAmountsOut,\r\n    uint[] memory amountsToBorrowOut,\r\n    int[] memory aprs18\r\n  );\r\n\r\n  /// @notice Get platformAdapter to which the converter belongs\r\n  function getPlatformAdapter(address converter_) external view returns (address);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppDataTypes.sol\";\r\n\r\ninterface IConverter {\r\n  function getConversionKind() external pure returns (\r\n    AppDataTypes.ConversionKind\r\n  );\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\n/// @notice Keep and provide addresses of all application contracts\r\ninterface IConverterController {\r\n  function governance() external view returns (address);\r\n\r\n  /// ********************* Health factor explanation  ****************\r\n  /// For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\r\n  /// For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\r\n  /// We set min-health-factor = 1.1, target-health-factor = 1.3\r\n  /// For collateral 100 we will borrow 100/1.3 = 76.92\r\n  ///\r\n  /// Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\r\n  /// Collateral * LT    85         65.45\r\n  /// Borrow value       65.38      65.38         but borrow value is the same as before\r\n  /// Health factor      1.3        1.001         liquidation almost happens here (!)\r\n  ///\r\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\r\n  /// and the borrow value won't change at the same time, the liquidation happens at that point.\r\n  /// Min health factor marks the point at which a rebalancing must be made asap.\r\n  /// *****************************************************************\r\n\r\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\r\n  function minHealthFactor2() external view returns (uint16);\r\n  function setMinHealthFactor2(uint16 value_) external;\r\n\r\n  /// @notice target health factor with decimals 2\r\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\r\n  ///      or additional borrow and restore the health factor to the given target value\r\n  function targetHealthFactor2() external view returns (uint16);\r\n  function setTargetHealthFactor2(uint16 value_) external;\r\n\r\n  /// @notice max allowed health factor with decimals 2\r\n  /// @dev For future versions, currently max health factor is not used\r\n  function maxHealthFactor2() external view returns (uint16);\r\n  /// @dev For future versions, currently max health factor is not used\r\n  function setMaxHealthFactor2(uint16 value_) external;\r\n\r\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\r\n  function blocksPerDay() external view returns (uint);\r\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\r\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\r\n  /// @notice Check if it's time to call updateBlocksPerDay()\r\n  /// @param periodInSeconds_ Period of auto-update in seconds\r\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\r\n  /// @notice Recalculate blocksPerDay value\r\n  /// @param periodInSeconds_ Period of auto-update in seconds\r\n  function updateBlocksPerDay(uint periodInSeconds_) external;\r\n\r\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\r\n  function paused() external view returns (bool);\r\n\r\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\r\n  function isWhitelisted(address user_) external view returns (bool);\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///        Core application contracts\r\n  ///////////////////////////////////////////////////////\r\n\r\n  function tetuConverter() external view returns (address);\r\n  function borrowManager() external view returns (address);\r\n  function debtMonitor() external view returns (address);\r\n  function tetuLiquidator() external view returns (address);\r\n  function swapManager() external view returns (address);\r\n  function priceOracle() external view returns (address);\r\n\r\n  ///////////////////////////////////////////////////////\r\n  ///        External contracts\r\n  ///////////////////////////////////////////////////////\r\n  /// @notice A keeper to control health and efficiency of the borrows\r\n  function keeper() external view returns (address);\r\n\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IDebtMonitor.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\n/// @notice Collects list of registered borrow-positions. Allow to check state of the collaterals.\r\ninterface IDebtMonitor {\r\n\r\n  /// @notice Enumerate {maxCountToCheck} pool adapters starting from {index0} and return unhealthy pool-adapters\r\n  ///         i.e. adapters with health factor below min allowed value\r\n  ///         It calculates two amounts: amount of borrow asset and amount of collateral asset\r\n  ///         To fix the health factor it's necessary to send EITHER one amount OR another one.\r\n  ///         There is special case: a liquidation happens inside the pool adapter.\r\n  ///         It means, that this is \"dirty\" pool adapter and this position must be closed and never used again.\r\n  ///         In this case, both amounts are zero (we need to make FULL repay)\r\n  /// @return nextIndexToCheck0 Index of next pool-adapter to check; 0: all pool-adapters were checked\r\n  /// @return outPoolAdapters List of pool adapters that should be reconverted\r\n  /// @return outAmountBorrowAsset What borrow-asset amount should be send to pool adapter to fix health factor\r\n  /// @return outAmountCollateralAsset What collateral-asset amount should be send to pool adapter to fix health factor\r\n  function checkHealth(\r\n    uint startIndex0,\r\n    uint maxCountToCheck,\r\n    uint maxCountToReturn\r\n  ) external view returns (\r\n    uint nextIndexToCheck0,\r\n    address[] memory outPoolAdapters,\r\n    uint[] memory outAmountBorrowAsset,\r\n    uint[] memory outAmountCollateralAsset\r\n  );\r\n\r\n  /// @notice Register new borrow position if it's not yet registered\r\n  /// @dev This function is called from a pool adapter after any borrow\r\n  function onOpenPosition() external;\r\n\r\n  /// @notice Unregister the borrow position if it's completely repaid\r\n  /// @dev This function is called from a pool adapter when the borrow is completely repaid\r\n  function onClosePosition() external;\r\n\r\n  /// @notice Check if the pool-adapter-caller has an opened position\r\n  function isPositionOpened() external view returns (bool);\r\n\r\n  /// @notice Pool adapter has opened borrow, but full liquidation happens and we've lost all collateral\r\n  ///         Close position without paying the debt and never use the pool adapter again.\r\n  function closeLiquidatedPosition(address poolAdapter_) external;\r\n\r\n  /// @notice Get total count of pool adapters with opened positions\r\n  function getCountPositions() external view returns (uint);\r\n\r\n  /// @notice Get active borrows of the user with given collateral/borrowToken\r\n  /// @return poolAdaptersOut The instances of IPoolAdapter\r\n  function getPositions (\r\n    address user_,\r\n    address collateralToken_,\r\n    address borrowedToken_\r\n  ) external view returns (\r\n    address[] memory poolAdaptersOut\r\n  );\r\n\r\n  /// @notice Get active borrows of the given user\r\n  /// @return poolAdaptersOut The instances of IPoolAdapter\r\n  function getPositionsForUser(address user_) external view returns(\r\n    address[] memory poolAdaptersOut\r\n  );\r\n\r\n  /// @notice Return true if there is a least once active pool adapter created on the base of the {converter_}\r\n  function isConverterInUse(address converter_) external view returns (bool);\r\n\r\n// TODO for next versions of the application\r\n//  /// @notice Enumerate {maxCountToCheck} pool adapters starting from {index0} and return all pool-adapters\r\n//  ///         with health factor exceeds max allowed value. In other words, it's safe to make additional borrow.\r\n//  /// @return nextIndexToCheck0 Index of next pool-adapter to check; 0: all pool-adapters were checked\r\n//  /// @return outPoolAdapters List of pool adapters that should be reconverted\r\n//  /// @return outAmountsToBorrow What amount can be additionally borrowed using exist collateral\r\n//  function checkAdditionalBorrow(\r\n//    uint startIndex0,\r\n//    uint maxCountToCheck,\r\n//    uint maxCountToReturn\r\n//  ) external view returns (\r\n//    uint nextIndexToCheck0,\r\n//    address[] memory outPoolAdapters,\r\n//    uint[] memory outAmountsToBorrow\r\n//  );\r\n\r\n// TODO for next versions of the application\r\n//  /// @notice Enumerate {maxCountToCheck} pool adapters starting from {index0} and return not-optimal pool-adapters\r\n//  /// @param periodInBlocks Period in blocks that should be used in rebalancing\r\n//  /// @return nextIndexToCheck0 Index of next pool-adapter to check; 0: all pool-adapters were checked\r\n//  /// @return poolAdapters List of pool adapters that should be reconverted\r\n//  function checkBetterBorrowExists(\r\n//    uint startIndex0,\r\n//    uint maxCountToCheck,\r\n//    uint maxCountToReturn,\r\n//    uint periodInBlocks\r\n//  ) external view returns (\r\n//    uint nextIndexToCheck0,\r\n//    address[] memory poolAdapters\r\n//  );\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IHealthKeeperCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IHealthKeeperCallback {\r\n  function nextIndexToCheck0() external view returns (uint);\r\n\r\n  function fixHealth(\r\n    uint nextIndexToCheck0_,\r\n    address[] calldata outPoolAdapters_,\r\n    uint[] calldata outAmountBorrowAsset_,\r\n    uint[] calldata outAmountCollateralAsset_\r\n  ) external;\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IKeeperCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/// @notice Keeper sends notifications to TetuConverter using following interface\r\ninterface IKeeperCallback {\r\n\r\n  /// @notice This function is called by a keeper if there is unhealthy borrow\r\n  ///         The called contract should send either collateral-amount or borrowed-amount to TetuConverter\r\n  /// @param requiredAmountBorrowAsset_ The borrower should return given borrowed amount back to TetuConverter\r\n  ///                                   in order to restore health factor to target value\r\n  /// @param requiredAmountCollateralAsset_ The borrower should send given amount of collateral to TetuConverter\r\n  ///                                       in order to restore health factor to target value\r\n  /// @param lendingPoolAdapter_ Address of the pool adapter that has problem health factor\r\n  function requireRepay(\r\n    uint requiredAmountBorrowAsset_,\r\n    uint requiredAmountCollateralAsset_,\r\n    address lendingPoolAdapter_\r\n  ) external;\r\n\r\n  // TODO for next versions of the application\r\n//  /// @notice This function is called by a keeper if the health factor of the borrow is too big,\r\n//  ///         and so it's possible to borrow additional amount using the exist collateral amount.\r\n//  ///         The borrowed amount is sent to the balance of the pool-adapter's user.\r\n//  /// @param amountToBorrow_ It's safe to borrow given amount. As result health factor will reduce to target value.\r\n//  /// @param lendingPoolAdapter_ Address of the pool adapter that has too big health factor\r\n//  function requireAdditionalBorrow(\r\n//    uint amountToBorrow_,\r\n//    address lendingPoolAdapter_\r\n//  ) external;\r\n//\r\n//  /// @notice This function is called by a keeper if the keeper has found MUCH better way of borrow than current one\r\n//  /// @param lendingPoolAdapter_ Position to be closed\r\n//  /// @param periodInBlocks_ Estimated period for new borrow, in blocks\r\n//  function requireReconversion(\r\n//    address lendingPoolAdapter_,\r\n//    uint periodInBlocks_\r\n//  ) external;\r\n\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IPlatformAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppDataTypes.sol\";\r\n\r\n/// @notice Adapter for lending platform attached to the given platform's pool.\r\ninterface IPlatformAdapter {\r\n  /// @notice Current version of contract\r\n  ///         There is a chance that we will register several versions of the same platform\r\n  ///         at the same time (only last version will be active, others will be frozen)\r\n  function PLATFORM_ADAPTER_VERSION() external view returns (string memory);\r\n\r\n  /// @notice Get pool data required to select best lending pool\r\n  /// @param healthFactor2_ Health factor (decimals 2) to be able to calculate max borrow amount\r\n  ///                       See IConverterController for explanation of health factors.\r\n  function getConversionPlan(\r\n    AppDataTypes.InputConversionParams memory params_,\r\n    uint16 healthFactor2_\r\n  ) external view returns (\r\n    AppDataTypes.ConversionPlan memory plan\r\n  );\r\n\r\n  /// @notice Full list of supported converters\r\n  function converters() external view returns (address[] memory);\r\n\r\n  /// @notice Initialize {poolAdapter_} created from {converter_} using minimal proxy pattern\r\n  function initializePoolAdapter(\r\n    address converter_,\r\n    address poolAdapter_,\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_\r\n  ) external;\r\n\r\n  /// @notice Estimate value of variable borrow rate after borrowing {amountToBorrow_}\r\n  function getBorrowRateAfterBorrow(address borrowAsset_, uint amountToBorrow_) external view returns (uint);\r\n\r\n  /// @notice True if the platform is frozen and new borrowing is not possible (at this moment)\r\n  function frozen() external view returns (bool);\r\n\r\n  /// @notice Set platform to frozen/unfrozen state. In frozen state any new borrowing is forbidden.\r\n  function setFrozen(bool frozen_) external;\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IPoolAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"./IConverter.sol\";\r\n\r\n/// @notice Allow to borrow given asset from the given pool using given asset as collateral.\r\n///         There is Template-Pool-Adapter contract for each platform (AAVE, HF, etc).\r\n/// @dev Terms: \"pool adapter\" is an instance of \"converter\" created using minimal-proxy-pattern\r\ninterface IPoolAdapter is IConverter {\r\n  /// @notice Update all interests, recalculate borrowed amount;\r\n  ///         After this call, getStatus will return exact amount-to-repay\r\n  function updateStatus() external;\r\n\r\n  /// @notice Supply collateral to the pool and borrow specified amount\r\n  /// @dev No re-balancing here; Collateral amount must be approved to the pool adapter before the call of this function\r\n  /// @param collateralAmount_ Amount of collateral, must be approved to the pool adapter before the call of borrow()\r\n  /// @param borrowAmount_ Amount that should be borrowed in result\r\n  /// @param receiver_ Receiver of the borrowed amount\r\n  /// @return borrowedAmountOut Result borrowed amount sent to the {receiver_}\r\n  function borrow(uint collateralAmount_, uint borrowAmount_, address receiver_) external returns (\r\n    uint borrowedAmountOut\r\n  );\r\n\r\n  /// @notice Borrow additional amount {borrowAmount_} using exist collateral and send it to {receiver_}\r\n  /// @dev Re-balance: too big health factor => target health factor\r\n  /// @return resultHealthFactor18 Result health factor after borrow\r\n  /// @return borrowedAmountOut Exact amount sent to the borrower\r\n  function borrowToRebalance(uint borrowAmount_, address receiver_) external returns (\r\n    uint resultHealthFactor18,\r\n    uint borrowedAmountOut\r\n  );\r\n\r\n  /// @notice Repay borrowed amount, return collateral to the user\r\n  /// @param amountToRepay_ Exact amount of borrow asset that should be repaid\r\n  ///                       The amount should be approved for the pool adapter before the call of repay()\r\n  /// @param closePosition_ true to pay full borrowed amount\r\n  /// @param receiver_ Receiver of withdrawn collateral\r\n  /// @return collateralAmountOut Amount of collateral asset sent to the {receiver_}\r\n  function repay(uint amountToRepay_, address receiver_, bool closePosition_) external returns (\r\n    uint collateralAmountOut\r\n  );\r\n\r\n  /// @notice Repay with rebalancing. Send amount of collateral/borrow asset to the pool adapter\r\n  ///         to recover the health factor to target state.\r\n  /// @dev It's not allowed to close position here (pay full debt) because no collateral will be returned.\r\n  /// @param amount_ Exact amount of asset that is transferred to the balance of the pool adapter.\r\n  ///                It can be amount of collateral asset or borrow asset depended on {isCollateral_}\r\n  ///                It must be stronger less then total borrow debt.\r\n  ///                The amount should be approved for the pool adapter before the call.\r\n  /// @param isCollateral_ true/false indicates that {amount_} is the amount of collateral/borrow asset\r\n  /// @return resultHealthFactor18 Result health factor after repay, decimals 18\r\n  function repayToRebalance(uint amount_, bool isCollateral_) external returns (\r\n    uint resultHealthFactor18\r\n  );\r\n\r\n  /// @return originConverter Address of original PoolAdapter contract that was cloned to make the instance of the pool adapter\r\n  function getConfig() external view returns (\r\n    address originConverter,\r\n    address user,\r\n    address collateralAsset,\r\n    address borrowAsset\r\n  );\r\n\r\n  /// @notice Get current status of the borrow position\r\n  /// @dev It returns STORED status. To get current status it's necessary to call updateStatus\r\n  ///      at first to update interest and recalculate status.\r\n  /// @return collateralAmount Total amount of provided collateral, collateral currency\r\n  /// @return amountToPay Total amount of borrowed debt in [borrow asset]. 0 - for closed borrow positions.\r\n  /// @return healthFactor18 Current health factor, decimals 18\r\n  /// @return opened The position is opened (there is not empty collateral/borrow balance)\r\n  /// @return collateralAmountLiquidated How much collateral was liquidated\r\n  function getStatus() external view returns (\r\n    uint collateralAmount,\r\n    uint amountToPay,\r\n    uint healthFactor18,\r\n    bool opened,\r\n    uint collateralAmountLiquidated\r\n  );\r\n\r\n  /// @notice Check if any reward tokens exist on the balance of the pool adapter, transfer reward tokens to {receiver_}\r\n  /// @return rewardToken Address of the transferred reward token\r\n  /// @return amount Amount of the transferred reward token\r\n  function claimRewards(address receiver_) external returns (address rewardToken, uint amount);\r\n\r\n  /// @notice If we paid {amountToRepay_}, how much collateral would we receive?\r\n  function getCollateralAmountToReturn(uint amountToRepay_, bool closePosition_) external view returns (uint);\r\n\r\n//  /// @notice Compute current APR value, decimals 18\r\n//  /// @return Interest * 1e18, i.e. 2.25e18 means APR=2.25%\r\n//  function getAPR18() external view returns (int);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\ninterface IPriceOracle {\r\n  /// @notice Return asset price in USD, decimals 18\r\n  function getAssetPrice(address asset) external view returns (uint256);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/IRequireAmountBySwapManagerCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/// @notice TetuConverter supports this interface\r\n///         It's called by SwapManager inside static-call swap simulation\r\n///         to transfer amount approved to TetuConverter by user to SwapManager\r\n///         before calling swap simulation\r\ninterface IRequireAmountBySwapManagerCallback {\r\n  /// @notice Transfer {sourceAmount_} approved by {sourceAmountApprover_} to swap manager\r\n  function onRequireAmountBySwapManager(\r\n    address sourceAmountApprover_,\r\n    address sourceToken_,\r\n    uint sourceAmount_\r\n  ) external;\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ISimulateProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/// @notice Provider of simulate() function\r\ninterface ISimulateProvider {\r\n  function simulate(\r\n    address targetContract,\r\n    bytes calldata calldataPayload\r\n  ) external returns (bytes memory response);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ISwapConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppDataTypes.sol\";\r\nimport \"./IConverter.sol\";\r\n\r\ninterface ISwapConverter is IConverter {\r\n  function getConversionKind()\r\n  override external pure returns (AppDataTypes.ConversionKind);\r\n\r\n  /// @notice Swap {sourceAmount_} of {sourceToken_} to {targetToken_} and send result amount to {receiver_}\r\n  /// @return outputAmount The amount that has been sent to the receiver\r\n  function swap(\r\n    address sourceToken_,\r\n    uint sourceAmount_,\r\n    address targetToken_,\r\n    address receiver_\r\n  ) external returns (uint outputAmount);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ISwapManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"../libs/AppDataTypes.sol\";\r\n\r\ninterface ISwapManager {\r\n\r\n  /// @notice Find a way to convert collateral asset to borrow asset in most efficient way\r\n  /// @dev This is a writable function with read-only behavior\r\n  ///      because to simulate real swap the function should be writable.\r\n  /// @param sourceAmountApprover_ A contract which has approved {sourceAmount_} to TetuConverter\r\n  /// @param sourceAmount_ Amount in terms of {sourceToken_} to be converter to {targetToken_}\r\n  /// @return converter Address of ISwapConverter\r\n  ///         If SwapManager cannot find a conversion way,\r\n  ///         it returns converter == 0 (in the same way as ITetuConverter)\r\n  function getConverter(\r\n    address sourceAmountApprover_,\r\n    address sourceToken_,\r\n    uint sourceAmount_,\r\n    address targetToken_\r\n  ) external returns (\r\n    address converter,\r\n    uint maxTargetAmount\r\n  );\r\n\r\n  /// @notice Calculate APR using known {sourceToken_} and known {targetAmount_}.\r\n  /// @param sourceAmount_ Source amount before conversion, in terms of {sourceToken_}\r\n  /// @param targetAmount_ Result of conversion. The amount is in terms of {targetToken_}\r\n  function getApr18(\r\n    address sourceToken_,\r\n    uint sourceAmount_,\r\n    address targetToken_,\r\n    uint targetAmount_\r\n  ) external view returns (int apr18);\r\n\r\n  /// @notice Return custom or default price impact tolerance for the asset\r\n  function getPriceImpactTolerance(address asset_) external view returns (uint priceImpactTolerance);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ISwapSimulator.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\ninterface ISwapSimulator {\r\n\r\n  /// @notice Make real swap to know result amount\r\n  ///         but exclude any additional operations\r\n  ///         like \"sending result amount to receiver\" or \"emitting any events\".\r\n  /// @dev This function should be called only inside static call to know result amount.\r\n  /// @param user_ A strategy which has approved source amount to TetuConverter\r\n  ///              and called a function findSwapStrategy\r\n  /// @param sourceAmount_ Amount in terms of {sourceToken_} to be converter to {targetToken_}\r\n  /// @return amountOut Result amount in terms of {targetToken_} after conversion\r\n  function simulateSwap(\r\n    address user_,\r\n    address sourceToken_,\r\n    uint sourceAmount_,\r\n    address targetToken_\r\n  ) external returns (\r\n    uint amountOut\r\n  );\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"./IConverterController.sol\";\r\n\r\n/// @notice Main contract of the TetuConverter application\r\n/// @dev Borrower (strategy) makes all operations via this contract only.\r\ninterface ITetuConverter {\r\n\r\n  function controller() external view returns (IConverterController);\r\n\r\n  /// @notice Find possible borrow strategies and provide \"cost of money\" as interest for the period for each strategy\r\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\r\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\r\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\r\n  ///                   0 is used by default\r\n  /// @param amountIn_  The meaning depends on entryData\r\n  ///                   For entryKind=0 it's max available amount of collateral\r\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\r\n  /// @return converters Array of available converters ordered in ascending order of APR.\r\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\r\n  ///                    This address should be passed to borrow-function during conversion.\r\n  ///                    The length of array is always equal to the count of available lending platforms.\r\n  ///                    Last items in array can contain zero addresses (it means they are not used)\r\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\r\n  /// @return amountToBorrowsOut Amounts that should be borrowed\r\n  ///                            This amount is not zero if corresponded converter is not zero.\r\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\r\n  function findBorrowStrategies(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_,\r\n    uint periodInBlocks_\r\n  ) external view returns (\r\n    address[] memory converters,\r\n    uint[] memory collateralAmountsOut,\r\n    uint[] memory amountToBorrowsOut,\r\n    int[] memory aprs18\r\n  );\r\n\r\n  /// @notice Find best swap strategy and provide \"cost of money\" as interest for the period\r\n  /// @dev This is writable function with read-only behavior.\r\n  ///      It should be writable to be able to simulate real swap and get a real APR.\r\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\r\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\r\n  ///                   0 is used by default\r\n  /// @param amountIn_  The meaning depends on entryData\r\n  ///                   For entryKind=0 it's max available amount of collateral\r\n  ///                   This amount must be approved to TetuConverter before the call.\r\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\r\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\r\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\r\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\r\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\r\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\r\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\r\n  function findSwapStrategy(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_\r\n  ) external returns (\r\n    address converter,\r\n    uint sourceAmountOut,\r\n    uint targetAmountOut,\r\n    int apr18\r\n  );\r\n\r\n  /// @notice Find best conversion strategy (swap or borrow) and provide \"cost of money\" as interest for the period.\r\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\r\n  /// @dev This is writable function with read-only behavior.\r\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\r\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\r\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\r\n  ///                   0 is used by default\r\n  /// @param amountIn_  The meaning depends on entryData\r\n  ///                   For entryKind=0 it's max available amount of collateral\r\n  ///                   This amount must be approved to TetuConverter before the call.\r\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\r\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\r\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\r\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\r\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\r\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\r\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\r\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\r\n  function findConversionStrategy(\r\n    bytes memory entryData_,\r\n    address sourceToken_,\r\n    uint amountIn_,\r\n    address targetToken_,\r\n    uint periodInBlocks_\r\n  ) external returns (\r\n    address converter,\r\n    uint collateralAmountOut,\r\n    uint amountToBorrowOut,\r\n    int apr18\r\n  );\r\n\r\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\r\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\r\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\r\n  ///      Only whitelisted users are allowed to make borrows\r\n  /// @param converter_ A converter received from findBestConversionStrategy.\r\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\r\n  ///                          This amount must be approved to TetuConverter before the call.\r\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\r\n  /// @param receiver_ A receiver of borrowed amount\r\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\r\n  function borrow(\r\n    address converter_,\r\n    address collateralAsset_,\r\n    uint collateralAmount_,\r\n    address borrowAsset_,\r\n    uint amountToBorrow_,\r\n    address receiver_\r\n  ) external returns (\r\n    uint borrowedAmountOut\r\n  );\r\n\r\n  /// @notice Full or partial repay of the borrow\r\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\r\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\r\n  ///                       You can know exact total amount of debt using {getStatusCurrent}.\r\n  ///                       if the amount exceed total amount of the debt:\r\n  ///                       - the debt will be fully repaid\r\n  ///                       - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\r\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\r\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\r\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\r\n  ///         If TetuConverter is not able to make the swap, it reverts\r\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\r\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\r\n  ///                                 This amount is returned back to the collateralReceiver_\r\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\r\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\r\n  function repay(\r\n    address collateralAsset_,\r\n    address borrowAsset_,\r\n    uint amountToRepay_,\r\n    address receiver_\r\n  ) external returns (\r\n    uint collateralAmountOut,\r\n    uint returnedBorrowAmountOut,\r\n    uint swappedLeftoverCollateralOut,\r\n    uint swappedLeftoverBorrowOut\r\n  );\r\n\r\n  /// @notice Estimate result amount after making full or partial repay\r\n  /// @dev It works in exactly same way as repay() but don't make actual repay\r\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\r\n  /// @param user_ user whose amount-to-repay will be calculated\r\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\r\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\r\n  function quoteRepay(\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_,\r\n    uint amountToRepay_\r\n  ) external returns (\r\n    uint collateralAmountOut\r\n  );\r\n\r\n  /// @notice Update status in all opened positions\r\n  ///         and calculate exact total amount of borrowed and collateral assets\r\n  /// @param user_ user whose debts will be updated and returned\r\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\r\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\r\n  function getDebtAmountCurrent(\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_\r\n  ) external returns (\r\n    uint totalDebtAmountOut,\r\n    uint totalCollateralAmountOut\r\n  );\r\n\r\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\r\n  /// @dev Actual debt amount can be a little LESS then the amount returned by this function.\r\n  ///      I.e. AAVE's pool adapter returns (amount of debt + tiny addon ~ 1 cent)\r\n  ///      The addon is required to workaround dust-tokens problem.\r\n  ///      After repaying the remaining amount is transferred back on the balance of the caller strategy.\r\n  /// @param user_ user whose debts will be returned\r\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\r\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\r\n  function getDebtAmountStored(\r\n    address user_,\r\n    address collateralAsset_,\r\n    address borrowAsset_\r\n  ) external view returns (\r\n    uint totalDebtAmountOut,\r\n    uint totalCollateralAmountOut\r\n  );\r\n\r\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\r\n  /// @param user_ user whose debts will be returned\r\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\r\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\r\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\r\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\r\n  ///                                           even if all borrowed amount will be returned.\r\n  ///                                           If this amount is not 0, you ask to get too much collateral.\r\n  function estimateRepay(\r\n    address user_,\r\n    address collateralAsset_,\r\n    uint collateralAmountRequired_,\r\n    address borrowAsset_\r\n  ) external view returns (\r\n    uint borrowAssetAmount,\r\n    uint unobtainableCollateralAssetAmount\r\n  );\r\n\r\n  /// @notice Transfer all reward tokens to {receiver_}\r\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\r\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\r\n  function claimRewards(address receiver_) external returns (\r\n    address[] memory rewardTokensOut,\r\n    uint[] memory amountsOut\r\n  );\r\n\r\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\r\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\r\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\r\n  ///                      It should be transferred on balance of the TetuConverter before the function call\r\n  /// @param receiver_ Result amount will be sent to this address\r\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\r\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\r\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\r\n  function safeLiquidate(\r\n    address assetIn_,\r\n    uint amountIn_,\r\n    address assetOut_,\r\n    address receiver_,\r\n    uint priceImpactToleranceSource_,\r\n    uint priceImpactToleranceTarget_\r\n  ) external returns (\r\n    uint amountOut\r\n  );\r\n\r\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\r\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\r\n  function isConversionValid(\r\n    address assetIn_,\r\n    uint amountIn_,\r\n    address assetOut_,\r\n    uint amountOut_,\r\n    uint priceImpactTolerance_\r\n  ) external view returns (bool);\r\n\r\n  /// @notice Close given borrow and return collateral back to the user, governance only\r\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\r\n  /// @param poolAdapter_ The pool adapter that represents the borrow\r\n  /// @param closePosition Close position after repay\r\n  ///        Usually it should be true, because the function always tries to repay all debt\r\n  ///        false can be used if user doesn't have enough amount to pay full debt\r\n  ///              and we are trying to pay \"as much as possible\"\r\n  /// @return collateralAmountOut Amount of collateral returned to the user\r\n  /// @return repaidAmountOut Amount of borrow asset repaid to the lending platform\r\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\r\n    uint collateralAmountOut,\r\n    uint repaidAmountOut\r\n  );\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/// @notice TetuConverter sends callback notifications to its user via this interface\r\ninterface ITetuConverterCallback {\r\n  /// @notice Converters calls this function if user should return some amount back.\r\n  ///         f.e. when the health factor is unhealthy and the converter needs more tokens to fix it.\r\n  ///         or when the full repay is required and converter needs to get full amount-to-repay.\r\n  /// @param asset_ Required asset (either collateral or borrow)\r\n  /// @param amount_ Required amount of the {asset_}\r\n  /// @return amountOut Exact amount that borrower has sent to balance of TetuConverter\r\n  function requirePayAmountBack(address asset_, uint amount_) external returns (uint amountOut);\r\n\r\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\r\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\r\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\r\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external;\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/AppDataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity 0.8.17;\r\n\r\nlibrary AppDataTypes {\r\n\r\n  enum ConversionKind {\r\n    UNKNOWN_0,\r\n    SWAP_1,\r\n    BORROW_2\r\n  }\r\n\r\n  /// @notice Input params for BorrowManager.findPool (stack is too deep problem)\r\n  struct InputConversionParams {\r\n    address collateralAsset;\r\n    address borrowAsset;\r\n\r\n    /// @notice Encoded entry kind and additional params if necessary (set of params depends on the kind)\r\n    ///         See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\r\n    bytes entryData;\r\n\r\n    uint countBlocks;\r\n\r\n    /// @notice The meaning depends on entryData kind, see EntryKinds library for details.\r\n    ///         For entry kind = 0: Amount of {sourceToken} to be converted to {targetToken}\r\n    ///         For entry kind = 1: Available amount of {sourceToken}\r\n    ///         For entry kind = 2: Amount of {targetToken} that should be received after conversion\r\n    uint amountIn;\r\n  }\r\n\r\n  /// @notice Explain how a given lending pool can make specified conversion\r\n  struct ConversionPlan {\r\n    /// @notice Template adapter contract that implements required strategy.\r\n    address converter;\r\n    /// @notice Current collateral factor [0..1e18], where 1e18 is corresponded to CF=1\r\n    uint liquidationThreshold18;\r\n\r\n    /// @notice Amount to borrow in terms of borrow asset\r\n    uint amountToBorrow;\r\n    /// @notice Amount to be used as collateral in terms of collateral asset\r\n    uint collateralAmount;\r\n\r\n    /// @notice Cost for the period calculated using borrow rate in terms of borrow tokens, decimals 36\r\n    /// @dev It doesn't take into account supply increment and rewards\r\n    uint borrowCost36;\r\n    /// @notice Potential supply increment after borrow period recalculated to Borrow Token, decimals 36\r\n    uint supplyIncomeInBorrowAsset36;\r\n    /// @notice Potential rewards amount after borrow period in terms of Borrow Tokens, decimals 36\r\n    uint rewardsAmountInBorrowAsset36;\r\n    /// @notice Amount of collateral in terms of borrow asset, decimals 36\r\n    uint amountCollateralInBorrowAsset36;\r\n\r\n    /// @notice Loan-to-value, decimals = 18 (wad)\r\n    uint ltv18;\r\n    /// @notice How much borrow asset we can borrow in the pool (in borrow tokens)\r\n    uint maxAmountToBorrow;\r\n    /// @notice How much collateral asset can be supplied (in collateral tokens).\r\n    ///         type(uint).max - unlimited, 0 - no supply is possible\r\n    uint maxAmountToSupply;\r\n  }\r\n\r\n  struct PricesAndDecimals {\r\n    /// @notice Price of the collateral asset (decimals same as the decimals of {priceBorrow})\r\n    uint priceCollateral;\r\n    /// @notice Price of the borrow asset (decimals same as the decimals of {priceCollateral})\r\n    uint priceBorrow;\r\n    /// @notice 10**{decimals of the collateral asset}\r\n    uint rc10powDec;\r\n    /// @notice 10**{decimals of the borrow asset}\r\n    uint rb10powDec;\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/AppErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/// @notice List of all errors generated by the application\r\n///         Each error should have unique code TC-XXX and descriptive comment\r\nlibrary AppErrors {\r\n  /// @notice Provided address should be not zero\r\n  string public constant ZERO_ADDRESS = \"TC-1 zero address\";\r\n  /// @notice Pool adapter for the given set {converter, user, collateral, borrowToken} not found and cannot be created\r\n  string public constant POOL_ADAPTER_NOT_FOUND = \"TC-2 adapter not found\";\r\n  /// @notice Health factor is not set or it's less then min allowed value\r\n  string public constant WRONG_HEALTH_FACTOR = \"TC-3 wrong health factor\";\r\n  /// @notice Received price is zero\r\n  string public constant ZERO_PRICE = \"TC-4 zero price\";\r\n  /// @notice Given platform adapter is not found in Borrow Manager\r\n  string public constant PLATFORM_ADAPTER_NOT_FOUND = \"TC-6 platform adapter not found\";\r\n  /// @notice Only pool adapters are allowed to make such operation\r\n  string public constant POOL_ADAPTER_ONLY = \"TC-7 pool adapter not found\";\r\n  /// @notice Only TetuConverter is allowed to make such operation\r\n  string public constant TETU_CONVERTER_ONLY = \"TC-8 tetu converter only\";\r\n  /// @notice Only Governance is allowed to make such operation\r\n  string public constant GOVERNANCE_ONLY = \"TC-9 governance only\";\r\n  /// @notice Cannot close borrow position if the position has not zero collateral or borrow balance\r\n  string public constant ATTEMPT_TO_CLOSE_NOT_EMPTY_BORROW_POSITION = \"TC-10 position not empty\";\r\n  /// @notice Borrow position is not registered in DebtMonitor\r\n  string public constant BORROW_POSITION_IS_NOT_REGISTERED = \"TC-11 position not registered\";\r\n  /// @notice Passed arrays should have same length\r\n  string public constant WRONG_LENGTHS = \"TC-12 wrong lengths\";\r\n  /// @notice Pool adapter expects some amount of collateral on its balance\r\n  string public constant WRONG_COLLATERAL_BALANCE=\"TC-13 wrong collateral balance\";\r\n  /// @notice Pool adapter expects some amount of derivative tokens on its balance after borrowing\r\n  string public constant WRONG_DERIVATIVE_TOKENS_BALANCE=\"TC-14 wrong ctokens balance\";\r\n  /// @notice Pool adapter expects some amount of borrowed tokens on its balance\r\n  string public constant WRONG_BORROWED_BALANCE = \"TC-15 wrong borrow balance\";\r\n  /// @notice cToken is not found for provided underlying\r\n  string public constant C_TOKEN_NOT_FOUND = \"TC-16 ctoken not found\";\r\n  /// @notice cToken.mint failed\r\n  string public constant MINT_FAILED = \"TC-17 mint failed\";\r\n  string public constant COMPTROLLER_GET_ACCOUNT_LIQUIDITY_FAILED = \"TC-18 get account liquidity failed\";\r\n  string public constant COMPTROLLER_GET_ACCOUNT_LIQUIDITY_UNDERWATER = \"TC-19 get account liquidity underwater\";\r\n  /// @notice borrow failed\r\n  string public constant BORROW_FAILED = \"TC-20 borrow failed\";\r\n  string public constant CTOKEN_GET_ACCOUNT_SNAPSHOT_FAILED = \"TC-21 snapshot failed\";\r\n  string public constant CTOKEN_GET_ACCOUNT_LIQUIDITY_FAILED = \"TC-22 liquidity failed\";\r\n  string public constant INCORRECT_RESULT_LIQUIDITY = \"TC-23 incorrect liquidity\";\r\n  string public constant CLOSE_POSITION_FAILED = \"TC-24 close position failed\";\r\n  string public constant CONVERTER_NOT_FOUND = \"TC-25 converter not found\";\r\n  string public constant REDEEM_FAILED = \"TC-26 redeem failed\";\r\n  string public constant REPAY_FAILED = \"TC-27 repay failed\";\r\n  /// @notice Balance shouldn't be zero\r\n  string public constant ZERO_BALANCE = \"TC-28 zero balance\";\r\n  string public constant INCORRECT_VALUE = \"TC-29 incorrect value\";\r\n  /// @notice Only user can make this action\r\n  string public constant USER_ONLY = \"TC-30 user only\";\r\n  /// @notice It's not allowed to close position with a pool adapter and make re-conversion using the same adapter\r\n  string public constant RECONVERSION_WITH_SAME_CONVERTER_FORBIDDEN = \"TC-31 reconversion forbidden\";\r\n\r\n  /// @notice Platform adapter cannot be unregistered because there is active pool adapter (open borrow on the platform)\r\n  string public constant PLATFORM_ADAPTER_IS_IN_USE = \"TC-33 platform adapter is in use\";\r\n\r\n  string public constant DIVISION_BY_ZERO = \"TC-34 division by zero\";\r\n\r\n  string public constant UNSUPPORTED_CONVERSION_KIND = \"TC-35: UNKNOWN CONVERSION\";\r\n  string public constant SLIPPAGE_TOO_BIG = \"TC-36: SLIPPAGE TOO BIG\";\r\n\r\n  /// @notice The relation \"platform adapter - converter\" is invariant.\r\n  ///         It's not allowed to assign new platform adapter to the converter\r\n  string public constant ONLY_SINGLE_PLATFORM_ADAPTER_CAN_USE_CONVERTER = \"TC-37 one platform adapter per conv\";\r\n\r\n  /// @notice Provided health factor value is not applicable for other health factors\r\n  ///         Invariant: min health factor < target health factor < max health factor\r\n  string public constant WRONG_HEALTH_FACTOR_CONFIG = \"TC-38: wrong health factor config\";\r\n\r\n  /// @notice Health factor is not good after rebalancing\r\n  string public constant WRONG_REBALANCING = \"TC-39: wrong rebalancing\";\r\n\r\n  /// @notice It's not allowed to pay debt completely using repayToRebalance\r\n  ///         Please use ordinal repay for this purpose (it allows to receive the collateral)\r\n  string public constant REPAY_TO_REBALANCE_NOT_ALLOWED = \"TC-40 repay to rebalance not allowed\";\r\n\r\n  /// @notice Received amount is different from expected one\r\n  string public constant WRONG_AMOUNT_RECEIVED = \"TC-41 wrong amount received\";\r\n  /// @notice Only one of the keepers is allowed to make such operation\r\n  string public constant KEEPER_ONLY = \"TC-42 keeper only\";\r\n\r\n  /// @notice The amount cannot be zero\r\n  string public constant ZERO_AMOUNT = \"TC-43 zero amount\";\r\n\r\n  /// @notice Value of \"converter\" passed to TetuConverter.borrow is incorrect ( != SwapManager address)\r\n  string public constant INCORRECT_CONVERTER_TO_SWAP = \"TC-44 incorrect converter\";\r\n\r\n  string public constant BORROW_MANAGER_ONLY = \"TC-45 borrow manager only\";\r\n\r\n  /// @notice Attempt to make a borrow using unhealthy pool adapter\r\n  ///         This is not normal situation.\r\n  ///         Health factor is greater 1 but it's less then minimum allowed value.\r\n  ///         Keeper doesn't work?\r\n  string public constant REBALANCING_IS_REQUIRED = \"TC-46 rebalancing is required\";\r\n\r\n  /// @notice Position can be closed as \"liquidated\" only if there is no collateral on it\r\n  string public constant CANNOT_CLOSE_LIVE_POSITION = \"TC-47 cannot close live pos\";\r\n\r\n  string public constant ACCESS_DENIED = \"TC-48 access denied\";\r\n\r\n  /// @notice Value A is less then B, so we will have overflow on A - B, but it's weird situation\r\n  ///         If balance is decreased after a supply or increased after a deposit\r\n  string public constant WEIRD_OVERFLOW = \"TC-49 weird overflow\";\r\n\r\n  string public constant AMOUNT_TOO_BIG = \"TC-50 amount too big\";\r\n\r\n  string public constant NOT_PENDING_GOVERNANCE = \"TC-51 not pending gov\";\r\n\r\n  string public constant INCORRECT_OPERATION = \"TC-52 incorrect op\";\r\n\r\n  string public constant ONLY_SWAP_MANAGER = \"TC-53 swap manager only\";\r\n\r\n  string public constant TOO_HIGH_PRICE_IMPACT = \"TC-54 price impact\";\r\n\r\n  /// @notice It's not possible to make partial repayment and close the position\r\n  string public constant CLOSE_POSITION_PARTIAL = \"TC-55 close position not allowed\";\r\n  string public constant ZERO_VALUE_NOT_ALLOWED = \"TC-56 zero not allowed\";\r\n  string public constant OUT_OF_WHITE_LIST = \"TC-57 whitelist\";\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/AppUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n/// @notice Common utils\r\nlibrary AppUtils {\r\n  /// @notice Convert {amount} with [sourceDecimals} to new amount with {targetDecimals}\r\n  function toMantissa(uint amount, uint8 sourceDecimals, uint8 targetDecimals) internal pure returns (uint) {\r\n    return sourceDecimals == targetDecimals\r\n      ? amount\r\n      : amount * (10 ** targetDecimals) / (10 ** sourceDecimals);\r\n  }\r\n\r\n  function uncheckedInc(uint i) internal pure returns (uint) {\r\n    unchecked {\r\n      return i + 1;\r\n    }\r\n  }\r\n\r\n  /// @notice Remove {itemToRemove} from {items}, move last item of {items} to the position of the removed item\r\n  function removeItemFromArray(address[] storage items, address itemToRemove) internal {\r\n    uint lenItems = items.length;\r\n    for (uint i = 0; i < lenItems; i = uncheckedInc(i)) {\r\n      if (items[i] == itemToRemove) {\r\n        if (i < lenItems - 1) {\r\n          items[i] = items[lenItems - 1];\r\n        }\r\n        items.pop();\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @notice Create new array with only first {countItemsToKeep_} items from {items_} array\r\n  /// @dev We assume, that trivial case countItemsToKeep_ == 0 is excluded, the function is not called in that case\r\n  function removeLastItems(address[] memory items_, uint countItemsToKeep_) internal pure returns (address[] memory) {\r\n    uint lenItems = items_.length;\r\n    if (lenItems <= countItemsToKeep_) {\r\n      return items_;\r\n    }\r\n\r\n    address[] memory dest = new address[](countItemsToKeep_);\r\n    for (uint i = 0; i < countItemsToKeep_; i = uncheckedInc(i)) {\r\n      dest[i] = items_[i];\r\n    }\r\n\r\n    return dest;\r\n  }\r\n\r\n  /// @dev We assume, that trivial case countItemsToKeep_ == 0 is excluded, the function is not called in that case\r\n  function removeLastItems(uint[] memory items_, uint countItemsToKeep_) internal pure returns (uint[] memory) {\r\n    uint lenItems = items_.length;\r\n    if (lenItems <= countItemsToKeep_) {\r\n      return items_;\r\n    }\r\n\r\n    uint[] memory dest = new uint[](countItemsToKeep_);\r\n    for (uint i = 0; i < countItemsToKeep_; i = uncheckedInc(i)) {\r\n      dest[i] = items_[i];\r\n    }\r\n\r\n    return dest;\r\n  }\r\n\r\n  /// @notice (amount1 - amount2) / amount1/2 < expected difference\r\n  function approxEqual(uint amount1, uint amount2, uint divisionMax18) internal pure returns (bool) {\r\n    return amount1 > amount2\r\n      ? (amount1 - amount2) * 1e18 / (amount2 + 1) < divisionMax18\r\n      : (amount2 - amount1) * 1e18 / (amount2 + 1) < divisionMax18;\r\n  }\r\n\r\n  /// @notice Reduce size of {aa_}, {bb_}, {cc_}, {dd_} ot {count_} if necessary\r\n  ///         and order all arrays in ascending order of {aa_}\r\n  /// @dev We assume here, that {count_} is rather small (it's a number of available lending platforms) < 10\r\n  function shrinkAndOrder(\r\n    uint count_,\r\n    address[] memory bb_,\r\n    uint[] memory cc_,\r\n    uint[] memory dd_,\r\n    int[] memory aa_\r\n  ) internal pure returns (\r\n    address[] memory bbOut,\r\n    uint[] memory ccOut,\r\n    uint[] memory ddOut,\r\n    int[] memory aaOut\r\n  ) {\r\n    uint[] memory indices = _sortAsc(count_, aa_);\r\n\r\n    aaOut = new int[](count_);\r\n    bbOut = new address[](count_);\r\n    ccOut = new uint[](count_);\r\n    ddOut = new uint[](count_);\r\n    for (uint i = 0; i < count_; ++i) {\r\n      aaOut[i] = aa_[indices[i]];\r\n      bbOut[i] = bb_[indices[i]];\r\n      ccOut[i] = cc_[indices[i]];\r\n      ddOut[i] = dd_[indices[i]];\r\n    }\r\n  }\r\n\r\n  /// @notice Insertion sorting algorithm for using with arrays fewer than 10 elements, isert in ascending order.\r\n  ///         Take into account only first {length_} items of the {items_} array\r\n  /// @dev Based on https://medium.com/coinmonks/sorting-in-solidity-without-comparison-4eb47e04ff0d\r\n  /// @return indices Ordered list of indices of the {items_}, size = {length}\r\n  function _sortAsc(uint length_, int[] memory items_) internal pure returns (uint[] memory indices) {\r\n    indices = new uint[](length_);\r\n    unchecked {\r\n      for (uint i; i < length_; ++i) {\r\n        indices[i] = i;\r\n      }\r\n\r\n      for (uint i = 1; i < length_; i++) {\r\n        uint key = indices[i];\r\n        uint j = i - 1;\r\n        while ((int(j) >= 0) && items_[indices[j]] > items_[key]) {\r\n          indices[j + 1] = indices[j];\r\n          j--;\r\n        }\r\n        indices[j + 1] = key;\r\n      }\r\n    }\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/EntryKinds.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"./AppDataTypes.sol\";\r\nimport \"./AppErrors.sol\";\r\n\r\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\r\nlibrary EntryKinds {\r\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\r\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\r\n\r\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\r\n  ///         C2 should be used as collateral to make a borrow B.\r\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\r\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\r\n\r\n  /// @notice Borrow given amount using min possible collateral\r\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\r\n\r\n\r\n  /// @notice Decode entryData, extract first uint - entry kind\r\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\r\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\r\n    if (entryData_.length == 0) {\r\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\r\n    }\r\n    return abi.decode(entryData_, (uint));\r\n  }\r\n\r\n  /// @notice Use {collateralAmount} as a collateral to receive max available {amountToBorrowOut}\r\n  ///         for the given {healthFactor18} and {liquidationThreshold18}\r\n  /// @param collateralAmount Available collateral amount\r\n  /// @param healthFactor18 Required health factor, decimals 18\r\n  /// @param liquidationThreshold18 Liquidation threshold of the selected landing platform, decimals 18\r\n  /// @param priceDecimals36 True if the prices in {pd} have decimals 36 (DForce, HundredFinance)\r\n  ///                        In this case, we can have overloading if collateralAmount is high enough,\r\n  ///                        so we need a special logic to avoid it\r\n  function exactCollateralInForMaxBorrowOut(\r\n    uint collateralAmount,\r\n    uint healthFactor18,\r\n    uint liquidationThreshold18,\r\n    AppDataTypes.PricesAndDecimals memory pd,\r\n    bool priceDecimals36\r\n  ) internal pure returns (\r\n    uint amountToBorrowOut\r\n  ) {\r\n    if (priceDecimals36) {\r\n      amountToBorrowOut =\r\n        1e18 * collateralAmount / healthFactor18\r\n        * (liquidationThreshold18 * pd.priceCollateral / pd.priceBorrow) // avoid overloading\r\n        * pd.rb10powDec\r\n        / 1e18\r\n        / pd.rc10powDec;\r\n    } else {\r\n      amountToBorrowOut =\r\n        1e18 * collateralAmount / healthFactor18\r\n        * liquidationThreshold18 * pd.priceCollateral / pd.priceBorrow\r\n        * pd.rb10powDec\r\n        / 1e18\r\n        / pd.rc10powDec;\r\n    }\r\n  }\r\n\r\n  /// @notice Borrow given {borrowAmount} using min possible collateral\r\n  /// @param borrowAmount Required amount to borrow\r\n  /// @param healthFactor18 Required health factor, decimals 18\r\n  /// @param liquidationThreshold18 Liquidation threshold of the selected landing platform, decimals 18\r\n  /// @param priceDecimals36 True if the prices in {pd} have decimals 36 (DForce, HundredFinance)\r\n  ///                        In this case, we can have overloading if collateralAmount is high enough,\r\n  ///                        so we need a special logic to avoid it\r\n  function exactBorrowOutForMinCollateralIn(\r\n    uint borrowAmount,\r\n    uint healthFactor18,\r\n    uint liquidationThreshold18,\r\n    AppDataTypes.PricesAndDecimals memory pd,\r\n    bool priceDecimals36\r\n  ) internal pure returns (\r\n    uint amountToCollateralOut\r\n  ) {\r\n    if (priceDecimals36) {\r\n      amountToCollateralOut = borrowAmount\r\n        * pd.priceBorrow / pd.priceCollateral\r\n        * healthFactor18 / liquidationThreshold18\r\n        * pd.rc10powDec\r\n        / pd.rb10powDec;\r\n    } else {\r\n      amountToCollateralOut = borrowAmount\r\n        * healthFactor18\r\n        * pd.priceBorrow / (liquidationThreshold18 * pd.priceCollateral)\r\n        * pd.rc10powDec\r\n        / pd.rb10powDec;\r\n    }\r\n  }\r\n\r\n  /// @notice Split {collateralAmount} on two parts: C1 and {collateralAmountOut}.\r\n  ///         {collateralAmountOut} will be used as collateral to borrow {amountToBorrowOut}.\r\n  ///         Result cost of {amountToBorrowOut} and C1 should be equal or almost equal.\r\n  /// @param collateralAmount Available collateral amount, we should use less amount.\r\n  /// @param healthFactor18 Required health factor, decimals 18\r\n  /// @param liquidationThreshold18 Liquidation threshold of the selected landing platform, decimals 18\r\n  /// @param priceDecimals36 True if the prices in {pd} have decimals 36 (DForce, HundredFinance)\r\n  ///                        In this case, we can have overloading if collateralAmount is high enough,\r\n  ///                        so we need a special logic to avoid it\r\n  /// @param entryData Additional encoded data: required proportions of C1' and {amountToBorrowOut}', X:Y\r\n  ///                  Encoded data: (uint entryKind, uint X, uint Y)\r\n  ///                  X - portion of C1, Y - portion of {amountToBorrowOut}\r\n  ///                  2:1 means, that we will have 2 parts of source asset and 1 part of borrowed asset in result.\r\n  ///                  entryKind must be equal to 1 (== ENTRY_KIND_EQUAL_COLLATERAL_AND_BORROW_OUT_1)\r\n  function exactProportion(\r\n    uint collateralAmount,\r\n    uint healthFactor18,\r\n    uint liquidationThreshold18,\r\n    AppDataTypes.PricesAndDecimals memory pd,\r\n    bytes memory entryData,\r\n    bool priceDecimals36\r\n  ) internal pure returns (\r\n    uint collateralAmountOut,\r\n    uint amountToBorrowOut\r\n  ) {\r\n    collateralAmountOut = getCollateralAmountToConvert(\r\n      entryData,\r\n      collateralAmount,\r\n      healthFactor18,\r\n      liquidationThreshold18\r\n    );\r\n    amountToBorrowOut = exactCollateralInForMaxBorrowOut(\r\n      collateralAmountOut,\r\n      healthFactor18,\r\n      liquidationThreshold18,\r\n      pd,\r\n      priceDecimals36\r\n    );\r\n  }\r\n\r\n  /// @notice Split {sourceAmount_} on two parts: C1 and C2. Swap C2 => {targetAmountOut}\r\n  ///         Result cost of {targetAmountOut} and C1 should be equal or almost equal\r\n  function getCollateralAmountToConvert(\r\n    bytes memory entryData,\r\n    uint collateralAmount,\r\n    uint healthFactor18,\r\n    uint liquidationThreshold18\r\n  ) internal pure returns (\r\n    uint collateralAmountOut\r\n  ) {\r\n    // C = C1 + C2, HF = healthFactor18, LT = liquidationThreshold18\r\n    // C' = C1' + C2' where C' is C recalculated to USD\r\n    // C' = C * PC / DC, where PC is price_C, DC = 10**decimals_C\r\n    // Y*B' = X*(C' - C1')*LT/HF ~ C1` => C1' = C' * a / (1 + a), C2' = C' / (1 + a)\r\n    // where a = (X * LT)/(HF * Y)\r\n\r\n    (, uint x, uint y) = abi.decode(entryData, (uint, uint, uint));\r\n    require(x != 0 && y != 0, AppErrors.ZERO_VALUE_NOT_ALLOWED);\r\n\r\n    uint a = (x * liquidationThreshold18 * 1e18) / (healthFactor18 * y);\r\n    return collateralAmount * 1e18 / (1e18 + a);\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/libs/SwapLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"./AppErrors.sol\";\r\nimport \"../openzeppelin/IERC20Metadata.sol\";\r\nimport \"../interfaces/IPriceOracle.sol\";\r\n\r\n/// @notice Various swap-related routines\r\nlibrary SwapLib {\r\n  uint public constant PRICE_IMPACT_NUMERATOR = 100_000;\r\n  uint public constant PRICE_IMPACT_TOLERANCE_DEFAULT = PRICE_IMPACT_NUMERATOR * 2 / 100; // 2%\r\n\r\n\r\n  /// @notice Convert amount of {assetIn_} to the corresponded amount of {assetOut_} using price oracle prices\r\n  /// @return Result amount in terms of {assetOut_}\r\n  function convertUsingPriceOracle(\r\n    IPriceOracle priceOracle_,\r\n    address assetIn_,\r\n    uint amountIn_,\r\n    address assetOut_\r\n  ) internal view returns (uint) {\r\n    uint priceOut = priceOracle_.getAssetPrice(assetOut_);\r\n    uint priceIn = priceOracle_.getAssetPrice(assetIn_);\r\n    require(priceOut != 0 && priceIn != 0, AppErrors.ZERO_PRICE);\r\n\r\n    return amountIn_\r\n      * 10**IERC20Metadata(assetOut_).decimals()\r\n      * priceIn\r\n      / priceOut\r\n      / 10**IERC20Metadata(assetIn_).decimals();\r\n  }\r\n\r\n  /// @notice Check if {amountOut_} is less than expected more than allowed by {priceImpactTolerance_}\r\n  ///         Expected amount is calculated using embedded price oracle.\r\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\r\n  function isConversionValid(\r\n    IPriceOracle priceOracle_,\r\n    address assetIn_,\r\n    uint amountIn_,\r\n    address assetOut_,\r\n    uint amountOut_,\r\n    uint priceImpactTolerance_\r\n  ) internal view returns (bool) {\r\n    uint priceOut = priceOracle_.getAssetPrice(assetOut_);\r\n    uint priceIn = priceOracle_.getAssetPrice(assetIn_);\r\n    require(priceOut != 0 && priceIn != 0, AppErrors.ZERO_PRICE);\r\n\r\n    uint expectedAmountOut = amountIn_\r\n      * 10**IERC20Metadata(assetOut_).decimals()\r\n      * priceIn\r\n      / priceOut\r\n      / 10**IERC20Metadata(assetIn_).decimals();\r\n    return amountOut_ > expectedAmountOut\r\n      ? true // we assume here, that higher output amount is not a problem\r\n      : (expectedAmountOut - amountOut_) <= expectedAmountOut * priceImpactTolerance_ / SwapLib.PRICE_IMPACT_NUMERATOR;\r\n  }\r\n}"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev Collection of functions related to the address type\r\n */\r\nlibrary Address {\r\n  /**\r\n   * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\r\n     *\r\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\r\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\r\n     * constructor.\r\n     * ====\r\n     */\r\n  function isContract(address account) internal view returns (bool) {\r\n    // This method relies on extcodesize/address.code.length, which returns 0\r\n    // for contracts in construction, since the code is only stored at the end\r\n    // of the constructor execution.\r\n\r\n    return account.code.length > 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n     * `recipient`, forwarding all available gas and reverting on errors.\r\n     *\r\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n     * imposed by `transfer`, making them unable to receive funds via\r\n     * `transfer`. {sendValue} removes this limitation.\r\n     *\r\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n     *\r\n     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n     * taken to not create reentrancy vulnerabilities. Consider using\r\n     * {ReentrancyGuard} or the\r\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n     */\r\n  function sendValue(address payable recipient, uint256 amount) internal {\r\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n    (bool success,) = recipient.call{value : amount}(\"\");\r\n    require(success, \"Address: unable to send value, recipient may have reverted\");\r\n  }\r\n\r\n  /**\r\n   * @dev Performs a Solidity function call using a low level `call`. A\r\n     * plain `call` is an unsafe replacement for a function call: use this\r\n     * function instead.\r\n     *\r\n     * If `target` reverts with a revert reason, it is bubbled up by this\r\n     * function (like regular Solidity function calls).\r\n     *\r\n     * Returns the raw returned data. To convert to the expected return value,\r\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `target` must be a contract.\r\n     * - calling `target` with `data` must not revert.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\r\n     * `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n  function functionCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, 0, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but also transferring `value` wei to `target`.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - the calling contract must have an ETH balance of at least `value`.\r\n     * - the called Solidity function must be `payable`.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value\r\n  ) internal returns (bytes memory) {\r\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\r\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\r\n     *\r\n     * _Available since v3.1._\r\n     */\r\n  function functionCallWithValue(\r\n    address target,\r\n    bytes memory data,\r\n    uint256 value,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\r\n    (bool success, bytes memory returndata) = target.call{value : value}(data);\r\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\r\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a static call.\r\n     *\r\n     * _Available since v3.3._\r\n     */\r\n  function functionStaticCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    (bool success, bytes memory returndata) = target.staticcall(data);\r\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\r\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\r\n     * but performing a delegate call.\r\n     *\r\n     * _Available since v3.4._\r\n     */\r\n  function functionDelegateCall(\r\n    address target,\r\n    bytes memory data,\r\n    string memory errorMessage\r\n  ) internal returns (bytes memory) {\r\n    (bool success, bytes memory returndata) = target.delegatecall(data);\r\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\r\n  }\r\n\r\n  /**\r\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\r\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\r\n     *\r\n     * _Available since v4.8._\r\n     */\r\n  function verifyCallResultFromTarget(\r\n    address target,\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes memory) {\r\n    if (success) {\r\n      if (returndata.length == 0) {\r\n        // only check isContract if the call was successful and the return data is empty\r\n        // otherwise we already know that it was a contract\r\n        require(isContract(target), \"Address: call to non-contract\");\r\n      }\r\n      return returndata;\r\n    } else {\r\n      _revert(returndata, errorMessage);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\r\n     * revert reason or using the provided one.\r\n     *\r\n     * _Available since v4.3._\r\n     */\r\n  function verifyCallResult(\r\n    bool success,\r\n    bytes memory returndata,\r\n    string memory errorMessage\r\n  ) internal pure returns (bytes memory) {\r\n    if (success) {\r\n      return returndata;\r\n    } else {\r\n      _revert(returndata, errorMessage);\r\n    }\r\n  }\r\n\r\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\r\n    // Look for revert reason and bubble it up if present\r\n    if (returndata.length > 0) {\r\n      // The easiest way to bubble the revert reason is using memory via assembly\r\n      /// @solidity memory-safe-assembly\r\n      assembly {\r\n        let returndata_size := mload(returndata)\r\n        revert(add(32, returndata), returndata_size)\r\n      }\r\n    } else {\r\n      revert(errorMessage);\r\n    }\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/Clones.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\r\n * deploying minimal proxy contracts, also known as \"clones\".\r\n *\r\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\r\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\r\n *\r\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\r\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\r\n * deterministic method.\r\n *\r\n * _Available since v3.4._\r\n */\r\nlibrary Clones {\r\n  /**\r\n   * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create opcode, which should never revert.\r\n     */\r\n  function clone(address implementation) internal returns (address instance) {\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n    // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n    // of the `implementation` address with the bytecode before the address.\r\n      mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n    // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n      mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n      instance := create(0, 0x09, 0x37)\r\n    }\r\n    require(instance != address(0), \"ERC1167: create failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\r\n     *\r\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\r\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\r\n     * the clones cannot be deployed twice at the same address.\r\n     */\r\n  function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n    // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\r\n    // of the `implementation` address with the bytecode before the address.\r\n      mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\r\n    // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\r\n      mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\r\n      instance := create2(0, 0x09, 0x37, salt)\r\n    }\r\n    require(instance != address(0), \"ERC1167: create2 failed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n  function predictDeterministicAddress(\r\n    address implementation,\r\n    bytes32 salt,\r\n    address deployer\r\n  ) internal pure returns (address predicted) {\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n      let ptr := mload(0x40)\r\n      mstore(add(ptr, 0x38), deployer)\r\n      mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\r\n      mstore(add(ptr, 0x14), implementation)\r\n      mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\r\n      mstore(add(ptr, 0x58), salt)\r\n      mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\r\n      predicted := keccak256(add(ptr, 0x43), 0x55)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\r\n     */\r\n  function predictDeterministicAddress(address implementation, bytes32 salt)\r\n  internal\r\n  view\r\n  returns (address predicted)\r\n  {\r\n    return predictDeterministicAddress(implementation, salt, address(this));\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"./EnumerableSet.sol\";\r\n\r\n/**\r\n * @dev Library for managing an enumerable variant of Solidity's\r\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\r\n * type.\r\n *\r\n * Maps have the following properties:\r\n *\r\n * - Entries are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableMap.UintToAddressMap private myMap;\r\n * }\r\n * ```\r\n *\r\n * The following map types are supported:\r\n *\r\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\r\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\r\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\r\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\r\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableMap.\r\n * ====\r\n */\r\nlibrary EnumerableMap {\r\n  using EnumerableSet for EnumerableSet.Bytes32Set;\r\n\r\n  // To implement this library for multiple types with as little code\r\n  // repetition as possible, we write it in terms of a generic Map type with\r\n  // bytes32 keys and values.\r\n  // The Map implementation uses private functions, and user-facing\r\n  // implementations (such as Uint256ToAddressMap) are just wrappers around\r\n  // the underlying Map.\r\n  // This means that we can only create new EnumerableMaps for types that fit\r\n  // in bytes32.\r\n\r\n  struct Bytes32ToBytes32Map {\r\n    // Storage of keys\r\n    EnumerableSet.Bytes32Set _keys;\r\n    mapping(bytes32 => bytes32) _values;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n  function set(\r\n    Bytes32ToBytes32Map storage map,\r\n    bytes32 key,\r\n    bytes32 value\r\n  ) internal returns (bool) {\r\n    map._values[key] = value;\r\n    return map._keys.add(key);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a key-value pair from a map. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\r\n    delete map._values[key];\r\n    return map._keys.remove(key);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\r\n    return map._keys.contains(key);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of key-value pairs in the map. O(1).\r\n     */\r\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\r\n    return map._keys.length();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of entries inside the\r\n     * array, and it may change when more entries are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\r\n    bytes32 key = map._keys.at(index);\r\n    return (key, map._values[key]);\r\n  }\r\n\r\n  /**\r\n   * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\r\n    bytes32 value = map._values[key];\r\n    if (value == bytes32(0)) {\r\n      return (contains(map, key), bytes32(0));\r\n    } else {\r\n      return (true, value);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\r\n    bytes32 value = map._values[key];\r\n    require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\r\n    return value;\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n  function get(\r\n    Bytes32ToBytes32Map storage map,\r\n    bytes32 key,\r\n    string memory errorMessage\r\n  ) internal view returns (bytes32) {\r\n    bytes32 value = map._values[key];\r\n    require(value != 0 || contains(map, key), errorMessage);\r\n    return value;\r\n  }\r\n\r\n  // UintToUintMap\r\n\r\n  struct UintToUintMap {\r\n    Bytes32ToBytes32Map _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n  function set(\r\n    UintToUintMap storage map,\r\n    uint256 key,\r\n    uint256 value\r\n  ) internal returns (bool) {\r\n    return set(map._inner, bytes32(key), bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\r\n    return remove(map._inner, bytes32(key));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\r\n    return contains(map._inner, bytes32(key));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n  function length(UintToUintMap storage map) internal view returns (uint256) {\r\n    return length(map._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the element stored at position `index` in the set. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\r\n    (bytes32 key, bytes32 value) = at(map._inner, index);\r\n    return (uint256(key), uint256(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\r\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\r\n    return (success, uint256(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\r\n    return uint256(get(map._inner, bytes32(key)));\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n  function get(\r\n    UintToUintMap storage map,\r\n    uint256 key,\r\n    string memory errorMessage\r\n  ) internal view returns (uint256) {\r\n    return uint256(get(map._inner, bytes32(key), errorMessage));\r\n  }\r\n\r\n  // UintToAddressMap\r\n\r\n  struct UintToAddressMap {\r\n    Bytes32ToBytes32Map _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n  function set(\r\n    UintToAddressMap storage map,\r\n    uint256 key,\r\n    address value\r\n  ) internal returns (bool) {\r\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\r\n    return remove(map._inner, bytes32(key));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\r\n    return contains(map._inner, bytes32(key));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\r\n    return length(map._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the element stored at position `index` in the set. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\r\n    (bytes32 key, bytes32 value) = at(map._inner, index);\r\n    return (uint256(key), address(uint160(uint256(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\r\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\r\n    return (success, address(uint160(uint256(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\r\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n  function get(\r\n    UintToAddressMap storage map,\r\n    uint256 key,\r\n    string memory errorMessage\r\n  ) internal view returns (address) {\r\n    return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\r\n  }\r\n\r\n  // AddressToUintMap\r\n\r\n  struct AddressToUintMap {\r\n    Bytes32ToBytes32Map _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n  function set(\r\n    AddressToUintMap storage map,\r\n    address key,\r\n    uint256 value\r\n  ) internal returns (bool) {\r\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\r\n    return remove(map._inner, bytes32(uint256(uint160(key))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\r\n    return contains(map._inner, bytes32(uint256(uint160(key))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\r\n    return length(map._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the element stored at position `index` in the set. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\r\n    (bytes32 key, bytes32 value) = at(map._inner, index);\r\n    return (address(uint160(uint256(key))), uint256(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\r\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\r\n    return (success, uint256(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\r\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n  function get(\r\n    AddressToUintMap storage map,\r\n    address key,\r\n    string memory errorMessage\r\n  ) internal view returns (uint256) {\r\n    return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\r\n  }\r\n\r\n  // Bytes32ToUintMap\r\n\r\n  struct Bytes32ToUintMap {\r\n    Bytes32ToBytes32Map _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\r\n     * key. O(1).\r\n     *\r\n     * Returns true if the key was added to the map, that is if it was not\r\n     * already present.\r\n     */\r\n  function set(\r\n    Bytes32ToUintMap storage map,\r\n    bytes32 key,\r\n    uint256 value\r\n  ) internal returns (bool) {\r\n    return set(map._inner, key, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the key was removed from the map, that is if it was present.\r\n     */\r\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\r\n    return remove(map._inner, key);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the key is in the map. O(1).\r\n     */\r\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\r\n    return contains(map._inner, key);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of elements in the map. O(1).\r\n     */\r\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\r\n    return length(map._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the element stored at position `index` in the set. O(1).\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\r\n    (bytes32 key, bytes32 value) = at(map._inner, index);\r\n    return (key, uint256(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Tries to returns the value associated with `key`. O(1).\r\n     * Does not revert if `key` is not in the map.\r\n     */\r\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\r\n    (bool success, bytes32 value) = tryGet(map._inner, key);\r\n    return (success, uint256(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value associated with `key`. O(1).\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `key` must be in the map.\r\n     */\r\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\r\n    return uint256(get(map._inner, key));\r\n  }\r\n\r\n  /**\r\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\r\n     *\r\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\r\n     * message unnecessarily. For custom revert reasons use {tryGet}.\r\n     */\r\n  function get(\r\n    Bytes32ToUintMap storage map,\r\n    bytes32 key,\r\n    string memory errorMessage\r\n  ) internal view returns (uint256) {\r\n    return uint256(get(map._inner, key, errorMessage));\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\r\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev Library for managing\r\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\r\n * types.\r\n *\r\n * Sets have the following properties:\r\n *\r\n * - Elements are added, removed, and checked for existence in constant time\r\n * (O(1)).\r\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\r\n *\r\n * ```\r\n * contract Example {\r\n *     // Add the library methods\r\n *     using EnumerableSet for EnumerableSet.AddressSet;\r\n *\r\n *     // Declare a set state variable\r\n *     EnumerableSet.AddressSet private mySet;\r\n * }\r\n * ```\r\n *\r\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\r\n * and `uint256` (`UintSet`) are supported.\r\n *\r\n * [WARNING]\r\n * ====\r\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\r\n * unusable.\r\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\r\n *\r\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\r\n * array of EnumerableSet.\r\n * ====\r\n */\r\nlibrary EnumerableSet {\r\n  // To implement this library for multiple types with as little code\r\n  // repetition as possible, we write it in terms of a generic Set type with\r\n  // bytes32 values.\r\n  // The Set implementation uses private functions, and user-facing\r\n  // implementations (such as AddressSet) are just wrappers around the\r\n  // underlying Set.\r\n  // This means that we can only create new EnumerableSets for types that fit\r\n  // in bytes32.\r\n\r\n  struct Set {\r\n    // Storage of set values\r\n    bytes32[] _values;\r\n    // Position of the value in the `values` array, plus 1 because index 0\r\n    // means a value is not in the set.\r\n    mapping(bytes32 => uint256) _indexes;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n  function _add(Set storage set, bytes32 value) private returns (bool) {\r\n    if (!_contains(set, value)) {\r\n      set._values.push(value);\r\n      // The value is stored at length-1, but we add 1 to all indexes\r\n      // and use 0 as a sentinel value\r\n      set._indexes[value] = set._values.length;\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\r\n    // We read and store the value's index to prevent multiple reads from the same storage slot\r\n    uint256 valueIndex = set._indexes[value];\r\n\r\n    if (valueIndex != 0) {\r\n      // Equivalent to contains(set, value)\r\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\r\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\r\n      // This modifies the order of the array, as noted in {at}.\r\n\r\n      uint256 toDeleteIndex = valueIndex - 1;\r\n      uint256 lastIndex = set._values.length - 1;\r\n\r\n      if (lastIndex != toDeleteIndex) {\r\n        bytes32 lastValue = set._values[lastIndex];\r\n\r\n        // Move the last value to the index where the value to delete is\r\n        set._values[toDeleteIndex] = lastValue;\r\n        // Update the index for the moved value\r\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\r\n      }\r\n\r\n      // Delete the slot where the moved value was stored\r\n      set._values.pop();\r\n\r\n      // Delete the index for the deleted slot\r\n      delete set._indexes[value];\r\n\r\n      return true;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\r\n    return set._indexes[value] != 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values on the set. O(1).\r\n     */\r\n  function _length(Set storage set) private view returns (uint256) {\r\n    return set._values.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\r\n    return set._values[index];\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n  function _values(Set storage set) private view returns (bytes32[] memory) {\r\n    return set._values;\r\n  }\r\n\r\n  // Bytes32Set\r\n\r\n  struct Bytes32Set {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n    return _add(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\r\n    return _remove(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\r\n    return _contains(set._inner, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n     */\r\n  function length(Bytes32Set storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\r\n    return _at(set._inner, index);\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\r\n    bytes32[] memory store = _values(set._inner);\r\n    bytes32[] memory result;\r\n\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // AddressSet\r\n\r\n  struct AddressSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n  function add(AddressSet storage set, address value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n  function remove(AddressSet storage set, address value) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\r\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n     */\r\n  function length(AddressSet storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\r\n    return address(uint160(uint256(_at(set._inner, index))));\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n  function values(AddressSet storage set) internal view returns (address[] memory) {\r\n    bytes32[] memory store = _values(set._inner);\r\n    address[] memory result;\r\n\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  // UintSet\r\n\r\n  struct UintSet {\r\n    Set _inner;\r\n  }\r\n\r\n  /**\r\n   * @dev Add a value to a set. O(1).\r\n     *\r\n     * Returns true if the value was added to the set, that is if it was not\r\n     * already present.\r\n     */\r\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\r\n    return _add(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Removes a value from a set. O(1).\r\n     *\r\n     * Returns true if the value was removed from the set, that is if it was\r\n     * present.\r\n     */\r\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\r\n    return _remove(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the value is in the set. O(1).\r\n     */\r\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\r\n    return _contains(set._inner, bytes32(value));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the number of values in the set. O(1).\r\n     */\r\n  function length(UintSet storage set) internal view returns (uint256) {\r\n    return _length(set._inner);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the value stored at position `index` in the set. O(1).\r\n     *\r\n     * Note that there are no guarantees on the ordering of values inside the\r\n     * array, and it may change when more values are added or removed.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `index` must be strictly less than {length}.\r\n     */\r\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\r\n    return uint256(_at(set._inner, index));\r\n  }\r\n\r\n  /**\r\n   * @dev Return the entire set in an array\r\n     *\r\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\r\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\r\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\r\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\r\n     */\r\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\r\n    bytes32[] memory store = _values(set._inner);\r\n    uint256[] memory result;\r\n\r\n    /// @solidity memory-safe-assembly\r\n    assembly {\r\n      result := store\r\n    }\r\n\r\n    return result;\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\n/**\r\n * @dev Interface of the ERC20 standard as defined in the EIP.\r\n */\r\ninterface IERC20 {\r\n  /**\r\n   * @dev Returns the amount of tokens in existence.\r\n   */\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the amount of tokens owned by `account`.\r\n   */\r\n  function balanceOf(address account) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Returns the remaining number of tokens that `spender` will be\r\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n   * zero by default.\r\n   *\r\n   * This value changes when {approve} or {transferFrom} are called.\r\n   */\r\n  function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n   * that someone may use both the old and the new allowance by unfortunate\r\n   * transaction ordering. One possible solution to mitigate this race\r\n   * condition is to first reduce the spender's allowance to 0 and set the\r\n   * desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   *\r\n   * Emits an {Approval} event.\r\n   */\r\n  function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n  /**\r\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n   * allowance mechanism. `amount` is then deducted from the caller's\r\n   * allowance.\r\n   *\r\n   * Returns a boolean value indicating whether the operation succeeded.\r\n   *\r\n   * Emits a {Transfer} event.\r\n   */\r\n  function transferFrom(\r\n    address sender,\r\n    address recipient,\r\n    uint256 amount\r\n  ) external returns (bool);\r\n\r\n  /**\r\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n   * another (`to`).\r\n   *\r\n   * Note that `value` may be zero.\r\n   */\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n  /**\r\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n   * a call to {approve}. `value` is the new allowance.\r\n   */\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IERC20.sol\";\r\n\r\n/**\r\n * @dev Interface for the optional metadata functions from the ERC20 standard.\r\n *\r\n * _Available since v4.1._\r\n */\r\ninterface IERC20Metadata is IERC20 {\r\n  /**\r\n   * @dev Returns the name of the token.\r\n   */\r\n  function name() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the symbol of the token.\r\n   */\r\n  function symbol() external view returns (string memory);\r\n\r\n  /**\r\n   * @dev Returns the decimals places of the token.\r\n   */\r\n  function decimals() external view returns (uint8);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\r\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\r\n *\r\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\r\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\r\n * need to send a transaction, and thus is not required to hold Ether at all.\r\n */\r\ninterface IERC20Permit {\r\n  /**\r\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\r\n     * given ``owner``'s signed approval.\r\n     *\r\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\r\n     * ordering also apply here.\r\n     *\r\n     * Emits an {Approval} event.\r\n     *\r\n     * Requirements:\r\n     *\r\n     * - `spender` cannot be the zero address.\r\n     * - `deadline` must be a timestamp in the future.\r\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\r\n     * over the EIP712-formatted function arguments.\r\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\r\n     *\r\n     * For more information on the signature format, see the\r\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\r\n     * section].\r\n     */\r\n  function permit(\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external;\r\n\r\n  /**\r\n   * @dev Returns the current nonce for `owner`. This value must be\r\n     * included whenever a signature is generated for {permit}.\r\n     *\r\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\r\n     * prevents a signature from being used multiple times.\r\n     */\r\n  function nonces(address owner) external view returns (uint256);\r\n\r\n  /**\r\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\r\n     */\r\n  // solhint-disable-next-line func-name-mixedcase\r\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"./Address.sol\";\r\n\r\n/**\r\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\r\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\r\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\r\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\r\n *\r\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\r\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\r\n * case an upgrade adds a module that needs to be initialized.\r\n *\r\n * For example:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * contract MyToken is ERC20Upgradeable {\r\n *     function initialize() initializer public {\r\n *         __ERC20_init(\"MyToken\", \"MTK\");\r\n *     }\r\n * }\r\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\r\n *     function initializeV2() reinitializer(2) public {\r\n *         __ERC20Permit_init(\"MyToken\");\r\n *     }\r\n * }\r\n * ```\r\n *\r\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\r\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\r\n *\r\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\r\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\r\n *\r\n * [CAUTION]\r\n * ====\r\n * Avoid leaving a contract uninitialized.\r\n *\r\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\r\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\r\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\r\n *\r\n * [.hljs-theme-light.nopadding]\r\n * ```\r\n * /// @custom:oz-upgrades-unsafe-allow constructor\r\n * constructor() {\r\n *     _disableInitializers();\r\n * }\r\n * ```\r\n * ====\r\n */\r\nabstract contract Initializable {\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n     * @custom:oz-retyped-from bool\r\n     */\r\n  uint8 private _initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n     */\r\n  bool private _initializing;\r\n\r\n  /**\r\n   * @dev Triggered when the contract has been initialized or reinitialized.\r\n     */\r\n  event Initialized(uint8 version);\r\n\r\n  /**\r\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\r\n     * `onlyInitializing` functions can be used to initialize parent contracts.\r\n     *\r\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\r\n     * constructor.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n  modifier initializer() {\r\n    bool isTopLevelCall = !_initializing;\r\n    require(\r\n      (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\r\n      \"Initializable: contract is already initialized\"\r\n    );\r\n    _initialized = 1;\r\n    if (isTopLevelCall) {\r\n      _initializing = true;\r\n    }\r\n    _;\r\n    if (isTopLevelCall) {\r\n      _initializing = false;\r\n      emit Initialized(1);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\r\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\r\n     * used to initialize parent contracts.\r\n     *\r\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\r\n     * are added through upgrades and that require initialization.\r\n     *\r\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\r\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\r\n     *\r\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\r\n     * a contract, executing them in the right order is up to the developer or operator.\r\n     *\r\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\r\n     *\r\n     * Emits an {Initialized} event.\r\n     */\r\n  modifier reinitializer(uint8 version) {\r\n    require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\r\n    _initialized = version;\r\n    _initializing = true;\r\n    _;\r\n    _initializing = false;\r\n    emit Initialized(version);\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\r\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\r\n     */\r\n  modifier onlyInitializing() {\r\n    require(_initializing, \"Initializable: contract is not initializing\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\r\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\r\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\r\n     * through proxies.\r\n     *\r\n     * Emits an {Initialized} event the first time it is successfully executed.\r\n     */\r\n  function _disableInitializers() internal virtual {\r\n    require(!_initializing, \"Initializable: contract is initializing\");\r\n    if (_initialized != type(uint8).max) {\r\n      _initialized = type(uint8).max;\r\n      emit Initialized(type(uint8).max);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\r\n     */\r\n  function _getInitializedVersion() internal view returns (uint8) {\r\n    return _initialized;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\r\n     */\r\n  function _isInitializing() internal view returns (bool) {\r\n    return _initializing;\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\n/**\r\n * @dev Contract module that helps prevent reentrant calls to a function.\r\n *\r\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\r\n * available, which can be applied to functions to make sure there are no nested\r\n * (reentrant) calls to them.\r\n *\r\n * Note that because there is a single `nonReentrant` guard, functions marked as\r\n * `nonReentrant` may not call one another. This can be worked around by making\r\n * those functions `private`, and then adding `external` `nonReentrant` entry\r\n * points to them.\r\n *\r\n * TIP: If you would like to learn more about reentrancy and alternative ways\r\n * to protect against it, check out our blog post\r\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\r\n */\r\nabstract contract ReentrancyGuard {\r\n  // Booleans are more expensive than uint256 or any type that takes up a full\r\n  // word because each write operation emits an extra SLOAD to first read the\r\n  // slot's contents, replace the bits taken up by the boolean, and then write\r\n  // back. This is the compiler's defense against contract upgrades and\r\n  // pointer aliasing, and it cannot be disabled.\r\n\r\n  // The values being non-zero value makes deployment a bit more expensive,\r\n  // but in exchange the refund on every call to nonReentrant will be lower in\r\n  // amount. Since refunds are capped to a percentage of the total\r\n  // transaction's gas, it is best to keep them low in cases like this one, to\r\n  // increase the likelihood of the full refund coming into effect.\r\n  uint256 private constant _NOT_ENTERED = 1;\r\n  uint256 private constant _ENTERED = 2;\r\n\r\n  uint256 private _status;\r\n\r\n  constructor() {\r\n    _status = _NOT_ENTERED;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n     * Calling a `nonReentrant` function from another `nonReentrant`\r\n     * function is not supported. It is possible to prevent this from happening\r\n     * by making the `nonReentrant` function external, and making it call a\r\n     * `private` function that does the actual work.\r\n     */\r\n  modifier nonReentrant() {\r\n    _nonReentrantBefore();\r\n    _;\r\n    _nonReentrantAfter();\r\n  }\r\n\r\n  function _nonReentrantBefore() private {\r\n    // On the first call to nonReentrant, _status will be _NOT_ENTERED\r\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n    // Any calls to nonReentrant after this point will fail\r\n    _status = _ENTERED;\r\n  }\r\n\r\n  function _nonReentrantAfter() private {\r\n    // By storing the original value once again, a refund is triggered (see\r\n    // https://eips.ethereum.org/EIPS/eip-2200)\r\n    _status = _NOT_ENTERED;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\r\n     * `nonReentrant` function in the call stack.\r\n     */\r\n  function _reentrancyGuardEntered() internal view returns (bool) {\r\n    return _status == _ENTERED;\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\r\n\r\npragma solidity 0.8.17;\r\n\r\nimport \"./IERC20.sol\";\r\nimport \"./IERC20Permit.sol\";\r\nimport \"./Address.sol\";\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\r\n * contract returns false). Tokens that return no value (and instead revert or\r\n * throw on failure) are also supported, non-reverting calls are assumed to be\r\n * successful.\r\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  using Address for address;\r\n\r\n  function safeTransfer(\r\n    IERC20 token,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    IERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  ) internal {\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\r\n  }\r\n\r\n  /**\r\n   * @dev Deprecated. This function has issues similar to the ones found in\r\n     * {IERC20-approve}, and its usage is discouraged.\r\n     *\r\n     * Whenever possible, use {safeIncreaseAllowance} and\r\n     * {safeDecreaseAllowance} instead.\r\n     */\r\n  function safeApprove(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    // safeApprove should only be called when setting an initial allowance,\r\n    // or when resetting it to zero. To increase and decrease it, use\r\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\r\n    require(\r\n      (value == 0) || (token.allowance(address(this), spender) == 0),\r\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\r\n    );\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\r\n  }\r\n\r\n  function safeIncreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n  }\r\n\r\n  function safeDecreaseAllowance(\r\n    IERC20 token,\r\n    address spender,\r\n    uint256 value\r\n  ) internal {\r\n  unchecked {\r\n    uint256 oldAllowance = token.allowance(address(this), spender);\r\n    require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\r\n    uint256 newAllowance = oldAllowance - value;\r\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\r\n  }\r\n  }\r\n\r\n  function safePermit(\r\n    IERC20Permit token,\r\n    address owner,\r\n    address spender,\r\n    uint256 value,\r\n    uint256 deadline,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) internal {\r\n    uint256 nonceBefore = token.nonces(owner);\r\n    token.permit(owner, spender, value, deadline, v, r, s);\r\n    uint256 nonceAfter = token.nonces(owner);\r\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\r\n  }\r\n\r\n  /**\r\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\r\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\r\n     * @param token The token targeted by the call.\r\n     * @param data The call data (encoded using abi.encode or one of its variants).\r\n     */\r\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\r\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\r\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\r\n    // the target address contains contract code and also asserts for success in the low-level call.\r\n\r\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\r\n    if (returndata.length > 0) {\r\n      // Return data is optional\r\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\r\n    }\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-converter/contracts/tests/keeper/KeeperCaller.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nimport \"../../integrations/gelato/IResolver.sol\";\r\nimport \"hardhat/console.sol\";\r\nimport \"../../integrations/gelato/OpsReady.sol\";\r\n\r\ncontract KeeperCaller is IOps {\r\n  enum LastCallResults {\r\n    NOT_CALLED_0,\r\n    SUCCESS_1,\r\n    FAILED_2\r\n  }\r\n  address public keeperChecker;\r\n  address public keeperExecutor;\r\n  LastCallResults public lastCallResults;\r\n\r\n  function setupKeeper(\r\n    address keeperChecker_,\r\n    address keeperExecutor_\r\n  ) external {\r\n    keeperChecker = keeperChecker_;\r\n    keeperExecutor = keeperExecutor_;\r\n  }\r\n\r\n  function gelato() external view override returns (address payable) {\r\n    console.log(\"is gelato\", address(this));\r\n    return payable(address(this));\r\n  }\r\n\r\n  function taskTreasury() external view override returns (address) {\r\n    return address(this);\r\n  }\r\n\r\n  function callChecker() external {\r\n    console.log(\"KeeperCaller.callChecker\", address(keeperChecker));\r\n    (\r\n      bool canExecOut,\r\n      bytes memory execPayloadOut\r\n    ) = IResolver(keeperChecker).checker();\r\n    console.log(\"KeeperCaller.canExecOut\", canExecOut);\r\n\r\n    if (canExecOut) {\r\n      console.log(\"KeeperCaller.execute\", address(keeperExecutor));\r\n      (bool success,) = address(keeperExecutor).call(execPayloadOut);\r\n      console.log(\"KeeperCaller.execute success\", success);\r\n      lastCallResults = success\r\n        ? LastCallResults.SUCCESS_1\r\n        : LastCallResults.FAILED_2;\r\n    } else {\r\n      lastCallResults = LastCallResults.NOT_CALLED_0;\r\n    }\r\n  }\r\n}\r\n"
    },
    "@tetu_io/tetu-liquidator/contracts/Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./interfaces/ILiquidatorController.sol\";\nimport \"./interfaces/IProxyControlled.sol\";\n\n\ncontract Controller is ILiquidatorController {\n\n  // *************************************************************\n  //                        VARIABLES\n  // *************************************************************\n\n  address public override governance;\n  address public pendingGovernance;\n  mapping(address => bool) public operators;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event SetGovernance(address value);\n  event ChangeOperatorStatus(address operator, bool status);\n\n  // *************************************************************\n  //                      CONSTRUCTOR\n  // *************************************************************\n\n  constructor () {\n    governance = msg.sender;\n    operators[msg.sender] = true;\n  }\n\n  // *************************************************************\n  //                     RESTRICTIONS\n  // *************************************************************\n\n  modifier onlyGovernance() {\n    require(msg.sender == governance, \"!gov\");\n    _;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  function isOperator(address _adr) external view override returns (bool) {\n    return operators[_adr];\n  }\n\n  // *************************************************************\n  //                     GOV ACTIONS\n  // *************************************************************\n\n  function updateProxies(address[] memory proxies, address[] memory newLogics) external onlyGovernance {\n    require(proxies.length == newLogics.length, \"Wrong arrays\");\n    for (uint i; i < proxies.length; i++) {\n      IProxyControlled(proxies[i]).upgrade(newLogics[i]);\n    }\n  }\n\n  function changeOperatorStatus(address operator, bool status) external onlyGovernance {\n    operators[operator] = status;\n    emit ChangeOperatorStatus(operator, status);\n  }\n\n  function setGovernance(address _value) external onlyGovernance {\n    pendingGovernance = _value;\n    emit SetGovernance(_value);\n  }\n\n  function acceptGovernance() external {\n    require(msg.sender == pendingGovernance, \"Not pending gov\");\n    governance = pendingGovernance;\n  }\n\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/dex/uniswap3/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/dex/uniswap3/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/dex/uniswap3/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/dex/uniswap3/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/dex/uniswap3/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/dex/uniswap3/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/dex/uniswap3/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/dex/uniswap3/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n     */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n     */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/interfaces/ILiquidatorControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ILiquidatorControllable {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/interfaces/ILiquidatorController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ILiquidatorController {\n\n  function governance() external view returns (address);\n\n  function isOperator(address _adr) external view returns (bool);\n\n\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/interfaces/IProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IProxyControlled {\n\n  function initProxy(address _logic) external;\n\n  function upgrade(address _newImplementation) external;\n\n  function implementation() external returns (address);\n\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/interfaces/ISwapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ISwapper {\n\n  function swap(\n    address pool,\n    address tokenIn,\n    address tokenOut,\n    address recipient,\n    uint priceImpactTolerance\n  ) external;\n\n  function getPrice(\n    address pool,\n    address tokenIn,\n    address tokenOut,\n    uint amount\n  ) external view returns (uint);\n\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/interfaces/ITetuLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ITetuLiquidator {\n\n  struct PoolData {\n    address pool;\n    address swapper;\n    address tokenIn;\n    address tokenOut;\n  }\n\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\n\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\n\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\n\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint priceImpactTolerance\n  ) external;\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint priceImpactTolerance\n  ) external;\n\n\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/lib/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  /// @dev Gets a slot array by index as uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  // ************* ARRAY SETTERS *******************\n\n  /// @dev Sets a slot array at index with address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, address value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets a slot array at index with uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, uint value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets an array length\n  function setLength(bytes32 slot, uint length) internal {\n    assembly {\n      sstore(slot, length)\n    }\n  }\n\n  /// @dev Pushes an address to the array\n  function push(bytes32 slot, address value) internal {\n    uint length = arrayLength(slot);\n    setAt(slot, length, value);\n    setLength(slot, length + 1);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/utils/AddressUpgradeable.sol\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n  function sendValue(address payable recipient, uint amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCall(target, data, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    require(isContract(target), \"Address: call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    require(isContract(target), \"Address: static call to non-contract\");\n\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResult(success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      // Look for revert reason and bubble it up if present\n      if (returndata.length > 0) {\n        // The easiest way to bubble the revert reason is using memory via assembly\n\n        assembly {\n          let returndata_size := mload(returndata)\n          revert(add(32, returndata), returndata_size)\n        }\n      } else {\n        revert(errorMessage);\n      }\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/openzeppelin/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"./Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n  uint8 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n     */\n  bool private _initializing;\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n  event Initialized(uint8 version);\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n  modifier initializer() {\n    bool isTopLevelCall = _setInitializedVersion(1);\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n      emit Initialized(1);\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n  modifier reinitializer(uint8 version) {\n    bool isTopLevelCall = _setInitializedVersion(version);\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n      emit Initialized(version);\n    }\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n  modifier onlyInitializing() {\n    require(_initializing, \"Initializable: contract is not initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n  function _disableInitializers() internal virtual {\n    _setInitializedVersion(type(uint8).max);\n  }\n\n  function _setInitializedVersion(uint8 version) private returns (bool) {\n    // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n    // inheritance patterns, but we only do this in the context of a constructor, and for the lowest level\n    // of initializers, because in other contexts the contract may have been reentered.\n    if (_initializing) {\n      require(\n        version == 1 && !Address.isContract(address(this)),\n        \"Initializable: contract is already initialized\"\n      );\n      return false;\n    } else {\n      require(_initialized < version, \"Initializable: contract is already initialized\");\n      _initialized = version;\n      return true;\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a * b;\n  }\n\n  function div(\n    uint256 a,\n    uint256 b,\n    bool roundUp\n  ) internal pure returns (uint256) {\n    return roundUp ? divUp(a, b) : divDown(a, b);\n  }\n\n  function divDown(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a / b;\n  }\n\n  function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    } else {\n      return 1 + (a - 1) / b;\n    }\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n     */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n     */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(x, y, not(0))\n      prod0 := mul(x, y)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n      return prod0 / denominator;\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    require(denominator > prod1);\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly {\n    // Compute remainder using mulmod.\n      remainder := mulmod(x, y, denominator)\n\n    // Subtract 256 bit number from 512 bit number.\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n    // See https://cs.stackexchange.com/q/138556/92363.\n\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\n    uint256 twos = denominator & (~denominator + 1);\n    assembly {\n    // Divide denominator by twos.\n      denominator := div(denominator, twos)\n\n    // Divide [prod1 prod0] by twos.\n      prod0 := div(prod0, twos)\n\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n\n    // Shift in bits from prod1 into prod0.\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n    // four bits. That is, denominator * inv = 1 mod 2^4.\n    uint256 inverse = (3 * denominator) ^ 2;\n\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n    // in modular arithmetic, doubling the correct bits in each step.\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inverse;\n    return result;\n  }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator,\n    Rounding rounding\n  ) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n  unchecked {\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    return min(result, a / result);\n  }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = sqrt(a);\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 128;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 64;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 32;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 16;\n    }\n    if (value >> 8 > 0) {\n      value >>= 8;\n      result += 8;\n    }\n    if (value >> 4 > 0) {\n      value >>= 4;\n      result += 4;\n    }\n    if (value >> 2 > 0) {\n      value >>= 2;\n      result += 2;\n    }\n    if (value >> 1 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log2(value);\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >= 10**64) {\n      value /= 10**64;\n      result += 64;\n    }\n    if (value >= 10**32) {\n      value /= 10**32;\n      result += 32;\n    }\n    if (value >= 10**16) {\n      value /= 10**16;\n      result += 16;\n    }\n    if (value >= 10**8) {\n      value /= 10**8;\n      result += 8;\n    }\n    if (value >= 10**4) {\n      value /= 10**4;\n      result += 4;\n    }\n    if (value >= 10**2) {\n      value /= 10**2;\n      result += 2;\n    }\n    if (value >= 10**1) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log10(value);\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 16;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 8;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 4;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 2;\n    }\n    if (value >> 8 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log256(value);\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n  }\n  }\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/openzeppelin/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n   *\n   * This function does not return to its internall call site, it will return directly to the external caller.\n   */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n    // Copy msg.data. We take full control of memory in this inline assembly\n    // block because it will not return to Solidity code. We overwrite the\n    // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n    // Call the implementation.\n    // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n    // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n   * and {_fallback} should delegate.\n   */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n   *\n   * This function does not return to its internall call site, it will return directly to the external caller.\n   */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n   * function in the contract matches the call data.\n   */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n   * is empty.\n   */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n   * call, or as part of the Solidity `fallback` or `receive` functions.\n   *\n   * If overriden should call `super._beforeFallback()`.\n   */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/openzeppelin/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n  // Booleans are more expensive than uint256 or any type that takes up a full\n  // word because each write operation emits an extra SLOAD to first read the\n  // slot's contents, replace the bits taken up by the boolean, and then write\n  // back. This is the compiler's defense against contract upgrades and\n  // pointer aliasing, and it cannot be disabled.\n\n  // The values being non-zero value makes deployment a bit more expensive,\n  // but in exchange the refund on every call to nonReentrant will be lower in\n  // amount. Since refunds are capped to a percentage of the total\n  // transaction's gas, it is best to keep them low in cases like this one, to\n  // increase the likelihood of the full refund coming into effect.\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor() {\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n   * Calling a `nonReentrant` function from another `nonReentrant`\n   * function is not supported. It is possible to prevent this from happening\n   * by making the `nonReentrant` function external, and make it call a\n   * `private` function that does the actual work.\n   */\n  modifier nonReentrant() {\n    // On the first call to nonReentrant, _notEntered will be true\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n\n    _;\n\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"./Address.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v4.6/contracts/token/ERC20/utils/SafeERC20.sol\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint value\n  ) internal {\n    uint newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint value\n  ) internal {\n  unchecked {\n    uint oldAllowance = token.allowance(address(this), spender);\n    require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n    uint newAllowance = oldAllowance - value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/openzeppelin/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n  function toString(uint256 value) internal pure returns (string memory) {\n  unchecked {\n    uint256 length = Math.log10(value) + 1;\n    string memory buffer = new string(length);\n    uint256 ptr;\n    /// @solidity memory-safe-assembly\n    assembly {\n      ptr := add(buffer, add(32, length))\n    }\n    while (true) {\n      ptr--;\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n      }\n      value /= 10;\n      if (value == 0) break;\n    }\n    return buffer;\n  }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n  unchecked {\n    return toHexString(value, Math.log256(value) + 1);\n  }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/proxy/ControllableV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../interfaces/ILiquidatorControllable.sol\";\nimport \"../interfaces/ILiquidatorController.sol\";\nimport \"../lib/SlotsLib.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract ControllableV3 is Initializable, ILiquidatorControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"3.0.0\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) public onlyInitializing {\n    require(controller_ != address(0), \"Zero controller\");\n    require(ILiquidatorController(controller_).governance() != address(0), \"Zero governance\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address _value) public override view returns (bool) {\n    return _value == controller();\n  }\n\n  /// @notice Return true if given address is setup as governance in Controller\n  function isGovernance(address _value) public override view returns (bool) {\n    return ILiquidatorController(controller()).governance() == _value;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view returns (uint){\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view returns (address){\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return controller address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/proxy/ProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/ILiquidatorControllable.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"./UpgradeableProxy.sol\";\n\n/// @title EIP1967 Upgradable proxy implementation.\n/// @dev Only Controller has access and should implement time-lock for upgrade action.\n/// @author belbix\ncontract ProxyControlled is UpgradeableProxy, IProxyControlled {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant PROXY_CONTROLLED_VERSION = \"1.0.0\";\n\n  /// @dev Initialize proxy implementation. Need to call after deploy new proxy.\n  function initProxy(address _logic) external override {\n    //make sure that given logic is controllable and not inited\n    require(ILiquidatorControllable(_logic).created() == 0, \"Proxy: Wrong implementation\");\n    _init(_logic);\n  }\n\n  /// @notice Upgrade contract logic\n  /// @dev Upgrade allowed only for Controller and should be done only after time-lock period\n  /// @param _newImplementation Implementation address\n  function upgrade(address _newImplementation) external override {\n    require(ILiquidatorControllable(address(this)).isController(msg.sender), \"Proxy: Forbidden\");\n    ILiquidatorControllable(address(this)).increaseRevision(_implementation());\n    _upgradeTo(_newImplementation);\n    // the new contract must have the same ABI and you must have the power to change it again\n    require(ILiquidatorControllable(address(this)).isController(msg.sender), \"Proxy: Wrong implementation\");\n  }\n\n  /// @notice Return current logic implementation\n  function implementation() external override view returns (address) {\n    return _implementation();\n  }\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Proxy.sol\";\nimport \"../openzeppelin/Address.sol\";\n\n/// @title OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/proxy/UpgradeableProxy.sol\n/// @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n///      implementation address that can be changed. This address is stored in storage in the location specified by\n///      https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n///      implementation behind the proxy.\n///      Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n///      {TransparentUpgradeableProxy}.\nabstract contract UpgradeableProxy is Proxy {\n\n  /// @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n  ///      If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n  ///      function call, and allows initializating the storage of the proxy like a Solidity constructor.\n  constructor() payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n  }\n\n  /// @dev Emitted when the implementation is upgraded.\n  event Upgraded(address indexed implementation);\n\n  ///@dev Storage slot with the address of the current implementation.\n  ///     This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n  ///     validated in the constructor.\n  bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /// @dev Post deploy initialisation for compatability with EIP-1167 factory\n  function _init(address _logic) internal {\n    require(_implementation() == address(0), \"Already inited\");\n    _setImplementation(_logic);\n  }\n\n  /// @dev Returns the current implementation address.\n  function _implementation() internal view virtual override returns (address impl) {\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /// @dev Upgrades the proxy to a new implementation.\n  ///      Emits an {Upgraded} event.\n  function _upgradeTo(address newImplementation) internal virtual {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /// @dev Stores a new address in the EIP1967 implementation slot.\n  function _setImplementation(address newImplementation) private {\n    require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/swappers/Uni3Swapper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../openzeppelin/Strings.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"../interfaces/ISwapper.sol\";\nimport \"../dex/uniswap3/interfaces/IUniswapV3Pool.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"../dex/uniswap3/interfaces/callback/IUniswapV3SwapCallback.sol\";\n\n/// @title Swap tokens via UniswapV3 contracts.\n/// @author belbix\ncontract Uni3Swapper is ControllableV3, ISwapper, IUniswapV3SwapCallback {\n  using SafeERC20 for IERC20;\n\n  struct SwapCallbackData {\n    address tokenIn;\n    uint amount;\n  }\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant UNI_SWAPPER3_VERSION = \"1.0.2\";\n  uint public constant FEE_DENOMINATOR = 100_000;\n  uint public constant PRICE_IMPACT_DENOMINATOR = 100_000;\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739 + 1;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\n  uint private constant TWO_96 = 2 ** 96;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Swap(\n    address pool,\n    address tokenIn,\n    address tokenOut,\n    address recipient,\n    uint priceImpactTolerance,\n    uint amountIn,\n    uint amountOut\n  );\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n\n  // *************************************************************\n  //                        PRICE\n  // *************************************************************\n\n  function _countDigits(uint n) internal pure returns (uint){\n    if (n == 0) {\n      return 0;\n    }\n    uint count = 0;\n    while (n != 0) {\n      n = n / 10;\n      ++count;\n    }\n    return count;\n  }\n\n  /// @dev Return current price without amount impact.\n  function getPrice(\n    address pool,\n    address tokenIn,\n    address /*tokenOut*/,\n    uint /*amount*/\n  ) public view override returns (uint) {\n    address token0 = IUniswapV3Pool(pool).token0();\n    address token1 = IUniswapV3Pool(pool).token1();\n\n    uint256 tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    uint256 tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    (uint160 sqrtPriceX96,,,,,,) = IUniswapV3Pool(pool).slot0();\n\n    uint divider = tokenOutDecimals < 18 ? Math.max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\n\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\n    uint purePrice;\n    uint precision;\n    if (tokenIn == token0) {\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\n      purePrice = part * part;\n    } else {\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\n      purePrice = part * part;\n    }\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\n  }\n\n  // *************************************************************\n  //                        SWAP\n  // *************************************************************\n\n  /// @dev Swap given tokenIn for tokenOut. Assume that tokenIn already sent to this contract.\n  /// @param pool UniswapV3 pool\n  /// @param tokenIn Token for sell\n  /// @param tokenOut Token for buy\n  /// @param recipient Recipient for tokenOut\n  /// @param priceImpactTolerance Price impact tolerance. Must include fees at least. Denominator is 100_000.\n  function swap(\n    address pool,\n    address tokenIn,\n    address tokenOut,\n    address recipient,\n    uint priceImpactTolerance\n  ) external override {\n    address token0 = IUniswapV3Pool(pool).token0();\n\n    uint balanceBefore = IERC20(tokenOut).balanceOf(recipient);\n    uint amount = IERC20(tokenIn).balanceOf(address(this));\n\n    {\n      uint priceBefore = getPrice(pool, tokenIn, tokenOut, amount);\n\n      IUniswapV3Pool(pool).swap(\n        recipient,\n        tokenIn == token0,\n        int(amount),\n        tokenIn == token0 ? MIN_SQRT_RATIO : MAX_SQRT_RATIO,\n        abi.encode(SwapCallbackData(tokenIn, amount))\n      );\n\n      uint priceAfter = getPrice(pool, tokenIn, tokenOut, amount);\n      // unreal but better to check\n      require(priceAfter <= priceBefore, \"Price increased\");\n\n      uint priceImpact = (priceBefore - priceAfter) * PRICE_IMPACT_DENOMINATOR / priceBefore;\n      require(priceImpact < priceImpactTolerance, string(abi.encodePacked(\"!PRICE \", Strings.toString(priceImpact))));\n    }\n\n    uint balanceAfter = IERC20(tokenOut).balanceOf(recipient);\n    emit Swap(\n      pool,\n      tokenIn,\n      tokenOut,\n      recipient,\n      priceImpactTolerance,\n      amount,\n      balanceAfter > balanceBefore ? balanceAfter - balanceBefore : 0\n    );\n  }\n\n  // *************************************************************\n  //                     INTERNAL LOGIC\n  // *************************************************************\n\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata _data\n  ) external override {\n    require(amount0Delta > 0 || amount1Delta > 0, \"Wrong callback amount\");\n    SwapCallbackData memory data = abi.decode(_data, (SwapCallbackData));\n    IERC20(data.tokenIn).safeTransfer(msg.sender, data.amount);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-liquidator/contracts/TetuLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./openzeppelin/ReentrancyGuard.sol\";\nimport \"./openzeppelin/SafeERC20.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IERC20Metadata.sol\";\nimport \"./interfaces/ISwapper.sol\";\nimport \"./interfaces/ITetuLiquidator.sol\";\nimport \"./proxy/ControllableV3.sol\";\n\n/// @title Contract for determinate trade routes on-chain and sell any token for any token.\n/// @author belbix\ncontract TetuLiquidator is ReentrancyGuard, ControllableV3, ITetuLiquidator {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant LIQUIDATOR_VERSION = \"1.0.2\";\n  uint public constant ROUTE_LENGTH_MAX = 5;\n\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Liquidity Pools with the highest TVL for given token\n  mapping(address => PoolData) public largestPools;\n  /// @dev Liquidity Pools with the most popular tokens\n  mapping(address => mapping(address => PoolData)) public blueChipsPools;\n  /// @dev Hold blue chips tokens addresses\n  mapping(address => bool) public blueChipsTokens;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Liquidated(address indexed tokenIn, address indexed tokenOut, uint amount);\n  event PoolAdded(PoolData poolData);\n  event PoolRemoved(address token);\n  event BlueChipAdded(PoolData poolData);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n\n  function _onlyOperator() internal view {\n    require(ILiquidatorController(controller()).isOperator(msg.sender), \"DENIED\");\n  }\n\n  // *************************************************************\n  //                   OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev Add pools with largest TVL\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external {\n    _onlyOperator();\n\n    for (uint i = 0; i < _pools.length; i++) {\n      PoolData memory pool = _pools[i];\n      require(largestPools[pool.tokenIn].pool == address(0) || rewrite, \"L: Exist\");\n      largestPools[pool.tokenIn] = pool;\n\n      emit PoolAdded(pool);\n    }\n  }\n\n  /// @dev Remove pool from data\n  function removeLargestPool(address token) external {\n    _onlyOperator();\n\n    delete largestPools[token];\n    emit PoolRemoved(token);\n  }\n\n  /// @dev Add largest pools with the most popular tokens on the current network\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external {\n    _onlyOperator();\n\n    for (uint i = 0; i < _pools.length; i++) {\n      PoolData memory pool = _pools[i];\n      require(blueChipsPools[pool.tokenIn][pool.tokenOut].pool == address(0) || rewrite, \"L: Exist\");\n      // not necessary to check the reversed\n\n      blueChipsPools[pool.tokenIn][pool.tokenOut] = pool;\n      blueChipsPools[pool.tokenOut][pool.tokenIn] = pool;\n      blueChipsTokens[pool.tokenIn] = true;\n      blueChipsTokens[pool.tokenOut] = true;\n\n      emit BlueChipAdded(pool);\n    }\n  }\n\n  function removeBlueChipPool(address tokenIn, address tokenOut) external {\n    _onlyOperator();\n\n    delete blueChipsPools[tokenIn][tokenOut];\n    delete blueChipsTokens[tokenIn];\n    // do not remove tokenOut, assume tha tokenIn is the main target for the removing\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Return price of given tokenIn against tokenOut in decimals of tokenOut.\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view override returns (uint) {\n    (PoolData[] memory route,) = buildRoute(tokenIn, tokenOut);\n    if (route.length == 0) {\n      return 0;\n    }\n    uint price;\n    if (amount == 0) {\n      price = 10 ** IERC20Metadata(tokenIn).decimals();\n    } else {\n      price = amount;\n    }\n    for (uint i; i < route.length; i++) {\n      PoolData memory data = route[i];\n      price = ISwapper(data.swapper).getPrice(data.pool, data.tokenIn, data.tokenOut, price);\n    }\n    return price;\n  }\n\n  /// @dev Return price the first poolData.tokenIn against the last poolData.tokenOut in decimals of tokenOut.\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view override returns (uint) {\n    uint price;\n    if (amount == 0) {\n      price = 10 ** IERC20Metadata(route[0].tokenIn).decimals();\n    } else {\n      price = amount;\n    }\n    for (uint i; i < route.length; i++) {\n      PoolData memory data = route[i];\n      price = ISwapper(data.swapper).getPrice(data.pool, data.tokenIn, data.tokenOut, price);\n    }\n    return price;\n  }\n\n  /// @dev Check possibility liquidate tokenIn for tokenOut.\n  function isRouteExist(address tokenIn, address tokenOut) external view override returns (bool) {\n    (PoolData[] memory route,) = buildRoute(tokenIn, tokenOut);\n    return route.length != 0;\n  }\n\n  // *************************************************************\n  //                        LIQUIDATE\n  // *************************************************************\n\n  /// @dev Sell tokenIn for tokenOut. Assume approve on this contract exist.\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint priceImpactTolerance\n  ) external override {\n\n    (PoolData[] memory route, string memory errorMessage) = buildRoute(tokenIn, tokenOut);\n    if (route.length == 0) {\n      revert(errorMessage);\n    }\n\n    _liquidate(route, amount, priceImpactTolerance);\n  }\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint priceImpactTolerance\n  ) external override {\n    _liquidate(route, amount, priceImpactTolerance);\n  }\n\n  function _liquidate(\n    PoolData[] memory route,\n    uint amount,\n    uint priceImpactTolerance\n  ) internal {\n    require(route.length > 0, \"ZERO_LENGTH\");\n\n    for (uint i; i < route.length; i++) {\n      PoolData memory data = route[i];\n\n      // if it is the first step send tokens to the swapper from the current contract\n      if (i == 0) {\n        IERC20(data.tokenIn).safeTransferFrom(msg.sender, data.swapper, amount);\n      }\n      address recipient;\n      // if it is not the last step of the route send to the next swapper\n      if (i != route.length - 1) {\n        recipient = route[i + 1].swapper;\n      } else {\n        // if it is the last step need to send to the sender\n        recipient = msg.sender;\n      }\n\n      ISwapper(data.swapper).swap(data.pool, data.tokenIn, data.tokenOut, recipient, priceImpactTolerance);\n    }\n\n    emit Liquidated(route[0].tokenIn, route[route.length - 1].tokenOut, amount);\n  }\n\n  // *************************************************************\n  //                        ROUTE\n  // *************************************************************\n\n  /// @dev Build route for liquidation. No reverts inside.\n  /// @return route Array of pools for liquidate tokenIn to tokenOut. Zero length indicate an error.\n  /// @return errorMessage Possible reason why the route was not found. Empty for success routes.\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) public view override returns (\n    PoolData[] memory route,\n    string memory errorMessage\n  )  {\n    route = new PoolData[](ROUTE_LENGTH_MAX);\n\n    // --- BLUE CHIPS for in/out\n\n    // in case that we try to liquidate blue chips use bc lps directly\n    PoolData memory poolDataBC = blueChipsPools[tokenIn][tokenOut];\n    if (poolDataBC.pool != address(0)) {\n      poolDataBC.tokenIn = tokenIn;\n      poolDataBC.tokenOut = tokenOut;\n      route[0] = poolDataBC;\n      return (_cutRoute(route, 1), \"\");\n    }\n\n    // --- POOL for in\n\n    // find the best Pool for token IN\n    PoolData memory poolDataIn = largestPools[tokenIn];\n    if (poolDataIn.pool == address(0)) {\n      return (_cutRoute(route, 0), \"L: Not found pool for tokenIn\");\n    }\n\n    route[0] = poolDataIn;\n    // if the best Pool for token IN a pair with token OUT token we complete the route\n    if (poolDataIn.tokenOut == tokenOut) {\n      return (_cutRoute(route, 1), \"\");\n    }\n\n    // --- BC for POOL_in\n\n    // if we able to swap opposite token to a blue chip it is the cheaper way to liquidate\n    poolDataBC = blueChipsPools[poolDataIn.tokenOut][tokenOut];\n    if (poolDataBC.pool != address(0)) {\n      poolDataBC.tokenIn = poolDataIn.tokenOut;\n      poolDataBC.tokenOut = tokenOut;\n      route[1] = poolDataBC;\n      return (_cutRoute(route, 2), \"\");\n    }\n\n    // --- POOL for out\n\n    // find the largest pool for token out\n    PoolData memory poolDataOut = largestPools[tokenOut];\n\n    if (poolDataOut.pool == address(0)) {\n      return (_cutRoute(route, 0), \"L: Not found pool for tokenOut\");\n    }\n\n    // need to swap directions for tokenOut pool\n    (poolDataOut.tokenIn, poolDataOut.tokenOut) = (poolDataOut.tokenOut, poolDataOut.tokenIn);\n\n    // if the largest pool for tokenOut contains tokenIn it is the best way\n    if (tokenIn == poolDataOut.tokenIn) {\n      route[0] = poolDataOut;\n      return (_cutRoute(route, 1), \"\");\n    }\n\n    // if we can swap between largest pools the route is ended\n    if (poolDataIn.tokenOut == poolDataOut.tokenIn) {\n      route[1] = poolDataOut;\n      return (_cutRoute(route, 2), \"\");\n    }\n\n    // --- BC for POOL_out\n\n    // if we able to swap opposite token to a blue chip it is the cheaper way to liquidate\n    poolDataBC = blueChipsPools[poolDataIn.tokenOut][poolDataOut.tokenIn];\n    if (poolDataBC.pool != address(0)) {\n      poolDataBC.tokenIn = poolDataIn.tokenOut;\n      poolDataBC.tokenOut = poolDataOut.tokenIn;\n      route[1] = poolDataBC;\n      route[2] = poolDataOut;\n      return (_cutRoute(route, 3), \"\");\n    }\n\n    // ------------------------------------------------------------------------\n    //                      RECURSIVE PART\n    // We don't have 1-2 pair routes. Need to find pairs for pairs.\n    // This part could be build as recursion but for reduce complexity and safe gas was not.\n    // ------------------------------------------------------------------------\n\n    // --- POOL2 for in\n\n    PoolData memory poolDataIn2 = largestPools[poolDataIn.tokenOut];\n    if (poolDataIn2.pool == address(0)) {\n      return (_cutRoute(route, 0), \"L: Not found pool for tokenIn2\");\n    }\n\n    route[1] = poolDataIn2;\n    if (poolDataIn2.tokenOut == tokenOut) {\n      return (_cutRoute(route, 2), \"\");\n    }\n\n    if (poolDataIn2.tokenOut == poolDataOut.tokenIn) {\n      route[2] = poolDataOut;\n      return (_cutRoute(route, 3), \"\");\n    }\n\n    // --- BC for POOL2_in\n\n    poolDataBC = blueChipsPools[poolDataIn2.tokenOut][tokenOut];\n    if (poolDataBC.pool != address(0)) {\n      poolDataBC.tokenIn = poolDataIn2.tokenOut;\n      poolDataBC.tokenOut = tokenOut;\n      route[2] = poolDataBC;\n      return (_cutRoute(route, 3), \"\");\n    }\n\n    // --- POOL2 for out\n\n    // find the largest pool for token out\n    PoolData memory poolDataOut2 = largestPools[poolDataOut.tokenIn];\n    if (poolDataOut2.pool == address(0)) {\n      return (_cutRoute(route, 0), \"L: Not found pool for tokenOut2\");\n    }\n\n    // need to swap directions for tokenOut2 pool\n    (poolDataOut2.tokenIn, poolDataOut2.tokenOut) = (poolDataOut2.tokenOut, poolDataOut2.tokenIn);\n\n    // if we can swap between largest pools the route is ended\n    if (poolDataIn.tokenOut == poolDataOut2.tokenIn) {\n      route[1] = poolDataOut2;\n      route[2] = poolDataOut;\n      return (_cutRoute(route, 3), \"\");\n    }\n\n    if (poolDataIn2.tokenOut == poolDataOut2.tokenIn) {\n      route[2] = poolDataOut2;\n      route[3] = poolDataOut;\n      return (_cutRoute(route, 4), \"\");\n    }\n\n    // --- BC for POOL2_out\n\n    // token OUT pool can be paired with BC pool with token IN\n    poolDataBC = blueChipsPools[tokenIn][poolDataOut2.tokenIn];\n    if (poolDataBC.pool != address(0)) {\n      poolDataBC.tokenIn = tokenIn;\n      poolDataBC.tokenOut = poolDataOut2.tokenIn;\n      route[0] = poolDataBC;\n      route[1] = poolDataOut2;\n      route[2] = poolDataOut;\n      return (_cutRoute(route, 3), \"\");\n    }\n\n    poolDataBC = blueChipsPools[poolDataIn.tokenOut][poolDataOut2.tokenIn];\n    if (poolDataBC.pool != address(0)) {\n      poolDataBC.tokenIn = poolDataIn.tokenOut;\n      poolDataBC.tokenOut = poolDataOut2.tokenIn;\n      route[1] = poolDataBC;\n      route[2] = poolDataOut2;\n      route[3] = poolDataOut;\n      return (_cutRoute(route, 4), \"\");\n    }\n\n    poolDataBC = blueChipsPools[poolDataIn2.tokenOut][poolDataOut2.tokenIn];\n    if (poolDataBC.pool != address(0)) {\n      poolDataBC.tokenIn = poolDataIn2.tokenOut;\n      poolDataBC.tokenOut = poolDataOut2.tokenIn;\n      route[2] = poolDataBC;\n      route[3] = poolDataOut2;\n      route[4] = poolDataOut;\n      return (_cutRoute(route, 5), \"\");\n    }\n\n    // We are not handling other cases such as:\n    // - If a token has liquidity with specific token\n    //   and this token also has liquidity only with specific token.\n    //   This case never exist but could be implemented if requires.\n    return (_cutRoute(route, 0), \"L: Liquidation path not found\");\n  }\n\n  function _cutRoute(PoolData[] memory route, uint length) internal pure returns (PoolData[] memory) {\n    PoolData[] memory result = new PoolData[](length);\n    for (uint i; i < length; ++i) {\n      result[i] = route[i];\n    }\n    return result;\n  }\n\n}\n"
    },
    "contracts/helpers/ERC20Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\n/// @title Contract with helper functions.\n/// @author bogdoslav\ncontract ERC20Helpers {\n  using SafeERC20 for IERC20;\n\n  function _balance(address token) internal view returns (uint) {\n    return IERC20(token).balanceOf(address(this));\n  }\n\n  /// @notice Should be used for third-party pools\n  function _safeApprove(address token, uint amount, address spender) internal {\n    IERC20(token).safeApprove(spender, 0);\n    IERC20(token).safeApprove(spender, amount);\n  }\n}\n"
    },
    "contracts/integrations/aave/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice A source of asset price for AAVE3 price oracle\n/// @dev Restored from https://polygonscan.com/address/0xb023e699F5a33916Ea823A16485e259257cA8Bd1#code\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}"
    },
    "contracts/integrations/aave/IAave3PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Restored from 0x69FA688f1Dc47d4B5d8029D5a35FB7a548310654 (events were removed)\ninterface IAave3PriceOracle {\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (address);\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   **/\n  function BASE_CURRENCY() external view returns (address);\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   **/\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   **/\n  function getAssetPrice(address asset) external view returns (uint256);\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] memory assets) external view returns (uint256[] memory);\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n\n  function setAssetSources(address[] memory assets, address[] memory sources) external;\n\n  function setFallbackOracle(address fallbackOracle) external;\n}\n"
    },
    "contracts/integrations/balancer/IBalancerBoostedAavePool.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"./IPoolSwapStructs.sol\";\n\n/// @notice Restored from Balancer Aave Boosted Pool (DAI) (bb-am-DAI) https://polygonscan.com/address/0x178E029173417b1F9C8bC16DCeC6f697bC323746\ninterface IBalancerBoostedAavePool {\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n  event PausedStateChanged(bool paused);\n  event RecoveryModeStateChanged(bool enabled);\n  event SwapFeePercentageChanged(uint256 swapFeePercentage);\n  event TargetsSet(address indexed token, uint256 lowerTarget, uint256 upperTarget);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function decimals() external view returns (uint8);\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (bool);\n\n  function disableRecoveryMode() external;\n\n  function enableRecoveryMode() external;\n\n  function getActionId(bytes4 selector) external view returns (bytes32);\n\n  function getAuthorizer() external view returns (address);\n\n  function getBptIndex() external view returns (uint256);\n\n  function getDomainSeparator() external view returns (bytes32);\n\n  function getMainIndex() external view returns (uint256);\n\n  function getMainToken() external view returns (address);\n\n  function getNextNonce(address account) external view returns (uint256);\n\n  function getOwner() external view returns (address);\n\n  function getPausedState() external view returns (\n    bool paused,\n    uint256 pauseWindowEndTime,\n    uint256 bufferPeriodEndTime\n  );\n\n  function getPoolId() external view returns (bytes32);\n\n  function getProtocolFeesCollector() external view returns (address);\n\n  function getRate() external view returns (uint256);\n\n  function getScalingFactors() external view returns (uint256[] memory);\n\n  function getSwapFeePercentage() external view returns (uint256);\n\n  function getTargets() external view returns (uint256 lowerTarget, uint256 upperTarget);\n\n  function getVault() external view returns (address);\n\n  function getVirtualSupply() external view returns (uint256);\n\n  function getWrappedIndex() external view returns (uint256);\n\n  function getWrappedToken() external view returns (address);\n\n  /**\n   * @notice Return the conversion rate between the wrapped and main tokens.\n     * @dev This is an 18-decimal fixed point value.\n     */\n  function getWrappedTokenRate() external view returns (uint256);\n\n  function inRecoveryMode() external view returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n  function initialize() external;\n\n  function name() external view returns (string memory);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function onExitPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onJoinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onSwap(\n    IPoolSwapStructs.SwapRequest memory request,\n    uint256[] memory balances,\n    uint256 indexIn,\n    uint256 indexOut\n  ) external returns (uint256);\n\n  function pause() external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function setAssetManagerPoolConfig(address token, bytes memory poolConfig) external;\n\n  function setSwapFeePercentage(uint256 swapFeePercentage) external;\n\n  function setTargets(uint256 newLowerTarget, uint256 newUpperTarget) external;\n\n  function symbol() external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  function unpause() external;\n}\n\ninterface AaveLinearPool {\n  struct ConstructorArgs {\n    address vault;\n    string name;\n    string symbol;\n    address mainToken;\n    address wrappedToken;\n    address assetManager;\n    uint256 upperTarget;\n    uint256 swapFeePercentage;\n    uint256 pauseWindowDuration;\n    uint256 bufferPeriodDuration;\n    address owner;\n  }\n}\n"
    },
    "contracts/integrations/balancer/IBalancerBoostedAaveStablePool.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"./IPoolSwapStructs.sol\";\n\n/// @notice Restored from https://polygonscan.com/address/0x48e6b98ef6329f8f0a30ebb8c7c960330d648085\ninterface IBalancerBoostedAaveStablePool {\n  event AmpUpdateStarted(\n    uint256 startValue,\n    uint256 endValue,\n    uint256 startTime,\n    uint256 endTime\n  );\n  event AmpUpdateStopped(uint256 currentValue);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n  event PausedStateChanged(bool paused);\n  event ProtocolFeePercentageCacheUpdated(\n    uint256 indexed feeType,\n    uint256 protocolFeePercentage\n  );\n  event RecoveryModeStateChanged(bool enabled);\n  event SwapFeePercentageChanged(uint256 swapFeePercentage);\n  event TokenRateCacheUpdated(uint256 indexed tokenIndex, uint256 rate);\n  event TokenRateProviderSet(\n    uint256 indexed tokenIndex,\n    address indexed provider,\n    uint256 cacheDuration\n  );\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL() external view returns (uint256);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  function balanceOf(address account) external view returns (uint256);\n\n  function decimals() external view returns (uint8);\n\n  function decreaseAllowance(address spender, uint256 amount) external returns (bool);\n\n  function disableRecoveryMode() external;\n\n  function enableRecoveryMode() external;\n\n  function getActionId(bytes4 selector) external view returns (bytes32);\n\n  /**\n   * @dev Returns the effective BPT supply.\n     *\n     * In other pools, this would be the same as `totalSupply`, but there are two key differences here:\n     *  - this pool pre-mints BPT and holds it in the Vault as a token, and as such we need to subtract the Vault's\n     *    balance to get the total \"circulating supply\". This is called the 'virtualSupply'.\n     *  - the Pool owes debt to the Protocol in the form of unminted BPT, which will be minted immediately before the\n     *    next join or exit. We need to take these into account since, even if they don't yet exist, they will\n     *    effectively be included in any Pool operation that involves BPT.\n     *\n     * In the vast majority of cases, this function should be used instead of `totalSupply()`.\n     */\n  function getActualSupply() external view returns (uint256);\n\n  function getAmplificationParameter() external view returns (\n    uint256 value,\n    bool isUpdating,\n    uint256 precision\n  );\n\n  function getAuthorizer() external view returns (address);\n\n  function getBptIndex() external view returns (uint256);\n\n  function getDomainSeparator() external view returns (bytes32);\n\n  function getLastJoinExitData() external view returns (\n    uint256 lastJoinExitAmplification,\n    uint256 lastPostJoinExitInvariant\n  );\n\n  function getMinimumBpt() external pure returns (uint256);\n\n  function getNextNonce(address account) external view returns (uint256);\n\n  function getOwner() external view returns (address);\n\n  function getPausedState() external view returns (\n    bool paused,\n    uint256 pauseWindowEndTime,\n    uint256 bufferPeriodEndTime\n  );\n\n  function getPoolId() external view returns (bytes32);\n\n  function getProtocolFeePercentageCache(uint256 feeType) external view returns (uint256);\n\n  function getProtocolFeesCollector() external view returns (address);\n\n  function getProtocolSwapFeeDelegation() external view returns (bool);\n\n  function getRate() external view returns (uint256);\n\n  function getRateProviders() external view returns (address[] memory);\n\n  function getScalingFactors() external view returns (uint256[] memory);\n\n  function getSwapFeePercentage() external view returns (uint256);\n\n  function getTokenRate(address token) external view returns (uint256);\n\n  function getTokenRateCache(address token) external view returns (\n    uint256 rate,\n    uint256 oldRate,\n    uint256 duration,\n    uint256 expires\n  );\n\n  function getVault() external view returns (address);\n\n  function inRecoveryMode() external view returns (bool);\n\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n  function isTokenExemptFromYieldProtocolFee(address token) external view returns (bool);\n\n  function name() external view returns (string memory);\n\n  function nonces(address owner) external view returns (uint256);\n\n  function onExitPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onJoinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onSwap(\n    IPoolSwapStructs.SwapRequest memory swapRequest,\n    uint256[] memory balances,\n    uint256 indexIn,\n    uint256 indexOut\n  ) external returns (uint256);\n\n  function pause() external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function setAssetManagerPoolConfig(address token, bytes memory poolConfig) external;\n\n  function setSwapFeePercentage(uint256 swapFeePercentage) external;\n\n  function setTokenRateCacheDuration(address token, uint256 duration) external;\n\n  function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external;\n\n  function stopAmplificationParameterUpdate() external;\n\n  function symbol() external view returns (string memory);\n\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  function unpause() external;\n\n  function updateProtocolFeePercentageCache() external;\n\n  function updateTokenRateCache(address token) external;\n}\n\ninterface ComposableStablePool {\n  struct NewPoolParams {\n    address vault;\n    address protocolFeeProvider;\n    string name;\n    string symbol;\n    address[] tokens;\n    address[] rateProviders;\n    uint256[] tokenRateCacheDurations;\n    bool[] exemptFromYieldProtocolFeeFlags;\n    uint256 amplificationParameter;\n    uint256 swapFeePercentage;\n    uint256 pauseWindowDuration;\n    uint256 bufferPeriodDuration;\n    address owner;\n  }\n}\n"
    },
    "contracts/integrations/balancer/IBalancerGauge.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IBalancerGauge {\n  function decimals() external view returns (uint256);\n\n  function version() external view returns (string memory);\n\n  function last_claim() external view returns (uint256);\n\n  function claimed_reward(address _addr, address _token) external view returns (uint256);\n\n  function claimable_reward(address _addr, address _token) external view returns (uint256);\n\n  function claimable_reward_write(address _addr, address _token) external returns (uint256);\n\n  function reward_contract() external view returns (address);\n\n  function reward_data(address _token) external view returns (\n    address token,\n    address distributor,\n    uint256 period_finish,\n    uint256 rate,\n    uint256 last_update,\n    uint256 integral\n  );\n\n  function reward_tokens(uint256 arg0) external view returns (address);\n\n  function reward_balances(address arg0) external view returns (uint256);\n\n  function rewards_receiver(address arg0) external view returns (address);\n\n  function reward_integral(address arg0) external view returns (uint256);\n\n  function reward_integral_for(address arg0, address arg1) external view returns (uint256);\n\n  function set_rewards_receiver(address _receiver) external;\n\n  function set_rewards(\n    address _reward_contract,\n    bytes32 _claim_sig,\n    address[8] memory _reward_tokens\n  ) external;\n\n  function claim_rewards() external;\n\n  function claim_rewards(address _addr) external;\n\n  function claim_rewards(address _addr, address _receiver) external;\n\n  function deposit(uint256 _value) external;\n\n  function deposit(uint256 _value, address _addr) external;\n\n  function deposit(uint256 _value, address _addr, bool _claim_rewards) external;\n\n  function withdraw(uint256 _value) external;\n\n  function withdraw(uint256 _value, bool _claim_rewards) external;\n\n  function transfer(address _to, uint256 _value) external returns (bool);\n\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  function approve(address _spender, uint256 _value) external returns (bool);\n\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _value,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (bool);\n\n  function increaseAllowance(address _spender, uint256 _added_value) external returns (bool);\n\n  function decreaseAllowance(address _spender, uint256 _subtracted_value) external returns (bool);\n\n  function initialize(\n    address _lp_token,\n    address _reward_contract,\n    bytes32 _claim_sig\n  ) external;\n\n  function lp_token() external view returns (address);\n\n  function balanceOf(address arg0) external view returns (uint256);\n\n  function totalSupply() external view returns (uint256);\n\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function nonces(address arg0) external view returns (uint256);\n\n  function claim_sig() external view returns (bytes memory);\n}\n"
    },
    "contracts/integrations/balancer/IBalancerHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IBVault.sol\";\n\ninterface IBalancerHelper {\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    IBVault.ExitPoolRequest memory request\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    IBVault.JoinPoolRequest memory request\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function vault() external view returns (address);\n}\n"
    },
    "contracts/integrations/balancer/IBVault.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\n\ninterface IAsset {\n}\n\ninterface IBVault {\n  // Internal Balance\n  //\n  // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n  // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n  // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n  // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n  //\n  // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n  // operations of different kinds, with different senders and recipients, at once.\n\n  /**\n   * @dev Returns `user`'s Internal Balance for a set of tokens.\n     */\n  function getInternalBalance(address user, IERC20[] calldata tokens) external view returns (uint256[] memory);\n\n  /**\n   * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n  function manageUserBalance(UserBalanceOp[] calldata ops) external payable;\n\n  /**\n   * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n  struct UserBalanceOp {\n    UserBalanceOpKind kind;\n    IAsset asset;\n    uint256 amount;\n    address sender;\n    address payable recipient;\n  }\n\n  // There are four possible operations in `manageUserBalance`:\n  //\n  // - DEPOSIT_INTERNAL\n  // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n  // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n  // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n  // relevant for relayers).\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - WITHDRAW_INTERNAL\n  // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n  // it to the recipient as ETH.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_INTERNAL\n  // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_EXTERNAL\n  // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n  // relayers, as it lets them reuse a user's Vault allowance.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `ExternalBalanceTransfer` event.\n\n  enum UserBalanceOpKind {DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL}\n\n  /**\n   * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n  event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n  /**\n   * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n  event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n  // Pools\n  //\n  // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n  // functionality:\n  //\n  //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n  // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n  // which increase with the number of registered tokens.\n  //\n  //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n  // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n  // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n  // independent of the number of registered tokens.\n  //\n  //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n  // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n  enum PoolSpecialization {GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN}\n\n  /**\n   * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n  function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n  /**\n   * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n  event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n  /**\n   * @dev Returns a Pool's contract address and specialization setting.\n     */\n  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n  /**\n   * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n  function registerTokens(\n    bytes32 poolId,\n    IERC20[] calldata tokens,\n    address[] calldata assetManagers\n  ) external;\n\n  /**\n   * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n  event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n  /**\n   * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n  function deregisterTokens(bytes32 poolId, IERC20[] calldata tokens) external;\n\n  /**\n   * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n  event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n  /**\n   * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n  function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n  external\n  view\n  returns (\n    uint256 cash,\n    uint256 managed,\n    uint256 lastChangeBlock,\n    address assetManager\n  );\n\n  /**\n   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n  function getPoolTokens(bytes32 poolId)\n  external\n  view\n  returns (\n    IERC20[] memory tokens,\n    uint256[] memory balances,\n    uint256 lastChangeBlock\n  );\n\n  /**\n   * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     *\n     * See https://dev.balancer.fi/resources/joins-and-exits/pool-joins\n     */\n  function joinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    JoinPoolRequest calldata request\n  ) external payable;\n\n  enum JoinKind {INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT}\n\n  /// @notice WeightedPool ExitKinds\n  enum ExitKind {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT}\n  /// @notice Composable Stable V2 ExitKinds\n  enum ExitKindComposableStable {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT, EXACT_BPT_IN_FOR_ALL_TOKENS_OUT}\n\n\n  struct JoinPoolRequest {\n    IAsset[] assets;\n    uint256[] maxAmountsIn;\n    bytes userData;\n    bool fromInternalBalance;\n  }\n\n  /**\n   * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n  function exitPool(\n    bytes32 poolId,\n    address sender,\n    address payable recipient,\n    ExitPoolRequest calldata request\n  ) external;\n\n  struct ExitPoolRequest {\n    IAsset[] assets;\n    uint256[] minAmountsOut;\n    bytes userData;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n  event PoolBalanceChanged(\n    bytes32 indexed poolId,\n    address indexed liquidityProvider,\n    IERC20[] tokens,\n    int256[] deltas,\n    uint256[] protocolFeeAmounts\n  );\n\n  enum PoolBalanceChangeKind {JOIN, EXIT}\n\n  // Swaps\n  //\n  // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n  // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n  // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n  //\n  // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n  // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n  // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n  // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n  // individual swaps.\n  //\n  // There are two swap kinds:\n  //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n  // `onSwap` hook) the amount of tokens out (to send to the recipient).\n  //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n  // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n  //\n  // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n  // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n  // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n  // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n  // the final intended token.\n  //\n  // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n  // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n  // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n  // much less gas than they would otherwise.\n  //\n  // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n  // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n  // updating the Pool's internal accounting).\n  //\n  // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n  // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n  // minimum amount of tokens to receive (by passing a negative value) is specified.\n  //\n  // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n  // this point in time (e.g. if the transaction failed to be included in a block promptly).\n  //\n  // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n  // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n  // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n  // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n  //\n  // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n  enum SwapKind {GIVEN_IN, GIVEN_OUT}\n\n  /**\n   * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n  function swap(\n    SingleSwap calldata singleSwap,\n    FundManagement calldata funds,\n    uint256 limit,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  /**\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct SingleSwap {\n    bytes32 poolId;\n    SwapKind kind;\n    IAsset assetIn;\n    IAsset assetOut;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n  function batchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds,\n    int256[] calldata limits,\n    uint256 deadline\n  ) external payable returns (int256[] memory);\n\n  /**\n   * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct BatchSwapStep {\n    bytes32 poolId;\n    uint256 assetInIndex;\n    uint256 assetOutIndex;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n  event Swap(\n    bytes32 indexed poolId,\n    IERC20 indexed tokenIn,\n    IERC20 indexed tokenOut,\n    uint256 amountIn,\n    uint256 amountOut\n  );\n\n  /**\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n  struct FundManagement {\n    address sender;\n    bool fromInternalBalance;\n    address payable recipient;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n  function queryBatchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds\n  ) external returns (int256[] memory assetDeltas);\n\n  // BasePool.sol\n\n  /**\n* @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\n     *\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\n     * data, such as the protocol swap fee percentage and Pool balances.\n     *\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\n     * explicitly use eth_call instead of eth_sendTransaction.\n     */\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n\n}\n"
    },
    "contracts/integrations/balancer/IChildChainLiquidityGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\n/// @notice ChildChainLiquidityGaugeFactory, restored for 0x3b8cA519122CdD8efb272b0D3085453404B25bD0\n/// @dev See https://dev.balancer.fi/resources/vebal-and-gauges/gauges\ninterface IChildChainLiquidityGaugeFactory {\n  event RewardsOnlyGaugeCreated(\n    address indexed gauge,\n    address indexed pool,\n    address streamer\n  );\n\n  function create(address pool) external returns (address);\n\n  function getChildChainStreamerImplementation() external view returns (address);\n\n  function getGaugeImplementation() external view returns (address);\n\n  function getGaugePool(address gauge) external view returns (address);\n\n  function getGaugeStreamer(address gauge) external view returns (address);\n\n  function getPoolGauge(address pool) external view returns (address);\n\n  function getPoolStreamer(address pool) external view returns (address);\n\n  function isGaugeFromFactory(address gauge) external view returns (bool);\n\n  function isStreamerFromFactory(address streamer) external view returns (bool);\n}\n\n"
    },
    "contracts/integrations/balancer/IPoolSwapStructs.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IPoolSwapStructs {\n  struct SwapRequest {\n    uint8 kind;\n    address tokenIn;\n    address tokenOut;\n    uint256 amount;\n    bytes32 poolId;\n    uint256 lastChangeBlock;\n    address from;\n    address to;\n    bytes userData;\n  }\n}"
    },
    "contracts/integrations/balancer/IRateProvider.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IRateProvider {\n  /**\n   * @dev Returns an 18 decimal fixed point number that is the exchange rate of the token to some other underlying\n     * token. The meaning of this rate depends on the context.\n     */\n  function getRate() external view returns (uint256);\n}\n"
    },
    "contracts/integrations/IWmatic.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0;\n\ninterface IWmatic {\n\n  function balanceOf(address target) external view returns (uint256);\n\n  function deposit() external payable;\n\n  function withdraw(uint256 wad) external;\n\n  function totalSupply() external view returns (uint256);\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n\n  function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n\n}\n"
    },
    "contracts/integrations/tetu-v1/ISmartVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISmartVault {\n  function DEPOSIT_FEE_DENOMINATOR() external view returns (uint256);\n\n  function LOCK_PENALTY_DENOMINATOR() external view returns (uint256);\n\n  function TO_INVEST_DENOMINATOR() external view returns (uint256);\n\n  function VERSION() external view returns (string memory);\n\n  function active() external view returns (bool);\n\n  function addRewardToken(address rt) external;\n\n  function alwaysInvest() external view returns (bool);\n\n  function availableToInvestOut() external view returns (uint256);\n\n  function changeActivityStatus(bool _active) external;\n\n  function changeAlwaysInvest(bool _active) external;\n\n  function changeDoHardWorkOnInvest(bool _active) external;\n\n  function changePpfsDecreaseAllowed(bool _value) external;\n\n  function changeProtectionMode(bool _active) external;\n\n  function deposit(uint256 amount) external;\n\n  function depositAndInvest(uint256 amount) external;\n\n  function depositFeeNumerator() external view returns (uint256);\n\n  function depositFor(uint256 amount, address holder) external;\n\n  function disableLock() external;\n\n  function doHardWork() external;\n\n  function doHardWorkOnInvest() external view returns (bool);\n\n  function duration() external view returns (uint256);\n\n  function earned(address rt, address account) external view returns (uint256);\n\n  function earnedWithBoost(address rt, address account) external view returns (uint256);\n\n  function exit() external;\n\n  function getAllRewards() external;\n\n  function getAllRewardsAndRedirect(address owner) external;\n\n  function getPricePerFullShare() external view returns (uint256);\n\n  function getReward(address rt) external;\n\n  function getRewardTokenIndex(address rt) external view returns (uint256);\n\n  function initializeSmartVault(\n    string memory _name,\n    string memory _symbol,\n    address _controller,\n    address __underlying,\n    uint256 _duration,\n    bool _lockAllowed,\n    address _rewardToken,\n    uint256 _depositFee\n  ) external;\n\n  function lastTimeRewardApplicable(address rt) external view returns (uint256);\n\n  function lastUpdateTimeForToken(address) external view returns (uint256);\n\n  function lockAllowed() external view returns (bool);\n\n  function lockPenalty() external view returns (uint256);\n\n  function notifyRewardWithoutPeriodChange(address _rewardToken, uint256 _amount) external;\n\n  function notifyTargetRewardAmount(address _rewardToken, uint256 amount) external;\n\n  function overrideName(string memory value) external;\n\n  function overrideSymbol(string memory value) external;\n\n  function periodFinishForToken(address) external view returns (uint256);\n\n  function ppfsDecreaseAllowed() external view returns (bool);\n\n  function protectionMode() external view returns (bool);\n\n  function rebalance() external;\n\n  function removeRewardToken(address rt) external;\n\n  function rewardPerToken(address rt) external view returns (uint256);\n\n  function rewardPerTokenStoredForToken(address) external view returns (uint256);\n\n  function rewardRateForToken(address) external view returns (uint256);\n\n  function rewardTokens() external view returns (address[] memory);\n\n  function rewardTokensLength() external view returns (uint256);\n\n  function rewardsForToken(address, address) external view returns (uint256);\n\n  function setLockPenalty(uint256 _value) external;\n\n  function setRewardsRedirect(address owner, address receiver) external;\n\n  function setLockPeriod(uint256 _value) external;\n\n  function setStrategy(address newStrategy) external;\n\n  function setToInvest(uint256 _value) external;\n\n  function stop() external;\n\n  function strategy() external view returns (address);\n\n  function toInvest() external view returns (uint256);\n\n  function underlying() external view returns (address);\n\n  function underlyingBalanceInVault() external view returns (uint256);\n\n  function underlyingBalanceWithInvestment() external view returns (uint256);\n\n  function underlyingBalanceWithInvestmentForHolder(address holder) external view returns (uint256);\n\n  function underlyingUnit() external view returns (uint256);\n\n  function userBoostTs(address) external view returns (uint256);\n\n  function userLastDepositTs(address) external view returns (uint256);\n\n  function userLastWithdrawTs(address) external view returns (uint256);\n\n  function userLockTs(address) external view returns (uint256);\n\n  function userRewardPerTokenPaidForToken(address, address) external view returns (uint256);\n\n  function withdraw(uint256 numberOfShares) external;\n\n  function withdrawAllToVault() external;\n\n  function getAllRewardsFor(address rewardsReceiver) external;\n\n  function lockPeriod() external view returns (uint256);\n}\n"
    },
    "contracts/integrations/tetu-v1/ITetuV1Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ITetuV1Controller {\n\n\n  function VERSION() external view returns (string memory);\n\n  function addHardWorker(address _worker) external;\n\n  function addStrategiesToSplitter(\n    address _splitter,\n    address[] memory _strategies\n  ) external;\n\n  function addStrategy(address _strategy) external;\n\n  function addVaultsAndStrategies(\n    address[] memory _vaults,\n    address[] memory _strategies\n  ) external;\n\n  function announcer() external view returns (address);\n\n  function bookkeeper() external view returns (address);\n\n  function changeWhiteListStatus(address[] memory _targets, bool status)\n  external;\n\n  function controllerTokenMove(\n    address _recipient,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function dao() external view returns (address);\n\n  function distributor() external view returns (address);\n\n  function doHardWork(address _vault) external;\n\n  function feeRewardForwarder() external view returns (address);\n\n  function fund() external view returns (address);\n\n  function fundDenominator() external view returns (uint256);\n\n  function fundKeeperTokenMove(\n    address _fund,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function fundNumerator() external view returns (uint256);\n\n  function fundToken() external view returns (address);\n\n  function governance() external view returns (address);\n\n  function hardWorkers(address) external view returns (bool);\n\n  function initialize() external;\n\n  function isAllowedUser(address _adr) external view returns (bool);\n\n  function isDao(address _adr) external view returns (bool);\n\n  function isHardWorker(address _adr) external view returns (bool);\n\n  function isPoorRewardConsumer(address _adr) external view returns (bool);\n\n  function isRewardDistributor(address _adr) external view returns (bool);\n\n  function isValidStrategy(address _strategy) external view returns (bool);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  function mintAndDistribute(uint256 totalAmount, bool mintAllAvailable)\n  external;\n\n  function mintHelper() external view returns (address);\n\n  function psDenominator() external view returns (uint256);\n\n  function psNumerator() external view returns (uint256);\n\n  function psVault() external view returns (address);\n\n  function pureRewardConsumers(address) external view returns (bool);\n\n  function rebalance(address _strategy) external;\n\n  function removeHardWorker(address _worker) external;\n\n  function rewardDistribution(address) external view returns (bool);\n\n  function rewardToken() external view returns (address);\n\n  function setAnnouncer(address _newValue) external;\n\n  function setBookkeeper(address newValue) external;\n\n  function setDao(address newValue) external;\n\n  function setDistributor(address _distributor) external;\n\n  function setFeeRewardForwarder(address _feeRewardForwarder) external;\n\n  function setFund(address _newValue) external;\n\n  function setFundNumeratorDenominator(uint256 numerator, uint256 denominator)\n  external;\n\n  function setFundToken(address _newValue) external;\n\n  function setGovernance(address newValue) external;\n\n  function setMintHelper(address _newValue) external;\n\n  function setPSNumeratorDenominator(uint256 numerator, uint256 denominator)\n  external;\n\n  function setPsVault(address _newValue) external;\n\n  function setPureRewardConsumers(address[] memory _targets, bool _flag)\n  external;\n\n  function setRewardDistribution(\n    address[] memory _newRewardDistribution,\n    bool _flag\n  ) external;\n\n  function setRewardToken(address _newValue) external;\n\n  function setVaultController(address _newValue) external;\n\n  function setVaultStrategyBatch(\n    address[] memory _vaults,\n    address[] memory _strategies\n  ) external;\n\n  function strategies(address) external view returns (bool);\n\n  function strategyTokenMove(\n    address _strategy,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function upgradeTetuProxyBatch(\n    address[] memory _contracts,\n    address[] memory _implementations\n  ) external;\n\n  function vaultController() external view returns (address);\n\n  function vaults(address) external view returns (bool);\n\n  function whiteList(address) external view returns (bool);\n}\n"
    },
    "contracts/integrations/uniswap/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n  uint8 internal constant RESOLUTION = 96;\n  uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/integrations/uniswap/FullMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(\n    uint256 a,\n    uint256 b,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = a * b\n    // Compute the product mod 2**256 and mod 2**256 - 1\n    // then use the Chinese Remainder Theorem to reconstruct\n    // the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2**256 + prod0\n    uint256 prod0;\n    // Least significant 256 bits of the product\n    uint256 prod1;\n    // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(a, b, not(0))\n      prod0 := mul(a, b)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division\n    if (prod1 == 0) {\n      require(denominator > 0);\n      assembly {\n        result := div(prod0, denominator)\n      }\n      return result;\n    }\n\n    // Make sure the result is less than 2**256.\n    // Also prevents denominator == 0\n    require(denominator > prod1);\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0]\n    // Compute remainder using mulmod\n    uint256 remainder;\n    assembly {\n      remainder := mulmod(a, b, denominator)\n    }\n    // Subtract 256 bit number from 512 bit number\n    assembly {\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator\n    // Compute largest power of two divisor of denominator.\n    // Always >= 1.\n    // EDIT for 0.8 compatibility:\n    // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint256\n    uint256 twos = denominator & (~denominator + 1);\n\n    // Divide denominator by power of two\n    assembly {\n      denominator := div(denominator, twos)\n    }\n\n    // Divide [prod1 prod0] by the factors of two\n    assembly {\n      prod0 := div(prod0, twos)\n    }\n    // Shift in bits from prod1 into prod0. For this we need\n    // to flip `twos` such that it is 2**256 / twos.\n    // If twos is zero, then it becomes one\n    assembly {\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2**256\n    // Now that denominator is an odd number, it has an inverse\n    // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n    // Compute the inverse by starting with a seed that is correct\n    // correct for four bits. That is, denominator * inv = 1 mod 2**4\n    uint256 inv = (3 * denominator) ^ 2;\n    // Now use Newton-Raphson iteration to improve the precision.\n    // Thanks to Hensel's lifting lemma, this also works in modular\n    // arithmetic, doubling the correct bits in each step.\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**8\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**16\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**32\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**64\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**128\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**256\n\n    // Because the division is now exact we can divide by multiplying\n    // with the modular inverse of denominator. This will give us the\n    // correct result modulo 2**256. Since the precoditions guarantee\n    // that the outcome is less than 2**256, this is the final result.\n    // We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inv;\n    return result;\n  }\n  }\n\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(\n    uint256 a,\n    uint256 b,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n    result = mulDiv(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      require(result < type(uint256).max);\n      result++;\n    }\n  }\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n  function feeTo() external view returns (address);\n\n  function feeToSetter() external view returns (address);\n\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n\n  function allPairs(uint) external view returns (address pair);\n\n  function allPairsLength() external view returns (uint);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n\n  function setFeeTo(address) external;\n\n  function setFeeToSetter(address) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  function name() external pure returns (string memory);\n\n  function symbol() external pure returns (string memory);\n\n  function decimals() external pure returns (uint8);\n\n  function totalSupply() external view returns (uint);\n\n  function balanceOf(address owner) external view returns (uint);\n\n  function allowance(address owner, address spender) external view returns (uint);\n\n  function approve(address spender, uint value) external returns (bool);\n\n  function transfer(address to, uint value) external returns (bool);\n\n  function transferFrom(address from, address to, uint value) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n\n  function nonces(address owner) external view returns (uint);\n\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n  event Mint(address indexed sender, uint amount0, uint amount1);\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint amount0In,\n    uint amount1In,\n    uint amount0Out,\n    uint amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\n\n  function factory() external view returns (address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n\n  function price0CumulativeLast() external view returns (uint);\n\n  function price1CumulativeLast() external view returns (uint);\n\n  function kLast() external view returns (uint);\n\n  function mint(address to) external returns (uint liquidity);\n\n  function burn(address to) external returns (uint amount0, uint amount1);\n\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\n  function skim(address to) external;\n\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IUniswapV2Router01 {\n  function factory() external pure returns (address);\n\n  function WETH() external pure returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountA, uint amountB, uint liquidity);\n\n  function addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountA, uint amountB);\n\n  function removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountToken, uint amountETH);\n\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  ) external returns (uint amountA, uint amountB);\n\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  ) external returns (uint amountToken, uint amountETH);\n\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  payable\n  returns (uint[] memory amounts);\n\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n  external\n  returns (uint[] memory amounts);\n\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  returns (uint[] memory amounts);\n\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n  external\n  payable\n  returns (uint[] memory amounts);\n\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport './IUniswapV2Router01.sol';\n\n/// @notice Roter release 2, currently recommended version\n/// @dev https://docs.quickswap.exchange/reference/smart-contracts/router02\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountETH);\n\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  ) external returns (uint amountETH);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable;\n\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n  /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n  /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n  /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n  function uniswapV3MintCallback(\n    uint256 amount0Owed,\n    uint256 amount1Owed,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\nimport './IUniswapV3PoolImmutables.sol';\nimport './IUniswapV3PoolState.sol';\nimport './IUniswapV3PoolDerivedState.sol';\nimport './IUniswapV3PoolActions.sol';\nimport './IUniswapV3PoolOwnerActions.sol';\nimport './IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\nIUniswapV3PoolImmutables,\nIUniswapV3PoolState,\nIUniswapV3PoolDerivedState,\nIUniswapV3PoolActions,\nIUniswapV3PoolOwnerActions,\nIUniswapV3PoolEvents\n{}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n  /// @notice Sets the initial price for the pool\n  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n  /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n  function initialize(uint160 sqrtPriceX96) external;\n\n  /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n  /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n  /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n  /// @param recipient The address for which the liquidity will be created\n  /// @param tickLower The lower tick of the position in which to add liquidity\n  /// @param tickUpper The upper tick of the position in which to add liquidity\n  /// @param amount The amount of liquidity to mint\n  /// @param data Any data that should be passed through to the callback\n  /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount,\n    bytes calldata data\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Collects tokens owed to a position\n  /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n  /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n  /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n  /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n  /// @param recipient The address which should receive the fees collected\n  /// @param tickLower The lower tick of the position for which to collect fees\n  /// @param tickUpper The upper tick of the position for which to collect fees\n  /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n  /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n  /// @return amount0 The amount of fees collected in token0\n  /// @return amount1 The amount of fees collected in token1\n  function collect(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n\n  /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n  /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n  /// @dev Fees must be collected separately via a call to #collect\n  /// @param tickLower The lower tick of the position for which to burn liquidity\n  /// @param tickUpper The upper tick of the position for which to burn liquidity\n  /// @param amount How much liquidity to burn\n  /// @return amount0 The amount of token0 sent to the recipient\n  /// @return amount1 The amount of token1 sent to the recipient\n  function burn(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Swap token0 for token1, or token1 for token0\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n  /// @param recipient The address to receive the output of the swap\n  /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n  /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n  /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n  /// @param data Any data to be passed through to the callback\n  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n  /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n  /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n  /// @param recipient The address which will receive the token0 and token1 amounts\n  /// @param amount0 The amount of token0 to send\n  /// @param amount1 The amount of token1 to send\n  /// @param data Any data to be passed through to the callback\n  function flash(\n    address recipient,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n\n  /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n  /// you must call it with secondsAgos = [3600, 0].\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n  /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n  /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n  /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n  /// timestamp\n  function observe(uint32[] calldata secondsAgos)\n  external\n  view\n  returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n  /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n  /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n  /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n  /// snapshot is taken and the second snapshot is taken.\n  /// @param tickLower The lower tick of the range\n  /// @param tickUpper The upper tick of the range\n  /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n  /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n  /// @return secondsInside The snapshot of seconds per liquidity for the range\n  function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n  external\n  view\n  returns (\n    int56 tickCumulativeInside,\n    uint160 secondsPerLiquidityInsideX128,\n    uint32 secondsInside\n  );\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n  /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n  /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n  /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n  event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n  /// @notice Emitted when liquidity is minted for a given position\n  /// @param sender The address that minted the liquidity\n  /// @param owner The owner of the position and recipient of any minted liquidity\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity minted to the position range\n  /// @param amount0 How much token0 was required for the minted liquidity\n  /// @param amount1 How much token1 was required for the minted liquidity\n  event Mint(\n    address sender,\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted when fees are collected by the owner of a position\n  /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n  /// @param owner The owner of the position for which fees are collected\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount0 The amount of token0 fees collected\n  /// @param amount1 The amount of token1 fees collected\n  event Collect(\n    address indexed owner,\n    address recipient,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount0,\n    uint128 amount1\n  );\n\n  /// @notice Emitted when a position's liquidity is removed\n  /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n  /// @param owner The owner of the position for which liquidity is removed\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity to remove\n  /// @param amount0 The amount of token0 withdrawn\n  /// @param amount1 The amount of token1 withdrawn\n  event Burn(\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted by the pool for any swaps between token0 and token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the output of the swap\n  /// @param amount0 The delta of the token0 balance of the pool\n  /// @param amount1 The delta of the token1 balance of the pool\n  /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n  /// @param liquidity The liquidity of the pool after the swap\n  /// @param tick The log base 1.0001 of price of the pool after the swap\n  event Swap(\n    address indexed sender,\n    address indexed recipient,\n    int256 amount0,\n    int256 amount1,\n    uint160 sqrtPriceX96,\n    uint128 liquidity,\n    int24 tick\n  );\n\n  /// @notice Emitted by the pool for any flashes of token0/token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the tokens from flash\n  /// @param amount0 The amount of token0 that was flashed\n  /// @param amount1 The amount of token1 that was flashed\n  /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n  /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n  event Flash(\n    address indexed sender,\n    address indexed recipient,\n    uint256 amount0,\n    uint256 amount1,\n    uint256 paid0,\n    uint256 paid1\n  );\n\n  /// @notice Emitted by the pool for increases to the number of observations that can be stored\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n  /// just before a mint/swap/burn.\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(\n    uint16 observationCardinalityNextOld,\n    uint16 observationCardinalityNextNew\n  );\n\n  /// @notice Emitted when the protocol fee is changed by the pool\n  /// @param feeProtocol0Old The previous value of the token0 protocol fee\n  /// @param feeProtocol1Old The previous value of the token1 protocol fee\n  /// @param feeProtocol0New The updated value of the token0 protocol fee\n  /// @param feeProtocol1New The updated value of the token1 protocol fee\n  event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n  /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n  /// @param sender The address that collects the protocol fees\n  /// @param recipient The address that receives the collected protocol fees\n  /// @param amount0 The amount of token0 protocol fees that is withdrawn\n  /// @param amount0 The amount of token1 protocol fees that is withdrawn\n  event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n  /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n  /// @return The contract address\n  function factory() external view returns (address);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (address);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (address);\n\n  /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n  /// @return The fee\n  function fee() external view returns (uint24);\n\n  /// @notice The pool tick spacing\n  /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n  /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n  /// This value is an int24 to avoid casting even though it is always positive.\n  /// @return The tick spacing\n  function tickSpacing() external view returns (int24);\n\n  /// @notice The maximum amount of position liquidity that can use any tick in the range\n  /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n  /// @notice Set the denominator of the protocol's % share of the fees\n  /// @param feeProtocol0 new protocol fee for token0 of the pool\n  /// @param feeProtocol1 new protocol fee for token1 of the pool\n  function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n  /// @notice Collect the protocol fee accrued to the pool\n  /// @param recipient The address to which collected protocol fees should be sent\n  /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n  /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n  /// @return amount0 The protocol fee collected in token0\n  /// @return amount1 The protocol fee collected in token1\n  function collectProtocol(\n    address recipient,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n  /// when accessed externally.\n  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n  /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n  /// boundary.\n  /// observationIndex The index of the last oracle observation that was written,\n  /// observationCardinality The current maximum number of observations stored in the pool,\n  /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n  /// feeProtocol The protocol fee for both tokens of the pool.\n  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n  /// unlocked Whether the pool is currently locked to reentrancy\n  function slot0()\n  external\n  view\n  returns (\n    uint160 sqrtPriceX96,\n    int24 tick,\n    uint16 observationIndex,\n    uint16 observationCardinality,\n    uint16 observationCardinalityNext,\n    uint8 feeProtocol,\n    bool unlocked\n  );\n\n  /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal0X128() external view returns (uint256);\n\n  /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal1X128() external view returns (uint256);\n\n  /// @notice The amounts of token0 and token1 that are owed to the protocol\n  /// @dev Protocol fees will never exceed uint128 max in either token\n  function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n  /// @notice The currently in range liquidity available to the pool\n  /// @dev This value has no relationship to the total liquidity across all ticks\n  function liquidity() external view returns (uint128);\n\n  /// @notice Look up information about a specific tick in the pool\n  /// @param tick The tick to look up\n  /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n  /// tick upper,\n  /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n  /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n  /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n  /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n  /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n  /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n  /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n  /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n  /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n  /// a specific position.\n  function ticks(int24 tick)\n  external\n  view\n  returns (\n    uint128 liquidityGross,\n    int128 liquidityNet,\n    uint256 feeGrowthOutside0X128,\n    uint256 feeGrowthOutside1X128,\n    int56 tickCumulativeOutside,\n    uint160 secondsPerLiquidityOutsideX128,\n    uint32 secondsOutside,\n    bool initialized\n  );\n\n  /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n  function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n  /// @notice Returns the information about a position by the position's key\n  /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n  /// @return _liquidity The amount of liquidity in the position,\n  /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n  /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n  /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n  /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n  function positions(bytes32 key)\n  external\n  view\n  returns (\n    uint128 _liquidity,\n    uint256 feeGrowthInside0LastX128,\n    uint256 feeGrowthInside1LastX128,\n    uint128 tokensOwed0,\n    uint128 tokensOwed1\n  );\n\n  /// @notice Returns data about a specific observation index\n  /// @param index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return blockTimestamp The timestamp of the observation,\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\n  function observations(uint256 index)\n  external\n  view\n  returns (\n    uint32 blockTimestamp,\n    int56 tickCumulative,\n    uint160 secondsPerLiquidityCumulativeX128,\n    bool initialized\n  );\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity 0.8.17;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/integrations/uniswap/LiquidityAmounts.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\nimport \"./FullMath.sol\";\nimport \"./FixedPoint96.sol\";\n\n/// @title Liquidity amount functions\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary LiquidityAmounts {\n  function toUint128(uint256 x) private pure returns (uint128 y) {\n    require((y = uint128(x)) == x);\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount0 The amount0 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function getLiquidityForAmount0(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint256 amount0\n  ) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96)\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    uint256 intermediate =\n    FullMath.mulDiv(sqrtRatioAX96, sqrtRatioBX96, FixedPoint96.Q96);\n    return\n    toUint128(\n      FullMath.mulDiv(\n        amount0,\n        intermediate,\n        sqrtRatioBX96 - sqrtRatioAX96\n      )\n    );\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount1 The amount1 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function getLiquidityForAmount1(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint256 amount1\n  ) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96)\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    return\n    toUint128(\n      FullMath.mulDiv(\n        amount1,\n        FixedPoint96.Q96,\n        sqrtRatioBX96 - sqrtRatioAX96\n      )\n    );\n  }\n\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n  /// pool prices and the prices at the tick boundaries\n  function getLiquidityForAmounts(\n    uint160 sqrtRatioX96,\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint256 amount0,\n    uint256 amount1\n  ) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96)\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      liquidity = getLiquidityForAmount0(\n        sqrtRatioAX96,\n        sqrtRatioBX96,\n        amount0\n      );\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      uint128 liquidity0 =\n      getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n      uint128 liquidity1 =\n      getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n    } else {\n      liquidity = getLiquidityForAmount1(\n        sqrtRatioAX96,\n        sqrtRatioBX96,\n        amount1\n      );\n    }\n  }\n\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount0 The amount0\n  function getAmount0ForLiquidity(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity\n  ) internal pure returns (uint256 amount0) {\n    if (sqrtRatioAX96 > sqrtRatioBX96)\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    return\n    FullMath.mulDiv(\n      uint256(liquidity) << FixedPoint96.RESOLUTION,\n      sqrtRatioBX96 - sqrtRatioAX96,\n      sqrtRatioBX96\n    ) / sqrtRatioAX96;\n  }\n\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount1 The amount1\n  function getAmount1ForLiquidity(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity\n  ) internal pure returns (uint256 amount1) {\n    if (sqrtRatioAX96 > sqrtRatioBX96)\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    return\n    FullMath.mulDiv(\n      liquidity,\n      sqrtRatioBX96 - sqrtRatioAX96,\n      FixedPoint96.Q96\n    );\n  }\n\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n  /// pool prices and the prices at the tick boundaries\n  function getAmountsForLiquidity(\n    uint160 sqrtRatioX96,\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity\n  ) internal pure returns (uint256 amount0, uint256 amount1) {\n    if (sqrtRatioAX96 > sqrtRatioBX96)\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      amount0 = getAmount0ForLiquidity(\n        sqrtRatioAX96,\n        sqrtRatioBX96,\n        liquidity\n      );\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      amount0 = getAmount0ForLiquidity(\n        sqrtRatioX96,\n        sqrtRatioBX96,\n        liquidity\n      );\n      amount1 = getAmount1ForLiquidity(\n        sqrtRatioAX96,\n        sqrtRatioX96,\n        liquidity\n      );\n    } else {\n      amount1 = getAmount1ForLiquidity(\n        sqrtRatioAX96,\n        sqrtRatioBX96,\n        liquidity\n      );\n    }\n  }\n}\n"
    },
    "contracts/integrations/uniswap/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\npragma solidity 0.8.17;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n  int24 internal constant MIN_TICK = - 887272;\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n  int24 internal constant MAX_TICK = - MIN_TICK;\n\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 internal constant MAX_SQRT_RATIO =\n  1461446703485210103287273052203988822378723970342;\n\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\n  /// @dev Throws if |tick| > max tick\n  /// @param tick The input tick for the above formula\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n  /// at the given tick\n  function getSqrtRatioAtTick(int24 tick)\n  internal\n  pure\n  returns (uint160 sqrtPriceX96)\n  {\n    uint256 absTick =\n    tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\n\n    // EDIT: 0.8 compatibility\n    require(absTick <= uint256(int256(MAX_TICK)), \"T\");\n\n    uint256 ratio =\n    absTick & 0x1 != 0\n    ? 0xfffcb933bd6fad37aa2d162d1a594001\n    : 0x100000000000000000000000000000000;\n    if (absTick & 0x2 != 0)\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n    if (absTick & 0x4 != 0)\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n    if (absTick & 0x8 != 0)\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n    if (absTick & 0x10 != 0)\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n    if (absTick & 0x20 != 0)\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n    if (absTick & 0x40 != 0)\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n    if (absTick & 0x80 != 0)\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n    if (absTick & 0x100 != 0)\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n    if (absTick & 0x200 != 0)\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n    if (absTick & 0x400 != 0)\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n    if (absTick & 0x800 != 0)\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n    if (absTick & 0x1000 != 0)\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n    if (absTick & 0x2000 != 0)\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n    if (absTick & 0x4000 != 0)\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n    if (absTick & 0x8000 != 0)\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n    if (absTick & 0x10000 != 0)\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n    if (absTick & 0x20000 != 0)\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n    if (absTick & 0x40000 != 0)\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n    if (absTick & 0x80000 != 0)\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n    if (tick > 0) ratio = type(uint256).max / ratio;\n\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n    sqrtPriceX96 = uint160(\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\n    );\n  }\n\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n  /// ever return.\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n  function getTickAtSqrtRatio(uint160 sqrtPriceX96)\n  internal\n  pure\n  returns (int24 tick)\n  {\n    // second inequality must be < because the price can never reach the price at the max tick\n    require(\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\n      \"R\"\n    );\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n    uint256 r = ratio;\n    uint256 msb = 0;\n\n    assembly {\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(5, gt(r, 0xFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(4, gt(r, 0xFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(3, gt(r, 0xFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(2, gt(r, 0xF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(1, gt(r, 0x3))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := gt(r, 0x1)\n      msb := or(msb, f)\n    }\n\n    if (msb >= 128) r = ratio >> (msb - 127);\n    else r = ratio << (127 - msb);\n\n    int256 log_2 = (int256(msb) - 128) << 64;\n\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(63, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(62, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(61, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(60, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(59, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(58, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(57, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(56, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(55, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(54, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(53, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(52, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(51, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(50, f))\n    }\n\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\n    // 128.128 number\n\n    int24 tickLow =\n    int24(\n      (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\n    );\n    int24 tickHi =\n    int24(\n      (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\n    );\n\n    tick = tickLow == tickHi\n    ? tickLow\n    : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\n    ? tickHi\n    : tickLow;\n  }\n}\n"
    },
    "contracts/interfaces/IRebalancingStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IRebalancingStrategy {\n    function needRebalance() external view returns (bool);\n    function rebalance() external;\n}\n"
    },
    "contracts/libs/AppErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice List of all errors generated by the application\n///         Each error should have unique code TS-XXX and descriptive comment\nlibrary AppErrors {\n  /// @notice Provided address should be not zero\n  string public constant ZERO_ADDRESS = \"TS-1 zero address\";\n\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\n  string public constant UNISWAP_PAIR_NOT_FOUND = \"TS-2 pair not found\";\n\n  /// @notice Lengths not matched\n  string public constant WRONG_LENGTHS = \"TS-4 wrong lengths\";\n\n  /// @notice Unexpected zero balance\n  string public constant ZERO_BALANCE = \"TS-5 zero balance\";\n\n  string public constant ITEM_NOT_FOUND = \"TS-6 not found\";\n\n  string public constant NOT_ENOUGH_BALANCE = \"TS-7 not enough balance\";\n\n  /// @notice Price oracle returns zero price\n  string public constant ZERO_PRICE = \"TS-8 zero price\";\n\n  string public constant WRONG_VALUE = \"TS-9 wrong value\";\n\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\n  string public constant ZERO_AMOUNT_BORROWED = \"TS-10 zero borrowed amount\";\n\n  string public constant WITHDRAW_TOO_MUCH = \"TS-11 try to withdraw too much\";\n\n  string public constant UNKNOWN_ENTRY_KIND = \"TS-12 unknown entry kind\";\n\n  string public constant ONLY_TETU_CONVERTER = \"TS-13 only TetuConverter\";\n\n  string public constant WRONG_ASSET = \"TS-14 wrong asset\";\n\n  string public constant NO_LIQUIDATION_ROUTE = \"TS-15 No liquidation route\";\n\n  string public constant PRICE_IMPACT = \"TS-16 price impact\";\n\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\n  string public constant REPAY_MAKES_SWAP = \"TS-17 can not convert back\";\n\n  string public constant NO_INVESTMENTS = \"TS-18 no investments\";\n\n  string public constant INCORRECT_LENGTHS = \"TS-19 lengths\";\n}\n"
    },
    "contracts/libs/AppLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\n/// @notice Common internal utils\nlibrary AppLib {\n  using SafeERC20 for IERC20;\n\n  /// @notice Unchecked increment for for-cycles\n  function uncheckedInc(uint i) internal pure returns (uint) {\n  unchecked {\n    return i + 1;\n  }\n  }\n\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\n  /// @dev Should NOT be used for third-party pools\n  function approveIfNeeded(address token, uint amount, address spender) internal {\n    if (IERC20(token).allowance(address(this), spender) < amount) {\n      IERC20(token).safeApprove(spender, 0);\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\n      IERC20(token).safeApprove(spender, 2 ** 255);\n    }\n  }\n}\n"
    },
    "contracts/libs/AppPlatforms.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nlibrary AppPlatforms {\n  string public constant UNIV3 = \"UniswapV3\";\n  string public constant BALANCER = \"Balancer\";\n}\n"
    },
    "contracts/libs/ConverterEntryKinds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\nlibrary ConverterEntryKinds {\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\n\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\n  ///         C2 should be used as collateral to make a borrow B.\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\n\n  /// @notice Borrow given amount using min possible collateral\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\n\n  /// @notice Decode entryData, extract first uint - entry kind\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\n    if (entryData_.length == 0) {\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\n    }\n    return abi.decode(entryData_, (uint));\n  }\n}\n"
    },
    "contracts/libs/TokenAmountsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AppErrors.sol\";\n\n/// @title Library for clearing / joining token addresses & amounts arrays\n/// @author bogdoslav\nlibrary TokenAmountsLib {\n\n  function uncheckedInc(uint i) internal pure returns (uint) {\n  unchecked {\n    return i + 1;\n  }\n  }\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \"1.0.0\";\n\n  function filterZeroAmounts(\n    address[] memory tokens,\n    uint[] memory amounts\n  ) internal pure returns (\n    address[] memory t,\n    uint[] memory a\n  ) {\n    require(tokens.length == amounts.length, 'TAL: Arrays mismatch');\n    uint len2 = 0;\n    uint len = tokens.length;\n    for (uint i = 0; i < len; i++) {\n      if (amounts[i] != 0) len2++;\n    }\n\n    t = new address[](len2);\n    a = new uint[](len2);\n\n    uint j = 0;\n    for (uint i = 0; i < len; i++) {\n      uint amount = amounts[i];\n      if (amount != 0) {\n        t[j] = tokens[i];\n        a[j] = amount;\n        j++;\n      }\n    }\n  }\n\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\n  function combineArrays(\n    address[] memory tokens0,\n    uint[] memory amounts0,\n    address[] memory tokens1,\n    uint[] memory amounts1,\n    address[] memory tokens2,\n    uint[] memory amounts2\n  ) internal pure returns (\n    address[] memory allTokens,\n    uint[] memory allAmounts\n  ) {\n    uint[] memory lens = new uint[](3);\n    lens[0] = tokens0.length;\n    lens[1] = tokens1.length;\n    lens[2] = tokens2.length;\n\n    require(\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\n      AppErrors.INCORRECT_LENGTHS\n    );\n\n    uint maxLength = lens[0] + lens[1] + lens[2];\n    address[] memory tokensOut = new address[](maxLength);\n    uint[] memory amountsOut = new uint[](maxLength);\n    uint unitedLength;\n\n    for (uint step; step < 3; ++step) {\n      uint[] memory amounts = step == 0\n        ? amounts0\n        : (step == 1\n          ? amounts1\n          : amounts2);\n      address[] memory tokens = step == 0\n        ? tokens0\n        : (step == 1\n          ? tokens1\n          : tokens2);\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\n        uint amount1 = amounts[i1];\n        address token1 = tokens[i1];\n        bool united = false;\n\n        for (uint i = 0; i < unitedLength; i++) {\n          if (token1 == tokensOut[i]) {\n            amountsOut[i] += amount1;\n            united = true;\n            break;\n          }\n        }\n\n        if (!united) {\n          tokensOut[unitedLength] = token1;\n          amountsOut[unitedLength] = amount1;\n          unitedLength++;\n        }\n      }\n    }\n\n    // copy united tokens to result array\n    allTokens = new address[](unitedLength);\n    allAmounts = new uint[](unitedLength);\n    for (uint i; i < unitedLength; i++) {\n      allTokens[i] = tokensOut[i];\n      allAmounts[i] = amountsOut[i];\n    }\n\n  }\n}\n"
    },
    "contracts/strategies/balancer/BalancerComposableStableDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"../DepositorBase.sol\";\nimport \"./BalancerLogicLib.sol\";\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../integrations/balancer/IBalancerHelper.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAavePool.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAaveStablePool.sol\";\nimport \"../../integrations/balancer/IChildChainLiquidityGaugeFactory.sol\";\nimport \"../../integrations/balancer/IBalancerGauge.sol\";\n\n\n/// @title Depositor for Composable Stable Pool with several embedded linear pools like \"Balancer Boosted Aave USD\"\n/// @dev See https://app.balancer.fi/#/polygon/pool/0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b\n///            bb-am-DAI (DAI + amDAI) + bb-am-USDC (USDC + amUSDC) + bb-am-USDT (USDT + amUSDT)\n///      See https://docs.balancer.fi/products/balancer-pools/boosted-pools for explanation of Boosted Pools on BalanceR.\n///      Terms\n///         bb-a-USD = pool bpt\n///         bb-a-DAI, bb-a-USDC, etc = underlying bpt\nabstract contract BalancerComposableStableDepositor is DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant BALANCER_COMPOSABLE_STABLE_DEPOSITOR_VERSION = \"1.0.0\";\n\n  /// @dev https://dev.balancer.fi/references/contracts/deployment-addresses\n  IBVault internal constant BALANCER_VAULT = IBVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n  address internal constant BALANCER_HELPER = 0x239e55F427D44C3cc793f49bFB507ebe76638a2b;\n  /// @notice ChildChainLiquidityGaugeFactory allows to get gauge address by pool id\n  /// @dev see https://dev.balancer.fi/resources/vebal-and-gauges/gauges\n  address internal constant CHILD_CHAIN_LIQUIDITY_GAUGE_FACTORY = 0x3b8cA519122CdD8efb272b0D3085453404B25bD0;\n\n  /// @notice i.e. for \"Balancer Boosted Aave USD\": 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b\n  bytes32 public poolId;\n  IBalancerGauge internal _gauge;\n  address[] internal _rewardTokens;\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  function __BalancerBoostedAaveUsdDepositor_init(\n    bytes32 poolId_,\n    address[] memory rewardTokens_\n  ) internal onlyInitializing {\n    poolId = poolId_;\n\n    _gauge = IBalancerGauge(\n      IChildChainLiquidityGaugeFactory(\n        CHILD_CHAIN_LIQUIDITY_GAUGE_FACTORY\n      ).getPoolGauge(BalancerLogicLib.getPoolAddress(poolId_))\n    );\n    // infinite approve of pool-BPT to the gauge todo is it safe for the external gauge?\n    IERC20(BalancerLogicLib.getPoolAddress(poolId_)).safeApprove(address(_gauge), type(uint).max);\n\n    // we can get list of reward tokens from the gauge, but it's more cheaper to get it outside\n    _rewardTokens = rewardTokens_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    return BalancerLogicLib.depositorPoolAssets(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Returns pool weights\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\n  /// @return totalWeight Total sum of all items of {weights}\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    return BalancerLogicLib.depositorPoolWeights(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of DAI, USDC, USDT\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \"Balancer Boosted Aave USD\" we return:\n  ///                     0: balance DAI + (balance amDAI recalculated to DAI)\n  ///                     1: balance USDC + (amUSDC recalculated to USDC)\n  ///                     2: balance USDT + (amUSDT recalculated to USDT)\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reservesOut) {\n    reservesOut = BalancerLogicLib.depositorPoolReserves(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() override internal virtual view returns (uint liquidityOut) {\n    liquidityOut = _gauge.balanceOf(address(this))\n    + IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId)).balanceOf(address(this));\n  }\n\n  //// @notice Total amount of liquidity (LP tokens) in the depositor\n  function _depositorTotalSupply() override internal view returns (uint totalSupplyOut) {\n    totalSupplyOut = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId)).getActualSupply();\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  ///         i.e. for \"Balancer Boosted Aave USD\" we have DAI, USDC, USDT\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    bytes32 _poolId = poolId;\n    IBalancerBoostedAaveStablePool pool = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(_poolId));\n\n    // join to the pool, receive pool-BPTs\n    (amountsConsumedOut, liquidityOut) = BalancerLogicLib.depositorEnter(BALANCER_VAULT, _poolId, amountsDesired_);\n\n    // stake all available pool-BPTs to the gauge\n    // we can have pool-BPTs on depositor's balance after previous exit, stake them too\n    _gauge.deposit(pool.balanceOf(address(this)));\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then should make full exit\n  /// @param liquidityAmount_ Max amount to withdraw in bpt. Actual withdrawn amount will be less,\n  ///                         so it worth to add a gap to this amount, i.e. 1%\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function _depositorExit(uint liquidityAmount_) override internal virtual returns (\n    uint[] memory amountsOut\n  ) {\n    bytes32 _poolId = poolId;\n    IBalancerGauge __gauge = _gauge;\n    IBalancerBoostedAaveStablePool pool = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(_poolId));\n\n    // we need to withdraw pool-BPTs from the _gauge\n    // at first, let's try to use exist pool-BPTs on the depositor balance, probably it's enough\n    // we can have pool-BPTs on depositor's balance after previous exit, see BalancerLogicLib.depositorExit\n    uint depositorBalance = pool.balanceOf(address(this));\n    uint gaugeBalance = __gauge.balanceOf(address(this));\n\n    uint liquidityToWithdraw = liquidityAmount_ > depositorBalance\n    ? liquidityAmount_ - depositorBalance\n    : 0;\n\n    // calculate how much pool-BPTs we should withdraw from the gauge\n    if (liquidityToWithdraw > 0) {\n      if (liquidityToWithdraw > gaugeBalance) {\n        liquidityToWithdraw = gaugeBalance;\n      }\n    }\n\n    // un-stake required pool-BPTs from the gauge\n    if (liquidityToWithdraw > 0) {\n      __gauge.withdraw(liquidityToWithdraw);\n    }\n\n    // withdraw the liquidity from the pool\n    amountsOut = (liquidityAmount_ >= depositorBalance + gaugeBalance)\n    ? BalancerLogicLib.depositorExitFull(BALANCER_VAULT, _poolId)\n    : BalancerLogicLib.depositorExit(BALANCER_VAULT, _poolId, liquidityToWithdraw);\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then full exit is required\n  ///      we emulate is at normal exit + conversion of remain BPT directly to the main asset\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function _depositorQuoteExit(uint liquidityAmount_) override internal virtual returns (uint[] memory amountsOut) {\n    uint liquidity = _depositorLiquidity();\n    if (liquidity == 0) {\n      // there is no liquidity, output is zero\n      return new uint[](_depositorPoolAssets().length);\n    } else {\n      // BalancerLogicLib.depositorQuoteExit takes into account the cost of unused BPT\n      // so we don't need a special logic here for the full exit\n      return BalancerLogicLib.depositorQuoteExit(\n        BALANCER_VAULT,\n        IBalancerHelper(BALANCER_HELPER),\n        poolId,\n        liquidityAmount_\n      );\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Claim all possible rewards.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    return BalancerLogicLib.depositorClaimRewards(_gauge, _rewardTokens);\n  }\n\n  /// @dev Returns reward token addresses array.\n  function rewardTokens() external view returns (address[] memory tokens) {\n    return _rewardTokens;\n  }\n\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[16] private __gap; // TODO 16 ???\n}\n"
    },
    "contracts/strategies/balancer/BalancerComposableStableStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./BalancerComposableStableDepositor.sol\";\nimport \"../../libs/AppPlatforms.sol\";\n\n// todo make BalancerComposableStableDepositor not abstract\ncontract BalancerComposableStableStrategy is ConverterStrategyBase, BalancerComposableStableDepositor {\n  string public constant override NAME = \"Balancer Boosted Aave USD Strategy\";\n  string public constant override PLATFORM = AppPlatforms.BALANCER;\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n  bytes32 public constant POOL_ID = 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b;\n\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_\n  ) external initializer {\n    // we can take address of the reward tokens using gauge and gauge.reward_contract\n    // it worth to encode these array to avoid calculation in init\n    address[] memory rewardTokens = new address[](1);\n    rewardTokens[0] = 0x9a71012B13CA4d3D0Cdc72A177DF3ef03b0E76A3;\n\n    __BalancerBoostedAaveUsdDepositor_init(POOL_ID, rewardTokens);\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n  }\n}\n"
    },
    "contracts/strategies/balancer/BalancerLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\nimport \"../../libs/AppErrors.sol\";\nimport \"../../libs/AppLib.sol\";\nimport \"../../libs/TokenAmountsLib.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAavePool.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAaveStablePool.sol\";\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../integrations/balancer/IBalancerHelper.sol\";\nimport \"../../integrations/balancer/IBalancerGauge.sol\";\n\n/// @notice Functions of BalancerComposableStableDepositor\n/// @dev Many of functions are declared as external to reduce contract size\nlibrary BalancerLogicLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Types\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev local vars in getAmountsToDeposit to avoid stack too deep\n  struct LocalGetAmountsToDeposit {\n    /// @notice Decimals of {tokens_}, 0 for BPT\n    uint[] decimals;\n    /// @notice Length of {tokens_} array\n    uint len;\n    /// @notice amountBPT / underlyingAmount, decimals 18, 0 for BPT\n    uint[] rates;\n  }\n\n  /// @notice Local variables required inside _depositorEnter/Exit/QuoteExit, avoid stack too deep\n  struct DepositorLocal {\n    uint bptIndex;\n    uint len;\n    IERC20[] tokens;\n    uint[] balances;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Asset related utils\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate amounts of {tokens} to be deposited to POOL_ID in proportions according to the {balances}\n  /// @param amountsDesired_ Desired amounts of tokens. The order of the tokens is exactly the same as in {tokens}.\n  ///                        But the array has length 3, not 4, because there is no amount for bb-am-USD here.\n  /// @param tokens_ All bb-am-* tokens (including bb-am-USD) received through getPoolTokens\n  ///                           The order of the tokens is exactly the same as in getPoolTokens-results\n  /// @param balances_ Balances of bb-am-* pools in terms of bb-am-USD tokens (received through getPoolTokens)\n  ///                           The order of the tokens is exactly the same as in {tokens}\n  /// @param totalUnderlying_ Total amounts of underlying assets (DAI, USDC, etc) in embedded linear pools.\n  ///                         The array should have same order of tokens as {tokens_}, value for BPT token is not used\n  /// @param indexBpt_ Index of BPT token inside {balances_}, {tokens_} and {totalUnderlying_} arrays\n  /// @return amountsOut Desired amounts in proper proportions for depositing.\n  ///         The order of the tokens is exactly the same as in results of getPoolTokens, 0 for BPT\n  ///         i.e. DAI, BB-AM-USD, USDC, USDT\n  function getAmountsToDeposit(\n    uint[] memory amountsDesired_,\n    IERC20[] memory tokens_,\n    uint[] memory balances_,\n    uint[] memory totalUnderlying_,\n    uint indexBpt_\n  ) internal view returns (\n    uint[] memory amountsOut\n  ) {\n    LocalGetAmountsToDeposit memory p;\n    // check not zero balances, cache index of bbAmUSD, save 10**decimals to array\n    p.len = tokens_.length;\n    require(p.len == balances_.length, AppErrors.WRONG_LENGTHS);\n    require(p.len == amountsDesired_.length || p.len - 1 == amountsDesired_.length, AppErrors.WRONG_LENGTHS);\n\n    p.decimals = new uint[](p.len);\n    p.rates = new uint[](p.len);\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexBpt_) {\n        require(balances_[i] != 0, AppErrors.ZERO_BALANCE);\n        p.decimals[i] = 10 ** IERC20Metadata(address(tokens_[i])).decimals();\n\n        // Let's calculate a rate: amountBPT / underlyingAmount, decimals 18\n        p.rates[i] = balances_[i] * 1e18 / totalUnderlying_[i];\n      }\n    }\n\n    amountsOut = new uint[](p.len - 1);\n\n    // The balances set proportions of underlying-bpt, i.e. bb-am-DAI : bb-am-USDC : bb-am-USDT\n    // Our task is find amounts of DAI : USDC : USDT that won't change that proportions after deposit.\n    // We have arbitrary desired amounts, i.e. DAI = X, USDC = Y, USDT = Z\n    // For each token: assume that it can be used in full.\n    // If so, what amounts will have other tokens in this case according to the given proportions?\n    // i.e. DAI = X = 100.0 => USDC = 200.0, USDT = 400.0. We need: Y >= 200, Z >= 400\n    // or   USDC = Y = 100.0 => DAI = 50.0, USDT = 200.0. We need: X >= 50, Z >= 200\n    // If any amount is less then expected, the token cannot be used in full.\n    // A token with min amount can be used in full, let's try to find its index.\n    // [0 : len - 1]\n    uint i3;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (indexBpt_ == i) continue;\n\n      uint amountInBpt18 = amountsDesired_[i3] * p.rates[i];\n\n      // [0 : len]\n      uint j;\n      // [0 : len - 1]\n      uint j3;\n      for (; j < p.len; j = AppLib.uncheckedInc(j)) {\n        if (indexBpt_ == j) continue;\n\n        // alpha = balancesDAI / balancesUSDC * decimalsDAI / decimalsUSDC\n        // amountDAI = amountUSDC * alpha * rateUSDC / rateDAI\n        amountsOut[j3] = amountInBpt18 * balances_[j] / p.rates[j] * p.decimals[j] / balances_[i] / p.decimals[i];\n        if (amountsOut[j3] > amountsDesired_[j3]) break;\n        j3++;\n      }\n\n      if (j == p.len) break;\n      i3++;\n    }\n  }\n\n\n  /// @notice Calculate total amount of underlying asset for each token except BPT\n  /// @dev Amount is calculated as MainTokenAmount + WrappedTokenAmount * WrappedTokenRate, see AaveLinearPool src\n  function getTotalAssetAmounts(IBVault vault_, IERC20[] memory tokens_, uint indexBpt_) internal view returns (\n    uint[] memory amountsOut\n  ) {\n    uint len = tokens_.length;\n    amountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexBpt_) {\n        IBalancerBoostedAavePool linearPool = IBalancerBoostedAavePool(address(tokens_[i]));\n        (, uint[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\n\n        amountsOut[i] =\n        balances[linearPool.getMainIndex()]\n        + balances[linearPool.getWrappedIndex()] * linearPool.getWrappedTokenRate() / 1e18;\n      }\n    }\n  }\n\n  /// @notice Split {liquidityAmount_} by assets according to proportions of their total balances\n  /// @param liquidityAmount_ Amount to withdraw in bpt\n  /// @param balances_ Balances received from getPoolTokens\n  /// @param bptIndex_ Index of pool-pbt inside {balances_}\n  /// @return bptAmountsOut Amounts of underlying-BPT. The array doesn't include an amount for pool-bpt\n  ///         Total amount of {bptAmountsOut}-items is equal to {liquidityAmount_}\n  function getBtpAmountsOut(\n    uint liquidityAmount_,\n    uint[] memory balances_,\n    uint bptIndex_\n  ) internal pure returns (uint[] memory bptAmountsOut) {\n    // we assume here, that len >= 2\n    // we don't check it because StableMath.sol in balancer has _MIN_TOKENS = 2;\n    uint len = balances_.length;\n    bptAmountsOut = new uint[](len - 1);\n\n    // compute total balance, skip pool-bpt\n    uint totalBalances;\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex_) continue;\n      totalBalances += balances_[i];\n      // temporary save incomplete amounts to bptAmountsOut\n      bptAmountsOut[k] = liquidityAmount_ * balances_[i];\n      ++k;\n    }\n\n    // finalize computation of bptAmountsOut using known totalBalances\n    uint total;\n    for (k = 0; k < len - 1; k = AppLib.uncheckedInc(k)) {\n      if (k == len - 2) {\n        // leftovers => last item\n        bptAmountsOut[k] = total > liquidityAmount_\n        ? 0\n        : liquidityAmount_ - total;\n      } else {\n        bptAmountsOut[k] /= totalBalances;\n        total += bptAmountsOut[k];\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Depositor view logic\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of DAI, USDC, USDT\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \"Balancer Boosted Aave USD\" we return:\n  ///                     0: balance DAI + (balance amDAI recalculated to DAI)\n  ///                     1: balance USDC + (amUSDC recalculated to USDC)\n  ///                     2: balance USDT + (amUSDT recalculated to USDT)\n  function depositorPoolReserves(IBVault vault_, bytes32 poolId_) external view returns (uint[] memory reservesOut) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    uint bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n    uint len = tokens.length;\n    // exclude pool-BPT\n    reservesOut = new uint[](len - 1);\n\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex) continue;\n      IBalancerBoostedAavePool linearPool = IBalancerBoostedAavePool(address(tokens[i]));\n\n      // Each bb-am-* returns (main-token, wrapped-token, bb-am-itself), the order of tokens is arbitrary\n      // i.e. (DAI + amDAI + bb-am-DAI) or (bb-am-USDC, amUSDC, USDC)\n\n      // get balances of all tokens of bb-am-XXX token, i.e. balances of (DAI, amDAI, bb-am-DAI)\n      (, uint256[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\n      // DAI\n      uint mainIndex = linearPool.getMainIndex();\n      // amDAI\n      uint wrappedIndex = linearPool.getWrappedIndex();\n\n      reservesOut[k] = balances[mainIndex] + balances[wrappedIndex] * linearPool.getWrappedTokenRate() / 1e18;\n      ++k;\n    }\n  }\n\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\n  function depositorPoolAssets(IBVault vault_, bytes32 poolId_) external view returns (address[] memory poolAssets) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    uint bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n    uint len = tokens.length;\n\n    poolAssets = new address[](len - 1);\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex) continue;\n\n      poolAssets[k] = IBalancerBoostedAavePool(address(tokens[i])).getMainToken();\n      ++k;\n    }\n  }\n\n  /// @notice Returns pool weights\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\n  /// @return totalWeight Total sum of all items of {weights}\n  function depositorPoolWeights(IBVault vault_, bytes32 poolId_) external view returns (\n    uint[] memory weights,\n    uint totalWeight\n  ) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    // totalWeight is equal to length of output array here\n    totalWeight = tokens.length - 1;\n    weights = new uint[](totalWeight);\n    for (uint i; i < totalWeight; i = AppLib.uncheckedInc(i)) {\n      weights[i] = 1;\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Depositor enter, exit logic\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  ///         i.e. for \"Balancer Boosted Aave USD\" we have DAI, USDC, USDT\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\n  function depositorEnter(IBVault vault_, bytes32 poolId_, uint[] memory amountsDesired_) external returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    DepositorLocal memory p;\n\n    // The implementation below assumes, that getPoolTokens returns the assets in following order:\n    //    bb-am-dai, bb-am-usd, bb-am-usdc, bb-am-usdt\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n    p.bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n\n    // temporary save current liquidity\n    liquidityOut = IBalancerBoostedAaveStablePool(address(p.tokens[p.bptIndex])).balanceOf(address(this));\n\n    // Original amounts can have any values.\n    // But we need amounts in such proportions that won't move the current balances\n    {\n      uint[] memory underlying = BalancerLogicLib.getTotalAssetAmounts(vault_, p.tokens, p.bptIndex);\n      amountsConsumedOut = BalancerLogicLib.getAmountsToDeposit(amountsDesired_, p.tokens, p.balances, underlying, p.bptIndex);\n    }\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n    sender : address(this),\n    fromInternalBalance : false,\n    recipient : payable(address(this)),\n    toInternalBalance : false\n    });\n\n    // swap all tokens XX => bb-am-XX\n    // we need two arrays with same amounts: amountsToDeposit (with 0 for BB-AM-USD) and userDataAmounts (no BB-AM-USD)\n    uint[] memory amountsToDeposit = new uint[](p.len);\n    // no bpt\n    uint[] memory userDataAmounts = new uint[](p.len - 1);\n    uint k;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      amountsToDeposit[i] = BalancerLogicLib.swap(\n        vault_,\n        IBalancerBoostedAavePool(address(p.tokens[i])).getPoolId(),\n        IBalancerBoostedAavePool(address(p.tokens[i])).getMainToken(),\n        address(p.tokens[i]),\n        amountsConsumedOut[k],\n        funds\n      );\n      userDataAmounts[k] = amountsToDeposit[i];\n      AppLib.approveIfNeeded(address(p.tokens[i]), amountsToDeposit[i], address(vault_));\n      ++k;\n    }\n\n    // add liquidity to balancer\n    vault_.joinPool(\n      poolId_,\n      address(this),\n      address(this),\n      IBVault.JoinPoolRequest({\n    assets : asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\n    maxAmountsIn : amountsToDeposit,\n    userData : abi.encode(IBVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, userDataAmounts, 0),\n    fromInternalBalance : false\n    })\n    );\n\n    uint liquidityAfter = IERC20(address(p.tokens[p.bptIndex])).balanceOf(address(this));\n\n    liquidityOut = liquidityAfter > liquidityOut\n    ? liquidityAfter - liquidityOut\n    : 0;\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @param liquidityAmount_ Amount to withdraw in bpt\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorExit(IBVault vault_, bytes32 poolId_, uint liquidityAmount_) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IBalancerBoostedAaveStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n\n    require(liquidityAmount_ <= p.tokens[p.bptIndex].balanceOf(address(this)), AppErrors.NOT_ENOUGH_BALANCE);\n\n    // BalancerR can spend a bit less amount of liquidity than {liquidityAmount_}\n    // i.e. we if liquidityAmount_ = 2875841, we can have leftovers = 494 after exit\n    vault_.exitPool(\n      poolId_,\n      address(this),\n      payable(address(this)),\n      IBVault.ExitPoolRequest({\n    assets : asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\n    minAmountsOut : new uint[](p.len), // todo: no limits?\n    userData : abi.encode(\n        IBVault.ExitKindComposableStable.BPT_IN_FOR_EXACT_TOKENS_OUT,\n        BalancerLogicLib.getBtpAmountsOut(liquidityAmount_, p.balances, p.bptIndex),\n        liquidityAmount_\n      ),\n    toInternalBalance : false\n    })\n    );\n\n    // now we have amBbXXX tokens; swap them to XXX assets\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n    sender : address(this),\n    fromInternalBalance : false,\n    recipient : payable(address(this)),\n    toInternalBalance : false\n    });\n\n    amountsOut = new uint[](p.len - 1);\n    uint k;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      uint amountIn = p.tokens[i].balanceOf(address(this));\n      if (amountIn != 0) {\n        amountsOut[k] = swap(\n          vault_,\n          IBalancerBoostedAavePool(address(p.tokens[i])).getPoolId(),\n          address(p.tokens[i]),\n          IBalancerBoostedAavePool(address(p.tokens[i])).getMainToken(),\n          amountIn,\n          funds\n        );\n      }\n      ++k;\n    }\n  }\n\n  /// @notice Withdraw all available amount of LP-tokens from the pool\n  ///         BalanceR doesn't allow to withdraw exact amount, so it's allowed to leave dust amount on the balance\n  /// @dev We make at most N attempts to withdraw (not more, each attempt takes a lot of gas).\n  ///      Each attempt reduces available balance at ~1e4 times.\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///                    The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorExitFull(IBVault vault_, bytes32 poolId_) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IBalancerBoostedAaveStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n    amountsOut = new uint[](p.len - 1);\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n    sender : address(this),\n    fromInternalBalance : false,\n    recipient : payable(address(this)),\n    toInternalBalance : false\n    });\n\n    uint liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\n    if (liquidityAmount > 0) {\n      uint liquidityThreshold = 10 ** IERC20Metadata(address(p.tokens[p.bptIndex])).decimals() / 100;\n\n      // we can make at most N attempts to withdraw amounts from the balanceR pool\n      for (uint i = 0; i < 2; ++i) {\n        vault_.exitPool(\n          poolId_,\n          address(this),\n          payable(address(this)),\n          IBVault.ExitPoolRequest({\n        assets : asIAsset(p.tokens),\n        minAmountsOut : new uint[](p.len), // todo: no limits?\n        userData : abi.encode(\n            IBVault.ExitKindComposableStable.BPT_IN_FOR_EXACT_TOKENS_OUT,\n            BalancerLogicLib.getBtpAmountsOut(liquidityAmount, p.balances, p.bptIndex),\n            liquidityAmount\n          ),\n        toInternalBalance : false\n        })\n        );\n        liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\n        if (liquidityAmount < liquidityThreshold || i == 1) {\n          break;\n        }\n        (, p.balances,) = vault_.getPoolTokens(poolId_);\n      }\n\n      // now we have amBbXXX tokens; swap them to XXX assets\n      uint k;\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n        if (i == p.bptIndex) continue;\n\n        uint amountIn = p.tokens[i].balanceOf(address(this));\n        if (amountIn != 0) {\n          amountsOut[k] = swap(\n            vault_,\n            IBalancerBoostedAavePool(address(p.tokens[i])).getPoolId(),\n            address(p.tokens[i]),\n            IBalancerBoostedAavePool(address(p.tokens[i])).getMainToken(),\n            amountIn,\n            funds\n          );\n        }\n        ++k;\n      }\n    }\n\n    uint depositorBalance = p.tokens[p.bptIndex].balanceOf(address(this));\n    if (depositorBalance > 0) {\n      uint k = 0;\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n        if (i == p.bptIndex) continue;\n\n        // we assume here, that the depositorBalance is small\n        // so we can directly swap it to any single asset without changing of pool resources proportions\n        amountsOut[k] += _convertSmallBptRemainder(vault_, poolId_, p, funds, depositorBalance, i);\n        break;\n      }\n    }\n\n    return amountsOut;\n  }\n\n  /// @notice convert remained SMALL amount of bpt => am-bpt => main token of the am-bpt\n  /// @return amountOut Received amount of am-bpt's main token\n  function _convertSmallBptRemainder(\n    IBVault vault_,\n    bytes32 poolId_,\n    DepositorLocal memory p,\n    IBVault.FundManagement memory funds,\n    uint bptAmountIn_,\n    uint indexTargetAmBpt_\n  ) internal returns (uint amountOut) {\n    uint amountAmBpt = BalancerLogicLib.swap(\n      vault_,\n      poolId_,\n      address(p.tokens[p.bptIndex]),\n      address(p.tokens[indexTargetAmBpt_]),\n      bptAmountIn_,\n      funds\n    );\n    amountOut = swap(\n      vault_,\n      IBalancerBoostedAavePool(address(p.tokens[indexTargetAmBpt_])).getPoolId(),\n      address(p.tokens[indexTargetAmBpt_]),\n      IBalancerBoostedAavePool(address(p.tokens[indexTargetAmBpt_])).getMainToken(),\n      amountAmBpt,\n      funds\n    );\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorQuoteExit(\n    IBVault vault_,\n    IBalancerHelper helper_,\n    bytes32 poolId_,\n    uint liquidityAmount_\n  ) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n\n    // bpt - amount of unconverted bpt\n    // let's temporary save total amount of converted BPT there\n    (uint256 bpt, uint[] memory amountsBpt) = helper_.queryExit(\n      poolId_,\n      address(this),\n      payable(address(this)),\n      IBVault.ExitPoolRequest({\n    assets : asIAsset(p.tokens),\n    minAmountsOut : new uint[](p.len), // todo: no limits?\n    userData : abi.encode(\n        IBVault.ExitKindComposableStable.BPT_IN_FOR_EXACT_TOKENS_OUT,\n        BalancerLogicLib.getBtpAmountsOut(liquidityAmount_, p.balances, p.bptIndex),\n        liquidityAmount_\n      ),\n    toInternalBalance : false\n    })\n    );\n\n    // amount of unconverted bpt, we need to take them into account for correct calculation of investedAssets amount\n    bpt = bpt < liquidityAmount_\n    ? liquidityAmount_ - bpt\n    : 0;\n\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n    sender : address(this),\n    fromInternalBalance : false,\n    recipient : payable(address(this)),\n    toInternalBalance : false\n    });\n    IBVault.BatchSwapStep[] memory steps = new IBVault.BatchSwapStep[](p.len - 1);\n    IAsset[] memory assets = new IAsset[](2 * (p.len - 1));\n    uint k;\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      if (bpt != 0) {\n        // take into account the cost of unused BPT by directly converting them to first available amBPT\n        int[] memory deltas = _convertBptToAmBpt(vault_, poolId_, p.tokens[p.bptIndex], bpt, p.tokens[i], funds);\n        if (deltas[0] > 0) {\n          bpt = (bpt < uint(deltas[0]))\n          ? bpt - uint(deltas[0])\n          : 0;\n          amountsBpt[i] += (deltas[1] < 0)\n          ? uint(- deltas[1])\n          : 0;\n        }\n      }\n      IBalancerBoostedAavePool linearPool = IBalancerBoostedAavePool(address(p.tokens[i]));\n      steps[k].poolId = linearPool.getPoolId();\n      steps[k].assetInIndex = 2 * k + 1;\n      steps[k].assetOutIndex = 2 * k;\n      steps[k].amount = amountsBpt[i];\n\n      assets[2 * k] = IAsset(linearPool.getMainToken());\n      assets[2 * k + 1] = IAsset(address(p.tokens[i]));\n      ++k;\n    }\n\n    int[] memory assetDeltas = vault_.queryBatchSwap(IBVault.SwapKind.GIVEN_IN, steps, assets, funds);\n\n    amountsOut = new uint[](p.len - 1);\n    k = 0;\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      amountsOut[k] = assetDeltas[2 * k] < 0\n      ? uint256(- assetDeltas[2 * k])\n      : 0;\n\n      ++k;\n    }\n  }\n\n  function _convertBptToAmBpt(\n    IBVault vault_,\n    bytes32 poolId_,\n    IERC20 bptToken,\n    uint amountBpt,\n    IERC20 amBptToken,\n    IBVault.FundManagement memory funds\n  ) internal returns (\n    int[] memory assetDeltas\n  ) {\n    IAsset[] memory assets = new IAsset[](2);\n    assets[0] = IAsset(address(bptToken));\n    assets[1] = IAsset(address(amBptToken));\n\n    IBVault.BatchSwapStep[] memory steps = new IBVault.BatchSwapStep[](1);\n    steps[0].poolId = poolId_;\n    steps[0].assetInIndex = 0;\n    steps[0].assetOutIndex = 1;\n    steps[0].amount = amountBpt;\n\n    return vault_.queryBatchSwap(IBVault.SwapKind.GIVEN_IN, steps, assets, funds);\n  }\n\n  /// @notice Swap given {amountIn_} of {assetIn_} to {assetOut_} using the given BalanceR pool\n  function swap(\n    IBVault vault_,\n    bytes32 poolId_,\n    address assetIn_,\n    address assetOut_,\n    uint amountIn_,\n    IBVault.FundManagement memory funds_\n  ) internal returns (uint amountOut) {\n    uint balanceBefore = IERC20(assetOut_).balanceOf(address(this));\n\n    IERC20(assetIn_).approve(address(vault_), amountIn_);\n    vault_.swap(\n      IBVault.SingleSwap({\n    poolId : poolId_,\n    kind : IBVault.SwapKind.GIVEN_IN,\n    assetIn : IAsset(assetIn_),\n    assetOut : IAsset(assetOut_),\n    amount : amountIn_,\n    userData : bytes(\"\")\n    }),\n      funds_,\n      1,\n      block.timestamp\n    );\n\n    // we assume here, that the balance cannot be decreased\n    amountOut = IERC20(assetOut_).balanceOf(address(this)) - balanceBefore;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Rewards\n  /////////////////////////////////////////////////////////////////////\n\n  function depositorClaimRewards(IBalancerGauge gauge_, address[] memory rewardTokens_) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    uint len = rewardTokens_.length;\n\n    tokensOut = new address[](len);\n    amountsOut = new uint[](len);\n\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\n      tokensOut[i] = rewardTokens_[i];\n\n      // temporary store current reward balance\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this));\n    }\n\n    gauge_.claim_rewards();\n\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this)) - amountsOut[i];\n    }\n\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Utils\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Returns the address of a Pool's contract.\n  ///      Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\n  function getPoolAddress(bytes32 id) internal pure returns (address) {\n    // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\n    // since the logical shift already sets the upper bits to zero.\n    return address(uint160(uint(id) >> (12 * 8)));\n  }\n\n  /// @dev see balancer-labs, ERC20Helpers.sol\n  function asIAsset(IERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      assets := tokens\n    }\n  }\n}\n"
    },
    "contracts/strategies/ConverterStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\";\nimport \"./ConverterStrategyBaseLib.sol\";\nimport \"./ConverterStrategyBaseLib2.sol\";\nimport \"./DepositorBase.sol\";\n\n/////////////////////////////////////////////////////////////////////\n///                        TERMS\n///  Main asset == underlying: the asset deposited to the vault by users\n///  Secondary assets: all assets deposited to the internal pool except the main asset\n///  Base amounts: not rewards; amounts deposited to vault, amounts deposited after compound\n///                Base amounts can be converted one to another\n/////////////////////////////////////////////////////////////////////\n\n/// @title Abstract contract for base Converter strategy functionality\n/// @notice All depositor assets must be correlated (ie USDC/USDT/DAI)\n/// @author bogdoslav, dvpublic\nabstract contract ConverterStrategyBase is ITetuConverterCallback, DepositorBase, StrategyBaseV2 {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n\n  struct WithdrawUniversalLocal {\n    uint[] reserves;\n    uint totalSupply;\n    uint depositorLiquidity;\n    uint liquidityAmount;\n    uint assetPrice;\n    uint[] amountsToConvert;\n  }\n\n  struct RequirePayAmountBackLocal {\n    uint len;\n    address converter;\n    address[] tokens;\n    uint indexTheAsset;\n    uint theAssetBaseAmount;\n    uint[] withdrawnAmounts;\n    uint[] spentAmounts;\n    uint liquidity;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant CONVERTER_STRATEGY_BASE_VERSION = \"1.0.1\";\n\n  uint internal constant REINVEST_THRESHOLD_DENOMINATOR = 100_000;\n\n  /////////////////////////////////////////////////////////////////////\n  //                        VARIABLES\n  //                Keep names and ordering!\n  // Add only in the bottom and don't forget to decrease gap variable\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Amount of underlying assets invested to the pool.\n  uint internal _investedAssets;\n\n  /// @dev Linked Tetu Converter\n  ITetuConverter public converter;\n\n  /// @notice Minimum token amounts that can be liquidated\n  mapping(address => uint) public liquidationThresholds;\n\n  /// @notice Percent of asset amount that can be not invested, it's allowed to just keep it on balance\n  ///         decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\n  /// @dev We need this threshold to avoid numerous conversions of small amounts\n  uint public reinvestThresholdPercent;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        Events\n  /////////////////////////////////////////////////////////////////////\n  event LiquidationThresholdChanged(address token, uint amount);\n  event ReinvestThresholdPercentChanged(uint amount);\n  event ReturnAssetToConverter(address asset, uint amount);\n  event OnDepositorEnter(uint[] amounts, uint[] consumedAmounts);\n  event OnDepositorExit(uint liquidityAmount, uint[] withdrawnAmounts);\n  event OnDepositorEmergencyExit(uint[] withdrawnAmounts);\n\n  /// @notice Recycle was made\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\n  /// @param receivedAmounts Received amounts of the tokens\n  ///        This array has +1 item at the end: received amount of the main asset\n  /// @param spentAmounts Spent amounts of the tokens\n  /// @param amountsToForward Amounts to be sent to forwarder\n  event Recycle(\n    address[] rewardTokens,\n    uint[] receivedAmounts,\n    uint[] spentAmounts,\n    uint[] amountsToForward,\n    uint[] performanceAmounts\n  );\n\n  /////////////////////////////////////////////////////////////////////\n  //                Initialization and configuration\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __ConverterStrategyBase_init(\n    address controller_,\n    address splitter_,\n    address converter_\n  ) internal onlyInitializing {\n    __StrategyBase_init(controller_, splitter_);\n    converter = ITetuConverter(converter_);\n  }\n\n  function setLiquidationThreshold(address token, uint amount) external {\n    StrategyLib.onlyOperators(controller());\n    liquidationThresholds[token] = amount;\n    emit LiquidationThresholdChanged(token, amount);\n  }\n\n  /// @param percent_ New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\n  function setReinvestThresholdPercent(uint percent_) external {\n    StrategyLib.onlyOperators(controller());\n    require(percent_ <= REINVEST_THRESHOLD_DENOMINATOR, StrategyLib.WRONG_VALUE);\n\n    reinvestThresholdPercent = percent_;\n    emit ReinvestThresholdPercentChanged(percent_);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                     Deposit to the pool\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Amount of underlying assets converted to pool assets and invested to the pool.\n  function investedAssets() override public view virtual returns (uint) {\n    return _investedAssets;\n  }\n\n  /// @notice Deposit given amount to the pool.\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    int totalAssetsDelta\n  ){\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(updateTotalAssetsBeforeInvest_);\n    // skip deposit for small amounts\n    if (amount_ > reinvestThresholdPercent * updatedInvestedAssets / REINVEST_THRESHOLD_DENOMINATOR) {\n      (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n\n      // prepare array of amounts ready to deposit, borrow missed amounts\n      (uint[] memory amounts, uint[] memory borrowedAmounts, uint collateral) = _beforeDeposit(\n        converter,\n        amount_,\n        tokens,\n        indexAsset\n      );\n\n      // make deposit, actually consumed amounts can be different from the desired amounts\n      (uint[] memory consumedAmounts,) = _depositorEnter(amounts);\n      emit OnDepositorEnter(amounts, consumedAmounts);\n\n      // adjust base-amounts\n      _updateBaseAmounts(tokens, borrowedAmounts, consumedAmounts, indexAsset, - int(collateral));\n      // adjust _investedAssets\n      _updateInvestedAssets();\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///               Convert amounts before deposit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Prepare {tokenAmounts} to be passed to depositorEnter\n  /// @dev Override this function to customize entry kind\n  /// @param amount_ The amount of main asset that should be invested\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return tokenAmounts Amounts of depositor's assets ready to invest (this array can be passed to depositorEnter)\n  /// @return borrowedAmounts Amounts that were borrowed to prepare {tokenAmounts}\n  /// @return spentCollateral Total collateral spent to get {borrowedAmounts}\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) internal virtual returns (\n    uint[] memory tokenAmounts,\n    uint[] memory borrowedAmounts,\n    uint spentCollateral\n  ) {\n    // calculate required collaterals for each token and temporary save them to tokenAmounts\n    (uint[] memory weights, uint totalWeight) = _depositorPoolWeights();\n    // temporary save collateral to tokensAmounts\n    tokenAmounts = ConverterStrategyBaseLib.getCollaterals(\n      amount_,\n      tokens_,\n      weights,\n      totalWeight,\n      indexAsset_,\n      IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle()),\n      baseAmounts\n    );\n\n    // make borrow and save amounts of tokens available for deposit to tokenAmounts\n    (tokenAmounts, borrowedAmounts, spentCollateral) = ConverterStrategyBaseLib.getTokenAmounts(\n      tetuConverter_,\n      tokens_,\n      indexAsset_,\n      tokenAmounts,\n      liquidationThresholds[tokens_[indexAsset_]],\n      baseAmounts\n    );\n    return (tokenAmounts, borrowedAmounts, spentCollateral);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                     Withdraw from the pool\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Withdraw given amount from the pool.\n  /// @param amount Amount to be withdrawn in terms of the asset.\n  /// @return investedAssetsUSD The value that we should receive after withdrawing (in USD, decimals of the {asset})\n  /// @return assetPrice Price of the {asset} from the price oracle\n  /// @return totalAssetsDelta The {strategy} updates its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawFromPool(uint amount) override internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(true);\n\n    require(updatedInvestedAssets != 0, AppErrors.NO_INVESTMENTS);\n    (investedAssetsUSD, assetPrice) = _withdrawUniversal(amount, false, updatedInvestedAssets);\n  }\n\n  /// @notice Withdraw all from the pool.\n  /// @return investedAssetsUSD The value that we should receive after withdrawing\n  /// @return assetPrice Price of the {asset} taken from the price oracle\n  /// @return totalAssetsDelta The {strategy} updates its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawAllFromPool() override internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(true);\n\n    (investedAssetsUSD, assetPrice) = _withdrawUniversal(0, true, updatedInvestedAssets);\n  }\n\n  /// @param amount Amount to be withdrawn. 0 is ok if we withdraw all.\n  /// @param all Withdraw all\n  /// @param investedAssets_ Current amount of invested assets\n  /// @return __investedAssetsUSD The value that we should receive after withdrawing\n  /// @return __assetPrice Price of the {asset} taken from the price oracle\n  function _withdrawUniversal(uint amount, bool all, uint investedAssets_) internal returns (\n    uint __investedAssetsUSD,\n    uint __assetPrice\n  ) {\n\n    if ((all || amount != 0) && investedAssets_ != 0) {\n\n      address[] memory tokens = _depositorPoolAssets();\n      address _asset = asset;\n      uint indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, _asset);\n      ITetuConverter _converter = converter;\n\n      WithdrawUniversalLocal memory vars = WithdrawUniversalLocal({\n      reserves : _depositorPoolReserves(),\n      totalSupply : _depositorTotalSupply(),\n      depositorLiquidity : _depositorLiquidity(),\n      liquidityAmount : 0,\n      amountsToConvert : new uint[](0),\n      assetPrice : ConverterStrategyBaseLib.getAssetPriceFromConverter(_converter, _asset)\n      });\n\n      (vars.liquidityAmount, vars.amountsToConvert) = ConverterStrategyBaseLib.getLiquidityAmountRatio(\n        all ? 0 : amount,\n        baseAmounts,\n        address(this),\n        tokens,\n        indexAsset,\n        _converter,\n        investedAssets_,\n        vars.depositorLiquidity\n      );\n\n      uint[] memory withdrawnAmounts;\n      uint expectedAmountMainAsset;\n\n      if (vars.liquidityAmount != 0) {\n\n        // =============== WITHDRAW =====================\n        // make withdraw\n        withdrawnAmounts = _depositorExit(vars.liquidityAmount);\n        emit OnDepositorExit(vars.liquidityAmount, withdrawnAmounts);\n        // ==============================================\n\n        (expectedAmountMainAsset, vars.amountsToConvert) = ConverterStrategyBaseLib.postWithdrawActions(\n          vars.reserves,\n          vars.depositorLiquidity,\n          vars.liquidityAmount,\n          vars.totalSupply,\n          vars.amountsToConvert,\n          tokens,\n          indexAsset,\n          _converter,\n          _depositorLiquidity(),\n          withdrawnAmounts\n        );\n\n      } else {\n        // we don't need to withdraw any amounts from the pool, available converted amounts are enough for us\n        (withdrawnAmounts, expectedAmountMainAsset) = ConverterStrategyBaseLib.postWithdrawActionsEmpty(\n          tokens,\n          indexAsset,\n          _converter,\n          new uint[](tokens.length), // array with all zero values\n          vars.amountsToConvert\n        );\n      }\n\n      // convert amounts to main asset and update base amounts\n      (uint collateral, uint[] memory repaid) = _convertAfterWithdraw(tokens, indexAsset, vars.amountsToConvert, _converter);\n      _updateBaseAmounts(tokens, withdrawnAmounts, repaid, indexAsset, int(collateral));\n\n      // adjust _investedAssets\n      _updateInvestedAssets();\n\n      return (expectedAmountMainAsset * vars.assetPrice / 1e18, vars.assetPrice);\n    }\n    return (0, 0);\n  }\n\n  /// @notice If pool supports emergency withdraw need to call it for emergencyExit()\n  function _emergencyExitFromPool() override internal virtual {\n    uint[] memory withdrawnAmounts = _depositorEmergencyExit();\n    emit OnDepositorEmergencyExit(withdrawnAmounts);\n\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n\n    // convert amounts to main asset and update base amounts\n    (uint collateral, uint[] memory repaid) = _convertAfterWithdrawAll(tokens, indexAsset);\n    _updateBaseAmounts(tokens, withdrawnAmounts, repaid, indexAsset, int(collateral));\n\n    // adjust _investedAssets\n    _updateInvestedAssets();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///               Convert amounts after withdraw\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Convert all available amounts of {tokens_} to the main {asset}\n  /// @dev todo SCB-587\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return collateralOut Total amount of collateral returned after closing positions\n  /// @return repaidAmounts What amounts were spent in exchange of the {collateralOut}\n  function _convertAfterWithdrawAll(address[] memory tokens_, uint indexAsset_) internal returns (\n    uint collateralOut,\n    uint[] memory repaidAmounts\n  ){\n    uint[] memory amountsToConvert = ConverterStrategyBaseLib2.getAvailableBalances(tokens_, indexAsset_);\n\n    // convert amounts to the main asset\n    (collateralOut, repaidAmounts) = _convertAfterWithdraw(tokens_, indexAsset_, amountsToConvert, converter);\n  }\n\n  /// @notice Convert {amountsToConvert_} to the main {asset}\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return collateralOut Total amount of collateral returned after closing positions\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\n  function _convertAfterWithdraw(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_,\n    ITetuConverter _converter\n  ) internal returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.convertAfterWithdraw(\n      _converter,\n      ITetuLiquidator(IController(controller()).liquidator()),\n      liquidationThresholds[tokens_[indexAsset_]],\n      tokens_,\n      indexAsset_,\n      amountsToConvert_\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                 Update base amounts\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Update base amounts after withdraw\n  /// @param receivedAmounts_ Received amounts of not main-asset\n  /// @param spentAmounts_ Spent amounts of not main-asset\n  /// @param indexAsset_ Index of the asset in {tokens_} with different update logic (using {amountAsset_})\n  /// @param amountAsset_ Base amount of the asset with index indexAsset_ should be adjusted to {amountAsset_}\n  function _updateBaseAmounts(\n    address[] memory tokens_,\n    uint[] memory receivedAmounts_,\n    uint[] memory spentAmounts_,\n    uint indexAsset_,\n    int amountAsset_\n  ) internal {\n    uint len = tokens_.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      uint receivedAmount = receivedAmounts_[i];\n      uint spentAmount = spentAmounts_[i];\n      if (i == indexAsset_) {\n        if (amountAsset_ > 0) {\n          receivedAmount += uint(amountAsset_);\n        } else {\n          spentAmount += uint(- amountAsset_);\n        }\n      }\n      _updateBaseAmountsForAsset(tokens_[i], receivedAmount, spentAmount);\n    }\n  }\n\n  function _updateBaseAmountsForAsset(address asset_, uint received_, uint spent_) internal {\n    if (received_ > spent_) {\n      _increaseBaseAmount(asset_, received_ - spent_, _balance(asset_));\n    } else if (spent_ > received_) {\n      _decreaseBaseAmount(asset_, spent_ - received_);\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                 Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claim all possible rewards.\n  function _claim() override internal virtual {\n    // get rewards from the Depositor\n    (address[] memory depositorRewardTokens, uint[] memory depositorRewardAmounts) = _depositorClaimRewards();\n\n    (address[] memory rewardTokens, uint[] memory amounts) = ConverterStrategyBaseLib.prepareRewardsList(\n      converter,\n      _depositorPoolAssets(),\n      depositorRewardTokens,\n      depositorRewardAmounts,\n      baseAmounts\n    );\n\n    uint len = rewardTokens.length;\n    if (len > 0) {\n      (uint[] memory received, uint[] memory spent, uint[] memory amountsToForward) = _recycle(rewardTokens, amounts);\n\n      _updateBaseAmounts(rewardTokens, received, spent, type(uint).max, 0);\n      // max - we don't need to exclude any asset\n      // received has a length equal to rewardTokens.length + 1\n      // last item contains amount of the {asset} received after swapping\n      _updateBaseAmountsForAsset(asset, received[len], 0);\n\n      // send forwarder-part of the rewards to the forwarder\n      ConverterStrategyBaseLib2.sendTokensToForwarder(controller(), splitter, rewardTokens, amountsToForward);\n    }\n  }\n\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards divided on two parts: to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just added to baseAmounts\n  /// All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder.\n  /// @dev {_recycle} is implemented as separate (inline) function to simplify unit testing\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @return receivedAmounts Received amounts of the tokens\n  ///         This array has +1 item at the end: received amount of the main asset\n  ///                                            there was no possibility to use separate var for it, stack too deep\n  /// @return spentAmounts Spent amounts of the tokens\n  /// @return amountsToForward Amounts to be sent to forwarder\n  function _recycle(address[] memory rewardTokens_, uint[] memory rewardAmounts_) internal returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    // send performance-part of the rewards to performanceReceiver\n    (uint[] memory rewardAmounts, uint[] memory performanceAmounts) = ConverterStrategyBaseLib2.sendPerformanceFee(\n      performanceFee,\n      performanceReceiver,\n      rewardTokens_,\n      rewardAmounts_\n    );\n\n    // send other part of rewards to forwarder/compound\n    (receivedAmounts, spentAmounts, amountsToForward) = ConverterStrategyBaseLib.recycle(\n      asset,\n      compoundRatio,\n      _depositorPoolAssets(),\n      ITetuLiquidator(IController(controller()).liquidator()),\n      liquidationThresholds,\n      baseAmounts,\n      rewardTokens_,\n      rewardAmounts\n    );\n\n    emit Recycle(\n      rewardTokens_,\n      receivedAmounts,\n      spentAmounts,\n      amountsToForward,\n      performanceAmounts\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Hardwork\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice A virtual handler to make any action before hardwork\n  function _preHardWork(bool reInvest) internal virtual {}\n\n  /// @notice A virtual handler to make any action after hardwork\n  function _postHardWork() internal virtual {}\n\n  /// @notice Is strategy ready to hard work\n  function isReadyToHardWork() override external virtual view returns (bool) {\n    // check claimable amounts and compare with thresholds\n    return true;\n  }\n\n  /// @notice Do hard work\n  function doHardWork() override public returns (uint, uint) {\n    require(msg.sender == splitter, StrategyLib.DENIED);\n    return _doHardWork(true);\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  function _handleRewards() internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    uint assetBalanceBefore = _balance(asset);\n    _claim();\n    assetBalanceAfterClaim = _balance(asset);\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(assetBalanceBefore, assetBalanceAfterClaim, earned, lost);\n    return (earned, lost, assetBalanceAfterClaim);\n  }\n\n  /// @return earned Earned amount in terms of {asset}\n  /// @return lost Lost amount in terms of {asset}\n  function _doHardWork(bool reInvest) internal returns (uint earned, uint lost) {\n    uint investedAssetsBefore = _investedAssets;\n    uint investedAssetsLocal = _updateInvestedAssets();\n\n    _preHardWork(reInvest);\n\n    uint assetBalance;\n    (earned, lost, assetBalance) = _handleRewards();\n\n    // register autocompound income or possible lose if assets fluctuated\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(investedAssetsBefore, investedAssetsLocal, earned, lost);\n\n    // re-invest income\n    if (reInvest && assetBalance > reinvestThresholdPercent * investedAssetsLocal / REINVEST_THRESHOLD_DENOMINATOR) {\n      uint assetInUseBefore = investedAssetsLocal + assetBalance;\n      _depositToPool(assetBalance, false);\n\n      (earned, lost) = ConverterStrategyBaseLib.registerIncome(assetInUseBefore, _investedAssets + _balance(asset), earned, lost);\n    }\n\n    _postHardWork();\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///               InvestedAssets Calculations\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Updates cached _investedAssets to actual value\n  /// @dev Should be called after deposit / withdraw / claim; virtual - for ut\n  function _updateInvestedAssets() internal returns (uint investedAssetsOut) {\n    investedAssetsOut = _calcInvestedAssets();\n    _investedAssets = investedAssetsOut;\n  }\n\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return Invested asset amount under control (in terms of {asset})\n  function _calcInvestedAssets() internal returns (uint) {\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n    return ConverterStrategyBaseLib.calcInvestedAssets(\n      tokens,\n    // quote exit should check zero liquidity\n      _depositorQuoteExit(_depositorLiquidity()),\n      indexAsset,\n      converter,\n      baseAmounts\n    );\n  }\n\n  function calcInvestedAssets() external returns (uint) {\n    return _calcInvestedAssets();\n  }\n\n  /// @notice Update invested assets and return delta [new-investedAssets - old-investedAssets]\n  /// @param updateTotalAssetsBeforeInvest_ If false - skip update, return delta = 0\n  function _updateInvestedAssetsAndGetDelta(bool updateTotalAssetsBeforeInvest_) internal returns (\n    uint updatedInvestedAssets,\n    int totalAssetsDelta\n  ) {\n    uint __investedAssets = _investedAssets;\n\n    updatedInvestedAssets = updateTotalAssetsBeforeInvest_\n    ? _updateInvestedAssets()\n    : __investedAssets;\n\n    totalAssetsDelta = updateTotalAssetsBeforeInvest_\n    ? int(updatedInvestedAssets) - int(__investedAssets)\n    : int(0);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///               ITetuConverterCallback\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Converters asks to send some amount back.\n  /// @param theAsset_ Required asset (either collateral or borrow)\n  /// @param amount_ Required amount of the {theAsset_}\n  /// @return amountOut Amount sent to balance of TetuConverter, amountOut <= amount_\n  function requirePayAmountBack(address theAsset_, uint amount_) external override returns (uint amountOut) {\n    // todo move to library\n    RequirePayAmountBackLocal memory v;\n    v.converter = address(converter);\n    require(msg.sender == v.converter, StrategyLib.DENIED);\n\n    // detect index of the target asset\n    (v.tokens, v.indexTheAsset) = _getTokens(theAsset_);\n    require(v.indexTheAsset != type(uint).max, StrategyLib.WRONG_VALUE);\n    v.len = v.tokens.length;\n\n    // get amount of target asset available to be sent\n    v.theAssetBaseAmount = baseAmounts[theAsset_];\n\n    // follow array can be re-created below but it's safer to initialize them here\n    v.withdrawnAmounts = new uint[](v.len);\n    v.spentAmounts = new uint[](v.len);\n\n    // withdraw from the pool\n    if (v.theAssetBaseAmount < amount_) {\n      // the strategy doesn't have enough target asset on balance\n      // withdraw all from the pool but don't convert assets to underlying\n      v.liquidity = _depositorLiquidity();\n      if (v.liquidity != 0) {\n        v.withdrawnAmounts = _depositorExit(v.liquidity);\n        emit OnDepositorExit(v.liquidity, v.withdrawnAmounts);\n      }\n    }\n\n    // convert withdrawn assets to the target asset\n    if (v.theAssetBaseAmount + v.withdrawnAmounts[v.indexTheAsset] < amount_) {\n      (v.spentAmounts, v.withdrawnAmounts) = ConverterStrategyBaseLib.swapToGivenAmount(\n        amount_ - (v.theAssetBaseAmount + v.withdrawnAmounts[v.indexTheAsset]),\n        v.tokens,\n        v.indexTheAsset,\n        asset, // underlying === main asset\n        v.withdrawnAmounts,\n        ITetuConverter(v.converter),\n        ITetuLiquidator(IController(controller()).liquidator()),\n        liquidationThresholds[theAsset_],\n        ConverterStrategyBaseLib.OVERSWAP,\n        baseAmounts\n      );\n    }\n\n    // send amount to converter and update baseAmounts\n    amountOut = Math.min(v.theAssetBaseAmount + v.withdrawnAmounts[v.indexTheAsset], amount_);\n    IERC20(theAsset_).safeTransfer(v.converter, amountOut);\n    _updateBaseAmounts(v.tokens, v.withdrawnAmounts, v.spentAmounts, v.indexTheAsset, - int(amountOut));\n    // There are two cases of calling requirePayAmountBack by converter:\n    // 1) close a borrow: we will receive collateral back and amount of investedAssets almost won't change\n    // 2) rebalancing: we have real loss, it will be taken into account at next hard work\n    // So, _updateInvestedAssets() is not called here\n    emit ReturnAssetToConverter(theAsset_, amountOut);\n\n    // let's leave any leftovers un-invested, they will be reinvested at next hardwork\n  }\n\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external override {\n    uint len = assets_.length;\n    require(len == amounts_.length, AppErrors.INCORRECT_LENGTHS);\n\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\n      if (amounts_[i] != 0) {\n        _increaseBaseAmount(assets_[i], amounts_[i], _balance(assets_[i]));\n      }\n    }\n\n    // TetuConverter is able two call this function in two cases:\n    // 1) rebalancing (the health factor of some borrow is too low)\n    // 2) forcible closing of the borrow\n    // In both cases we update invested assets value here\n    // and avoid fixing any related losses in hardwork\n    _updateInvestedAssets();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                Others\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Unlimited capacity by default\n  function capacity() external virtual view returns (uint) {\n    return 2 ** 255;\n    // almost same as type(uint).max but more gas efficient\n  }\n\n  function _getTokens(address asset_) internal view returns (address[] memory tokens, uint indexAsset) {\n    tokens = _depositorPoolAssets();\n    indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, asset_);\n  }\n\n  /**\n* @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[46] private __gap;\n\n}\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppLib.sol\";\nimport \"../libs/TokenAmountsLib.sol\";\nimport \"../libs/ConverterEntryKinds.sol\";\n\nlibrary ConverterStrategyBaseLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\n  struct RecycleLocalParams {\n    uint amountToCompound;\n    uint amountToForward;\n    address rewardToken;\n    uint liquidationThresholdAsset;\n    uint len;\n    uint baseAmountIn;\n    uint totalRewardAmounts;\n    uint spentAmountIn;\n    uint receivedAmountOut;\n  }\n\n  struct OpenPositionLocal {\n    uint entryKind;\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n  }\n\n  struct OpenPositionEntryKind1Local {\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n    uint c1;\n    uint c3;\n    uint ratio;\n    uint alpha;\n  }\n\n  struct CalcInvestedAssetsLocal {\n    uint len;\n    uint[] prices;\n    uint[] decs;\n    uint[] debts;\n  }\n\n  struct ConvertAfterWithdrawLocalParams {\n    address asset;\n    uint collateral;\n    uint spentAmountIn;\n    uint receivedAmountOut;\n  }\n\n  struct SwapToGivenAmountInputParams {\n    uint targetAmount;\n    address[] tokens;\n    uint indexTargetAsset;\n    address underlying;\n    uint[] amounts;\n    ITetuConverter converter;\n    ITetuLiquidator liquidator;\n    uint liquidationThresholdForTargetAsset;\n    /// @notice Allow to swap more then required (i.e. 1_000 => +1%)\n    ///         to avoid additional swap if the swap return amount a bit less than we expected\n    uint overswap;\n  }\n\n  struct SwapToGivenAmountLocal {\n    uint len;\n    uint[] availableAmounts;\n    uint[] receivedAmounts;\n    uint i;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        Constants\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice approx one month for average block time 2 sec\n  uint internal constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\n  uint internal constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n  uint internal constant DENOMINATOR = 100_000;\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\n  uint internal constant PRICE_IMPACT_TOLERANCE = 300;\n  /// @notice borrow/collateral amount cannot be less than given number of tokens\n  uint internal constant DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD = 10;\n  /// @notice Allow to swap more then required (i.e. 1_000 => +1%) inside {swapToGivenAmount}\n  ///         to avoid additional swap if the swap will return amount a bit less than we expected\n  uint internal constant OVERSWAP = PRICE_IMPACT_TOLERANCE + _ASSET_LIQUIDATION_SLIPPAGE;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                         Events\n  /////////////////////////////////////////////////////////////////////\n  /// @notice A borrow was made\n  event OpenPosition(\n    address converter,\n    address collateralAsset,\n    uint collateralAmount,\n    address borrowAsset,\n    uint borrowedAmount,\n    address recepient\n  );\n\n  /// @notice Some borrow(s) was/were repaid\n  event ClosePosition(\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    address recepient,\n    uint returnedAssetAmountOut,\n    uint returnedBorrowAmountOut\n  );\n\n  /// @notice A liquidation was made\n  event Liquidation(\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint spentAmountIn,\n    uint receivedAmountOut\n  );\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      View functions\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Get amount of assets that we expect to receive after withdrawing\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\n  ///                  one of assets must be {asset_}\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\n  function getExpectedWithdrawnAmounts(\n    uint[] memory reserves_,\n    uint liquidityAmount_,\n    uint totalSupply_\n  ) internal pure returns (\n    uint[] memory withdrawnAmountsOut\n  ) {\n    uint ratio = totalSupply_ == 0\n      ? 0\n      : (liquidityAmount_ >= totalSupply_\n        ? 1e18\n        : 1e18 * liquidityAmount_ / totalSupply_\n    );\n    // we need brackets here for npm.run.coverage\n\n    uint len = reserves_.length;\n    withdrawnAmountsOut = new uint[](len);\n\n    if (ratio != 0) {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\n      }\n    }\n  }\n\n  /// @notice For each {token_} calculate a part of {amount_} to be used as collateral according to the weights.\n  ///         I.e. we have 300 USDC, we need to split it on 100 USDC, 100 USDT, 100 DAI\n  ///         USDC is main asset, USDT and DAI should be borrowed. We check amounts of USDT and DAI on the balance\n  ///         and return collaterals reduced on that amounts. For main asset, we return full amount always (100 USDC).\n  function getCollaterals(\n    uint amount_,\n    address[] memory tokens_,\n    uint[] memory weights_,\n    uint totalWeight_,\n    uint indexAsset_,\n    IPriceOracle priceOracle,\n    mapping(address => uint) storage baseAmounts_\n  ) external view returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    uint len = tokens_.length;\n    tokenAmountsOut = new uint[](len);\n\n    // get token prices and decimals\n    (uint[] memory prices, uint[] memory decs) = _getPricesAndDecs(priceOracle, tokens_, len);\n\n    // split the amount on tokens proportionally to the weights\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      uint amountAssetForToken = amount_ * weights_[i] / totalWeight_;\n\n      if (i == indexAsset_) {\n        tokenAmountsOut[i] = amountAssetForToken;\n      } else {\n        // if we have some tokens on balance then we need to use only a part of the collateral\n        uint tokenAmountToBeBorrowed = amountAssetForToken\n        * prices[indexAsset_]\n        * decs[i]\n        / prices[i]\n        / decs[indexAsset_];\n\n        uint tokenBalance = baseAmounts_[tokens_[i]];\n        if (tokenBalance < tokenAmountToBeBorrowed) {\n          tokenAmountsOut[i] = amountAssetForToken * (tokenAmountToBeBorrowed - tokenBalance) / tokenAmountToBeBorrowed;\n        }\n      }\n    }\n  }\n\n  /// @return prices Prices with decimals 18\n  /// @return decs 10**decimals\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\n    uint[] memory prices,\n    uint[] memory decs\n  ) {\n    prices = new uint[](len);\n    decs = new uint[](len);\n    {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\n      }\n    }\n  }\n\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\n    uint len = tokens_.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (tokens_[i] == asset_) {\n        return i;\n      }\n    }\n    return type(uint).max;\n  }\n\n  /// @notice Get a ratio to calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\n  ///         User needs to withdraw {targetAmount_} in main asset.\n  ///         There are two kinds of available liquidity:\n  ///         1) liquidity in the pool - {depositorLiquidity_}\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\n  ///         To withdraw {targetAmount_} we need\n  ///         1) Reconvert converted amounts back to main asset\n  ///         2) IF result amount is not necessary - withdraw some liquidity from the pool\n  ///            and also convert it to the main asset.\n  /// @dev This is a writable function with read-only behavior (because of the quote-call)\n  /// @param targetAmount_ Required amount of main asset to be withdrawn from the strategy\n  ///                      0 - withdraw all\n  /// @param baseAmounts_ Available balances of the converted assets\n  /// @param strategy_ Address of the strategy\n  function getLiquidityAmountRatio(\n    uint targetAmount_,\n    mapping(address => uint) storage baseAmounts_,\n    address strategy_,\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint investedAssets,\n    uint depositorLiquidity\n  ) external returns (\n    uint liquidityRatioOut,\n    uint[] memory amountsToConvertOut\n  ) {\n    bool all = targetAmount_ == 0;\n\n    uint len = tokens.length;\n    amountsToConvertOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n\n      uint baseAmount = baseAmounts_[tokens[i]];\n      if (baseAmount != 0) {\n        // let's estimate collateral that we received back after repaying baseAmount\n        uint expectedCollateral = converter.quoteRepay(\n          strategy_,\n          tokens[indexAsset],\n          tokens[i],\n          baseAmount\n        );\n\n        if (all || targetAmount_ != 0) {\n          // We always repay WHOLE available baseAmount even if it gives us much more amount then we need.\n          // We cannot repay a part of it because converter doesn't allow to know\n          // what amount should be repaid to get given amount of collateral.\n          // And it's too dangerous to assume that we can calculate this amount\n          // by reducing baseAmount proportionally to expectedCollateral/targetAmount_\n          amountsToConvertOut[i] = baseAmount;\n        }\n\n        if (targetAmount_ > expectedCollateral) {\n          targetAmount_ -= expectedCollateral;\n        } else {\n          targetAmount_ = 0;\n        }\n\n        if (investedAssets > expectedCollateral) {\n          investedAssets -= expectedCollateral;\n        } else {\n          investedAssets = 0;\n        }\n      }\n    }\n\n    require(all || investedAssets > 0, AppErrors.WITHDRAW_TOO_MUCH);\n\n    liquidityRatioOut = all\n      ? 1e18\n      : ((targetAmount_ == 0)\n        ? 0\n        : 1e18\n          * 101 // add 1% on top...\n          * targetAmount_ / investedAssets // a part of amount that we are going to withdraw\n          / 100 // .. add 1% on top\n    );\n\n    if (liquidityRatioOut != 0) {\n      // liquidityAmount temporary contains ratio...\n      liquidityRatioOut = liquidityRatioOut * depositorLiquidity / 1e18;\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Borrow and close positions\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  function openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdAmountIn_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return _openPosition(tetuConverter_, entryData_, collateralAsset_, borrowAsset_, amountIn_, thresholdAmountIn_);\n  }\n\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  /// @param thresholdAmountIn_ Min value of amountIn allowed for the second and subsequent conversions.\n  ///        0 - use default min value\n  ///        If amountIn becomes too low, no additional borrows are possible, so\n  ///        the rest amountIn is just added to collateral/borrow amount of previous conversion.\n  function _openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdAmountIn_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    if (thresholdAmountIn_ == 0) {\n      // zero threshold is not allowed because round-issues are possible, see openPosition.dust test\n      // we assume here, that it's useless to borrow amount using collateral/borrow amount\n      // less than given number of tokens (event for BTC)\n      thresholdAmountIn_ = DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD;\n    }\n    require(amountIn_ > thresholdAmountIn_, AppErrors.WRONG_VALUE);\n\n    OpenPositionLocal memory vars;\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\n    vars.entryKind = ConverterEntryKinds.getEntryKind(entryData_);\n    if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\n      return openPositionEntryKind1(\n        tetuConverter_,\n        entryData_,\n        collateralAsset_,\n        borrowAsset_,\n        amountIn_,\n        thresholdAmountIn_\n      );\n    } else {\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n        entryData_,\n        collateralAsset_,\n        amountIn_,\n        borrowAsset_,\n        _LOAN_PERIOD_IN_BLOCKS\n      );\n\n      uint len = vars.converters.length;\n      if (len > 0) {\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\n          vars.collateral;\n          vars.amountToBorrow;\n          if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\n            // we have exact amount of total collateral amount\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\n            ? amountIn_\n            : vars.collateralsRequired[i];\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\n            ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\n            : vars.amountsToBorrow[i];\n            amountIn_ -= vars.collateral;\n          } else {\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\n            // we have exact amount of total amount-to-borrow\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\n            ? amountIn_\n            : vars.amountsToBorrow[i];\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\n            ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\n            : vars.collateralsRequired[i];\n            amountIn_ -= vars.amountToBorrow;\n          }\n\n          if (amountIn_ < thresholdAmountIn_ && amountIn_ != 0) {\n            // dust amount is left, just leave it unused\n            // we cannot add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\n            amountIn_ = 0;\n          }\n\n          if (vars.amountToBorrow != 0) {\n            borrowedAmountOut += tetuConverter_.borrow(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n            collateralAmountOut += vars.collateral;\n            emit OpenPosition(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n          }\n\n          if (amountIn_ == 0) break;\n        }\n      }\n\n      return (collateralAmountOut, borrowedAmountOut);\n    }\n  }\n\n  /// @notice Open position using entry kind 1 - split provided amount on two parts according provided proportions\n  /// @param amountIn_ Amount of collateral to be divided on parts. We assume {amountIn_} > 0\n  /// @return collateralAmountOut Total collateral used to borrow {borrowedAmountOut}\n  /// @return borrowedAmountOut Total borrowed amount\n  function openPositionEntryKind1(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint collateralThreshold_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    OpenPositionEntryKind1Local memory vars;\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n      entryData_,\n      collateralAsset_,\n      amountIn_,\n      borrowAsset_,\n      _LOAN_PERIOD_IN_BLOCKS\n    );\n\n    uint len = vars.converters.length;\n    if (len > 0) {\n      // we should split amountIn on two amounts with proportions x:y\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\n      // calculate prices conversion ratio using price oracle, decimals 18\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\n\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\n        // and give us required proportions in result\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\n        // C1 is collateral amount left untouched (x)\n        // C2 is collateral amount converted to B2 (y)\n        // but if lending platform doesn't have enough liquidity\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        vars.ratio = (vars.collateralsRequired[i] + vars.c1) > amountIn_\n          ? 1e18 * amountIn_ / (vars.collateralsRequired[i] + vars.c1)\n          : 1e18;\n\n        vars.collateral = vars.collateralsRequired[i] * vars.ratio / 1e18;\n        vars.amountToBorrow = vars.amountsToBorrow[i] * vars.ratio / 1e18;\n\n        // skip any attempts to borrow zero amount or use too little collateral\n        if (vars.collateral < collateralThreshold_ || vars.amountToBorrow == 0) {\n          if (vars.collateralsRequired[i] + vars.c1 + collateralThreshold_ > amountIn_) {\n            // The lending platform has enough resources to make the borrow but amount of the borrow is too low\n            // Skip the borrow, leave leftover of collateral untouched\n            break;\n          } else {\n            // The lending platform doesn't have enough resources to make the borrow.\n            // We should try to make borrow on the next platform (if any)\n            continue;\n          }\n        }\n\n        require(\n          tetuConverter_.borrow(\n            vars.converters[i],\n            collateralAsset_,\n            vars.collateral,\n            borrowAsset_,\n            vars.amountToBorrow,\n            address(this)\n          ) == vars.amountToBorrow,\n          StrategyLib.WRONG_VALUE\n        );\n        emit OpenPosition(\n          vars.converters[i],\n          collateralAsset_,\n          vars.collateral,\n          borrowAsset_,\n          vars.amountToBorrow,\n          address(this)\n        );\n\n        borrowedAmountOut += vars.amountToBorrow;\n        collateralAmountOut += vars.collateral;\n\n        // calculate amount to be borrowed in the next converter\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        amountIn_ = (amountIn_ > vars.c1 + vars.collateral)\n          ? amountIn_ - (vars.c1 + vars.collateral)\n          : 0;\n\n        // protection against dust amounts, see \"openPosition.dust\", just leave dust amount unused\n        // we CAN NOT add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\n        if (amountIn_ < collateralThreshold_ || amountIn_ == 0) break;\n      }\n    }\n\n    return (collateralAmountOut, borrowedAmountOut);\n  }\n\n  /// @notice Get ratio18 = collateral / borrow\n  function _getCollateralToBorrowRatio(\n    ITetuConverter tetuConverter_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) internal view returns (uint){\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle());\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\n    return 1e18 * priceBorrow * 10 ** IERC20Metadata(collateralAsset_).decimals()\n    / priceCollateral / 10 ** IERC20Metadata(borrowAsset_).decimals();\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function _closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) internal returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n\n    // We shouldn't try to pay more than we actually need to repay\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\n    // Let's limit amountToRepay by needToRepay-amount\n    (uint needToRepay,) = tetuConverter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset);\n\n    uint amountRepay = amountToRepay < needToRepay\n    ? amountToRepay\n    : needToRepay;\n\n    // Make full/partial repayment\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\n    IERC20(borrowAsset).safeTransfer(address(tetuConverter_), amountRepay);\n    uint returnedBorrowAmountOut;\n\n    (returnedAssetAmountOut, returnedBorrowAmountOut,,) = tetuConverter_.repay(\n      collateralAsset,\n      borrowAsset,\n      amountRepay,\n      address(this)\n    );\n    emit ClosePosition(\n      collateralAsset,\n      borrowAsset,\n      amountRepay,\n      address(this),\n      returnedAssetAmountOut,\n      returnedBorrowAmountOut\n    );\n    uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\n\n    // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (dust tokens)\n    repaidAmountOut = balanceBefore > balanceAfter\n    ? balanceBefore - balanceAfter\n    : 0;\n\n    require(returnedBorrowAmountOut == 0, StrategyLib.WRONG_VALUE);\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                         Liquidation\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  function liquidate(\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdForTokenOut_\n  ) external returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    return _liquidate(liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdForTokenOut_);\n  }\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  function _liquidate(\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdForTokenOut_\n  ) internal returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\n\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\n\n    // calculate balance in out value for check threshold\n    uint amountOut = liquidator_.getPriceForRoute(route, amountIn_);\n\n    // if the expected value is higher than threshold distribute to destinations\n    if (amountOut > liquidationThresholdForTokenOut_) {\n      // we need to approve each time, liquidator address can be changed in controller\n      AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\n\n      uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\n\n      liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\n\n      // temporary save balance of token out after  liquidation to spentAmountIn\n      uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\n\n      // assign correct values to\n      receivedAmountOut = balanceAfter > balanceBefore\n      ? balanceAfter - balanceBefore\n      : 0;\n      spentAmountIn = amountIn_;\n\n      emit Liquidation(\n        tokenIn_,\n        tokenOut_,\n        amountIn_,\n        spentAmountIn,\n        receivedAmountOut\n      );\n    }\n\n    return (spentAmountIn, receivedAmountOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                 requirePayAmountBack\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Swap available {amounts_} of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\n  /// @param targetAmount_ Required amount of tokens[indexTheAsset_] that should be received by swap(s)\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param indexTargetAsset_ Index of target asset in tokens_ array\n  /// @param underlying_ Index of underlying\n  /// @param withdrawnAmounts_ Amounts withdrawn from the pool\n  /// @param liquidationThresholdForTargetAsset_ Liquidation thresholds for the target asset\n  /// @param overswap_ Allow to swap more then required (i.e. 1_000 => +1%)\n  ///                  to avoid additional swap if the swap return amount a bit less than we expected\n  /// @return spentAmounts Any amounts spent during the swaps\n  /// @return withdrawnAmountsOut withdrawnAmounts + any amounts received during the swaps\n  function swapToGivenAmount(\n    uint targetAmount_,\n    address[] memory tokens_,\n    uint indexTargetAsset_,\n    address underlying_,\n    uint[] memory withdrawnAmounts_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint liquidationThresholdForTargetAsset_,\n    uint overswap_,\n    mapping(address => uint) storage baseAmounts_\n  ) external returns (\n    uint[] memory spentAmounts,\n    uint[] memory withdrawnAmountsOut\n  ) {\n    SwapToGivenAmountLocal memory v;\n    v.len = tokens_.length;\n\n    spentAmounts = new uint[](v.len);\n    withdrawnAmountsOut = new uint[](v.len);\n\n    v.availableAmounts = new uint[](v.len);\n    for (; v.i < v.len; v.i = AppLib.uncheckedInc(v.i)) {\n      v.availableAmounts[v.i] = withdrawnAmounts_[v.i] + baseAmounts_[tokens_[v.i]];\n    }\n    (spentAmounts, v.receivedAmounts) = _swapToGivenAmount(\n      SwapToGivenAmountInputParams({\n        targetAmount: targetAmount_,\n        tokens: tokens_,\n        indexTargetAsset: indexTargetAsset_,\n        underlying: underlying_,\n        amounts: v.availableAmounts,\n        converter: converter_,\n        liquidator: liquidator_,\n        liquidationThresholdForTargetAsset: liquidationThresholdForTargetAsset_,\n        overswap: overswap_\n      })\n    );\n    for (v.i = 0; v.i < v.len; v.i = AppLib.uncheckedInc(v.i)) {\n      withdrawnAmountsOut[v.i] = withdrawnAmounts_[v.i] + v.receivedAmounts[v.i];\n    }\n  }\n\n  /// @notice Swap available {amounts_} of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\n  /// @return spentAmounts Any amounts spent during the swaps\n  /// @return receivedAmounts Any amounts received during the swaps\n  function _swapToGivenAmount(SwapToGivenAmountInputParams memory p) internal returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = p.tokens.length;\n    receivedAmounts = new uint[](v.len);\n    spentAmounts = new uint[](v.len);\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(p.converter.controller()).priceOracle()),\n      p.tokens,\n      v.len\n    );\n\n    // we need to swap other assets to the asset\n    // at first we should swap NOT underlying.\n    // if it would be not enough, we can swap underlying too.\n\n    // swap NOT underlying, initialize {indexUnderlying}\n    uint indexUnderlying;\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (p.underlying == p.tokens[i]) {\n        indexUnderlying = i;\n        continue;\n      }\n      if (p.indexTargetAsset == i) continue;\n\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, i);\n      spentAmounts[i] += spent;\n      receivedAmounts[p.indexTargetAsset] += received;\n\n      if (receivedAmounts[p.indexTargetAsset] >= p.targetAmount) break;\n    }\n\n    // swap underlying\n    if (receivedAmounts[p.indexTargetAsset] < p.targetAmount && p.indexTargetAsset != indexUnderlying) {\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, indexUnderlying);\n      spentAmounts[indexUnderlying] += spent;\n      receivedAmounts[p.indexTargetAsset] += received;\n    }\n  }\n\n  /// @notice Swap a part of amount of asset {tokens[indexTokenIn]} to {targetAsset} to get {targetAmount} in result\n  /// @param receivedTargetAmount Already received amount of {targetAsset} in previous swaps\n  /// @param indexTokenIn Index of the tokenIn in p.tokens\n  function _swapToGetAmount(\n    uint receivedTargetAmount,\n    SwapToGivenAmountInputParams memory p,\n    CalcInvestedAssetsLocal memory v,\n    uint indexTokenIn\n  ) internal returns (\n    uint amountSpent,\n    uint amountReceived\n  ) {\n    if (p.amounts[indexTokenIn] != 0) {\n      // we assume here, that p.targetAmount > receivedTargetAmount, see _swapToGivenAmount implementation\n\n      // calculate amount that should be swapped\n      // {overswap} allows to swap a bit more\n      // to avoid additional swaps if the swap will give us a bit less amount than expected\n      uint amountIn = (\n        (p.targetAmount - receivedTargetAmount)\n        * v.prices[p.indexTargetAsset] * v.decs[indexTokenIn]\n        / v.prices[indexTokenIn] / v.decs[p.indexTargetAsset]\n      ) * (p.overswap + DENOMINATOR) / DENOMINATOR;\n\n      (amountSpent, amountReceived) = _liquidate(\n        p.liquidator,\n        p.tokens[indexTokenIn],\n        p.tokens[p.indexTargetAsset],\n        Math.min(amountIn, p.amounts[indexTokenIn]),\n        _ASSET_LIQUIDATION_SLIPPAGE,\n        p.liquidationThresholdForTargetAsset\n      );\n    }\n\n    return (amountSpent, amountReceived);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      Recycle rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards are immediately \"recycled\".\n  /// It means, they are divided on two parts: to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just added to baseAmounts\n  /// All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder.\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @param liquidationThresholds_ Liquidation thresholds for rewards tokens\n  /// @param baseAmounts_ Base amounts for rewards tokens\n  ///                     The base amounts allow to separate just received and previously received rewards.\n  /// @return receivedAmounts Received amounts of the tokens\n  ///         This array has +1 item at the end: received amount of the main asset\n  ///                                            there was no possibility to use separate var for it, stack too deep\n  /// @return spentAmounts Spent amounts of the tokens\n  /// @return amountsToForward Amounts to be sent to forwarder\n  function recycle(\n    address asset_,\n    uint compoundRatio_,\n    address[] memory tokens_,\n    ITetuLiquidator liquidator_,\n    mapping(address => uint) storage liquidationThresholds_,\n    mapping(address => uint) storage baseAmounts_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_\n  ) external returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    (receivedAmounts, spentAmounts, amountsToForward) = _recycle(\n      asset_,\n      compoundRatio_,\n      tokens_,\n      liquidator_,\n      rewardTokens_,\n      rewardAmounts_,\n      liquidationThresholds_,\n      baseAmounts_\n    );\n  }\n\n  /// @dev Implementation of {recycle}\n  function _recycle(\n    address asset,\n    uint compoundRatio,\n    address[] memory tokens,\n    ITetuLiquidator liquidator,\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts,\n    mapping(address => uint) storage liquidationThresholds,\n    mapping(address => uint) storage baseAmounts\n  ) internal returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    RecycleLocalParams memory p;\n\n    p.len = rewardTokens.length;\n    require(p.len == rewardAmounts.length, AppErrors.WRONG_LENGTHS);\n\n    p.liquidationThresholdAsset = liquidationThresholds[asset];\n\n    amountsToForward = new uint[](p.len);\n    receivedAmounts = new uint[](p.len + 1);\n    spentAmounts = new uint[](p.len);\n\n    // split each amount on two parts: a part-to-compound and a part-to-transfer-to-the-forwarder\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      p.rewardToken = rewardTokens[i];\n      p.amountToCompound = rewardAmounts[i] * compoundRatio / COMPOUND_DENOMINATOR;\n\n      if (p.amountToCompound > 0) {\n        if (ConverterStrategyBaseLib.getAssetIndex(tokens, p.rewardToken) != type(uint).max) {\n          // The asset is in the list of depositor's assets, liquidation is not allowed\n          receivedAmounts[i] += p.amountToCompound;\n        } else {\n          p.baseAmountIn = baseAmounts[p.rewardToken];\n          // total amount that can be liquidated\n          p.totalRewardAmounts = p.amountToCompound + p.baseAmountIn;\n\n          if (p.totalRewardAmounts < liquidationThresholds[p.rewardToken]) {\n            // amount is too small, liquidation is not allowed\n            receivedAmounts[i] += p.amountToCompound;\n          } else {\n            // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\n            // We assume here, that {token} cannot be equal to {_asset}\n            // because the {_asset} is always included to the list of depositor's assets\n            (p.spentAmountIn, p.receivedAmountOut) = _liquidate(\n              liquidator,\n              p.rewardToken,\n              asset,\n              p.totalRewardAmounts,\n              _REWARD_LIQUIDATION_SLIPPAGE,\n              p.liquidationThresholdAsset\n            );\n\n            // Adjust amounts after liquidation\n            if (p.receivedAmountOut > 0) {\n              receivedAmounts[p.len] += p.receivedAmountOut;\n            }\n            if (p.spentAmountIn == 0) {\n              receivedAmounts[i] += p.amountToCompound;\n            } else {\n              require(p.spentAmountIn == p.amountToCompound + p.baseAmountIn, StrategyLib.WRONG_VALUE);\n              spentAmounts[i] += p.baseAmountIn;\n            }\n          }\n        }\n      }\n\n      p.amountToForward = rewardAmounts[i] - p.amountToCompound;\n      amountsToForward[i] = p.amountToForward;\n    }\n\n    return (receivedAmounts, spentAmounts, amountsToForward);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      calcInvestedAssets\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return amountOut Invested asset amount under control (in terms of {asset})\n  function calcInvestedAssets(\n    address[] memory tokens,\n    uint[] memory amountsOut,\n    uint indexAsset,\n    ITetuConverter converter_,\n    mapping(address => uint) storage baseAmounts\n  ) external returns (\n    uint amountOut\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = tokens.length;\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\n      tokens,\n      v.len\n    );\n\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\n        amountOut += amountsOut[i];\n      } else {\n        // available amount to repay\n        uint toRepay = baseAmounts[tokens[i]] + amountsOut[i];\n\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(address(this), tokens[indexAsset], tokens[i]);\n        amountOut += collateral;\n        if (toRepay >= toPay) {\n          amountOut += (toRepay - toPay) * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        } else {\n          // there is not enough amount to pay the debt\n          // let's register a debt and try to resolve it later below\n          if (v.debts.length == 0) {\n            // lazy initialization\n            v.debts = new uint[](v.len);\n          }\n          // to pay the following amount we need to swap some other asset at first\n          v.debts[i] = toPay - toRepay;\n        }\n      }\n    }\n\n    if (v.debts.length == v.len) {\n      // we assume here, that it would be always profitable to save collateral\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n        if (v.debts[i] == 0) continue;\n\n        // estimatedAssets should be reduced on the debt-value\n        uint debtInAsset = v.debts[i] * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        if (debtInAsset > amountOut) {\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\n          amountOut = 0;\n        } else {\n          amountOut -= debtInAsset;\n        }\n      }\n    }\n\n    return amountOut;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      getExpectedAmountMainAsset\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate expected amount of the main asset after withdrawing\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\n  /// @return amountOut Expected amount of the main asset\n  function getExpectedAmountMainAsset(\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint[] memory withdrawnAmounts_,\n    uint[] memory amountsToConvert_\n  ) internal returns (\n    uint amountOut\n  ) {\n    uint len = tokens.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        amountOut += withdrawnAmounts_[i];\n      } else {\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\n        if (amount != 0) {\n          amountOut += converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\n        }\n      }\n    }\n\n    return amountOut;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///              Reduce size of ConverterStrategyBase\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Make borrow and save amounts of tokens available for deposit to tokenAmounts\n  /// @param thresholdMainAsset_ Min allowed value of collateral in terms of main asset, 0 - use default min value\n  /// @return tokenAmountsOut Amounts available for deposit\n  /// @return borrowedAmounts Amounts borrowed for {spendCollateral}\n  /// @return spentCollateral Total collateral amount spent for borrowing\n  function getTokenAmounts(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory collaterals_,\n    uint thresholdMainAsset_,\n    mapping(address => uint) storage baseAmounts_\n  ) external returns (\n    uint[] memory tokenAmountsOut,\n    uint[] memory borrowedAmounts,\n    uint spentCollateral\n  ) {\n    // content of tokenAmounts will be modified in place\n    uint len = tokens_.length;\n    borrowedAmounts = new uint[](len);\n    tokenAmountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset_) {\n        tokenAmountsOut[i] = collaterals_[i];\n      } else {\n        if (collaterals_[i] > 0) {\n          uint collateral;\n          AppLib.approveIfNeeded(tokens_[indexAsset_], collaterals_[i], address(tetuConverter_));\n          (collateral, borrowedAmounts[i]) = _openPosition(\n            tetuConverter_,\n            \"\", // entry kind = 0: fixed collateral amount, max possible borrow amount\n            tokens_[indexAsset_],\n            tokens_[i],\n            collaterals_[i],\n            thresholdMainAsset_\n          );\n          // collateral should be equal to tokenAmounts[i] here because we use default entry kind\n          spentCollateral += collateral;\n\n          // zero amount are possible (conversion is not available) but it's not suitable for depositor\n          require(borrowedAmounts[i] != 0, AppErrors.ZERO_AMOUNT_BORROWED);\n        }\n        tokenAmountsOut[i] = baseAmounts_[tokens_[i]] + borrowedAmounts[i];\n      }\n    }\n\n    return (tokenAmountsOut, borrowedAmounts, spentCollateral);\n  }\n\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\n  /// @dev The post-processing is rewards conversion to the main asset\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens_ List of rewards claimed from the internal pool\n  /// @param rewardTokens_ Amounts of rewards claimed from the internal pool\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\n  /// @param amountsOut Amounts of available rewards\n  function prepareRewardsList(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_,\n    mapping(address => uint) storage baseAmounts_\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    // Rewards from TetuConverter\n    (address[] memory tokensTC, uint[] memory amountsTC) = tetuConverter_.claimRewards(address(this));\n\n    // Join arrays and recycle tokens\n    (tokensOut, amountsOut) = TokenAmountsLib.combineArrays(\n      rewardTokens_, rewardAmounts_,\n      tokensTC, amountsTC,\n      // by default, depositor assets have zero amounts here .. but probably they have airdrops (see below)\n      tokens_, new uint[](tokens_.length)\n    );\n\n    // Add airdrops\n    uint len = tokensOut.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      amountsOut[i] = IERC20(tokensOut[i]).balanceOf(address(this)) - baseAmounts_[tokensOut[i]];\n    }\n\n    // filter zero amounts out\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       WITHDRAW HELPERS\n  /////////////////////////////////////////////////////////////////////\n\n  function postWithdrawActions(\n    uint[] memory reserves,\n    uint depositorLiquidity,\n    uint liquidityAmount,\n    uint totalSupply,\n    uint[] memory amountsToConvert,\n\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n\n    uint _depositorLiquidityNew,\n    uint[] memory withdrawnAmounts\n  ) external returns (uint _expectedAmountMainAsset, uint[] memory _amountsToConvert){\n\n    // estimate, how many assets should be withdrawn\n    // the depositor is able to use less liquidity than it was asked\n    // (i.e. Balancer-depositor leaves some BPT unused)\n    // so, we need to fix liquidityAmount on this amount\n\n    // we assume here, that liquidity cannot increase in _depositorExit\n    uint depositorLiquidityDelta = depositorLiquidity - _depositorLiquidityNew;\n    if (liquidityAmount > depositorLiquidityDelta) {\n      liquidityAmount = depositorLiquidityDelta;\n    }\n\n    // now we can estimate expected amount of assets to be withdrawn\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\n      reserves,\n      liquidityAmount,\n      totalSupply\n    );\n\n    uint expectedAmountMainAsset = getExpectedAmountMainAsset(\n      tokens,\n      indexAsset,\n      converter,\n      expectedWithdrawAmounts,\n      amountsToConvert\n    );\n    for (uint i; i < tokens.length; i = AppLib.uncheckedInc(i)) {\n      amountsToConvert[i] += withdrawnAmounts[i];\n    }\n\n    return (expectedAmountMainAsset, amountsToConvert);\n  }\n\n  function postWithdrawActionsEmpty(\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint[] memory withdrawnAmounts_,\n    uint[] memory amountsToConvert_\n  ) external returns (uint[] memory withdrawnAmounts, uint expectedAmountMainAsset){\n    withdrawnAmounts = withdrawnAmounts_;\n    expectedAmountMainAsset = getExpectedAmountMainAsset(\n      tokens,\n      indexAsset,\n      converter,\n      withdrawnAmounts_,\n      amountsToConvert_\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      convertAfterWithdraw\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Convert {p.amountsToConvert_} to the main asset\n  /// @return collateralOut Total amount of collateral returned after closing positions\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\n  function convertAfterWithdraw(\n    ITetuConverter tetuConverter,\n    ITetuLiquidator liquidator,\n    uint liquidationThreshold,\n    address[] memory tokens,\n    uint indexAsset,\n    uint[] memory amountsToConvert\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    ConvertAfterWithdrawLocalParams memory vars;\n    vars.asset = tokens[indexAsset];\n\n    uint len = tokens.length;\n    repaidAmountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n      (vars.collateral, repaidAmountsOut[i]) = _closePosition(\n        tetuConverter,\n        vars.asset,\n        tokens[i],\n        amountsToConvert[i]\n      );\n      collateralOut += vars.collateral;\n    }\n\n    // Manually swap remain leftovers\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n      if (amountsToConvert[i] > repaidAmountsOut[i]) {\n        (vars.spentAmountIn, vars.receivedAmountOut) = _liquidate(\n          liquidator,\n          tokens[i],\n          vars.asset,\n          amountsToConvert[i] - repaidAmountsOut[i],\n          _ASSET_LIQUIDATION_SLIPPAGE,\n          liquidationThreshold\n        );\n        if (vars.receivedAmountOut != 0) {\n          collateralOut += vars.receivedAmountOut;\n        }\n        if (vars.spentAmountIn != 0) {\n          repaidAmountsOut[i] += vars.spentAmountIn;\n          require(\n            tetuConverter.isConversionValid(\n              tokens[i],\n              vars.spentAmountIn,\n              vars.asset,\n              vars.receivedAmountOut,\n              PRICE_IMPACT_TOLERANCE\n            ),\n            AppErrors.PRICE_IMPACT\n          );\n        }\n      }\n    }\n\n    return (collateralOut, repaidAmountsOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       OTHER HELPERS\n  /////////////////////////////////////////////////////////////////////\n\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\n    return IPriceOracle(IConverterController(converter.controller()).priceOracle()).getAssetPrice(token);\n  }\n\n  function registerIncome(\n    uint assetBefore,\n    uint assetAfter,\n    uint earned,\n    uint lost\n  ) internal pure returns (uint _earned, uint _lost) {\n    if (assetAfter > assetBefore) {\n      earned += assetAfter - assetBefore;\n    } else {\n      lost += assetBefore - assetAfter;\n    }\n    return (earned, lost);\n  }\n\n}\n\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"../libs/AppErrors.sol\";\nimport \"../libs/AppLib.sol\";\nimport \"../libs/TokenAmountsLib.sol\";\nimport \"../libs/ConverterEntryKinds.sol\";\n\n/// @notice Continuation of ConverterStrategyBaseLib (workaround for size limits)\nlibrary ConverterStrategyBaseLib2 {\n  using SafeERC20 for IERC20;\n  uint internal constant DENOMINATOR = 100_000;\n\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\n  function getAvailableBalances(\n    address[] memory tokens_,\n    uint indexAsset\n  ) external view returns (uint[] memory) {\n    uint len = tokens_.length;\n    uint[] memory amountsToConvert = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this)); // todo baseAmounts??\n    }\n    return amountsToConvert;\n  }\n  /// @notice Send {performanceFee_} of {rewardAmounts_} to {performanceReceiver}\n  /// @param performanceFee_ Max is FEE_DENOMINATOR\n  /// @return rewardAmounts = rewardAmounts_ - performanceAmounts\n  /// @return performanceAmounts Theses amounts were sent to {performanceReceiver_}\n  function sendPerformanceFee(\n    uint performanceFee_,\n    address performanceReceiver_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_\n  ) external returns (\n    uint[] memory rewardAmounts,\n    uint[] memory performanceAmounts\n  ) {\n    // we assume that performanceFee_ <= FEE_DENOMINATOR and we don't need to check it here\n    uint len = rewardAmounts_.length;\n    rewardAmounts = new uint[](len);\n    performanceAmounts = new uint[](len);\n\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\n      performanceAmounts[i] = rewardAmounts_[i] * performanceFee_ / DENOMINATOR;\n      rewardAmounts[i] = rewardAmounts_[i] - performanceAmounts[i];\n      IERC20(rewardTokens_[i]).safeTransfer(performanceReceiver_, performanceAmounts[i]);\n    }\n  }\n\n  function sendTokensToForwarder(\n    address controller_,\n    address splitter_,\n    address[] memory tokens_,\n    uint[] memory amounts_\n  ) external {\n    uint len = tokens_.length;\n    IForwarder forwarder = IForwarder(IController(controller_).forwarder());\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      AppLib.approveIfNeeded(tokens_[i], amounts_[i], address(forwarder));\n    }\n\n    forwarder.registerIncome(tokens_, amounts_, ISplitter(splitter_).vault(), true);\n  }\n}\n\n"
    },
    "contracts/strategies/DepositorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../helpers/ERC20Helpers.sol\";\n\n/// @title Abstract base Depositor contract.\n/// @notice Converter strategies should inherit xDepositor.\n/// @notice All communication with external pools should be done at inherited contract\n/// @author bogdoslav\nabstract contract DepositorBase is ERC20Helpers {\n\n  /// @notice Returns pool assets\n  function _depositorPoolAssets() internal virtual view returns (address[] memory assets);\n\n  /// @notice Returns pool token proportions\n  function _depositorPoolWeights() internal virtual view returns (uint[] memory weights, uint total);\n\n  /// @notice Returns pool token reserves\n  function _depositorPoolReserves() internal virtual view returns (uint[] memory reserves);\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() internal virtual view returns (uint);\n\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() internal view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @dev Depositor must care about tokens approval by itself.\n  function _depositorEnter(uint[] memory amountsDesired_) internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  );\n\n  /// @notice Withdraw given lp amount from the pool.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @notice Quotes output for given lp amount from the pool.\n  /// @dev Write function with read-only behavior. BalanceR's depositor requires not-view.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorQuoteExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @dev If pool supports emergency withdraw need to call it for emergencyExit()\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorEmergencyExit() internal virtual returns (uint[] memory amountsOut) {\n    return _depositorExit(_depositorLiquidity());\n  }\n\n  /// @notice Claim all possible rewards.\n  function _depositorClaimRewards() internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts\n  );\n}\n"
    },
    "contracts/strategies/tetu-v1/ExternalRateProvider.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC4626.sol\";\nimport \"../../integrations/balancer/IRateProvider.sol\";\n\n/// @dev Rete provider which uses external rate provider to calculate rate.\n///      It is used to calculate rate for tokens like stMatic. We have external rate for MATIC/stMatic.\n/// @author AlehNat\ncontract ExternalRateProvider is IRateProvider {\n\n  // underlying asset\n  address public immutable asset;\n\n  // ERC4626 vault\n  address public immutable vault;\n\n  // external rate provider\n  address public immutable externalRateProvider;\n\n  constructor(address _asset, address _vault, address _externalRateProvider) {\n    require(_asset != address(0) && _vault != address(0) && _externalRateProvider != address(0), 'mandatory params');\n    asset = _asset;\n    vault = _vault;\n    externalRateProvider = _externalRateProvider;\n  }\n\n  function getRate() external view override returns (uint256) {\n    uint assetPrecision = 10 ** IERC20Metadata(asset).decimals();\n    return IERC4626(vault).convertToAssets(assetPrecision) * IRateProvider(externalRateProvider).getRate() / assetPrecision;\n  }\n\n}\n"
    },
    "contracts/strategies/tetu-v1/TetuV1SingleTokenStrictStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyStrictBase.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"../../integrations/tetu-v1/ISmartVault.sol\";\nimport \"../../libs/AppLib.sol\";\nimport \"../../helpers/ERC20Helpers.sol\";\nimport \"../../integrations/balancer/IRateProvider.sol\";\n\n/// @title Simple auto compounding strategy for TETU V1 vaults.\n/// @author AlehNat\ncontract TetuV1SingleTokenStrictStrategy is StrategyStrictBase, IRateProvider, ERC20Helpers {\n  using SafeERC20 for IERC20;\n\n  string public constant override NAME = \"TetuV1 Single Token Strict Strategy\";\n  string public constant override PLATFORM = \"TETU\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  uint private constant _ASSET_LIQUIDATION_SLIPPAGE = 5000; // 5%\n\n  // in this strategy TETU V1 vault is used as a pool\n  ISmartVault public immutable pool;\n  ITetuLiquidator public immutable liquidator;\n  address public immutable xTetuAddress;\n\n  bool public override isReadyToHardWork;\n\n  constructor(address _pool, address _liquidator, address _xTetuAddress) {\n    require(_pool != address(0) && _liquidator != address(0) && _xTetuAddress != address(0), '!address');\n    pool = ISmartVault(_pool);\n    liquidator = ITetuLiquidator(_liquidator);\n    xTetuAddress = _xTetuAddress;\n    isReadyToHardWork = true;\n  }\n\n\n  // uint earned, uint lost is it in USD?\n  function doHardWork() external override returns (uint earned, uint lost) {\n    // if we have some asset in the strategy we need to deposit it to the pool to not liquidate it.\n    uint assetBalanceBeforeClaim = _balance(asset);\n    if (assetBalanceBeforeClaim > 0) {\n      _depositToPool(assetBalanceBeforeClaim);\n    }\n\n    uint strategyBalanceBefore = pool.underlyingBalanceWithInvestmentForHolder(address(this));\n\n    _claim();\n    _unwrapXTetu();\n    _liquidateReward();\n    uint assetBalance = _balance(asset);\n    if (assetBalance > 0) {\n      _depositToPool(assetBalance);\n    }\n    earned = 0;\n    lost = 0;\n\n    uint strategyBalanceAfter = pool.underlyingBalanceWithInvestmentForHolder(address(this));\n\n    if (strategyBalanceAfter > strategyBalanceBefore) {\n      earned = strategyBalanceAfter - strategyBalanceBefore;\n    } else {\n      lost = strategyBalanceBefore - strategyBalanceAfter;\n    }\n  }\n\n  /// @dev Deposit given amount to the pool.\n  function _depositToPool(uint amount) internal override {\n    IERC20(asset).safeIncreaseAllowance(address(pool), amount);\n    pool.depositAndInvest(amount);\n  }\n\n  /// @dev Withdraw given amount from the pool.\n  /// @return investedAssetsUSD and assetPrice are not used in this strategy (0,0)\n  function _withdrawFromPool(uint amount) internal override returns (uint investedAssetsUSD, uint assetPrice) {\n    pool.withdraw(amount);\n    return (0, 0);\n  }\n\n  /// @dev Withdraw all from the pool.\n  /// @return investedAssetsUSD and assetPrice are not used in this strategy returns (0,0)\n  function _withdrawAllFromPool() internal override returns (uint investedAssetsUSD, uint assetPrice) {\n    uint totalBalance = _balance(address(pool));\n    return _withdrawFromPool(totalBalance);\n  }\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  ///      Withdraw assets without impact checking.\n  function _emergencyExitFromPool() internal override {\n    _withdrawAllFromPool();\n  }\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal override {\n    pool.getAllRewards();\n  }\n\n  function _unwrapXTetu() internal {\n    uint xTetuBalance = _balance(xTetuAddress);\n    if (xTetuBalance > 0) {\n      ISmartVault(xTetuAddress).withdraw(xTetuBalance);\n    }\n  }\n\n  function _liquidateReward() internal {\n    address [] memory rewardTokens = pool.rewardTokens();\n    for (uint i = 0; i < rewardTokens.length; i = AppLib.uncheckedInc(i)) {\n      address rewardToken = rewardTokens[i];\n      uint rewardBalance = _balance(rewardToken);\n      if (rewardBalance > 0) {\n        IERC20(rewardToken).safeIncreaseAllowance(address(liquidator), rewardBalance);\n        liquidator.liquidate(rewardToken, asset, rewardBalance, _ASSET_LIQUIDATION_SLIPPAGE);\n      }\n    }\n  }\n\n  function getRate() external view override returns (uint256) {\n    uint assetPrecision = 10 ** IERC20Metadata(asset).decimals();\n    return IERC4626(vault).convertToAssets(assetPrecision) * 1e18 / assetPrecision;\n  }\n\n  function investedAssets() public view override returns (uint) {\n    return pool.underlyingBalanceWithInvestmentForHolder(address(this));\n  }\n\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3ConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./UniswapV3Depositor.sol\";\nimport \"./UniswapV3ConverterStrategyLogicLib.sol\";\nimport \"../../libs/AppPlatforms.sol\";\n\n/// @title Delta-neutral liquidity hedging converter fill-up/swap rebalancing strategy for UniswapV3\n/// @notice This strategy provides delta-neutral liquidity hedging for Uniswap V3 pools. It rebalances the liquidity\n///         by utilizing fill-up and swap methods depending on the range size of the liquidity provided.\n///         It also attempts to cover rebalancing losses with rewards.\n/// @author a17\ncontract UniswapV3ConverterStrategy is UniswapV3Depositor, ConverterStrategyBase {\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  string public constant override NAME = \"UniswapV3 Converter Strategy\";\n  string public constant override PLATFORM = AppPlatforms.UNIV3;\n  string public constant override STRATEGY_VERSION = \"1.1.0\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                INIT\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize the strategy with the given parameters.\n  /// @param controller_ The address of the controller.\n  /// @param splitter_ The address of the splitter.\n  /// @param converter_ The address of the converter.\n  /// @param pool_ The address of the pool.\n  /// @param tickRange_ The tick range for the liquidity position.\n  /// @param rebalanceTickRange_ The tick range for rebalancing.\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address pool_,\n    int24 tickRange_,\n    int24 rebalanceTickRange_\n  ) external initializer {\n    __UniswapV3Depositor_init(ISplitter(splitter_).asset(), pool_, tickRange_, rebalanceTickRange_);\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n    UniswapV3ConverterStrategyLogicLib.initStrategyState(state, controller_, converter_);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                OPERATOR ACTIONS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Disable fuse for the strategy.\n  function disableFuse() external {\n    StrategyLib.onlyOperators(controller());\n    state.isFuseTriggered = false;\n\n    UniswapV3ConverterStrategyLogicLib.emitDisableFuse();\n  }\n\n  /// @notice Set the fuse threshold for the strategy.\n  /// @param newFuseThreshold The new fuse threshold value.\n  function setFuseThreshold(uint newFuseThreshold) external {\n    StrategyLib.onlyOperators(controller());\n    state.fuseThreshold = newFuseThreshold;\n\n    UniswapV3ConverterStrategyLogicLib.emitNewFuseThreshold(newFuseThreshold);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   METRIC VIEWS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Check if the strategy is ready for hard work.\n  /// @return A boolean indicating if the strategy is ready for hard work.\n  function isReadyToHardWork() override external virtual view returns (bool) {\n    return UniswapV3ConverterStrategyLogicLib.isReadyToHardWork(state, converter);\n  }\n\n  /// @notice Check if the strategy needs rebalancing.\n  /// @return A boolean indicating if the strategy needs rebalancing.\n  function needRebalance() external view returns (bool) {\n    return UniswapV3ConverterStrategyLogicLib.needRebalance(\n      state.isFuseTriggered,\n      state.pool,\n      state.lowerTick,\n      state.upperTick,\n      state.tickSpacing,\n      state.rebalanceTickRange\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   REBALANCE\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev The rebalancing functionality is the core of this strategy.\n  ///      Depending on the size of the range of liquidity provided, the Fill-up or Swap method is used.\n  ///      There is also an attempt to cover rebalancing losses with rewards.\n  function rebalance() external {\n    address _controller = controller();\n    StrategyLib.onlyOperators(_controller);\n\n    /// @dev withdraw all liquidity from pool with adding calculated fees to rebalanceEarned0, rebalanceEarned1\n    _depositorEmergencyExit();\n\n    (\n    uint[] memory tokenAmounts, // _depositorEnter(tokenAmounts) if length == 2\n    bool isNeedFillup\n    ) = UniswapV3ConverterStrategyLogicLib.rebalance(\n      state,\n      converter,\n      _controller,\n      investedAssets()\n    );\n\n    if (tokenAmounts.length == 2) {\n      _depositorEnter(tokenAmounts);\n\n      //add fill-up liquidity part of fill-up is used\n      if (isNeedFillup) {\n        (state.lowerTickFillup, state.upperTickFillup, state.totalLiquidityFillup) = UniswapV3ConverterStrategyLogicLib.addFillup(\n          state.pool,\n          state.lowerTick,\n          state.upperTick,\n          state.tickSpacing,\n          state.rebalanceEarned0,\n          state.rebalanceEarned1\n        );\n      }\n    }\n\n    (\n    uint receivedA,\n    uint spentA,\n    uint receivedB,\n    uint spentB\n    ) = UniswapV3ConverterStrategyLogicLib.getUpdateInfo(state, baseAmounts);\n\n    _updateBaseAmountsForAsset(\n      state.tokenA,\n      receivedA,\n      spentA\n    );\n    _updateBaseAmountsForAsset(\n      state.tokenB,\n      receivedB,\n      spentB\n    );\n\n    //updating investedAssets based on new baseAmounts\n    _updateInvestedAssets();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   INTERNAL LOGIC\n  /////////////////////////////////////////////////////////////////////\n\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory /*tokens_*/,\n    uint /*indexAsset_*/\n  ) override internal virtual returns (\n    uint[] memory tokenAmounts,\n    uint[] memory borrowedAmounts,\n    uint spentCollateral\n  ) {\n    tokenAmounts = new uint[](2);\n    borrowedAmounts = new uint[](2);\n\n    bytes memory entryData = UniswapV3ConverterStrategyLogicLib.getEntryData(\n      state.pool,\n      state.lowerTick,\n      state.upperTick,\n      state.tickSpacing,\n      state.depositorSwapTokens\n    );\n\n    AppLib.approveIfNeeded(state.tokenA, amount_, address(tetuConverter_));\n    (spentCollateral, borrowedAmounts[1]) = ConverterStrategyBaseLib.openPosition(\n      tetuConverter_,\n      entryData,\n      state.tokenA,\n      state.tokenB,\n      amount_,\n      0\n    );\n\n    tokenAmounts[0] = amount_ - spentCollateral;\n    tokenAmounts[1] = borrowedAmounts[1];\n\n    return (tokenAmounts, borrowedAmounts, spentCollateral);\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  /// @return earned The amount of earned rewards.\n  /// @return lost The amount of lost rewards.\n  /// @return assetBalanceAfterClaim The asset balance after claiming rewards.\n  function _handleRewards() override internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    earned = UniswapV3ConverterStrategyLogicLib.calcEarned(state);\n    _claim();\n    assetBalanceAfterClaim = _balance(asset);\n    if (state.rebalanceLost > 0) {\n      lost = state.rebalanceLost;\n      state.rebalanceLost = 0;\n    }\n    return (earned, lost, assetBalanceAfterClaim);\n  }\n\n  /// @notice Withdraw given amount from the pool.\n  /// @param amount Amount to be withdrawn in terms of the asset.\n  /// @return investedAssetsUSD The value that we should receive after withdrawing (in USD, decimals of the {asset})\n  /// @return assetPrice Price of the {asset} from the price oracle\n  /// @return totalAssetsDelta The {strategy} updates its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawFromPool(uint amount) override internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(true);\n    require(updatedInvestedAssets != 0, AppErrors.NO_INVESTMENTS);\n    (investedAssetsUSD, assetPrice) = _withdrawUniversal(amount, false, updatedInvestedAssets);\n  }\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amount_ The amount to be deposited.\n  /// @param updateTotalAssetsBeforeInvest_ A boolean indicating if the total assets should be updated before investing.\n  /// @return totalAssetsDelta The change in total assets after the deposit.\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    int totalAssetsDelta\n  ) {\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(updateTotalAssetsBeforeInvest_);\n\n    // skip deposit for small amounts\n    if (amount_ > reinvestThresholdPercent * updatedInvestedAssets / REINVEST_THRESHOLD_DENOMINATOR) {\n      if (state.isFuseTriggered) {\n        uint[] memory tokenAmounts = new uint[](2);\n        tokenAmounts[0] = amount_;\n        emit OnDepositorEnter(tokenAmounts, tokenAmounts);\n        _updateBaseAmountsForAsset(state.tokenA, amount_, 0);\n      } else {\n        (address[] memory tokens, uint indexAsset) = _getTokens(asset);\n\n        // prepare array of amounts ready to deposit, borrow missed amounts\n        (uint[] memory amounts, uint[] memory borrowedAmounts, uint collateral) = _beforeDeposit(\n          converter,\n          amount_,\n          tokens,\n          indexAsset\n        );\n\n        // make deposit, actually consumed amounts can be different from the desired amounts\n        (uint[] memory consumedAmounts,) = _depositorEnter(amounts);\n        emit OnDepositorEnter(amounts, consumedAmounts);\n\n        // adjust base-amounts\n        _updateBaseAmounts(tokens, borrowedAmounts, consumedAmounts, indexAsset, - int(collateral));\n      }\n\n      // adjust _investedAssets\n      _updateInvestedAssets();\n    }\n  }\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3ConverterStrategyLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./UniswapV3Lib.sol\";\nimport \"./UniswapV3DebtLib.sol\";\n\nlibrary UniswapV3ConverterStrategyLogicLib {\n\n  //////////////////////////////////////////\n  //            CONSTANTS\n  //////////////////////////////////////////\n\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_STABLE = 100;\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE = 500;\n  uint internal constant HARD_WORK_USD_FEE_THRESHOLD = 100;\n  uint public constant DEFAULT_FUSE_THRESHOLD = 5e15;\n\n  //////////////////////////////////////////\n  //            EVENTS\n  //////////////////////////////////////////\n\n  event FuseTriggered();\n  event Rebalanced();\n  event DisableFuse();\n  event NewFuseThreshold(uint newFuseThreshold);\n\n  //////////////////////////////////////////\n  //            STRUCTURES\n  //////////////////////////////////////////\n\n  struct State {\n    address tokenA;\n    address tokenB;\n    IUniswapV3Pool pool;\n    int24 tickSpacing;\n    bool fillUp;\n    bool isStablePool;\n    int24 lowerTick;\n    int24 upperTick;\n    int24 lowerTickFillup;\n    int24 upperTickFillup;\n    int24 rebalanceTickRange;\n    bool depositorSwapTokens;\n    uint128 totalLiquidity;\n    uint128 totalLiquidityFillup;\n    uint rebalanceEarned0;\n    uint rebalanceEarned1;\n    uint rebalanceLost;\n    bool isFuseTriggered;\n    uint fuseThreshold;\n    uint lastPrice;\n  }\n\n  struct TryCoverLossParams {\n    IUniswapV3Pool pool;\n    address tokenA;\n    address tokenB;\n    bool depositorSwapTokens;\n    uint fee0;\n    uint fee1;\n    uint oldInvestedAssets;\n  }\n\n  struct RebalanceLocalVariables {\n    int24 upperTick;\n    int24 lowerTick;\n    int24 tickSpacing;\n    IUniswapV3Pool pool;\n    address tokenA;\n    address tokenB;\n    uint lastPrice;\n    uint fuseThreshold;\n    bool depositorSwapTokens;\n    uint rebalanceEarned0;\n    uint rebalanceEarned1;\n\n    uint newRebalanceEarned0;\n    uint newRebalanceEarned1;\n    uint notCoveredLoss;\n    int24 newLowerTick;\n    int24 newUpperTick;\n\n    bool fillUp;\n    bool isStablePool;\n    uint newPrice;\n  }\n\n  //////////////////////////////////////////\n  //            HELPERS\n  //////////////////////////////////////////\n\n  function emitDisableFuse() external {\n    emit DisableFuse();\n  }\n\n  function emitNewFuseThreshold(uint value) external {\n    emit NewFuseThreshold(value);\n  }\n\n  /// @dev Gets the liquidator swap slippage based on the pool type (stable or volatile).\n  /// @param pool The IUniswapV3Pool instance.\n  /// @return The liquidator swap slippage percentage.\n  function _getLiquidatorSwapSlippage(IUniswapV3Pool pool) internal view returns (uint) {\n    return isStablePool(pool) ? LIQUIDATOR_SWAP_SLIPPAGE_STABLE : LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE;\n  }\n\n  /// @notice Get the balance of the given token held by the contract.\n  /// @param token The token address.\n  /// @return The balance of the token.\n  function _balance(address token) internal view returns (uint) {\n    return IERC20(token).balanceOf(address(this));\n  }\n\n  /// @notice Check if the given pool is a stable pool.\n  /// @param pool The Uniswap V3 pool.\n  /// @return A boolean indicating if the pool is stable.\n  function isStablePool(IUniswapV3Pool pool) public view returns (bool) {\n    return pool.fee() == 100;\n  }\n\n  /// @notice Get the token amounts held by the contract excluding earned parts.\n  /// @param state The state of the pool.\n  /// @return amountA The balance of tokenA.\n  /// @return amountB The balance of tokenB.\n  function getTokenAmounts(State storage state) external view returns (uint amountA, uint amountB) {\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    amountA = _balance(state.tokenA);\n    amountB = _balance(state.tokenB);\n\n    uint earned0 = (depositorSwapTokens ? state.rebalanceEarned1 : state.rebalanceEarned0);\n    uint earned1 = (depositorSwapTokens ? state.rebalanceEarned0 : state.rebalanceEarned1);\n\n    require(amountA >= earned0 && amountB >= earned1, \"Wrong balance\");\n    amountA -= earned0;\n    amountB -= earned1;\n  }\n\n  /// @notice Get the price ratio of the two given tokens from the oracle.\n  /// @param converter The Tetu converter.\n  /// @param tokenA The first token address.\n  /// @param tokenB The second token address.\n  /// @return The price ratio of the two tokens.\n  function getOracleAssetsPrice(ITetuConverter converter, address tokenA, address tokenB) public view returns (uint) {\n    IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n    uint priceA = oracle.getAssetPrice(tokenA);\n    uint priceB = oracle.getAssetPrice(tokenB);\n    return priceB * 1e18 / priceA;\n  }\n\n  /// @notice Check if the fuse is enabled based on the price difference and fuse threshold.\n  /// @param oldPrice The old price.\n  /// @param newPrice The new price.\n  /// @param fuseThreshold The fuse threshold.\n  /// @return A boolean indicating if the fuse is enabled.\n  function isEnableFuse(uint oldPrice, uint newPrice, uint fuseThreshold) internal pure returns (bool) {\n    return oldPrice > newPrice ? (oldPrice - newPrice) > fuseThreshold : (newPrice - oldPrice) > fuseThreshold;\n  }\n\n  /// @dev Gets the update information for the strategy, including token amounts received and spent.\n  /// @param state The State storage object.\n  /// @param baseAmounts Mapping of token addresses to their base amounts on the strategy balance (not rewards).\n  /// @return receivedA The amount of tokenA received.\n  /// @return spentA The amount of tokenA spent.\n  /// @return receivedB The amount of tokenB received.\n  /// @return spentB The amount of tokenB spent.\n  function getUpdateInfo(State storage state, mapping(address => uint) storage baseAmounts) external view returns (\n    uint receivedA,\n    uint spentA,\n    uint receivedB,\n    uint spentB\n  ){\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    bool depositorSwapTokens = state.depositorSwapTokens;\n    //updating baseAmounts (token amounts on strategy balance which are not rewards)\n    uint balanceOfTokenABefore = baseAmounts[tokenA];\n    uint balanceOfTokenBBefore = baseAmounts[tokenB];\n    uint balanceOfTokenAAfter = _balance(tokenA) - (depositorSwapTokens ? state.rebalanceEarned1 : state.rebalanceEarned0);\n    uint balanceOfTokenBAfter = _balance(tokenB) - (depositorSwapTokens ? state.rebalanceEarned0 : state.rebalanceEarned1);\n\n    receivedA = balanceOfTokenABefore > balanceOfTokenAAfter ? 0 : balanceOfTokenAAfter - balanceOfTokenABefore;\n    spentA = balanceOfTokenABefore > balanceOfTokenAAfter ? balanceOfTokenABefore - balanceOfTokenAAfter : 0;\n    receivedB = balanceOfTokenBBefore > balanceOfTokenBAfter ? 0 : balanceOfTokenBAfter - balanceOfTokenBBefore;\n    spentB = balanceOfTokenBBefore > balanceOfTokenBAfter ? balanceOfTokenBBefore - balanceOfTokenBAfter : 0;\n  }\n\n  function initStrategyState(State storage state, address controller_, address converter) external {\n    address liquidator = IController(controller_).liquidator();\n    IERC20(state.tokenA).approve(liquidator, type(uint).max);\n    IERC20(state.tokenB).approve(liquidator, type(uint).max);\n\n    /// for ultra-wide ranges we use Swap rebalancing strategy and Fill-up for other\n    /// upperTick always greater then lowerTick\n    state.fillUp = state.upperTick - state.lowerTick >= 4 * state.tickSpacing;\n\n    if (isStablePool(state.pool)) {\n      /// for stable pools fuse can be enabled\n      state.isStablePool = true;\n      // 0.5% price change\n      state.fuseThreshold = DEFAULT_FUSE_THRESHOLD;\n      emit NewFuseThreshold(DEFAULT_FUSE_THRESHOLD);\n      state.lastPrice = getOracleAssetsPrice(ITetuConverter(converter), state.tokenA, state.tokenB);\n    }\n  }\n\n  //////////////////////////////////////////\n  //            CALCULATIONS\n  //////////////////////////////////////////\n\n  /// @notice Calculate the initial values for a Uniswap V3 pool Depositor.\n  /// @param pool The Uniswap V3 pool to get the initial values from.\n  /// @param tickRange_ The tick range for the pool.\n  /// @param rebalanceTickRange_ The rebalance tick range for the pool.\n  /// @param asset_ Underlying asset of the depositor.\n  /// @return tickSpacing The tick spacing for the pool.\n  /// @return lowerTick The lower tick value for the pool.\n  /// @return upperTick The upper tick value for the pool.\n  /// @return tokenA The address of the first token in the pool.\n  /// @return tokenB The address of the second token in the pool.\n  /// @return _depositorSwapTokens A boolean representing whether to use reverse tokens for pool.\n  function calcInitialDepositorValues(\n    IUniswapV3Pool pool,\n    int24 tickRange_,\n    int24 rebalanceTickRange_,\n    address asset_\n  ) external view returns (\n    int24 tickSpacing,\n    int24 lowerTick,\n    int24 upperTick,\n    address tokenA,\n    address tokenB,\n    bool _depositorSwapTokens\n  ) {\n    tickSpacing = UniswapV3Lib.getTickSpacing(pool.fee());\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (tickRange_ == 0) {\n      lowerTick = tick / tickSpacing * tickSpacing;\n      upperTick = lowerTick + tickSpacing;\n    } else {\n      require(tickRange_ == tickRange_ / tickSpacing * tickSpacing, 'Incorrect tickRange');\n      require(rebalanceTickRange_ == rebalanceTickRange_ / tickSpacing * tickSpacing, 'Incorrect rebalanceTickRange');\n      lowerTick = (tick - tickRange_) / tickSpacing * tickSpacing;\n      upperTick = (tick + tickRange_) / tickSpacing * tickSpacing;\n    }\n    require(asset_ == pool.token0() || asset_ == pool.token1(), 'Incorrect asset');\n    if (asset_ == pool.token0()) {\n      tokenA = pool.token0();\n      tokenB = pool.token1();\n      _depositorSwapTokens = false;\n    } else {\n      tokenA = pool.token1();\n      tokenB = pool.token0();\n      _depositorSwapTokens = true;\n    }\n  }\n\n  /// @notice Calculate the new tick range for a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool to calculate the new tick range for.\n  /// @param lowerTick The current lower tick value for the pool.\n  /// @param upperTick The current upper tick value for the pool.\n  /// @param tickSpacing The tick spacing for the pool.\n  /// @return lowerTickNew The new lower tick value for the pool.\n  /// @return upperTickNew The new upper tick value for the pool.\n  function _calcNewTickRange(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing\n  ) internal view returns (int24 lowerTickNew, int24 upperTickNew) {\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (upperTick - lowerTick == tickSpacing) {\n      lowerTickNew = tick / tickSpacing * tickSpacing;\n      upperTickNew = lowerTickNew + tickSpacing;\n    } else {\n      int24 halfRange = (upperTick - lowerTick) / 2;\n      lowerTickNew = (tick - halfRange) / tickSpacing * tickSpacing;\n      upperTickNew = (tick + halfRange) / tickSpacing * tickSpacing;\n    }\n  }\n\n  /// @dev Calculates the new fee amounts and the not covered loss, if any, after attempting to cover losses.\n  /// @param p The TryCoverLossParams instance containing required parameters.\n  /// @param collateralAmount The current collateral amount.\n  /// @return newFee0 The new fee amount for tokenA.\n  /// @return newFee1 The new fee amount for tokenB.\n  /// @return notCoveredLoss The amount of loss that could not be covered by fees.\n  function _calculateCoverLoss(\n    TryCoverLossParams memory p,\n    uint collateralAmount\n  ) internal view returns (uint newFee0, uint newFee1, uint notCoveredLoss) {\n    notCoveredLoss = 0;\n\n    newFee0 = p.fee0;\n    newFee1 = p.fee1;\n    uint feeA = p.depositorSwapTokens ? newFee1 : newFee0;\n    uint feeB = p.depositorSwapTokens ? newFee0 : newFee1;\n\n    uint newInvestedAssets = collateralAmount + _balance(p.tokenA) - feeA;\n    if (newInvestedAssets < p.oldInvestedAssets) {\n      // we have lost\n      uint lost = p.oldInvestedAssets - newInvestedAssets;\n\n      if (lost <= feeA) {\n        // feeA is enough to cover lost\n        if (p.depositorSwapTokens) {\n          newFee1 -= lost;\n        } else {\n          newFee0 -= lost;\n        }\n      } else {\n        // feeA is not enough to cover lost\n\n        if (p.depositorSwapTokens) {\n          newFee1 = 0;\n        } else {\n          newFee0 = 0;\n        }\n\n        uint feeBinTermOfA;\n        if (feeB > 0) {\n\n          feeBinTermOfA = UniswapV3Lib.getPrice(address(p.pool), p.tokenB) * feeB / 10 ** IERC20Metadata(p.tokenB).decimals();\n\n          if (feeA + feeBinTermOfA > lost) {\n            if (p.depositorSwapTokens) {\n              newFee0 = (feeA + feeBinTermOfA - lost) * UniswapV3Lib.getPrice(address(p.pool), p.tokenA) / 10 ** IERC20Metadata(p.tokenA).decimals();\n            } else {\n              newFee1 = (feeA + feeBinTermOfA - lost) * UniswapV3Lib.getPrice(address(p.pool), p.tokenA) / 10 ** IERC20Metadata(p.tokenA).decimals();\n            }\n          } else {\n            notCoveredLoss = lost - feeA - feeBinTermOfA;\n            if (p.depositorSwapTokens) {\n              newFee0 = 0;\n            } else {\n              newFee1 = 0;\n            }\n          }\n        } else {\n          notCoveredLoss = lost - feeA;\n        }\n      }\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Pool info\n  //////////////////////////////////////////\n\n  /// @notice Retrieve the reserves of a Uniswap V3 pool managed by this contract.\n  /// @param state The State storage containing the pool's information.\n  /// @return reserves An array containing the reserve amounts of the contract owned liquidity.\n  function getPoolReserves(State storage state) external view returns (uint[] memory reserves) {\n    reserves = new uint[](2);\n    (uint160 sqrtRatioX96, , , , , ,) = state.pool.slot0();\n\n    (reserves[0], reserves[1]) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTick,\n      state.upperTick,\n      state.totalLiquidity\n    );\n\n    (uint amount0CurrentFillup, uint amount1CurrentFillup) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      state.lowerTickFillup,\n      state.upperTickFillup,\n      state.totalLiquidityFillup\n    );\n\n    (uint fee0, uint fee1) = getFees(state);\n\n    reserves[0] += amount0CurrentFillup + fee0 + _balance(state.pool.token0());\n    reserves[1] += amount1CurrentFillup + fee1 + _balance(state.pool.token1());\n\n    if (state.depositorSwapTokens) {\n      (reserves[0], reserves[1]) = (reserves[1], reserves[0]);\n    }\n  }\n\n  /// @notice Retrieve the fees generated by a Uniswap V3 pool managed by this contract.\n  /// @param state The State storage containing the pool's information.\n  /// @return fee0 The fees generated for the first token in the pool.\n  /// @return fee1 The fees generated for the second token in the pool.\n  function getFees(State storage state) public view returns (uint fee0, uint fee1) {\n    UniswapV3Lib.PoolPosition memory position = UniswapV3Lib.PoolPosition(address(state.pool), state.lowerTick, state.upperTick, state.totalLiquidity, address(this));\n    (fee0, fee1) = UniswapV3Lib.getFees(position);\n    UniswapV3Lib.PoolPosition memory positionFillup = UniswapV3Lib.PoolPosition(address(state.pool), state.lowerTickFillup, state.upperTickFillup, state.totalLiquidityFillup, address(this));\n    (uint fee0Fillup, uint fee1Fillup) = UniswapV3Lib.getFees(positionFillup);\n    fee0 += fee0Fillup;\n    fee1 += fee1Fillup;\n  }\n\n  /// @notice Estimate the exit amounts for a given liquidity amount in a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool to quote the exit amounts for.\n  /// @param lowerTick The lower tick value for the pool.\n  /// @param upperTick The upper tick value for the pool.\n  /// @param lowerTickFillup The lower tick value for the fillup range in the pool.\n  /// @param upperTickFillup The upper tick value for the fillup range in the pool.\n  /// @param liquidity The current liquidity in the pool.\n  /// @param liquidityFillup The current liquidity in the fillup range.\n  /// @param liquidityAmountToExit The amount of liquidity to exit.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsOut An array containing the estimated exit amounts for each token in the pool.\n  function quoteExit(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 lowerTickFillup,\n    int24 upperTickFillup,\n    uint128 liquidity,\n    uint128 liquidityFillup,\n    uint128 liquidityAmountToExit,\n    bool _depositorSwapTokens\n  ) external view returns (uint[] memory amountsOut) {\n    amountsOut = new uint[](2);\n    (uint160 sqrtRatioX96, , , , , ,) = pool.slot0();\n\n    (amountsOut[0], amountsOut[1]) = UniswapV3Lib.getAmountsForLiquidity(\n      sqrtRatioX96,\n      lowerTick,\n      upperTick,\n      liquidityAmountToExit\n    );\n\n    if (liquidity > 0 && liquidityFillup > 0) {\n      (uint amountOut0Fillup, uint amountOut1Fillup) = UniswapV3Lib.getAmountsForLiquidity(\n        sqrtRatioX96,\n        lowerTickFillup,\n        upperTickFillup,\n        liquidityFillup * liquidityAmountToExit / liquidity\n      );\n\n      amountsOut[0] += amountOut0Fillup;\n      amountsOut[1] += amountOut1Fillup;\n    }\n\n    if (_depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  /// @notice Determine if the pool needs to be rebalanced.\n  /// @return A boolean indicating if the pool needs to be rebalanced.\n  function needRebalance(\n    bool isFuseTriggered,\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing,\n    int24 rebalanceTickRange\n  ) public view returns (bool) {\n    if (isFuseTriggered) {\n      return false;\n    }\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (upperTick - lowerTick == tickSpacing) {\n      return tick < lowerTick || tick >= upperTick;\n    } else {\n      int24 halfRange = (upperTick - lowerTick) / 2;\n      int24 oldMedianTick = lowerTick + halfRange;\n      if (tick > oldMedianTick) {\n        return tick - oldMedianTick >= rebalanceTickRange;\n      }\n      return oldMedianTick - tick > rebalanceTickRange;\n    }\n  }\n\n  /// @notice Get entry data for a Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool instance.\n  /// @param lowerTick The lower tick of the pool's main range.\n  /// @param upperTick The upper tick of the pool's main range.\n  /// @param tickSpacing The tick spacing of the pool.\n  /// @param depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return entryData A byte array containing the entry data for the pool.\n  function getEntryData(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing,\n    bool depositorSwapTokens\n  ) public view returns (bytes memory entryData) {\n    address token1 = pool.token1();\n    uint token1Price = UniswapV3Lib.getPrice(address(pool), token1);\n    (lowerTick, upperTick) = _calcNewTickRange(pool, lowerTick, upperTick, tickSpacing);\n\n    uint token1Decimals = IERC20Metadata(token1).decimals();\n\n    uint token0Desired = token1Price;\n    uint token1Desired = 10 ** token1Decimals;\n\n    // calculate proportions\n    (uint consumed0, uint consumed1,) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTick, upperTick, token0Desired, token1Desired);\n\n    if (depositorSwapTokens) {\n      entryData = abi.encode(1, consumed1 * token1Price / token1Desired, consumed0);\n    } else {\n      entryData = abi.encode(1, consumed0, consumed1 * token1Price / token1Desired);\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Joins to the pool\n  //////////////////////////////////////////\n\n  /// @notice Enter the pool and provide liquidity with desired token amounts.\n  /// @param pool The Uniswap V3 pool to provide liquidity to.\n  /// @param lowerTick The lower tick value for the pool.\n  /// @param upperTick The upper tick value for the pool.\n  /// @param amountsDesired_ An array containing the desired amounts of tokens to provide liquidity.\n  /// @param totalLiquidity The current total liquidity in the pool.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsConsumed An array containing the consumed amounts for each token in the pool.\n  /// @return liquidityOut The amount of liquidity added to the pool.\n  /// @return totalLiquidityNew The updated total liquidity after providing liquidity.\n  function enter(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    uint[] memory amountsDesired_,\n    uint128 totalLiquidity,\n    bool _depositorSwapTokens\n  ) external returns (uint[] memory amountsConsumed, uint liquidityOut, uint128 totalLiquidityNew) {\n\n    amountsConsumed = new uint[](2);\n    if (_depositorSwapTokens) {\n      (amountsDesired_[0], amountsDesired_[1]) = (amountsDesired_[1], amountsDesired_[0]);\n    }\n    uint128 newLiquidity;\n    (amountsConsumed[0], amountsConsumed[1], newLiquidity) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTick, upperTick, amountsDesired_[0], amountsDesired_[1]);\n    pool.mint(address(this), lowerTick, upperTick, newLiquidity, \"\");\n    liquidityOut = uint(newLiquidity);\n    totalLiquidityNew = totalLiquidity + newLiquidity;\n    if (_depositorSwapTokens) {\n      (amountsConsumed[0], amountsConsumed[1]) = (amountsConsumed[1], amountsConsumed[0]);\n    }\n  }\n\n  /// @notice Add liquidity to a Uniswap V3 pool in a specified tick range according fill up rules.\n  /// @param pool The Uniswap V3 pool to add liquidity to.\n  /// @param lowerTick The current lower tick value for the pool.\n  /// @param upperTick The current upper tick value for the pool.\n  /// @param tickSpacing The tick spacing for the pool.\n  /// @param fee0 The fee amount for the first token in the pool.\n  /// @param fee1 The fee amount for the second token in the pool.\n  /// @return lowerTickFillup The lower tick value for the new liquidity range.\n  /// @return upperTickFillup The upper tick value for the new liquidity range.\n  /// @return liquidityOutFillup The liquidity amount added to the new range.\n  function addFillup(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 tickSpacing,\n    uint fee0,\n    uint fee1\n  ) external returns (int24 lowerTickFillup, int24 upperTickFillup, uint128 liquidityOutFillup) {\n    uint balance0 = _balance(pool.token0());\n    uint balance1 = _balance(pool.token1());\n\n    require(balance0 >= fee0 && balance1 >= fee1, \"Wrong fee\");\n    balance0 -= fee0;\n    balance1 -= fee1;\n\n    (, int24 tick, , , , ,) = pool.slot0();\n    if (balance0 > balance1 * UniswapV3Lib.getPrice(address(pool), pool.token1()) / 10 ** IERC20Metadata(pool.token1()).decimals()) {\n      // add token0 to half range\n      lowerTickFillup = tick / tickSpacing * tickSpacing + tickSpacing;\n      upperTickFillup = upperTick;\n      (,, liquidityOutFillup) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTickFillup, upperTickFillup, balance0, 0);\n      pool.mint(address(this), lowerTickFillup, upperTickFillup, liquidityOutFillup, \"\");\n    } else {\n      lowerTickFillup = lowerTick;\n      upperTickFillup = tick / tickSpacing * tickSpacing - tickSpacing;\n      (,, liquidityOutFillup) = UniswapV3Lib.addLiquidityPreview(address(pool), lowerTickFillup, upperTickFillup, 0, balance1);\n      pool.mint(address(this), lowerTickFillup, upperTickFillup, liquidityOutFillup, \"\");\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Exit from the pool\n  //////////////////////////////////////////\n\n\n  /// @notice Exit the pool and collect tokens proportional to the liquidity amount to exit.\n  /// @param pool The Uniswap V3 pool to exit from.\n  /// @param lowerTick The lower tick value for the pool.\n  /// @param upperTick The upper tick value for the pool.\n  /// @param lowerTickFillup The lower tick value for the fillup range in the pool.\n  /// @param upperTickFillup The upper tick value for the fillup range in the pool.\n  /// @param liquidity The current liquidity in the pool.\n  /// @param liquidityFillup The current liquidity in the fillup range.\n  /// @param liquidityAmountToExit The amount of liquidity to exit.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsOut An array containing the collected amounts for each token in the pool.\n  /// @return totalLiquidity The updated total liquidity after the exit.\n  /// @return totalLiquidityFillup The updated total liquidity in the fillup range after the exit.\n  function exit(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 lowerTickFillup,\n    int24 upperTickFillup,\n    uint128 liquidity,\n    uint128 liquidityFillup,\n    uint128 liquidityAmountToExit,\n    bool _depositorSwapTokens\n  ) external returns (uint[] memory amountsOut, uint128 totalLiquidity, uint128 totalLiquidityFillup) {\n    totalLiquidityFillup = 0;\n\n    amountsOut = new uint[](2);\n    (amountsOut[0], amountsOut[1]) = pool.burn(lowerTick, upperTick, liquidityAmountToExit);\n    // all fees will be collected but not returned in amountsOut\n    pool.collect(\n      address(this),\n      lowerTick,\n      upperTick,\n      type(uint128).max,\n      type(uint128).max\n    );\n\n    // remove proportional part of fillup liquidity\n    if (liquidityFillup != 0) {\n      uint128 toRemoveFillUpAmount = liquidityFillup * liquidityAmountToExit / liquidity;\n      (uint amountsOutFillup0, uint amountsOutFillup1) = pool.burn(lowerTickFillup, upperTickFillup, toRemoveFillUpAmount);\n      pool.collect(\n        address(this),\n        lowerTickFillup,\n        upperTickFillup,\n        type(uint128).max,\n        type(uint128).max\n      );\n      amountsOut[0] += amountsOutFillup0;\n      amountsOut[1] += amountsOutFillup1;\n\n      require(liquidityFillup >= toRemoveFillUpAmount, \"Wrong fillup\");\n      totalLiquidityFillup = liquidityFillup - toRemoveFillUpAmount;\n    }\n\n    require(liquidity >= liquidityAmountToExit, \"Wrong liquidity\");\n    totalLiquidity = liquidity - liquidityAmountToExit;\n\n    if (_depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  //////////////////////////////////////////\n  //            Claim\n  //////////////////////////////////////////\n\n  /// @notice Claim rewards from the Uniswap V3 pool.\n  /// @param pool The Uniswap V3 pool instance.\n  /// @param lowerTick The lower tick of the pool's main range.\n  /// @param upperTick The upper tick of the pool's main range.\n  /// @param lowerTickFillup The lower tick of the pool's fill-up range.\n  /// @param upperTickFillup The upper tick of the pool's fill-up range.\n  /// @param rebalanceEarned0 The amount of token0 earned from rebalancing.\n  /// @param rebalanceEarned1 The amount of token1 earned from rebalancing.\n  /// @param _depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @return amountsOut An array containing the amounts of token0 and token1 claimed as rewards.\n  function claimRewards(\n    IUniswapV3Pool pool,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 lowerTickFillup,\n    int24 upperTickFillup,\n    uint rebalanceEarned0,\n    uint rebalanceEarned1,\n    bool _depositorSwapTokens\n  ) external returns (uint[] memory amountsOut) {\n    amountsOut = new uint[](2);\n    pool.burn(lowerTick, upperTick, 0);\n    (amountsOut[0], amountsOut[1]) = pool.collect(\n      address(this),\n      lowerTick,\n      upperTick,\n      type(uint128).max,\n      type(uint128).max\n    );\n    if (lowerTickFillup != upperTickFillup) {\n      pool.burn(lowerTickFillup, upperTickFillup, 0);\n      (uint fillup0, uint fillup1) = pool.collect(\n        address(this),\n        lowerTickFillup,\n        upperTickFillup,\n        type(uint128).max,\n        type(uint128).max\n      );\n      amountsOut[0] += fillup0;\n      amountsOut[1] += fillup1;\n    }\n    amountsOut[0] += rebalanceEarned0;\n    amountsOut[1] += rebalanceEarned1;\n    if (_depositorSwapTokens) {\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\n    }\n  }\n\n  function isReadyToHardWork(State storage state, ITetuConverter converter) external view returns (bool isReady) {\n    // check claimable amounts and compare with thresholds\n    (uint fee0, uint fee1) = getFees(state);\n    fee0 += state.rebalanceEarned0;\n    fee1 += state.rebalanceEarned1;\n\n    if (state.depositorSwapTokens) {\n      (fee0, fee1) = (fee1, fee0);\n    }\n\n    address tokenA = state.tokenA;\n    address tokenB = state.tokenB;\n    IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\n    uint priceA = oracle.getAssetPrice(tokenA);\n    uint priceB = oracle.getAssetPrice(tokenB);\n\n    uint fee0USD = fee0 * priceA / 1e18;\n    uint fee1USD = fee1 * priceB / 1e18;\n\n    return fee0USD > HARD_WORK_USD_FEE_THRESHOLD || fee1USD > HARD_WORK_USD_FEE_THRESHOLD;\n  }\n\n  //////////////////////////////////////////\n  //            Rebalance\n  //////////////////////////////////////////\n\n  /// @dev Rebalances the current position, adjusts the tick range, and attempts to cover loss with pool rewards.\n  /// @param state The State storage object.\n  /// @param converter The TetuConverter contract.\n  /// @param controller The Tetu controller address.\n  /// @param oldInvestedAssets The amount of invested assets before rebalancing.\n  /// @return tokenAmounts The token amounts for deposit (if length != 2 then do nothing).\n  /// @return isNeedFillup Indicates if fill-up is required after rebalancing.\n  function rebalance(\n    State storage state,\n    ITetuConverter converter,\n    address controller,\n    uint oldInvestedAssets\n  ) external returns (\n    uint[] memory tokenAmounts, // _depositorEnter(tokenAmounts) if length == 2\n    bool isNeedFillup\n  ) {\n    tokenAmounts = new uint[](0);\n    isNeedFillup = false;\n\n    RebalanceLocalVariables memory vars = RebalanceLocalVariables({\n    upperTick : state.upperTick,\n    lowerTick : state.lowerTick,\n    tickSpacing : state.tickSpacing,\n    pool : state.pool,\n    tokenA : state.tokenA,\n    tokenB : state.tokenB,\n    lastPrice : state.lastPrice,\n    fuseThreshold : state.fuseThreshold,\n    depositorSwapTokens : state.depositorSwapTokens,\n    rebalanceEarned0 : state.rebalanceEarned0,\n    rebalanceEarned1 : state.rebalanceEarned1,\n    // setup initial values\n    newRebalanceEarned0 : 0,\n    newRebalanceEarned1 : 0,\n    notCoveredLoss : 0,\n    newLowerTick : 0,\n    newUpperTick : 0,\n    fillUp : state.fillUp,\n    isStablePool : state.isStablePool,\n    newPrice : 0\n    });\n\n    require(needRebalance(\n        state.isFuseTriggered,\n        vars.pool,\n        vars.lowerTick,\n        vars.upperTick,\n        vars.tickSpacing,\n        state.rebalanceTickRange\n      ), \"No rebalancing needed\");\n\n    vars.newPrice = getOracleAssetsPrice(converter, vars.tokenA, vars.tokenB);\n\n    if (vars.isStablePool && isEnableFuse(vars.lastPrice, vars.newPrice, vars.fuseThreshold)) {\n      /// enabling fuse: close debt and stop providing liquidity\n      state.isFuseTriggered = true;\n      emit FuseTriggered();\n\n      UniswapV3DebtLib.closeDebt(\n        converter,\n        controller,\n        vars.pool,\n        vars.tokenA,\n        vars.tokenB,\n        vars.depositorSwapTokens,\n        vars.rebalanceEarned0,\n        vars.rebalanceEarned1,\n        _getLiquidatorSwapSlippage(vars.pool)\n      );\n\n      vars.newRebalanceEarned0 = vars.rebalanceEarned0;\n      vars.newRebalanceEarned1 = vars.rebalanceEarned1;\n      vars.newLowerTick = vars.lowerTick;\n      vars.newUpperTick = vars.upperTick;\n    } else {\n      if (vars.isStablePool) {\n        state.lastPrice = vars.newPrice;\n      }\n\n      /// rebalancing debt with passing rebalanceEarned0, rebalanceEarned1 that will remain untouched\n      UniswapV3DebtLib.rebalanceDebt(\n        converter,\n        controller,\n        vars.pool,\n        vars.tokenA,\n        vars.tokenB,\n        vars.fillUp,\n        (vars.depositorSwapTokens ? vars.rebalanceEarned1 : vars.rebalanceEarned0),\n        (vars.depositorSwapTokens ? vars.rebalanceEarned0 : vars.rebalanceEarned1),\n        getEntryData(vars.pool, vars.lowerTick, vars.upperTick, vars.tickSpacing, vars.depositorSwapTokens),\n        _getLiquidatorSwapSlippage(vars.pool)\n      );\n\n      /// trying to cover rebalance loss (IL + not hedged part of tokenB + swap cost) by pool rewards\n      (vars.newRebalanceEarned0, vars.newRebalanceEarned1, vars.notCoveredLoss) = _calculateCoverLoss(\n        TryCoverLossParams(\n          vars.pool,\n          vars.tokenA,\n          vars.tokenB,\n          vars.depositorSwapTokens,\n          vars.rebalanceEarned0,\n          vars.rebalanceEarned1,\n          oldInvestedAssets\n        ),\n        UniswapV3DebtLib.getDeptTotalCollateralAmountOut(converter, vars.tokenA, vars.tokenB)\n      );\n      state.rebalanceEarned0 = vars.newRebalanceEarned0;\n      state.rebalanceEarned1 = vars.newRebalanceEarned1;\n      if (vars.notCoveredLoss != 0) {\n        state.rebalanceLost += vars.notCoveredLoss;\n      }\n\n      // calculate and set new tick range\n      (vars.newLowerTick, vars.newUpperTick) = _calcNewTickRange(vars.pool, vars.lowerTick, vars.upperTick, vars.tickSpacing);\n      state.lowerTick = vars.newLowerTick;\n      state.upperTick = vars.newUpperTick;\n\n\n      tokenAmounts = new uint[](2);\n      tokenAmounts[0] = _balance(vars.tokenA) - (vars.depositorSwapTokens ? vars.newRebalanceEarned1 : vars.newRebalanceEarned0);\n      tokenAmounts[1] = _balance(vars.tokenB) - (vars.depositorSwapTokens ? vars.newRebalanceEarned0 : vars.newRebalanceEarned1);\n\n      if (vars.fillUp) {\n        isNeedFillup = true;\n      }\n    }\n    emit Rebalanced();\n  }\n\n  function calcEarned(State storage state) external view returns (uint) {\n    address tokenB = state.tokenB;\n\n    (uint fee0, uint fee1) = getFees(state);\n    fee0 += state.rebalanceEarned0;\n    fee1 += state.rebalanceEarned1;\n\n    if (state.depositorSwapTokens) {\n      (fee0, fee1) = (fee1, fee0);\n    }\n\n    uint feeBinTermOfA = UniswapV3Lib.getPrice(address(state.pool), tokenB) * fee1 / 10 ** IERC20Metadata(tokenB).decimals();\n\n    return fee0 + feeBinTermOfA;\n  }\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3DebtLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBaseLib.sol\";\nimport \"./UniswapV3Lib.sol\";\n\nlibrary UniswapV3DebtLib {\n\n  //////////////////////////////////////////\n  //            CONSTANTS\n  //////////////////////////////////////////\n\n  uint internal constant SELL_GAP = 100;\n  /// @dev should be placed local, probably will be adjusted later\n  uint internal constant BORROW_PERIOD_ESTIMATION = 30 days / 2;\n\n  //////////////////////////////////////////\n  //            STRUCTURES\n  //////////////////////////////////////////\n\n  struct RebalanceDebtFillUpLocalVariables {\n    uint debtAmount;\n    uint availableBalanceTokenA;\n    uint availableBalanceTokenB;\n    uint needToBorrowOrFreeFromBorrow;\n  }\n\n  //////////////////////////////////////////\n  //            MAIN LOGIC\n  //////////////////////////////////////////\n\n  /// @dev Returns the total collateral amount out for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  /// @return totalCollateralAmountOut The total collateral amount out for the token pair.\n  function getDeptTotalCollateralAmountOut(ITetuConverter tetuConverter, address tokenA, address tokenB) internal returns (uint totalCollateralAmountOut) {\n    (, totalCollateralAmountOut) = tetuConverter.getDebtAmountCurrent(address(this), tokenA, tokenB);\n  }\n\n  /// @dev Returns the total debt amount out for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  /// @return totalDebtAmountOut The total debt amount out for the token pair.\n  function getDeptTotalDebtAmountOut(ITetuConverter tetuConverter, address tokenA, address tokenB) internal returns (uint totalDebtAmountOut) {\n    (totalDebtAmountOut,) = tetuConverter.getDebtAmountCurrent(address(this), tokenA, tokenB);\n  }\n\n  /// @dev Closes the debt positions for the given token pair.\n  /// @param tetuConverter The ITetuConverter instance.\n  /// @param controller The controller address.\n  /// @param pool The IUniswapV3Pool instance.\n  /// @param tokenA The address of tokenA.\n  /// @param tokenB The address of tokenB.\n  /// @param depositorSwapTokens A boolean indicating if need to use token B instead of token A.\n  /// @param fee0 The fee amount for tokenA.\n  /// @param fee1 The fee amount for tokenB.\n  function closeDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    IUniswapV3Pool pool,\n    address tokenA,\n    address tokenB,\n    bool depositorSwapTokens,\n    uint fee0,\n    uint fee1,\n    uint liquidatorSwapSlippage\n  ) internal {\n    uint tokenAFee = depositorSwapTokens ? fee1 : fee0;\n    uint tokenBFee = depositorSwapTokens ? fee0 : fee1;\n    _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, tokenAFee, tokenBFee, liquidatorSwapSlippage);\n  }\n\n  /// @dev Rebalances the debt by either filling up or closing and reopening debt positions.\n  function rebalanceDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    IUniswapV3Pool pool,\n    address tokenA,\n    address tokenB,\n    bool fillUp,\n    uint tokenAFee,\n    uint tokenBFee,\n    bytes memory entryData,\n    uint liquidatorSwapSlippage\n  ) external {\n    if (fillUp) {\n      _rebalanceDebtFillup(tetuConverter, controller, pool, tokenA, tokenB, tokenAFee, tokenBFee, liquidatorSwapSlippage);\n    } else {\n      _closeDebt(tetuConverter, controller, pool, tokenA, tokenB, tokenAFee, tokenBFee, liquidatorSwapSlippage);\n      _openDebt(tetuConverter, tokenA, tokenB, entryData, tokenAFee);\n    }\n  }\n\n  /// @notice Closes debt by liquidating tokens as necessary.\n  ///         This function helps ensure that the converter strategy maintains the appropriate balances\n  ///         and debt positions for token A and token B, while accounting for fees and potential price impacts.\n  function _closeDebt(\n    ITetuConverter tetuConverter,\n    address controller,\n    IUniswapV3Pool pool,\n    address tokenA,\n    address tokenB,\n    uint feeA,\n    uint feeB,\n    uint liquidatorSwapSlippage\n  ) internal {\n    uint debtAmount = getDeptTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n\n    uint availableBalanceTokenA = _balance(tokenA);\n    uint availableBalanceTokenB = _balance(tokenB);\n\n    require(availableBalanceTokenA >= feeA && availableBalanceTokenB >= feeB, \"Wrong balance\");\n    availableBalanceTokenA -= feeA;\n    availableBalanceTokenB -= feeB;\n\n    if (availableBalanceTokenB < debtAmount) {\n\n      uint tokenBprice = UniswapV3Lib.getPrice(address(pool), tokenB);\n      uint needToSellTokenA = tokenBprice * (debtAmount - availableBalanceTokenB) / 10 ** IERC20Metadata(tokenB).decimals();\n      // add 1% gap for price impact\n      needToSellTokenA += needToSellTokenA / SELL_GAP;\n\n      if (needToSellTokenA < availableBalanceTokenA) {\n        ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, needToSellTokenA, liquidatorSwapSlippage, 0);\n      } else {\n        // very rare case, but happens on long run backtests\n        ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, availableBalanceTokenA, liquidatorSwapSlippage, 0);\n        ConverterStrategyBaseLib.closePosition(\n          tetuConverter,\n          tokenA,\n          tokenB,\n          _balance(tokenB) - feeB\n        );\n        // refresh dept amount\n        debtAmount = getDeptTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n        if (debtAmount > 0) {\n          tokenBprice = UniswapV3Lib.getPrice(address(pool), tokenB);\n          needToSellTokenA = tokenBprice * debtAmount / 10 ** IERC20Metadata(tokenB).decimals();\n          needToSellTokenA += needToSellTokenA / SELL_GAP;\n          ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, needToSellTokenA, liquidatorSwapSlippage, 0);\n        }\n      }\n    }\n\n    if (debtAmount > 0) {\n      ConverterStrategyBaseLib.closePosition(\n        tetuConverter,\n        tokenA,\n        tokenB,\n        debtAmount\n      );\n    }\n\n    ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenB, tokenA, _balance(tokenB) - feeB, liquidatorSwapSlippage, 0);\n  }\n\n  /// @dev Opens a new debt position using entry data.\n  /// @param tetuConverter The TetuConverter contract.\n  /// @param tokenA The address of token A.\n  /// @param tokenB The address of token B.\n  /// @param entryData The data required to open a position.\n  /// @param feeA The fee associated with token A.\n  function _openDebt(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    bytes memory entryData,\n    uint feeA\n  ) internal {\n    ConverterStrategyBaseLib.openPosition(\n      tetuConverter,\n      entryData,\n      tokenA,\n      tokenB,\n      _balance(tokenA) - feeA,\n      0\n    );\n  }\n\n  /// @dev Rebalances the debt to reach the optimal ratio between token A and token B.\n  function _rebalanceDebtFillup(\n    ITetuConverter tetuConverter,\n    address controller,\n    IUniswapV3Pool pool,\n    address tokenA,\n    address tokenB,\n    uint tokenAFee,\n    uint tokenBFee,\n    uint liquidatorSwapSlippage\n  ) internal {\n    RebalanceDebtFillUpLocalVariables memory vars;\n    vars.debtAmount = getDeptTotalDebtAmountOut(tetuConverter, tokenA, tokenB);\n\n    vars.availableBalanceTokenA = getBalanceWithoutFees(tokenA, tokenAFee);\n    vars.availableBalanceTokenB = getBalanceWithoutFees(tokenB, tokenBFee);\n\n    if (vars.availableBalanceTokenB > vars.debtAmount) {\n      vars.needToBorrowOrFreeFromBorrow = vars.availableBalanceTokenB - vars.debtAmount;\n\n      if (_getCollateralAmountForBorrow(tetuConverter, tokenA, tokenB, vars.needToBorrowOrFreeFromBorrow) < vars.availableBalanceTokenA) {\n        ConverterStrategyBaseLib.openPosition(\n          tetuConverter,\n          abi.encode(2),\n          tokenA,\n          tokenB,\n          vars.needToBorrowOrFreeFromBorrow,\n          0\n        );\n      } else {\n        ConverterStrategyBaseLib.closePosition(\n          tetuConverter,\n          tokenA,\n          tokenB,\n          vars.debtAmount\n        );\n\n        vars.availableBalanceTokenB = getBalanceWithoutFees(tokenB, tokenBFee);\n\n        ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenB, tokenA, vars.availableBalanceTokenB, liquidatorSwapSlippage, 0);\n\n        vars.availableBalanceTokenA = getBalanceWithoutFees(tokenA, tokenAFee);\n\n        ConverterStrategyBaseLib.openPosition(\n          tetuConverter,\n          abi.encode(1, 1, 1),\n          tokenA,\n          tokenB,\n          vars.availableBalanceTokenA,\n          0\n        );\n      }\n    } else {\n      vars.needToBorrowOrFreeFromBorrow = vars.debtAmount - vars.availableBalanceTokenB;\n      if (vars.availableBalanceTokenB > vars.needToBorrowOrFreeFromBorrow) {\n        ConverterStrategyBaseLib.closePosition(\n          tetuConverter,\n          tokenA,\n          tokenB,\n          vars.needToBorrowOrFreeFromBorrow\n        );\n      } else {\n        uint needToSellTokenA = UniswapV3Lib.getPrice(address(pool), tokenB) * vars.needToBorrowOrFreeFromBorrow / 10 ** IERC20Metadata(tokenB).decimals();\n        // add % gap for price impact\n        needToSellTokenA += needToSellTokenA / SELL_GAP;\n        ConverterStrategyBaseLib.liquidate(ITetuLiquidator(IController(controller).liquidator()), tokenA, tokenB, needToSellTokenA, liquidatorSwapSlippage, 0);\n\n        vars.availableBalanceTokenB = getBalanceWithoutFees(tokenB, tokenBFee);\n\n        ConverterStrategyBaseLib.closePosition(\n          tetuConverter,\n          tokenA,\n          tokenB,\n          vars.debtAmount < vars.availableBalanceTokenB ? vars.debtAmount : vars.availableBalanceTokenB\n        );\n\n        vars.availableBalanceTokenA = getBalanceWithoutFees(tokenA, tokenAFee);\n\n        ConverterStrategyBaseLib.openPosition(\n          tetuConverter,\n          abi.encode(1, 1, 1),\n          tokenA,\n          tokenB,\n          vars.availableBalanceTokenA,\n          0\n        );\n      }\n    }\n  }\n\n  /// @dev Calculates the collateral amount required for borrowing a specified amount.\n  /// @param tetuConverter The TetuConverter contract.\n  /// @param tokenA The address of token A.\n  /// @param tokenB The address of token B.\n  /// @param needToBorrow The amount that needs to be borrowed.\n  /// @return collateralAmount The amount of collateral required for borrowing the specified amount.\n  function _getCollateralAmountForBorrow(\n    ITetuConverter tetuConverter,\n    address tokenA,\n    address tokenB,\n    uint needToBorrow\n  ) internal view returns (uint collateralAmount) {\n    ConverterStrategyBaseLib.OpenPositionLocal memory vars;\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter.findBorrowStrategies(\n      abi.encode(2),\n      tokenA,\n      needToBorrow,\n      tokenB,\n      BORROW_PERIOD_ESTIMATION\n    );\n\n    uint len = vars.converters.length;\n    if (len > 0) {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        vars.amountToBorrow = needToBorrow < vars.amountsToBorrow[i]\n        ? needToBorrow\n        : vars.amountsToBorrow[i];\n        vars.collateral = needToBorrow < vars.amountsToBorrow[i]\n        ? vars.collateralsRequired[i] * needToBorrow / vars.amountsToBorrow[i]\n        : vars.collateralsRequired[i];\n        needToBorrow -= vars.amountToBorrow;\n        if (needToBorrow == 0) break;\n      }\n    }\n    return vars.collateral;\n  }\n\n  /// @notice Get the balance of the given token held by the contract.\n  /// @param token The token address.\n  /// @return The balance of the token.\n  function _balance(address token) internal view returns (uint) {\n    return IERC20(token).balanceOf(address(this));\n  }\n\n  /// @dev Gets the token balance without fees.\n  /// @param token The token address.\n  /// @param fee The fee amount to be subtracted from the balance.\n  /// @return balanceWithoutFees The token balance without the specified fee amount.\n  function getBalanceWithoutFees(address token, uint fee) internal view returns (uint balanceWithoutFees) {\n    balanceWithoutFees = _balance(token);\n    require(balanceWithoutFees >= fee, \"Balance lower than fee\");\n    balanceWithoutFees -= fee;\n  }\n\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3Depositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"../DepositorBase.sol\";\nimport \"../../integrations/uniswap/IUniswapV3MintCallback.sol\";\nimport \"./UniswapV3ConverterStrategyLogicLib.sol\";\n\n/// @title UniswapV3Depositor\n/// @dev Abstract contract that is designed to interact with Uniswap V3 pools and manage liquidity.\n///      Inherits from IUniswapV3MintCallback, DepositorBase, and Initializable.\nabstract contract UniswapV3Depositor is IUniswapV3MintCallback, DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant UNISWAPV3_DEPOSITOR_VERSION = \"1.0.1\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                VARIABLES\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev State variable to store the current state of the whole strategy\n  UniswapV3ConverterStrategyLogicLib.State internal state;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                INIT\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Initializes the contract with the provided parameters.\n  /// @param asset_ The address of the asset.\n  /// @param pool_ The address of the Uniswap V3 pool.\n  /// @param tickRange_ The tick range for the positions.\n  /// @param rebalanceTickRange_ The tick range for rebalancing.\n  function __UniswapV3Depositor_init(\n    address asset_,\n    address pool_,\n    int24 tickRange_,\n    int24 rebalanceTickRange_\n  ) internal onlyInitializing {\n    require(pool_ != address(0), AppErrors.ZERO_ADDRESS);\n    state.pool = IUniswapV3Pool(pool_);\n    state.rebalanceTickRange = rebalanceTickRange_;\n    (\n    state.tickSpacing,\n    state.lowerTick,\n    state.upperTick,\n    state.tokenA,\n    state.tokenB,\n    state.depositorSwapTokens\n    ) = UniswapV3ConverterStrategyLogicLib.calcInitialDepositorValues(\n      state.pool,\n      tickRange_,\n      rebalanceTickRange_,\n      asset_\n    );\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns the current state of the contract.\n  function getState() external view returns (\n    address tokenA,\n    address tokenB,\n    IUniswapV3Pool pool,\n    int24 tickSpacing,\n    int24 lowerTick,\n    int24 upperTick,\n    int24 rebalanceTickRange,\n    uint128 totalLiquidity,\n    bool isFuseTriggered,\n    uint fuseThreshold,\n    uint[] memory rebalanceResults\n  ) {\n    tokenA = state.tokenA;\n    tokenB = state.tokenB;\n    pool = state.pool;\n    tickSpacing = state.tickSpacing;\n    lowerTick = state.lowerTick;\n    upperTick = state.upperTick;\n    rebalanceTickRange = state.rebalanceTickRange;\n    totalLiquidity = state.totalLiquidity;\n    isFuseTriggered = state.isFuseTriggered;\n    fuseThreshold = state.fuseThreshold;\n\n    rebalanceResults = new uint[](3);\n    rebalanceResults[0] = state.rebalanceEarned0;\n    rebalanceResults[1] = state.rebalanceEarned1;\n    rebalanceResults[2] = state.rebalanceLost;\n  }\n\n  /// @notice Returns the fees for the current state.\n  /// @return fee0 and fee1.\n  function getFees() public view returns (uint fee0, uint fee1) {\n    return UniswapV3ConverterStrategyLogicLib.getFees(state);\n  }\n\n  /// @notice Returns the pool assets.\n  /// @return poolAssets An array containing the addresses of the pool assets.\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    poolAssets = new address[](2);\n    poolAssets[0] = state.tokenA;\n    poolAssets[1] = state.tokenB;\n  }\n\n  /// @notice Returns the pool weights and the total weight.\n  /// @return weights An array containing the weights of the pool assets, and totalWeight the sum of the weights.\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    weights = new uint[](2);\n    weights[0] = 1;\n    weights[1] = 1;\n    totalWeight = 2;\n  }\n\n  /// @notice Returns the pool reserves.\n  /// @return reserves An array containing the reserves of the pool assets.\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    return UniswapV3ConverterStrategyLogicLib.getPoolReserves(state);\n  }\n\n  /// @notice Returns the current liquidity of the depositor.\n  /// @return The current liquidity of the depositor.\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return uint(state.totalLiquidity);\n  }\n\n  /// @notice Returns the total supply of the depositor.\n  /// @return In UniV3 we can not calculate the total supply of the wgole pool. Return only ourself value.\n  function _depositorTotalSupply() override internal view virtual returns (uint) {\n    return uint(state.totalLiquidity);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                CALLBACK\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Callback function called by Uniswap V3 pool on mint operation.\n  /// @param amount0Owed The amount of token0 owed to the pool.\n  /// @param amount1Owed The amount of token1 owed to the pool.\n  function uniswapV3MintCallback(\n    uint amount0Owed,\n    uint amount1Owed,\n    bytes calldata /*_data*/\n  ) external override {\n    require(msg.sender == address(state.pool), \"callback caller\");\n    if (amount0Owed > 0) IERC20(state.depositorSwapTokens ? state.tokenB : state.tokenA).safeTransfer(msg.sender, amount0Owed);\n    if (amount1Owed > 0) IERC20(state.depositorSwapTokens ? state.tokenA : state.tokenB).safeTransfer(msg.sender, amount1Owed);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Handles the deposit operation.\n  function _depositorEnter(\n    uint[] memory amountsDesired_\n  ) override internal virtual returns (uint[] memory amountsConsumed, uint liquidityOut) {\n    (amountsConsumed, liquidityOut, state.totalLiquidity) = UniswapV3ConverterStrategyLogicLib.enter(state.pool, state.lowerTick, state.upperTick, amountsDesired_, state.totalLiquidity, state.depositorSwapTokens);\n  }\n\n  /// @notice Handles the withdrawal operation.\n  /// @param liquidityAmount The amount of liquidity to be withdrawn.\n  /// @return amountsOut The amounts of the tokens withdrawn.\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    (uint fee0, uint fee1) = getFees();\n    state.rebalanceEarned0 += fee0;\n    state.rebalanceEarned1 += fee1;\n    (amountsOut, state.totalLiquidity, state.totalLiquidityFillup) = UniswapV3ConverterStrategyLogicLib.exit(state.pool, state.lowerTick, state.upperTick, state.lowerTickFillup, state.upperTickFillup, state.totalLiquidity, state.totalLiquidityFillup, uint128(liquidityAmount), state.depositorSwapTokens);\n  }\n\n  /// @notice Returns the amount of tokens that would be withdrawn based on the provided liquidity amount.\n  /// @param liquidityAmount The amount of liquidity to quote the withdrawal for.\n  /// @return amountsOut The amounts of the tokens that would be withdrawn.\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    amountsOut = UniswapV3ConverterStrategyLogicLib.quoteExit(state.pool, state.lowerTick, state.upperTick, state.lowerTickFillup, state.upperTickFillup, state.totalLiquidity, state.totalLiquidityFillup, uint128(liquidityAmount), state.depositorSwapTokens);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claims all possible rewards.\n  /// @return tokensOut An array containing the addresses of the reward tokens,\n  /// @return amountsOut An array containing the amounts of the reward tokens.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    amountsOut = UniswapV3ConverterStrategyLogicLib.claimRewards(state.pool, state.lowerTick, state.upperTick, state.lowerTickFillup, state.upperTickFillup, state.rebalanceEarned0, state.rebalanceEarned1, state.depositorSwapTokens);\n    state.rebalanceEarned0 = 0;\n    state.rebalanceEarned1 = 0;\n    tokensOut = new address[](2);\n    tokensOut[0] = state.tokenA;\n    tokensOut[1] = state.tokenB;\n  }\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[49] private __gap;\n\n}\n"
    },
    "contracts/strategies/uniswap/UniswapV3Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/uniswap/IUniswapV3Pool.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\n\n/// @title Uniswap V3 liquidity management helper\n/// @notice Provides functions for computing liquidity amounts from token amounts and prices\nlibrary UniswapV3Lib {\n  uint8 internal constant RESOLUTION = 96;\n  uint internal constant Q96 = 0x1000000000000000000000000;\n  uint private constant TWO_96 = 2 ** 96;\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n  int24 internal constant MIN_TICK = - 887272;\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n  int24 internal constant MAX_TICK = - MIN_TICK;\n\n  struct PoolPosition {\n    address pool;\n    int24 lowerTick;\n    int24 upperTick;\n    uint128 liquidity;\n    address owner;\n  }\n\n  function getTickSpacing(uint24 fee) external pure returns (int24) {\n    if (fee == 10000) {\n      return 200;\n    }\n    if (fee == 3000) {\n      return 60;\n    }\n    if (fee == 500) {\n      return 10;\n    }\n    return 1;\n  }\n\n  function getFees(PoolPosition memory position) public view returns (uint fee0, uint fee1) {\n    bytes32 positionId = _getPositionId(position);\n    IUniswapV3Pool pool = IUniswapV3Pool(position.pool);\n    (, int24 tick, , , , ,) = pool.slot0();\n    (, uint feeGrowthInside0Last, uint feeGrowthInside1Last, uint128 tokensOwed0, uint128 tokensOwed1) = pool.positions(positionId);\n    fee0 = _computeFeesEarned(position, true, feeGrowthInside0Last, tick) + uint(tokensOwed0);\n    fee1 = _computeFeesEarned(position, false, feeGrowthInside1Last, tick) + uint(tokensOwed1);\n  }\n\n  function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\n    IUniswapV3Pool pool = IUniswapV3Pool(pool_);\n    (uint160 sqrtRatioX96, , , , , ,) = pool.slot0();\n    liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\n    (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\n  }\n\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\n  /// pool prices and the prices at the tick boundaries\n  function getLiquidityForAmounts(\n    uint160 sqrtRatioX96,\n    int24 lowerTick,\n    int24 upperTick,\n    uint amount0,\n    uint amount1\n  ) public pure returns (uint128 liquidity) {\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\n      uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\n    } else {\n      liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\n    }\n  }\n\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\n  /// pool prices and the prices at the tick boundaries\n  function getAmountsForLiquidity(\n    uint160 sqrtRatioX96,\n    int24 lowerTick,\n    int24 upperTick,\n    uint128 liquidity\n  ) public pure returns (uint amount0, uint amount1) {\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\n\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\n      amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\n      amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\n    } else {\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\n    }\n  }\n\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(\n    uint a,\n    uint b,\n    uint denominator\n  ) public pure returns (uint result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = a * b\n    // Compute the product mod 2**256 and mod 2**256 - 1\n    // then use the Chinese Remainder Theorem to reconstruct\n    // the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2**256 + prod0\n    uint prod0;\n    // Least significant 256 bits of the product\n    uint prod1;\n    // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(a, b, not(0))\n      prod0 := mul(a, b)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division\n    if (prod1 == 0) {\n      require(denominator > 0);\n      assembly {\n        result := div(prod0, denominator)\n      }\n      return result;\n    }\n\n    // Make sure the result is less than 2**256.\n    // Also prevents denominator == 0\n    require(denominator > prod1);\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0]\n    // Compute remainder using mulmod\n    uint remainder;\n    assembly {\n      remainder := mulmod(a, b, denominator)\n    }\n    // Subtract 256 bit number from 512 bit number\n    assembly {\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator\n    // Compute largest power of two divisor of denominator.\n    // Always >= 1.\n    // EDIT for 0.8 compatibility:\n    // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\n    uint twos = denominator & (~denominator + 1);\n\n    // Divide denominator by power of two\n    assembly {\n      denominator := div(denominator, twos)\n    }\n\n    // Divide [prod1 prod0] by the factors of two\n    assembly {\n      prod0 := div(prod0, twos)\n    }\n    // Shift in bits from prod1 into prod0. For this we need\n    // to flip `twos` such that it is 2**256 / twos.\n    // If twos is zero, then it becomes one\n    assembly {\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2**256\n    // Now that denominator is an odd number, it has an inverse\n    // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n    // Compute the inverse by starting with a seed that is correct\n    // correct for four bits. That is, denominator * inv = 1 mod 2**4\n    uint inv = (3 * denominator) ^ 2;\n    // Now use Newton-Raphson iteration to improve the precision.\n    // Thanks to Hensel's lifting lemma, this also works in modular\n    // arithmetic, doubling the correct bits in each step.\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**8\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**16\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**32\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**64\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**128\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**256\n\n    // Because the division is now exact we can divide by multiplying\n    // with the modular inverse of denominator. This will give us the\n    // correct result modulo 2**256. Since the precoditions guarantee\n    // that the outcome is less than 2**256, this is the final result.\n    // We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inv;\n    return result;\n  }\n  }\n\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(\n    uint a,\n    uint b,\n    uint denominator\n  ) internal pure returns (uint result) {\n    result = mulDiv(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      require(result < type(uint).max);\n      result++;\n    }\n  }\n\n  /// @notice Calculates price in pool\n  function getPrice(address pool_, address tokenIn) public view returns (uint) {\n    IUniswapV3Pool pool = IUniswapV3Pool(pool_);\n    address token0 = pool.token0();\n    address token1 = pool.token1();\n\n    uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\n    (uint160 sqrtPriceX96,,,,,,) = pool.slot0();\n\n    uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\n\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\n    uint purePrice;\n    uint precision;\n    if (tokenIn == token0) {\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\n      purePrice = part * part;\n    } else {\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\n      purePrice = part * part;\n    }\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount0 The amount0 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\n    return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param amount1 The amount1 being sent in\n  /// @return liquidity The amount of returned liquidity\n  function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\n  }\n\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount0 The amount0\n  function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\n  }\n\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The liquidity being valued\n  /// @return amount1 The amount1\n  function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n    }\n    return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\n  }\n\n  function _computeFeesEarned(\n    PoolPosition memory position,\n    bool isZero,\n    uint feeGrowthInsideLast,\n    int24 tick\n  ) internal view returns (uint fee) {\n    IUniswapV3Pool pool = IUniswapV3Pool(position.pool);\n    uint feeGrowthOutsideLower;\n    uint feeGrowthOutsideUpper;\n    uint feeGrowthGlobal;\n    if (isZero) {\n      feeGrowthGlobal = pool.feeGrowthGlobal0X128();\n      (,, feeGrowthOutsideLower,,,,,) = pool.ticks(position.lowerTick);\n      (,, feeGrowthOutsideUpper,,,,,) = pool.ticks(position.upperTick);\n    } else {\n      feeGrowthGlobal = pool.feeGrowthGlobal1X128();\n      (,,, feeGrowthOutsideLower,,,,) = pool.ticks(position.lowerTick);\n      (,,, feeGrowthOutsideUpper,,,,) = pool.ticks(position.upperTick);\n    }\n\n  unchecked {\n    // calculate fee growth below\n    uint feeGrowthBelow;\n    if (tick >= position.lowerTick) {\n      feeGrowthBelow = feeGrowthOutsideLower;\n    } else {\n      feeGrowthBelow = feeGrowthGlobal - feeGrowthOutsideLower;\n    }\n\n    // calculate fee growth above\n    uint feeGrowthAbove;\n    if (tick < position.upperTick) {\n      feeGrowthAbove = feeGrowthOutsideUpper;\n    } else {\n      feeGrowthAbove = feeGrowthGlobal - feeGrowthOutsideUpper;\n    }\n\n    uint feeGrowthInside =\n    feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove;\n    fee = mulDiv(\n      position.liquidity,\n      feeGrowthInside - feeGrowthInsideLast,\n      0x100000000000000000000000000000000\n    );\n  }\n  }\n\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\n  /// @dev Throws if |tick| > max tick\n  /// @param tick The input tick for the above formula\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n  /// at the given tick\n  function _getSqrtRatioAtTick(int24 tick)\n  internal\n  pure\n  returns (uint160 sqrtPriceX96)\n  {\n    uint256 absTick =\n    tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\n\n    // EDIT: 0.8 compatibility\n    require(absTick <= uint256(int256(MAX_TICK)), \"T\");\n\n    uint256 ratio =\n    absTick & 0x1 != 0\n    ? 0xfffcb933bd6fad37aa2d162d1a594001\n    : 0x100000000000000000000000000000000;\n    if (absTick & 0x2 != 0)\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n    if (absTick & 0x4 != 0)\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n    if (absTick & 0x8 != 0)\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n    if (absTick & 0x10 != 0)\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n    if (absTick & 0x20 != 0)\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n    if (absTick & 0x40 != 0)\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n    if (absTick & 0x80 != 0)\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n    if (absTick & 0x100 != 0)\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n    if (absTick & 0x200 != 0)\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n    if (absTick & 0x400 != 0)\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n    if (absTick & 0x800 != 0)\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n    if (absTick & 0x1000 != 0)\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n    if (absTick & 0x2000 != 0)\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n    if (absTick & 0x4000 != 0)\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n    if (absTick & 0x8000 != 0)\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n    if (absTick & 0x10000 != 0)\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n    if (absTick & 0x20000 != 0)\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n    if (absTick & 0x40000 != 0)\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n    if (absTick & 0x80000 != 0)\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n    if (tick > 0) ratio = type(uint256).max / ratio;\n\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n    sqrtPriceX96 = uint160(\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\n    );\n  }\n\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n  /// ever return.\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n  function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    // second inequality must be < because the price can never reach the price at the max tick\n    require(\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\n      \"R\"\n    );\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n    uint256 r = ratio;\n    uint256 msb = 0;\n\n    assembly {\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(5, gt(r, 0xFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(4, gt(r, 0xFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(3, gt(r, 0xFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(2, gt(r, 0xF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(1, gt(r, 0x3))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := gt(r, 0x1)\n      msb := or(msb, f)\n    }\n\n    if (msb >= 128) r = ratio >> (msb - 127);\n    else r = ratio << (127 - msb);\n\n    int256 log_2 = (int256(msb) - 128) << 64;\n\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(63, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(62, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(61, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(60, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(59, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(58, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(57, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(56, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(55, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(54, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(53, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(52, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(51, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(50, f))\n    }\n\n    tick = _getFinalTick(log_2, sqrtPriceX96);\n  }\n\n  function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n    // 128.128 number\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\n\n    int24 tickLow =\n    int24(\n      (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\n    );\n    int24 tickHi =\n    int24(\n      (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\n    );\n\n    tick = (tickLow == tickHi)\n    ? tickLow\n    : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96\n    ? tickHi\n    : tickLow);\n  }\n\n  function _getPositionId(PoolPosition memory position) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(position.owner, position.lowerTick, position.upperTick));\n  }\n\n  function _countDigits(uint n) internal pure returns (uint) {\n    if (n == 0) {\n      return 0;\n    }\n    uint count = 0;\n    while (n != 0) {\n      n = n / 10;\n      ++count;\n    }\n    return count;\n  }\n\n  function _min(uint a, uint b) internal pure returns (uint) {\n    return a < b ? a : b;\n  }\n\n  function _max(uint a, uint b) internal pure returns (uint) {\n    return a > b ? a : b;\n  }\n\n  function _toUint128(uint x) private pure returns (uint128 y) {\n    require((y = uint128(x)) == x);\n  }\n}\n"
    },
    "contracts/test/aave/Aave3AggregatorInterfaceMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/aave/AggregatorInterface.sol\";\n\n/// @notice A source of asset's price for AAVE3 price oracle\n///         See price oracle 0xb023e699F5a33916Ea823A16485e259257cA8Bd1\ncontract Aave3AggregatorInterfaceMock is AggregatorInterface {\n  int256 public price;\n  uint public round;\n  mapping(uint => uint) roundToTimestamp;\n  mapping(uint => int256) roundToPrice;\n\n  constructor (int256 price_) {\n    price = price_;\n    round = 1;\n    roundToTimestamp[round] = block.timestamp;\n    roundToPrice[round] = price_;\n  }\n\n  function setPrice(int256 price_) external {\n    price = price_;\n    round += 1;\n    roundToTimestamp[round] = block.timestamp;\n    roundToPrice[round] = price_;\n  }\n\n  // ---------------  AggregatorInterface ----------------------------------------------------------\n  function latestAnswer() external override view returns (int256) {\n    return price;\n  }\n\n  function latestTimestamp() external override view returns (uint256) {\n    return roundToTimestamp[round];\n  }\n\n  function latestRound() external override view returns (uint256) {\n    return round;\n  }\n\n  function getAnswer(uint256 roundId) external override view returns (int256) {\n    return roundToPrice[roundId];\n  }\n\n  function getTimestamp(uint256 roundId) external override view returns (uint256) {\n    return roundToTimestamp[roundId];\n  }\n}"
    },
    "contracts/test/balancer/BalancerComposableStableDepositorFacade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../strategies/balancer/BalancerComposableStableDepositor.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @notice Provide direct access to internal functions of {BalancerBoostedAaveStableDepositor}\ncontract BalancerComposableStableDepositorFacade is BalancerComposableStableDepositor {\n  function init(\n    bytes32 poolId,\n    address[] memory rewardTokens_\n  ) external initializer {\n    console.log(\"BalancerComposableStableDepositorFacade.init\", rewardTokens_.length);\n    __BalancerBoostedAaveUsdDepositor_init(poolId, rewardTokens_);\n  }\n\n  function _depositorPoolAssetsAccess() external virtual view returns (address[] memory poolAssets) {\n    return _depositorPoolAssets();\n  }\n\n  function _depositorPoolWeightsAccess() external virtual view returns (uint[] memory weights, uint totalWeight) {\n    return _depositorPoolWeights();\n  }\n\n  function _depositorPoolReservesAccess() external virtual view returns (uint[] memory reserves) {\n    return _depositorPoolReserves();\n  }\n\n  function _depositorLiquidityAccess() external virtual view returns (uint) {\n    return _depositorLiquidity();\n  }\n\n  function _depositorTotalSupplyAccess() external view returns (uint) {\n    return _depositorTotalSupply();\n  }\n\n  uint[] public lastAmountsConsumedOut;\n  uint public lastAmountsConsumedOutLength;\n  uint public lastLiquidityOut;\n\n  function _depositorEnterAccess(uint[] memory amountsDesired_) external virtual returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    (amountsConsumedOut, liquidityOut) = _depositorEnter(amountsDesired_);\n    // let's store results of _depositorEnter last call to public members\n    (lastAmountsConsumedOut, lastLiquidityOut) = (amountsConsumedOut, liquidityOut);\n    lastAmountsConsumedOutLength = lastAmountsConsumedOut.length;\n  }\n\n  uint[] public lastAmountsOut;\n  uint public lastAmountsOutLength;\n  uint public lastLiquidityAmountIn;\n\n  function _depositorExitAccess(uint liquidityAmount_) external returns (uint[] memory) {\n    lastLiquidityAmountIn = liquidityAmount_ == 0  // 0 means that we should withdraw all liquidity\n    ? _depositorLiquidity()\n    : liquidityAmount_;\n    lastAmountsOut = _depositorExit(lastLiquidityAmountIn);\n    lastAmountsOutLength = lastAmountsOut.length;\n    return lastAmountsOut;\n  }\n\n  uint[] public lastQuoteExitAmountsOut;\n  uint public lastQuoteExitAmountsOutLength;\n\n  function _depositorQuoteExitAccess(uint liquidityAmount_) external returns (uint[] memory) {\n    lastQuoteExitAmountsOut = _depositorQuoteExit(\n      liquidityAmount_ == 0  // 0 means that we should withdraw all liquidity\n      ? _depositorLiquidity()\n      : liquidityAmount_\n    );\n    lastQuoteExitAmountsOutLength = lastQuoteExitAmountsOut.length;\n    return lastQuoteExitAmountsOut;\n  }\n\n  uint[] public lastRewardsAmountsOut;\n  address[] public lastRewardsTokensOut;\n  uint public lastRewardsAmountsOutLength;\n  uint public lastRewardsTokensOutLength;\n\n  function _depositorClaimRewardsAccess() external virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    (tokensOut, amountsOut) = _depositorClaimRewards();\n    console.log(\"_depositorClaimRewardsAccess.tokensOut\", tokensOut.length);\n    console.log(\"_depositorClaimRewardsAccess.amountsOut\", amountsOut.length);\n    lastRewardsAmountsOut = amountsOut;\n    lastRewardsTokensOut = tokensOut;\n    lastRewardsAmountsOutLength = amountsOut.length;\n    lastRewardsTokensOutLength = tokensOut.length;\n  }\n}\n"
    },
    "contracts/test/balancer/BalancerLogicLibFacade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"../../strategies/balancer/BalancerLogicLib.sol\";\n\n/// @notice Provide external access to all functions of BalancerLogicLib\ncontract BalancerLogicLibFacade {\n  function getAmountsToDeposit(\n    uint[] memory amountsDesired_,\n    IERC20[] memory tokens_,\n    uint[] memory balances_,\n    uint[] memory totalUnderlying_,\n    uint indexBpt_\n  ) external view returns (\n    uint[] memory amountsOut\n  ) {\n    return BalancerLogicLib.getAmountsToDeposit(amountsDesired_, tokens_, balances_, totalUnderlying_, indexBpt_);\n  }\n\n  function getTotalAssetAmounts(IBVault vault_, IERC20[] memory tokens_, uint indexBpt_) external view returns (\n    uint[] memory amountsOut\n  ) {\n    return BalancerLogicLib.getTotalAssetAmounts(vault_, tokens_, indexBpt_);\n  }\n\n  function getBtpAmountsOut(\n    uint liquidityAmount_,\n    uint[] memory balances_,\n    uint bptIndex_\n  ) external pure returns (uint[] memory) {\n    return BalancerLogicLib.getBtpAmountsOut(liquidityAmount_, balances_, bptIndex_);\n  }\n}\n"
    },
    "contracts/test/BalancerComposableStableStrategyAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/balancer/BalancerComposableStableStrategy.sol\";\n\n/// @notice Provide direct access to BalancerComposableStableStrategy internal functions\ncontract BalancerComposableStableStrategyAccess is BalancerComposableStableStrategy {\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  ///  Set up\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function setBaseAmountAccess(address token_, uint amount_) external {\n    baseAmounts[token_] = amount_;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  ///  Access to internal functions\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function _depositToPoolAccess(uint amount_, bool updateTotalAssetsBeforeInvest_) external returns (\n    int totalAssetsDelta\n  ) {\n    return _depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n  }\n\n  function _withdrawFromPoolAccess(uint amount) external returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    return _withdrawFromPool(amount);\n  }\n\n  function _withdrawAllFromPoolAccess() external returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    return _withdrawAllFromPool();\n  }\n}"
    },
    "contracts/test/compound-core/BaseJumpRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./InterestRateModel.sol\";\n\n/**\n  * @title Logic for Compound's JumpRateModel Contract V2.\n  * @author Compound (modified by Dharma Labs, refactored by Arr00)\n  * @notice Version 2 modifies Version 1 by enabling updateable parameters.\n  */\nabstract contract BaseJumpRateModelV2 is InterestRateModel {\n  event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\n\n  uint256 private constant BASE = 1e18;\n\n  /**\n   * @notice The address of the owner, i.e. the Timelock contract, which can update parameters directly\n     */\n  address public owner;\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n  uint public constant blocksPerYear = 2102400;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n  uint public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n  uint public baseRatePerBlock;\n\n  /**\n   * @notice The multiplierPerBlock after hitting a specified utilization point\n     */\n  uint public jumpMultiplierPerBlock;\n\n  /**\n   * @notice The utilization point at which the jump multiplier is applied\n     */\n  uint public kink;\n\n  /**\n   * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n     */\n  constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_) {\n    owner = owner_;\n\n    updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n  }\n\n  /**\n   * @notice Update the parameters of the interest rate model (only callable by owner, i.e. Timelock)\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n  function updateJumpRateModel(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) virtual external {\n    require(msg.sender == owner, \"only the owner may call this function.\");\n\n    updateJumpRateModelInternal(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_);\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, BASE]\n     */\n  function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return borrows * BASE / (cash + borrows - reserves);\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\n     */\n  function getBorrowRateInternal(uint cash, uint borrows, uint reserves) internal view returns (uint) {\n    uint util = utilizationRate(cash, borrows, reserves);\n\n    if (util <= kink) {\n      return ((util * multiplierPerBlock) / BASE) + baseRatePerBlock;\n    } else {\n      uint normalRate = ((kink * multiplierPerBlock) / BASE) + baseRatePerBlock;\n      uint excessUtil = util - kink;\n      return ((excessUtil * jumpMultiplierPerBlock) / BASE) + normalRate;\n    }\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by BASE)\n     */\n  function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual override public view returns (uint) {\n    uint oneMinusReserveFactor = BASE - reserveFactorMantissa;\n    uint borrowRate = getBorrowRateInternal(cash, borrows, reserves);\n    uint rateToPool = borrowRate * oneMinusReserveFactor / BASE;\n    return utilizationRate(cash, borrows, reserves) * rateToPool / BASE;\n  }\n\n  /**\n   * @notice Internal function to update the parameters of the interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n  function updateJumpRateModelInternal(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) internal {\n    baseRatePerBlock = baseRatePerYear / blocksPerYear;\n    multiplierPerBlock = (multiplierPerYear * BASE) / (blocksPerYear * kink_);\n    jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\n    kink = kink_;\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n  }\n}\n"
    },
    "contracts/test/compound-core/CDaiDelegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CErc20Delegate.sol\";\n\n/**\n * @title Compound's CDai Contract\n * @notice CToken which wraps Multi-Collateral DAI\n * @author Compound\n */\ncontract CDaiDelegate is CErc20Delegate {\n  /**\n   * @notice DAI adapter address\n     */\n  address public daiJoinAddress;\n\n  /**\n   * @notice DAI Savings Rate (DSR) pot address\n     */\n  address public potAddress;\n\n  /**\n   * @notice DAI vat address\n     */\n  address public vatAddress;\n\n  /**\n   * @notice Delegate interface to become the implementation\n     * @param data The encoded arguments for becoming\n     */\n  function _becomeImplementation(bytes memory data) override public {\n    require(msg.sender == admin, \"only the admin may initialize the implementation\");\n\n    (address daiJoinAddress_, address potAddress_) = abi.decode(data, (address, address));\n    return _becomeImplementation(daiJoinAddress_, potAddress_);\n  }\n\n  /**\n   * @notice Explicit interface to become the implementation\n     * @param daiJoinAddress_ DAI adapter address\n     * @param potAddress_ DAI Savings Rate (DSR) pot address\n     */\n  function _becomeImplementation(address daiJoinAddress_, address potAddress_) internal {\n    // Get dai and vat and sanity check the underlying\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress_);\n    PotLike pot = PotLike(potAddress_);\n    GemLike dai = daiJoin.dai();\n    VatLike vat = daiJoin.vat();\n    require(address(dai) == underlying, \"DAI must be the same as underlying\");\n\n    // Remember the relevant addresses\n    daiJoinAddress = daiJoinAddress_;\n    potAddress = potAddress_;\n    vatAddress = address(vat);\n\n    // Approve moving our DAI into the vat through daiJoin\n    dai.approve(daiJoinAddress, type(uint).max);\n\n    // Approve the pot to transfer our funds within the vat\n    vat.hope(potAddress);\n    vat.hope(daiJoinAddress);\n\n    // Accumulate DSR interest -- must do this in order to doTransferIn\n    pot.drip();\n\n    // Transfer all cash in (doTransferIn does this regardless of amount)\n    doTransferIn(address(this), 0);\n  }\n\n  /**\n   * @notice Delegate interface to resign the implementation\n     */\n  function _resignImplementation() override public {\n    require(msg.sender == admin, \"only the admin may abandon the implementation\");\n\n    // Transfer all cash out of the DSR - note that this relies on self-transfer\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n    PotLike pot = PotLike(potAddress);\n    VatLike vat = VatLike(vatAddress);\n\n    // Accumulate interest\n    pot.drip();\n\n    // Calculate the total amount in the pot, and move it out\n    uint pie = pot.pie(address(this));\n    pot.exit(pie);\n\n    // Checks the actual balance of DAI in the vat after the pot exit\n    uint bal = vat.dai(address(this));\n\n    // Remove our whole balance\n    daiJoin.exit(address(this), bal / RAY);\n  }\n\n  /*** CToken Overrides ***/\n\n  /**\n    * @notice Accrues DSR then applies accrued interest to total borrows and reserves\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      */\n  function accrueInterest() override public returns (uint) {\n    // Accumulate DSR interest\n    PotLike(potAddress).drip();\n\n    // Accumulate CToken interest\n    return super.accrueInterest();\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n  function getCashPrior() override internal view returns (uint) {\n    PotLike pot = PotLike(potAddress);\n    uint pie = pot.pie(address(this));\n    return mul(pot.chi(), pie) / RAY;\n  }\n\n  /**\n   * @notice Transfer the underlying to this contract and sweep into DSR pot\n     * @param from Address to transfer funds from\n     * @param amount Amount of underlying to transfer\n     * @return The actual amount that is transferred\n     */\n  function doTransferIn(address from, uint amount) override internal returns (uint) {\n    // Read from storage once\n    address underlying_ = underlying;\n    // Perform the EIP-20 transfer in\n    EIP20Interface token = EIP20Interface(underlying_);\n    require(token.transferFrom(from, address(this), amount), \"unexpected EIP-20 transfer in return\");\n\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n    GemLike dai = GemLike(underlying_);\n    PotLike pot = PotLike(potAddress);\n    VatLike vat = VatLike(vatAddress);\n\n    // Convert all our DAI to internal DAI in the vat\n    daiJoin.join(address(this), dai.balanceOf(address(this)));\n\n    // Checks the actual balance of DAI in the vat after the join\n    uint bal = vat.dai(address(this));\n\n    // Calculate the percentage increase to th pot for the entire vat, and move it in\n    // Note: We may leave a tiny bit of DAI in the vat...but we do the whole thing every time\n    uint pie = bal / pot.chi();\n    pot.join(pie);\n\n    return amount;\n  }\n\n  /**\n   * @notice Transfer the underlying from this contract, after sweeping out of DSR pot\n     * @param to Address to transfer funds to\n     * @param amount Amount of underlying to transfer\n     */\n  function doTransferOut(address payable to, uint amount) override internal {\n    DaiJoinLike daiJoin = DaiJoinLike(daiJoinAddress);\n    PotLike pot = PotLike(potAddress);\n\n    // Calculate the percentage decrease from the pot, and move that much out\n    // Note: Use a slightly larger pie size to ensure that we get at least amount in the vat\n    uint pie = add(mul(amount, RAY) / pot.chi(), 1);\n    pot.exit(pie);\n\n    daiJoin.exit(to, amount);\n  }\n\n  /*** Maker Internals ***/\n\n  uint256 constant RAY = 10 ** 27;\n\n  function add(uint x, uint y) internal pure returns (uint z) {\n    require((z = x + y) >= x, \"add-overflow\");\n  }\n\n  function mul(uint x, uint y) internal pure returns (uint z) {\n    require(y == 0 || (z = x * y) / y == x, \"mul-overflow\");\n  }\n}\n\n/*** Maker Interfaces ***/\n\ninterface PotLike {\n  function chi() external view returns (uint);\n\n  function pie(address) external view returns (uint);\n\n  function drip() external returns (uint);\n\n  function join(uint) external;\n\n  function exit(uint) external;\n}\n\ninterface GemLike {\n  function approve(address, uint) external;\n\n  function balanceOf(address) external view returns (uint);\n\n  function transferFrom(address, address, uint) external returns (bool);\n}\n\ninterface VatLike {\n  function dai(address) external view returns (uint);\n\n  function hope(address) external;\n}\n\ninterface DaiJoinLike {\n  function vat() external returns (VatLike);\n\n  function dai() external returns (GemLike);\n\n  function join(address, uint) external payable;\n\n  function exit(address, uint) external;\n}\n"
    },
    "contracts/test/compound-core/CErc20.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\n\ninterface CompLike {\n  function delegate(address delegatee) external;\n}\n\n/**\n * @title Compound's CErc20 Contract\n * @notice CTokens which wrap an EIP-20 underlying\n * @author Compound\n */\ncontract CErc20 is CToken, CErc20Interface {\n  /**\n   * @notice Initialize the new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     */\n  function initialize(address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_) public {\n    // CToken initialize does the bulk of the work\n    super.initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n    // Set underlying and sanity check it\n    underlying = underlying_;\n    EIP20Interface(underlying).totalSupply();\n  }\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function mint(uint mintAmount) override external returns (uint) {\n    mintInternal(mintAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function redeem(uint redeemTokens) override external returns (uint) {\n    redeemInternal(redeemTokens);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function redeemUnderlying(uint redeemAmount) override external returns (uint) {\n    redeemUnderlyingInternal(redeemAmount);\n    return NO_ERROR;\n  }\n\n  /**\n    * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function borrow(uint borrowAmount) override external returns (uint) {\n    borrowInternal(borrowAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function repayBorrow(uint repayAmount) override external returns (uint) {\n    repayBorrowInternal(repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\n    repayBorrowBehalfInternal(borrower, repayAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) override external returns (uint) {\n    liquidateBorrowInternal(borrower, repayAmount, cTokenCollateral);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n     * @param token The address of the ERC-20 token to sweep\n     */\n  function sweepToken(EIP20NonStandardInterface token) override external {\n    require(msg.sender == admin, \"CErc20::sweepToken: only admin can sweep tokens\");\n    require(address(token) != underlying, \"CErc20::sweepToken: can not sweep underlying token\");\n    uint256 balance = token.balanceOf(address(this));\n    token.transfer(admin, balance);\n  }\n\n  /**\n   * @notice The sender adds to reserves.\n     * @param addAmount The amount fo underlying token to add as reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function _addReserves(uint addAmount) override external returns (uint) {\n    return _addReservesInternal(addAmount);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying tokens owned by this contract\n     */\n  function getCashPrior() virtual override internal view returns (uint) {\n    EIP20Interface token = EIP20Interface(underlying);\n    return token.balanceOf(address(this));\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False result from `transferFrom` and reverts in that case.\n     *      This will revert due to insufficient balance or insufficient allowance.\n     *      This function returns the actual amount received,\n     *      which may be less than `amount` if there is a fee attached to the transfer.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n  function doTransferIn(address from, uint amount) virtual override internal returns (uint) {\n    // Read from storage once\n    address underlying_ = underlying;\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying_);\n    uint balanceBefore = EIP20Interface(underlying_).balanceOf(address(this));\n    token.transferFrom(from, address(this), amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {// This is a non-standard ERC-20\n        success := not(0)          // set success to true\n      }\n      case 32 {// This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0)        // Set `success = returndata` of override external call\n      }\n      default {// This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_IN_FAILED\");\n\n    // Calculate the amount that was *actually* transferred\n    uint balanceAfter = EIP20Interface(underlying_).balanceOf(address(this));\n    return balanceAfter - balanceBefore;\n    // underflow already checked above, just subtract\n  }\n\n  /**\n   * @dev Similar to EIP20 transfer, except it handles a False success from `transfer` and returns an explanatory\n     *      error code rather than reverting. If caller has not called checked protocol's balance, this may revert due to\n     *      insufficient cash held in this contract. If caller has checked protocol's balance prior to this call, and verified\n     *      it is >= amount, this should not revert in normal conditions.\n     *\n     *      Note: This wrapper safely handles non-standard ERC-20 tokens that do not return a value.\n     *            See here: https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n     */\n  function doTransferOut(address payable to, uint amount) virtual override internal {\n    EIP20NonStandardInterface token = EIP20NonStandardInterface(underlying);\n    token.transfer(to, amount);\n\n    bool success;\n    assembly {\n      switch returndatasize()\n      case 0 {// This is a non-standard ERC-20\n        success := not(0)          // set success to true\n      }\n      case 32 {// This is a compliant ERC-20\n        returndatacopy(0, 0, 32)\n        success := mload(0)        // Set `success = returndata` of override external call\n      }\n      default {// This is an excessively non-compliant ERC-20, revert.\n        revert(0, 0)\n      }\n    }\n    require(success, \"TOKEN_TRANSFER_OUT_FAILED\");\n  }\n\n  /**\n  * @notice Admin call to delegate the votes of the COMP-like underlying\n    * @param compLikeDelegatee The address to delegate votes to\n    * @dev CTokens whose underlying are not CompLike should revert here\n    */\n  function _delegateCompLikeTo(address compLikeDelegatee) external {\n    require(msg.sender == admin, \"only the admin may set the comp-like delegate\");\n    CompLike(underlying).delegate(compLikeDelegatee);\n  }\n}\n"
    },
    "contracts/test/compound-core/CErc20Delegate.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CErc20.sol\";\n\n/**\n * @title Compound's CErc20Delegate Contract\n * @notice CTokens which wrap an EIP-20 underlying and are delegated to\n * @author Compound\n */\ncontract CErc20Delegate is CErc20, CDelegateInterface {\n  /**\n   * @notice Construct an empty delegate\n     */\n  constructor() {}\n\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n     * @param data The encoded bytes data for any initialization\n     */\n  function _becomeImplementation(bytes memory data) virtual override public {\n    // Shh -- currently unused\n    data;\n\n    // Shh -- we don't ever want this hook to be marked pure\n    if (false) {\n      implementation = address(0);\n    }\n\n    require(msg.sender == admin, \"only the admin may call _becomeImplementation\");\n  }\n\n  /**\n   * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n  function _resignImplementation() virtual override public {\n    // Shh -- we don't ever want this hook to be marked pure\n    if (false) {\n      implementation = address(0);\n    }\n\n    require(msg.sender == admin, \"only the admin may call _resignImplementation\");\n  }\n}\n"
    },
    "contracts/test/compound-core/CErc20Delegator.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CTokenInterfaces.sol\";\n\n/**\n * @title Compound's CErc20Delegator Contract\n * @notice CTokens which wrap an EIP-20 underlying and delegate to an implementation\n * @author Compound\n */\ncontract CErc20Delegator is CTokenInterface, CErc20Interface, CDelegatorInterface {\n  /**\n   * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     * @param implementation_ The address of the implementation the contract delegates to\n     * @param becomeImplementationData The encoded args for becomeImplementation\n     */\n  constructor(address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address payable admin_,\n    address implementation_,\n    bytes memory becomeImplementationData) {\n    // Creator of the contract is admin during initialization\n    admin = payable(msg.sender);\n\n    // First delegate gets to initialize the delegator (i.e. storage contract)\n    delegateTo(implementation_, abi.encodeWithSignature(\"initialize(address,address,address,uint256,string,string,uint8)\",\n      underlying_,\n      comptroller_,\n      interestRateModel_,\n      initialExchangeRateMantissa_,\n      name_,\n      symbol_,\n      decimals_));\n\n    // New implementations always get set via the settor (post-initialize)\n    _setImplementation(implementation_, false, becomeImplementationData);\n\n    // Set the proper admin now that initialization is done\n    admin = admin_;\n  }\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n  function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) override public {\n    require(msg.sender == admin, \"CErc20Delegator::_setImplementation: Caller must be admin\");\n\n    if (allowResign) {\n      delegateToImplementation(abi.encodeWithSignature(\"_resignImplementation()\"));\n    }\n\n    address oldImplementation = implementation;\n    implementation = implementation_;\n\n    delegateToImplementation(abi.encodeWithSignature(\"_becomeImplementation(bytes)\", becomeImplementationData));\n\n    emit NewImplementation(oldImplementation, implementation);\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function mint(uint mintAmount) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"mint(uint256)\", mintAmount));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function redeem(uint redeemTokens) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeem(uint256)\", redeemTokens));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function redeemUnderlying(uint redeemAmount) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"redeemUnderlying(uint256)\", redeemAmount));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n    * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function borrow(uint borrowAmount) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrow(uint256)\", borrowAmount));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function repayBorrow(uint repayAmount) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrow(uint256)\", repayAmount));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function repayBorrowBehalf(address borrower, uint repayAmount) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"repayBorrowBehalf(address,uint256)\", borrower, repayAmount));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"liquidateBorrow(address,uint256,address)\", borrower, repayAmount, cTokenCollateral));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n  function transfer(address dst, uint amount) override external returns (bool) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transfer(address,uint256)\", dst, amount));\n    return abi.decode(data, (bool));\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n  function transferFrom(address src, address dst, uint256 amount) override external returns (bool) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", src, dst, amount));\n    return abi.decode(data, (bool));\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n  function approve(address spender, uint256 amount) override external returns (bool) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"approve(address,uint256)\", spender, amount));\n    return abi.decode(data, (bool));\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n  function allowance(address owner, address spender) override external view returns (uint) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"allowance(address,address)\", owner, spender));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n  function balanceOf(address owner) override external view returns (uint) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"balanceOf(address)\", owner));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n  function balanceOfUnderlying(address owner) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"balanceOfUnderlying(address)\", owner));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n  function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getAccountSnapshot(address)\", account));\n    return abi.decode(data, (uint, uint, uint, uint));\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n  function borrowRatePerBlock() override external view returns (uint) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowRatePerBlock()\"));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n  function supplyRatePerBlock() override external view returns (uint) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"supplyRatePerBlock()\"));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n  function totalBorrowsCurrent() override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"totalBorrowsCurrent()\"));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n  function borrowBalanceCurrent(address account) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"borrowBalanceCurrent(address)\", account));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n  function borrowBalanceStored(address account) override public view returns (uint) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"borrowBalanceStored(address)\", account));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n  function exchangeRateCurrent() override public returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"exchangeRateCurrent()\"));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n  function exchangeRateStored() override public view returns (uint) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"exchangeRateStored()\"));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n  function getCash() override external view returns (uint) {\n    bytes memory data = delegateToViewImplementation(abi.encodeWithSignature(\"getCash()\"));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n    * @notice Applies accrued interest to total borrows and reserves.\n      * @dev This calculates interest accrued from the last checkpointed block\n      *      up to the current block and writes new checkpoint to storage.\n      */\n  function accrueInterest() override public returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"accrueInterest()\"));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function seize(address liquidator, address borrower, uint seizeTokens) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"seize(address,address,uint256)\", liquidator, borrower, seizeTokens));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice A public function to sweep accidental ERC-20 transfers to this contract. Tokens are sent to admin (timelock)\n     * @param token The address of the ERC-20 token to sweep\n     */\n  function sweepToken(EIP20NonStandardInterface token) override external {\n    delegateToImplementation(abi.encodeWithSignature(\"sweepToken(address)\", token));\n  }\n\n\n  /*** Admin Functions ***/\n\n  /**\n    * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setPendingAdmin(address)\", newPendingAdmin));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n    * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _setComptroller(ComptrollerInterface newComptroller) override public returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setComptroller(address)\", newComptroller));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n    * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _setReserveFactor(uint newReserveFactorMantissa) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setReserveFactor(uint256)\", newReserveFactorMantissa));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n    * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _acceptAdmin() override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_acceptAdmin()\"));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Accrues interest and adds reserves by transferring from admin\n     * @param addAmount Amount of reserves to add\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function _addReserves(uint addAmount) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_addReserves(uint256)\", addAmount));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function _reduceReserves(uint reduceAmount) override external returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_reduceReserves(uint256)\", reduceAmount));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\n    bytes memory data = delegateToImplementation(abi.encodeWithSignature(\"_setInterestRateModel(address)\", newInterestRateModel));\n    return abi.decode(data, (uint));\n  }\n\n  /**\n   * @notice Internal method to delegate execution to another contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param callee The contract to delegatecall\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n  function delegateTo(address callee, bytes memory data) internal returns (bytes memory) {\n    (bool success, bytes memory returnData) = callee.delegatecall(data);\n    assembly {\n      if eq(success, 0) {\n        revert(add(returnData, 0x20), returndatasize())\n      }\n    }\n    return returnData;\n  }\n\n  /**\n   * @notice Delegates execution to the implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n  function delegateToImplementation(bytes memory data) public returns (bytes memory) {\n    return delegateTo(implementation, data);\n  }\n\n  /**\n   * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     *  There are an additional 2 prefix uints from the wrapper returndata, which we ignore since we make an extra hop.\n     * @param data The raw data to delegatecall\n     * @return The returned bytes from the delegatecall\n     */\n  function delegateToViewImplementation(bytes memory data) public view returns (bytes memory) {\n    (bool success, bytes memory returnData) = address(this).staticcall(abi.encodeWithSignature(\"delegateToImplementation(bytes)\", data));\n    assembly {\n      if eq(success, 0) {\n        revert(add(returnData, 0x20), returndatasize())\n      }\n    }\n    return abi.decode(returnData, (bytes));\n  }\n\n  /**\n   * @notice Delegates execution to an implementation contract\n     * @dev It returns to the external caller whatever the implementation returns or forwards reverts\n     */\n  fallback() external /*payable*/ {\n    //        require(msg.value == 0,\"CErc20Delegator:fallback: cannot send value to fallback\");\n\n    // delegate all other functions to current implementation\n    (bool success,) = implementation.delegatecall(msg.data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize())\n\n      switch success\n      case 0 {revert(free_mem_ptr, returndatasize())}\n      default {return (free_mem_ptr, returndatasize())}\n    }\n  }\n}\n"
    },
    "contracts/test/compound-core/CErc20Immutable.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CErc20.sol\";\n\n/**\n * @title Compound's CErc20Immutable Contract\n * @notice CTokens which wrap an EIP-20 underlying and are immutable\n * @author Compound\n */\ncontract CErc20Immutable is CErc20 {\n  /**\n   * @notice Construct a new money market\n     * @param underlying_ The address of the underlying asset\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     */\n  constructor(address underlying_,\n    ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address payable admin_) {\n    // Creator of the contract is admin during initialization\n    admin = payable(msg.sender);\n\n    // Initialize the market\n    initialize(underlying_, comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n    // Set the proper admin now that initialization is done\n    admin = admin_;\n  }\n}\n"
    },
    "contracts/test/compound-core/CEther.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\n\n/**\n * @title Compound's CEther Contract\n * @notice CToken which wraps Ether\n * @author Compound\n */\ncontract CEther is CToken {\n  /**\n   * @notice Construct a new CEther money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ ERC-20 name of this token\n     * @param symbol_ ERC-20 symbol of this token\n     * @param decimals_ ERC-20 decimal precision of this token\n     * @param admin_ Address of the administrator of this token\n     */\n  constructor(ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_,\n    address payable admin_) {\n    // Creator of the contract is admin during initialization\n    admin = payable(msg.sender);\n\n    initialize(comptroller_, interestRateModel_, initialExchangeRateMantissa_, name_, symbol_, decimals_);\n\n    // Set the proper admin now that initialization is done\n    admin = admin_;\n  }\n\n\n  /*** User Interface ***/\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Reverts upon any failure\n     */\n  function mint() external payable {\n    mintInternal(msg.value);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function redeem(uint redeemTokens) external returns (uint) {\n    redeemInternal(redeemTokens);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to redeem\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function redeemUnderlying(uint redeemAmount) external returns (uint) {\n    redeemUnderlyingInternal(redeemAmount);\n    return NO_ERROR;\n  }\n\n  /**\n    * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function borrow(uint borrowAmount) external returns (uint) {\n    borrowInternal(borrowAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n     * @dev Reverts upon any failure\n     */\n  function repayBorrow() external payable {\n    repayBorrowInternal(msg.value);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n     * @dev Reverts upon any failure\n     * @param borrower the account with the debt being payed off\n     */\n  function repayBorrowBehalf(address borrower) external payable {\n    repayBorrowBehalfInternal(borrower, msg.value);\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @dev Reverts upon any failure\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     */\n  function liquidateBorrow(address borrower, CToken cTokenCollateral) external payable {\n    liquidateBorrowInternal(borrower, msg.value, cTokenCollateral);\n  }\n\n  /**\n   * @notice The sender adds to reserves.\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function _addReserves() external payable returns (uint) {\n    return _addReservesInternal(msg.value);\n  }\n\n  /**\n   * @notice Send Ether to CEther to mint\n     */\n  receive() external payable {\n    mintInternal(msg.value);\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of Ether, before this message\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of Ether owned by this contract\n     */\n  function getCashPrior() override internal view returns (uint) {\n    return address(this).balance - msg.value;\n  }\n\n  /**\n   * @notice Perform the actual transfer in, which is a no-op\n     * @param from Address sending the Ether\n     * @param amount Amount of Ether being sent\n     * @return The actual amount of Ether transferred\n     */\n  function doTransferIn(address from, uint amount) override internal returns (uint) {\n    // Sanity checks\n    require(msg.sender == from, \"sender mismatch\");\n    require(msg.value == amount, \"value mismatch\");\n    return amount;\n  }\n\n  function doTransferOut(address payable to, uint amount) virtual override internal {\n    /* Send the Ether, with minimal gas and revert on failure */\n    to.transfer(amount);\n  }\n}\n"
    },
    "contracts/test/compound-core/Comptroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./Governance/Comp.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n */\ncontract Comptroller is ComptrollerV7Storage, ComptrollerInterface, ComptrollerErrorReporter, ExponentialNoError {\n  /// @notice Emitted when an admin supports a market\n  event MarketListed(CToken cToken);\n\n  /// @notice Emitted when an account enters a market\n  event MarketEntered(CToken cToken, address account);\n\n  /// @notice Emitted when an account exits a market\n  event MarketExited(CToken cToken, address account);\n\n  /// @notice Emitted when close factor is changed by admin\n  event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n  /// @notice Emitted when a collateral factor is changed by admin\n  event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n  /// @notice Emitted when liquidation incentive is changed by admin\n  event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n  /// @notice Emitted when price oracle is changed\n  event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n  /// @notice Emitted when pause guardian is changed\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n  /// @notice Emitted when an action is paused globally\n  event ActionPaused(string action, bool pauseState);\n\n  /// @notice Emitted when an action is paused on a market\n  event ActionPaused(CToken cToken, string action, bool pauseState);\n\n  /// @notice Emitted when a new borrow-side COMP speed is calculated for a market\n  event CompBorrowSpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n  /// @notice Emitted when a new supply-side COMP speed is calculated for a market\n  event CompSupplySpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n  /// @notice Emitted when a new COMP speed is set for a contributor\n  event ContributorCompSpeedUpdated(address indexed contributor, uint newSpeed);\n\n  /// @notice Emitted when COMP is distributed to a supplier\n  event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\n\n  /// @notice Emitted when COMP is distributed to a borrower\n  event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\n\n  /// @notice Emitted when borrow cap for a cToken is changed\n  event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);\n\n  /// @notice Emitted when borrow cap guardian is changed\n  event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n  /// @notice Emitted when COMP is granted by admin\n  event CompGranted(address recipient, uint amount);\n\n  /// @notice Emitted when COMP accrued for a user has been manually adjusted.\n  event CompAccruedAdjusted(address indexed user, uint oldCompAccrued, uint newCompAccrued);\n\n  /// @notice Emitted when COMP receivable for a user has been updated.\n  event CompReceivableUpdated(address indexed user, uint oldCompReceivable, uint newCompReceivable);\n\n  /// @notice The initial COMP index for a market\n  uint224 public constant compInitialIndex = 1e36;\n\n  // closeFactorMantissa must be strictly greater than this value\n  uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n  // closeFactorMantissa must not exceed this value\n  uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n  // No collateralFactorMantissa may exceed this value\n  uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n  constructor() {\n    admin = msg.sender;\n  }\n\n  /*** Assets You Are In ***/\n\n  /**\n   * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n  function getAssetsIn(address account) external view returns (CToken[] memory) {\n    CToken[] memory assetsIn = accountAssets[account];\n\n    return assetsIn;\n  }\n\n  /**\n   * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n  function checkMembership(address account, CToken cToken) external view returns (bool) {\n    return markets[address(cToken)].accountMembership[account];\n  }\n\n  /**\n   * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n  function enterMarkets(address[] memory cTokens) override public returns (uint[] memory) {\n    uint len = cTokens.length;\n\n    uint[] memory results = new uint[](len);\n    for (uint i = 0; i < len; i++) {\n      CToken cToken = CToken(cTokens[i]);\n\n      results[i] = uint(addToMarketInternal(cToken, msg.sender));\n    }\n\n    return results;\n  }\n\n  /**\n   * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n  function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n    Market storage marketToJoin = markets[address(cToken)];\n\n    if (!marketToJoin.isListed) {\n      // market is not listed, cannot join\n      return Error.MARKET_NOT_LISTED;\n    }\n\n    if (marketToJoin.accountMembership[borrower] == true) {\n      // already joined\n      return Error.NO_ERROR;\n    }\n\n    // survived the gauntlet, add to list\n    // NOTE: we store these somewhat redundantly as a significant optimization\n    //  this avoids having to iterate through the list for the most common use cases\n    //  that is, only when we need to perform liquidity checks\n    //  and not whenever we want to check if an account is in a particular market\n    marketToJoin.accountMembership[borrower] = true;\n    accountAssets[borrower].push(cToken);\n\n    emit MarketEntered(cToken, borrower);\n\n    return Error.NO_ERROR;\n  }\n\n  /**\n   * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n  function exitMarket(address cTokenAddress) override external returns (uint) {\n    CToken cToken = CToken(cTokenAddress);\n    /* Get sender tokensHeld and amountOwed underlying from the cToken */\n    (uint oErr, uint tokensHeld, uint amountOwed,) = cToken.getAccountSnapshot(msg.sender);\n    require(oErr == 0, \"exitMarket: getAccountSnapshot failed\");\n    // semi-opaque error code\n\n    /* Fail if the sender has a borrow balance */\n    if (amountOwed != 0) {\n      return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n    }\n\n    /* Fail if the sender is not permitted to redeem all of their tokens */\n    uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n    if (allowed != 0) {\n      return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n    }\n\n    Market storage marketToExit = markets[address(cToken)];\n\n    /* Return true if the sender is not already ‘in’ the market */\n    if (!marketToExit.accountMembership[msg.sender]) {\n      return uint(Error.NO_ERROR);\n    }\n\n    /* Set cToken account membership to false */\n    delete marketToExit.accountMembership[msg.sender];\n\n    /* Delete cToken from the account’s list of assets */\n    // load into memory for faster iteration\n    CToken[] memory userAssetList = accountAssets[msg.sender];\n    uint len = userAssetList.length;\n    uint assetIndex = len;\n    for (uint i = 0; i < len; i++) {\n      if (userAssetList[i] == cToken) {\n        assetIndex = i;\n        break;\n      }\n    }\n\n    // We *must* have found the asset in the list or our redundant data structure is broken\n    assert(assetIndex < len);\n\n    // copy last item in list to location of item to be removed, reduce length by 1\n    CToken[] storage storedList = accountAssets[msg.sender];\n    storedList[assetIndex] = storedList[storedList.length - 1];\n    storedList.pop();\n\n    emit MarketExited(cToken, msg.sender);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /*** Policy Hooks ***/\n\n  /**\n   * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function mintAllowed(address cToken, address minter, uint mintAmount) override external returns (uint) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n    // Shh - currently unused\n    minter;\n    mintAmount;\n\n    if (!markets[cToken].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    // Keep the flywheel moving\n    updateCompSupplyIndex(cToken);\n    distributeSupplierComp(cToken, minter);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates mint and reverts on rejection. May emit logs.\n     * @param cToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n  function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) override external {\n    // Shh - currently unused\n    cToken;\n    minter;\n    actualMintAmount;\n    mintTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function redeemAllowed(address cToken, address redeemer, uint redeemTokens) override external returns (uint) {\n    uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n    if (allowed != uint(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    updateCompSupplyIndex(cToken);\n    distributeSupplierComp(cToken, redeemer);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n    if (!markets[cToken].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n    if (!markets[cToken].accountMembership[redeemer]) {\n      return uint(Error.NO_ERROR);\n    }\n\n    /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n    (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);\n    if (err != Error.NO_ERROR) {\n      return uint(err);\n    }\n    if (shortfall > 0) {\n      return uint(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n  function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) override external pure {\n    // Shh - currently unused\n    cToken;\n    redeemer;\n\n    // Require tokens is zero or amount is also zero\n    if (redeemTokens == 0 && redeemAmount > 0) {\n      revert(\"redeemTokens zero\");\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function borrowAllowed(address cToken, address borrower, uint borrowAmount) override external returns (uint) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n    if (!markets[cToken].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    if (!markets[cToken].accountMembership[borrower]) {\n      // only cTokens may call borrowAllowed if borrower not in market\n      require(msg.sender == cToken, \"sender must be cToken\");\n\n      // attempt to add borrower to the market\n      Error err1 = addToMarketInternal(CToken(msg.sender), borrower);\n      if (err1 != Error.NO_ERROR) {\n        return uint(err1);\n      }\n\n      // it should be impossible to break the important invariant\n      assert(markets[cToken].accountMembership[borrower]);\n    }\n\n    if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n      return uint(Error.PRICE_ERROR);\n    }\n\n\n    uint borrowCap = borrowCaps[cToken];\n    // Borrow cap of 0 corresponds to unlimited borrowing\n    if (borrowCap != 0) {\n      uint totalBorrows = CToken(cToken).totalBorrows();\n      uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\n      require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n    }\n\n    (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\n    if (err != Error.NO_ERROR) {\n      return uint(err);\n    }\n    if (shortfall > 0) {\n      return uint(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    // Keep the flywheel moving\n    Exp memory borrowIndex = Exp({mantissa : CToken(cToken).borrowIndex()});\n    updateCompBorrowIndex(cToken, borrowIndex);\n    distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates borrow and reverts on rejection. May emit logs.\n     * @param cToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n  function borrowVerify(address cToken, address borrower, uint borrowAmount) override external {\n    // Shh - currently unused\n    cToken;\n    borrower;\n    borrowAmount;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint repayAmount) override external returns (uint) {\n    // Shh - currently unused\n    payer;\n    borrower;\n    repayAmount;\n\n    if (!markets[cToken].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    // Keep the flywheel moving\n    Exp memory borrowIndex = Exp({mantissa : CToken(cToken).borrowIndex()});\n    updateCompBorrowIndex(cToken, borrowIndex);\n    distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n     * @param cToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint actualRepayAmount,\n    uint borrowerIndex) override external {\n    // Shh - currently unused\n    cToken;\n    payer;\n    borrower;\n    actualRepayAmount;\n    borrowerIndex;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint repayAmount) override external view returns (uint) {\n    // Shh - currently unused\n    liquidator;\n\n    if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n\n    /* allow accounts to be liquidated if the market is deprecated */\n    if (isDeprecated(CToken(cTokenBorrowed))) {\n      require(borrowBalance >= repayAmount, \"Can not repay more than the total borrow\");\n    } else {\n      /* The borrower must have shortfall in order to be liquidatable */\n      (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\n      if (err != Error.NO_ERROR) {\n        return uint(err);\n      }\n\n      if (shortfall == 0) {\n        return uint(Error.INSUFFICIENT_SHORTFALL);\n      }\n\n      /* The liquidator may not repay more than what is allowed by the closeFactor */\n      uint maxClose = mul_ScalarTruncate(Exp({mantissa : closeFactorMantissa}), borrowBalance);\n      if (repayAmount > maxClose) {\n        return uint(Error.TOO_MUCH_REPAY);\n      }\n    }\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n  function liquidateBorrowVerify(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint actualRepayAmount,\n    uint seizeTokens) override external {\n    // Shh - currently unused\n    cTokenBorrowed;\n    cTokenCollateral;\n    liquidator;\n    borrower;\n    actualRepayAmount;\n    seizeTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint seizeTokens) override external returns (uint) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!seizeGuardianPaused, \"seize is paused\");\n\n    // Shh - currently unused\n    seizeTokens;\n\n    if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n      return uint(Error.COMPTROLLER_MISMATCH);\n    }\n\n    // Keep the flywheel moving\n    updateCompSupplyIndex(cTokenCollateral);\n    distributeSupplierComp(cTokenCollateral, borrower);\n    distributeSupplierComp(cTokenCollateral, liquidator);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates seize and reverts on rejection. May emit logs.\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint seizeTokens) override external {\n    // Shh - currently unused\n    cTokenCollateral;\n    cTokenBorrowed;\n    liquidator;\n    borrower;\n    seizeTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function transferAllowed(address cToken, address src, address dst, uint transferTokens) override external returns (uint) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!transferGuardianPaused, \"transfer is paused\");\n\n    // Currently the only consideration is whether or not\n    //  the src is allowed to redeem this many tokens\n    uint allowed = redeemAllowedInternal(cToken, src, transferTokens);\n    if (allowed != uint(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    updateCompSupplyIndex(cToken);\n    distributeSupplierComp(cToken, src);\n    distributeSupplierComp(cToken, dst);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates transfer and reverts on rejection. May emit logs.\n     * @param cToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     */\n  function transferVerify(address cToken, address src, address dst, uint transferTokens) override external {\n    // Shh - currently unused\n    cToken;\n    src;\n    dst;\n    transferTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  /**\n   * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n  struct AccountLiquidityLocalVars {\n    uint sumCollateral;\n    uint sumBorrowPlusEffects;\n    uint cTokenBalance;\n    uint borrowBalance;\n    uint exchangeRateMantissa;\n    uint oraclePriceMantissa;\n    Exp collateralFactor;\n    Exp exchangeRate;\n    Exp oraclePrice;\n    Exp tokensToDenom;\n  }\n\n  /**\n   * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n  function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n    (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n\n    return (uint(err), liquidity, shortfall);\n  }\n\n  /**\n   * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n  function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n    return getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n  }\n\n  /**\n   * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint redeemTokens,\n    uint borrowAmount) public view returns (uint, uint, uint) {\n    (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);\n    return (uint(err), liquidity, shortfall);\n  }\n\n  /**\n   * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidityInternal(\n    address account,\n    CToken cTokenModify,\n    uint redeemTokens,\n    uint borrowAmount) internal view returns (Error, uint, uint) {\n\n    AccountLiquidityLocalVars memory vars;\n    // Holds all our calculation results\n    uint oErr;\n\n    // For each asset the account is in\n    CToken[] memory assets = accountAssets[account];\n    for (uint i = 0; i < assets.length; i++) {\n      CToken asset = assets[i];\n\n      // Read the balances and exchange rate from the cToken\n      (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n      if (oErr != 0) {// semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n        return (Error.SNAPSHOT_ERROR, 0, 0);\n      }\n      vars.collateralFactor = Exp({mantissa : markets[address(asset)].collateralFactorMantissa});\n      vars.exchangeRate = Exp({mantissa : vars.exchangeRateMantissa});\n\n      // Get the normalized price of the asset\n      vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n      if (vars.oraclePriceMantissa == 0) {\n        return (Error.PRICE_ERROR, 0, 0);\n      }\n      vars.oraclePrice = Exp({mantissa : vars.oraclePriceMantissa});\n\n      // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n      vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n      // sumCollateral += tokensToDenom * cTokenBalance\n      vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n      // sumBorrowPlusEffects += oraclePrice * borrowBalance\n      vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n\n      // Calculate effects of interacting with cTokenModify\n      if (asset == cTokenModify) {\n        // redeem effect\n        // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\n\n        // borrow effect\n        // sumBorrowPlusEffects += oraclePrice * borrowAmount\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n      }\n    }\n\n    // These are safe, as the underflow condition is checked first\n    if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n      return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n    } else {\n      return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n    }\n  }\n\n  /**\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n  function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) override external view returns (uint, uint) {\n    /* Read oracle prices for borrowed and collateral markets */\n    uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n    uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n    if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n      return (uint(Error.PRICE_ERROR), 0);\n    }\n\n    /*\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n     *  seizeTokens = seizeAmount / exchangeRate\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n     */\n    uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored();\n    // Note: reverts on error\n    uint seizeTokens;\n    Exp memory numerator;\n    Exp memory denominator;\n    Exp memory ratio;\n\n    numerator = mul_(Exp({mantissa : liquidationIncentiveMantissa}), Exp({mantissa : priceBorrowedMantissa}));\n    denominator = mul_(Exp({mantissa : priceCollateralMantissa}), Exp({mantissa : exchangeRateMantissa}));\n    ratio = div_(numerator, denominator);\n\n    seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n    return (uint(Error.NO_ERROR), seizeTokens);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n    * @notice Sets a new price oracle for the comptroller\n      * @dev Admin function to set a new price oracle\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n    }\n\n    // Track the old oracle for the comptroller\n    PriceOracle oldOracle = oracle;\n\n    // Set comptroller's oracle to newOracle\n    oracle = newOracle;\n\n    // Emit NewPriceOracle(oldOracle, newOracle)\n    emit NewPriceOracle(oldOracle, newOracle);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n    * @notice Sets the closeFactor used when liquidating borrows\n      * @dev Admin function to set closeFactor\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure\n      */\n  function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n    // Check caller is admin\n    require(msg.sender == admin, \"only admin can set close factor\");\n\n    uint oldCloseFactorMantissa = closeFactorMantissa;\n    closeFactorMantissa = newCloseFactorMantissa;\n    emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n    * @notice Sets the collateralFactor for a market\n      * @dev Admin function to set per-market collateralFactor\n      * @param cToken The market to set the factor on\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n  function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n    }\n\n    // Verify market is listed\n    Market storage market = markets[address(cToken)];\n    if (!market.isListed) {\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n    }\n\n    Exp memory newCollateralFactorExp = Exp({mantissa : newCollateralFactorMantissa});\n\n    // Check collateral factor <= 0.9\n    Exp memory highLimit = Exp({mantissa : collateralFactorMaxMantissa});\n    if (lessThanExp(highLimit, newCollateralFactorExp)) {\n      return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n    }\n\n    // If collateral factor != 0, fail if price == 0\n    if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n      return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n    }\n\n    // Set market's collateral factor to new collateral factor, remember old value\n    uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n    market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n    // Emit event with asset, old collateral factor, and new collateral factor\n    emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n    * @notice Sets liquidationIncentive\n      * @dev Admin function to set liquidationIncentive\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n  function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n    }\n\n    // Save current value for use in log\n    uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n    // Set liquidation incentive to new incentive\n    liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n    // Emit event with old incentive, new incentive\n    emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n    * @notice Add the market to the markets mapping and set it as listed\n      * @dev Admin function to set isListed and add support for the market\n      * @param cToken The address of the market (token) to list\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n  function _supportMarket(CToken cToken) external returns (uint) {\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n    }\n\n    if (markets[address(cToken)].isListed) {\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n    }\n\n    cToken.isCToken();\n    // Sanity check to make sure its really a CToken\n\n    // Note that isComped is not in active use anymore\n    Market storage newMarket = markets[address(cToken)];\n    newMarket.isListed = true;\n    newMarket.isComped = false;\n    newMarket.collateralFactorMantissa = 0;\n\n    _addMarketInternal(address(cToken));\n    _initializeMarket(address(cToken));\n\n    emit MarketListed(cToken);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  function _addMarketInternal(address cToken) internal {\n    for (uint i = 0; i < allMarkets.length; i ++) {\n      require(allMarkets[i] != CToken(cToken), \"market already added\");\n    }\n    allMarkets.push(CToken(cToken));\n  }\n\n  function _initializeMarket(address cToken) internal {\n    uint32 blockNumber = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    CompMarketState storage borrowState = compBorrowState[cToken];\n\n    /*\n     * Update market state indices\n     */\n    if (supplyState.index == 0) {\n      // Initialize supply state index with default value\n      supplyState.index = compInitialIndex;\n    }\n\n    if (borrowState.index == 0) {\n      // Initialize borrow state index with default value\n      borrowState.index = compInitialIndex;\n    }\n\n    /*\n     * Update market state block numbers\n     */\n    supplyState.block = borrowState.block = blockNumber;\n  }\n\n\n  /**\n    * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n      * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n      */\n  function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {\n    require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n\n    uint numMarkets = cTokens.length;\n    uint numBorrowCaps = newBorrowCaps.length;\n\n    require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n    for (uint i = 0; i < numMarkets; i++) {\n      borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n      emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n    }\n  }\n\n  /**\n   * @notice Admin function to change the Borrow Cap Guardian\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n     */\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n    require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n    // Save current value for inclusion in log\n    address oldBorrowCapGuardian = borrowCapGuardian;\n\n    // Store borrowCapGuardian with value newBorrowCapGuardian\n    borrowCapGuardian = newBorrowCapGuardian;\n\n    // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n    emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n  }\n\n  /**\n   * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n  function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n    }\n\n    // Save current value for inclusion in log\n    address oldPauseGuardian = pauseGuardian;\n\n    // Store pauseGuardian with value newPauseGuardian\n    pauseGuardian = newPauseGuardian;\n\n    // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n    emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n    require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n    require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n    require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n    mintGuardianPaused[address(cToken)] = state;\n    emit ActionPaused(cToken, \"Mint\", state);\n    return state;\n  }\n\n  function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n    require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n    require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n    require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n    borrowGuardianPaused[address(cToken)] = state;\n    emit ActionPaused(cToken, \"Borrow\", state);\n    return state;\n  }\n\n  function _setTransferPaused(bool state) public returns (bool) {\n    require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n    require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n    transferGuardianPaused = state;\n    emit ActionPaused(\"Transfer\", state);\n    return state;\n  }\n\n  function _setSeizePaused(bool state) public returns (bool) {\n    require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n    require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n    seizeGuardianPaused = state;\n    emit ActionPaused(\"Seize\", state);\n    return state;\n  }\n\n  function _become(Unitroller unitroller) public {\n    require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n    require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n  }\n\n  /// @notice Delete this function after proposal 65 is executed\n  function fixBadAccruals(address[] calldata affectedUsers, uint[] calldata amounts) external {\n    require(msg.sender == admin, \"Only admin can call this function\");\n    // Only the timelock can call this function\n    require(!proposal65FixExecuted, \"Already executed this one-off function\");\n    // Require that this function is only called once\n    require(affectedUsers.length == amounts.length, \"Invalid input\");\n\n    // Loop variables\n    address user;\n    uint currentAccrual;\n    uint amountToSubtract;\n    uint newAccrual;\n\n    // Iterate through all affected users\n    for (uint i = 0; i < affectedUsers.length; ++i) {\n      user = affectedUsers[i];\n      currentAccrual = compAccrued[user];\n\n      amountToSubtract = amounts[i];\n\n      // The case where the user has claimed and received an incorrect amount of COMP.\n      // The user has less currently accrued than the amount they incorrectly received.\n      if (amountToSubtract > currentAccrual) {\n        // Amount of COMP the user owes the protocol\n        uint accountReceivable = amountToSubtract - currentAccrual;\n        // Underflow safe since amountToSubtract > currentAccrual\n\n        uint oldReceivable = compReceivable[user];\n        uint newReceivable = add_(oldReceivable, accountReceivable);\n\n        // Accounting: record the COMP debt for the user\n        compReceivable[user] = newReceivable;\n\n        emit CompReceivableUpdated(user, oldReceivable, newReceivable);\n\n        amountToSubtract = currentAccrual;\n      }\n\n      if (amountToSubtract > 0) {\n        // Subtract the bad accrual amount from what they have accrued.\n        // Users will keep whatever they have correctly accrued.\n        compAccrued[user] = newAccrual = sub_(currentAccrual, amountToSubtract);\n\n        emit CompAccruedAdjusted(user, currentAccrual, newAccrual);\n      }\n    }\n\n    proposal65FixExecuted = true;\n    // Makes it so that this function cannot be called again\n  }\n\n  /**\n   * @notice Checks caller is admin, or this contract is becoming the new implementation\n     */\n  function adminOrInitializing() internal view returns (bool) {\n    return msg.sender == admin || msg.sender == comptrollerImplementation;\n  }\n\n  /*** Comp Distribution ***/\n\n  /**\n   * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param supplySpeed New supply-side COMP speed for market\n     * @param borrowSpeed New borrow-side COMP speed for market\n     */\n  function setCompSpeedInternal(CToken cToken, uint supplySpeed, uint borrowSpeed) internal {\n    Market storage market = markets[address(cToken)];\n    require(market.isListed, \"comp market is not listed\");\n\n    if (compSupplySpeeds[address(cToken)] != supplySpeed) {\n      // Supply speed updated so let's update supply state to ensure that\n      //  1. COMP accrued properly for the old speed, and\n      //  2. COMP accrued at the new speed starts after this block.\n      updateCompSupplyIndex(address(cToken));\n\n      // Update speed and emit event\n      compSupplySpeeds[address(cToken)] = supplySpeed;\n      emit CompSupplySpeedUpdated(cToken, supplySpeed);\n    }\n\n    if (compBorrowSpeeds[address(cToken)] != borrowSpeed) {\n      // Borrow speed updated so let's update borrow state to ensure that\n      //  1. COMP accrued properly for the old speed, and\n      //  2. COMP accrued at the new speed starts after this block.\n      Exp memory borrowIndex = Exp({mantissa : cToken.borrowIndex()});\n      updateCompBorrowIndex(address(cToken), borrowIndex);\n\n      // Update speed and emit event\n      compBorrowSpeeds[address(cToken)] = borrowSpeed;\n      emit CompBorrowSpeedUpdated(cToken, borrowSpeed);\n    }\n  }\n\n  /**\n   * @notice Accrue COMP to the market by updating the supply index\n     * @param cToken The market whose supply index to update\n     * @dev Index is a cumulative sum of the COMP per cToken accrued.\n     */\n  function updateCompSupplyIndex(address cToken) internal {\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    uint supplySpeed = compSupplySpeeds[cToken];\n    uint32 blockNumber = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n    uint deltaBlocks = sub_(uint(blockNumber), uint(supplyState.block));\n    if (deltaBlocks > 0 && supplySpeed > 0) {\n      uint supplyTokens = CToken(cToken).totalSupply();\n      uint compAccrued = mul_(deltaBlocks, supplySpeed);\n      Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa : 0});\n      supplyState.index = safe224(add_(Double({mantissa : supplyState.index}), ratio).mantissa, \"new index exceeds 224 bits\");\n      supplyState.block = blockNumber;\n    } else if (deltaBlocks > 0) {\n      supplyState.block = blockNumber;\n    }\n  }\n\n  /**\n   * @notice Accrue COMP to the market by updating the borrow index\n     * @param cToken The market whose borrow index to update\n     * @dev Index is a cumulative sum of the COMP per cToken accrued.\n     */\n  function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {\n    CompMarketState storage borrowState = compBorrowState[cToken];\n    uint borrowSpeed = compBorrowSpeeds[cToken];\n    uint32 blockNumber = safe32(getBlockNumber(), \"block number exceeds 32 bits\");\n    uint deltaBlocks = sub_(uint(blockNumber), uint(borrowState.block));\n    if (deltaBlocks > 0 && borrowSpeed > 0) {\n      uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\n      uint compAccrued = mul_(deltaBlocks, borrowSpeed);\n      Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa : 0});\n      borrowState.index = safe224(add_(Double({mantissa : borrowState.index}), ratio).mantissa, \"new index exceeds 224 bits\");\n      borrowState.block = blockNumber;\n    } else if (deltaBlocks > 0) {\n      borrowState.block = blockNumber;\n    }\n  }\n\n  /**\n   * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\n     * @param cToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute COMP to\n     */\n  function distributeSupplierComp(address cToken, address supplier) internal {\n    // TODO: Don't distribute supplier COMP if the user is not in the supplier market.\n    // This check should be as gas efficient as possible as distributeSupplierComp is called in many places.\n    // - We really don't want to call an external contract as that's quite expensive.\n\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    uint supplyIndex = supplyState.index;\n    uint supplierIndex = compSupplierIndex[cToken][supplier];\n\n    // Update supplier's index to the current index since we are distributing accrued COMP\n    compSupplierIndex[cToken][supplier] = supplyIndex;\n\n    if (supplierIndex == 0 && supplyIndex >= compInitialIndex) {\n      // Covers the case where users supplied tokens before the market's supply state index was set.\n      // Rewards the user with COMP accrued from the start of when supplier rewards were first\n      // set for the market.\n      supplierIndex = compInitialIndex;\n    }\n\n    // Calculate change in the cumulative sum of the COMP per cToken accrued\n    Double memory deltaIndex = Double({mantissa : sub_(supplyIndex, supplierIndex)});\n\n    uint supplierTokens = CToken(cToken).balanceOf(supplier);\n\n    // Calculate COMP accrued: cTokenAmount * accruedPerCToken\n    uint supplierDelta = mul_(supplierTokens, deltaIndex);\n\n    uint supplierAccrued = add_(compAccrued[supplier], supplierDelta);\n    compAccrued[supplier] = supplierAccrued;\n\n    emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex);\n  }\n\n  /**\n   * @notice Calculate COMP accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n     * @param cToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute COMP to\n     */\n  function distributeBorrowerComp(address cToken, address borrower, Exp memory marketBorrowIndex) internal {\n    // TODO: Don't distribute supplier COMP if the user is not in the borrower market.\n    // This check should be as gas efficient as possible as distributeBorrowerComp is called in many places.\n    // - We really don't want to call an external contract as that's quite expensive.\n\n    CompMarketState storage borrowState = compBorrowState[cToken];\n    uint borrowIndex = borrowState.index;\n    uint borrowerIndex = compBorrowerIndex[cToken][borrower];\n\n    // Update borrowers's index to the current index since we are distributing accrued COMP\n    compBorrowerIndex[cToken][borrower] = borrowIndex;\n\n    if (borrowerIndex == 0 && borrowIndex >= compInitialIndex) {\n      // Covers the case where users borrowed tokens before the market's borrow state index was set.\n      // Rewards the user with COMP accrued from the start of when borrower rewards were first\n      // set for the market.\n      borrowerIndex = compInitialIndex;\n    }\n\n    // Calculate change in the cumulative sum of the COMP per borrowed unit accrued\n    Double memory deltaIndex = Double({mantissa : sub_(borrowIndex, borrowerIndex)});\n\n    uint borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);\n\n    // Calculate COMP accrued: cTokenAmount * accruedPerBorrowedUnit\n    uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n\n    uint borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\n    compAccrued[borrower] = borrowerAccrued;\n\n    emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex);\n  }\n\n  /**\n   * @notice Calculate additional accrued COMP for a contributor since last accrual\n     * @param contributor The address to calculate contributor rewards for\n     */\n  function updateContributorRewards(address contributor) public {\n    uint compSpeed = compContributorSpeeds[contributor];\n    uint blockNumber = getBlockNumber();\n    uint deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\n    if (deltaBlocks > 0 && compSpeed > 0) {\n      uint newAccrued = mul_(deltaBlocks, compSpeed);\n      uint contributorAccrued = add_(compAccrued[contributor], newAccrued);\n\n      compAccrued[contributor] = contributorAccrued;\n      lastContributorBlock[contributor] = blockNumber;\n    }\n  }\n\n  /**\n   * @notice Claim all the comp accrued by holder in all markets\n     * @param holder The address to claim COMP for\n     */\n  function claimComp(address holder) public {\n    return claimComp(holder, allMarkets);\n  }\n\n  /**\n   * @notice Claim all the comp accrued by holder in the specified markets\n     * @param holder The address to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     */\n  function claimComp(address holder, CToken[] memory cTokens) public {\n    address[] memory holders = new address[](1);\n    holders[0] = holder;\n    claimComp(holders, cTokens, true, true);\n  }\n\n  /**\n   * @notice Claim all comp accrued by the holders\n     * @param holders The addresses to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     * @param borrowers Whether or not to claim COMP earned by borrowing\n     * @param suppliers Whether or not to claim COMP earned by supplying\n     */\n  function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {\n    for (uint i = 0; i < cTokens.length; i++) {\n      CToken cToken = cTokens[i];\n      require(markets[address(cToken)].isListed, \"market must be listed\");\n      if (borrowers == true) {\n        Exp memory borrowIndex = Exp({mantissa : cToken.borrowIndex()});\n        updateCompBorrowIndex(address(cToken), borrowIndex);\n        for (uint j = 0; j < holders.length; j++) {\n          distributeBorrowerComp(address(cToken), holders[j], borrowIndex);\n        }\n      }\n      if (suppliers == true) {\n        updateCompSupplyIndex(address(cToken));\n        for (uint j = 0; j < holders.length; j++) {\n          distributeSupplierComp(address(cToken), holders[j]);\n        }\n      }\n    }\n    for (uint j = 0; j < holders.length; j++) {\n      compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n    }\n  }\n\n  /**\n   * @notice Transfer COMP to the user\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param user The address of the user to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     * @return The amount of COMP which was NOT transferred to the user\n     */\n  function grantCompInternal(address user, uint amount) internal returns (uint) {\n    Comp comp = Comp(getCompAddress());\n    uint compRemaining = comp.balanceOf(address(this));\n    if (amount > 0 && amount <= compRemaining) {\n      comp.transfer(user, amount);\n      return 0;\n    }\n    return amount;\n  }\n\n  /*** Comp Distribution Admin ***/\n\n  /**\n   * @notice Transfer COMP to the recipient\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param recipient The address of the recipient to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     */\n  function _grantComp(address recipient, uint amount) public {\n    require(adminOrInitializing(), \"only admin can grant comp\");\n    uint amountLeft = grantCompInternal(recipient, amount);\n    require(amountLeft == 0, \"insufficient comp for grant\");\n    emit CompGranted(recipient, amount);\n  }\n\n  /**\n   * @notice Set COMP borrow and supply speeds for the specified markets.\n     * @param cTokens The markets whose COMP speed to update.\n     * @param supplySpeeds New supply-side COMP speed for the corresponding market.\n     * @param borrowSpeeds New borrow-side COMP speed for the corresponding market.\n     */\n  function _setCompSpeeds(CToken[] memory cTokens, uint[] memory supplySpeeds, uint[] memory borrowSpeeds) public {\n    require(adminOrInitializing(), \"only admin can set comp speed\");\n\n    uint numTokens = cTokens.length;\n    require(numTokens == supplySpeeds.length && numTokens == borrowSpeeds.length, \"Comptroller::_setCompSpeeds invalid input\");\n\n    for (uint i = 0; i < numTokens; ++i) {\n      setCompSpeedInternal(cTokens[i], supplySpeeds[i], borrowSpeeds[i]);\n    }\n  }\n\n  /**\n   * @notice Set COMP speed for a single contributor\n     * @param contributor The contributor whose COMP speed to update\n     * @param compSpeed New COMP speed for contributor\n     */\n  function _setContributorCompSpeed(address contributor, uint compSpeed) public {\n    require(adminOrInitializing(), \"only admin can set comp speed\");\n\n    // note that COMP speed could be set to 0 to halt liquidity rewards for a contributor\n    updateContributorRewards(contributor);\n    if (compSpeed == 0) {\n      // release storage\n      delete lastContributorBlock[contributor];\n    } else {\n      lastContributorBlock[contributor] = getBlockNumber();\n    }\n    compContributorSpeeds[contributor] = compSpeed;\n\n    emit ContributorCompSpeedUpdated(contributor, compSpeed);\n  }\n\n  /**\n   * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n  function getAllMarkets() public view returns (CToken[] memory) {\n    return allMarkets;\n  }\n\n  /**\n   * @notice Returns true if the given cToken market has been deprecated\n     * @dev All borrows in a deprecated cToken market can be immediately liquidated\n     * @param cToken The market to check if deprecated\n     */\n  function isDeprecated(CToken cToken) public view returns (bool) {\n    return\n    markets[address(cToken)].collateralFactorMantissa == 0 &&\n    borrowGuardianPaused[address(cToken)] == true &&\n    cToken.reserveFactorMantissa() == 1e18\n    ;\n  }\n\n  function getBlockNumber() virtual public view returns (uint) {\n    return block.number;\n  }\n\n  /**\n   * @notice Return the address of the COMP token\n     * @return The address of COMP\n     */\n  function getCompAddress() virtual public view returns (address) {\n    return 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n  }\n}\n"
    },
    "contracts/test/compound-core/ComptrollerG7.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./PriceOracle.sol\";\nimport \"./ComptrollerInterface.sol\";\nimport \"./ComptrollerStorage.sol\";\nimport \"./Unitroller.sol\";\nimport \"./Governance/Comp.sol\";\n\n/**\n * @title Compound's Comptroller Contract\n * @author Compound\n */\ncontract ComptrollerG7 is ComptrollerV5Storage, ComptrollerInterface, ComptrollerErrorReporter, ExponentialNoError {\n  /// @notice Emitted when an admin supports a market\n  event MarketListed(CToken cToken);\n\n  /// @notice Emitted when an account enters a market\n  event MarketEntered(CToken cToken, address account);\n\n  /// @notice Emitted when an account exits a market\n  event MarketExited(CToken cToken, address account);\n\n  /// @notice Emitted when close factor is changed by admin\n  event NewCloseFactor(uint oldCloseFactorMantissa, uint newCloseFactorMantissa);\n\n  /// @notice Emitted when a collateral factor is changed by admin\n  event NewCollateralFactor(CToken cToken, uint oldCollateralFactorMantissa, uint newCollateralFactorMantissa);\n\n  /// @notice Emitted when liquidation incentive is changed by admin\n  event NewLiquidationIncentive(uint oldLiquidationIncentiveMantissa, uint newLiquidationIncentiveMantissa);\n\n  /// @notice Emitted when price oracle is changed\n  event NewPriceOracle(PriceOracle oldPriceOracle, PriceOracle newPriceOracle);\n\n  /// @notice Emitted when pause guardian is changed\n  event NewPauseGuardian(address oldPauseGuardian, address newPauseGuardian);\n\n  /// @notice Emitted when an action is paused globally\n  event ActionPaused(string action, bool pauseState);\n\n  /// @notice Emitted when an action is paused on a market\n  event ActionPaused(CToken cToken, string action, bool pauseState);\n\n  /// @notice Emitted when a new COMP speed is calculated for a market\n  event CompSpeedUpdated(CToken indexed cToken, uint newSpeed);\n\n  /// @notice Emitted when a new COMP speed is set for a contributor\n  event ContributorCompSpeedUpdated(address indexed contributor, uint newSpeed);\n\n  /// @notice Emitted when COMP is distributed to a supplier\n  event DistributedSupplierComp(CToken indexed cToken, address indexed supplier, uint compDelta, uint compSupplyIndex);\n\n  /// @notice Emitted when COMP is distributed to a borrower\n  event DistributedBorrowerComp(CToken indexed cToken, address indexed borrower, uint compDelta, uint compBorrowIndex);\n\n  /// @notice Emitted when borrow cap for a cToken is changed\n  event NewBorrowCap(CToken indexed cToken, uint newBorrowCap);\n\n  /// @notice Emitted when borrow cap guardian is changed\n  event NewBorrowCapGuardian(address oldBorrowCapGuardian, address newBorrowCapGuardian);\n\n  /// @notice Emitted when COMP is granted by admin\n  event CompGranted(address recipient, uint amount);\n\n  /// @notice The initial COMP index for a market\n  uint224 public constant compInitialIndex = 1e36;\n\n  // closeFactorMantissa must be strictly greater than this value\n  uint internal constant closeFactorMinMantissa = 0.05e18; // 0.05\n\n  // closeFactorMantissa must not exceed this value\n  uint internal constant closeFactorMaxMantissa = 0.9e18; // 0.9\n\n  // No collateralFactorMantissa may exceed this value\n  uint internal constant collateralFactorMaxMantissa = 0.9e18; // 0.9\n\n  constructor() {\n    admin = msg.sender;\n  }\n\n  /*** Assets You Are In ***/\n\n  /**\n   * @notice Returns the assets an account has entered\n     * @param account The address of the account to pull assets for\n     * @return A dynamic list with the assets the account has entered\n     */\n  function getAssetsIn(address account) external view returns (CToken[] memory) {\n    CToken[] memory assetsIn = accountAssets[account];\n\n    return assetsIn;\n  }\n\n  /**\n   * @notice Returns whether the given account is entered in the given asset\n     * @param account The address of the account to check\n     * @param cToken The cToken to check\n     * @return True if the account is in the asset, otherwise false.\n     */\n  function checkMembership(address account, CToken cToken) external view returns (bool) {\n    return markets[address(cToken)].accountMembership[account];\n  }\n\n  /**\n   * @notice Add assets to be included in account liquidity calculation\n     * @param cTokens The list of addresses of the cToken markets to be enabled\n     * @return Success indicator for whether each corresponding market was entered\n     */\n  function enterMarkets(address[] memory cTokens) override public returns (uint[] memory) {\n    uint len = cTokens.length;\n\n    uint[] memory results = new uint[](len);\n    for (uint i = 0; i < len; i++) {\n      CToken cToken = CToken(cTokens[i]);\n\n      results[i] = uint(addToMarketInternal(cToken, msg.sender));\n    }\n\n    return results;\n  }\n\n  /**\n   * @notice Add the market to the borrower's \"assets in\" for liquidity calculations\n     * @param cToken The market to enter\n     * @param borrower The address of the account to modify\n     * @return Success indicator for whether the market was entered\n     */\n  function addToMarketInternal(CToken cToken, address borrower) internal returns (Error) {\n    Market storage marketToJoin = markets[address(cToken)];\n\n    if (!marketToJoin.isListed) {\n      // market is not listed, cannot join\n      return Error.MARKET_NOT_LISTED;\n    }\n\n    if (marketToJoin.accountMembership[borrower] == true) {\n      // already joined\n      return Error.NO_ERROR;\n    }\n\n    // survived the gauntlet, add to list\n    // NOTE: we store these somewhat redundantly as a significant optimization\n    //  this avoids having to iterate through the list for the most common use cases\n    //  that is, only when we need to perform liquidity checks\n    //  and not whenever we want to check if an account is in a particular market\n    marketToJoin.accountMembership[borrower] = true;\n    accountAssets[borrower].push(cToken);\n\n    emit MarketEntered(cToken, borrower);\n\n    return Error.NO_ERROR;\n  }\n\n  /**\n   * @notice Removes asset from sender's account liquidity calculation\n     * @dev Sender must not have an outstanding borrow balance in the asset,\n     *  or be providing necessary collateral for an outstanding borrow.\n     * @param cTokenAddress The address of the asset to be removed\n     * @return Whether or not the account successfully exited the market\n     */\n  function exitMarket(address cTokenAddress) override external returns (uint) {\n    CToken cToken = CToken(cTokenAddress);\n    /* Get sender tokensHeld and amountOwed underlying from the cToken */\n    (uint oErr, uint tokensHeld, uint amountOwed,) = cToken.getAccountSnapshot(msg.sender);\n    require(oErr == 0, \"exitMarket: getAccountSnapshot failed\");\n    // semi-opaque error code\n\n    /* Fail if the sender has a borrow balance */\n    if (amountOwed != 0) {\n      return fail(Error.NONZERO_BORROW_BALANCE, FailureInfo.EXIT_MARKET_BALANCE_OWED);\n    }\n\n    /* Fail if the sender is not permitted to redeem all of their tokens */\n    uint allowed = redeemAllowedInternal(cTokenAddress, msg.sender, tokensHeld);\n    if (allowed != 0) {\n      return failOpaque(Error.REJECTION, FailureInfo.EXIT_MARKET_REJECTION, allowed);\n    }\n\n    Market storage marketToExit = markets[address(cToken)];\n\n    /* Return true if the sender is not already ‘in’ the market */\n    if (!marketToExit.accountMembership[msg.sender]) {\n      return uint(Error.NO_ERROR);\n    }\n\n    /* Set cToken account membership to false */\n    delete marketToExit.accountMembership[msg.sender];\n\n    /* Delete cToken from the account’s list of assets */\n    // load into memory for faster iteration\n    CToken[] memory userAssetList = accountAssets[msg.sender];\n    uint len = userAssetList.length;\n    uint assetIndex = len;\n    for (uint i = 0; i < len; i++) {\n      if (userAssetList[i] == cToken) {\n        assetIndex = i;\n        break;\n      }\n    }\n\n    // We *must* have found the asset in the list or our redundant data structure is broken\n    assert(assetIndex < len);\n\n    // copy last item in list to location of item to be removed, reduce length by 1\n    CToken[] storage storedList = accountAssets[msg.sender];\n    storedList[assetIndex] = storedList[storedList.length - 1];\n    storedList.pop();\n\n    emit MarketExited(cToken, msg.sender);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /*** Policy Hooks ***/\n\n  /**\n   * @notice Checks if the account should be allowed to mint tokens in the given market\n     * @param cToken The market to verify the mint against\n     * @param minter The account which would get the minted tokens\n     * @param mintAmount The amount of underlying being supplied to the market in exchange for tokens\n     * @return 0 if the mint is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function mintAllowed(address cToken, address minter, uint mintAmount) override external returns (uint) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!mintGuardianPaused[cToken], \"mint is paused\");\n\n    // Shh - currently unused\n    minter;\n    mintAmount;\n\n    if (!markets[cToken].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    // Keep the flywheel moving\n    updateCompSupplyIndex(cToken);\n    distributeSupplierComp(cToken, minter);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates mint and reverts on rejection. May emit logs.\n     * @param cToken Asset being minted\n     * @param minter The address minting the tokens\n     * @param actualMintAmount The amount of the underlying asset being minted\n     * @param mintTokens The number of tokens being minted\n     */\n  function mintVerify(address cToken, address minter, uint actualMintAmount, uint mintTokens) override external {\n    // Shh - currently unused\n    cToken;\n    minter;\n    actualMintAmount;\n    mintTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to redeem tokens in the given market\n     * @param cToken The market to verify the redeem against\n     * @param redeemer The account which would redeem the tokens\n     * @param redeemTokens The number of cTokens to exchange for the underlying asset in the market\n     * @return 0 if the redeem is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function redeemAllowed(address cToken, address redeemer, uint redeemTokens) override external returns (uint) {\n    uint allowed = redeemAllowedInternal(cToken, redeemer, redeemTokens);\n    if (allowed != uint(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    updateCompSupplyIndex(cToken);\n    distributeSupplierComp(cToken, redeemer);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  function redeemAllowedInternal(address cToken, address redeemer, uint redeemTokens) internal view returns (uint) {\n    if (!markets[cToken].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    /* If the redeemer is not 'in' the market, then we can bypass the liquidity check */\n    if (!markets[cToken].accountMembership[redeemer]) {\n      return uint(Error.NO_ERROR);\n    }\n\n    /* Otherwise, perform a hypothetical liquidity check to guard against shortfall */\n    (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(redeemer, CToken(cToken), redeemTokens, 0);\n    if (err != Error.NO_ERROR) {\n      return uint(err);\n    }\n    if (shortfall > 0) {\n      return uint(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates redeem and reverts on rejection. May emit logs.\n     * @param cToken Asset being redeemed\n     * @param redeemer The address redeeming the tokens\n     * @param redeemAmount The amount of the underlying asset being redeemed\n     * @param redeemTokens The number of tokens being redeemed\n     */\n  function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) override external pure {\n    // Shh - currently unused\n    cToken;\n    redeemer;\n\n    // Require tokens is zero or amount is also zero\n    if (redeemTokens == 0 && redeemAmount > 0) {\n      revert(\"redeemTokens zero\");\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to borrow the underlying asset of the given market\n     * @param cToken The market to verify the borrow against\n     * @param borrower The account which would borrow the asset\n     * @param borrowAmount The amount of underlying the account would borrow\n     * @return 0 if the borrow is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function borrowAllowed(address cToken, address borrower, uint borrowAmount) override external returns (uint) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!borrowGuardianPaused[cToken], \"borrow is paused\");\n\n    if (!markets[cToken].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    if (!markets[cToken].accountMembership[borrower]) {\n      // only cTokens may call borrowAllowed if borrower not in market\n      require(msg.sender == cToken, \"sender must be cToken\");\n\n      // attempt to add borrower to the market\n      Error err1 = addToMarketInternal(CToken(msg.sender), borrower);\n      if (err1 != Error.NO_ERROR) {\n        return uint(err1);\n      }\n\n      // it should be impossible to break the important invariant\n      assert(markets[cToken].accountMembership[borrower]);\n    }\n\n    if (oracle.getUnderlyingPrice(CToken(cToken)) == 0) {\n      return uint(Error.PRICE_ERROR);\n    }\n\n\n    uint borrowCap = borrowCaps[cToken];\n    // Borrow cap of 0 corresponds to unlimited borrowing\n    if (borrowCap != 0) {\n      uint totalBorrows = CToken(cToken).totalBorrows();\n      uint nextTotalBorrows = add_(totalBorrows, borrowAmount);\n      require(nextTotalBorrows < borrowCap, \"market borrow cap reached\");\n    }\n\n    (Error err, , uint shortfall) = getHypotheticalAccountLiquidityInternal(borrower, CToken(cToken), 0, borrowAmount);\n    if (err != Error.NO_ERROR) {\n      return uint(err);\n    }\n    if (shortfall > 0) {\n      return uint(Error.INSUFFICIENT_LIQUIDITY);\n    }\n\n    // Keep the flywheel moving\n    Exp memory borrowIndex = Exp({mantissa : CToken(cToken).borrowIndex()});\n    updateCompBorrowIndex(cToken, borrowIndex);\n    distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates borrow and reverts on rejection. May emit logs.\n     * @param cToken Asset whose underlying is being borrowed\n     * @param borrower The address borrowing the underlying\n     * @param borrowAmount The amount of the underlying asset requested to borrow\n     */\n  function borrowVerify(address cToken, address borrower, uint borrowAmount) override external {\n    // Shh - currently unused\n    cToken;\n    borrower;\n    borrowAmount;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to repay a borrow in the given market\n     * @param cToken The market to verify the repay against\n     * @param payer The account which would repay the asset\n     * @param borrower The account which would borrowed the asset\n     * @param repayAmount The amount of the underlying asset the account would repay\n     * @return 0 if the repay is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint repayAmount) override external returns (uint) {\n    // Shh - currently unused\n    payer;\n    borrower;\n    repayAmount;\n\n    if (!markets[cToken].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    // Keep the flywheel moving\n    Exp memory borrowIndex = Exp({mantissa : CToken(cToken).borrowIndex()});\n    updateCompBorrowIndex(cToken, borrowIndex);\n    distributeBorrowerComp(cToken, borrower, borrowIndex);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates repayBorrow and reverts on rejection. May emit logs.\n     * @param cToken Asset being repaid\n     * @param payer The address repaying the borrow\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint actualRepayAmount,\n    uint borrowerIndex) override external {\n    // Shh - currently unused\n    cToken;\n    payer;\n    borrower;\n    actualRepayAmount;\n    borrowerIndex;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the liquidation should be allowed to occur\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param repayAmount The amount of underlying being repaid\n     */\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint repayAmount) override external view returns (uint) {\n    // Shh - currently unused\n    liquidator;\n\n    if (!markets[cTokenBorrowed].isListed || !markets[cTokenCollateral].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    /* The borrower must have shortfall in order to be liquidatable */\n    (Error err, , uint shortfall) = getAccountLiquidityInternal(borrower);\n    if (err != Error.NO_ERROR) {\n      return uint(err);\n    }\n    if (shortfall == 0) {\n      return uint(Error.INSUFFICIENT_SHORTFALL);\n    }\n\n    /* The liquidator may not repay more than what is allowed by the closeFactor */\n    uint borrowBalance = CToken(cTokenBorrowed).borrowBalanceStored(borrower);\n    uint maxClose = mul_ScalarTruncate(Exp({mantissa : closeFactorMantissa}), borrowBalance);\n    if (repayAmount > maxClose) {\n      return uint(Error.TOO_MUCH_REPAY);\n    }\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates liquidateBorrow and reverts on rejection. May emit logs.\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param actualRepayAmount The amount of underlying being repaid\n     */\n  function liquidateBorrowVerify(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint actualRepayAmount,\n    uint seizeTokens) override external {\n    // Shh - currently unused\n    cTokenBorrowed;\n    cTokenCollateral;\n    liquidator;\n    borrower;\n    actualRepayAmount;\n    seizeTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the seizing of assets should be allowed to occur\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint seizeTokens) override external returns (uint) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!seizeGuardianPaused, \"seize is paused\");\n\n    // Shh - currently unused\n    seizeTokens;\n\n    if (!markets[cTokenCollateral].isListed || !markets[cTokenBorrowed].isListed) {\n      return uint(Error.MARKET_NOT_LISTED);\n    }\n\n    if (CToken(cTokenCollateral).comptroller() != CToken(cTokenBorrowed).comptroller()) {\n      return uint(Error.COMPTROLLER_MISMATCH);\n    }\n\n    // Keep the flywheel moving\n    updateCompSupplyIndex(cTokenCollateral);\n    distributeSupplierComp(cTokenCollateral, borrower);\n    distributeSupplierComp(cTokenCollateral, liquidator);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates seize and reverts on rejection. May emit logs.\n     * @param cTokenCollateral Asset which was used as collateral and will be seized\n     * @param cTokenBorrowed Asset which was borrowed by the borrower\n     * @param liquidator The address repaying the borrow and seizing the collateral\n     * @param borrower The address of the borrower\n     * @param seizeTokens The number of collateral tokens to seize\n     */\n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint seizeTokens) override external {\n    // Shh - currently unused\n    cTokenCollateral;\n    cTokenBorrowed;\n    liquidator;\n    borrower;\n    seizeTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /**\n   * @notice Checks if the account should be allowed to transfer tokens in the given market\n     * @param cToken The market to verify the transfer against\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     * @return 0 if the transfer is allowed, otherwise a semi-opaque error code (See ErrorReporter.sol)\n     */\n  function transferAllowed(address cToken, address src, address dst, uint transferTokens) override external returns (uint) {\n    // Pausing is a very serious situation - we revert to sound the alarms\n    require(!transferGuardianPaused, \"transfer is paused\");\n\n    // Currently the only consideration is whether or not\n    //  the src is allowed to redeem this many tokens\n    uint allowed = redeemAllowedInternal(cToken, src, transferTokens);\n    if (allowed != uint(Error.NO_ERROR)) {\n      return allowed;\n    }\n\n    // Keep the flywheel moving\n    updateCompSupplyIndex(cToken);\n    distributeSupplierComp(cToken, src);\n    distributeSupplierComp(cToken, dst);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @notice Validates transfer and reverts on rejection. May emit logs.\n     * @param cToken Asset being transferred\n     * @param src The account which sources the tokens\n     * @param dst The account which receives the tokens\n     * @param transferTokens The number of cTokens to transfer\n     */\n  function transferVerify(address cToken, address src, address dst, uint transferTokens) override external {\n    // Shh - currently unused\n    cToken;\n    src;\n    dst;\n    transferTokens;\n\n    // Shh - we don't ever want this hook to be marked pure\n    if (false) {\n      maxAssets = maxAssets;\n    }\n  }\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  /**\n   * @dev Local vars for avoiding stack-depth limits in calculating account liquidity.\n     *  Note that `cTokenBalance` is the number of cTokens the account owns in the market,\n     *  whereas `borrowBalance` is the amount of underlying that the account has borrowed.\n     */\n  struct AccountLiquidityLocalVars {\n    uint sumCollateral;\n    uint sumBorrowPlusEffects;\n    uint cTokenBalance;\n    uint borrowBalance;\n    uint exchangeRateMantissa;\n    uint oraclePriceMantissa;\n    Exp collateralFactor;\n    Exp exchangeRate;\n    Exp oraclePrice;\n    Exp tokensToDenom;\n  }\n\n  /**\n   * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code (semi-opaque),\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n  function getAccountLiquidity(address account) public view returns (uint, uint, uint) {\n    (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n\n    return (uint(err), liquidity, shortfall);\n  }\n\n  /**\n   * @notice Determine the current account liquidity wrt collateral requirements\n     * @return (possible error code,\n                account liquidity in excess of collateral requirements,\n     *          account shortfall below collateral requirements)\n     */\n  function getAccountLiquidityInternal(address account) internal view returns (Error, uint, uint) {\n    return getHypotheticalAccountLiquidityInternal(account, CToken(address(0)), 0, 0);\n  }\n\n  /**\n   * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @return (possible error code (semi-opaque),\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidity(\n    address account,\n    address cTokenModify,\n    uint redeemTokens,\n    uint borrowAmount) public view returns (uint, uint, uint) {\n    (Error err, uint liquidity, uint shortfall) = getHypotheticalAccountLiquidityInternal(account, CToken(cTokenModify), redeemTokens, borrowAmount);\n    return (uint(err), liquidity, shortfall);\n  }\n\n  /**\n   * @notice Determine what the account liquidity would be if the given amounts were redeemed/borrowed\n     * @param cTokenModify The market to hypothetically redeem/borrow in\n     * @param account The account to determine liquidity for\n     * @param redeemTokens The number of tokens to hypothetically redeem\n     * @param borrowAmount The amount of underlying to hypothetically borrow\n     * @dev Note that we calculate the exchangeRateStored for each collateral cToken using stored data,\n     *  without calculating accumulated interest.\n     * @return (possible error code,\n                hypothetical account liquidity in excess of collateral requirements,\n     *          hypothetical account shortfall below collateral requirements)\n     */\n  function getHypotheticalAccountLiquidityInternal(\n    address account,\n    CToken cTokenModify,\n    uint redeemTokens,\n    uint borrowAmount) internal view returns (Error, uint, uint) {\n\n    AccountLiquidityLocalVars memory vars;\n    // Holds all our calculation results\n    uint oErr;\n\n    // For each asset the account is in\n    CToken[] memory assets = accountAssets[account];\n    for (uint i = 0; i < assets.length; i++) {\n      CToken asset = assets[i];\n\n      // Read the balances and exchange rate from the cToken\n      (oErr, vars.cTokenBalance, vars.borrowBalance, vars.exchangeRateMantissa) = asset.getAccountSnapshot(account);\n      if (oErr != 0) {// semi-opaque error code, we assume NO_ERROR == 0 is invariant between upgrades\n        return (Error.SNAPSHOT_ERROR, 0, 0);\n      }\n      vars.collateralFactor = Exp({mantissa : markets[address(asset)].collateralFactorMantissa});\n      vars.exchangeRate = Exp({mantissa : vars.exchangeRateMantissa});\n\n      // Get the normalized price of the asset\n      vars.oraclePriceMantissa = oracle.getUnderlyingPrice(asset);\n      if (vars.oraclePriceMantissa == 0) {\n        return (Error.PRICE_ERROR, 0, 0);\n      }\n      vars.oraclePrice = Exp({mantissa : vars.oraclePriceMantissa});\n\n      // Pre-compute a conversion factor from tokens -> ether (normalized price value)\n      vars.tokensToDenom = mul_(mul_(vars.collateralFactor, vars.exchangeRate), vars.oraclePrice);\n\n      // sumCollateral += tokensToDenom * cTokenBalance\n      vars.sumCollateral = mul_ScalarTruncateAddUInt(vars.tokensToDenom, vars.cTokenBalance, vars.sumCollateral);\n\n      // sumBorrowPlusEffects += oraclePrice * borrowBalance\n      vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, vars.borrowBalance, vars.sumBorrowPlusEffects);\n\n      // Calculate effects of interacting with cTokenModify\n      if (asset == cTokenModify) {\n        // redeem effect\n        // sumBorrowPlusEffects += tokensToDenom * redeemTokens\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.tokensToDenom, redeemTokens, vars.sumBorrowPlusEffects);\n\n        // borrow effect\n        // sumBorrowPlusEffects += oraclePrice * borrowAmount\n        vars.sumBorrowPlusEffects = mul_ScalarTruncateAddUInt(vars.oraclePrice, borrowAmount, vars.sumBorrowPlusEffects);\n      }\n    }\n\n    // These are safe, as the underflow condition is checked first\n    if (vars.sumCollateral > vars.sumBorrowPlusEffects) {\n      return (Error.NO_ERROR, vars.sumCollateral - vars.sumBorrowPlusEffects, 0);\n    } else {\n      return (Error.NO_ERROR, 0, vars.sumBorrowPlusEffects - vars.sumCollateral);\n    }\n  }\n\n  /**\n   * @notice Calculate number of tokens of collateral asset to seize given an underlying amount\n     * @dev Used in liquidation (called in cToken.liquidateBorrowFresh)\n     * @param cTokenBorrowed The address of the borrowed cToken\n     * @param cTokenCollateral The address of the collateral cToken\n     * @param actualRepayAmount The amount of cTokenBorrowed underlying to convert into cTokenCollateral tokens\n     * @return (errorCode, number of cTokenCollateral tokens to be seized in a liquidation)\n     */\n  function liquidateCalculateSeizeTokens(address cTokenBorrowed, address cTokenCollateral, uint actualRepayAmount) override external view returns (uint, uint) {\n    /* Read oracle prices for borrowed and collateral markets */\n    uint priceBorrowedMantissa = oracle.getUnderlyingPrice(CToken(cTokenBorrowed));\n    uint priceCollateralMantissa = oracle.getUnderlyingPrice(CToken(cTokenCollateral));\n    if (priceBorrowedMantissa == 0 || priceCollateralMantissa == 0) {\n      return (uint(Error.PRICE_ERROR), 0);\n    }\n\n    /*\n     * Get the exchange rate and calculate the number of collateral tokens to seize:\n     *  seizeAmount = actualRepayAmount * liquidationIncentive * priceBorrowed / priceCollateral\n     *  seizeTokens = seizeAmount / exchangeRate\n     *   = actualRepayAmount * (liquidationIncentive * priceBorrowed) / (priceCollateral * exchangeRate)\n     */\n    uint exchangeRateMantissa = CToken(cTokenCollateral).exchangeRateStored();\n    // Note: reverts on error\n    uint seizeTokens;\n    Exp memory numerator;\n    Exp memory denominator;\n    Exp memory ratio;\n\n    numerator = mul_(Exp({mantissa : liquidationIncentiveMantissa}), Exp({mantissa : priceBorrowedMantissa}));\n    denominator = mul_(Exp({mantissa : priceCollateralMantissa}), Exp({mantissa : exchangeRateMantissa}));\n    ratio = div_(numerator, denominator);\n\n    seizeTokens = mul_ScalarTruncate(ratio, actualRepayAmount);\n\n    return (uint(Error.NO_ERROR), seizeTokens);\n  }\n\n  /*** Admin Functions ***/\n\n  /**\n    * @notice Sets a new price oracle for the comptroller\n      * @dev Admin function to set a new price oracle\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _setPriceOracle(PriceOracle newOracle) public returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PRICE_ORACLE_OWNER_CHECK);\n    }\n\n    // Track the old oracle for the comptroller\n    PriceOracle oldOracle = oracle;\n\n    // Set comptroller's oracle to newOracle\n    oracle = newOracle;\n\n    // Emit NewPriceOracle(oldOracle, newOracle)\n    emit NewPriceOracle(oldOracle, newOracle);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n    * @notice Sets the closeFactor used when liquidating borrows\n      * @dev Admin function to set closeFactor\n      * @param newCloseFactorMantissa New close factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure\n      */\n  function _setCloseFactor(uint newCloseFactorMantissa) external returns (uint) {\n    // Check caller is admin\n    require(msg.sender == admin, \"only admin can set close factor\");\n\n    uint oldCloseFactorMantissa = closeFactorMantissa;\n    closeFactorMantissa = newCloseFactorMantissa;\n    emit NewCloseFactor(oldCloseFactorMantissa, closeFactorMantissa);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n    * @notice Sets the collateralFactor for a market\n      * @dev Admin function to set per-market collateralFactor\n      * @param cToken The market to set the factor on\n      * @param newCollateralFactorMantissa The new collateral factor, scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n  function _setCollateralFactor(CToken cToken, uint newCollateralFactorMantissa) external returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_COLLATERAL_FACTOR_OWNER_CHECK);\n    }\n\n    // Verify market is listed\n    Market storage market = markets[address(cToken)];\n    if (!market.isListed) {\n      return fail(Error.MARKET_NOT_LISTED, FailureInfo.SET_COLLATERAL_FACTOR_NO_EXISTS);\n    }\n\n    Exp memory newCollateralFactorExp = Exp({mantissa : newCollateralFactorMantissa});\n\n    // Check collateral factor <= 0.9\n    Exp memory highLimit = Exp({mantissa : collateralFactorMaxMantissa});\n    if (lessThanExp(highLimit, newCollateralFactorExp)) {\n      return fail(Error.INVALID_COLLATERAL_FACTOR, FailureInfo.SET_COLLATERAL_FACTOR_VALIDATION);\n    }\n\n    // If collateral factor != 0, fail if price == 0\n    if (newCollateralFactorMantissa != 0 && oracle.getUnderlyingPrice(cToken) == 0) {\n      return fail(Error.PRICE_ERROR, FailureInfo.SET_COLLATERAL_FACTOR_WITHOUT_PRICE);\n    }\n\n    // Set market's collateral factor to new collateral factor, remember old value\n    uint oldCollateralFactorMantissa = market.collateralFactorMantissa;\n    market.collateralFactorMantissa = newCollateralFactorMantissa;\n\n    // Emit event with asset, old collateral factor, and new collateral factor\n    emit NewCollateralFactor(cToken, oldCollateralFactorMantissa, newCollateralFactorMantissa);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n    * @notice Sets liquidationIncentive\n      * @dev Admin function to set liquidationIncentive\n      * @param newLiquidationIncentiveMantissa New liquidationIncentive scaled by 1e18\n      * @return uint 0=success, otherwise a failure. (See ErrorReporter for details)\n      */\n  function _setLiquidationIncentive(uint newLiquidationIncentiveMantissa) external returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_LIQUIDATION_INCENTIVE_OWNER_CHECK);\n    }\n\n    // Save current value for use in log\n    uint oldLiquidationIncentiveMantissa = liquidationIncentiveMantissa;\n\n    // Set liquidation incentive to new incentive\n    liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;\n\n    // Emit event with old incentive, new incentive\n    emit NewLiquidationIncentive(oldLiquidationIncentiveMantissa, newLiquidationIncentiveMantissa);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n    * @notice Add the market to the markets mapping and set it as listed\n      * @dev Admin function to set isListed and add support for the market\n      * @param cToken The address of the market (token) to list\n      * @return uint 0=success, otherwise a failure. (See enum Error for details)\n      */\n  function _supportMarket(CToken cToken) external returns (uint) {\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SUPPORT_MARKET_OWNER_CHECK);\n    }\n\n    if (markets[address(cToken)].isListed) {\n      return fail(Error.MARKET_ALREADY_LISTED, FailureInfo.SUPPORT_MARKET_EXISTS);\n    }\n\n    cToken.isCToken();\n    // Sanity check to make sure its really a CToken\n\n    // Note that isComped is not in active use anymore\n    Market storage market = markets[address(cToken)];\n    market.isListed = true;\n    market.isComped = false;\n    market.collateralFactorMantissa = 0;\n\n    _addMarketInternal(address(cToken));\n\n    emit MarketListed(cToken);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  function _addMarketInternal(address cToken) internal {\n    for (uint i = 0; i < allMarkets.length; i ++) {\n      require(allMarkets[i] != CToken(cToken), \"market already added\");\n    }\n    allMarkets.push(CToken(cToken));\n  }\n\n\n  /**\n    * @notice Set the given borrow caps for the given cToken markets. Borrowing that brings total borrows to or above borrow cap will revert.\n      * @dev Admin or borrowCapGuardian function to set the borrow caps. A borrow cap of 0 corresponds to unlimited borrowing.\n      * @param cTokens The addresses of the markets (tokens) to change the borrow caps for\n      * @param newBorrowCaps The new borrow cap values in underlying to be set. A value of 0 corresponds to unlimited borrowing.\n      */\n  function _setMarketBorrowCaps(CToken[] calldata cTokens, uint[] calldata newBorrowCaps) external {\n    require(msg.sender == admin || msg.sender == borrowCapGuardian, \"only admin or borrow cap guardian can set borrow caps\");\n\n    uint numMarkets = cTokens.length;\n    uint numBorrowCaps = newBorrowCaps.length;\n\n    require(numMarkets != 0 && numMarkets == numBorrowCaps, \"invalid input\");\n\n    for (uint i = 0; i < numMarkets; i++) {\n      borrowCaps[address(cTokens[i])] = newBorrowCaps[i];\n      emit NewBorrowCap(cTokens[i], newBorrowCaps[i]);\n    }\n  }\n\n  /**\n   * @notice Admin function to change the Borrow Cap Guardian\n     * @param newBorrowCapGuardian The address of the new Borrow Cap Guardian\n     */\n  function _setBorrowCapGuardian(address newBorrowCapGuardian) external {\n    require(msg.sender == admin, \"only admin can set borrow cap guardian\");\n\n    // Save current value for inclusion in log\n    address oldBorrowCapGuardian = borrowCapGuardian;\n\n    // Store borrowCapGuardian with value newBorrowCapGuardian\n    borrowCapGuardian = newBorrowCapGuardian;\n\n    // Emit NewBorrowCapGuardian(OldBorrowCapGuardian, NewBorrowCapGuardian)\n    emit NewBorrowCapGuardian(oldBorrowCapGuardian, newBorrowCapGuardian);\n  }\n\n  /**\n   * @notice Admin function to change the Pause Guardian\n     * @param newPauseGuardian The address of the new Pause Guardian\n     * @return uint 0=success, otherwise a failure. (See enum Error for details)\n     */\n  function _setPauseGuardian(address newPauseGuardian) public returns (uint) {\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PAUSE_GUARDIAN_OWNER_CHECK);\n    }\n\n    // Save current value for inclusion in log\n    address oldPauseGuardian = pauseGuardian;\n\n    // Store pauseGuardian with value newPauseGuardian\n    pauseGuardian = newPauseGuardian;\n\n    // Emit NewPauseGuardian(OldPauseGuardian, NewPauseGuardian)\n    emit NewPauseGuardian(oldPauseGuardian, pauseGuardian);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  function _setMintPaused(CToken cToken, bool state) public returns (bool) {\n    require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n    require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n    require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n    mintGuardianPaused[address(cToken)] = state;\n    emit ActionPaused(cToken, \"Mint\", state);\n    return state;\n  }\n\n  function _setBorrowPaused(CToken cToken, bool state) public returns (bool) {\n    require(markets[address(cToken)].isListed, \"cannot pause a market that is not listed\");\n    require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n    require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n    borrowGuardianPaused[address(cToken)] = state;\n    emit ActionPaused(cToken, \"Borrow\", state);\n    return state;\n  }\n\n  function _setTransferPaused(bool state) public returns (bool) {\n    require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n    require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n    transferGuardianPaused = state;\n    emit ActionPaused(\"Transfer\", state);\n    return state;\n  }\n\n  function _setSeizePaused(bool state) public returns (bool) {\n    require(msg.sender == pauseGuardian || msg.sender == admin, \"only pause guardian and admin can pause\");\n    require(msg.sender == admin || state == true, \"only admin can unpause\");\n\n    seizeGuardianPaused = state;\n    emit ActionPaused(\"Seize\", state);\n    return state;\n  }\n\n  function _become(Unitroller unitroller) public {\n    require(msg.sender == unitroller.admin(), \"only unitroller admin can change brains\");\n    require(unitroller._acceptImplementation() == 0, \"change not authorized\");\n  }\n\n  /**\n   * @notice Checks caller is admin, or this contract is becoming the new implementation\n     */\n  function adminOrInitializing() internal view returns (bool) {\n    return msg.sender == admin || msg.sender == comptrollerImplementation;\n  }\n\n  /*** Comp Distribution ***/\n\n  /**\n   * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n  function setCompSpeedInternal(CToken cToken, uint compSpeed) internal {\n    uint currentCompSpeed = compSpeeds[address(cToken)];\n    if (currentCompSpeed != 0) {\n      // note that COMP speed could be set to 0 to halt liquidity rewards for a market\n      Exp memory borrowIndex = Exp({mantissa : cToken.borrowIndex()});\n      updateCompSupplyIndex(address(cToken));\n      updateCompBorrowIndex(address(cToken), borrowIndex);\n    } else if (compSpeed != 0) {\n      // Add the COMP market\n      Market storage market = markets[address(cToken)];\n      require(market.isListed == true, \"comp market is not listed\");\n\n      if (compSupplyState[address(cToken)].index == 0 && compSupplyState[address(cToken)].block == 0) {\n        compSupplyState[address(cToken)] = CompMarketState({\n        index : compInitialIndex,\n        block : safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n        });\n      }\n\n      if (compBorrowState[address(cToken)].index == 0 && compBorrowState[address(cToken)].block == 0) {\n        compBorrowState[address(cToken)] = CompMarketState({\n        index : compInitialIndex,\n        block : safe32(getBlockNumber(), \"block number exceeds 32 bits\")\n        });\n      }\n    }\n\n    if (currentCompSpeed != compSpeed) {\n      compSpeeds[address(cToken)] = compSpeed;\n      emit CompSpeedUpdated(cToken, compSpeed);\n    }\n  }\n\n  /**\n   * @notice Accrue COMP to the market by updating the supply index\n     * @param cToken The market whose supply index to update\n     */\n  function updateCompSupplyIndex(address cToken) internal {\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    uint supplySpeed = compSpeeds[cToken];\n    uint blockNumber = getBlockNumber();\n    uint deltaBlocks = sub_(blockNumber, uint(supplyState.block));\n    if (deltaBlocks > 0 && supplySpeed > 0) {\n      uint supplyTokens = CToken(cToken).totalSupply();\n      uint compAccrued = mul_(deltaBlocks, supplySpeed);\n      Double memory ratio = supplyTokens > 0 ? fraction(compAccrued, supplyTokens) : Double({mantissa : 0});\n      Double memory index = add_(Double({mantissa : supplyState.index}), ratio);\n      compSupplyState[cToken] = CompMarketState({\n      index : safe224(index.mantissa, \"new index exceeds 224 bits\"),\n      block : safe32(blockNumber, \"block number exceeds 32 bits\")\n      });\n    } else if (deltaBlocks > 0) {\n      supplyState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n    }\n  }\n\n  /**\n   * @notice Accrue COMP to the market by updating the borrow index\n     * @param cToken The market whose borrow index to update\n     */\n  function updateCompBorrowIndex(address cToken, Exp memory marketBorrowIndex) internal {\n    CompMarketState storage borrowState = compBorrowState[cToken];\n    uint borrowSpeed = compSpeeds[cToken];\n    uint blockNumber = getBlockNumber();\n    uint deltaBlocks = sub_(blockNumber, uint(borrowState.block));\n    if (deltaBlocks > 0 && borrowSpeed > 0) {\n      uint borrowAmount = div_(CToken(cToken).totalBorrows(), marketBorrowIndex);\n      uint compAccrued = mul_(deltaBlocks, borrowSpeed);\n      Double memory ratio = borrowAmount > 0 ? fraction(compAccrued, borrowAmount) : Double({mantissa : 0});\n      Double memory index = add_(Double({mantissa : borrowState.index}), ratio);\n      compBorrowState[cToken] = CompMarketState({\n      index : safe224(index.mantissa, \"new index exceeds 224 bits\"),\n      block : safe32(blockNumber, \"block number exceeds 32 bits\")\n      });\n    } else if (deltaBlocks > 0) {\n      borrowState.block = safe32(blockNumber, \"block number exceeds 32 bits\");\n    }\n  }\n\n  /**\n   * @notice Calculate COMP accrued by a supplier and possibly transfer it to them\n     * @param cToken The market in which the supplier is interacting\n     * @param supplier The address of the supplier to distribute COMP to\n     */\n  function distributeSupplierComp(address cToken, address supplier) internal {\n    CompMarketState storage supplyState = compSupplyState[cToken];\n    Double memory supplyIndex = Double({mantissa : supplyState.index});\n    Double memory supplierIndex = Double({mantissa : compSupplierIndex[cToken][supplier]});\n    compSupplierIndex[cToken][supplier] = supplyIndex.mantissa;\n\n    if (supplierIndex.mantissa == 0 && supplyIndex.mantissa > 0) {\n      supplierIndex.mantissa = compInitialIndex;\n    }\n\n    Double memory deltaIndex = sub_(supplyIndex, supplierIndex);\n    uint supplierTokens = CToken(cToken).balanceOf(supplier);\n    uint supplierDelta = mul_(supplierTokens, deltaIndex);\n    uint supplierAccrued = add_(compAccrued[supplier], supplierDelta);\n    compAccrued[supplier] = supplierAccrued;\n    emit DistributedSupplierComp(CToken(cToken), supplier, supplierDelta, supplyIndex.mantissa);\n  }\n\n  /**\n   * @notice Calculate COMP accrued by a borrower and possibly transfer it to them\n     * @dev Borrowers will not begin to accrue until after the first interaction with the protocol.\n     * @param cToken The market in which the borrower is interacting\n     * @param borrower The address of the borrower to distribute COMP to\n     */\n  function distributeBorrowerComp(address cToken, address borrower, Exp memory marketBorrowIndex) internal {\n    CompMarketState storage borrowState = compBorrowState[cToken];\n    Double memory borrowIndex = Double({mantissa : borrowState.index});\n    Double memory borrowerIndex = Double({mantissa : compBorrowerIndex[cToken][borrower]});\n    compBorrowerIndex[cToken][borrower] = borrowIndex.mantissa;\n\n    if (borrowerIndex.mantissa > 0) {\n      Double memory deltaIndex = sub_(borrowIndex, borrowerIndex);\n      uint borrowerAmount = div_(CToken(cToken).borrowBalanceStored(borrower), marketBorrowIndex);\n      uint borrowerDelta = mul_(borrowerAmount, deltaIndex);\n      uint borrowerAccrued = add_(compAccrued[borrower], borrowerDelta);\n      compAccrued[borrower] = borrowerAccrued;\n      emit DistributedBorrowerComp(CToken(cToken), borrower, borrowerDelta, borrowIndex.mantissa);\n    }\n  }\n\n  /**\n   * @notice Calculate additional accrued COMP for a contributor since last accrual\n     * @param contributor The address to calculate contributor rewards for\n     */\n  function updateContributorRewards(address contributor) public {\n    uint compSpeed = compContributorSpeeds[contributor];\n    uint blockNumber = getBlockNumber();\n    uint deltaBlocks = sub_(blockNumber, lastContributorBlock[contributor]);\n    if (deltaBlocks > 0 && compSpeed > 0) {\n      uint newAccrued = mul_(deltaBlocks, compSpeed);\n      uint contributorAccrued = add_(compAccrued[contributor], newAccrued);\n\n      compAccrued[contributor] = contributorAccrued;\n      lastContributorBlock[contributor] = blockNumber;\n    }\n  }\n\n  /**\n   * @notice Claim all the comp accrued by holder in all markets\n     * @param holder The address to claim COMP for\n     */\n  function claimComp(address holder) public {\n    return claimComp(holder, allMarkets);\n  }\n\n  /**\n   * @notice Claim all the comp accrued by holder in the specified markets\n     * @param holder The address to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     */\n  function claimComp(address holder, CToken[] memory cTokens) public {\n    address[] memory holders = new address[](1);\n    holders[0] = holder;\n    claimComp(holders, cTokens, true, true);\n  }\n\n  /**\n   * @notice Claim all comp accrued by the holders\n     * @param holders The addresses to claim COMP for\n     * @param cTokens The list of markets to claim COMP in\n     * @param borrowers Whether or not to claim COMP earned by borrowing\n     * @param suppliers Whether or not to claim COMP earned by supplying\n     */\n  function claimComp(address[] memory holders, CToken[] memory cTokens, bool borrowers, bool suppliers) public {\n    for (uint i = 0; i < cTokens.length; i++) {\n      CToken cToken = cTokens[i];\n      require(markets[address(cToken)].isListed, \"market must be listed\");\n      if (borrowers == true) {\n        Exp memory borrowIndex = Exp({mantissa : cToken.borrowIndex()});\n        updateCompBorrowIndex(address(cToken), borrowIndex);\n        for (uint j = 0; j < holders.length; j++) {\n          distributeBorrowerComp(address(cToken), holders[j], borrowIndex);\n          compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n        }\n      }\n      if (suppliers == true) {\n        updateCompSupplyIndex(address(cToken));\n        for (uint j = 0; j < holders.length; j++) {\n          distributeSupplierComp(address(cToken), holders[j]);\n          compAccrued[holders[j]] = grantCompInternal(holders[j], compAccrued[holders[j]]);\n        }\n      }\n    }\n  }\n\n  /**\n   * @notice Transfer COMP to the user\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param user The address of the user to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     * @return The amount of COMP which was NOT transferred to the user\n     */\n  function grantCompInternal(address user, uint amount) internal returns (uint) {\n    Comp comp = Comp(getCompAddress());\n    uint compRemaining = comp.balanceOf(address(this));\n    if (amount > 0 && amount <= compRemaining) {\n      comp.transfer(user, amount);\n      return 0;\n    }\n    return amount;\n  }\n\n  /*** Comp Distribution Admin ***/\n\n  /**\n   * @notice Transfer COMP to the recipient\n     * @dev Note: If there is not enough COMP, we do not perform the transfer all.\n     * @param recipient The address of the recipient to transfer COMP to\n     * @param amount The amount of COMP to (possibly) transfer\n     */\n  function _grantComp(address recipient, uint amount) public {\n    require(adminOrInitializing(), \"only admin can grant comp\");\n    uint amountLeft = grantCompInternal(recipient, amount);\n    require(amountLeft == 0, \"insufficient comp for grant\");\n    emit CompGranted(recipient, amount);\n  }\n\n  /**\n   * @notice Set COMP speed for a single market\n     * @param cToken The market whose COMP speed to update\n     * @param compSpeed New COMP speed for market\n     */\n  function _setCompSpeed(CToken cToken, uint compSpeed) public {\n    require(adminOrInitializing(), \"only admin can set comp speed\");\n    setCompSpeedInternal(cToken, compSpeed);\n  }\n\n  /**\n   * @notice Set COMP speed for a single contributor\n     * @param contributor The contributor whose COMP speed to update\n     * @param compSpeed New COMP speed for contributor\n     */\n  function _setContributorCompSpeed(address contributor, uint compSpeed) public {\n    require(adminOrInitializing(), \"only admin can set comp speed\");\n\n    // note that COMP speed could be set to 0 to halt liquidity rewards for a contributor\n    updateContributorRewards(contributor);\n    if (compSpeed == 0) {\n      // release storage\n      delete lastContributorBlock[contributor];\n    } else {\n      lastContributorBlock[contributor] = getBlockNumber();\n    }\n    compContributorSpeeds[contributor] = compSpeed;\n\n    emit ContributorCompSpeedUpdated(contributor, compSpeed);\n  }\n\n  /**\n   * @notice Return all of the markets\n     * @dev The automatic getter may be used to access an individual market.\n     * @return The list of market addresses\n     */\n  function getAllMarkets() public view returns (CToken[] memory) {\n    return allMarkets;\n  }\n\n  function getBlockNumber() public view returns (uint) {\n    return block.number;\n  }\n\n  /**\n   * @notice Return the address of the COMP token\n     * @return The address of COMP\n     */\n  function getCompAddress() public pure returns (address) {\n    return 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n  }\n}\n"
    },
    "contracts/test/compound-core/ComptrollerInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nabstract contract ComptrollerInterface {\n  /// @notice Indicator that this is a Comptroller contract (for inspection)\n  bool public constant isComptroller = true;\n\n  /*** Assets You Are In ***/\n\n  function enterMarkets(address[] calldata cTokens) virtual external returns (uint[] memory);\n\n  function exitMarket(address cToken) virtual external returns (uint);\n\n  /*** Policy Hooks ***/\n\n  function mintAllowed(address cToken, address minter, uint mintAmount) virtual external returns (uint);\n\n  function mintVerify(address cToken, address minter, uint mintAmount, uint mintTokens) virtual external;\n\n  function redeemAllowed(address cToken, address redeemer, uint redeemTokens) virtual external returns (uint);\n\n  function redeemVerify(address cToken, address redeemer, uint redeemAmount, uint redeemTokens) virtual external;\n\n  function borrowAllowed(address cToken, address borrower, uint borrowAmount) virtual external returns (uint);\n\n  function borrowVerify(address cToken, address borrower, uint borrowAmount) virtual external;\n\n  function repayBorrowAllowed(\n    address cToken,\n    address payer,\n    address borrower,\n    uint repayAmount) virtual external returns (uint);\n\n  function repayBorrowVerify(\n    address cToken,\n    address payer,\n    address borrower,\n    uint repayAmount,\n    uint borrowerIndex) virtual external;\n\n  function liquidateBorrowAllowed(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint repayAmount) virtual external returns (uint);\n\n  function liquidateBorrowVerify(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    address liquidator,\n    address borrower,\n    uint repayAmount,\n    uint seizeTokens) virtual external;\n\n  function seizeAllowed(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint seizeTokens) virtual external returns (uint);\n\n  function seizeVerify(\n    address cTokenCollateral,\n    address cTokenBorrowed,\n    address liquidator,\n    address borrower,\n    uint seizeTokens) virtual external;\n\n  function transferAllowed(address cToken, address src, address dst, uint transferTokens) virtual external returns (uint);\n\n  function transferVerify(address cToken, address src, address dst, uint transferTokens) virtual external;\n\n  /*** Liquidity/Liquidation Calculations ***/\n\n  function liquidateCalculateSeizeTokens(\n    address cTokenBorrowed,\n    address cTokenCollateral,\n    uint repayAmount) virtual external view returns (uint, uint);\n}\n"
    },
    "contracts/test/compound-core/ComptrollerStorage.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\nimport \"./PriceOracle.sol\";\n\ncontract UnitrollerAdminStorage {\n  /**\n  * @notice Administrator for this contract\n    */\n  address public admin;\n\n  /**\n  * @notice Pending administrator for this contract\n    */\n  address public pendingAdmin;\n\n  /**\n  * @notice Active brains of Unitroller\n    */\n  address public comptrollerImplementation;\n\n  /**\n  * @notice Pending brains of Unitroller\n    */\n  address public pendingComptrollerImplementation;\n}\n\ncontract ComptrollerV1Storage is UnitrollerAdminStorage {\n\n  /**\n   * @notice Oracle which gives the price of any given asset\n     */\n  PriceOracle public oracle;\n\n  /**\n   * @notice Multiplier used to calculate the maximum repayAmount when liquidating a borrow\n     */\n  uint public closeFactorMantissa;\n\n  /**\n   * @notice Multiplier representing the discount on collateral that a liquidator receives\n     */\n  uint public liquidationIncentiveMantissa;\n\n  /**\n   * @notice Max number of assets a single account can participate in (borrow or use as collateral)\n     */\n  uint public maxAssets;\n\n  /**\n   * @notice Per-account mapping of \"assets you are in\", capped by maxAssets\n     */\n  mapping(address => CToken[]) public accountAssets;\n\n}\n\ncontract ComptrollerV2Storage is ComptrollerV1Storage {\n  struct Market {\n    // Whether or not this market is listed\n    bool isListed;\n\n    //  Multiplier representing the most one can borrow against their collateral in this market.\n    //  For instance, 0.9 to allow borrowing 90% of collateral value.\n    //  Must be between 0 and 1, and stored as a mantissa.\n    uint collateralFactorMantissa;\n\n    // Per-market mapping of \"accounts in this asset\"\n    mapping(address => bool) accountMembership;\n\n    // Whether or not this market receives COMP\n    bool isComped;\n  }\n\n  /**\n   * @notice Official mapping of cTokens -> Market metadata\n     * @dev Used e.g. to determine if a market is supported\n     */\n  mapping(address => Market) public markets;\n\n\n  /**\n   * @notice The Pause Guardian can pause certain actions as a safety mechanism.\n     *  Actions which allow users to remove their own assets cannot be paused.\n     *  Liquidation / seizing / transfer can only be paused globally, not by market.\n     */\n  address public pauseGuardian;\n  bool public _mintGuardianPaused;\n  bool public _borrowGuardianPaused;\n  bool public transferGuardianPaused;\n  bool public seizeGuardianPaused;\n  mapping(address => bool) public mintGuardianPaused;\n  mapping(address => bool) public borrowGuardianPaused;\n}\n\ncontract ComptrollerV3Storage is ComptrollerV2Storage {\n  struct CompMarketState {\n    // The market's last updated compBorrowIndex or compSupplyIndex\n    uint224 index;\n\n    // The block number the index was last updated at\n    uint32 block;\n  }\n\n  /// @notice A list of all markets\n  CToken[] public allMarkets;\n\n  /// @notice The rate at which the flywheel distributes COMP, per block\n  uint public compRate;\n\n  /// @notice The portion of compRate that each market currently receives\n  mapping(address => uint) public compSpeeds;\n\n  /// @notice The COMP market supply state for each market\n  mapping(address => CompMarketState) public compSupplyState;\n\n  /// @notice The COMP market borrow state for each market\n  mapping(address => CompMarketState) public compBorrowState;\n\n  /// @notice The COMP borrow index for each market for each supplier as of the last time they accrued COMP\n  mapping(address => mapping(address => uint)) public compSupplierIndex;\n\n  /// @notice The COMP borrow index for each market for each borrower as of the last time they accrued COMP\n  mapping(address => mapping(address => uint)) public compBorrowerIndex;\n\n  /// @notice The COMP accrued but not yet transferred to each user\n  mapping(address => uint) public compAccrued;\n}\n\ncontract ComptrollerV4Storage is ComptrollerV3Storage {\n  // @notice The borrowCapGuardian can set borrowCaps to any number for any market. Lowering the borrow cap could disable borrowing on the given market.\n  address public borrowCapGuardian;\n\n  // @notice Borrow caps enforced by borrowAllowed for each cToken address. Defaults to zero which corresponds to unlimited borrowing.\n  mapping(address => uint) public borrowCaps;\n}\n\ncontract ComptrollerV5Storage is ComptrollerV4Storage {\n  /// @notice The portion of COMP that each contributor receives per block\n  mapping(address => uint) public compContributorSpeeds;\n\n  /// @notice Last block at which a contributor's COMP rewards have been allocated\n  mapping(address => uint) public lastContributorBlock;\n}\n\ncontract ComptrollerV6Storage is ComptrollerV5Storage {\n  /// @notice The rate at which comp is distributed to the corresponding borrow market (per block)\n  mapping(address => uint) public compBorrowSpeeds;\n\n  /// @notice The rate at which comp is distributed to the corresponding supply market (per block)\n  mapping(address => uint) public compSupplySpeeds;\n}\n\ncontract ComptrollerV7Storage is ComptrollerV6Storage {\n  /// @notice Flag indicating whether the function to fix COMP accruals has been executed (RE: proposal 62 bug)\n  bool public proposal65FixExecuted;\n\n  /// @notice Accounting storage mapping account addresses to how much COMP they owe the protocol.\n  mapping(address => uint) public compReceivable;\n}\n"
    },
    "contracts/test/compound-core/CToken.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./CTokenInterfaces.sol\";\nimport \"./ErrorReporter.sol\";\nimport \"./EIP20Interface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./ExponentialNoError.sol\";\n\n/**\n * @title Compound's CToken Contract\n * @notice Abstract base for CTokens\n * @author Compound\n */\nabstract contract CToken is CTokenInterface, ExponentialNoError, TokenErrorReporter {\n  /**\n   * @notice Initialize the money market\n     * @param comptroller_ The address of the Comptroller\n     * @param interestRateModel_ The address of the interest rate model\n     * @param initialExchangeRateMantissa_ The initial exchange rate, scaled by 1e18\n     * @param name_ EIP-20 name of this token\n     * @param symbol_ EIP-20 symbol of this token\n     * @param decimals_ EIP-20 decimal precision of this token\n     */\n  function initialize(ComptrollerInterface comptroller_,\n    InterestRateModel interestRateModel_,\n    uint initialExchangeRateMantissa_,\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_) public {\n    require(msg.sender == admin, \"only admin may initialize the market\");\n    require(accrualBlockNumber == 0 && borrowIndex == 0, \"market may only be initialized once\");\n\n    // Set initial exchange rate\n    initialExchangeRateMantissa = initialExchangeRateMantissa_;\n    require(initialExchangeRateMantissa > 0, \"initial exchange rate must be greater than zero.\");\n\n    // Set the comptroller\n    uint err = _setComptroller(comptroller_);\n    require(err == NO_ERROR, \"setting comptroller failed\");\n\n    // Initialize block number and borrow index (block number mocks depend on comptroller being set)\n    accrualBlockNumber = getBlockNumber();\n    borrowIndex = mantissaOne;\n\n    // Set the interest rate model (depends on block number / borrow index)\n    err = _setInterestRateModelFresh(interestRateModel_);\n    require(err == NO_ERROR, \"setting interest rate model failed\");\n\n    name = name_;\n    symbol = symbol_;\n    decimals = decimals_;\n\n    // The counter starts true to prevent changing it from zero to non-zero (i.e. smaller cost/refund)\n    _notEntered = true;\n  }\n\n  /**\n   * @notice Transfer `tokens` tokens from `src` to `dst` by `spender`\n     * @dev Called by both `transfer` and `transferFrom` internally\n     * @param spender The address of the account performing the transfer\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param tokens The number of tokens to transfer\n     * @return 0 if the transfer succeeded, else revert\n     */\n  function transferTokens(address spender, address src, address dst, uint tokens) internal returns (uint) {\n    /* Fail if transfer not allowed */\n    uint allowed = comptroller.transferAllowed(address(this), src, dst, tokens);\n    if (allowed != 0) {\n      revert TransferComptrollerRejection(allowed);\n    }\n\n    /* Do not allow self-transfers */\n    if (src == dst) {\n      revert TransferNotAllowed();\n    }\n\n    /* Get the allowance, infinite for the account owner */\n    uint startingAllowance = 0;\n    if (spender == src) {\n      startingAllowance = type(uint).max;\n    } else {\n      startingAllowance = transferAllowances[src][spender];\n    }\n\n    /* Do the calculations, checking for {under,over}flow */\n    uint allowanceNew = startingAllowance - tokens;\n    uint srcTokensNew = accountTokens[src] - tokens;\n    uint dstTokensNew = accountTokens[dst] + tokens;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    accountTokens[src] = srcTokensNew;\n    accountTokens[dst] = dstTokensNew;\n\n    /* Eat some of the allowance (if necessary) */\n    if (startingAllowance != type(uint).max) {\n      transferAllowances[src][spender] = allowanceNew;\n    }\n\n    /* We emit a Transfer event */\n    emit Transfer(src, dst, tokens);\n\n    // unused function\n    // comptroller.transferVerify(address(this), src, dst, tokens);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n  function transfer(address dst, uint256 amount) override external nonReentrant returns (bool) {\n    return transferTokens(msg.sender, msg.sender, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param amount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n  function transferFrom(address src, address dst, uint256 amount) override external nonReentrant returns (bool) {\n    return transferTokens(msg.sender, src, dst, amount) == NO_ERROR;\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param amount The number of tokens that are approved (uint256.max means infinite)\n     * @return Whether or not the approval succeeded\n     */\n  function approve(address spender, uint256 amount) override external returns (bool) {\n    address src = msg.sender;\n    transferAllowances[src][spender] = amount;\n    emit Approval(src, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the current allowance from `owner` for `spender`\n     * @param owner The address of the account which owns the tokens to be spent\n     * @param spender The address of the account which may transfer tokens\n     * @return The number of tokens allowed to be spent (-1 means infinite)\n     */\n  function allowance(address owner, address spender) override external view returns (uint256) {\n    return transferAllowances[owner][spender];\n  }\n\n  /**\n   * @notice Get the token balance of the `owner`\n     * @param owner The address of the account to query\n     * @return The number of tokens owned by `owner`\n     */\n  function balanceOf(address owner) override external view returns (uint256) {\n    return accountTokens[owner];\n  }\n\n  /**\n   * @notice Get the underlying balance of the `owner`\n     * @dev This also accrues interest in a transaction\n     * @param owner The address of the account to query\n     * @return The amount of underlying owned by `owner`\n     */\n  function balanceOfUnderlying(address owner) override external returns (uint) {\n    Exp memory exchangeRate = Exp({mantissa : exchangeRateCurrent()});\n    return mul_ScalarTruncate(exchangeRate, accountTokens[owner]);\n  }\n\n  /**\n   * @notice Get a snapshot of the account's balances, and the cached exchange rate\n     * @dev This is used by comptroller to more efficiently perform liquidity checks.\n     * @param account Address of the account to snapshot\n     * @return (possible error, token balance, borrow balance, exchange rate mantissa)\n     */\n  function getAccountSnapshot(address account) override external view returns (uint, uint, uint, uint) {\n    return (\n    NO_ERROR,\n    accountTokens[account],\n    borrowBalanceStoredInternal(account),\n    exchangeRateStoredInternal()\n    );\n  }\n\n  /**\n   * @dev Function to simply retrieve block number\n     *  This exists mainly for inheriting test contracts to stub this result.\n     */\n  function getBlockNumber() virtual internal view returns (uint) {\n    return block.number;\n  }\n\n  /**\n   * @notice Returns the current per-block borrow interest rate for this cToken\n     * @return The borrow interest rate per block, scaled by 1e18\n     */\n  function borrowRatePerBlock() override external view returns (uint) {\n    return interestRateModel.getBorrowRate(getCashPrior(), totalBorrows, totalReserves);\n  }\n\n  /**\n   * @notice Returns the current per-block supply interest rate for this cToken\n     * @return The supply interest rate per block, scaled by 1e18\n     */\n  function supplyRatePerBlock() override external view returns (uint) {\n    return interestRateModel.getSupplyRate(getCashPrior(), totalBorrows, totalReserves, reserveFactorMantissa);\n  }\n\n  /**\n   * @notice Returns the current total borrows plus accrued interest\n     * @return The total borrows with interest\n     */\n  function totalBorrowsCurrent() override external nonReentrant returns (uint) {\n    accrueInterest();\n    return totalBorrows;\n  }\n\n  /**\n   * @notice Accrue interest to updated borrowIndex and then calculate account's borrow balance using the updated borrowIndex\n     * @param account The address whose balance should be calculated after updating borrowIndex\n     * @return The calculated balance\n     */\n  function borrowBalanceCurrent(address account) override external nonReentrant returns (uint) {\n    accrueInterest();\n    return borrowBalanceStored(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return The calculated balance\n     */\n  function borrowBalanceStored(address account) override public view returns (uint) {\n    return borrowBalanceStoredInternal(account);\n  }\n\n  /**\n   * @notice Return the borrow balance of account based on stored data\n     * @param account The address whose balance should be calculated\n     * @return (error code, the calculated balance or 0 if error code is non-zero)\n     */\n  function borrowBalanceStoredInternal(address account) internal view returns (uint) {\n    /* Get borrowBalance and borrowIndex */\n    BorrowSnapshot storage borrowSnapshot = accountBorrows[account];\n\n    /* If borrowBalance = 0 then borrowIndex is likely also 0.\n     * Rather than failing the calculation with a division by 0, we immediately return 0 in this case.\n     */\n    if (borrowSnapshot.principal == 0) {\n      return 0;\n    }\n\n    /* Calculate new borrow balance using the interest index:\n     *  recentBorrowBalance = borrower.borrowBalance * market.borrowIndex / borrower.borrowIndex\n     */\n    uint principalTimesIndex = borrowSnapshot.principal * borrowIndex;\n    return principalTimesIndex / borrowSnapshot.interestIndex;\n  }\n\n  /**\n   * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n  function exchangeRateCurrent() override public nonReentrant returns (uint) {\n    accrueInterest();\n    return exchangeRateStored();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n  function exchangeRateStored() override public view returns (uint) {\n    return exchangeRateStoredInternal();\n  }\n\n  /**\n   * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return calculated exchange rate scaled by 1e18\n     */\n  function exchangeRateStoredInternal() virtual internal view returns (uint) {\n    uint _totalSupply = totalSupply;\n    if (_totalSupply == 0) {\n      /*\n       * If there are no tokens minted:\n       *  exchangeRate = initialExchangeRate\n       */\n      return initialExchangeRateMantissa;\n    } else {\n      /*\n       * Otherwise:\n       *  exchangeRate = (totalCash + totalBorrows - totalReserves) / totalSupply\n       */\n      uint totalCash = getCashPrior();\n      uint cashPlusBorrowsMinusReserves = totalCash + totalBorrows - totalReserves;\n      uint exchangeRate = cashPlusBorrowsMinusReserves * expScale / _totalSupply;\n\n      return exchangeRate;\n    }\n  }\n\n  /**\n   * @notice Get cash balance of this cToken in the underlying asset\n     * @return The quantity of underlying asset owned by this contract\n     */\n  function getCash() override external view returns (uint) {\n    return getCashPrior();\n  }\n\n  /**\n   * @notice Applies accrued interest to total borrows and reserves\n     * @dev This calculates interest accrued from the last checkpointed block\n     *   up to the current block and writes new checkpoint to storage.\n     */\n  function accrueInterest() virtual override public returns (uint) {\n    /* Remember the initial block number */\n    uint currentBlockNumber = getBlockNumber();\n    uint accrualBlockNumberPrior = accrualBlockNumber;\n\n    /* Short-circuit accumulating 0 interest */\n    if (accrualBlockNumberPrior == currentBlockNumber) {\n      return NO_ERROR;\n    }\n\n    /* Read the previous values out of storage */\n    uint cashPrior = getCashPrior();\n    uint borrowsPrior = totalBorrows;\n    uint reservesPrior = totalReserves;\n    uint borrowIndexPrior = borrowIndex;\n\n    /* Calculate the current borrow interest rate */\n    uint borrowRateMantissa = interestRateModel.getBorrowRate(cashPrior, borrowsPrior, reservesPrior);\n    require(borrowRateMantissa <= borrowRateMaxMantissa, \"borrow rate is absurdly high\");\n\n    /* Calculate the number of blocks elapsed since the last accrual */\n    uint blockDelta = currentBlockNumber - accrualBlockNumberPrior;\n\n    /*\n     * Calculate the interest accumulated into borrows and reserves and the new index:\n     *  simpleInterestFactor = borrowRate * blockDelta\n     *  interestAccumulated = simpleInterestFactor * totalBorrows\n     *  totalBorrowsNew = interestAccumulated + totalBorrows\n     *  totalReservesNew = interestAccumulated * reserveFactor + totalReserves\n     *  borrowIndexNew = simpleInterestFactor * borrowIndex + borrowIndex\n     */\n\n    Exp memory simpleInterestFactor = mul_(Exp({mantissa : borrowRateMantissa}), blockDelta);\n    uint interestAccumulated = mul_ScalarTruncate(simpleInterestFactor, borrowsPrior);\n    uint totalBorrowsNew = interestAccumulated + borrowsPrior;\n    uint totalReservesNew = mul_ScalarTruncateAddUInt(Exp({mantissa : reserveFactorMantissa}), interestAccumulated, reservesPrior);\n    uint borrowIndexNew = mul_ScalarTruncateAddUInt(simpleInterestFactor, borrowIndexPrior, borrowIndexPrior);\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the previously calculated values into storage */\n    accrualBlockNumber = currentBlockNumber;\n    borrowIndex = borrowIndexNew;\n    totalBorrows = totalBorrowsNew;\n    totalReserves = totalReservesNew;\n\n    /* We emit an AccrueInterest event */\n    emit AccrueInterest(cashPrior, interestAccumulated, borrowIndexNew, totalBorrowsNew);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Sender supplies assets into the market and receives cTokens in exchange\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n  function mintInternal(uint mintAmount) internal nonReentrant {\n    accrueInterest();\n    // mintFresh emits the actual Mint event if successful and logs on errors, so we don't need to\n    mintFresh(msg.sender, mintAmount);\n  }\n\n  /**\n   * @notice User supplies assets into the market and receives cTokens in exchange\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param minter The address of the account which is supplying the assets\n     * @param mintAmount The amount of the underlying asset to supply\n     */\n  function mintFresh(address minter, uint mintAmount) internal {\n    /* Fail if mint not allowed */\n    uint allowed = comptroller.mintAllowed(address(this), minter, mintAmount);\n    if (allowed != 0) {\n      revert MintComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert MintFreshnessCheck();\n    }\n\n    Exp memory exchangeRate = Exp({mantissa : exchangeRateStoredInternal()});\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     *  We call `doTransferIn` for the minter and the mintAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  `doTransferIn` reverts if anything goes wrong, since we can't be sure if\n     *  side-effects occurred. The function returns the amount actually transferred,\n     *  in case of a fee. On success, the cToken holds an additional `actualMintAmount`\n     *  of cash.\n     */\n    uint actualMintAmount = doTransferIn(minter, mintAmount);\n\n    /*\n     * We get the current exchange rate and calculate the number of cTokens to be minted:\n     *  mintTokens = actualMintAmount / exchangeRate\n     */\n\n    uint mintTokens = div_(actualMintAmount, exchangeRate);\n\n    /*\n     * We calculate the new total supply of cTokens and minter token balance, checking for overflow:\n     *  totalSupplyNew = totalSupply + mintTokens\n     *  accountTokensNew = accountTokens[minter] + mintTokens\n     * And write them into storage\n     */\n    totalSupply = totalSupply + mintTokens;\n    accountTokens[minter] = accountTokens[minter] + mintTokens;\n\n    /* We emit a Mint event, and a Transfer event */\n    emit Mint(minter, actualMintAmount, mintTokens);\n    emit Transfer(address(this), minter, mintTokens);\n\n    /* We call the defense hook */\n    // unused function\n    // comptroller.mintVerify(address(this), minter, actualMintAmount, mintTokens);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for the underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemTokens The number of cTokens to redeem into underlying\n     */\n  function redeemInternal(uint redeemTokens) internal nonReentrant {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    redeemFresh(payable(msg.sender), redeemTokens, 0);\n  }\n\n  /**\n   * @notice Sender redeems cTokens in exchange for a specified amount of underlying asset\n     * @dev Accrues interest whether or not the operation succeeds, unless reverted\n     * @param redeemAmount The amount of underlying to receive from redeeming cTokens\n     */\n  function redeemUnderlyingInternal(uint redeemAmount) internal nonReentrant {\n    accrueInterest();\n    // redeemFresh emits redeem-specific logs on errors, so we don't need to\n    redeemFresh(payable(msg.sender), 0, redeemAmount);\n  }\n\n  /**\n   * @notice User redeems cTokens in exchange for the underlying asset\n     * @dev Assumes interest has already been accrued up to the current block\n     * @param redeemer The address of the account which is redeeming the tokens\n     * @param redeemTokensIn The number of cTokens to redeem into underlying (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     * @param redeemAmountIn The number of underlying tokens to receive from redeeming cTokens (only one of redeemTokensIn or redeemAmountIn may be non-zero)\n     */\n  function redeemFresh(address payable redeemer, uint redeemTokensIn, uint redeemAmountIn) internal {\n    require(redeemTokensIn == 0 || redeemAmountIn == 0, \"one of redeemTokensIn or redeemAmountIn must be zero\");\n\n    /* exchangeRate = invoke Exchange Rate Stored() */\n    Exp memory exchangeRate = Exp({mantissa : exchangeRateStoredInternal()});\n\n    uint redeemTokens;\n    uint redeemAmount;\n    /* If redeemTokensIn > 0: */\n    if (redeemTokensIn > 0) {\n      /*\n       * We calculate the exchange rate and the amount of underlying to be redeemed:\n       *  redeemTokens = redeemTokensIn\n       *  redeemAmount = redeemTokensIn x exchangeRateCurrent\n       */\n      redeemTokens = redeemTokensIn;\n      redeemAmount = mul_ScalarTruncate(exchangeRate, redeemTokensIn);\n    } else {\n      /*\n       * We get the current exchange rate and calculate the amount to be redeemed:\n       *  redeemTokens = redeemAmountIn / exchangeRate\n       *  redeemAmount = redeemAmountIn\n       */\n      redeemTokens = div_(redeemAmountIn, exchangeRate);\n      redeemAmount = redeemAmountIn;\n    }\n\n    /* Fail if redeem not allowed */\n    uint allowed = comptroller.redeemAllowed(address(this), redeemer, redeemTokens);\n    if (allowed != 0) {\n      revert RedeemComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert RedeemFreshnessCheck();\n    }\n\n    /* Fail gracefully if protocol has insufficient cash */\n    if (getCashPrior() < redeemAmount) {\n      revert RedeemTransferOutNotPossible();\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n\n    /*\n     * We write the previously calculated values into storage.\n     *  Note: Avoid token reentrancy attacks by writing reduced supply before external transfer.\n     */\n    totalSupply = totalSupply - redeemTokens;\n    accountTokens[redeemer] = accountTokens[redeemer] - redeemTokens;\n\n    /*\n     * We invoke doTransferOut for the redeemer and the redeemAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken has redeemAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(redeemer, redeemAmount);\n\n    /* We emit a Transfer event, and a Redeem event */\n    emit Transfer(redeemer, address(this), redeemTokens);\n    emit Redeem(redeemer, redeemAmount, redeemTokens);\n\n    /* We call the defense hook */\n    comptroller.redeemVerify(address(this), redeemer, redeemAmount, redeemTokens);\n  }\n\n  /**\n    * @notice Sender borrows assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n  function borrowInternal(uint borrowAmount) internal nonReentrant {\n    accrueInterest();\n    // borrowFresh emits borrow-specific logs on errors, so we don't need to\n    borrowFresh(payable(msg.sender), borrowAmount);\n  }\n\n  /**\n    * @notice Users borrow assets from the protocol to their own address\n      * @param borrowAmount The amount of the underlying asset to borrow\n      */\n  function borrowFresh(address payable borrower, uint borrowAmount) internal {\n    /* Fail if borrow not allowed */\n    uint allowed = comptroller.borrowAllowed(address(this), borrower, borrowAmount);\n    if (allowed != 0) {\n      revert BorrowComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert BorrowFreshnessCheck();\n    }\n\n    /* Fail gracefully if protocol has insufficient underlying cash */\n    if (getCashPrior() < borrowAmount) {\n      revert BorrowCashNotAvailable();\n    }\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on overflow:\n     *  accountBorrowNew = accountBorrow + borrowAmount\n     *  totalBorrowsNew = totalBorrows + borrowAmount\n     */\n    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n    uint accountBorrowsNew = accountBorrowsPrev + borrowAmount;\n    uint totalBorrowsNew = totalBorrows + borrowAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We write the previously calculated values into storage.\n     *  Note: Avoid token reentrancy attacks by writing increased borrow before external transfer.\n    `*/\n    accountBorrows[borrower].principal = accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = totalBorrowsNew;\n\n    /*\n     * We invoke doTransferOut for the borrower and the borrowAmount.\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken borrowAmount less of cash.\n     *  doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     */\n    doTransferOut(borrower, borrowAmount);\n\n    /* We emit a Borrow event */\n    emit Borrow(borrower, borrowAmount, accountBorrowsNew, totalBorrowsNew);\n  }\n\n  /**\n   * @notice Sender repays their own borrow\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     */\n  function repayBorrowInternal(uint repayAmount) internal nonReentrant {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    repayBorrowFresh(msg.sender, msg.sender, repayAmount);\n  }\n\n  /**\n   * @notice Sender repays a borrow belonging to borrower\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount The amount to repay, or -1 for the full outstanding amount\n     */\n  function repayBorrowBehalfInternal(address borrower, uint repayAmount) internal nonReentrant {\n    accrueInterest();\n    // repayBorrowFresh emits repay-borrow-specific logs on errors, so we don't need to\n    repayBorrowFresh(msg.sender, borrower, repayAmount);\n  }\n\n  /**\n   * @notice Borrows are repaid by another user (possibly the borrower).\n     * @param payer the account paying off the borrow\n     * @param borrower the account with the debt being payed off\n     * @param repayAmount the amount of underlying tokens being returned, or -1 for the full outstanding amount\n     * @return (uint) the actual repayment amount.\n     */\n  function repayBorrowFresh(address payer, address borrower, uint repayAmount) internal returns (uint) {\n    /* Fail if repayBorrow not allowed */\n    uint allowed = comptroller.repayBorrowAllowed(address(this), payer, borrower, repayAmount);\n    if (allowed != 0) {\n      revert RepayBorrowComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert RepayBorrowFreshnessCheck();\n    }\n\n    /* We fetch the amount the borrower owes, with accumulated interest */\n    uint accountBorrowsPrev = borrowBalanceStoredInternal(borrower);\n\n    /* If repayAmount == -1, repayAmount = accountBorrows */\n    uint repayAmountFinal = repayAmount == type(uint).max ? accountBorrowsPrev : repayAmount;\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the payer and the repayAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional repayAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *   it returns the amount actually transferred, in case of a fee.\n     */\n    uint actualRepayAmount = doTransferIn(payer, repayAmountFinal);\n\n    /*\n     * We calculate the new borrower and total borrow balances, failing on underflow:\n     *  accountBorrowsNew = accountBorrows - actualRepayAmount\n     *  totalBorrowsNew = totalBorrows - actualRepayAmount\n     */\n    uint accountBorrowsNew = accountBorrowsPrev - actualRepayAmount;\n    uint totalBorrowsNew = totalBorrows - actualRepayAmount;\n\n    /* We write the previously calculated values into storage */\n    accountBorrows[borrower].principal = accountBorrowsNew;\n    accountBorrows[borrower].interestIndex = borrowIndex;\n    totalBorrows = totalBorrowsNew;\n\n    /* We emit a RepayBorrow event */\n    emit RepayBorrow(payer, borrower, actualRepayAmount, accountBorrowsNew, totalBorrowsNew);\n\n    return actualRepayAmount;\n  }\n\n  /**\n   * @notice The sender liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     */\n  function liquidateBorrowInternal(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal nonReentrant {\n    accrueInterest();\n\n    uint error = cTokenCollateral.accrueInterest();\n    if (error != NO_ERROR) {\n      // accrueInterest emits logs on errors, but we still want to log the fact that an attempted liquidation failed\n      revert LiquidateAccrueCollateralInterestFailed(error);\n    }\n\n    // liquidateBorrowFresh emits borrow-specific logs on errors, so we don't need to\n    liquidateBorrowFresh(msg.sender, borrower, repayAmount, cTokenCollateral);\n  }\n\n  /**\n   * @notice The liquidator liquidates the borrowers collateral.\n     *  The collateral seized is transferred to the liquidator.\n     * @param borrower The borrower of this cToken to be liquidated\n     * @param liquidator The address repaying the borrow and seizing collateral\n     * @param cTokenCollateral The market in which to seize collateral from the borrower\n     * @param repayAmount The amount of the underlying borrowed asset to repay\n     */\n  function liquidateBorrowFresh(address liquidator, address borrower, uint repayAmount, CTokenInterface cTokenCollateral) internal {\n    /* Fail if liquidate not allowed */\n    uint allowed = comptroller.liquidateBorrowAllowed(address(this), address(cTokenCollateral), liquidator, borrower, repayAmount);\n    if (allowed != 0) {\n      revert LiquidateComptrollerRejection(allowed);\n    }\n\n    /* Verify market's block number equals current block number */\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert LiquidateFreshnessCheck();\n    }\n\n    /* Verify cTokenCollateral market's block number equals current block number */\n    if (cTokenCollateral.accrualBlockNumber() != getBlockNumber()) {\n      revert LiquidateCollateralFreshnessCheck();\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      revert LiquidateLiquidatorIsBorrower();\n    }\n\n    /* Fail if repayAmount = 0 */\n    if (repayAmount == 0) {\n      revert LiquidateCloseAmountIsZero();\n    }\n\n    /* Fail if repayAmount = -1 */\n    if (repayAmount == type(uint).max) {\n      revert LiquidateCloseAmountIsUintMax();\n    }\n\n    /* Fail if repayBorrow fails */\n    uint actualRepayAmount = repayBorrowFresh(liquidator, borrower, repayAmount);\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We calculate the number of collateral tokens that will be seized */\n    (uint amountSeizeError, uint seizeTokens) = comptroller.liquidateCalculateSeizeTokens(address(this), address(cTokenCollateral), actualRepayAmount);\n    require(amountSeizeError == NO_ERROR, \"LIQUIDATE_COMPTROLLER_CALCULATE_AMOUNT_SEIZE_FAILED\");\n\n    /* Revert if borrower collateral token balance < seizeTokens */\n    require(cTokenCollateral.balanceOf(borrower) >= seizeTokens, \"LIQUIDATE_SEIZE_TOO_MUCH\");\n\n    // If this is also the collateral, run seizeInternal to avoid re-entrancy, otherwise make an external call\n    if (address(cTokenCollateral) == address(this)) {\n      seizeInternal(address(this), liquidator, borrower, seizeTokens);\n    } else {\n      require(cTokenCollateral.seize(liquidator, borrower, seizeTokens) == NO_ERROR, \"token seizure failed\");\n    }\n\n    /* We emit a LiquidateBorrow event */\n    emit LiquidateBorrow(liquidator, borrower, actualRepayAmount, address(cTokenCollateral), seizeTokens);\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Will fail unless called by another cToken during the process of liquidation.\n     *  Its absolutely critical to use msg.sender as the borrowed cToken and not a parameter.\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function seize(address liquidator, address borrower, uint seizeTokens) override external nonReentrant returns (uint) {\n    seizeInternal(msg.sender, liquidator, borrower, seizeTokens);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Transfers collateral tokens (this market) to the liquidator.\n     * @dev Called only during an in-kind liquidation, or by liquidateBorrow during the liquidation of another CToken.\n     *  Its absolutely critical to use msg.sender as the seizer cToken and not a parameter.\n     * @param seizerToken The contract seizing the collateral (i.e. borrowed cToken)\n     * @param liquidator The account receiving seized collateral\n     * @param borrower The account having collateral seized\n     * @param seizeTokens The number of cTokens to seize\n     */\n  function seizeInternal(address seizerToken, address liquidator, address borrower, uint seizeTokens) internal {\n    /* Fail if seize not allowed */\n    uint allowed = comptroller.seizeAllowed(address(this), seizerToken, liquidator, borrower, seizeTokens);\n    if (allowed != 0) {\n      revert LiquidateSeizeComptrollerRejection(allowed);\n    }\n\n    /* Fail if borrower = liquidator */\n    if (borrower == liquidator) {\n      revert LiquidateSeizeLiquidatorIsBorrower();\n    }\n\n    /*\n     * We calculate the new borrower and liquidator token balances, failing on underflow/overflow:\n     *  borrowerTokensNew = accountTokens[borrower] - seizeTokens\n     *  liquidatorTokensNew = accountTokens[liquidator] + seizeTokens\n     */\n    uint protocolSeizeTokens = mul_(seizeTokens, Exp({mantissa : protocolSeizeShareMantissa}));\n    uint liquidatorSeizeTokens = seizeTokens - protocolSeizeTokens;\n    Exp memory exchangeRate = Exp({mantissa : exchangeRateStoredInternal()});\n    uint protocolSeizeAmount = mul_ScalarTruncate(exchangeRate, protocolSeizeTokens);\n    uint totalReservesNew = totalReserves + protocolSeizeAmount;\n\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /* We write the calculated values into storage */\n    totalReserves = totalReservesNew;\n    totalSupply = totalSupply - protocolSeizeTokens;\n    accountTokens[borrower] = accountTokens[borrower] - seizeTokens;\n    accountTokens[liquidator] = accountTokens[liquidator] + liquidatorSeizeTokens;\n\n    /* Emit a Transfer event */\n    emit Transfer(borrower, liquidator, liquidatorSeizeTokens);\n    emit Transfer(borrower, address(this), protocolSeizeTokens);\n    emit ReservesAdded(address(this), protocolSeizeAmount, totalReservesNew);\n  }\n\n\n  /*** Admin Functions ***/\n\n  /**\n    * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _setPendingAdmin(address payable newPendingAdmin) override external returns (uint) {\n    // Check caller = admin\n    if (msg.sender != admin) {\n      revert SetPendingAdminOwnerCheck();\n    }\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return NO_ERROR;\n  }\n\n  /**\n    * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _acceptAdmin() override external returns (uint) {\n    // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      revert AcceptAdminPendingAdminCheck();\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = payable(address(0));\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return NO_ERROR;\n  }\n\n  /**\n    * @notice Sets a new comptroller for the market\n      * @dev Admin function to set a new comptroller\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _setComptroller(ComptrollerInterface newComptroller) override public returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetComptrollerOwnerCheck();\n    }\n\n    ComptrollerInterface oldComptroller = comptroller;\n    // Ensure invoke comptroller.isComptroller() returns true\n    require(newComptroller.isComptroller(), \"marker method returned false\");\n\n    // Set market's comptroller to newComptroller\n    comptroller = newComptroller;\n\n    // Emit NewComptroller(oldComptroller, newComptroller)\n    emit NewComptroller(oldComptroller, newComptroller);\n\n    return NO_ERROR;\n  }\n\n  /**\n    * @notice accrues interest and sets a new reserve factor for the protocol using _setReserveFactorFresh\n      * @dev Admin function to accrue interest and set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _setReserveFactor(uint newReserveFactorMantissa) override external nonReentrant returns (uint) {\n    accrueInterest();\n    // _setReserveFactorFresh emits reserve-factor-specific logs on errors, so we don't need to.\n    return _setReserveFactorFresh(newReserveFactorMantissa);\n  }\n\n  /**\n    * @notice Sets a new reserve factor for the protocol (*requires fresh interest accrual)\n      * @dev Admin function to set a new reserve factor\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _setReserveFactorFresh(uint newReserveFactorMantissa) internal returns (uint) {\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetReserveFactorAdminCheck();\n    }\n\n    // Verify market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert SetReserveFactorFreshCheck();\n    }\n\n    // Check newReserveFactor ≤ maxReserveFactor\n    if (newReserveFactorMantissa > reserveFactorMaxMantissa) {\n      revert SetReserveFactorBoundsCheck();\n    }\n\n    uint oldReserveFactorMantissa = reserveFactorMantissa;\n    reserveFactorMantissa = newReserveFactorMantissa;\n\n    emit NewReserveFactor(oldReserveFactorMantissa, newReserveFactorMantissa);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring from msg.sender\n     * @param addAmount Amount of addition to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function _addReservesInternal(uint addAmount) internal nonReentrant returns (uint) {\n    accrueInterest();\n\n    // _addReservesFresh emits reserve-addition-specific logs on errors, so we don't need to.\n    _addReservesFresh(addAmount);\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice Add reserves by transferring from caller\n     * @dev Requires fresh interest accrual\n     * @param addAmount Amount of addition to reserves\n     * @return (uint, uint) An error code (0=success, otherwise a failure (see ErrorReporter.sol for details)) and the actual amount added, net token fees\n     */\n  function _addReservesFresh(uint addAmount) internal returns (uint, uint) {\n    // totalReserves + actualAddAmount\n    uint totalReservesNew;\n    uint actualAddAmount;\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert AddReservesFactorFreshCheck(actualAddAmount);\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    /*\n     * We call doTransferIn for the caller and the addAmount\n     *  Note: The cToken must handle variations between ERC-20 and ETH underlying.\n     *  On success, the cToken holds an additional addAmount of cash.\n     *  doTransferIn reverts if anything goes wrong, since we can't be sure if side effects occurred.\n     *  it returns the amount actually transferred, in case of a fee.\n     */\n\n    actualAddAmount = doTransferIn(msg.sender, addAmount);\n\n    totalReservesNew = totalReserves + actualAddAmount;\n\n    // Store reserves[n+1] = reserves[n] + actualAddAmount\n    totalReserves = totalReservesNew;\n\n    /* Emit NewReserves(admin, actualAddAmount, reserves[n+1]) */\n    emit ReservesAdded(msg.sender, actualAddAmount, totalReservesNew);\n\n    /* Return (NO_ERROR, actualAddAmount) */\n    return (NO_ERROR, actualAddAmount);\n  }\n\n\n  /**\n   * @notice Accrues interest and reduces reserves by transferring to admin\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function _reduceReserves(uint reduceAmount) override external nonReentrant returns (uint) {\n    accrueInterest();\n    // _reduceReservesFresh emits reserve-reduction-specific logs on errors, so we don't need to.\n    return _reduceReservesFresh(reduceAmount);\n  }\n\n  /**\n   * @notice Reduces reserves by transferring to admin\n     * @dev Requires fresh interest accrual\n     * @param reduceAmount Amount of reduction to reserves\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function _reduceReservesFresh(uint reduceAmount) internal returns (uint) {\n    // totalReserves - reduceAmount\n    uint totalReservesNew;\n\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert ReduceReservesAdminCheck();\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert ReduceReservesFreshCheck();\n    }\n\n    // Fail gracefully if protocol has insufficient underlying cash\n    if (getCashPrior() < reduceAmount) {\n      revert ReduceReservesCashNotAvailable();\n    }\n\n    // Check reduceAmount ≤ reserves[n] (totalReserves)\n    if (reduceAmount > totalReserves) {\n      revert ReduceReservesCashValidation();\n    }\n\n    /////////////////////////\n    // EFFECTS & INTERACTIONS\n    // (No safe failures beyond this point)\n\n    totalReservesNew = totalReserves - reduceAmount;\n\n    // Store reserves[n+1] = reserves[n] - reduceAmount\n    totalReserves = totalReservesNew;\n\n    // doTransferOut reverts if anything goes wrong, since we can't be sure if side effects occurred.\n    doTransferOut(admin, reduceAmount);\n\n    emit ReservesReduced(admin, reduceAmount, totalReservesNew);\n\n    return NO_ERROR;\n  }\n\n  /**\n   * @notice accrues interest and updates the interest rate model using _setInterestRateModelFresh\n     * @dev Admin function to accrue interest and update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) override public returns (uint) {\n    accrueInterest();\n    // _setInterestRateModelFresh emits interest-rate-model-update-specific logs on errors, so we don't need to.\n    return _setInterestRateModelFresh(newInterestRateModel);\n  }\n\n  /**\n   * @notice updates the interest rate model (*requires fresh interest accrual)\n     * @dev Admin function to update the interest rate model\n     * @param newInterestRateModel the new interest rate model to use\n     * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n     */\n  function _setInterestRateModelFresh(InterestRateModel newInterestRateModel) internal returns (uint) {\n\n    // Used to store old model for use in the event that is emitted on success\n    InterestRateModel oldInterestRateModel;\n\n    // Check caller is admin\n    if (msg.sender != admin) {\n      revert SetInterestRateModelOwnerCheck();\n    }\n\n    // We fail gracefully unless market's block number equals current block number\n    if (accrualBlockNumber != getBlockNumber()) {\n      revert SetInterestRateModelFreshCheck();\n    }\n\n    // Track the market's current interest rate model\n    oldInterestRateModel = interestRateModel;\n\n    // Ensure invoke newInterestRateModel.isInterestRateModel() returns true\n    require(newInterestRateModel.isInterestRateModel(), \"marker method returned false\");\n\n    // Set the interest rate model to newInterestRateModel\n    interestRateModel = newInterestRateModel;\n\n    // Emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel)\n    emit NewMarketInterestRateModel(oldInterestRateModel, newInterestRateModel);\n\n    return NO_ERROR;\n  }\n\n  /*** Safe Token ***/\n\n  /**\n   * @notice Gets balance of this contract in terms of the underlying\n     * @dev This excludes the value of the current message, if any\n     * @return The quantity of underlying owned by this contract\n     */\n  function getCashPrior() virtual internal view returns (uint);\n\n  /**\n   * @dev Performs a transfer in, reverting upon failure. Returns the amount actually transferred to the protocol, in case of a fee.\n     *  This may revert due to insufficient balance or insufficient allowance.\n     */\n  function doTransferIn(address from, uint amount) virtual internal returns (uint);\n\n  /**\n   * @dev Performs a transfer out, ideally returning an explanatory error code upon failure rather than reverting.\n     *  If caller has not called checked protocol's balance, may revert due to insufficient cash held in the contract.\n     *  If caller has checked protocol's balance, and verified it is >= amount, this should not revert in normal conditions.\n     */\n  function doTransferOut(address payable to, uint amount) virtual internal;\n\n\n  /*** Reentrancy Guard ***/\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n     */\n  modifier nonReentrant() {\n    require(_notEntered, \"re-entered\");\n    _notEntered = false;\n    _;\n    _notEntered = true;\n    // get a gas-refund post-Istanbul\n  }\n}\n"
    },
    "contracts/test/compound-core/CTokenInterfaces.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ComptrollerInterface.sol\";\nimport \"./InterestRateModel.sol\";\nimport \"./EIP20NonStandardInterface.sol\";\nimport \"./ErrorReporter.sol\";\n\ncontract CTokenStorage {\n  /**\n   * @dev Guard variable for re-entrancy checks\n     */\n  bool internal _notEntered;\n\n  /**\n   * @notice EIP-20 token name for this token\n     */\n  string public name;\n\n  /**\n   * @notice EIP-20 token symbol for this token\n     */\n  string public symbol;\n\n  /**\n   * @notice EIP-20 token decimals for this token\n     */\n  uint8 public decimals;\n\n  // Maximum borrow rate that can ever be applied (.0005% / block)\n  uint internal constant borrowRateMaxMantissa = 0.0005e16;\n\n  // Maximum fraction of interest that can be set aside for reserves\n  uint internal constant reserveFactorMaxMantissa = 1e18;\n\n  /**\n   * @notice Administrator for this contract\n     */\n  address payable public admin;\n\n  /**\n   * @notice Pending administrator for this contract\n     */\n  address payable public pendingAdmin;\n\n  /**\n   * @notice Contract which oversees inter-cToken operations\n     */\n  ComptrollerInterface public comptroller;\n\n  /**\n   * @notice Model which tells what the current interest rate should be\n     */\n  InterestRateModel public interestRateModel;\n\n  // Initial exchange rate used when minting the first CTokens (used when totalSupply = 0)\n  uint internal initialExchangeRateMantissa;\n\n  /**\n   * @notice Fraction of interest currently set aside for reserves\n     */\n  uint public reserveFactorMantissa;\n\n  /**\n   * @notice Block number that interest was last accrued at\n     */\n  uint public accrualBlockNumber;\n\n  /**\n   * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n  uint public borrowIndex;\n\n  /**\n   * @notice Total amount of outstanding borrows of the underlying in this market\n     */\n  uint public totalBorrows;\n\n  /**\n   * @notice Total amount of reserves of the underlying held in this market\n     */\n  uint public totalReserves;\n\n  /**\n   * @notice Total number of tokens in circulation\n     */\n  uint public totalSupply;\n\n  // Official record of token balances for each account\n  mapping(address => uint) internal accountTokens;\n\n  // Approved token transfer amounts on behalf of others\n  mapping(address => mapping(address => uint)) internal transferAllowances;\n\n  /**\n   * @notice Container for borrow balance information\n     * @member principal Total balance (with accrued interest), after applying the most recent balance-changing action\n     * @member interestIndex Global borrowIndex as of the most recent balance-changing action\n     */\n  struct BorrowSnapshot {\n    uint principal;\n    uint interestIndex;\n  }\n\n  // Mapping of account addresses to outstanding borrow balances\n  mapping(address => BorrowSnapshot) internal accountBorrows;\n\n  /**\n   * @notice Share of seized collateral that is added to reserves\n     */\n  uint public constant protocolSeizeShareMantissa = 2.8e16; //2.8%\n}\n\nabstract contract CTokenInterface is CTokenStorage {\n  /**\n   * @notice Indicator that this is a CToken contract (for inspection)\n     */\n  bool public constant isCToken = true;\n\n\n  /*** Market Events ***/\n\n  /**\n   * @notice Event emitted when interest is accrued\n     */\n  event AccrueInterest(uint cashPrior, uint interestAccumulated, uint borrowIndex, uint totalBorrows);\n\n  /**\n   * @notice Event emitted when tokens are minted\n     */\n  event Mint(address minter, uint mintAmount, uint mintTokens);\n\n  /**\n   * @notice Event emitted when tokens are redeemed\n     */\n  event Redeem(address redeemer, uint redeemAmount, uint redeemTokens);\n\n  /**\n   * @notice Event emitted when underlying is borrowed\n     */\n  event Borrow(address borrower, uint borrowAmount, uint accountBorrows, uint totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is repaid\n     */\n  event RepayBorrow(address payer, address borrower, uint repayAmount, uint accountBorrows, uint totalBorrows);\n\n  /**\n   * @notice Event emitted when a borrow is liquidated\n     */\n  event LiquidateBorrow(address liquidator, address borrower, uint repayAmount, address cTokenCollateral, uint seizeTokens);\n\n\n  /*** Admin Events ***/\n\n  /**\n   * @notice Event emitted when pendingAdmin is changed\n     */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n   * @notice Event emitted when pendingAdmin is accepted, which means admin is updated\n     */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  /**\n   * @notice Event emitted when comptroller is changed\n     */\n  event NewComptroller(ComptrollerInterface oldComptroller, ComptrollerInterface newComptroller);\n\n  /**\n   * @notice Event emitted when interestRateModel is changed\n     */\n  event NewMarketInterestRateModel(InterestRateModel oldInterestRateModel, InterestRateModel newInterestRateModel);\n\n  /**\n   * @notice Event emitted when the reserve factor is changed\n     */\n  event NewReserveFactor(uint oldReserveFactorMantissa, uint newReserveFactorMantissa);\n\n  /**\n   * @notice Event emitted when the reserves are added\n     */\n  event ReservesAdded(address benefactor, uint addAmount, uint newTotalReserves);\n\n  /**\n   * @notice Event emitted when the reserves are reduced\n     */\n  event ReservesReduced(address admin, uint reduceAmount, uint newTotalReserves);\n\n  /**\n   * @notice EIP20 Transfer event\n     */\n  event Transfer(address indexed from, address indexed to, uint amount);\n\n  /**\n   * @notice EIP20 Approval event\n     */\n  event Approval(address indexed owner, address indexed spender, uint amount);\n\n\n  /*** User Interface ***/\n\n  function transfer(address dst, uint amount) virtual external returns (bool);\n\n  function transferFrom(address src, address dst, uint amount) virtual external returns (bool);\n\n  function approve(address spender, uint amount) virtual external returns (bool);\n\n  function allowance(address owner, address spender) virtual external view returns (uint);\n\n  function balanceOf(address owner) virtual external view returns (uint);\n\n  function balanceOfUnderlying(address owner) virtual external returns (uint);\n\n  function getAccountSnapshot(address account) virtual external view returns (uint, uint, uint, uint);\n\n  function borrowRatePerBlock() virtual external view returns (uint);\n\n  function supplyRatePerBlock() virtual external view returns (uint);\n\n  function totalBorrowsCurrent() virtual external returns (uint);\n\n  function borrowBalanceCurrent(address account) virtual external returns (uint);\n\n  function borrowBalanceStored(address account) virtual external view returns (uint);\n\n  function exchangeRateCurrent() virtual external returns (uint);\n\n  function exchangeRateStored() virtual external view returns (uint);\n\n  function getCash() virtual external view returns (uint);\n\n  function accrueInterest() virtual external returns (uint);\n\n  function seize(address liquidator, address borrower, uint seizeTokens) virtual external returns (uint);\n\n\n  /*** Admin Functions ***/\n\n  function _setPendingAdmin(address payable newPendingAdmin) virtual external returns (uint);\n\n  function _acceptAdmin() virtual external returns (uint);\n\n  function _setComptroller(ComptrollerInterface newComptroller) virtual external returns (uint);\n\n  function _setReserveFactor(uint newReserveFactorMantissa) virtual external returns (uint);\n\n  function _reduceReserves(uint reduceAmount) virtual external returns (uint);\n\n  function _setInterestRateModel(InterestRateModel newInterestRateModel) virtual external returns (uint);\n}\n\ncontract CErc20Storage {\n  /**\n   * @notice Underlying asset for this CToken\n     */\n  address public underlying;\n}\n\nabstract contract CErc20Interface is CErc20Storage {\n\n  /*** User Interface ***/\n\n  function mint(uint mintAmount) virtual external returns (uint);\n\n  function redeem(uint redeemTokens) virtual external returns (uint);\n\n  function redeemUnderlying(uint redeemAmount) virtual external returns (uint);\n\n  function borrow(uint borrowAmount) virtual external returns (uint);\n\n  function repayBorrow(uint repayAmount) virtual external returns (uint);\n\n  function repayBorrowBehalf(address borrower, uint repayAmount) virtual external returns (uint);\n\n  function liquidateBorrow(address borrower, uint repayAmount, CTokenInterface cTokenCollateral) virtual external returns (uint);\n\n  function sweepToken(EIP20NonStandardInterface token) virtual external;\n\n\n  /*** Admin Functions ***/\n\n  function _addReserves(uint addAmount) virtual external returns (uint);\n}\n\ncontract CDelegationStorage {\n  /**\n   * @notice Implementation address for this contract\n     */\n  address public implementation;\n}\n\nabstract contract CDelegatorInterface is CDelegationStorage {\n  /**\n   * @notice Emitted when implementation is changed\n     */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n   * @notice Called by the admin to update the implementation of the delegator\n     * @param implementation_ The address of the new implementation for delegation\n     * @param allowResign Flag to indicate whether to call _resignImplementation on the old implementation\n     * @param becomeImplementationData The encoded bytes data to be passed to _becomeImplementation\n     */\n  function _setImplementation(address implementation_, bool allowResign, bytes memory becomeImplementationData) virtual external;\n}\n\nabstract contract CDelegateInterface is CDelegationStorage {\n  /**\n   * @notice Called by the delegator on a delegate to initialize it for duty\n     * @dev Should revert if any issues arise which make it unfit for delegation\n     * @param data The encoded bytes data for any initialization\n     */\n  function _becomeImplementation(bytes memory data) virtual external;\n\n  /**\n   * @notice Called by the delegator on a delegate to forfeit its responsibility\n     */\n  function _resignImplementation() virtual external;\n}\n"
    },
    "contracts/test/compound-core/DAIInterestRateModelV3.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./JumpRateModelV2.sol\";\n\n/**\n  * @title Compound's DAIInterestRateModel Contract (version 3)\n  * @author Compound (modified by Dharma Labs)\n  * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper.\n  * Version 3 modifies the interest rate model in Version 2 by increasing the initial \"gap\" or slope of\n  * the model prior to the \"kink\" from 2% to 4%, and enabling updateable parameters.\n  */\ncontract DAIInterestRateModelV3 is JumpRateModelV2 {\n  uint256 private constant BASE = 1e18;\n  uint256 private constant RAY_BASE = 1e27;\n  uint256 private constant RAY_TO_BASE_SCALE = 1e9;\n  uint256 private constant SECONDS_PER_BLOCK = 15;\n\n  /**\n   * @notice The additional margin per block separating the base borrow rate from the roof.\n     */\n  uint public gapPerBlock;\n\n  /**\n   * @notice The assumed (1 - reserve factor) used to calculate the minimum borrow rate (reserve factor = 0.05)\n     */\n  uint public constant assumedOneMinusReserveFactorMantissa = 0.95e18;\n\n  PotLike pot;\n  JugLike jug;\n\n  /**\n   * @notice Construct an interest rate model\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     * @param pot_ The address of the Dai pot (where DSR is earned)\n     * @param jug_ The address of the Dai jug (where SF is kept)\n     * @param owner_ The address of the owner, i.e. the Timelock contract (which has the ability to update parameters directly)\n     */\n  constructor(uint jumpMultiplierPerYear, uint kink_, address pot_, address jug_, address owner_) JumpRateModelV2(0, 0, jumpMultiplierPerYear, kink_, owner_) {\n    gapPerBlock = 4e16 / blocksPerYear;\n    pot = PotLike(pot_);\n    jug = JugLike(jug_);\n    poke();\n  }\n\n  /**\n   * @notice External function to update the parameters of the interest rate model\n     * @param gapPerYear The Additional margin per year separating the base borrow rate from the roof. (scaled by BASE)\n     * @param jumpMultiplierPerYear The jumpMultiplierPerYear after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n  function updateJumpRateModel(uint /*baseRatePerYear*/, uint gapPerYear, uint jumpMultiplierPerYear, uint kink_) override external {\n    require(msg.sender == owner, \"only the owner may call this function.\");\n    gapPerBlock = gapPerYear / blocksPerYear;\n    updateJumpRateModelInternal(0, 0, jumpMultiplierPerYear, kink_);\n    poke();\n  }\n\n  /**\n   * @notice Calculates the current supply interest rate per block including the Dai savings rate\n     * @param cash The total amount of cash the market has\n     * @param borrows The total amount of borrows the market has outstanding\n     * @param reserves The total amnount of reserves the market has\n     * @param reserveFactorMantissa The current reserve factor the market has\n     * @return The supply rate per block (as a percentage, and scaled by BASE)\n     */\n  function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) override(BaseJumpRateModelV2, InterestRateModel) public view returns (uint) {\n    uint protocolRate = super.getSupplyRate(cash, borrows, reserves, reserveFactorMantissa);\n\n    uint underlying = cash + borrows - reserves;\n    if (underlying == 0) {\n      return protocolRate;\n    } else {\n      uint cashRate = cash * dsrPerBlock() / underlying;\n      return cashRate + protocolRate;\n    }\n  }\n\n  /**\n   * @notice Calculates the Dai savings rate per block\n     * @return The Dai savings rate per block (as a percentage, and scaled by BASE)\n     */\n  function dsrPerBlock() public view returns (uint) {\n    return (pot.dsr() - RAY_BASE) // scaled RAY_BASE aka RAY, and includes an extra \"ONE\" before subtraction\n    / RAY_TO_BASE_SCALE // descale to BASE\n    * SECONDS_PER_BLOCK;\n    // seconds per block\n  }\n\n  /**\n   * @notice Resets the baseRate and multiplier per block based on the stability fee and Dai savings rate\n     */\n  function poke() public {\n    (uint duty,) = jug.ilks(\"ETH-A\");\n    uint stabilityFeePerBlock = (duty + jug.base() - RAY_BASE) / RAY_TO_BASE_SCALE * SECONDS_PER_BLOCK;\n\n    // We ensure the minimum borrow rate >= DSR / (1 - reserve factor)\n    baseRatePerBlock = dsrPerBlock() * BASE / assumedOneMinusReserveFactorMantissa;\n\n    // The roof borrow rate is max(base rate, stability fee) + gap, from which we derive the slope\n    if (baseRatePerBlock < stabilityFeePerBlock) {\n      multiplierPerBlock = (stabilityFeePerBlock - baseRatePerBlock + gapPerBlock) * BASE / kink;\n    } else {\n      multiplierPerBlock = gapPerBlock * BASE / kink;\n    }\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n  }\n}\n\n\n/*** Maker Interfaces ***/\n\ninterface PotLike {\n  function chi() external view returns (uint);\n\n  function dsr() external view returns (uint);\n\n  function rho() external view returns (uint);\n\n  function pie(address) external view returns (uint);\n\n  function drip() external returns (uint);\n\n  function join(uint) external;\n\n  function exit(uint) external;\n}\n\ncontract JugLike {\n  // --- Data ---\n  struct Ilk {\n    uint256 duty;\n    uint256 rho;\n  }\n\n  mapping(bytes32 => Ilk) public ilks;\n  uint256 public base;\n}\n"
    },
    "contracts/test/compound-core/EIP20Interface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title ERC 20 Token Standard Interface\n *  https://eips.ethereum.org/EIPS/eip-20\n */\ninterface EIP20Interface {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n  /**\n    * @notice Get the total number of tokens in circulation\n      * @return The supply of tokens\n      */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance The balance\n     */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  /**\n    * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return success Whether or not the transfer succeeded\n      */\n  function transfer(address dst, uint256 amount) external returns (bool success);\n\n  /**\n    * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      * @return success Whether or not the transfer succeeded\n      */\n  function transferFrom(address src, address dst, uint256 amount) external returns (bool success);\n\n  /**\n    * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved (-1 means infinite)\n      * @return success Whether or not the approval succeeded\n      */\n  function approve(address spender, uint256 amount) external returns (bool success);\n\n  /**\n    * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return remaining The number of tokens allowed to be spent (-1 means infinite)\n      */\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/test/compound-core/EIP20NonStandardInterface.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title EIP20NonStandardInterface\n * @dev Version of ERC20 with no return values for `transfer` and `transferFrom`\n *  See https://medium.com/coinmonks/missing-return-value-bug-at-least-130-tokens-affected-d67bf08521ca\n */\ninterface EIP20NonStandardInterface {\n\n  /**\n   * @notice Get the total number of tokens in circulation\n     * @return The supply of tokens\n     */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @notice Gets the balance of the specified address\n     * @param owner The address from which the balance will be retrieved\n     * @return balance The balance\n     */\n  function balanceOf(address owner) external view returns (uint256 balance);\n\n  ///\n  /// !!!!!!!!!!!!!!\n  /// !!! NOTICE !!! `transfer` does not return a value, in violation of the ERC-20 specification\n  /// !!!!!!!!!!!!!!\n  ///\n\n  /**\n    * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n  function transfer(address dst, uint256 amount) external;\n\n  ///\n  /// !!!!!!!!!!!!!!\n  /// !!! NOTICE !!! `transferFrom` does not return a value, in violation of the ERC-20 specification\n  /// !!!!!!!!!!!!!!\n  ///\n\n  /**\n    * @notice Transfer `amount` tokens from `src` to `dst`\n      * @param src The address of the source account\n      * @param dst The address of the destination account\n      * @param amount The number of tokens to transfer\n      */\n  function transferFrom(address src, address dst, uint256 amount) external;\n\n  /**\n    * @notice Approve `spender` to transfer up to `amount` from `src`\n      * @dev This will overwrite the approval amount for `spender`\n      *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n      * @param spender The address of the account which may transfer tokens\n      * @param amount The number of tokens that are approved\n      * @return success Whether or not the approval succeeded\n      */\n  function approve(address spender, uint256 amount) external returns (bool success);\n\n  /**\n    * @notice Get the current allowance from `owner` for `spender`\n      * @param owner The address of the account which owns the tokens to be spent\n      * @param spender The address of the account which may transfer tokens\n      * @return remaining The number of tokens allowed to be spent\n      */\n  function allowance(address owner, address spender) external view returns (uint256 remaining);\n\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n}\n"
    },
    "contracts/test/compound-core/ErrorReporter.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract ComptrollerErrorReporter {\n  enum Error {\n    NO_ERROR,\n    UNAUTHORIZED,\n    COMPTROLLER_MISMATCH,\n    INSUFFICIENT_SHORTFALL,\n    INSUFFICIENT_LIQUIDITY,\n    INVALID_CLOSE_FACTOR,\n    INVALID_COLLATERAL_FACTOR,\n    INVALID_LIQUIDATION_INCENTIVE,\n    MARKET_NOT_ENTERED, // no longer possible\n    MARKET_NOT_LISTED,\n    MARKET_ALREADY_LISTED,\n    MATH_ERROR,\n    NONZERO_BORROW_BALANCE,\n    PRICE_ERROR,\n    REJECTION,\n    SNAPSHOT_ERROR,\n    TOO_MANY_ASSETS,\n    TOO_MUCH_REPAY\n  }\n\n  enum FailureInfo {\n    ACCEPT_ADMIN_PENDING_ADMIN_CHECK,\n    ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK,\n    EXIT_MARKET_BALANCE_OWED,\n    EXIT_MARKET_REJECTION,\n    SET_CLOSE_FACTOR_OWNER_CHECK,\n    SET_CLOSE_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_OWNER_CHECK,\n    SET_COLLATERAL_FACTOR_NO_EXISTS,\n    SET_COLLATERAL_FACTOR_VALIDATION,\n    SET_COLLATERAL_FACTOR_WITHOUT_PRICE,\n    SET_IMPLEMENTATION_OWNER_CHECK,\n    SET_LIQUIDATION_INCENTIVE_OWNER_CHECK,\n    SET_LIQUIDATION_INCENTIVE_VALIDATION,\n    SET_MAX_ASSETS_OWNER_CHECK,\n    SET_PENDING_ADMIN_OWNER_CHECK,\n    SET_PENDING_IMPLEMENTATION_OWNER_CHECK,\n    SET_PRICE_ORACLE_OWNER_CHECK,\n    SUPPORT_MARKET_EXISTS,\n    SUPPORT_MARKET_OWNER_CHECK,\n    SET_PAUSE_GUARDIAN_OWNER_CHECK\n  }\n\n  /**\n    * @dev `error` corresponds to enum Error; `info` corresponds to enum FailureInfo, and `detail` is an arbitrary\n      * contract-specific code that enables us to report opaque error codes from upgradeable contracts.\n      **/\n  event Failure(uint error, uint info, uint detail);\n\n  /**\n    * @dev use this when reporting a known error from the money market or a non-upgradeable collaborator\n      */\n  function fail(Error err, FailureInfo info) internal returns (uint) {\n    emit Failure(uint(err), uint(info), 0);\n\n    return uint(err);\n  }\n\n  /**\n    * @dev use this when reporting an opaque error from an upgradeable collaborator contract\n      */\n  function failOpaque(Error err, FailureInfo info, uint opaqueError) internal returns (uint) {\n    emit Failure(uint(err), uint(info), opaqueError);\n\n    return uint(err);\n  }\n}\n\ncontract TokenErrorReporter {\n  uint public constant NO_ERROR = 0; // support legacy return codes\n\n  error TransferComptrollerRejection(uint256 errorCode);\n  error TransferNotAllowed();\n  error TransferNotEnough();\n  error TransferTooMuch();\n\n  error MintComptrollerRejection(uint256 errorCode);\n  error MintFreshnessCheck();\n\n  error RedeemComptrollerRejection(uint256 errorCode);\n  error RedeemFreshnessCheck();\n  error RedeemTransferOutNotPossible();\n\n  error BorrowComptrollerRejection(uint256 errorCode);\n  error BorrowFreshnessCheck();\n  error BorrowCashNotAvailable();\n\n  error RepayBorrowComptrollerRejection(uint256 errorCode);\n  error RepayBorrowFreshnessCheck();\n\n  error LiquidateComptrollerRejection(uint256 errorCode);\n  error LiquidateFreshnessCheck();\n  error LiquidateCollateralFreshnessCheck();\n  error LiquidateAccrueBorrowInterestFailed(uint256 errorCode);\n  error LiquidateAccrueCollateralInterestFailed(uint256 errorCode);\n  error LiquidateLiquidatorIsBorrower();\n  error LiquidateCloseAmountIsZero();\n  error LiquidateCloseAmountIsUintMax();\n  error LiquidateRepayBorrowFreshFailed(uint256 errorCode);\n\n  error LiquidateSeizeComptrollerRejection(uint256 errorCode);\n  error LiquidateSeizeLiquidatorIsBorrower();\n\n  error AcceptAdminPendingAdminCheck();\n\n  error SetComptrollerOwnerCheck();\n  error SetPendingAdminOwnerCheck();\n\n  error SetReserveFactorAdminCheck();\n  error SetReserveFactorFreshCheck();\n  error SetReserveFactorBoundsCheck();\n\n  error AddReservesFactorFreshCheck(uint256 actualAddAmount);\n\n  error ReduceReservesAdminCheck();\n  error ReduceReservesFreshCheck();\n  error ReduceReservesCashNotAvailable();\n  error ReduceReservesCashValidation();\n\n  error SetInterestRateModelOwnerCheck();\n  error SetInterestRateModelFreshCheck();\n}\n"
    },
    "contracts/test/compound-core/ExponentialNoError.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title Exponential module for storing fixed-precision decimals\n * @author Compound\n * @notice Exp is a struct which stores decimals with a fixed precision of 18 decimal places.\n *         Thus, if we wanted to store the 5.1, mantissa would store 5.1e18. That is:\n *         `Exp({mantissa: 5100000000000000000})`.\n */\ncontract ExponentialNoError {\n  uint constant expScale = 1e18;\n  uint constant doubleScale = 1e36;\n  uint constant halfExpScale = expScale / 2;\n  uint constant mantissaOne = expScale;\n\n  struct Exp {\n    uint mantissa;\n  }\n\n  struct Double {\n    uint mantissa;\n  }\n\n  /**\n   * @dev Truncates the given exp to a whole number value.\n     *      For example, truncate(Exp{mantissa: 15 * expScale}) = 15\n     */\n  function truncate(Exp memory exp) pure internal returns (uint) {\n    // Note: We are not using careful math here as we're performing a division that cannot fail\n    return exp.mantissa / expScale;\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, then truncate to return an unsigned integer.\n     */\n  function mul_ScalarTruncate(Exp memory a, uint scalar) pure internal returns (uint) {\n    Exp memory product = mul_(a, scalar);\n    return truncate(product);\n  }\n\n  /**\n   * @dev Multiply an Exp by a scalar, truncate, then add an to an unsigned integer, returning an unsigned integer.\n     */\n  function mul_ScalarTruncateAddUInt(Exp memory a, uint scalar, uint addend) pure internal returns (uint) {\n    Exp memory product = mul_(a, scalar);\n    return add_(truncate(product), addend);\n  }\n\n  /**\n   * @dev Checks if first Exp is less than second Exp.\n     */\n  function lessThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n    return left.mantissa < right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp <= right Exp.\n     */\n  function lessThanOrEqualExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n    return left.mantissa <= right.mantissa;\n  }\n\n  /**\n   * @dev Checks if left Exp > right Exp.\n     */\n  function greaterThanExp(Exp memory left, Exp memory right) pure internal returns (bool) {\n    return left.mantissa > right.mantissa;\n  }\n\n  /**\n   * @dev returns true if Exp is exactly zero\n     */\n  function isZeroExp(Exp memory value) pure internal returns (bool) {\n    return value.mantissa == 0;\n  }\n\n  function safe224(uint n, string memory errorMessage) pure internal returns (uint224) {\n    require(n < 2 ** 224, errorMessage);\n    return uint224(n);\n  }\n\n  function safe32(uint n, string memory errorMessage) pure internal returns (uint32) {\n    require(n < 2 ** 32, errorMessage);\n    return uint32(n);\n  }\n\n  function add_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n    return Exp({mantissa : add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(Double memory a, Double memory b) pure internal returns (Double memory) {\n    return Double({mantissa : add_(a.mantissa, b.mantissa)});\n  }\n\n  function add_(uint a, uint b) pure internal returns (uint) {\n    return a + b;\n  }\n\n  function sub_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n    return Exp({mantissa : sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(Double memory a, Double memory b) pure internal returns (Double memory) {\n    return Double({mantissa : sub_(a.mantissa, b.mantissa)});\n  }\n\n  function sub_(uint a, uint b) pure internal returns (uint) {\n    return a - b;\n  }\n\n  function mul_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n    return Exp({mantissa : mul_(a.mantissa, b.mantissa) / expScale});\n  }\n\n  function mul_(Exp memory a, uint b) pure internal returns (Exp memory) {\n    return Exp({mantissa : mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint a, Exp memory b) pure internal returns (uint) {\n    return mul_(a, b.mantissa) / expScale;\n  }\n\n  function mul_(Double memory a, Double memory b) pure internal returns (Double memory) {\n    return Double({mantissa : mul_(a.mantissa, b.mantissa) / doubleScale});\n  }\n\n  function mul_(Double memory a, uint b) pure internal returns (Double memory) {\n    return Double({mantissa : mul_(a.mantissa, b)});\n  }\n\n  function mul_(uint a, Double memory b) pure internal returns (uint) {\n    return mul_(a, b.mantissa) / doubleScale;\n  }\n\n  function mul_(uint a, uint b) pure internal returns (uint) {\n    return a * b;\n  }\n\n  function div_(Exp memory a, Exp memory b) pure internal returns (Exp memory) {\n    return Exp({mantissa : div_(mul_(a.mantissa, expScale), b.mantissa)});\n  }\n\n  function div_(Exp memory a, uint b) pure internal returns (Exp memory) {\n    return Exp({mantissa : div_(a.mantissa, b)});\n  }\n\n  function div_(uint a, Exp memory b) pure internal returns (uint) {\n    return div_(mul_(a, expScale), b.mantissa);\n  }\n\n  function div_(Double memory a, Double memory b) pure internal returns (Double memory) {\n    return Double({mantissa : div_(mul_(a.mantissa, doubleScale), b.mantissa)});\n  }\n\n  function div_(Double memory a, uint b) pure internal returns (Double memory) {\n    return Double({mantissa : div_(a.mantissa, b)});\n  }\n\n  function div_(uint a, Double memory b) pure internal returns (uint) {\n    return div_(mul_(a, doubleScale), b.mantissa);\n  }\n\n  function div_(uint a, uint b) pure internal returns (uint) {\n    return a / b;\n  }\n\n  function fraction(uint a, uint b) pure internal returns (Double memory) {\n    return Double({mantissa : div_(mul_(a, doubleScale), b)});\n  }\n}\n"
    },
    "contracts/test/compound-core/Governance/Comp.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\ncontract Comp {\n  /// @notice EIP-20 token name for this token\n  string public constant name = \"Compound\";\n\n  /// @notice EIP-20 token symbol for this token\n  string public constant symbol = \"COMP\";\n\n  /// @notice EIP-20 token decimals for this token\n  uint8 public constant decimals = 18;\n\n  /// @notice Total number of tokens in circulation\n  uint public constant totalSupply = 10000000e18; // 10 million Comp\n\n  /// @notice Allowance amounts on behalf of others\n  mapping(address => mapping(address => uint96)) internal allowances;\n\n  /// @notice Official record of token balances for each account\n  mapping(address => uint96) internal balances;\n\n  /// @notice A record of each accounts delegate\n  mapping(address => address) public delegates;\n\n  /// @notice A checkpoint for marking number of votes from a given block\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint96 votes;\n  }\n\n  /// @notice A record of votes checkpoints for each account, by index\n  mapping(address => mapping(uint32 => Checkpoint)) public checkpoints;\n\n  /// @notice The number of checkpoints for each account\n  mapping(address => uint32) public numCheckpoints;\n\n  /// @notice The EIP-712 typehash for the contract's domain\n  bytes32 public constant DOMAIN_TYPEHASH = keccak256(\"EIP712Domain(string name,uint256 chainId,address verifyingContract)\");\n\n  /// @notice The EIP-712 typehash for the delegation struct used by the contract\n  bytes32 public constant DELEGATION_TYPEHASH = keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n  /// @notice A record of states for signing / validating signatures\n  mapping(address => uint) public nonces;\n\n  /// @notice An event thats emitted when an account changes its delegate\n  event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n  /// @notice An event thats emitted when a delegate account's vote balance changes\n  event DelegateVotesChanged(address indexed delegate, uint previousBalance, uint newBalance);\n\n  /// @notice The standard EIP-20 transfer event\n  event Transfer(address indexed from, address indexed to, uint256 amount);\n\n  /// @notice The standard EIP-20 approval event\n  event Approval(address indexed owner, address indexed spender, uint256 amount);\n\n  /**\n   * @notice Construct a new Comp token\n     * @param account The initial account to grant all the tokens\n     */\n  constructor(address account) {\n    balances[account] = uint96(totalSupply);\n    emit Transfer(address(0), account, totalSupply);\n  }\n\n  /**\n   * @notice Get the number of tokens `spender` is approved to spend on behalf of `account`\n     * @param account The address of the account holding the funds\n     * @param spender The address of the account spending the funds\n     * @return The number of tokens approved\n     */\n  function allowance(address account, address spender) external view returns (uint) {\n    return allowances[account][spender];\n  }\n\n  /**\n   * @notice Approve `spender` to transfer up to `amount` from `src`\n     * @dev This will overwrite the approval amount for `spender`\n     *  and is subject to issues noted [here](https://eips.ethereum.org/EIPS/eip-20#approve)\n     * @param spender The address of the account which may transfer tokens\n     * @param rawAmount The number of tokens that are approved (2^256-1 means infinite)\n     * @return Whether or not the approval succeeded\n     */\n  function approve(address spender, uint rawAmount) external returns (bool) {\n    uint96 amount;\n    if (rawAmount == type(uint).max) {\n      amount = type(uint96).max;\n    } else {\n      amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n    }\n\n    allowances[msg.sender][spender] = amount;\n\n    emit Approval(msg.sender, spender, amount);\n    return true;\n  }\n\n  /**\n   * @notice Get the number of tokens held by the `account`\n     * @param account The address of the account to get the balance of\n     * @return The number of tokens held\n     */\n  function balanceOf(address account) external view returns (uint) {\n    return balances[account];\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `msg.sender` to `dst`\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n  function transfer(address dst, uint rawAmount) external returns (bool) {\n    uint96 amount = safe96(rawAmount, \"Comp::transfer: amount exceeds 96 bits\");\n    _transferTokens(msg.sender, dst, amount);\n    return true;\n  }\n\n  /**\n   * @notice Transfer `amount` tokens from `src` to `dst`\n     * @param src The address of the source account\n     * @param dst The address of the destination account\n     * @param rawAmount The number of tokens to transfer\n     * @return Whether or not the transfer succeeded\n     */\n  function transferFrom(address src, address dst, uint rawAmount) external returns (bool) {\n    address spender = msg.sender;\n    uint96 spenderAllowance = allowances[src][spender];\n    uint96 amount = safe96(rawAmount, \"Comp::approve: amount exceeds 96 bits\");\n\n    if (spender != src && spenderAllowance != type(uint96).max) {\n      uint96 newAllowance = sub96(spenderAllowance, amount, \"Comp::transferFrom: transfer amount exceeds spender allowance\");\n      allowances[src][spender] = newAllowance;\n\n      emit Approval(src, spender, newAllowance);\n    }\n\n    _transferTokens(src, dst, amount);\n    return true;\n  }\n\n  /**\n   * @notice Delegate votes from `msg.sender` to `delegatee`\n     * @param delegatee The address to delegate votes to\n     */\n  function delegate(address delegatee) public {\n    return _delegate(msg.sender, delegatee);\n  }\n\n  /**\n   * @notice Delegates votes from signatory to `delegatee`\n     * @param delegatee The address to delegate votes to\n     * @param nonce The contract state required to match the signature\n     * @param expiry The time at which to expire the signature\n     * @param v The recovery byte of the signature\n     * @param r Half of the ECDSA signature pair\n     * @param s Half of the ECDSA signature pair\n     */\n  function delegateBySig(address delegatee, uint nonce, uint expiry, uint8 v, bytes32 r, bytes32 s) public {\n    bytes32 domainSeparator = keccak256(abi.encode(DOMAIN_TYPEHASH, keccak256(bytes(name)), getChainId(), address(this)));\n    bytes32 structHash = keccak256(abi.encode(DELEGATION_TYPEHASH, delegatee, nonce, expiry));\n    bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    address signatory = ecrecover(digest, v, r, s);\n    require(signatory != address(0), \"Comp::delegateBySig: invalid signature\");\n    require(nonce == nonces[signatory]++, \"Comp::delegateBySig: invalid nonce\");\n    require(block.timestamp <= expiry, \"Comp::delegateBySig: signature expired\");\n    return _delegate(signatory, delegatee);\n  }\n\n  /**\n   * @notice Gets the current votes balance for `account`\n     * @param account The address to get votes balance\n     * @return The number of current votes for `account`\n     */\n  function getCurrentVotes(address account) external view returns (uint96) {\n    uint32 nCheckpoints = numCheckpoints[account];\n    return nCheckpoints > 0 ? checkpoints[account][nCheckpoints - 1].votes : 0;\n  }\n\n  /**\n   * @notice Determine the prior number of votes for an account as of a block number\n     * @dev Block number must be a finalized block or else this function will revert to prevent misinformation.\n     * @param account The address of the account to check\n     * @param blockNumber The block number to get the vote balance at\n     * @return The number of votes the account had as of the given block\n     */\n  function getPriorVotes(address account, uint blockNumber) public view returns (uint96) {\n    require(blockNumber < block.number, \"Comp::getPriorVotes: not yet determined\");\n\n    uint32 nCheckpoints = numCheckpoints[account];\n    if (nCheckpoints == 0) {\n      return 0;\n    }\n\n    // First check most recent balance\n    if (checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber) {\n      return checkpoints[account][nCheckpoints - 1].votes;\n    }\n\n    // Next check implicit zero balance\n    if (checkpoints[account][0].fromBlock > blockNumber) {\n      return 0;\n    }\n\n    uint32 lower = 0;\n    uint32 upper = nCheckpoints - 1;\n    while (upper > lower) {\n      uint32 center = upper - (upper - lower) / 2;\n      // ceil, avoiding overflow\n      Checkpoint memory cp = checkpoints[account][center];\n      if (cp.fromBlock == blockNumber) {\n        return cp.votes;\n      } else if (cp.fromBlock < blockNumber) {\n        lower = center;\n      } else {\n        upper = center - 1;\n      }\n    }\n    return checkpoints[account][lower].votes;\n  }\n\n  function _delegate(address delegator, address delegatee) internal {\n    address currentDelegate = delegates[delegator];\n    uint96 delegatorBalance = balances[delegator];\n    delegates[delegator] = delegatee;\n\n    emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n    _moveDelegates(currentDelegate, delegatee, delegatorBalance);\n  }\n\n  function _transferTokens(address src, address dst, uint96 amount) internal {\n    require(src != address(0), \"Comp::_transferTokens: cannot transfer from the zero address\");\n    require(dst != address(0), \"Comp::_transferTokens: cannot transfer to the zero address\");\n\n    balances[src] = sub96(balances[src], amount, \"Comp::_transferTokens: transfer amount exceeds balance\");\n    balances[dst] = add96(balances[dst], amount, \"Comp::_transferTokens: transfer amount overflows\");\n    emit Transfer(src, dst, amount);\n\n    _moveDelegates(delegates[src], delegates[dst], amount);\n  }\n\n  function _moveDelegates(address srcRep, address dstRep, uint96 amount) internal {\n    if (srcRep != dstRep && amount > 0) {\n      if (srcRep != address(0)) {\n        uint32 srcRepNum = numCheckpoints[srcRep];\n        uint96 srcRepOld = srcRepNum > 0 ? checkpoints[srcRep][srcRepNum - 1].votes : 0;\n        uint96 srcRepNew = sub96(srcRepOld, amount, \"Comp::_moveVotes: vote amount underflows\");\n        _writeCheckpoint(srcRep, srcRepNum, srcRepOld, srcRepNew);\n      }\n\n      if (dstRep != address(0)) {\n        uint32 dstRepNum = numCheckpoints[dstRep];\n        uint96 dstRepOld = dstRepNum > 0 ? checkpoints[dstRep][dstRepNum - 1].votes : 0;\n        uint96 dstRepNew = add96(dstRepOld, amount, \"Comp::_moveVotes: vote amount overflows\");\n        _writeCheckpoint(dstRep, dstRepNum, dstRepOld, dstRepNew);\n      }\n    }\n  }\n\n  function _writeCheckpoint(address delegatee, uint32 nCheckpoints, uint96 oldVotes, uint96 newVotes) internal {\n    uint32 blockNumber = safe32(block.number, \"Comp::_writeCheckpoint: block number exceeds 32 bits\");\n\n    if (nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber) {\n      checkpoints[delegatee][nCheckpoints - 1].votes = newVotes;\n    } else {\n      checkpoints[delegatee][nCheckpoints] = Checkpoint(blockNumber, newVotes);\n      numCheckpoints[delegatee] = nCheckpoints + 1;\n    }\n\n    emit DelegateVotesChanged(delegatee, oldVotes, newVotes);\n  }\n\n  function safe32(uint n, string memory errorMessage) internal pure returns (uint32) {\n    require(n < 2 ** 32, errorMessage);\n    return uint32(n);\n  }\n\n  function safe96(uint n, string memory errorMessage) internal pure returns (uint96) {\n    require(n < 2 ** 96, errorMessage);\n    return uint96(n);\n  }\n\n  function add96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n    uint96 c = a + b;\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub96(uint96 a, uint96 b, string memory errorMessage) internal pure returns (uint96) {\n    require(b <= a, errorMessage);\n    return a - b;\n  }\n\n  function getChainId() internal view returns (uint) {\n    uint256 chainId;\n    assembly {chainId := chainid()}\n    return chainId;\n  }\n}\n"
    },
    "contracts/test/compound-core/InterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n  * @title Compound's InterestRateModel Interface\n  * @author Compound\n  */\nabstract contract InterestRateModel {\n  /// @notice Indicator that this is an InterestRateModel contract (for inspection)\n  bool public constant isInterestRateModel = true;\n\n  /**\n    * @notice Calculates the current borrow interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @return The borrow rate per block (as a percentage, and scaled by 1e18)\n      */\n  function getBorrowRate(uint cash, uint borrows, uint reserves) virtual external view returns (uint);\n\n  /**\n    * @notice Calculates the current supply interest rate per block\n      * @param cash The total amount of cash the market has\n      * @param borrows The total amount of borrows the market has outstanding\n      * @param reserves The total amount of reserves the market has\n      * @param reserveFactorMantissa The current reserve factor the market has\n      * @return The supply rate per block (as a percentage, and scaled by 1e18)\n      */\n  function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) virtual external view returns (uint);\n}\n"
    },
    "contracts/test/compound-core/JumpRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./InterestRateModel.sol\";\n\n/**\n  * @title Compound's JumpRateModel Contract\n  * @author Compound\n  */\ncontract JumpRateModel is InterestRateModel {\n  event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock, uint jumpMultiplierPerBlock, uint kink);\n\n  uint256 private constant BASE = 1e18;\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n  uint public constant blocksPerYear = 2102400;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n  uint public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n  uint public baseRatePerBlock;\n\n  /**\n   * @notice The multiplierPerBlock after hitting a specified utilization point\n     */\n  uint public jumpMultiplierPerBlock;\n\n  /**\n   * @notice The utilization point at which the jump multiplier is applied\n     */\n  uint public kink;\n\n  /**\n   * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     * @param jumpMultiplierPerYear The multiplierPerBlock after hitting a specified utilization point\n     * @param kink_ The utilization point at which the jump multiplier is applied\n     */\n  constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_) {\n    baseRatePerBlock = baseRatePerYear / blocksPerYear;\n    multiplierPerBlock = multiplierPerYear / blocksPerYear;\n    jumpMultiplierPerBlock = jumpMultiplierPerYear / blocksPerYear;\n    kink = kink_;\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, jumpMultiplierPerBlock, kink);\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, BASE]\n     */\n  function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return borrows * BASE / (cash + borrows - reserves);\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\n     */\n  function getBorrowRate(uint cash, uint borrows, uint reserves) override public view returns (uint) {\n    uint util = utilizationRate(cash, borrows, reserves);\n\n    if (util <= kink) {\n      return (util * multiplierPerBlock / BASE) + baseRatePerBlock;\n    } else {\n      uint normalRate = (kink * multiplierPerBlock / BASE) + baseRatePerBlock;\n      uint excessUtil = util - kink;\n      return (excessUtil * jumpMultiplierPerBlock / BASE) + normalRate;\n    }\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by BASE)\n     */\n  function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) override public view returns (uint) {\n    uint oneMinusReserveFactor = BASE - reserveFactorMantissa;\n    uint borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint rateToPool = borrowRate * oneMinusReserveFactor / BASE;\n    return utilizationRate(cash, borrows, reserves) * rateToPool / BASE;\n  }\n}\n"
    },
    "contracts/test/compound-core/JumpRateModelV2.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./BaseJumpRateModelV2.sol\";\nimport \"./InterestRateModel.sol\";\n\n\n/**\n  * @title Compound's JumpRateModel Contract V2 for V2 cTokens\n  * @author Arr00\n  * @notice Supports only for V2 cTokens\n  */\ncontract JumpRateModelV2 is InterestRateModel, BaseJumpRateModelV2 {\n\n  /**\n     * @notice Calculates the current borrow rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by 1e18)\n     */\n  function getBorrowRate(uint cash, uint borrows, uint reserves) override external view returns (uint) {\n    return getBorrowRateInternal(cash, borrows, reserves);\n  }\n\n  constructor(uint baseRatePerYear, uint multiplierPerYear, uint jumpMultiplierPerYear, uint kink_, address owner_)\n\n  BaseJumpRateModelV2(baseRatePerYear, multiplierPerYear, jumpMultiplierPerYear, kink_, owner_) {}\n}\n"
    },
    "contracts/test/compound-core/Maximillion.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CEther.sol\";\n\n/**\n * @title Compound's Maximillion Contract\n * @author Compound\n */\ncontract Maximillion {\n  /**\n   * @notice The default cEther market to repay in\n     */\n  CEther public cEther;\n\n  /**\n   * @notice Construct a Maximillion to repay max in a CEther market\n     */\n  constructor(CEther cEther_) {\n    cEther = cEther_;\n  }\n\n  /**\n   * @notice msg.sender sends Ether to repay an account's borrow in the cEther market\n     * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\n     * @param borrower The address of the borrower account to repay on behalf of\n     */\n  function repayBehalf(address borrower) public payable {\n    repayBehalfExplicit(borrower, cEther);\n  }\n\n  /**\n   * @notice msg.sender sends Ether to repay an account's borrow in a cEther market\n     * @dev The provided Ether is applied towards the borrow balance, any excess is refunded\n     * @param borrower The address of the borrower account to repay on behalf of\n     * @param cEther_ The address of the cEther contract to repay in\n     */\n  function repayBehalfExplicit(address borrower, CEther cEther_) public payable {\n    uint received = msg.value;\n    uint borrows = cEther_.borrowBalanceCurrent(borrower);\n    if (received > borrows) {\n      cEther_.repayBorrowBehalf{value : borrows}(borrower);\n      payable(msg.sender).transfer(received - borrows);\n    } else {\n      cEther_.repayBorrowBehalf{value : received}(borrower);\n    }\n  }\n}\n"
    },
    "contracts/test/compound-core/PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./CToken.sol\";\n\nabstract contract PriceOracle {\n  /// @notice Indicator that this is a PriceOracle contract (for inspection)\n  bool public constant isPriceOracle = true;\n\n  /**\n    * @notice Get the underlying price of a cToken asset\n      * @param cToken The cToken to get the underlying price of\n      * @return The underlying asset price mantissa (scaled by 1e18).\n      *  Zero means the price is unavailable.\n      */\n  function getUnderlyingPrice(CToken cToken) virtual external view returns (uint);\n}\n"
    },
    "contracts/test/compound-core/Reservoir.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n/**\n * @title Reservoir Contract\n * @notice Distributes a token to a different contract at a fixed rate.\n * @dev This contract must be poked via the `drip()` function every so often.\n * @author Compound\n */\ncontract Reservoir {\n\n  /// @notice The block number when the Reservoir started (immutable)\n  uint public dripStart;\n\n  /// @notice Tokens per block that to drip to target (immutable)\n  uint public dripRate;\n\n  /// @notice Reference to token to drip (immutable)\n  EIP20Interface public token;\n\n  /// @notice Target to receive dripped tokens (immutable)\n  address public target;\n\n  /// @notice Amount that has already been dripped\n  uint public dripped;\n\n  /**\n    * @notice Constructs a Reservoir\n    * @param dripRate_ Numer of tokens per block to drip\n    * @param token_ The token to drip\n    * @param target_ The recipient of dripped tokens\n    */\n  constructor(uint dripRate_, EIP20Interface token_, address target_) {\n    dripStart = block.number;\n    dripRate = dripRate_;\n    token = token_;\n    target = target_;\n    dripped = 0;\n  }\n\n  /**\n    * @notice Drips the maximum amount of tokens to match the drip rate since inception\n    * @dev Note: this will only drip up to the amount of tokens available.\n    * @return The amount of tokens dripped in this call\n    */\n  function drip() public returns (uint) {\n    // First, read storage into memory\n    EIP20Interface token_ = token;\n    uint reservoirBalance_ = token_.balanceOf(address(this));\n    // TODO: Verify this is a static call\n    uint dripRate_ = dripRate;\n    uint dripStart_ = dripStart;\n    uint dripped_ = dripped;\n    address target_ = target;\n    uint blockNumber_ = block.number;\n\n    // Next, calculate intermediate values\n    uint dripTotal_ = mul(dripRate_, blockNumber_ - dripStart_, \"dripTotal overflow\");\n    uint deltaDrip_ = sub(dripTotal_, dripped_, \"deltaDrip underflow\");\n    uint toDrip_ = min(reservoirBalance_, deltaDrip_);\n    uint drippedNext_ = add(dripped_, toDrip_, \"tautological\");\n\n    // Finally, write new `dripped` value and transfer tokens to target\n    dripped = drippedNext_;\n    token_.transfer(target_, toDrip_);\n\n    return toDrip_;\n  }\n\n  /* Internal helper functions for safe math */\n\n  function add(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    uint c;\n  unchecked {c = a + b;}\n    require(c >= a, errorMessage);\n    return c;\n  }\n\n  function sub(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    require(b <= a, errorMessage);\n    uint c = a - b;\n    return c;\n  }\n\n  function mul(uint a, uint b, string memory errorMessage) internal pure returns (uint) {\n    if (a == 0) {\n      return 0;\n    }\n    uint c;\n  unchecked {c = a * b;}\n    require(c / a == b, errorMessage);\n    return c;\n  }\n\n  function min(uint a, uint b) internal pure returns (uint) {\n    if (a <= b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n}\n\nimport \"./EIP20Interface.sol\";\n"
    },
    "contracts/test/compound-core/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\n// From https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/math/Math.sol\n// Subject to the MIT license.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c;\n  unchecked {c = a + b;}\n    require(c >= a, \"SafeMath: addition overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the addition of two unsigned integers, reverting with custom message on overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n  function add(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    uint256 c;\n  unchecked {c = a + b;}\n    require(c >= a, errorMessage);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    return sub(a, b, \"SafeMath: subtraction underflow\");\n  }\n\n  /**\n   * @dev Returns the subtraction of two unsigned integers, reverting with custom message on underflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot underflow.\n     */\n  function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b <= a, errorMessage);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c;\n  unchecked {c = a * b;}\n    require(c / a == b, \"SafeMath: multiplication overflow\");\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the multiplication of two unsigned integers, reverting on overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n  function mul(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c;\n  unchecked {c = a * b;}\n    require(c / a == b, errorMessage);\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers.\n     * Reverts on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    return div(a, b, \"SafeMath: division by zero\");\n  }\n\n  /**\n   * @dev Returns the integer division of two unsigned integers.\n     * Reverts with custom message on division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n  function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b > 0, errorMessage);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n    return c;\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    return mod(a, b, \"SafeMath: modulo by zero\");\n  }\n\n  /**\n   * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n  function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n    require(b != 0, errorMessage);\n    return a % b;\n  }\n}\n"
    },
    "contracts/test/compound-core/SimplePriceOracle.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./PriceOracle.sol\";\nimport \"./CErc20.sol\";\n\ncontract SimplePriceOracle is PriceOracle {\n  mapping(address => uint) prices;\n\n  event PricePosted(address asset, uint previousPriceMantissa, uint requestedPriceMantissa, uint newPriceMantissa);\n\n  function _getUnderlyingAddress(CToken cToken) private view returns (address) {\n    address asset;\n    if (compareStrings(cToken.symbol(), \"cETH\")) {\n      asset = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n    } else {\n      asset = address(CErc20(address(cToken)).underlying());\n    }\n    return asset;\n  }\n\n  function getUnderlyingPrice(CToken cToken) public override view returns (uint) {\n    return prices[_getUnderlyingAddress(cToken)];\n  }\n\n  function setUnderlyingPrice(CToken cToken, uint underlyingPriceMantissa) public {\n    address asset = _getUnderlyingAddress(cToken);\n    emit PricePosted(asset, prices[asset], underlyingPriceMantissa, underlyingPriceMantissa);\n    prices[asset] = underlyingPriceMantissa;\n  }\n\n  function setDirectPrice(address asset, uint price) public {\n    emit PricePosted(asset, prices[asset], price, price);\n    prices[asset] = price;\n  }\n\n  // v1 price oracle interface for use as backing of proxy\n  function assetPrices(address asset) external view returns (uint) {\n    return prices[asset];\n  }\n\n  function compareStrings(string memory a, string memory b) internal pure returns (bool) {\n    return (keccak256(abi.encodePacked((a))) == keccak256(abi.encodePacked((b))));\n  }\n}\n"
    },
    "contracts/test/compound-core/Timelock.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./SafeMath.sol\";\n\ncontract Timelock {\n  using SafeMath for uint;\n\n  event NewAdmin(address indexed newAdmin);\n  event NewPendingAdmin(address indexed newPendingAdmin);\n  event NewDelay(uint indexed newDelay);\n  event CancelTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n  event ExecuteTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n  event QueueTransaction(bytes32 indexed txHash, address indexed target, uint value, string signature, bytes data, uint eta);\n\n  uint public constant GRACE_PERIOD = 14 days;\n  uint public constant MINIMUM_DELAY = 2 days;\n  uint public constant MAXIMUM_DELAY = 30 days;\n\n  address public admin;\n  address public pendingAdmin;\n  uint public delay;\n\n  mapping(bytes32 => bool) public queuedTransactions;\n\n\n  constructor(address admin_, uint delay_) {\n    require(delay_ >= MINIMUM_DELAY, \"Timelock::constructor: Delay must exceed minimum delay.\");\n    require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n\n    admin = admin_;\n    delay = delay_;\n  }\n\n  fallback() external /*payable */{}\n\n  function setDelay(uint delay_) public {\n    require(msg.sender == address(this), \"Timelock::setDelay: Call must come from Timelock.\");\n    require(delay_ >= MINIMUM_DELAY, \"Timelock::setDelay: Delay must exceed minimum delay.\");\n    require(delay_ <= MAXIMUM_DELAY, \"Timelock::setDelay: Delay must not exceed maximum delay.\");\n    delay = delay_;\n\n    emit NewDelay(delay);\n  }\n\n  function acceptAdmin() public {\n    require(msg.sender == pendingAdmin, \"Timelock::acceptAdmin: Call must come from pendingAdmin.\");\n    admin = msg.sender;\n    pendingAdmin = address(0);\n\n    emit NewAdmin(admin);\n  }\n\n  function setPendingAdmin(address pendingAdmin_) public {\n    require(msg.sender == address(this), \"Timelock::setPendingAdmin: Call must come from Timelock.\");\n    pendingAdmin = pendingAdmin_;\n\n    emit NewPendingAdmin(pendingAdmin);\n  }\n\n  function queueTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public returns (bytes32) {\n    require(msg.sender == admin, \"Timelock::queueTransaction: Call must come from admin.\");\n    require(eta >= getBlockTimestamp().add(delay), \"Timelock::queueTransaction: Estimated execution block must satisfy delay.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = true;\n\n    emit QueueTransaction(txHash, target, value, signature, data, eta);\n    return txHash;\n  }\n\n  function cancelTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public {\n    require(msg.sender == admin, \"Timelock::cancelTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    queuedTransactions[txHash] = false;\n\n    emit CancelTransaction(txHash, target, value, signature, data, eta);\n  }\n\n  function executeTransaction(address target, uint value, string memory signature, bytes memory data, uint eta) public payable returns (bytes memory) {\n    require(msg.sender == admin, \"Timelock::executeTransaction: Call must come from admin.\");\n\n    bytes32 txHash = keccak256(abi.encode(target, value, signature, data, eta));\n    require(queuedTransactions[txHash], \"Timelock::executeTransaction: Transaction hasn't been queued.\");\n    require(getBlockTimestamp() >= eta, \"Timelock::executeTransaction: Transaction hasn't surpassed time lock.\");\n    require(getBlockTimestamp() <= eta.add(GRACE_PERIOD), \"Timelock::executeTransaction: Transaction is stale.\");\n\n    queuedTransactions[txHash] = false;\n\n    bytes memory callData;\n\n    if (bytes(signature).length == 0) {\n      callData = data;\n    } else {\n      callData = abi.encodePacked(bytes4(keccak256(bytes(signature))), data);\n    }\n\n    // solium-disable-next-line security/no-call-value\n    (bool success, bytes memory returnData) = target.call{value : value}(callData);\n    require(success, \"Timelock::executeTransaction: Transaction execution reverted.\");\n\n    emit ExecuteTransaction(txHash, target, value, signature, data, eta);\n\n    return returnData;\n  }\n\n  function getBlockTimestamp() internal view returns (uint) {\n    // solium-disable-next-line security/no-block-members\n    return block.timestamp;\n  }\n}\n"
    },
    "contracts/test/compound-core/Unitroller.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./ErrorReporter.sol\";\nimport \"./ComptrollerStorage.sol\";\n/**\n * @title ComptrollerCore\n * @dev Storage for the comptroller is at this address, while execution is delegated to the `comptrollerImplementation`.\n * CTokens should reference this contract as their comptroller.\n */\ncontract Unitroller is UnitrollerAdminStorage, ComptrollerErrorReporter {\n\n  /**\n    * @notice Emitted when pendingComptrollerImplementation is changed\n      */\n  event NewPendingImplementation(address oldPendingImplementation, address newPendingImplementation);\n\n  /**\n    * @notice Emitted when pendingComptrollerImplementation is accepted, which means comptroller implementation is updated\n      */\n  event NewImplementation(address oldImplementation, address newImplementation);\n\n  /**\n    * @notice Emitted when pendingAdmin is changed\n      */\n  event NewPendingAdmin(address oldPendingAdmin, address newPendingAdmin);\n\n  /**\n    * @notice Emitted when pendingAdmin is accepted, which means admin is updated\n      */\n  event NewAdmin(address oldAdmin, address newAdmin);\n\n  constructor() {\n    // Set admin to caller\n    admin = msg.sender;\n  }\n\n  /*** Admin Functions ***/\n  function _setPendingImplementation(address newPendingImplementation) public returns (uint) {\n\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_IMPLEMENTATION_OWNER_CHECK);\n    }\n\n    address oldPendingImplementation = pendingComptrollerImplementation;\n\n    pendingComptrollerImplementation = newPendingImplementation;\n\n    emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n  * @notice Accepts new implementation of comptroller. msg.sender must be pendingImplementation\n    * @dev Admin function for new implementation to accept it's role as implementation\n    * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n    */\n  function _acceptImplementation() public returns (uint) {\n    // Check caller is pendingImplementation and pendingImplementation ≠ address(0)\n    if (msg.sender != pendingComptrollerImplementation || pendingComptrollerImplementation == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_PENDING_IMPLEMENTATION_ADDRESS_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldImplementation = comptrollerImplementation;\n    address oldPendingImplementation = pendingComptrollerImplementation;\n\n    comptrollerImplementation = pendingComptrollerImplementation;\n\n    pendingComptrollerImplementation = address(0);\n\n    emit NewImplementation(oldImplementation, comptrollerImplementation);\n    emit NewPendingImplementation(oldPendingImplementation, pendingComptrollerImplementation);\n\n    return uint(Error.NO_ERROR);\n  }\n\n\n  /**\n    * @notice Begins transfer of admin rights. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @dev Admin function to begin change of admin. The newPendingAdmin must call `_acceptAdmin` to finalize the transfer.\n      * @param newPendingAdmin New pending admin.\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _setPendingAdmin(address newPendingAdmin) public returns (uint) {\n    // Check caller = admin\n    if (msg.sender != admin) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.SET_PENDING_ADMIN_OWNER_CHECK);\n    }\n\n    // Save current value, if any, for inclusion in log\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store pendingAdmin with value newPendingAdmin\n    pendingAdmin = newPendingAdmin;\n\n    // Emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin)\n    emit NewPendingAdmin(oldPendingAdmin, newPendingAdmin);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n    * @notice Accepts transfer of admin rights. msg.sender must be pendingAdmin\n      * @dev Admin function for pending admin to accept role and update admin\n      * @return uint 0=success, otherwise a failure (see ErrorReporter.sol for details)\n      */\n  function _acceptAdmin() public returns (uint) {\n    // Check caller is pendingAdmin and pendingAdmin ≠ address(0)\n    if (msg.sender != pendingAdmin || msg.sender == address(0)) {\n      return fail(Error.UNAUTHORIZED, FailureInfo.ACCEPT_ADMIN_PENDING_ADMIN_CHECK);\n    }\n\n    // Save current values for inclusion in log\n    address oldAdmin = admin;\n    address oldPendingAdmin = pendingAdmin;\n\n    // Store admin with value pendingAdmin\n    admin = pendingAdmin;\n\n    // Clear the pending value\n    pendingAdmin = address(0);\n\n    emit NewAdmin(oldAdmin, admin);\n    emit NewPendingAdmin(oldPendingAdmin, pendingAdmin);\n\n    return uint(Error.NO_ERROR);\n  }\n\n  /**\n   * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n  fallback()/* payable*/ external {\n    // delegate all other functions to current implementation\n    (bool success,) = comptrollerImplementation.delegatecall(msg.data);\n\n    assembly {\n      let free_mem_ptr := mload(0x40)\n      returndatacopy(free_mem_ptr, 0, returndatasize())\n\n      switch success\n      case 0 {revert(free_mem_ptr, returndatasize())}\n      default {return (free_mem_ptr, returndatasize())}\n    }\n  }\n}\n"
    },
    "contracts/test/compound-core/WhitePaperInterestRateModel.sol": {
      "content": "// SPDX-License-Identifier: BSD-3-Clause\npragma solidity ^0.8.10;\n\nimport \"./InterestRateModel.sol\";\n\n/**\n  * @title Compound's WhitePaperInterestRateModel Contract\n  * @author Compound\n  * @notice The parameterized model described in section 2.4 of the original Compound Protocol whitepaper\n  */\ncontract WhitePaperInterestRateModel is InterestRateModel {\n  event NewInterestParams(uint baseRatePerBlock, uint multiplierPerBlock);\n\n  uint256 private constant BASE = 1e18;\n\n  /**\n   * @notice The approximate number of blocks per year that is assumed by the interest rate model\n     */\n  uint public constant blocksPerYear = 2102400;\n\n  /**\n   * @notice The multiplier of utilization rate that gives the slope of the interest rate\n     */\n  uint public multiplierPerBlock;\n\n  /**\n   * @notice The base interest rate which is the y-intercept when utilization rate is 0\n     */\n  uint public baseRatePerBlock;\n\n  /**\n   * @notice Construct an interest rate model\n     * @param baseRatePerYear The approximate target base APR, as a mantissa (scaled by BASE)\n     * @param multiplierPerYear The rate of increase in interest rate wrt utilization (scaled by BASE)\n     */\n  constructor(uint baseRatePerYear, uint multiplierPerYear) {\n    baseRatePerBlock = baseRatePerYear / blocksPerYear;\n    multiplierPerBlock = multiplierPerYear / blocksPerYear;\n\n    emit NewInterestParams(baseRatePerBlock, multiplierPerBlock);\n  }\n\n  /**\n   * @notice Calculates the utilization rate of the market: `borrows / (cash + borrows - reserves)`\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market (currently unused)\n     * @return The utilization rate as a mantissa between [0, BASE]\n     */\n  function utilizationRate(uint cash, uint borrows, uint reserves) public pure returns (uint) {\n    // Utilization rate is 0 when there are no borrows\n    if (borrows == 0) {\n      return 0;\n    }\n\n    return borrows * BASE / (cash + borrows - reserves);\n  }\n\n  /**\n   * @notice Calculates the current borrow rate per block, with the error code expected by the market\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @return The borrow rate percentage per block as a mantissa (scaled by BASE)\n     */\n  function getBorrowRate(uint cash, uint borrows, uint reserves) override public view returns (uint) {\n    uint ur = utilizationRate(cash, borrows, reserves);\n    return (ur * multiplierPerBlock / BASE) + baseRatePerBlock;\n  }\n\n  /**\n   * @notice Calculates the current supply rate per block\n     * @param cash The amount of cash in the market\n     * @param borrows The amount of borrows in the market\n     * @param reserves The amount of reserves in the market\n     * @param reserveFactorMantissa The current reserve factor for the market\n     * @return The supply rate percentage per block as a mantissa (scaled by BASE)\n     */\n  function getSupplyRate(uint cash, uint borrows, uint reserves, uint reserveFactorMantissa) override public view returns (uint) {\n    uint oneMinusReserveFactor = BASE - reserveFactorMantissa;\n    uint borrowRate = getBorrowRate(cash, borrows, reserves);\n    uint rateToPool = borrowRate * oneMinusReserveFactor / BASE;\n    return utilizationRate(cash, borrows, reserves) * rateToPool / BASE;\n  }\n}\n"
    },
    "contracts/test/CompPriceOracleImitator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./compound-core/PriceOracle.sol\";\nimport \"./compound-core/CErc20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\n\ncontract CompPriceOracleImitator is PriceOracle {\n  address public usdc;\n  ITetuLiquidator liquidator;\n\n  constructor(address usdc_, address liquidator_) {\n    usdc = usdc_;\n    liquidator = ITetuLiquidator(liquidator_);\n  }\n\n  function _getUnderlyingAddress(CToken cToken) private view returns (address) {\n    return address(CErc20(address(cToken)).underlying());\n  }\n\n  function getUnderlyingPrice(CToken cToken) public override view returns (uint) {\n    address asset = _getUnderlyingAddress(cToken);\n    if (asset == usdc) {\n      return 1e30;\n    }\n    uint tokenInDecimals = IERC20Metadata(asset).decimals();\n    uint lPrice = liquidator.getPrice(asset, usdc, 10 ** tokenInDecimals);\n    return lPrice * 10 ** (12 + 18 - tokenInDecimals);\n  }\n}\n"
    },
    "contracts/test/Converter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n// converter\nimport \"@tetu_io/tetu-converter/contracts/core/BorrowManager.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/ConverterController.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/DebtMonitor.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/Keeper.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/SwapManager.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/TetuConverter.sol\";\nimport \"@tetu_io/tetu-converter/contracts/core/PriceOracle.sol\";\nimport \"@tetu_io/tetu-converter/contracts/tests/keeper/KeeperCaller.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/hundred-finance/HfPoolAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/hundred-finance/HfPlatformAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/aave3/Aave3PlatformAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/aave3/Aave3PoolAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/aave3/Aave3PoolAdapterEMode.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/aaveTwo/AaveTwoPlatformAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/aaveTwo/AaveTwoPoolAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/dforce/DForcePlatformAdapter.sol\";\n//import \"@tetu_io/tetu-converter/contracts/protocols/dforce/DForcePoolAdapter.sol\";\n"
    },
    "contracts/test/DepositorTestBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/DepositorBase.sol\";\n\n\n/// @title Abstract Depositor Test Base contract.\n/// @author bogdoslav\nabstract contract DepositorTestBase is DepositorBase {\n\n  address[] private _claimedRewardTokens;\n  uint[] private _claimedRewardAmounts;\n\n  /// @dev Deposit given amount to the pool.\n  /// @notice Depositor must care about tokens approval by itself.\n  function depositorEnter(uint[] memory amountsDesired_)\n  external returns (uint[] memory amountsConsumed, uint liquidityOut) {\n    return _depositorEnter(amountsDesired_);\n  }\n\n  /// @dev Withdraw given lp amount from the pool.\n  /// @notice if requested liquidityAmount >= invested, then should make full exit\n  function depositorExit(uint liquidityAmount)\n  external returns (uint[] memory amountsOut) {\n    return _depositorExit(liquidityAmount);\n  }\n\n  /// @dev Quotes output for given lp amount from the pool.\n  function depositorQuoteExit(uint liquidityAmount) external returns (uint[] memory amountsOut) {\n    return _depositorQuoteExit(liquidityAmount);\n  }\n\n  /// @dev If pool supports emergency withdraw need to call it for emergencyExit()\n  function depositorEmergencyExit()\n  external returns (uint[] memory amountsOut) {\n    return _depositorEmergencyExit();\n  }\n\n  /// @dev Claim all possible rewards.\n  function depositorClaimRewards()\n  external returns (address[] memory rewardTokens, uint[] memory rewardAmounts) {\n    (rewardTokens, rewardAmounts) = _depositorClaimRewards();\n    _claimedRewardTokens = rewardTokens;\n    _claimedRewardAmounts = rewardAmounts;\n  }\n\n  function claimedRewardTokens()\n  external view returns (address[] memory) {\n    return _claimedRewardTokens;\n  }\n\n  function claimedRewardAmounts()\n  external view returns (uint[] memory) {\n    return _claimedRewardAmounts;\n  }\n\n  /// @dev Returns depositor's pool shares / lp token amount\n  function depositorLiquidity() external view returns (uint) {\n    return _depositorLiquidity();\n\n  }\n\n  /// @dev Returns pool token reserves\n  function depositorPoolReserves() external view returns (uint[] memory reserves) {\n    return _depositorPoolReserves();\n  }\n\n  /// @dev Returns pool token assets\n  function depositorPoolAssets() external view returns (address[] memory assets) {\n    return _depositorPoolAssets();\n  }\n\n  /// @dev Returns pool token weights\n  function depositorPoolWeights() external view returns (uint[] memory weights, uint total) {\n    return _depositorPoolWeights();\n  }\n\n\n}\n"
    },
    "contracts/test/DummyERC4626Strict.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/ERC4626Strict.sol\";\n\n\ncontract DummyERC4626Strict is ERC4626Strict {\n  constructor(IERC20 asset_,\n    string memory _name,\n    string memory _symbol,\n    address _strategy,\n    uint _buffer)  ERC4626Strict(asset_, _name, _symbol, _strategy, _buffer){}\n}\n"
    },
    "contracts/test/DystopiaDepositorTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n//import \"../strategies/DepositorBase.sol\";\n//import \"../strategies/dystopia/DystopiaDepositor.sol\";\n//import \"./DepositorTestBase.sol\";\n//\n///// @title Dystopia Depositor Test contract.\n///// @author bogdoslav\n//contract DystopiaDepositorTest is DepositorTestBase, DystopiaDepositor {\n//  constructor(address router, address tokenA, address tokenB, bool stable, address voter)\n//  initializer {\n//    __DystopiaDepositor_init(router, tokenA, tokenB, stable, voter);\n//  }\n//\n//  function depositorGauge() external view returns (address) {\n//    return _depositorGauge;\n//  }\n//}\n"
    },
    "contracts/test/facades/ConverterStrategyBaseLibFacade.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\n\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"../../strategies/ConverterStrategyBaseLib.sol\";\nimport \"../../strategies/ConverterStrategyBaseLib2.sol\";\n\n/// @notice Provide public access to internal functions of ConverterStrategyBaseLib\ncontract ConverterStrategyBaseLibFacade {\n  function getExpectedWithdrawnAmounts(\n    uint[] memory reserves_,\n    uint liquidityAmount_,\n    uint totalSupply_\n  ) external pure returns (\n    uint[] memory withdrawnAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.getExpectedWithdrawnAmounts(reserves_, liquidityAmount_, totalSupply_);\n  }\n\n  mapping(address => uint) public baseAmounts;\n\n  function setBaseAmounts(address asset, uint amount) external {\n    baseAmounts[asset] = amount;\n  }\n\n  function getLiquidityAmountRatio(\n    uint targetAmount_,\n    address strategy_,\n    address[] memory tokens,\n    uint indexAsset,\n    ITetuConverter converter,\n    uint investedAssets\n  ) external returns (\n    uint liquidityRatioOut,\n    uint[] memory amountsToConvertOut\n  ) {\n    return ConverterStrategyBaseLib.getLiquidityAmountRatio(\n      targetAmount_,\n      baseAmounts,\n      strategy_,\n      tokens,\n      indexAsset,\n      converter,\n      investedAssets,\n      1e18\n    );\n  }\n\n  function getCollaterals(\n    uint amount_,\n    address[] memory tokens_,\n    uint[] memory weights_,\n    uint totalWeight_,\n    uint indexAsset_,\n    IPriceOracle priceOracle\n  ) external view returns (uint[] memory tokenAmountsOut) {\n    return ConverterStrategyBaseLib.getCollaterals(\n      amount_,\n      tokens_,\n      weights_,\n      totalWeight_,\n      indexAsset_,\n      priceOracle,\n      baseAmounts\n    );\n  }\n\n  function openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint thresholdMainAsset_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.openPosition(\n      tetuConverter_,\n      entryData_,\n      collateralAsset_,\n      borrowAsset_,\n      amountIn_,\n      thresholdMainAsset_\n    );\n  }\n\n  function openPositionEntryKind1(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_,\n    uint collateralThreshold_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.openPositionEntryKind1(\n      tetuConverter_,\n      entryData_,\n      collateralAsset_,\n      borrowAsset_,\n      amountIn_,\n      collateralThreshold_\n    );\n  }\n\n  function closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint leftoverOut\n  ) {\n    return ConverterStrategyBaseLib.closePosition(\n      tetuConverter_,\n      collateralAsset,\n      borrowAsset,\n      amountToRepay\n    );\n  }\n\n  function liquidate(\n    ITetuLiquidator liquidator_,\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint slippage,\n    uint rewardLiquidationThresholdForTokenOut\n  ) external returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.liquidate(\n      liquidator_,\n      tokenIn,\n      tokenOut,\n      amountIn,\n      slippage,\n      rewardLiquidationThresholdForTokenOut\n    );\n  }\n\n  function getAssetIndex(address[] memory tokens_, address asset_) external pure returns (uint) {\n    return ConverterStrategyBaseLib.getAssetIndex(tokens_, asset_);\n  }\n\n  function getAvailableBalances(\n    address[] memory tokens_,\n    uint indexAsset\n  ) external view returns (uint[] memory) {\n    return ConverterStrategyBaseLib2.getAvailableBalances(tokens_, indexAsset);\n  }\n\n  function calcInvestedAssets(\n    address[] memory tokens,\n    uint[] memory amountsOut,\n    uint indexAsset,\n    ITetuConverter converter_\n  ) external returns (\n    uint amountOut\n  ) {\n    return ConverterStrategyBaseLib.calcInvestedAssets(\n      tokens,\n      amountsOut,\n      indexAsset,\n      converter_,\n      baseAmounts\n    );\n  }\n\n  function sendPerformanceFee(\n    uint performanceFee_,\n    address performanceReceiver_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_\n  ) external returns (\n    uint[] memory rewardAmounts,\n    uint[] memory performanceAmounts\n  ) {\n    return ConverterStrategyBaseLib2.sendPerformanceFee(\n      performanceFee_,\n      performanceReceiver_,\n      rewardTokens_,\n      rewardAmounts_\n    );\n  }\n\n  function swapToGivenAmountAccess(\n    uint targetAmount_,\n    address[] memory tokens_,\n    uint indexTargetAsset_,\n    address underlying_,\n    uint[] memory withdrawnAmounts_,\n    ITetuConverter converter_,\n    ITetuLiquidator liquidator_,\n    uint liquidationThresholdForTargetAsset_,\n    uint overswap_\n  ) external returns (\n    uint[] memory spentAmounts,\n    uint[] memory withdrawnAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.swapToGivenAmount(\n      targetAmount_,\n      tokens_,\n      indexTargetAsset_,\n      underlying_,\n      withdrawnAmounts_,\n      converter_,\n      liquidator_,\n      liquidationThresholdForTargetAsset_,\n      overswap_,\n      baseAmounts\n    );\n  }\n\n  function _swapToGivenAmountAccess(ConverterStrategyBaseLib.SwapToGivenAmountInputParams memory p) external returns (\n    uint[] memory spentAmounts,\n    uint[] memory receivedAmounts\n  ) {\n    return ConverterStrategyBaseLib._swapToGivenAmount(p);\n  }\n\n  function swapToGetAmountAccess(\n    uint receivedTargetAmount,\n    ConverterStrategyBaseLib.SwapToGivenAmountInputParams memory p,\n    ConverterStrategyBaseLib.CalcInvestedAssetsLocal memory v,\n    uint indexTokenIn\n  ) external returns (\n    uint amountSpent,\n    uint amountReceived\n  ) {\n    return ConverterStrategyBaseLib._swapToGetAmount(receivedTargetAmount, p, v, indexTokenIn);\n  }\n}\n"
    },
    "contracts/test/facades/TokenAmountsLibTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../libs/TokenAmountsLib.sol\";\n\n/// @author bogdoslav\ncontract TokenAmountsLibTest {\n\n  function filterZeroAmounts(\n    address[] memory tokens,\n    uint[] memory amounts\n  ) external pure returns (\n    address[] memory t,\n    uint[] memory a\n  ) {\n    return TokenAmountsLib.filterZeroAmounts(tokens, amounts);\n  }\n\n  function combineArrays(\n    address[] memory tokens0,\n    uint[] memory amounts0,\n    address[] memory tokens1,\n    uint[] memory amounts1,\n    address[] memory tokens2,\n    uint[] memory amounts2\n  ) external pure returns (\n    address[] memory allTokens,\n    uint[] memory allAmounts\n  ) {\n    return TokenAmountsLib.combineArrays(\n      tokens0, amounts0,\n      tokens1, amounts1,\n      tokens2, amounts2\n    );\n  }\n}\n"
    },
    "contracts/test/facades/Uniswap2LibFacade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n//import \"../../integrations/uniswap/IUniswapV2Router02.sol\";\n//import \"../../tools/Uniswap2Lib.sol\";\n//\n///// @notice Provide direct access to Uniswal2Lib functions for unit tests\n//contract Uniswap2LibFacade {\n//  function quoteRemoveLiquidity(\n//    IUniswapV2Router02 router_,\n//    address user_,\n//    address tokenA_,\n//    address tokenB_,\n//    uint liquidity_\n//  ) external view returns(\n//    uint amountAOut,\n//    uint amountBOut\n//  ) {\n//    return Uniswap2Lib.quoteRemoveLiquidity(router_, user_, tokenA_, tokenB_, liquidity_);\n//  }\n//}\n"
    },
    "contracts/test/Liquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-liquidator/contracts/Controller.sol\";\nimport \"@tetu_io/tetu-liquidator/contracts/TetuLiquidator.sol\";\nimport \"@tetu_io/tetu-liquidator/contracts/proxy/ProxyControlled.sol\";\nimport \"@tetu_io/tetu-liquidator/contracts/swappers/Uni3Swapper.sol\";\n"
    },
    "contracts/test/MockConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../strategies/ConverterStrategyBase.sol\";\nimport \"./MockDepositor.sol\";\n\n/// @title Mock Converter Strategy with MockDepositor\n/// @author bogdoslav\ncontract MockConverterStrategy is ConverterStrategyBase, MockDepositor {\n\n  string public constant override NAME = \"mock converter strategy\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address[] memory depositorTokens_,\n    uint[] memory depositorWeights_,\n    uint[] memory depositorReserves_\n  ) external initializer {\n\n    __MockDepositor_init(\n      depositorTokens_,\n      depositorWeights_,\n      depositorReserves_\n    );\n\n    __ConverterStrategyBase_init(\n      controller_,\n      splitter_,\n      converter_\n    );\n  }\n\n\n  //////////////////////////////////////////////////////////////////////\n  ///    Provide direct access to internal functions for tests\n  //////////////////////////////////////////////////////////////////////\n  function _updateBaseAmountsAccess(\n    address[] memory tokens_,\n    uint[] memory receivedAmounts_,\n    uint[] memory spentAmounts_,\n    uint indexAsset_,\n    int amountAsset_\n  ) external {\n    return _updateBaseAmounts(tokens_, receivedAmounts_, spentAmounts_, indexAsset_, amountAsset_);\n  }\n\n  function _convertAfterWithdrawAccess(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.convertAfterWithdraw(\n      converter,\n      ITetuLiquidator(IController(controller()).liquidator()),\n      liquidationThresholds[tokens_[indexAsset_]],\n      tokens_,\n      indexAsset_,\n      amountsToConvert_\n    );\n  }\n\n  function _convertAfterWithdrawAllAccess(\n    address[] memory tokens_,\n    uint indexAsset_\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return _convertAfterWithdrawAll(tokens_, indexAsset_);\n  }\n\n  function closePositionTestAccess(address collateralAsset, address borrowAsset, uint amountToRepay) external returns (\n    uint returnedAssetAmount,\n    uint leftover\n  ) {\n    return ConverterStrategyBaseLib.closePosition(converter, collateralAsset, borrowAsset, amountToRepay);\n  }\n\n  function updateInvestedAssetsTestAccess() external {\n    _updateInvestedAssets();\n  }\n\n  function withdrawUniversalTestAccess(uint amount, bool all, uint investedAssets_) external returns (\n    uint investedAssetsUSD,\n    uint assetPrice\n  ) {\n    return _withdrawUniversal(amount, all, investedAssets_);\n  }\n\n  function _doHardWorkAccess(bool reInvest) external returns (uint earned, uint lost) {\n    return _doHardWork(reInvest);\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// _handleRewards, mocked version + accessor\n  /////////////////////////////////////////////////////////////////////////////////////\n  function _handleRewards() internal override returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\n    if (handleRewardsParams.initialized) {\n      //      console.log(\"_handleRewards.mocked-version is called\");\n      if (handleRewardsParams.assetBalanceChange > 0) {\n        IERC20(asset).transferFrom(\n          handleRewardsParams.providerBalanceChange,\n          address(this),\n          uint(handleRewardsParams.assetBalanceChange)\n        );\n      } else if (handleRewardsParams.assetBalanceChange < 0) {\n        IERC20(asset).transfer(\n          handleRewardsParams.providerBalanceChange,\n          uint(- handleRewardsParams.assetBalanceChange)\n        );\n      }\n      return (handleRewardsParams.earned, handleRewardsParams.lost, _balance(asset));\n    } else {\n      return super._handleRewards();\n    }\n  }\n\n  struct MockedHandleRewardsParams {\n    bool initialized;\n    uint earned;\n    uint lost;\n    int assetBalanceChange;\n    address providerBalanceChange;\n  }\n\n  MockedHandleRewardsParams private handleRewardsParams;\n\n  function setMockedHandleRewardsResults(\n    uint earned,\n    uint lost,\n    int assetBalanceChange,\n    address providerBalanceChange\n  ) external {\n    handleRewardsParams = MockedHandleRewardsParams({\n        initialized: true,\n        earned: earned,\n        lost: lost,\n        assetBalanceChange: assetBalanceChange,\n        providerBalanceChange: providerBalanceChange\n    });\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// _depositToPool mock\n  /////////////////////////////////////////////////////////////////////////////////////\n  struct MockedDepositToPoolParams {\n    bool initialized;\n    int balanceChange;\n    address providerBalanceChange;\n    int totalAssetsDelta;\n  }\n\n  MockedDepositToPoolParams internal depositToPoolParams;\n\n  function _depositToPoolAccess(uint amount_, bool updateTotalAssetsBeforeInvest_) external returns (\n    int totalAssetsDelta\n  ) {\n    return _depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n  }\n\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    int totalAssetsDelta\n  ){\n    if (depositToPoolParams.initialized) {\n      //      console.log(\"_depositToPool.mocked-version is called\");\n      if (depositToPoolParams.balanceChange > 0) {\n        IERC20(asset).transferFrom(\n          depositToPoolParams.providerBalanceChange,\n          address(this),\n          uint(depositToPoolParams.balanceChange)\n        );\n      } else if (depositToPoolParams.balanceChange < 0) {\n        IERC20(asset).transfer(\n          depositToPoolParams.providerBalanceChange,\n          uint(- depositToPoolParams.balanceChange)\n        );\n      }\n      totalAssetsDelta = depositToPoolParams.totalAssetsDelta;\n    } else {\n      totalAssetsDelta = super._depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n    }\n  }\n\n  function setMockedDepositToPool(int balanceChange, address providerBalanceChange, int totalAssetsDelta_) external {\n    depositToPoolParams = MockedDepositToPoolParams({\n    initialized : true,\n    balanceChange : balanceChange,\n    providerBalanceChange : providerBalanceChange,\n    totalAssetsDelta : totalAssetsDelta_\n    });\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// Others\n  /////////////////////////////////////////////////////////////////////////////////////\n\n  function _beforeDepositAccess(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) external returns (\n    uint[] memory tokenAmounts,\n    uint[] memory borrowedAmounts,\n    uint spentCollateral\n  ) {\n    return _beforeDeposit(\n      tetuConverter_,\n      amount_,\n      tokens_,\n      indexAsset_\n    );\n  }\n\n  function setBaseAmountAccess(address token_, uint amount_) external {\n    baseAmounts[token_] = amount_;\n  }\n\n  function _emergencyExitFromPoolAccess() external {\n    _emergencyExitFromPool();\n  }\n\n  function _prepareRewardsListAccess(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_\n  ) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    return ConverterStrategyBaseLib.prepareRewardsList(tetuConverter_, tokens_, rewardTokens_, rewardAmounts_, baseAmounts);\n  }\n\n  function _recycleAccess(address[] memory tokens, uint[] memory amounts) external returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    return _recycle(tokens, amounts);\n  }\n}\n"
    },
    "contracts/test/MockDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/DepositorBase.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/IMockToken.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\n// import \"hardhat/console.sol\";\n\n/// @title Mock contract for base Depositor.\ncontract MockDepositor is DepositorBase, Initializable {\n\n  uint[] private _depositorReserves;\n  uint[] private _depositorWeights;\n\n  address[] private _depositorAssets;\n\n  /// @notice total amount of active LP tokens.\n  uint public totalSupply;\n  uint private depositorLiquidity;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  // @notice tokens must be MockTokens\n  function __MockDepositor_init(\n    address[] memory tokens_,\n    uint[] memory depositorWeights_,\n    uint[] memory depositorReserves_\n  ) internal onlyInitializing {\n    uint tokensLength = tokens_.length;\n    for (uint i = 0; i < tokensLength; ++i) {\n      _depositorAssets.push(tokens_[i]);\n      _depositorWeights.push(depositorWeights_[i]);\n      _depositorReserves.push(depositorReserves_[i]);\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorTotalSupply\n  /////////////////////////////////////////////////////////////////////\n  function setTotalSupply(uint totalSupply_) external {\n    totalSupply = totalSupply_;\n  }\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() override internal view returns (uint) {\n    return totalSupply;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorLiquidity\n  /////////////////////////////////////////////////////////////////////\n\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return depositorLiquidity;\n  }\n\n  function setDepositorLiquidity(uint depositorLiquidity_) external {\n    depositorLiquidity = depositorLiquidity_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Misc\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Returns pool assets\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory) {\n    //    console.log(\"_depositorPoolAssets\");\n    return _depositorAssets;\n  }\n\n  /// @dev Returns pool weights\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    //    console.log(\"_depositorPoolWeights\", _depositorWeights.length);\n    weights = _depositorWeights;\n    uint len = weights.length;\n    totalWeight = 0;\n    for (uint i; i < len; i++) {\n      totalWeight += weights[i];\n    }\n  }\n\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    reserves = _depositorReserves;\n  }\n\n  function setDepositorPoolReserves(uint[] memory depositorReserves_) external {\n    _depositorReserves = depositorReserves_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorEnter\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorEnterParams {\n    uint[] amountsDesired;\n    uint[] amountsConsumed;\n    uint liquidityOut;\n  }\n\n  DepositorEnterParams internal depositorEnterParams;\n\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  ) {\n    require(_depositorAssets.length == amountsDesired_.length);\n\n    uint len = amountsDesired_.length;\n    amountsConsumed = depositorEnterParams.amountsConsumed;\n\n    for (uint i = 0; i < len; ++i) {\n      require(amountsDesired_[i] == depositorEnterParams.amountsDesired[i], \"!depositorEnter\");\n      IMockToken token = IMockToken(_depositorAssets[i]);\n      token.burn(address(this), depositorEnterParams.amountsConsumed[i]);\n    }\n\n    liquidityOut = depositorEnterParams.liquidityOut;\n    depositorLiquidity += liquidityOut;\n  }\n\n  function setDepositorEnter(uint[] memory amountsDesired_, uint[] memory amountsConsumed_, uint liquidityOut_) external {\n    depositorEnterParams.liquidityOut = liquidityOut_;\n    depositorEnterParams.amountsDesired = amountsDesired_;\n    depositorEnterParams.amountsConsumed = amountsConsumed_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorExit\n  /////////////////////////////////////////////////////////////////////\n\n  struct DepositorExitParams {\n    uint liquidityAmount;\n    uint[] amountsOut;\n  }\n\n  DepositorExitParams internal depositorExitParams;\n\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    require(liquidityAmount == depositorExitParams.liquidityAmount, \"!depositorExit\");\n\n    uint len = _depositorAssets.length;\n    amountsOut = depositorExitParams.amountsOut;\n\n    for (uint i = 0; i < len; ++i) {\n      IMockToken token = IMockToken(_depositorAssets[i]);\n      token.mint(address(this), depositorExitParams.amountsOut[i]);\n    }\n\n    // we need to modify depositorLiquidity for tests with _updateInvestedAssets\n    if (depositorLiquidity >= liquidityAmount) {\n      depositorLiquidity -= liquidityAmount;\n    }\n  }\n\n  function setDepositorExit(uint liquidityAmount_, uint[] memory amountsOut_) external {\n    //    console.log(\"MockDepositor.setDepositorExit liquidityAmount\", liquidityAmount_);\n    depositorExitParams.liquidityAmount = liquidityAmount_;\n    depositorExitParams.amountsOut = amountsOut_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorQuoteExit\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorQuoteExitParams {\n    uint liquidityAmount;\n    uint[] amountsOut;\n  }\n  /// @notice keccak256(liquidityAmount + 1) => results\n  mapping(bytes32 => DepositorQuoteExitParams) internal depositorQuoteExitParams;\n\n  /// @dev Quotes output for given lp amount from the pool.\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual view returns (uint[] memory amountsOut) {\n    bytes32 key = keccak256(abi.encodePacked(liquidityAmount + 1));\n    DepositorQuoteExitParams memory p = depositorQuoteExitParams[key];\n    if (p.liquidityAmount == liquidityAmount) {\n      amountsOut = p.amountsOut;\n    } else {\n      //console.log(\"_depositorQuoteExit.missed liquidityAmount\", liquidityAmount);\n      revert(\"MockDepositor.!liquidityAmount\");\n    }\n\n    return amountsOut;\n  }\n\n  function setDepositorQuoteExit(uint liquidityAmount_, uint[] memory amountsOut_) external {\n    //    console.log(\"setDepositorQuoteExit, liquidityAmount_\", liquidityAmount_);\n    bytes32 key = keccak256(abi.encodePacked(liquidityAmount_ + 1));\n\n    DepositorQuoteExitParams memory p = DepositorQuoteExitParams({\n    liquidityAmount : liquidityAmount_,\n    amountsOut : amountsOut_\n    });\n\n    depositorQuoteExitParams[key] = p;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorClaimRewards\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorClaimRewardsParams {\n    address[] rewardTokens;\n    uint[] rewardAmounts;\n  }\n\n  DepositorClaimRewardsParams internal depositorClaimRewardsParams;\n\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts\n  ) {\n    uint len = depositorClaimRewardsParams.rewardTokens.length;\n    rewardTokens = depositorClaimRewardsParams.rewardTokens;\n    rewardAmounts = depositorClaimRewardsParams.rewardAmounts;\n\n    for (uint i = 0; i < len; ++i) {\n      IMockToken token = IMockToken(depositorClaimRewardsParams.rewardTokens[i]);\n      token.mint(address(this), depositorClaimRewardsParams.rewardAmounts[i]);\n    }\n    return (rewardTokens, rewardAmounts);\n  }\n\n  function setDepositorClaimRewards(address[] memory rewardTokens_, uint[] memory rewardAmounts_) external {\n    depositorClaimRewardsParams.rewardTokens = rewardTokens_;\n    depositorClaimRewardsParams.rewardAmounts = rewardAmounts_;\n  }\n}\n"
    },
    "contracts/test/MockForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MockForwarder is IForwarder {\n  address[] private lastRegisterIncomeTokens;\n  uint[] private lastRegisterIncomeAmounts;\n\n  function tokenPerDestinationLength(address destination) external pure returns (uint) {\n    destination;\n    return 0;\n  }\n\n  function tokenPerDestinationAt(address destination, uint i) external pure returns (address) {\n    destination;\n    i;\n\n    return address(0);\n  }\n\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vault,\n    bool isDistribute\n  ) external {\n    console.log(\"registerIncome\", gasleft());\n    lastRegisterIncomeTokens = tokens;\n    lastRegisterIncomeAmounts = amounts;\n    // move all tokens to the balance of the IForwarder\n    for (uint i = 0; i < tokens.length; ++i) {\n      IERC20(tokens[i]).transferFrom(msg.sender, address(this), amounts[i]);\n    }\n    vault;\n    isDistribute;\n    console.log(\"registerIncome.end\", gasleft());\n  }\n\n  function getLastRegisterIncomeResults() external view returns (\n    address[] memory tokens,\n    uint[] memory amounts\n  ) {\n    return (lastRegisterIncomeTokens, lastRegisterIncomeAmounts);\n  }\n\n  function distributeAll(address destination) external pure {\n    destination;\n  }\n\n  function distribute(address token) external pure {\n    token;\n  }\n\n  function setInvestFundRatio(uint value) external pure {\n    value;\n  }\n\n  function setGaugesRatio(uint value) external pure {\n    value;\n  }\n\n  function supportsInterface(bytes4) public pure returns (bool) {\n    return true;\n  }\n}"
    },
    "contracts/test/MockLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\n\ncontract MockLiquidator is ITetuLiquidator {\n\n  uint price = 100_000 * 1e18;\n  string error = \"\";\n  uint routeLength = 1;\n\n  function setPrice(uint value) external {\n    price = value;\n  }\n\n  function setError(string memory value) external {\n    error = value;\n  }\n\n  function setRouteLength(uint value) external {\n    routeLength = value;\n  }\n\n  function getPrice(address, address, uint) external view override returns (uint) {\n    return price;\n  }\n\n  function getPriceForRoute(PoolData[] memory, uint) external view override returns (uint) {\n    return price;\n  }\n\n  function isRouteExist(address, address) external pure override returns (bool) {\n    return true;\n  }\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view override returns (PoolData[] memory route, string memory errorMessage) {\n    if (routeLength == 1) {\n      route = new PoolData[](1);\n      route[0].tokenIn = tokenIn;\n      route[0].tokenOut = tokenOut;\n    } else {\n      route = new PoolData[](0);\n    }\n    return (route, error);\n  }\n\n  function liquidate(\n    address,\n    address tokenOut,\n    uint amount,\n    uint\n  ) external override {\n    IERC20(tokenOut).transfer(msg.sender, amount);\n  }\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint\n  ) external override {\n    IERC20(route[0].tokenIn).transferFrom(msg.sender, address(this), amount);\n    IERC20(route[route.length - 1].tokenOut).transfer(msg.sender, amount);\n  }\n\n  function addLargestPools(PoolData[] memory /*_pools*/, bool /*rewrite*/) external pure {\n    // noop\n  }\n\n  function addBlueChipsPools(PoolData[] memory /*_pools*/, bool /*rewrite*/) external pure {\n    // noop\n  }\n\n}\n"
    },
    "contracts/test/MockTetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\";\nimport \"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"hardhat/console.sol\";\n\n/// @notice Mock of ITetuConverter, each function saves input params and has customizable output value\n///         Some functions can be not implemented\n/// @dev We assume, that in each test only single function is called, so we can setup behavior before the call\n///      and check results after the call on the side of the script\ncontract MockTetuConverter is ITetuConverter {\n  //////////////////////////////////////////////////////////\n  ///  Controller\n  //////////////////////////////////////////////////////////\n  address public _controller;\n\n  function controller() external view returns (IConverterController) {\n    return IConverterController(_controller);\n  }\n\n  function setController(address controller_) external {\n    _controller = controller_;\n  }\n\n\n  //////////////////////////////////////////////////////////\n  ///  findBorrowStrategy\n  //////////////////////////////////////////////////////////\n  struct FindBorrowStrategyOutputParams {\n    bytes entryData;\n    address[] converters;\n    uint[] collateralAmountsOut;\n    uint[] amountsToBorrowOut;\n    int[] aprs18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n    uint periodInBlocks;\n  }\n  /// @notice keccak256(entryData, sourceToken, targetToken) => results\n  mapping(bytes32 => FindBorrowStrategyOutputParams) public findBorrowStrategyOutputParams;\n\n  function findBorrowStrategies(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountsToBorrowOut,\n    int[] memory aprs18\n  ) {\n    periodInBlocks_;\n    console.log(\"MockTetuConverter.findBorrowStrategies token,amountIn\", sourceToken_, amountIn_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindBorrowStrategyOutputParams memory p = findBorrowStrategyOutputParams[key];\n    console.log(\"MockTetuConverter.p.sourceToken\", p.sourceToken);\n    if (sourceToken_ == p.sourceToken) {\n      return (\n      p.converters,\n      p.collateralAmountsOut,\n      p.amountsToBorrowOut,\n      p.aprs18\n      );\n    } else {\n      console.log(\"findBorrowStrategy.missed\", sourceToken_, amountIn_, targetToken_);\n      return (converters, collateralAmountsOut, amountsToBorrowOut, aprs18);\n    }\n  }\n\n  function setFindBorrowStrategyOutputParams(\n    bytes memory entryData_,\n    address[] memory converters_,\n    uint[] memory collateralAmountsOut_,\n    uint[] memory amountToBorrowsOut_,\n    int[] memory aprs18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external {\n    console.log(\"setFindBorrowStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    findBorrowStrategyOutputParams[key] = FindBorrowStrategyOutputParams({\n    entryData : entryData_,\n    converters : converters_,\n    collateralAmountsOut : collateralAmountsOut_,\n    amountsToBorrowOut : amountToBorrowsOut_,\n    aprs18 : aprs18_,\n    sourceAmount : sourceAmount_,\n    sourceToken : sourceToken_,\n    targetToken : targetToken_,\n    periodInBlocks : periodInBlocks_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  findSwapStrategy\n  //////////////////////////////////////////////////////////\n  struct FindSwapStrategyOutputParams {\n    bytes entryData;\n    address converter;\n    uint sourceAmountOut;\n    uint targetAmountOut;\n    int apr18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n  }\n  /// @notice keccak256(entryData_, sourceToken, targetToken) => results\n  mapping(bytes32 => FindSwapStrategyOutputParams) public findSwapStrategyOutputParams;\n\n  function findSwapStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external view returns (\n    address converter,\n    uint sourceAmountOut,\n    uint targetAmountOut,\n    int apr18\n  ) {\n    console.log(\"MockTetuConverter.findSwapStrategy token,amount\", sourceToken_, sourceAmount_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindSwapStrategyOutputParams memory p = findSwapStrategyOutputParams[key];\n    if (sourceToken_ == p.sourceToken) {\n      return (p.converter, p.sourceAmountOut, p.targetAmountOut, p.apr18);\n    } else {\n      console.log(\"findSwapStrategy.missed\", sourceToken_, sourceAmount_, targetToken_);\n      return (converter, sourceAmountOut, targetAmountOut, apr18);\n    }\n  }\n\n  function setFindSwapStrategyOutputParams(\n    bytes memory entryData_,\n    address converter_,\n    uint sourceAmountOut_,\n    uint targetAmountOut_,\n    int apr18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external {\n    console.log(\"setFindSwapStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(sourceToken_, targetToken_));\n    findSwapStrategyOutputParams[key] = FindSwapStrategyOutputParams({\n    entryData : entryData_,\n    converter : converter_,\n    sourceAmountOut : sourceAmountOut_,\n    targetAmountOut : targetAmountOut_,\n    apr18 : apr18_,\n    sourceToken : sourceToken_,\n    sourceAmount : sourceAmount_,\n    targetToken : targetToken_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  findConversionStrategy\n  //////////////////////////////////////////////////////////\n  struct FindConversionStrategyOutputParams {\n    bytes entryData;\n    address converter;\n    uint amountToBorrowOut;\n    uint collateralAmountOut;\n    int apr18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n    uint periodInBlocks;\n  }\n  /// @notice keccak256(entryData, sourceToken, targetToken) => results\n  mapping(bytes32 => FindConversionStrategyOutputParams) public findConversionStrategyOutputParams;\n\n  function findConversionStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address converter,\n    uint collateralAmountOut,\n    uint amountToBorrowOut,\n    int apr18\n  ) {\n    periodInBlocks_;\n    console.log(\"MockTetuConverter.findConversionStrategy token,amount\", sourceToken_, sourceAmount_);\n\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindConversionStrategyOutputParams memory p = findConversionStrategyOutputParams[key];\n    if (sourceToken_ == p.sourceToken) {\n      return (p.converter, p.collateralAmountOut, p.amountToBorrowOut, p.apr18);\n    } else {\n      console.log(\"findConversionStrategy.missed\", sourceToken_, sourceAmount_, targetToken_);\n      return (converter, collateralAmountOut, amountToBorrowOut, apr18);\n    }\n  }\n\n  function setFindConversionStrategyOutputParams(\n    bytes memory entryData_,\n    address converter_,\n    uint collateralAmountOut_,\n    uint amountToBorrowOut_,\n    int apr18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external {\n    console.log(\"setFindConversionStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    findConversionStrategyOutputParams[key] = FindConversionStrategyOutputParams({\n    entryData : entryData_,\n    converter : converter_,\n    collateralAmountOut : collateralAmountOut_,\n    amountToBorrowOut : amountToBorrowOut_,\n    apr18 : apr18_,\n    sourceAmount : sourceAmount_,\n    sourceToken : sourceToken_,\n    targetToken : targetToken_,\n    periodInBlocks : periodInBlocks_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  borrow\n  //////////////////////////////////////////////////////////\n  struct BorrowParams {\n    uint borrowedAmountOut;\n\n    address converter;\n    address collateralAsset;\n    uint collateralAmount;\n    address borrowAsset;\n    uint amountToBorrow;\n    address receiver;\n  }\n  /// @notice keccak256(converter_, collateralAsset_, collateralAmount_, borrowAsset_) => results\n  mapping(bytes32 => BorrowParams) public borrowParams;\n\n  function borrow(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_\n  ) external returns (\n    uint borrowedAmountOut\n  ) {\n    console.log(\"MockTetuConverter.borrow token,amount\", collateralAsset_, collateralAmount_);\n    bytes32 key = keccak256(abi.encodePacked(converter_, collateralAsset_, collateralAmount_, borrowAsset_));\n    BorrowParams memory p = borrowParams[key];\n    if (converter_ == p.converter\n    && collateralAsset_ == p.collateralAsset\n    && collateralAmount_ == p.collateralAmount\n      && borrowAsset_ == p.borrowAsset\n    ) {\n      IERC20Metadata(collateralAsset_).transferFrom(msg.sender, address(this), collateralAmount_);\n\n      uint balance = IERC20Metadata(borrowAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverter.borrow.balance, amountToBorrow_\", balance, amountToBorrow_);\n      require(balance >= amountToBorrow_, \"MockTetuConverter.borrow.balance\");\n      IERC20Metadata(borrowAsset_).transfer(receiver_, amountToBorrow_);\n\n      return p.borrowedAmountOut;\n    } else {\n      console.log(\"MockTetuConverter.borrow.missed.collateralAsset_\", collateralAsset_);\n      console.log(\"MockTetuConverter.borrow.missed.collateralAmount_\", collateralAmount_);\n      console.log(\"MockTetuConverter.borrow.missed.borrowAsset_\", borrowAsset_);\n      console.log(\"MockTetuConverter.borrow.missed.amountToBorrow_\", amountToBorrow_);\n      return 0;\n    }\n  }\n\n  function setBorrowParams(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_,\n    uint borrowedAmountOut_\n  ) external {\n    console.log(\"setBorrowParams\", collateralAsset_, collateralAmount_, borrowAsset_);\n    bytes32 key = keccak256(abi.encodePacked(converter_, collateralAsset_, collateralAmount_, borrowAsset_));\n    borrowParams[key] = BorrowParams({\n    converter : converter_,\n    collateralAsset : collateralAsset_,\n    collateralAmount : collateralAmount_,\n    borrowAsset : borrowAsset_,\n    amountToBorrow : amountToBorrow_,\n    receiver : receiver_,\n    borrowedAmountOut : borrowedAmountOut_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  repay\n  //////////////////////////////////////////////////////////\n  struct RepayParams {\n    address collateralAsset;\n    address borrowAsset;\n    uint amountToRepay;\n    address receiver;\n    uint collateralAmountOut;\n    uint returnedBorrowAmountOut;\n    uint swappedLeftoverCollateralOut;\n    uint swappedLeftoverBorrowOut;\n  }\n  /// @notice keccak256(collateralAsset_, borrowAsset_, amountToRepay_) => results\n  mapping(bytes32 => RepayParams) public repayParams;\n\n  function repay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_\n  ) external returns (\n    uint collateralAmountOut,\n    uint returnedBorrowAmountOut,\n    uint swappedLeftoverCollateralOut,\n    uint swappedLeftoverBorrowOut\n  ) {\n    console.log(\"MockTetuConverter.repay collateral,borrow,amount\", collateralAsset_, borrowAsset_, amountToRepay_);\n\n    require(IERC20Metadata(borrowAsset_).balanceOf(address(this)) == amountToRepay_, \"MockTetuConverter.repay.amountToRepay_\");\n\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    RepayParams memory p = repayParams[key];\n    if (collateralAsset_ == p.collateralAsset\n    && borrowAsset_ == p.borrowAsset\n      && amountToRepay_ == p.amountToRepay\n    ) {\n      // transfer collateral back to the strategy\n      uint balanceCollateral = IERC20Metadata(collateralAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverter.repay balanceCollateral, collateralAmountOut\", balanceCollateral, p.collateralAmountOut);\n      require(\n        balanceCollateral >= p.collateralAmountOut,\n        \"MockTetuConverter.repay.collateralAmountOut\"\n      );\n      IERC20Metadata(collateralAsset_).transfer(receiver_, p.collateralAmountOut);\n\n      // needToRepay was bigger than amountRepaid\n      // we need to return the leftover back to the strategy\n      uint balanceBorrow = IERC20Metadata(borrowAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverter.repay balanceBorrow, returnedBorrowAmountOut\", balanceBorrow, p.returnedBorrowAmountOut);\n      if (p.returnedBorrowAmountOut != 0) {\n        require(\n          balanceBorrow >= p.returnedBorrowAmountOut,\n          \"MockTetuConverter.repay.returnedBorrowAmountOut\"\n        );\n        IERC20Metadata(borrowAsset_).transfer(receiver_, p.returnedBorrowAmountOut);\n      }\n\n      return (\n      p.collateralAmountOut,\n      p.returnedBorrowAmountOut,\n      p.swappedLeftoverCollateralOut,\n      p.swappedLeftoverBorrowOut\n      );\n    } else {\n      console.log(\"MockTetuConverter.repay.missed collateral,borrow,amountToRepay\", collateralAsset_, borrowAsset_, amountToRepay_);\n      return (collateralAmountOut, returnedBorrowAmountOut, swappedLeftoverCollateralOut, swappedLeftoverBorrowOut);\n    }\n  }\n\n  function setRepay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_,\n    uint collateralAmountOut_,\n    uint returnedBorrowAmountOut_,\n    uint swappedLeftoverCollateralOut_,\n    uint swappedLeftoverBorrowOut_\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    repayParams[key] = RepayParams({\n    collateralAsset : collateralAsset_,\n    borrowAsset : borrowAsset_,\n    amountToRepay : amountToRepay_,\n    receiver : receiver_,\n    collateralAmountOut : collateralAmountOut_,\n    returnedBorrowAmountOut : returnedBorrowAmountOut_,\n    swappedLeftoverCollateralOut : swappedLeftoverCollateralOut_,\n    swappedLeftoverBorrowOut : swappedLeftoverBorrowOut_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  quoteRepay\n  //////////////////////////////////////////////////////////\n  struct QuoteRepayParams {\n    address user;\n    address collateralAsset;\n    address borrowAsset;\n    uint amountToRepay;\n    uint collateralAmountOut;\n  }\n  /// @notice keccak256(collateralAsset_, borrowAsset_, amountToRepay_) => results\n  mapping(bytes32 => QuoteRepayParams) public quoteRepayParams;\n\n  function quoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_\n  ) external view returns (\n    uint collateralAmountOut\n  ) {\n    user_;\n    // hide warning\n    console.log(\"MockTetuConverter.quoteRepay collateral,borrow,amount\", collateralAsset_, borrowAsset_, amountToRepay_);\n\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    QuoteRepayParams memory p = quoteRepayParams[key];\n    if (p.collateralAsset == collateralAsset_) {\n      return p.collateralAmountOut;\n    } else {\n      console.log(\"MockTetuConverter.quoteRepay.missed amountToRepay_,collateralAsset_,borrowAsset_\", amountToRepay_, collateralAsset_, borrowAsset_);\n      return 0;\n    }\n  }\n\n  function setQuoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    uint collateralAmountOut\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    quoteRepayParams[key] = QuoteRepayParams({\n    user : user_,\n    collateralAsset : collateralAsset_,\n    borrowAsset : borrowAsset_,\n    amountToRepay : amountToRepay_,\n    collateralAmountOut : collateralAmountOut\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  getDebtAmountCurrent\n  //////////////////////////////////////////////////////////\n  struct GetDebtAmountParams {\n    address user;\n    address collateralAsset;\n    address borrowAsset;\n    uint totalDebtAmountOut;\n    uint totalCollateralAmountOut;\n  }\n\n  /// @notice keccak256(user_, collateralAsset_, borrowAsset_) => results\n  mapping(bytes32 => GetDebtAmountParams) public getDebtAmountCurrentParams;\n\n  function getDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) {\n    console.log(\"MockTetuConverter.getDebtAmountCurrent user,collateral,borrow\", user_, collateralAsset_, borrowAsset_);\n\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_));\n    GetDebtAmountParams memory p = getDebtAmountCurrentParams[key];\n    if (\n      p.user == user_\n      && p.collateralAsset == collateralAsset_\n      && p.borrowAsset == borrowAsset_\n    ) {\n      console.log(\"MockTetuConverter.getDebtAmountCurrent totalDebtAmountOut,totalCollateralAmountOut\",\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut\n      );\n      return (\n      p.totalDebtAmountOut,\n      p.totalCollateralAmountOut\n      );\n    } else {\n      console.log(\"MockTetuConverter.getDebtAmountCurrent.missed user,collateral,borrow\", user_, collateralAsset_, borrowAsset_);\n      return (0, 0);\n    }\n  }\n\n  function setGetDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_));\n    getDebtAmountCurrentParams[key] = GetDebtAmountParams({\n    user : user_,\n    collateralAsset : collateralAsset_,\n    borrowAsset : borrowAsset_,\n    totalCollateralAmountOut : totalCollateralAmountOut,\n    totalDebtAmountOut : totalDebtAmountOut\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  getDebtAmountStored\n  //////////////////////////////////////////////////////////\n  GetDebtAmountParams public getDebtAmountStoredParams;\n\n  function getDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) {\n    console.log(\"MockTetuConverter.getDebtAmountStored user,collateral,borrow\", user_, collateralAsset_, borrowAsset_);\n\n    if (\n      getDebtAmountStoredParams.user == user_\n      && getDebtAmountStoredParams.collateralAsset == collateralAsset_\n      && getDebtAmountStoredParams.borrowAsset == borrowAsset_\n    ) {\n      return (\n      getDebtAmountStoredParams.totalDebtAmountOut,\n      getDebtAmountStoredParams.totalCollateralAmountOut\n      );\n    } else {\n      return (0, 0);\n    }\n  }\n\n  function setGetDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) external {\n    getDebtAmountStoredParams.user = user_;\n    getDebtAmountStoredParams.collateralAsset = collateralAsset_;\n    getDebtAmountStoredParams.borrowAsset = borrowAsset_;\n    getDebtAmountStoredParams.totalCollateralAmountOut = totalCollateralAmountOut;\n    getDebtAmountStoredParams.totalDebtAmountOut = totalDebtAmountOut;\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  estimateRepay\n  //////////////////////////////////////////////////////////\n  function estimateRepay(\n    address user_,\n    address collateralAsset_,\n    uint collateralAmountRequired_,\n    address borrowAsset_\n  ) external pure returns (\n    uint borrowAssetAmount,\n    uint unobtainableCollateralAssetAmount\n  ) {\n    user_;\n    collateralAsset_;\n    collateralAmountRequired_;\n    borrowAsset_;\n    borrowAssetAmount;\n    unobtainableCollateralAssetAmount;\n    revert (\"estimateRepay is not implemented\");\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  claimRewards\n  //////////////////////////////////////////////////////////\n  struct ClaimRewardsParams {\n    address[] rewardTokensOut;\n    uint[] amountsOut;\n  }\n\n  ClaimRewardsParams private claimRewardsParams;\n\n  function claimRewards(address receiver_) external returns (\n    address[] memory rewardTokensOut,\n    uint[] memory amountsOut\n  ) {\n    for (uint i = 0; i < claimRewardsParams.rewardTokensOut.length; ++i) {\n      uint balance = IERC20Metadata(claimRewardsParams.rewardTokensOut[i]).balanceOf(address(this));\n      console.log(\"claimRewards asset, balance, amountOut\", claimRewardsParams.rewardTokensOut[i], balance, claimRewardsParams.amountsOut[i]);\n      IERC20Metadata(claimRewardsParams.rewardTokensOut[i]).transfer(receiver_, claimRewardsParams.amountsOut[i]);\n    }\n    return (claimRewardsParams.rewardTokensOut, claimRewardsParams.amountsOut);\n  }\n\n  function setClaimRewards(address[] memory rewardTokensOut, uint[] memory amountsOut) external {\n    claimRewardsParams = ClaimRewardsParams({\n    rewardTokensOut : rewardTokensOut,\n    amountsOut : amountsOut\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  Safe liquidation\n  //////////////////////////////////////////////////////////\n  function safeLiquidate(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    address receiver_,\n    uint priceImpactToleranceSource_,\n    uint priceImpactToleranceTarget_\n  ) external pure returns (\n    uint amountOut\n  ) {\n    assetIn_;\n    amountIn_;\n    assetOut_;\n    receiver_;\n    priceImpactToleranceSource_;\n    priceImpactToleranceTarget_;\n    amountOut;\n    revert(\"safeLiquidate is not implemented\");\n  }\n\n  struct IsConversionValidParams {\n    address assetIn;\n    uint amountIn;\n    address assetOut;\n    uint amountOut;\n    bool result;\n  }\n  /// @notice keccak256(assetIn_, amountIn_, assetOut_, amountOut_) => results\n  mapping(bytes32 => IsConversionValidParams) public isConversionValidParams;\n\n  function isConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    uint priceImpactTolerance_\n  ) external view returns (bool) {\n    bytes32 key = keccak256(abi.encodePacked(assetIn_, amountIn_, assetOut_, amountOut_));\n    priceImpactTolerance_;\n    IsConversionValidParams memory p = isConversionValidParams[key];\n    if (p.assetIn == assetIn_) {\n      return p.result;\n    } else {\n      console.log(\"isConversionValid assetIn\", assetIn_, amountIn_);\n      console.log(\"isConversionValid assetOut\", assetOut_, amountOut_);\n      revert(\"isConversionValid is missed\");\n    }\n  }\n\n  function setIsConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    bool result_\n  ) external {\n    console.log(\"setIsConversionValid assetIn\", assetIn_, amountIn_);\n    console.log(\"setIsConversionValid assetOut\", assetOut_, amountOut_);\n    bytes32 key = keccak256(abi.encodePacked(assetIn_, amountIn_, assetOut_, amountOut_));\n    isConversionValidParams[key] = IsConversionValidParams({\n    assetIn : assetIn_,\n    amountIn : amountIn_,\n    assetOut : assetOut_,\n    amountOut : amountOut_,\n    result : result_\n    });\n  }\n\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external pure returns (\n    uint collateralAmountOut,\n    uint repaidAmountOut\n  ) {\n    poolAdapter_;\n    closePosition;\n    return (collateralAmountOut, repaidAmountOut);\n  }\n}\n"
    },
    "contracts/test/MockTetuConverterController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ncontract MockTetuConverterController {\n  address public priceOracle;\n  constructor(address priceOracle_) {\n    priceOracle = priceOracle_;\n  }\n}\n"
    },
    "contracts/test/MockTetuLiquidatorSingleCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/// @notice Mock of ITetuLiquidator, each function saves input params and has customizable output value\n///         Some functions can be not implemented\n/// @dev We assume, that in each test only single function is called, so we can setup behavior before the call\n///      and check results after the call on the side of the script\ncontract MockTetuLiquidatorSingleCall is ITetuLiquidator {\n\n\n  ///////////////////////////////////////////////////\n  ///               build route\n  ///////////////////////////////////////////////////\n  struct BuildRouteParams {\n    address tokenIn;\n    address tokenOut;\n    address pool;\n    address swapper;\n    string errorMessage;\n  }\n  /// @notice keccak256(tokenIn, tokenOut) => results\n  mapping(bytes32 => BuildRouteParams) public buildRouteParams;\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view override returns (\n    PoolData[] memory route,\n    string memory errorMessage\n  ) {\n    console.log(\"MockTetuLiquidatorSingleCall.buildRoute\", tokenIn, tokenOut);\n    bytes32 key = keccak256(abi.encodePacked(tokenIn, tokenOut));\n    BuildRouteParams memory p = buildRouteParams[key];\n\n    if (bytes(p.errorMessage).length != 0) {\n      console.log(\"MockTetuLiquidatorSingleCall.buildRoute.error\");\n      return (route, p.errorMessage);\n    } else {\n      if (tokenIn == p.tokenIn && tokenOut == p.tokenOut) {\n        route = new PoolData[](1);\n        route[0].tokenIn = p.tokenIn;\n        route[0].tokenOut = p.tokenOut;\n        route[0].pool = p.pool;\n        route[0].swapper = p.swapper;\n        return (route, errorMessage);\n      } else {\n        console.log(\"MockTetuLiquidatorSingleCall.buildRoute.error.not.found\", tokenIn, tokenOut);\n        return (route, \"route not found\");\n      }\n    }\n  }\n\n  function setBuildRoute(\n    address tokenIn,\n    address tokenOut,\n    address pool,\n    address swapper,\n    string memory errorMessage\n  ) external {\n    console.log(\"setBuildRoute\", tokenIn, tokenOut);\n    bytes32 key = keccak256(abi.encodePacked(tokenIn, tokenOut));\n    buildRouteParams[key] = BuildRouteParams({\n    errorMessage : errorMessage,\n    tokenIn : tokenIn,\n    tokenOut : tokenOut,\n    pool : pool,\n    swapper : swapper\n    });\n  }\n\n  ///////////////////////////////////////////////////\n  ///               Get price for route\n  ///////////////////////////////////////////////////\n  struct GetPriceForRouteParams {\n    address tokenIn;\n    address tokenOut;\n    address pool;\n    address swapper;\n    uint amount;\n    uint priceOut;\n  }\n  /// @notice keccak256(tokenIn, tokenOut, pool, swapper, amount) => results\n  mapping(bytes32 => GetPriceForRouteParams) public getPriceForRouteParams;\n\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view override returns (uint) {\n    //console.log(\"MockTetuLiquidatorSingleCall.getPriceForRoute amount route.length\", amount, route.length);\n    //console.log(\"MockTetuLiquidatorSingleCall.getPriceForRoute tokenIn, tokenOut\", route[0].tokenIn, route[0].tokenOut);\n    //console.log(\"MockTetuLiquidatorSingleCall.getPriceForRoute pool, swapper\", route[0].pool, route[0].swapper);\n\n    bytes32 key = keccak256(abi.encodePacked(route[0].tokenIn, route[0].tokenOut, route[0].pool, route[0].swapper, amount));\n    GetPriceForRouteParams memory p = getPriceForRouteParams[key];\n\n    if (route.length == 1 && route[0].tokenOut == p.tokenOut) {\n      //console.log(\"MockTetuLiquidatorSingleCall.getPriceForRoute.data\");\n      return p.priceOut;\n    } else {\n      console.log(\"MockTetuLiquidatorSingleCall.getPriceForRoute.missed amount\", amount);\n      return 0;\n    }\n  }\n\n  function setGetPriceForRoute(\n    address tokenIn,\n    address tokenOut,\n    address pool,\n    address swapper,\n    uint amount,\n    uint priceOut\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(tokenIn, tokenOut, pool, swapper, amount));\n    getPriceForRouteParams[key] = GetPriceForRouteParams({\n    tokenIn : tokenIn,\n    tokenOut : tokenOut,\n    pool : pool,\n    swapper : swapper,\n    amount : amount,\n    priceOut : priceOut\n    });\n  }\n\n  ///////////////////////////////////////////////////\n  ///               liquidateWithRoute\n  ///////////////////////////////////////////////////\n  struct LiquidateWithRouteParams {\n    address tokenIn;\n    address tokenOut;\n    address pool;\n    address swapper;\n    uint amount;\n    uint slippage;\n    uint amountOut;\n  }\n  /// @notice keccak256(tokenIn, tokenOut, pool, swapper, amount) => results\n  mapping(bytes32 => LiquidateWithRouteParams) public liquidateWithRouteParams;\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint /*slippage*/\n  ) external override {\n    //console.log(\"MockTetuLiquidatorSingleCall.liquidateWithRoute\");\n\n    bytes32 key = keccak256(abi.encodePacked(route[0].tokenIn, route[0].tokenOut, route[0].pool, route[0].swapper, amount));\n    LiquidateWithRouteParams memory p = liquidateWithRouteParams[key];\n\n    if (route.length == 1 && route[0].tokenOut == p.tokenOut) {\n      console.log(\"MockTetuLiquidatorSingleCall.liquidateWithRoute.data.1 balanceIn amount\", IERC20(route[0].tokenIn).balanceOf(msg.sender), amount);\n      IERC20(route[0].tokenIn).transferFrom(msg.sender, address(this), amount);\n\n      console.log(\"MockTetuLiquidatorSingleCall.liquidateWithRoute.data.2 balanceOut amount\", IERC20(route[0].tokenOut).balanceOf(address(this)), p.amountOut);\n      IERC20(route[0].tokenOut).transfer(msg.sender, p.amountOut);\n\n    } else {\n      console.log(\"MockTetuLiquidatorSingleCall.liquidateWithRoute.missed\");\n    }\n  }\n\n  function setLiquidateWithRoute(\n    address tokenIn,\n    address tokenOut,\n    address pool,\n    address swapper,\n    uint amount,\n    uint amountOut\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(tokenIn, tokenOut, pool, swapper, amount));\n    liquidateWithRouteParams[key] = LiquidateWithRouteParams({\n    tokenIn : tokenIn,\n    tokenOut : tokenOut,\n    pool : pool,\n    swapper : swapper,\n    amount : amount,\n    slippage : 0,\n    amountOut : amountOut\n    });\n  }\n\n  ///////////////////////////////////////////////////\n  ///               Get price\n  ///////////////////////////////////////////////////\n  function getPrice(address tokenIn, address tokenOut, uint amount) external pure override returns (uint) {\n    tokenIn;\n    tokenOut;\n    amount;\n    revert(\"get Price is not implemented\");\n  }\n\n  ///////////////////////////////////////////////////\n  ///               liquidate\n  ///////////////////////////////////////////////////\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint slippage\n  ) external override {\n    tokenIn;\n    tokenOut;\n    slippage;\n    IERC20(tokenOut).transfer(msg.sender, amount);\n    revert(\"liquidate is not implemented\");\n  }\n\n  ///////////////////////////////////////////////////\n  ///               Is route exists\n  ///////////////////////////////////////////////////\n  function isRouteExist(address tokenIn, address tokenOut) external pure override returns (bool) {\n    tokenIn;\n    tokenOut;\n    revert(\"isRouteExist is not implemented\");\n  }\n\n  ///////////////////////////////////////////////////\n  ///               addLargestPools\n  ///////////////////////////////////////////////////\n  function addLargestPools(PoolData[] memory /*_pools*/, bool /*rewrite*/) external pure {\n    // noop\n    revert(\"addLargestPools is not implemented\");\n  }\n\n  ///////////////////////////////////////////////////\n  ///               addBlueChipsPools\n  ///////////////////////////////////////////////////\n  function addBlueChipsPools(PoolData[] memory /*_pools*/, bool /*rewrite*/) external pure {\n    // noop\n    revert(\"addBlueChipsPools is not implemented\");\n  }\n\n}\n"
    },
    "contracts/test/PriceOracleImitator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\n\ncontract PriceOracleImitator is IPriceOracle {\n  address public usdc;\n  ITetuLiquidator liquidator;\n\n  constructor(address usdc_, address liquidator_) {\n    usdc = usdc_;\n    liquidator = ITetuLiquidator(liquidator_);\n  }\n\n  /// @notice Return asset price in USD, decimals 18\n  function getAssetPrice(address asset) external view override returns (uint256) {\n    if (asset == usdc) {\n      return 1e18;\n    }\n    uint tokenInDecimals = IERC20Metadata(asset).decimals();\n    uint lPrice = liquidator.getPrice(asset, usdc, 10 ** tokenInDecimals);\n    return lPrice * 1e12;\n  }\n\n  function setUsdc(address asset) external {\n    usdc = asset;\n  }\n}\n"
    },
    "contracts/test/PriceOracleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\";\nimport \"hardhat/console.sol\";\n\ncontract PriceOracleMock is IPriceOracle {\n  /// how much 1 token costs in USD, decimals 18\n  mapping(address => uint256) public prices;\n\n  constructor(address[] memory assets, uint[] memory pricesInUSD) {\n    _changePrices(assets, pricesInUSD);\n  }\n  ///////////////////////////////////////////////////////\n  ///           Set up\n  ///////////////////////////////////////////////////////\n  function changePrices(address[] memory assets, uint[] memory pricesInUSD) external {\n    _changePrices(assets, pricesInUSD);\n  }\n\n  function _changePrices(address[] memory assets, uint[] memory pricesInUSD) internal {\n    require(assets.length == pricesInUSD.length, \"wrong lengths\");\n    for (uint i = 0; i < assets.length; ++i) {\n      prices[assets[i]] = pricesInUSD[i];\n      console.log(\"Price for %d is %d USD\", assets[i], pricesInUSD[i]);\n    }\n  }\n\n  ///////////////////////////////////////////////////////\n  ///           IPriceOracle\n  ///////////////////////////////////////////////////////\n\n  /// @notice Return asset price in USD, decimals 18\n  function getAssetPrice(address asset) external view override returns (uint256) {\n    console.log(\"PriceOracleMock.getAssetPrice\", asset, prices[asset]);\n    return prices[asset];\n  }\n}\n"
    },
    "contracts/test/Typechain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// import contracts here from node_moules to include it in to typechain\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockToken.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/proxy/ProxyControlled.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/Multicall.sol\";\n\n// for hardhat chain quick tests\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/ControllerMinimal.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockGauge.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockStrategy.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockStrategySimple.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockSplitter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/TetuVaultV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/VaultInsurance.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/StrategySplitterV2.sol\";\n\n// for TokenUtils / Tests\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeTetu.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IPlatformVoter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeDistributor.sol\";\n\n//\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/VaultFactory.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/infrastructure/ForwarderV3.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/infrastructure/ControllerV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/infrastructure/PlatformVoter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/infrastructure/InvestFundV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/ve/VeTetu.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/ve/VeDistributor.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/ve/TetuVoter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/reward/MultiGauge.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/reward/MultiBribe.sol\";\n\n\ncontract ___typechain___ {}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/callback/IUniswapV3FlashCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#flash\n/// @notice Any contract that calls IUniswapV3PoolActions#flash must implement this interface\ninterface IUniswapV3FlashCallback {\n  /// @notice Called to `msg.sender` after transferring to the recipient from IUniswapV3Pool#flash.\n  /// @dev In the implementation you must repay the pool the tokens sent by flash plus the computed fee amounts.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// @param fee0 The fee amount in token0 due to the pool by the end of the flash\n  /// @param fee1 The fee amount in token1 due to the pool by the end of the flash\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#flash call\n  function uniswapV3FlashCallback(\n    uint256 fee0,\n    uint256 fee1,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/callback/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n  /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n  /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n  /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n  function uniswapV3MintCallback(\n    uint256 amount0Owed,\n    uint256 amount1Owed,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n  /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n  /// @dev In the implementation you must pay the pool tokens owed for the swap.\n  /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n  /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n  /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n  /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n  /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n  /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external;\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/IERC20Minimal.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Minimal ERC20 interface for Uniswap\n/// @notice Contains a subset of the full ERC20 interface that is used in Uniswap V3\ninterface IERC20Minimal {\n  /// @notice Returns the balance of a token\n  /// @param account The account for which to look up the number of tokens it has, i.e. its balance\n  /// @return The number of tokens held by the account\n  function balanceOf(address account) external view returns (uint256);\n\n  /// @notice Transfers the amount of token from the `msg.sender` to the recipient\n  /// @param recipient The account that will receive the amount transferred\n  /// @param amount The number of tokens to send from the sender to the recipient\n  /// @return Returns true for a successful transfer, false for an unsuccessful transfer\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /// @notice Returns the current allowance given to a spender by an owner\n  /// @param owner The account of the token owner\n  /// @param spender The account of the token spender\n  /// @return The current allowance granted by `owner` to `spender`\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /// @notice Sets the allowance of a spender from the `msg.sender` to the value `amount`\n  /// @param spender The account which will be allowed to spend a given amount of the owners tokens\n  /// @param amount The amount of tokens allowed to be used by `spender`\n  /// @return Returns true for a successful approval, false for unsuccessful\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /// @notice Transfers `amount` tokens from `sender` to `recipient` up to the allowance given to the `msg.sender`\n  /// @param sender The account from which the transfer will be initiated\n  /// @param recipient The recipient of the transfer\n  /// @param amount The amount of the transfer\n  /// @return Returns true for a successful transfer, false for unsuccessful\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /// @notice Event emitted when tokens are transferred from one address to another, either via `#transfer` or `#transferFrom`.\n  /// @param from The account from which the tokens were sent, i.e. the balance decreased\n  /// @param to The account to which the tokens were sent, i.e. the balance increased\n  /// @param value The amount of tokens that were transferred\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /// @notice Event emitted when the approval amount for the spender of a given owner's tokens changes.\n  /// @param owner The account that approved spending of its tokens\n  /// @param spender The account for which the spending allowance was modified\n  /// @param value The new allowance from the owner to the spender\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n  /// @notice Emitted when the owner of the factory is changed\n  /// @param oldOwner The owner before the owner was changed\n  /// @param newOwner The owner after the owner was changed\n  event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n  /// @notice Emitted when a pool is created\n  /// @param token0 The first token of the pool by address sort order\n  /// @param token1 The second token of the pool by address sort order\n  /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n  /// @param tickSpacing The minimum number of ticks between initialized ticks\n  /// @param pool The address of the created pool\n  event PoolCreated(\n    address indexed token0,\n    address indexed token1,\n    uint24 indexed fee,\n    int24 tickSpacing,\n    address pool\n  );\n\n  /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n  /// @param fee The enabled fee, denominated in hundredths of a bip\n  /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n  event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n  /// @notice Returns the current owner of the factory\n  /// @dev Can be changed by the current owner via setOwner\n  /// @return The address of the factory owner\n  function owner() external view returns (address);\n\n  /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n  /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n  /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n  /// @return The tick spacing\n  function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n  /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n  /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n  /// @param tokenA The contract address of either token0 or token1\n  /// @param tokenB The contract address of the other token\n  /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n  /// @return pool The pool address\n  function getPool(\n    address tokenA,\n    address tokenB,\n    uint24 fee\n  ) external view returns (address pool);\n\n  /// @notice Creates a pool for the given two tokens and fee\n  /// @param tokenA One of the two tokens in the desired pool\n  /// @param tokenB The other of the two tokens in the desired pool\n  /// @param fee The desired fee for the pool\n  /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n  /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n  /// are invalid.\n  /// @return pool The address of the newly created pool\n  function createPool(\n    address tokenA,\n    address tokenB,\n    uint24 fee\n  ) external returns (address pool);\n\n  /// @notice Updates the owner of the factory\n  /// @dev Must be called by the current owner\n  /// @param _owner The new owner of the factory\n  function setOwner(address _owner) external;\n\n  /// @notice Enables a fee amount with the given tickSpacing\n  /// @dev Fee amounts may never be removed once enabled\n  /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n  /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n  function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport {IUniswapV3PoolImmutables} from './pool/IUniswapV3PoolImmutables.sol';\nimport {IUniswapV3PoolState} from './pool/IUniswapV3PoolState.sol';\nimport {IUniswapV3PoolDerivedState} from './pool/IUniswapV3PoolDerivedState.sol';\nimport {IUniswapV3PoolActions} from './pool/IUniswapV3PoolActions.sol';\nimport {IUniswapV3PoolOwnerActions} from './pool/IUniswapV3PoolOwnerActions.sol';\nimport {IUniswapV3PoolErrors} from './pool/IUniswapV3PoolErrors.sol';\nimport {IUniswapV3PoolEvents} from './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\nIUniswapV3PoolImmutables,\nIUniswapV3PoolState,\nIUniswapV3PoolDerivedState,\nIUniswapV3PoolActions,\nIUniswapV3PoolOwnerActions,\nIUniswapV3PoolErrors,\nIUniswapV3PoolEvents\n{\n\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/IUniswapV3PoolDeployer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title An interface for a contract that is capable of deploying Uniswap V3 Pools\n/// @notice A contract that constructs a pool must implement this to pass arguments to the pool\n/// @dev This is used to avoid having constructor arguments in the pool contract, which results in the init code hash\n/// of the pool being constant allowing the CREATE2 address of the pool to be cheaply computed on-chain\ninterface IUniswapV3PoolDeployer {\n  /// @notice Get the parameters to be used in constructing the pool, set transiently during pool creation.\n  /// @dev Called by the pool constructor to fetch the parameters of the pool\n  /// Returns factory The factory address\n  /// Returns token0 The first token of the pool by address sort order\n  /// Returns token1 The second token of the pool by address sort order\n  /// Returns fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n  /// Returns tickSpacing The minimum number of ticks between initialized ticks\n  function parameters()\n  external\n  view\n  returns (\n    address factory,\n    address token0,\n    address token1,\n    uint24 fee,\n    int24 tickSpacing\n  );\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n  /// @notice Sets the initial price for the pool\n  /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n  /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n  function initialize(uint160 sqrtPriceX96) external;\n\n  /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n  /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n  /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n  /// @param recipient The address for which the liquidity will be created\n  /// @param tickLower The lower tick of the position in which to add liquidity\n  /// @param tickUpper The upper tick of the position in which to add liquidity\n  /// @param amount The amount of liquidity to mint\n  /// @param data Any data that should be passed through to the callback\n  /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount,\n    bytes calldata data\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Collects tokens owed to a position\n  /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n  /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n  /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n  /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n  /// @param recipient The address which should receive the fees collected\n  /// @param tickLower The lower tick of the position for which to collect fees\n  /// @param tickUpper The upper tick of the position for which to collect fees\n  /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n  /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n  /// @return amount0 The amount of fees collected in token0\n  /// @return amount1 The amount of fees collected in token1\n  function collect(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n\n  /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n  /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n  /// @dev Fees must be collected separately via a call to #collect\n  /// @param tickLower The lower tick of the position for which to burn liquidity\n  /// @param tickUpper The upper tick of the position for which to burn liquidity\n  /// @param amount How much liquidity to burn\n  /// @return amount0 The amount of token0 sent to the recipient\n  /// @return amount1 The amount of token1 sent to the recipient\n  function burn(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount\n  ) external returns (uint256 amount0, uint256 amount1);\n\n  /// @notice Swap token0 for token1, or token1 for token0\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n  /// @param recipient The address to receive the output of the swap\n  /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n  /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n  /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n  /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n  /// @param data Any data to be passed through to the callback\n  /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n  /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external returns (int256 amount0, int256 amount1);\n\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n  /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n  /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n  /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n  /// @param recipient The address which will receive the token0 and token1 amounts\n  /// @param amount0 The amount of token0 to send\n  /// @param amount1 The amount of token1 to send\n  /// @param data Any data to be passed through to the callback\n  function flash(\n    address recipient,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external;\n\n  /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n  /// the input observationCardinalityNext.\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n  /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n  /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n  /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n  /// you must call it with secondsAgos = [3600, 0].\n  /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n  /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n  /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n  /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n  /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n  /// timestamp\n  function observe(uint32[] calldata secondsAgos)\n  external\n  view\n  returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n  /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n  /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n  /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n  /// snapshot is taken and the second snapshot is taken.\n  /// @param tickLower The lower tick of the range\n  /// @param tickUpper The upper tick of the range\n  /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n  /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n  /// @return secondsInside The snapshot of seconds per liquidity for the range\n  function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n  external\n  view\n  returns (\n    int56 tickCumulativeInside,\n    uint160 secondsPerLiquidityInsideX128,\n    uint32 secondsInside\n  );\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/pool/IUniswapV3PoolErrors.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Errors emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolErrors {\n  error LOK();\n  error TLU();\n  error TLM();\n  error TUM();\n  error AI();\n  error M0();\n  error M1();\n  error AS();\n  error IIA();\n  error L();\n  error F0();\n  error F1();\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n  /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n  /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n  /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n  event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n  /// @notice Emitted when liquidity is minted for a given position\n  /// @param sender The address that minted the liquidity\n  /// @param owner The owner of the position and recipient of any minted liquidity\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity minted to the position range\n  /// @param amount0 How much token0 was required for the minted liquidity\n  /// @param amount1 How much token1 was required for the minted liquidity\n  event Mint(\n    address sender,\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted when fees are collected by the owner of a position\n  /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n  /// @param owner The owner of the position for which fees are collected\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount0 The amount of token0 fees collected\n  /// @param amount1 The amount of token1 fees collected\n  event Collect(\n    address indexed owner,\n    address recipient,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount0,\n    uint128 amount1\n  );\n\n  /// @notice Emitted when a position's liquidity is removed\n  /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n  /// @param owner The owner of the position for which liquidity is removed\n  /// @param tickLower The lower tick of the position\n  /// @param tickUpper The upper tick of the position\n  /// @param amount The amount of liquidity to remove\n  /// @param amount0 The amount of token0 withdrawn\n  /// @param amount1 The amount of token1 withdrawn\n  event Burn(\n    address indexed owner,\n    int24 indexed tickLower,\n    int24 indexed tickUpper,\n    uint128 amount,\n    uint256 amount0,\n    uint256 amount1\n  );\n\n  /// @notice Emitted by the pool for any swaps between token0 and token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the output of the swap\n  /// @param amount0 The delta of the token0 balance of the pool\n  /// @param amount1 The delta of the token1 balance of the pool\n  /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n  /// @param liquidity The liquidity of the pool after the swap\n  /// @param tick The log base 1.0001 of price of the pool after the swap\n  event Swap(\n    address indexed sender,\n    address indexed recipient,\n    int256 amount0,\n    int256 amount1,\n    uint160 sqrtPriceX96,\n    uint128 liquidity,\n    int24 tick\n  );\n\n  /// @notice Emitted by the pool for any flashes of token0/token1\n  /// @param sender The address that initiated the swap call, and that received the callback\n  /// @param recipient The address that received the tokens from flash\n  /// @param amount0 The amount of token0 that was flashed\n  /// @param amount1 The amount of token1 that was flashed\n  /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n  /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n  event Flash(\n    address indexed sender,\n    address indexed recipient,\n    uint256 amount0,\n    uint256 amount1,\n    uint256 paid0,\n    uint256 paid1\n  );\n\n  /// @notice Emitted by the pool for increases to the number of observations that can be stored\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n  /// just before a mint/swap/burn.\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n  event IncreaseObservationCardinalityNext(\n    uint16 observationCardinalityNextOld,\n    uint16 observationCardinalityNextNew\n  );\n\n  /// @notice Emitted when the protocol fee is changed by the pool\n  /// @param feeProtocol0Old The previous value of the token0 protocol fee\n  /// @param feeProtocol1Old The previous value of the token1 protocol fee\n  /// @param feeProtocol0New The updated value of the token0 protocol fee\n  /// @param feeProtocol1New The updated value of the token1 protocol fee\n  event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n  /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n  /// @param sender The address that collects the protocol fees\n  /// @param recipient The address that receives the collected protocol fees\n  /// @param amount0 The amount of token0 protocol fees that is withdrawn\n  /// @param amount0 The amount of token1 protocol fees that is withdrawn\n  event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n  /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n  /// @return The contract address\n  function factory() external view returns (address);\n\n  /// @notice The first of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token0() external view returns (address);\n\n  /// @notice The second of the two tokens of the pool, sorted by address\n  /// @return The token contract address\n  function token1() external view returns (address);\n\n  /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n  /// @return The fee\n  function fee() external view returns (uint24);\n\n  /// @notice The pool tick spacing\n  /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n  /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n  /// This value is an int24 to avoid casting even though it is always positive.\n  /// @return The tick spacing\n  function tickSpacing() external view returns (int24);\n\n  /// @notice The maximum amount of position liquidity that can use any tick in the range\n  /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n  /// @return The max amount of liquidity per tick\n  function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n  /// @notice Set the denominator of the protocol's % share of the fees\n  /// @param feeProtocol0 new protocol fee for token0 of the pool\n  /// @param feeProtocol1 new protocol fee for token1 of the pool\n  function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n  /// @notice Collect the protocol fee accrued to the pool\n  /// @param recipient The address to which collected protocol fees should be sent\n  /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n  /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n  /// @return amount0 The protocol fee collected in token0\n  /// @return amount1 The protocol fee collected in token1\n  function collectProtocol(\n    address recipient,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/test/uniswapv3-core/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n  /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n  /// when accessed externally.\n  /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n  /// @return tick The current tick of the pool, i.e. according to the last tick transition that was run.\n  /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n  /// boundary.\n  /// @return observationIndex The index of the last oracle observation that was written,\n  /// @return observationCardinality The current maximum number of observations stored in the pool,\n  /// @return observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n  /// @return feeProtocol The protocol fee for both tokens of the pool.\n  /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n  /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n  /// unlocked Whether the pool is currently locked to reentrancy\n  function slot0()\n  external\n  view\n  returns (\n    uint160 sqrtPriceX96,\n    int24 tick,\n    uint16 observationIndex,\n    uint16 observationCardinality,\n    uint16 observationCardinalityNext,\n    uint8 feeProtocol,\n    bool unlocked\n  );\n\n  /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal0X128() external view returns (uint256);\n\n  /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n  /// @dev This value can overflow the uint256\n  function feeGrowthGlobal1X128() external view returns (uint256);\n\n  /// @notice The amounts of token0 and token1 that are owed to the protocol\n  /// @dev Protocol fees will never exceed uint128 max in either token\n  function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n  /// @notice The currently in range liquidity available to the pool\n  /// @dev This value has no relationship to the total liquidity across all ticks\n  /// @return The liquidity at the current price of the pool\n  function liquidity() external view returns (uint128);\n\n  /// @notice Look up information about a specific tick in the pool\n  /// @param tick The tick to look up\n  /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n  /// tick upper\n  /// @return liquidityNet how much liquidity changes when the pool price crosses the tick,\n  /// @return feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n  /// @return feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n  /// @return tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n  /// @return secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n  /// @return secondsOutside the seconds spent on the other side of the tick from the current tick,\n  /// @return initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n  /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n  /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n  /// a specific position.\n  function ticks(int24 tick)\n  external\n  view\n  returns (\n    uint128 liquidityGross,\n    int128 liquidityNet,\n    uint256 feeGrowthOutside0X128,\n    uint256 feeGrowthOutside1X128,\n    int56 tickCumulativeOutside,\n    uint160 secondsPerLiquidityOutsideX128,\n    uint32 secondsOutside,\n    bool initialized\n  );\n\n  /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n  function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n  /// @notice Returns the information about a position by the position's key\n  /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n  /// @return liquidity The amount of liquidity in the position,\n  /// @return feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n  /// @return feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n  /// @return tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n  /// @return tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n  function positions(bytes32 key)\n  external\n  view\n  returns (\n    uint128 liquidity,\n    uint256 feeGrowthInside0LastX128,\n    uint256 feeGrowthInside1LastX128,\n    uint128 tokensOwed0,\n    uint128 tokensOwed1\n  );\n\n  /// @notice Returns data about a specific observation index\n  /// @param index The element of the observations array to fetch\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n  /// ago, rather than at a specific index in the array.\n  /// @return blockTimestamp The timestamp of the observation,\n  /// @return tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n  /// @return secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n  /// @return initialized whether the observation has been initialized and the values are safe to use\n  function observations(uint256 index)\n  external\n  view\n  returns (\n    uint32 blockTimestamp,\n    int56 tickCumulative,\n    uint160 secondsPerLiquidityCumulativeX128,\n    bool initialized\n  );\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n  /// @notice Returns the index of the most significant bit of the number,\n  ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n  /// @dev The function satisfies the property:\n  ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n  /// @param x the value for which to compute the most significant bit, must be greater than 0\n  /// @return r the index of the most significant bit\n  function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n    require(x > 0);\n\n  unchecked {\n    if (x >= 0x100000000000000000000000000000000) {\n      x >>= 128;\n      r += 128;\n    }\n    if (x >= 0x10000000000000000) {\n      x >>= 64;\n      r += 64;\n    }\n    if (x >= 0x100000000) {\n      x >>= 32;\n      r += 32;\n    }\n    if (x >= 0x10000) {\n      x >>= 16;\n      r += 16;\n    }\n    if (x >= 0x100) {\n      x >>= 8;\n      r += 8;\n    }\n    if (x >= 0x10) {\n      x >>= 4;\n      r += 4;\n    }\n    if (x >= 0x4) {\n      x >>= 2;\n      r += 2;\n    }\n    if (x >= 0x2) r += 1;\n  }\n  }\n\n  /// @notice Returns the index of the least significant bit of the number,\n  ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n  /// @dev The function satisfies the property:\n  ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n  /// @param x the value for which to compute the least significant bit, must be greater than 0\n  /// @return r the index of the least significant bit\n  function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n    require(x > 0);\n\n  unchecked {\n    r = 255;\n    if (x & type(uint128).max > 0) {\n      r -= 128;\n    } else {\n      x >>= 128;\n    }\n    if (x & type(uint64).max > 0) {\n      r -= 64;\n    } else {\n      x >>= 64;\n    }\n    if (x & type(uint32).max > 0) {\n      r -= 32;\n    } else {\n      x >>= 32;\n    }\n    if (x & type(uint16).max > 0) {\n      r -= 16;\n    } else {\n      x >>= 16;\n    }\n    if (x & type(uint8).max > 0) {\n      r -= 8;\n    } else {\n      x >>= 8;\n    }\n    if (x & 0xf > 0) {\n      r -= 4;\n    } else {\n      x >>= 4;\n    }\n    if (x & 0x3 > 0) {\n      r -= 2;\n    } else {\n      x >>= 2;\n    }\n    if (x & 0x1 > 0) r -= 1;\n  }\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/FixedPoint128.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n  uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n  uint8 internal constant RESOLUTION = 96;\n  uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n  /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n  function mulDiv(\n    uint256 a,\n    uint256 b,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = a * b\n    // Compute the product mod 2**256 and mod 2**256 - 1\n    // then use the Chinese Remainder Theorem to reconstruct\n    // the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2**256 + prod0\n    uint256 prod0;\n    // Least significant 256 bits of the product\n    uint256 prod1;\n    // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(a, b, not(0))\n      prod0 := mul(a, b)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division\n    if (prod1 == 0) {\n      require(denominator > 0);\n      assembly {\n        result := div(prod0, denominator)\n      }\n      return result;\n    }\n\n    // Make sure the result is less than 2**256.\n    // Also prevents denominator == 0\n    require(denominator > prod1);\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0]\n    // Compute remainder using mulmod\n    uint256 remainder;\n    assembly {\n      remainder := mulmod(a, b, denominator)\n    }\n    // Subtract 256 bit number from 512 bit number\n    assembly {\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator\n    // Compute largest power of two divisor of denominator.\n    // Always >= 1.\n    uint256 twos = (0 - denominator) & denominator;\n    // Divide denominator by power of two\n    assembly {\n      denominator := div(denominator, twos)\n    }\n\n    // Divide [prod1 prod0] by the factors of two\n    assembly {\n      prod0 := div(prod0, twos)\n    }\n    // Shift in bits from prod1 into prod0. For this we need\n    // to flip `twos` such that it is 2**256 / twos.\n    // If twos is zero, then it becomes one\n    assembly {\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2**256\n    // Now that denominator is an odd number, it has an inverse\n    // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n    // Compute the inverse by starting with a seed that is correct\n    // correct for four bits. That is, denominator * inv = 1 mod 2**4\n    uint256 inv = (3 * denominator) ^ 2;\n    // Now use Newton-Raphson iteration to improve the precision.\n    // Thanks to Hensel's lifting lemma, this also works in modular\n    // arithmetic, doubling the correct bits in each step.\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**8\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**16\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**32\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**64\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**128\n    inv *= 2 - denominator * inv;\n    // inverse mod 2**256\n\n    // Because the division is now exact we can divide by multiplying\n    // with the modular inverse of denominator. This will give us the\n    // correct result modulo 2**256. Since the precoditions guarantee\n    // that the outcome is less than 2**256, this is the final result.\n    // We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inv;\n    return result;\n  }\n  }\n\n  /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n  /// @param a The multiplicand\n  /// @param b The multiplier\n  /// @param denominator The divisor\n  /// @return result The 256-bit result\n  function mulDivRoundingUp(\n    uint256 a,\n    uint256 b,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n  unchecked {\n    result = mulDiv(a, b, denominator);\n    if (mulmod(a, b, denominator) > 0) {\n      require(result < type(uint256).max);\n      result++;\n    }\n  }\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/Oracle.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n/// @title Oracle\n/// @notice Provides price and liquidity data useful for a wide variety of system designs\n/// @dev Instances of stored oracle data, \"observations\", are collected in the oracle array\n/// Every pool is initialized with an oracle array length of 1. Anyone can pay the SSTOREs to increase the\n/// maximum length of the oracle array. New slots will be added when the array is fully populated.\n/// Observations are overwritten when the full length of the oracle array is populated.\n/// The most recent observation is available, independent of the length of the oracle array, by passing 0 to observe()\nlibrary Oracle {\n  error I();\n  error OLD();\n\n  struct Observation {\n    // the block timestamp of the observation\n    uint32 blockTimestamp;\n    // the tick accumulator, i.e. tick * time elapsed since the pool was first initialized\n    int56 tickCumulative;\n    // the seconds per liquidity, i.e. seconds elapsed / max(1, liquidity) since the pool was first initialized\n    uint160 secondsPerLiquidityCumulativeX128;\n    // whether or not the observation is initialized\n    bool initialized;\n  }\n\n  /// @notice Transforms a previous observation into a new observation, given the passage of time and the current tick and liquidity values\n  /// @dev blockTimestamp _must_ be chronologically equal to or greater than last.blockTimestamp, safe for 0 or 1 overflows\n  /// @param last The specified observation to be transformed\n  /// @param blockTimestamp The timestamp of the new observation\n  /// @param tick The active tick at the time of the new observation\n  /// @param liquidity The total in-range liquidity at the time of the new observation\n  /// @return Observation The newly populated observation\n  function transform(\n    Observation memory last,\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity\n  ) private pure returns (Observation memory) {\n  unchecked {\n    uint32 delta = blockTimestamp - last.blockTimestamp;\n    return\n    Observation({\n    blockTimestamp : blockTimestamp,\n    tickCumulative : last.tickCumulative + int56(tick) * int56(uint56(delta)),\n    secondsPerLiquidityCumulativeX128 : last.secondsPerLiquidityCumulativeX128 +\n      ((uint160(delta) << 128) / (liquidity > 0 ? liquidity : 1)),\n    initialized : true\n    });\n  }\n  }\n\n  /// @notice Initialize the oracle array by writing the first slot. Called once for the lifecycle of the observations array\n  /// @param self The stored oracle array\n  /// @param time The time of the oracle initialization, via block.timestamp truncated to uint32\n  /// @return cardinality The number of populated elements in the oracle array\n  /// @return cardinalityNext The new length of the oracle array, independent of population\n  function initialize(Observation[65535] storage self, uint32 time)\n  internal\n  returns (uint16 cardinality, uint16 cardinalityNext)\n  {\n    self[0] = Observation({\n    blockTimestamp : time,\n    tickCumulative : 0,\n    secondsPerLiquidityCumulativeX128 : 0,\n    initialized : true\n    });\n    return (1, 1);\n  }\n\n  /// @notice Writes an oracle observation to the array\n  /// @dev Writable at most once per block. Index represents the most recently written element. cardinality and index must be tracked externally.\n  /// If the index is at the end of the allowable array length (according to cardinality), and the next cardinality\n  /// is greater than the current one, cardinality may be increased. This restriction is created to preserve ordering.\n  /// @param self The stored oracle array\n  /// @param index The index of the observation that was most recently written to the observations array\n  /// @param blockTimestamp The timestamp of the new observation\n  /// @param tick The active tick at the time of the new observation\n  /// @param liquidity The total in-range liquidity at the time of the new observation\n  /// @param cardinality The number of populated elements in the oracle array\n  /// @param cardinalityNext The new length of the oracle array, independent of population\n  /// @return indexUpdated The new index of the most recently written element in the oracle array\n  /// @return cardinalityUpdated The new cardinality of the oracle array\n  function write(\n    Observation[65535] storage self,\n    uint16 index,\n    uint32 blockTimestamp,\n    int24 tick,\n    uint128 liquidity,\n    uint16 cardinality,\n    uint16 cardinalityNext\n  ) internal returns (uint16 indexUpdated, uint16 cardinalityUpdated) {\n  unchecked {\n    Observation memory last = self[index];\n\n    // early return if we've already written an observation this block\n    if (last.blockTimestamp == blockTimestamp) return (index, cardinality);\n\n    // if the conditions are right, we can bump the cardinality\n    if (cardinalityNext > cardinality && index == (cardinality - 1)) {\n      cardinalityUpdated = cardinalityNext;\n    } else {\n      cardinalityUpdated = cardinality;\n    }\n\n    indexUpdated = (index + 1) % cardinalityUpdated;\n    self[indexUpdated] = transform(last, blockTimestamp, tick, liquidity);\n  }\n  }\n\n  /// @notice Prepares the oracle array to store up to `next` observations\n  /// @param self The stored oracle array\n  /// @param current The current next cardinality of the oracle array\n  /// @param next The proposed next cardinality which will be populated in the oracle array\n  /// @return next The next cardinality which will be populated in the oracle array\n  function grow(\n    Observation[65535] storage self,\n    uint16 current,\n    uint16 next\n  ) internal returns (uint16) {\n  unchecked {\n    if (current <= 0) revert I();\n    // no-op if the passed next value isn't greater than the current next value\n    if (next <= current) return current;\n    // store in each slot to prevent fresh SSTOREs in swaps\n    // this data will not be used because the initialized boolean is still false\n    for (uint16 i = current; i < next; i++) self[i].blockTimestamp = 1;\n    return next;\n  }\n  }\n\n  /// @notice comparator for 32-bit timestamps\n  /// @dev safe for 0 or 1 overflows, a and b _must_ be chronologically before or equal to time\n  /// @param time A timestamp truncated to 32 bits\n  /// @param a A comparison timestamp from which to determine the relative position of `time`\n  /// @param b From which to determine the relative position of `time`\n  /// @return Whether `a` is chronologically <= `b`\n  function lte(\n    uint32 time,\n    uint32 a,\n    uint32 b\n  ) private pure returns (bool) {\n  unchecked {\n    // if there hasn't been overflow, no need to adjust\n    if (a <= time && b <= time) return a <= b;\n\n    uint256 aAdjusted = a > time ? a : a + 2 ** 32;\n    uint256 bAdjusted = b > time ? b : b + 2 ** 32;\n\n    return aAdjusted <= bAdjusted;\n  }\n  }\n\n  /// @notice Fetches the observations beforeOrAt and atOrAfter a target, i.e. where [beforeOrAt, atOrAfter] is satisfied.\n  /// The result may be the same observation, or adjacent observations.\n  /// @dev The answer must be contained in the array, used when the target is located within the stored observation\n  /// boundaries: older than the most recent observation and younger, or the same age as, the oldest observation\n  /// @param self The stored oracle array\n  /// @param time The current block.timestamp\n  /// @param target The timestamp at which the reserved observation should be for\n  /// @param index The index of the observation that was most recently written to the observations array\n  /// @param cardinality The number of populated elements in the oracle array\n  /// @return beforeOrAt The observation recorded before, or at, the target\n  /// @return atOrAfter The observation recorded at, or after, the target\n  function binarySearch(\n    Observation[65535] storage self,\n    uint32 time,\n    uint32 target,\n    uint16 index,\n    uint16 cardinality\n  ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n  unchecked {\n    uint256 l = (index + 1) % cardinality;\n    // oldest observation\n    uint256 r = l + cardinality - 1;\n    // newest observation\n    uint256 i;\n    while (true) {\n      i = (l + r) / 2;\n\n      beforeOrAt = self[i % cardinality];\n\n      // we've landed on an uninitialized tick, keep searching higher (more recently)\n      if (!beforeOrAt.initialized) {\n        l = i + 1;\n        continue;\n      }\n\n      atOrAfter = self[(i + 1) % cardinality];\n\n      bool targetAtOrAfter = lte(time, beforeOrAt.blockTimestamp, target);\n\n      // check if we've found the answer!\n      if (targetAtOrAfter && lte(time, target, atOrAfter.blockTimestamp)) break;\n\n      if (!targetAtOrAfter) r = i - 1;\n      else l = i + 1;\n    }\n  }\n  }\n\n  /// @notice Fetches the observations beforeOrAt and atOrAfter a given target, i.e. where [beforeOrAt, atOrAfter] is satisfied\n  /// @dev Assumes there is at least 1 initialized observation.\n  /// Used by observeSingle() to compute the counterfactual accumulator values as of a given block timestamp.\n  /// @param self The stored oracle array\n  /// @param time The current block.timestamp\n  /// @param target The timestamp at which the reserved observation should be for\n  /// @param tick The active tick at the time of the returned or simulated observation\n  /// @param index The index of the observation that was most recently written to the observations array\n  /// @param liquidity The total pool liquidity at the time of the call\n  /// @param cardinality The number of populated elements in the oracle array\n  /// @return beforeOrAt The observation which occurred at, or before, the given timestamp\n  /// @return atOrAfter The observation which occurred at, or after, the given timestamp\n  function getSurroundingObservations(\n    Observation[65535] storage self,\n    uint32 time,\n    uint32 target,\n    int24 tick,\n    uint16 index,\n    uint128 liquidity,\n    uint16 cardinality\n  ) private view returns (Observation memory beforeOrAt, Observation memory atOrAfter) {\n  unchecked {\n    // optimistically set before to the newest observation\n    beforeOrAt = self[index];\n\n    // if the target is chronologically at or after the newest observation, we can early return\n    if (lte(time, beforeOrAt.blockTimestamp, target)) {\n      if (beforeOrAt.blockTimestamp == target) {\n        // if newest observation equals target, we're in the same block, so we can ignore atOrAfter\n        return (beforeOrAt, atOrAfter);\n      } else {\n        // otherwise, we need to transform\n        return (beforeOrAt, transform(beforeOrAt, target, tick, liquidity));\n      }\n    }\n\n    // now, set before to the oldest observation\n    beforeOrAt = self[(index + 1) % cardinality];\n    if (!beforeOrAt.initialized) beforeOrAt = self[0];\n\n    // ensure that the target is chronologically at or after the oldest observation\n    if (!lte(time, beforeOrAt.blockTimestamp, target)) revert OLD();\n\n    // if we've reached this point, we have to binary search\n    return binarySearch(self, time, target, index, cardinality);\n  }\n  }\n\n  /// @dev Reverts if an observation at or before the desired observation timestamp does not exist.\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\n  /// If called with a timestamp falling between two observations, returns the counterfactual accumulator values\n  /// at exactly the timestamp between the two observations.\n  /// @param self The stored oracle array\n  /// @param time The current block timestamp\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return an observation\n  /// @param tick The current tick\n  /// @param index The index of the observation that was most recently written to the observations array\n  /// @param liquidity The current in-range pool liquidity\n  /// @param cardinality The number of populated elements in the oracle array\n  /// @return tickCumulative The tick * time elapsed since the pool was first initialized, as of `secondsAgo`\n  /// @return secondsPerLiquidityCumulativeX128 The time elapsed / max(1, liquidity) since the pool was first initialized, as of `secondsAgo`\n  function observeSingle(\n    Observation[65535] storage self,\n    uint32 time,\n    uint32 secondsAgo,\n    int24 tick,\n    uint16 index,\n    uint128 liquidity,\n    uint16 cardinality\n  ) internal view returns (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) {\n  unchecked {\n    if (secondsAgo == 0) {\n      Observation memory last = self[index];\n      if (last.blockTimestamp != time) last = transform(last, time, tick, liquidity);\n      return (last.tickCumulative, last.secondsPerLiquidityCumulativeX128);\n    }\n\n    uint32 target = time - secondsAgo;\n\n    (Observation memory beforeOrAt, Observation memory atOrAfter) = getSurroundingObservations(\n      self,\n      time,\n      target,\n      tick,\n      index,\n      liquidity,\n      cardinality\n    );\n\n    if (target == beforeOrAt.blockTimestamp) {\n      // we're at the left boundary\n      return (beforeOrAt.tickCumulative, beforeOrAt.secondsPerLiquidityCumulativeX128);\n    } else if (target == atOrAfter.blockTimestamp) {\n      // we're at the right boundary\n      return (atOrAfter.tickCumulative, atOrAfter.secondsPerLiquidityCumulativeX128);\n    } else {\n      // we're in the middle\n      uint32 observationTimeDelta = atOrAfter.blockTimestamp - beforeOrAt.blockTimestamp;\n      uint32 targetDelta = target - beforeOrAt.blockTimestamp;\n      return (\n      beforeOrAt.tickCumulative +\n      ((atOrAfter.tickCumulative - beforeOrAt.tickCumulative) / int56(uint56(observationTimeDelta))) *\n      int56(uint56(targetDelta)),\n      beforeOrAt.secondsPerLiquidityCumulativeX128 +\n      uint160(\n        (uint256(\n          atOrAfter.secondsPerLiquidityCumulativeX128 -\n          beforeOrAt.secondsPerLiquidityCumulativeX128\n        ) * targetDelta) / observationTimeDelta\n      )\n      );\n    }\n  }\n  }\n\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\n  /// @dev Reverts if `secondsAgos` > oldest observation\n  /// @param self The stored oracle array\n  /// @param time The current block.timestamp\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return an observation\n  /// @param tick The current tick\n  /// @param index The index of the observation that was most recently written to the observations array\n  /// @param liquidity The current in-range pool liquidity\n  /// @param cardinality The number of populated elements in the oracle array\n  /// @return tickCumulatives The tick * time elapsed since the pool was first initialized, as of each `secondsAgo`\n  /// @return secondsPerLiquidityCumulativeX128s The cumulative seconds / max(1, liquidity) since the pool was first initialized, as of each `secondsAgo`\n  function observe(\n    Observation[65535] storage self,\n    uint32 time,\n    uint32[] memory secondsAgos,\n    int24 tick,\n    uint16 index,\n    uint128 liquidity,\n    uint16 cardinality\n  ) internal view returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s) {\n  unchecked {\n    if (cardinality <= 0) revert I();\n\n    tickCumulatives = new int56[](secondsAgos.length);\n    secondsPerLiquidityCumulativeX128s = new uint160[](secondsAgos.length);\n    for (uint256 i = 0; i < secondsAgos.length; i++) {\n      (tickCumulatives[i], secondsPerLiquidityCumulativeX128s[i]) = observeSingle(\n        self,\n        time,\n        secondsAgos[i],\n        tick,\n        index,\n        liquidity,\n        cardinality\n      );\n    }\n  }\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/Position.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {FullMath} from './FullMath.sol';\nimport {FixedPoint128} from './FixedPoint128.sol';\n\n/// @title Position\n/// @notice Positions represent an owner address' liquidity between a lower and upper tick boundary\n/// @dev Positions store additional state for tracking fees owed to the position\nlibrary Position {\n  error NP();\n\n  // info stored for each user's position\n  struct Info {\n    // the amount of liquidity owned by this position\n    uint128 liquidity;\n    // fee growth per unit of liquidity as of the last update to liquidity or fees owed\n    uint256 feeGrowthInside0LastX128;\n    uint256 feeGrowthInside1LastX128;\n    // the fees owed to the position owner in token0/token1\n    uint128 tokensOwed0;\n    uint128 tokensOwed1;\n  }\n\n  /// @notice Returns the Info struct of a position, given an owner and position boundaries\n  /// @param self The mapping containing all user positions\n  /// @param owner The address of the position owner\n  /// @param tickLower The lower tick boundary of the position\n  /// @param tickUpper The upper tick boundary of the position\n  /// @return position The position info struct of the given owners' position\n  function get(\n    mapping(bytes32 => Info) storage self,\n    address owner,\n    int24 tickLower,\n    int24 tickUpper\n  ) internal view returns (Position.Info storage position) {\n    position = self[keccak256(abi.encodePacked(owner, tickLower, tickUpper))];\n  }\n\n  /// @notice Credits accumulated fees to a user's position\n  /// @param self The individual position to update\n  /// @param liquidityDelta The change in pool liquidity as a result of the position update\n  /// @param feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n  /// @param feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n  function update(\n    Info storage self,\n    int128 liquidityDelta,\n    uint256 feeGrowthInside0X128,\n    uint256 feeGrowthInside1X128\n  ) internal {\n    Info memory _self = self;\n\n    uint128 liquidityNext;\n    if (liquidityDelta == 0) {\n      if (_self.liquidity <= 0) revert NP();\n      // disallow pokes for 0 liquidity positions\n      liquidityNext = _self.liquidity;\n    } else {\n      liquidityNext = liquidityDelta < 0\n      ? _self.liquidity - uint128(- liquidityDelta)\n      : _self.liquidity + uint128(liquidityDelta);\n    }\n\n    // calculate accumulated fees. overflow in the subtraction of fee growth is expected\n    uint128 tokensOwed0;\n    uint128 tokensOwed1;\n  unchecked {\n    tokensOwed0 = uint128(\n      FullMath.mulDiv(\n        feeGrowthInside0X128 - _self.feeGrowthInside0LastX128,\n        _self.liquidity,\n        FixedPoint128.Q128\n      )\n    );\n    tokensOwed1 = uint128(\n      FullMath.mulDiv(\n        feeGrowthInside1X128 - _self.feeGrowthInside1LastX128,\n        _self.liquidity,\n        FixedPoint128.Q128\n      )\n    );\n\n    // update the position\n    if (liquidityDelta != 0) self.liquidity = liquidityNext;\n    self.feeGrowthInside0LastX128 = feeGrowthInside0X128;\n    self.feeGrowthInside1LastX128 = feeGrowthInside1X128;\n    if (tokensOwed0 > 0 || tokensOwed1 > 0) {\n      // overflow is acceptable, user must withdraw before they hit type(uint128).max fees\n      self.tokensOwed0 += tokensOwed0;\n      self.tokensOwed1 += tokensOwed1;\n    }\n  }\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n  /// @notice Cast a uint256 to a uint160, revert on overflow\n  /// @param y The uint256 to be downcasted\n  /// @return z The downcasted integer, now type uint160\n  function toUint160(uint256 y) internal pure returns (uint160 z) {\n    require((z = uint160(y)) == y);\n  }\n\n  /// @notice Cast a int256 to a int128, revert on overflow or underflow\n  /// @param y The int256 to be downcasted\n  /// @return z The downcasted integer, now type int128\n  function toInt128(int256 y) internal pure returns (int128 z) {\n    require((z = int128(y)) == y);\n  }\n\n  /// @notice Cast a uint256 to a int256, revert on overflow\n  /// @param y The uint256 to be casted\n  /// @return z The casted integer, now type int256\n  function toInt256(uint256 y) internal pure returns (int256 z) {\n    require(y < 2 ** 255);\n    z = int256(y);\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/SqrtPriceMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {SafeCast} from './SafeCast.sol';\n\nimport {FullMath} from './FullMath.sol';\nimport {UnsafeMath} from './UnsafeMath.sol';\nimport {FixedPoint96} from './FixedPoint96.sol';\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n  using SafeCast for uint256;\n\n  /// @notice Gets the next sqrt price given a delta of token0\n  /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n  /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n  /// price less in order to not send too much output.\n  /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n  /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n  /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n  /// @param liquidity The amount of usable liquidity\n  /// @param amount How much of token0 to add or remove from virtual reserves\n  /// @param add Whether to add or remove the amount of token0\n  /// @return The price after adding or removing amount, depending on add\n  function getNextSqrtPriceFromAmount0RoundingUp(\n    uint160 sqrtPX96,\n    uint128 liquidity,\n    uint256 amount,\n    bool add\n  ) internal pure returns (uint160) {\n    // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n    if (amount == 0) return sqrtPX96;\n    uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n    if (add) {\n    unchecked {\n      uint256 product;\n      if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n        uint256 denominator = numerator1 + product;\n        if (denominator >= numerator1)\n        // always fits in 160 bits\n          return uint160(FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator));\n      }\n    }\n      // denominator is checked for overflow\n      return uint160(UnsafeMath.divRoundingUp(numerator1, (numerator1 / sqrtPX96) + amount));\n    } else {\n    unchecked {\n      uint256 product;\n      // if the product overflows, we know the denominator underflows\n      // in addition, we must check that the denominator does not underflow\n      require((product = amount * sqrtPX96) / amount == sqrtPX96 && numerator1 > product);\n      uint256 denominator = numerator1 - product;\n      return FullMath.mulDivRoundingUp(numerator1, sqrtPX96, denominator).toUint160();\n    }\n    }\n  }\n\n  /// @notice Gets the next sqrt price given a delta of token1\n  /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n  /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n  /// price less in order to not send too much output.\n  /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n  /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n  /// @param liquidity The amount of usable liquidity\n  /// @param amount How much of token1 to add, or remove, from virtual reserves\n  /// @param add Whether to add, or remove, the amount of token1\n  /// @return The price after adding or removing `amount`\n  function getNextSqrtPriceFromAmount1RoundingDown(\n    uint160 sqrtPX96,\n    uint128 liquidity,\n    uint256 amount,\n    bool add\n  ) internal pure returns (uint160) {\n    // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n    // in both cases, avoid a mulDiv for most inputs\n    if (add) {\n      uint256 quotient = (\n      amount <= type(uint160).max\n      ? (amount << FixedPoint96.RESOLUTION) / liquidity\n      : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n      );\n\n      return (uint256(sqrtPX96) + quotient).toUint160();\n    } else {\n      uint256 quotient = (\n      amount <= type(uint160).max\n      ? UnsafeMath.divRoundingUp(amount << FixedPoint96.RESOLUTION, liquidity)\n      : FullMath.mulDivRoundingUp(amount, FixedPoint96.Q96, liquidity)\n      );\n\n      require(sqrtPX96 > quotient);\n      // always fits 160 bits\n    unchecked {\n      return uint160(sqrtPX96 - quotient);\n    }\n    }\n  }\n\n  /// @notice Gets the next sqrt price given an input amount of token0 or token1\n  /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n  /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n  /// @param liquidity The amount of usable liquidity\n  /// @param amountIn How much of token0, or token1, is being swapped in\n  /// @param zeroForOne Whether the amount in is token0 or token1\n  /// @return sqrtQX96 The price after adding the input amount to token0 or token1\n  function getNextSqrtPriceFromInput(\n    uint160 sqrtPX96,\n    uint128 liquidity,\n    uint256 amountIn,\n    bool zeroForOne\n  ) internal pure returns (uint160 sqrtQX96) {\n    require(sqrtPX96 > 0);\n    require(liquidity > 0);\n\n    // round to make sure that we don't pass the target price\n    return\n    zeroForOne\n    ? getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountIn, true)\n    : getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountIn, true);\n  }\n\n  /// @notice Gets the next sqrt price given an output amount of token0 or token1\n  /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n  /// @param sqrtPX96 The starting price before accounting for the output amount\n  /// @param liquidity The amount of usable liquidity\n  /// @param amountOut How much of token0, or token1, is being swapped out\n  /// @param zeroForOne Whether the amount out is token0 or token1\n  /// @return sqrtQX96 The price after removing the output amount of token0 or token1\n  function getNextSqrtPriceFromOutput(\n    uint160 sqrtPX96,\n    uint128 liquidity,\n    uint256 amountOut,\n    bool zeroForOne\n  ) internal pure returns (uint160 sqrtQX96) {\n    require(sqrtPX96 > 0);\n    require(liquidity > 0);\n\n    // round to make sure that we pass the target price\n    return\n    zeroForOne\n    ? getNextSqrtPriceFromAmount1RoundingDown(sqrtPX96, liquidity, amountOut, false)\n    : getNextSqrtPriceFromAmount0RoundingUp(sqrtPX96, liquidity, amountOut, false);\n  }\n\n  /// @notice Gets the amount0 delta between two prices\n  /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n  /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The amount of usable liquidity\n  /// @param roundUp Whether to round the amount up or down\n  /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n  function getAmount0Delta(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity,\n    bool roundUp\n  ) internal pure returns (uint256 amount0) {\n  unchecked {\n    if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n    uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n    require(sqrtRatioAX96 > 0);\n\n    return\n    roundUp\n    ? UnsafeMath.divRoundingUp(\n      FullMath.mulDivRoundingUp(numerator1, numerator2, sqrtRatioBX96),\n      sqrtRatioAX96\n    )\n    : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) / sqrtRatioAX96;\n  }\n  }\n\n  /// @notice Gets the amount1 delta between two prices\n  /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The amount of usable liquidity\n  /// @param roundUp Whether to round the amount up, or down\n  /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n  function getAmount1Delta(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    uint128 liquidity,\n    bool roundUp\n  ) internal pure returns (uint256 amount1) {\n  unchecked {\n    if (sqrtRatioAX96 > sqrtRatioBX96) (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n    return\n    roundUp\n    ? FullMath.mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96)\n    : FullMath.mulDiv(liquidity, sqrtRatioBX96 - sqrtRatioAX96, FixedPoint96.Q96);\n  }\n  }\n\n  /// @notice Helper that gets signed token0 delta\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The change in liquidity for which to compute the amount0 delta\n  /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\n  function getAmount0Delta(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    int128 liquidity\n  ) internal pure returns (int256 amount0) {\n  unchecked {\n    return\n    liquidity < 0\n    ? - getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(- liquidity), false).toInt256()\n    : getAmount0Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n  }\n  }\n\n  /// @notice Helper that gets signed token1 delta\n  /// @param sqrtRatioAX96 A sqrt price\n  /// @param sqrtRatioBX96 Another sqrt price\n  /// @param liquidity The change in liquidity for which to compute the amount1 delta\n  /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\n  function getAmount1Delta(\n    uint160 sqrtRatioAX96,\n    uint160 sqrtRatioBX96,\n    int128 liquidity\n  ) internal pure returns (int256 amount1) {\n  unchecked {\n    return\n    liquidity < 0\n    ? - getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(- liquidity), false).toInt256()\n    : getAmount1Delta(sqrtRatioAX96, sqrtRatioBX96, uint128(liquidity), true).toInt256();\n  }\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/SwapMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {FullMath} from './FullMath.sol';\nimport {SqrtPriceMath} from './SqrtPriceMath.sol';\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n  /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n  /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n  /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n  /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n  /// @param liquidity The usable liquidity\n  /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n  /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n  /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n  /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap\n  /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap\n  /// @return feeAmount The amount of input that will be taken as a fee\n  function computeSwapStep(\n    uint160 sqrtRatioCurrentX96,\n    uint160 sqrtRatioTargetX96,\n    uint128 liquidity,\n    int256 amountRemaining,\n    uint24 feePips\n  )\n  internal\n  pure\n  returns (\n    uint160 sqrtRatioNextX96,\n    uint256 amountIn,\n    uint256 amountOut,\n    uint256 feeAmount\n  )\n  {\n  unchecked {\n    bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n    bool exactIn = amountRemaining >= 0;\n\n    if (exactIn) {\n      uint256 amountRemainingLessFee = FullMath.mulDiv(uint256(amountRemaining), 1e6 - feePips, 1e6);\n      amountIn = zeroForOne\n      ? SqrtPriceMath.getAmount0Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, true)\n      : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, true);\n      if (amountRemainingLessFee >= amountIn) sqrtRatioNextX96 = sqrtRatioTargetX96;\n      else\n        sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n          sqrtRatioCurrentX96,\n          liquidity,\n          amountRemainingLessFee,\n          zeroForOne\n        );\n    } else {\n      amountOut = zeroForOne\n      ? SqrtPriceMath.getAmount1Delta(sqrtRatioTargetX96, sqrtRatioCurrentX96, liquidity, false)\n      : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioTargetX96, liquidity, false);\n      if (uint256(- amountRemaining) >= amountOut) sqrtRatioNextX96 = sqrtRatioTargetX96;\n      else\n        sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n          sqrtRatioCurrentX96,\n          liquidity,\n          uint256(- amountRemaining),\n          zeroForOne\n        );\n    }\n\n    bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n    // get the input/output amounts\n    if (zeroForOne) {\n      amountIn = max && exactIn\n      ? amountIn\n      : SqrtPriceMath.getAmount0Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, true);\n      amountOut = max && !exactIn\n      ? amountOut\n      : SqrtPriceMath.getAmount1Delta(sqrtRatioNextX96, sqrtRatioCurrentX96, liquidity, false);\n    } else {\n      amountIn = max && exactIn\n      ? amountIn\n      : SqrtPriceMath.getAmount1Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, true);\n      amountOut = max && !exactIn\n      ? amountOut\n      : SqrtPriceMath.getAmount0Delta(sqrtRatioCurrentX96, sqrtRatioNextX96, liquidity, false);\n    }\n\n    // cap the output amount to not exceed the remaining output amount\n    if (!exactIn && amountOut > uint256(- amountRemaining)) {\n      amountOut = uint256(- amountRemaining);\n    }\n\n    if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n      // we didn't reach the target, so take the remainder of the maximum input as fee\n      feeAmount = uint256(amountRemaining) - amountIn;\n    } else {\n      feeAmount = FullMath.mulDivRoundingUp(amountIn, feePips, 1e6 - feePips);\n    }\n  }\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/Tick.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {SafeCast} from './SafeCast.sol';\n\nimport {TickMath} from './TickMath.sol';\n\n/// @title Tick\n/// @notice Contains functions for managing tick processes and relevant calculations\nlibrary Tick {\n  error LO();\n\n  using SafeCast for int256;\n\n  // info stored for each initialized individual tick\n  struct Info {\n    // the total position liquidity that references this tick\n    uint128 liquidityGross;\n    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),\n    int128 liquidityNet;\n    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint256 feeGrowthOutside0X128;\n    uint256 feeGrowthOutside1X128;\n    // the cumulative tick value on the other side of the tick\n    int56 tickCumulativeOutside;\n    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint160 secondsPerLiquidityOutsideX128;\n    // the seconds spent on the other side of the tick (relative to the current tick)\n    // only has relative meaning, not absolute — the value depends on when the tick is initialized\n    uint32 secondsOutside;\n    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0\n    // these 8 bits are set to prevent fresh sstores when crossing newly initialized ticks\n    bool initialized;\n  }\n\n  /// @notice Derives max liquidity per tick from given tick spacing\n  /// @dev Executed within the pool constructor\n  /// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`\n  ///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...\n  /// @return The max liquidity per tick\n  function tickSpacingToMaxLiquidityPerTick(int24 tickSpacing) internal pure returns (uint128) {\n  unchecked {\n    int24 minTick = (TickMath.MIN_TICK / tickSpacing) * tickSpacing;\n    int24 maxTick = (TickMath.MAX_TICK / tickSpacing) * tickSpacing;\n    uint24 numTicks = uint24((maxTick - minTick) / tickSpacing) + 1;\n    return type(uint128).max / numTicks;\n  }\n  }\n\n  /// @notice Retrieves fee growth data\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tickLower The lower tick boundary of the position\n  /// @param tickUpper The upper tick boundary of the position\n  /// @param tickCurrent The current tick\n  /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n  /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n  /// @return feeGrowthInside0X128 The all-time fee growth in token0, per unit of liquidity, inside the position's tick boundaries\n  /// @return feeGrowthInside1X128 The all-time fee growth in token1, per unit of liquidity, inside the position's tick boundaries\n  function getFeeGrowthInside(\n    mapping(int24 => Tick.Info) storage self,\n    int24 tickLower,\n    int24 tickUpper,\n    int24 tickCurrent,\n    uint256 feeGrowthGlobal0X128,\n    uint256 feeGrowthGlobal1X128\n  ) internal view returns (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) {\n  unchecked {\n    Info storage lower = self[tickLower];\n    Info storage upper = self[tickUpper];\n\n    // calculate fee growth below\n    uint256 feeGrowthBelow0X128;\n    uint256 feeGrowthBelow1X128;\n    if (tickCurrent >= tickLower) {\n      feeGrowthBelow0X128 = lower.feeGrowthOutside0X128;\n      feeGrowthBelow1X128 = lower.feeGrowthOutside1X128;\n    } else {\n      feeGrowthBelow0X128 = feeGrowthGlobal0X128 - lower.feeGrowthOutside0X128;\n      feeGrowthBelow1X128 = feeGrowthGlobal1X128 - lower.feeGrowthOutside1X128;\n    }\n\n    // calculate fee growth above\n    uint256 feeGrowthAbove0X128;\n    uint256 feeGrowthAbove1X128;\n    if (tickCurrent < tickUpper) {\n      feeGrowthAbove0X128 = upper.feeGrowthOutside0X128;\n      feeGrowthAbove1X128 = upper.feeGrowthOutside1X128;\n    } else {\n      feeGrowthAbove0X128 = feeGrowthGlobal0X128 - upper.feeGrowthOutside0X128;\n      feeGrowthAbove1X128 = feeGrowthGlobal1X128 - upper.feeGrowthOutside1X128;\n    }\n\n    feeGrowthInside0X128 = feeGrowthGlobal0X128 - feeGrowthBelow0X128 - feeGrowthAbove0X128;\n    feeGrowthInside1X128 = feeGrowthGlobal1X128 - feeGrowthBelow1X128 - feeGrowthAbove1X128;\n  }\n  }\n\n  /// @notice Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tick The tick that will be updated\n  /// @param tickCurrent The current tick\n  /// @param liquidityDelta A new amount of liquidity to be added (subtracted) when tick is crossed from left to right (right to left)\n  /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n  /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n  /// @param secondsPerLiquidityCumulativeX128 The all-time seconds per max(1, liquidity) of the pool\n  /// @param tickCumulative The tick * time elapsed since the pool was first initialized\n  /// @param time The current block timestamp cast to a uint32\n  /// @param upper true for updating a position's upper tick, or false for updating a position's lower tick\n  /// @param maxLiquidity The maximum liquidity allocation for a single tick\n  /// @return flipped Whether the tick was flipped from initialized to uninitialized, or vice versa\n  function update(\n    mapping(int24 => Tick.Info) storage self,\n    int24 tick,\n    int24 tickCurrent,\n    int128 liquidityDelta,\n    uint256 feeGrowthGlobal0X128,\n    uint256 feeGrowthGlobal1X128,\n    uint160 secondsPerLiquidityCumulativeX128,\n    int56 tickCumulative,\n    uint32 time,\n    bool upper,\n    uint128 maxLiquidity\n  ) internal returns (bool flipped) {\n    Tick.Info storage info = self[tick];\n\n    uint128 liquidityGrossBefore = info.liquidityGross;\n    uint128 liquidityGrossAfter = liquidityDelta < 0\n    ? liquidityGrossBefore - uint128(- liquidityDelta)\n    : liquidityGrossBefore + uint128(liquidityDelta);\n\n    if (liquidityGrossAfter > maxLiquidity) revert LO();\n\n    flipped = (liquidityGrossAfter == 0) != (liquidityGrossBefore == 0);\n\n    if (liquidityGrossBefore == 0) {\n      // by convention, we assume that all growth before a tick was initialized happened _below_ the tick\n      if (tick <= tickCurrent) {\n        info.feeGrowthOutside0X128 = feeGrowthGlobal0X128;\n        info.feeGrowthOutside1X128 = feeGrowthGlobal1X128;\n        info.secondsPerLiquidityOutsideX128 = secondsPerLiquidityCumulativeX128;\n        info.tickCumulativeOutside = tickCumulative;\n        info.secondsOutside = time;\n      }\n      info.initialized = true;\n    }\n\n    info.liquidityGross = liquidityGrossAfter;\n\n    // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)\n    info.liquidityNet = upper ? info.liquidityNet - liquidityDelta : info.liquidityNet + liquidityDelta;\n  }\n\n  /// @notice Clears tick data\n  /// @param self The mapping containing all initialized tick information for initialized ticks\n  /// @param tick The tick that will be cleared\n  function clear(mapping(int24 => Tick.Info) storage self, int24 tick) internal {\n    delete self[tick];\n  }\n\n  /// @notice Transitions to next tick as needed by price movement\n  /// @param self The mapping containing all tick information for initialized ticks\n  /// @param tick The destination tick of the transition\n  /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0\n  /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1\n  /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity\n  /// @param tickCumulative The tick * time elapsed since the pool was first initialized\n  /// @param time The current block.timestamp\n  /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)\n  function cross(\n    mapping(int24 => Tick.Info) storage self,\n    int24 tick,\n    uint256 feeGrowthGlobal0X128,\n    uint256 feeGrowthGlobal1X128,\n    uint160 secondsPerLiquidityCumulativeX128,\n    int56 tickCumulative,\n    uint32 time\n  ) internal returns (int128 liquidityNet) {\n  unchecked {\n    Tick.Info storage info = self[tick];\n    info.feeGrowthOutside0X128 = feeGrowthGlobal0X128 - info.feeGrowthOutside0X128;\n    info.feeGrowthOutside1X128 = feeGrowthGlobal1X128 - info.feeGrowthOutside1X128;\n    info.secondsPerLiquidityOutsideX128 =\n    secondsPerLiquidityCumulativeX128 -\n    info.secondsPerLiquidityOutsideX128;\n    info.tickCumulativeOutside = tickCumulative - info.tickCumulativeOutside;\n    info.secondsOutside = time - info.secondsOutside;\n    liquidityNet = info.liquidityNet;\n  }\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/TickBitmap.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\nimport {BitMath} from './BitMath.sol';\n\n/// @title Packed tick initialized state library\n/// @notice Stores a packed mapping of tick index to its initialized state\n/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.\nlibrary TickBitmap {\n  /// @notice Computes the position in the mapping where the initialized bit for a tick lives\n  /// @param tick The tick for which to compute the position\n  /// @return wordPos The key in the mapping containing the word in which the bit is stored\n  /// @return bitPos The bit position in the word where the flag is stored\n  function position(int24 tick) private pure returns (int16 wordPos, uint8 bitPos) {\n  unchecked {\n    wordPos = int16(tick >> 8);\n    bitPos = uint8(int8(tick % 256));\n  }\n  }\n\n  /// @notice Flips the initialized state for a given tick from false to true, or vice versa\n  /// @param self The mapping in which to flip the tick\n  /// @param tick The tick to flip\n  /// @param tickSpacing The spacing between usable ticks\n  function flipTick(\n    mapping(int16 => uint256) storage self,\n    int24 tick,\n    int24 tickSpacing\n  ) internal {\n  unchecked {\n    require(tick % tickSpacing == 0);\n    // ensure that the tick is spaced\n    (int16 wordPos, uint8 bitPos) = position(tick / tickSpacing);\n    uint256 mask = 1 << bitPos;\n    self[wordPos] ^= mask;\n  }\n  }\n\n  /// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either\n  /// to the left (less than or equal to) or right (greater than) of the given tick\n  /// @param self The mapping in which to compute the next initialized tick\n  /// @param tick The starting tick\n  /// @param tickSpacing The spacing between usable ticks\n  /// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)\n  /// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick\n  /// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks\n  function nextInitializedTickWithinOneWord(\n    mapping(int16 => uint256) storage self,\n    int24 tick,\n    int24 tickSpacing,\n    bool lte\n  ) internal view returns (int24 next, bool initialized) {\n  unchecked {\n    int24 compressed = tick / tickSpacing;\n    if (tick < 0 && tick % tickSpacing != 0) compressed--;\n    // round towards negative infinity\n\n    if (lte) {\n      (int16 wordPos, uint8 bitPos) = position(compressed);\n      // all the 1s at or to the right of the current bitPos\n      uint256 mask = (1 << bitPos) - 1 + (1 << bitPos);\n      uint256 masked = self[wordPos] & mask;\n\n      // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word\n      initialized = masked != 0;\n      // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n      next = initialized\n      ? (compressed - int24(uint24(bitPos - BitMath.mostSignificantBit(masked)))) * tickSpacing\n      : (compressed - int24(uint24(bitPos))) * tickSpacing;\n    } else {\n      // start from the word of the next tick, since the current tick state doesn't matter\n      (int16 wordPos, uint8 bitPos) = position(compressed + 1);\n      // all the 1s at or to the left of the bitPos\n      uint256 mask = ~((1 << bitPos) - 1);\n      uint256 masked = self[wordPos] & mask;\n\n      // if there are no initialized ticks to the left of the current tick, return leftmost in the word\n      initialized = masked != 0;\n      // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick\n      next = initialized\n      ? (compressed + 1 + int24(uint24(BitMath.leastSignificantBit(masked) - bitPos))) * tickSpacing\n      : (compressed + 1 + int24(uint24(type(uint8).max - bitPos))) * tickSpacing;\n    }\n  }\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n  error T();\n  error R();\n\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\n  int24 internal constant MIN_TICK = - 887272;\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\n  int24 internal constant MAX_TICK = - MIN_TICK;\n\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\n\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\n  /// @dev Throws if |tick| > max tick\n  /// @param tick The input tick for the above formula\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\n  /// at the given tick\n  function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\n  unchecked {\n    uint256 absTick = tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\n    if (absTick > uint256(int256(MAX_TICK))) revert T();\n\n    uint256 ratio = absTick & 0x1 != 0\n    ? 0xfffcb933bd6fad37aa2d162d1a594001\n    : 0x100000000000000000000000000000000;\n    if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\n    if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n    if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n    if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n    if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n    if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n    if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n    if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n    if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n    if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n    if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n    if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n    if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n    if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n    if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n    if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n    if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\n    if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n    if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\n\n    if (tick > 0) ratio = type(uint256).max / ratio;\n\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\n    sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\n  }\n  }\n\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\n  /// ever return.\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\n  function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\n  unchecked {\n    // second inequality must be < because the price can never reach the price at the max tick\n    if (!(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO)) revert R();\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\n\n    uint256 r = ratio;\n    uint256 msb = 0;\n\n    assembly {\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(5, gt(r, 0xFFFFFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(4, gt(r, 0xFFFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(3, gt(r, 0xFF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(2, gt(r, 0xF))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := shl(1, gt(r, 0x3))\n      msb := or(msb, f)\n      r := shr(f, r)\n    }\n    assembly {\n      let f := gt(r, 0x1)\n      msb := or(msb, f)\n    }\n\n    if (msb >= 128) r = ratio >> (msb - 127);\n    else r = ratio << (127 - msb);\n\n    int256 log_2 = (int256(msb) - 128) << 64;\n\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(63, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(62, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(61, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(60, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(59, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(58, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(57, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(56, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(55, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(54, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(53, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(52, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(51, f))\n      r := shr(f, r)\n    }\n    assembly {\n      r := shr(127, mul(r, r))\n      let f := shr(128, r)\n      log_2 := or(log_2, shl(50, f))\n    }\n\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\n    // 128.128 number\n\n    int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\n    int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\n\n    tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\n  }\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport {IERC20Minimal} from '../interfaces/IERC20Minimal.sol';\n\n/// @title TransferHelper\n/// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false\nlibrary TransferHelper {\n  error TF();\n\n  /// @notice Transfers tokens from msg.sender to a recipient\n  /// @dev Calls transfer on token contract, errors with TF if transfer fails\n  /// @param token The contract address of the token which will be transferred\n  /// @param to The recipient of the transfer\n  /// @param value The value of the transfer\n  function safeTransfer(\n    address token,\n    address to,\n    uint256 value\n  ) internal {\n    (bool success, bytes memory data) = token.call(\n      abi.encodeWithSelector(IERC20Minimal.transfer.selector, to, value)\n    );\n    if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert TF();\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n  /// @notice Returns ceil(x / y)\n  /// @dev division by 0 has unspecified behavior, and must be checked externally\n  /// @param x The dividend\n  /// @param y The divisor\n  /// @return z The quotient, ceil(x / y)\n  function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n    assembly {\n      z := add(div(x, y), gt(mod(x, y), 0))\n    }\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/NoDelegateCall.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.12;\n\n/// @title Prevents delegatecall to a contract\n/// @notice Base contract that provides a modifier for preventing delegatecall to methods in a child contract\nabstract contract NoDelegateCall {\n  /// @dev The original address of this contract\n  address private immutable original;\n\n  constructor() {\n    // Immutables are computed in the init code of the contract, and then inlined into the deployed bytecode.\n    // In other words, this variable won't change when it's checked at runtime.\n    original = address(this);\n  }\n\n  /// @dev Private method is used instead of inlining into modifier because modifiers are copied into each method,\n  ///     and the use of immutable means the address bytes are copied in every place the modifier is used.\n  function checkNotDelegateCall() private view {\n    require(address(this) == original);\n  }\n\n  /// @notice Prevents delegatecall into the modified method\n  modifier noDelegateCall() {\n    checkNotDelegateCall();\n    _;\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/UniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.12;\n\nimport {IUniswapV3Factory} from './interfaces/IUniswapV3Factory.sol';\n\nimport {UniswapV3PoolDeployer} from './UniswapV3PoolDeployer.sol';\nimport {NoDelegateCall} from './NoDelegateCall.sol';\n\nimport {UniswapV3Pool} from './UniswapV3Pool.sol';\n\n/// @title Canonical Uniswap V3 factory\n/// @notice Deploys Uniswap V3 pools and manages ownership and control over pool protocol fees\ncontract UniswapV3Factory is IUniswapV3Factory, UniswapV3PoolDeployer, NoDelegateCall {\n  /// @inheritdoc IUniswapV3Factory\n  address public override owner;\n\n  /// @inheritdoc IUniswapV3Factory\n  mapping(uint24 => int24) public override feeAmountTickSpacing;\n  /// @inheritdoc IUniswapV3Factory\n  mapping(address => mapping(address => mapping(uint24 => address))) public override getPool;\n\n  constructor() {\n    owner = msg.sender;\n    emit OwnerChanged(address(0), msg.sender);\n\n    feeAmountTickSpacing[100] = 1;\n    emit FeeAmountEnabled(100, 1);\n    feeAmountTickSpacing[500] = 10;\n    emit FeeAmountEnabled(500, 10);\n    feeAmountTickSpacing[3000] = 60;\n    emit FeeAmountEnabled(3000, 60);\n    feeAmountTickSpacing[10000] = 200;\n    emit FeeAmountEnabled(10000, 200);\n  }\n\n  /// @inheritdoc IUniswapV3Factory\n  function createPool(\n    address tokenA,\n    address tokenB,\n    uint24 fee\n  ) external override noDelegateCall returns (address pool) {\n    require(tokenA != tokenB);\n    // not need to sort tokens in this env, need put exact order on pool creation\n    (address token0, address token1) = /*tokenA < tokenB ? */(tokenA, tokenB)/* : (tokenB, tokenA)*/;\n    require(token0 != address(0));\n    int24 tickSpacing = feeAmountTickSpacing[fee];\n    require(tickSpacing != 0);\n    require(getPool[token0][token1][fee] == address(0));\n    pool = deploy(address(this), token0, token1, fee, tickSpacing);\n    getPool[token0][token1][fee] = pool;\n    // populate mapping in the reverse direction, deliberate choice to avoid the cost of comparing addresses\n    getPool[token1][token0][fee] = pool;\n    emit PoolCreated(token0, token1, fee, tickSpacing, pool);\n  }\n\n  /// @inheritdoc IUniswapV3Factory\n  function setOwner(address _owner) external override {\n    require(msg.sender == owner);\n    emit OwnerChanged(owner, _owner);\n    owner = _owner;\n  }\n\n  /// @inheritdoc IUniswapV3Factory\n  function enableFeeAmount(uint24 fee, int24 tickSpacing) public override {\n    require(msg.sender == owner);\n    require(fee < 1000000);\n    // tick spacing is capped at 16384 to prevent the situation where tickSpacing is so large that\n    // TickBitmap#nextInitializedTickWithinOneWord overflows int24 container from a valid tick\n    // 16384 ticks represents a >5x price change with ticks of 1 bips\n    require(tickSpacing > 0 && tickSpacing < 16384);\n    require(feeAmountTickSpacing[fee] == 0);\n\n    feeAmountTickSpacing[fee] = tickSpacing;\n    emit FeeAmountEnabled(fee, tickSpacing);\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/UniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.12;\n\nimport {IUniswapV3PoolImmutables, IUniswapV3PoolState, IUniswapV3PoolActions, IUniswapV3PoolDerivedState, IUniswapV3PoolOwnerActions, IUniswapV3Pool} from './interfaces/IUniswapV3Pool.sol';\n\nimport {NoDelegateCall} from './NoDelegateCall.sol';\n\nimport {SafeCast} from './libraries/SafeCast.sol';\nimport {Tick} from './libraries/Tick.sol';\nimport {TickBitmap} from './libraries/TickBitmap.sol';\nimport {Position} from './libraries/Position.sol';\nimport {Oracle} from './libraries/Oracle.sol';\n\nimport {FullMath} from './libraries/FullMath.sol';\nimport {FixedPoint128} from './libraries/FixedPoint128.sol';\nimport {TransferHelper} from './libraries/TransferHelper.sol';\nimport {TickMath} from './libraries/TickMath.sol';\nimport {SqrtPriceMath} from './libraries/SqrtPriceMath.sol';\nimport {SwapMath} from './libraries/SwapMath.sol';\n\nimport {IUniswapV3PoolDeployer} from './interfaces/IUniswapV3PoolDeployer.sol';\nimport {IUniswapV3Factory} from './interfaces/IUniswapV3Factory.sol';\nimport {IERC20Minimal} from './interfaces/IERC20Minimal.sol';\nimport {IUniswapV3MintCallback} from './interfaces/callback/IUniswapV3MintCallback.sol';\nimport {IUniswapV3SwapCallback} from './interfaces/callback/IUniswapV3SwapCallback.sol';\nimport {IUniswapV3FlashCallback} from './interfaces/callback/IUniswapV3FlashCallback.sol';\n\ncontract UniswapV3Pool is IUniswapV3Pool, NoDelegateCall {\n  using SafeCast for uint256;\n  using SafeCast for int256;\n  using Tick for mapping(int24 => Tick.Info);\n  using TickBitmap for mapping(int16 => uint256);\n  using Position for mapping(bytes32 => Position.Info);\n  using Position for Position.Info;\n  using Oracle for Oracle.Observation[65535];\n\n  /// @inheritdoc IUniswapV3PoolImmutables\n  address public immutable override factory;\n  /// @inheritdoc IUniswapV3PoolImmutables\n  address public immutable override token0;\n  /// @inheritdoc IUniswapV3PoolImmutables\n  address public immutable override token1;\n  /// @inheritdoc IUniswapV3PoolImmutables\n  uint24 public immutable override fee;\n\n  /// @inheritdoc IUniswapV3PoolImmutables\n  int24 public immutable override tickSpacing;\n\n  /// @inheritdoc IUniswapV3PoolImmutables\n  uint128 public immutable override maxLiquidityPerTick;\n\n  struct Slot0 {\n    // the current price\n    uint160 sqrtPriceX96;\n    // the current tick\n    int24 tick;\n    // the most-recently updated index of the observations array\n    uint16 observationIndex;\n    // the current maximum number of observations that are being stored\n    uint16 observationCardinality;\n    // the next maximum number of observations to store, triggered in observations.write\n    uint16 observationCardinalityNext;\n    // the current protocol fee as a percentage of the swap fee taken on withdrawal\n    // represented as an integer denominator (1/x)%\n    uint8 feeProtocol;\n    // whether the pool is locked\n    bool unlocked;\n  }\n  /// @inheritdoc IUniswapV3PoolState\n  Slot0 public override slot0;\n\n  /// @inheritdoc IUniswapV3PoolState\n  uint256 public override feeGrowthGlobal0X128;\n  /// @inheritdoc IUniswapV3PoolState\n  uint256 public override feeGrowthGlobal1X128;\n\n  // accumulated protocol fees in token0/token1 units\n  struct ProtocolFees {\n    uint128 token0;\n    uint128 token1;\n  }\n  /// @inheritdoc IUniswapV3PoolState\n  ProtocolFees public override protocolFees;\n\n  /// @inheritdoc IUniswapV3PoolState\n  uint128 public override liquidity;\n\n  /// @inheritdoc IUniswapV3PoolState\n  mapping(int24 => Tick.Info) public override ticks;\n  /// @inheritdoc IUniswapV3PoolState\n  mapping(int16 => uint256) public override tickBitmap;\n  /// @inheritdoc IUniswapV3PoolState\n  mapping(bytes32 => Position.Info) public override positions;\n  /// @inheritdoc IUniswapV3PoolState\n  Oracle.Observation[65535] public override observations;\n\n  /// @dev Mutually exclusive reentrancy protection into the pool to/from a method. This method also prevents entrance\n  /// to a function before the pool is initialized. The reentrancy guard is required throughout the contract because\n  /// we use balance checks to determine the payment status of interactions such as mint, swap and flash.\n  modifier lock() {\n    if (!slot0.unlocked) revert LOK();\n    slot0.unlocked = false;\n    _;\n    slot0.unlocked = true;\n  }\n\n  /// @dev Prevents calling a function from anyone except the address returned by IUniswapV3Factory#owner()\n  modifier onlyFactoryOwner() {\n    require(msg.sender == IUniswapV3Factory(factory).owner());\n    _;\n  }\n\n  constructor() {\n    int24 _tickSpacing;\n    (factory, token0, token1, fee, _tickSpacing) = IUniswapV3PoolDeployer(msg.sender).parameters();\n    tickSpacing = _tickSpacing;\n\n    maxLiquidityPerTick = Tick.tickSpacingToMaxLiquidityPerTick(_tickSpacing);\n  }\n\n  /// @dev Common checks for valid tick inputs.\n  function checkTicks(int24 tickLower, int24 tickUpper) private pure {\n    if (tickLower >= tickUpper) revert TLU();\n    if (tickLower < TickMath.MIN_TICK) revert TLM();\n    if (tickUpper > TickMath.MAX_TICK) revert TUM();\n  }\n\n  /// @dev Returns the block timestamp truncated to 32 bits, i.e. mod 2**32. This method is overridden in tests.\n  function _blockTimestamp() internal view virtual returns (uint32) {\n    return uint32(block.timestamp);\n    // truncation is desired\n  }\n\n  /// @dev Get the pool's balance of token0\n  /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n  /// check\n  function balance0() private view returns (uint256) {\n    (bool success, bytes memory data) = token0.staticcall(\n      abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))\n    );\n    require(success && data.length >= 32);\n    return abi.decode(data, (uint256));\n  }\n\n  /// @dev Get the pool's balance of token1\n  /// @dev This function is gas optimized to avoid a redundant extcodesize check in addition to the returndatasize\n  /// check\n  function balance1() private view returns (uint256) {\n    (bool success, bytes memory data) = token1.staticcall(\n      abi.encodeWithSelector(IERC20Minimal.balanceOf.selector, address(this))\n    );\n    require(success && data.length >= 32);\n    return abi.decode(data, (uint256));\n  }\n\n  /// @inheritdoc IUniswapV3PoolDerivedState\n  function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n  external\n  view\n  override\n  noDelegateCall\n  returns (\n    int56 tickCumulativeInside,\n    uint160 secondsPerLiquidityInsideX128,\n    uint32 secondsInside\n  )\n  {\n    checkTicks(tickLower, tickUpper);\n\n    int56 tickCumulativeLower;\n    int56 tickCumulativeUpper;\n    uint160 secondsPerLiquidityOutsideLowerX128;\n    uint160 secondsPerLiquidityOutsideUpperX128;\n    uint32 secondsOutsideLower;\n    uint32 secondsOutsideUpper;\n\n    {\n      Tick.Info storage lower = ticks[tickLower];\n      Tick.Info storage upper = ticks[tickUpper];\n      bool initializedLower;\n      (tickCumulativeLower, secondsPerLiquidityOutsideLowerX128, secondsOutsideLower, initializedLower) = (\n      lower.tickCumulativeOutside,\n      lower.secondsPerLiquidityOutsideX128,\n      lower.secondsOutside,\n      lower.initialized\n      );\n      require(initializedLower);\n\n      bool initializedUpper;\n      (tickCumulativeUpper, secondsPerLiquidityOutsideUpperX128, secondsOutsideUpper, initializedUpper) = (\n      upper.tickCumulativeOutside,\n      upper.secondsPerLiquidityOutsideX128,\n      upper.secondsOutside,\n      upper.initialized\n      );\n      require(initializedUpper);\n    }\n\n    Slot0 memory _slot0 = slot0;\n\n  unchecked {\n    if (_slot0.tick < tickLower) {\n      return (\n      tickCumulativeLower - tickCumulativeUpper,\n      secondsPerLiquidityOutsideLowerX128 - secondsPerLiquidityOutsideUpperX128,\n      secondsOutsideLower - secondsOutsideUpper\n      );\n    } else if (_slot0.tick < tickUpper) {\n      uint32 time = _blockTimestamp();\n      (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(\n        time,\n        0,\n        _slot0.tick,\n        _slot0.observationIndex,\n        liquidity,\n        _slot0.observationCardinality\n      );\n      return (\n      tickCumulative - tickCumulativeLower - tickCumulativeUpper,\n      secondsPerLiquidityCumulativeX128 -\n      secondsPerLiquidityOutsideLowerX128 -\n      secondsPerLiquidityOutsideUpperX128,\n      time - secondsOutsideLower - secondsOutsideUpper\n      );\n    } else {\n      return (\n      tickCumulativeUpper - tickCumulativeLower,\n      secondsPerLiquidityOutsideUpperX128 - secondsPerLiquidityOutsideLowerX128,\n      secondsOutsideUpper - secondsOutsideLower\n      );\n    }\n  }\n  }\n\n  /// @inheritdoc IUniswapV3PoolDerivedState\n  function observe(uint32[] calldata secondsAgos)\n  external\n  view\n  override\n  noDelegateCall\n  returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s)\n  {\n    return\n    observations.observe(\n      _blockTimestamp(),\n      secondsAgos,\n      slot0.tick,\n      slot0.observationIndex,\n      liquidity,\n      slot0.observationCardinality\n    );\n  }\n\n  /// @inheritdoc IUniswapV3PoolActions\n  function increaseObservationCardinalityNext(uint16 observationCardinalityNext)\n  external\n  override\n  lock\n  noDelegateCall\n  {\n    uint16 observationCardinalityNextOld = slot0.observationCardinalityNext;\n    // for the event\n    uint16 observationCardinalityNextNew = observations.grow(\n      observationCardinalityNextOld,\n      observationCardinalityNext\n    );\n    slot0.observationCardinalityNext = observationCardinalityNextNew;\n    if (observationCardinalityNextOld != observationCardinalityNextNew)\n      emit IncreaseObservationCardinalityNext(observationCardinalityNextOld, observationCardinalityNextNew);\n  }\n\n  /// @inheritdoc IUniswapV3PoolActions\n  /// @dev not locked because it initializes unlocked\n  function initialize(uint160 sqrtPriceX96) external override {\n    if (slot0.sqrtPriceX96 != 0) revert AI();\n\n    int24 tick = TickMath.getTickAtSqrtRatio(sqrtPriceX96);\n\n    (uint16 cardinality, uint16 cardinalityNext) = observations.initialize(_blockTimestamp());\n\n    slot0 = Slot0({\n    sqrtPriceX96 : sqrtPriceX96,\n    tick : tick,\n    observationIndex : 0,\n    observationCardinality : cardinality,\n    observationCardinalityNext : cardinalityNext,\n    feeProtocol : 0,\n    unlocked : true\n    });\n\n    emit Initialize(sqrtPriceX96, tick);\n  }\n\n  struct ModifyPositionParams {\n    // the address that owns the position\n    address owner;\n    // the lower and upper tick of the position\n    int24 tickLower;\n    int24 tickUpper;\n    // any change in liquidity\n    int128 liquidityDelta;\n  }\n\n  /// @dev Effect some changes to a position\n  /// @param params the position details and the change to the position's liquidity to effect\n  /// @return position a storage pointer referencing the position with the given owner and tick range\n  /// @return amount0 the amount of token0 owed to the pool, negative if the pool should pay the recipient\n  /// @return amount1 the amount of token1 owed to the pool, negative if the pool should pay the recipient\n  function _modifyPosition(ModifyPositionParams memory params)\n  private\n  noDelegateCall\n  returns (\n    Position.Info storage position,\n    int256 amount0,\n    int256 amount1\n  )\n  {\n    checkTicks(params.tickLower, params.tickUpper);\n\n    Slot0 memory _slot0 = slot0;\n    // SLOAD for gas optimization\n\n    position = _updatePosition(\n      params.owner,\n      params.tickLower,\n      params.tickUpper,\n      params.liquidityDelta,\n      _slot0.tick\n    );\n\n    if (params.liquidityDelta != 0) {\n      if (_slot0.tick < params.tickLower) {\n        // current tick is below the passed range; liquidity can only become in range by crossing from left to\n        // right, when we'll need _more_ token0 (it's becoming more valuable) so user must provide it\n        amount0 = SqrtPriceMath.getAmount0Delta(\n          TickMath.getSqrtRatioAtTick(params.tickLower),\n          TickMath.getSqrtRatioAtTick(params.tickUpper),\n          params.liquidityDelta\n        );\n      } else if (_slot0.tick < params.tickUpper) {\n        // current tick is inside the passed range\n        uint128 liquidityBefore = liquidity;\n        // SLOAD for gas optimization\n\n        // write an oracle entry\n        (slot0.observationIndex, slot0.observationCardinality) = observations.write(\n          _slot0.observationIndex,\n          _blockTimestamp(),\n          _slot0.tick,\n          liquidityBefore,\n          _slot0.observationCardinality,\n          _slot0.observationCardinalityNext\n        );\n\n        amount0 = SqrtPriceMath.getAmount0Delta(\n          _slot0.sqrtPriceX96,\n          TickMath.getSqrtRatioAtTick(params.tickUpper),\n          params.liquidityDelta\n        );\n        amount1 = SqrtPriceMath.getAmount1Delta(\n          TickMath.getSqrtRatioAtTick(params.tickLower),\n          _slot0.sqrtPriceX96,\n          params.liquidityDelta\n        );\n\n        liquidity = params.liquidityDelta < 0\n        ? liquidityBefore - uint128(- params.liquidityDelta)\n        : liquidityBefore + uint128(params.liquidityDelta);\n      } else {\n        // current tick is above the passed range; liquidity can only become in range by crossing from right to\n        // left, when we'll need _more_ token1 (it's becoming more valuable) so user must provide it\n        amount1 = SqrtPriceMath.getAmount1Delta(\n          TickMath.getSqrtRatioAtTick(params.tickLower),\n          TickMath.getSqrtRatioAtTick(params.tickUpper),\n          params.liquidityDelta\n        );\n      }\n    }\n  }\n\n  /// @dev Gets and updates a position with the given liquidity delta\n  /// @param owner the owner of the position\n  /// @param tickLower the lower tick of the position's tick range\n  /// @param tickUpper the upper tick of the position's tick range\n  /// @param tick the current tick, passed to avoid sloads\n  function _updatePosition(\n    address owner,\n    int24 tickLower,\n    int24 tickUpper,\n    int128 liquidityDelta,\n    int24 tick\n  ) private returns (Position.Info storage position) {\n    position = positions.get(owner, tickLower, tickUpper);\n\n    uint256 _feeGrowthGlobal0X128 = feeGrowthGlobal0X128;\n    // SLOAD for gas optimization\n    uint256 _feeGrowthGlobal1X128 = feeGrowthGlobal1X128;\n    // SLOAD for gas optimization\n\n    // if we need to update the ticks, do it\n    bool flippedLower;\n    bool flippedUpper;\n    if (liquidityDelta != 0) {\n      uint32 time = _blockTimestamp();\n      (int56 tickCumulative, uint160 secondsPerLiquidityCumulativeX128) = observations.observeSingle(\n        time,\n        0,\n        slot0.tick,\n        slot0.observationIndex,\n        liquidity,\n        slot0.observationCardinality\n      );\n\n      flippedLower = ticks.update(\n        tickLower,\n        tick,\n        liquidityDelta,\n        _feeGrowthGlobal0X128,\n        _feeGrowthGlobal1X128,\n        secondsPerLiquidityCumulativeX128,\n        tickCumulative,\n        time,\n        false,\n        maxLiquidityPerTick\n      );\n      flippedUpper = ticks.update(\n        tickUpper,\n        tick,\n        liquidityDelta,\n        _feeGrowthGlobal0X128,\n        _feeGrowthGlobal1X128,\n        secondsPerLiquidityCumulativeX128,\n        tickCumulative,\n        time,\n        true,\n        maxLiquidityPerTick\n      );\n\n      if (flippedLower) {\n        tickBitmap.flipTick(tickLower, tickSpacing);\n      }\n      if (flippedUpper) {\n        tickBitmap.flipTick(tickUpper, tickSpacing);\n      }\n    }\n\n    (uint256 feeGrowthInside0X128, uint256 feeGrowthInside1X128) = ticks.getFeeGrowthInside(\n      tickLower,\n      tickUpper,\n      tick,\n      _feeGrowthGlobal0X128,\n      _feeGrowthGlobal1X128\n    );\n\n    position.update(liquidityDelta, feeGrowthInside0X128, feeGrowthInside1X128);\n\n    // clear any tick data that is no longer needed\n    if (liquidityDelta < 0) {\n      if (flippedLower) {\n        ticks.clear(tickLower);\n      }\n      if (flippedUpper) {\n        ticks.clear(tickUpper);\n      }\n    }\n  }\n\n  /// @inheritdoc IUniswapV3PoolActions\n  /// @dev noDelegateCall is applied indirectly via _modifyPosition\n  function mint(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount,\n    bytes calldata data\n  ) external override lock returns (uint256 amount0, uint256 amount1) {\n    require(amount > 0);\n    (, int256 amount0Int, int256 amount1Int) = _modifyPosition(\n      ModifyPositionParams({\n    owner : recipient,\n    tickLower : tickLower,\n    tickUpper : tickUpper,\n    liquidityDelta : int256(uint256(amount)).toInt128()\n    })\n    );\n\n    amount0 = uint256(amount0Int);\n    amount1 = uint256(amount1Int);\n\n    uint256 balance0Before;\n    uint256 balance1Before;\n    if (amount0 > 0) balance0Before = balance0();\n    if (amount1 > 0) balance1Before = balance1();\n    IUniswapV3MintCallback(msg.sender).uniswapV3MintCallback(amount0, amount1, data);\n    if (amount0 > 0 && balance0Before + amount0 > balance0()) revert M0();\n    if (amount1 > 0 && balance1Before + amount1 > balance1()) revert M1();\n\n    emit Mint(msg.sender, recipient, tickLower, tickUpper, amount, amount0, amount1);\n  }\n\n  /// @inheritdoc IUniswapV3PoolActions\n  function collect(\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external override lock returns (uint128 amount0, uint128 amount1) {\n    // we don't need to checkTicks here, because invalid positions will never have non-zero tokensOwed{0,1}\n    Position.Info storage position = positions.get(msg.sender, tickLower, tickUpper);\n\n    amount0 = amount0Requested > position.tokensOwed0 ? position.tokensOwed0 : amount0Requested;\n    amount1 = amount1Requested > position.tokensOwed1 ? position.tokensOwed1 : amount1Requested;\n\n  unchecked {\n    if (amount0 > 0) {\n      position.tokensOwed0 -= amount0;\n      TransferHelper.safeTransfer(token0, recipient, amount0);\n    }\n    if (amount1 > 0) {\n      position.tokensOwed1 -= amount1;\n      TransferHelper.safeTransfer(token1, recipient, amount1);\n    }\n  }\n\n    emit Collect(msg.sender, recipient, tickLower, tickUpper, amount0, amount1);\n  }\n\n  /// @inheritdoc IUniswapV3PoolActions\n  /// @dev noDelegateCall is applied indirectly via _modifyPosition\n  function burn(\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount\n  ) external override lock returns (uint256 amount0, uint256 amount1) {\n  unchecked {\n    (Position.Info storage position, int256 amount0Int, int256 amount1Int) = _modifyPosition(\n      ModifyPositionParams({\n    owner : msg.sender,\n    tickLower : tickLower,\n    tickUpper : tickUpper,\n    liquidityDelta : - int256(uint256(amount)).toInt128()\n    })\n    );\n\n    amount0 = uint256(- amount0Int);\n    amount1 = uint256(- amount1Int);\n\n    if (amount0 > 0 || amount1 > 0) {\n      (position.tokensOwed0, position.tokensOwed1) = (\n      position.tokensOwed0 + uint128(amount0),\n      position.tokensOwed1 + uint128(amount1)\n      );\n    }\n\n    emit Burn(msg.sender, tickLower, tickUpper, amount, amount0, amount1);\n  }\n  }\n\n  struct SwapCache {\n    // the protocol fee for the input token\n    uint8 feeProtocol;\n    // liquidity at the beginning of the swap\n    uint128 liquidityStart;\n    // the timestamp of the current block\n    uint32 blockTimestamp;\n    // the current value of the tick accumulator, computed only if we cross an initialized tick\n    int56 tickCumulative;\n    // the current value of seconds per liquidity accumulator, computed only if we cross an initialized tick\n    uint160 secondsPerLiquidityCumulativeX128;\n    // whether we've computed and cached the above two accumulators\n    bool computedLatestObservation;\n  }\n\n  // the top level state of the swap, the results of which are recorded in storage at the end\n  struct SwapState {\n    // the amount remaining to be swapped in/out of the input/output asset\n    int256 amountSpecifiedRemaining;\n    // the amount already swapped out/in of the output/input asset\n    int256 amountCalculated;\n    // current sqrt(price)\n    uint160 sqrtPriceX96;\n    // the tick associated with the current price\n    int24 tick;\n    // the global fee growth of the input token\n    uint256 feeGrowthGlobalX128;\n    // amount of input token paid as protocol fee\n    uint128 protocolFee;\n    // the current liquidity in range\n    uint128 liquidity;\n  }\n\n  struct StepComputations {\n    // the price at the beginning of the step\n    uint160 sqrtPriceStartX96;\n    // the next tick to swap to from the current tick in the swap direction\n    int24 tickNext;\n    // whether tickNext is initialized or not\n    bool initialized;\n    // sqrt(price) for the next tick (1/0)\n    uint160 sqrtPriceNextX96;\n    // how much is being swapped in in this step\n    uint256 amountIn;\n    // how much is being swapped out\n    uint256 amountOut;\n    // how much fee is being paid in\n    uint256 feeAmount;\n  }\n\n  /// @inheritdoc IUniswapV3PoolActions\n  function swap(\n    address recipient,\n    bool zeroForOne,\n    int256 amountSpecified,\n    uint160 sqrtPriceLimitX96,\n    bytes calldata data\n  ) external override noDelegateCall returns (int256 amount0, int256 amount1) {\n    if (amountSpecified == 0) revert AS();\n\n    Slot0 memory slot0Start = slot0;\n\n    if (!slot0Start.unlocked) revert LOK();\n    require(\n      zeroForOne\n      ? sqrtPriceLimitX96 < slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_RATIO\n      : sqrtPriceLimitX96 > slot0Start.sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_RATIO,\n      'SPL'\n    );\n\n    slot0.unlocked = false;\n\n    SwapCache memory cache = SwapCache({\n    liquidityStart : liquidity,\n    blockTimestamp : _blockTimestamp(),\n    feeProtocol : zeroForOne ? (slot0Start.feeProtocol % 16) : (slot0Start.feeProtocol >> 4),\n    secondsPerLiquidityCumulativeX128 : 0,\n    tickCumulative : 0,\n    computedLatestObservation : false\n    });\n\n    bool exactInput = amountSpecified > 0;\n\n    SwapState memory state = SwapState({\n    amountSpecifiedRemaining : amountSpecified,\n    amountCalculated : 0,\n    sqrtPriceX96 : slot0Start.sqrtPriceX96,\n    tick : slot0Start.tick,\n    feeGrowthGlobalX128 : zeroForOne ? feeGrowthGlobal0X128 : feeGrowthGlobal1X128,\n    protocolFee : 0,\n    liquidity : cache.liquidityStart\n    });\n\n    // continue swapping as long as we haven't used the entire input/output and haven't reached the price limit\n    while (state.amountSpecifiedRemaining != 0 && state.sqrtPriceX96 != sqrtPriceLimitX96) {\n      StepComputations memory step;\n\n      step.sqrtPriceStartX96 = state.sqrtPriceX96;\n\n      (step.tickNext, step.initialized) = tickBitmap.nextInitializedTickWithinOneWord(\n        state.tick,\n        tickSpacing,\n        zeroForOne\n      );\n\n      // ensure that we do not overshoot the min/max tick, as the tick bitmap is not aware of these bounds\n      if (step.tickNext < TickMath.MIN_TICK) {\n        step.tickNext = TickMath.MIN_TICK;\n      } else if (step.tickNext > TickMath.MAX_TICK) {\n        step.tickNext = TickMath.MAX_TICK;\n      }\n\n      // get the price for the next tick\n      step.sqrtPriceNextX96 = TickMath.getSqrtRatioAtTick(step.tickNext);\n\n      // compute values to swap to the target tick, price limit, or point where input/output amount is exhausted\n      (state.sqrtPriceX96, step.amountIn, step.amountOut, step.feeAmount) = SwapMath.computeSwapStep(\n        state.sqrtPriceX96,\n        (zeroForOne ? step.sqrtPriceNextX96 < sqrtPriceLimitX96 : step.sqrtPriceNextX96 > sqrtPriceLimitX96)\n        ? sqrtPriceLimitX96\n        : step.sqrtPriceNextX96,\n        state.liquidity,\n        state.amountSpecifiedRemaining,\n        fee\n      );\n\n      if (exactInput) {\n        // safe because we test that amountSpecified > amountIn + feeAmount in SwapMath\n      unchecked {\n        state.amountSpecifiedRemaining -= (step.amountIn + step.feeAmount).toInt256();\n      }\n        state.amountCalculated -= step.amountOut.toInt256();\n      } else {\n      unchecked {\n        state.amountSpecifiedRemaining += step.amountOut.toInt256();\n      }\n        state.amountCalculated += (step.amountIn + step.feeAmount).toInt256();\n      }\n\n      // if the protocol fee is on, calculate how much is owed, decrement feeAmount, and increment protocolFee\n      if (cache.feeProtocol > 0) {\n      unchecked {\n        uint256 delta = step.feeAmount / cache.feeProtocol;\n        step.feeAmount -= delta;\n        state.protocolFee += uint128(delta);\n      }\n      }\n\n      // update global fee tracker\n      if (state.liquidity > 0) {\n      unchecked {\n        state.feeGrowthGlobalX128 += FullMath.mulDiv(step.feeAmount, FixedPoint128.Q128, state.liquidity);\n      }\n      }\n\n      // shift tick if we reached the next price\n      if (state.sqrtPriceX96 == step.sqrtPriceNextX96) {\n        // if the tick is initialized, run the tick transition\n        if (step.initialized) {\n          // check for the placeholder value, which we replace with the actual value the first time the swap\n          // crosses an initialized tick\n          if (!cache.computedLatestObservation) {\n            (cache.tickCumulative, cache.secondsPerLiquidityCumulativeX128) = observations.observeSingle(\n              cache.blockTimestamp,\n              0,\n              slot0Start.tick,\n              slot0Start.observationIndex,\n              cache.liquidityStart,\n              slot0Start.observationCardinality\n            );\n            cache.computedLatestObservation = true;\n          }\n          int128 liquidityNet = ticks.cross(\n            step.tickNext,\n            (zeroForOne ? state.feeGrowthGlobalX128 : feeGrowthGlobal0X128),\n            (zeroForOne ? feeGrowthGlobal1X128 : state.feeGrowthGlobalX128),\n            cache.secondsPerLiquidityCumulativeX128,\n            cache.tickCumulative,\n            cache.blockTimestamp\n          );\n          // if we're moving leftward, we interpret liquidityNet as the opposite sign\n          // safe because liquidityNet cannot be type(int128).min\n        unchecked {\n          if (zeroForOne) liquidityNet = - liquidityNet;\n        }\n\n          state.liquidity = liquidityNet < 0\n          ? state.liquidity - uint128(- liquidityNet)\n          : state.liquidity + uint128(liquidityNet);\n        }\n\n      unchecked {\n        state.tick = zeroForOne ? step.tickNext - 1 : step.tickNext;\n      }\n      } else if (state.sqrtPriceX96 != step.sqrtPriceStartX96) {\n        // recompute unless we're on a lower tick boundary (i.e. already transitioned ticks), and haven't moved\n        state.tick = TickMath.getTickAtSqrtRatio(state.sqrtPriceX96);\n      }\n    }\n\n    // update tick and write an oracle entry if the tick change\n    if (state.tick != slot0Start.tick) {\n      (uint16 observationIndex, uint16 observationCardinality) = observations.write(\n        slot0Start.observationIndex,\n        cache.blockTimestamp,\n        slot0Start.tick,\n        cache.liquidityStart,\n        slot0Start.observationCardinality,\n        slot0Start.observationCardinalityNext\n      );\n      (slot0.sqrtPriceX96, slot0.tick, slot0.observationIndex, slot0.observationCardinality) = (\n      state.sqrtPriceX96,\n      state.tick,\n      observationIndex,\n      observationCardinality\n      );\n    } else {\n      // otherwise just update the price\n      slot0.sqrtPriceX96 = state.sqrtPriceX96;\n    }\n\n    // update liquidity if it changed\n    if (cache.liquidityStart != state.liquidity) liquidity = state.liquidity;\n\n    // update fee growth global and, if necessary, protocol fees\n    // overflow is acceptable, protocol has to withdraw before it hits type(uint128).max fees\n    if (zeroForOne) {\n      feeGrowthGlobal0X128 = state.feeGrowthGlobalX128;\n    unchecked {\n      if (state.protocolFee > 0) protocolFees.token0 += state.protocolFee;\n    }\n    } else {\n      feeGrowthGlobal1X128 = state.feeGrowthGlobalX128;\n    unchecked {\n      if (state.protocolFee > 0) protocolFees.token1 += state.protocolFee;\n    }\n    }\n\n  unchecked {\n    (amount0, amount1) = zeroForOne == exactInput\n    ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)\n    : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);\n  }\n\n    // do the transfers and collect payment\n    if (zeroForOne) {\n    unchecked {\n      if (amount1 < 0) TransferHelper.safeTransfer(token1, recipient, uint256(- amount1));\n    }\n\n      uint256 balance0Before = balance0();\n      IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);\n      if (balance0Before + uint256(amount0) > balance0()) revert IIA();\n    } else {\n    unchecked {\n      if (amount0 < 0) TransferHelper.safeTransfer(token0, recipient, uint256(- amount0));\n    }\n\n      uint256 balance1Before = balance1();\n      IUniswapV3SwapCallback(msg.sender).uniswapV3SwapCallback(amount0, amount1, data);\n      if (balance1Before + uint256(amount1) > balance1()) revert IIA();\n    }\n\n    emit Swap(msg.sender, recipient, amount0, amount1, state.sqrtPriceX96, state.liquidity, state.tick);\n    slot0.unlocked = true;\n  }\n\n  /// @inheritdoc IUniswapV3PoolActions\n  function flash(\n    address recipient,\n    uint256 amount0,\n    uint256 amount1,\n    bytes calldata data\n  ) external override lock noDelegateCall {\n    uint128 _liquidity = liquidity;\n    if (_liquidity <= 0) revert L();\n\n    uint256 fee0 = FullMath.mulDivRoundingUp(amount0, fee, 1e6);\n    uint256 fee1 = FullMath.mulDivRoundingUp(amount1, fee, 1e6);\n    uint256 balance0Before = balance0();\n    uint256 balance1Before = balance1();\n\n    if (amount0 > 0) TransferHelper.safeTransfer(token0, recipient, amount0);\n    if (amount1 > 0) TransferHelper.safeTransfer(token1, recipient, amount1);\n\n    IUniswapV3FlashCallback(msg.sender).uniswapV3FlashCallback(fee0, fee1, data);\n\n    uint256 balance0After = balance0();\n    uint256 balance1After = balance1();\n\n    if (balance0Before + fee0 > balance0After) revert F0();\n    if (balance1Before + fee1 > balance1After) revert F1();\n\n  unchecked {\n    // sub is safe because we know balanceAfter is gt balanceBefore by at least fee\n    uint256 paid0 = balance0After - balance0Before;\n    uint256 paid1 = balance1After - balance1Before;\n\n    if (paid0 > 0) {\n      uint8 feeProtocol0 = slot0.feeProtocol % 16;\n      uint256 pFees0 = feeProtocol0 == 0 ? 0 : paid0 / feeProtocol0;\n      if (uint128(pFees0) > 0) protocolFees.token0 += uint128(pFees0);\n      feeGrowthGlobal0X128 += FullMath.mulDiv(paid0 - pFees0, FixedPoint128.Q128, _liquidity);\n    }\n    if (paid1 > 0) {\n      uint8 feeProtocol1 = slot0.feeProtocol >> 4;\n      uint256 pFees1 = feeProtocol1 == 0 ? 0 : paid1 / feeProtocol1;\n      if (uint128(pFees1) > 0) protocolFees.token1 += uint128(pFees1);\n      feeGrowthGlobal1X128 += FullMath.mulDiv(paid1 - pFees1, FixedPoint128.Q128, _liquidity);\n    }\n\n    emit Flash(msg.sender, recipient, amount0, amount1, paid0, paid1);\n  }\n  }\n\n  /// @inheritdoc IUniswapV3PoolOwnerActions\n  function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external override lock onlyFactoryOwner {\n  unchecked {\n    require(\n      (feeProtocol0 == 0 || (feeProtocol0 >= 4 && feeProtocol0 <= 10)) &&\n      (feeProtocol1 == 0 || (feeProtocol1 >= 4 && feeProtocol1 <= 10))\n    );\n    uint8 feeProtocolOld = slot0.feeProtocol;\n    slot0.feeProtocol = feeProtocol0 + (feeProtocol1 << 4);\n    emit SetFeeProtocol(feeProtocolOld % 16, feeProtocolOld >> 4, feeProtocol0, feeProtocol1);\n  }\n  }\n\n  /// @inheritdoc IUniswapV3PoolOwnerActions\n  function collectProtocol(\n    address recipient,\n    uint128 amount0Requested,\n    uint128 amount1Requested\n  ) external override lock onlyFactoryOwner returns (uint128 amount0, uint128 amount1) {\n    amount0 = amount0Requested > protocolFees.token0 ? protocolFees.token0 : amount0Requested;\n    amount1 = amount1Requested > protocolFees.token1 ? protocolFees.token1 : amount1Requested;\n\n  unchecked {\n    if (amount0 > 0) {\n      if (amount0 == protocolFees.token0) amount0--;\n      // ensure that the slot is not cleared, for gas savings\n      protocolFees.token0 -= amount0;\n      TransferHelper.safeTransfer(token0, recipient, amount0);\n    }\n    if (amount1 > 0) {\n      if (amount1 == protocolFees.token1) amount1--;\n      // ensure that the slot is not cleared, for gas savings\n      protocolFees.token1 -= amount1;\n      TransferHelper.safeTransfer(token1, recipient, amount1);\n    }\n  }\n\n    emit CollectProtocol(msg.sender, recipient, amount0, amount1);\n  }\n}\n"
    },
    "contracts/test/uniswapv3-core/UniswapV3PoolDeployer.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.8.12;\n\nimport {IUniswapV3PoolDeployer} from './interfaces/IUniswapV3PoolDeployer.sol';\n\nimport {UniswapV3Pool} from './UniswapV3Pool.sol';\n\ncontract UniswapV3PoolDeployer is IUniswapV3PoolDeployer {\n  struct Parameters {\n    address factory;\n    address token0;\n    address token1;\n    uint24 fee;\n    int24 tickSpacing;\n  }\n\n  /// @inheritdoc IUniswapV3PoolDeployer\n  Parameters public override parameters;\n\n  /// @dev Deploys a pool with the given parameters by transiently setting the parameters storage slot and then\n  /// clearing it after deploying the pool.\n  /// @param factory The contract address of the Uniswap V3 factory\n  /// @param token0 The first token of the pool by address sort order\n  /// @param token1 The second token of the pool by address sort order\n  /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n  /// @param tickSpacing The spacing between usable ticks\n  function deploy(\n    address factory,\n    address token0,\n    address token1,\n    uint24 fee,\n    int24 tickSpacing\n  ) internal returns (address pool) {\n    parameters = Parameters({factory : factory, token0 : token0, token1 : token1, fee : fee, tickSpacing : tickSpacing});\n    pool = address(new UniswapV3Pool{salt : keccak256(abi.encode(token0, token1, fee))}());\n    delete parameters;\n  }\n}\n"
    },
    "contracts/test/uniswapv3/UniswapV3Calee.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.12;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"../../integrations/uniswap/IUniswapV3Pool.sol\";\nimport \"../../integrations/uniswap/IUniswapV3MintCallback.sol\";\nimport \"../../integrations/uniswap/IUniswapV3SwapCallback.sol\";\n\ncontract UniswapV3Callee is IUniswapV3MintCallback, IUniswapV3SwapCallback {\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\n  uint160 internal constant MIN_SQRT_RATIO = 4295128739 + 1;\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\n  uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\n\n  function swap(\n    address pool,\n    address recipient,\n    address tokenIn,\n    uint amount\n  ) external {\n    address token0 = IUniswapV3Pool(pool).token0();\n    IUniswapV3Pool(pool).swap(\n      recipient,\n      tokenIn == token0,\n      int(amount),\n      tokenIn == token0 ? MIN_SQRT_RATIO : MAX_SQRT_RATIO,\n      abi.encode(msg.sender)\n    );\n  }\n\n  function mint(\n    address pool,\n    address recipient,\n    int24 tickLower,\n    int24 tickUpper,\n    uint128 amount\n  ) external {\n    IUniswapV3Pool(pool).mint(recipient, tickLower, tickUpper, amount, abi.encode(msg.sender));\n  }\n\n  function uniswapV3SwapCallback(\n    int256 amount0Delta,\n    int256 amount1Delta,\n    bytes calldata data\n  ) external override {\n    address sender = abi.decode(data, (address));\n\n    if (amount0Delta > 0) {\n      IERC20(IUniswapV3Pool(msg.sender).token0()).transferFrom(sender, msg.sender, uint(amount0Delta));\n    } else if (amount1Delta > 0) {\n      IERC20(IUniswapV3Pool(msg.sender).token1()).transferFrom(sender, msg.sender, uint(amount1Delta));\n    }\n  }\n\n  /// @notice Uniswap V3 callback fn, called back on pool.mint\n  function uniswapV3MintCallback(\n    uint amount0Owed,\n    uint amount1Owed,\n    bytes calldata data\n  ) external override {\n    address sender = abi.decode(data, (address));\n    if (amount0Owed > 0) {\n      IERC20(IUniswapV3Pool(msg.sender).token0()).transferFrom(sender, msg.sender, amount0Owed);\n    }\n    if (amount1Owed > 0) {\n      IERC20(IUniswapV3Pool(msg.sender).token1()).transferFrom(sender, msg.sender, amount1Owed);\n    }\n  }\n\n}\n"
    },
    "contracts/tools/RebalanceResolver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/proxy/ControllableV3.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EnumerableSet.sol\";\nimport \"../interfaces/IRebalancingStrategy.sol\";\n\n/// @title Gelato resolver for rebalancing strategies\n/// @author a17\ncontract RebalanceResolver is ControllableV3 {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  // --- CONSTANTS ---\n\n  string public constant VERSION = \"1.0.0\";\n  uint public constant DELAY_RATE_DENOMINATOR = 100_000;\n\n  // --- VARIABLES ---\n\n  address public owner;\n  address public pendingOwner;\n  uint public delay;\n  uint public maxGas;\n\n  mapping(address => uint) internal _lastRebalance;\n  mapping(address => uint) public delayRate;\n  mapping(address => bool) public operators;\n\n  EnumerableSet.AddressSet internal strategies;\n\n  // --- INIT ---\n\n  function init(address controller_) external initializer {\n    ControllableV3.__Controllable_init(controller_);\n\n    owner = msg.sender;\n    delay = 1 minutes;\n    maxGas = 35 gwei;\n  }\n\n  modifier onlyOwner() {\n    require(msg.sender == owner, \"!owner\");\n    _;\n  }\n\n  function allStrategies() external view returns (address[] memory) {\n    return strategies.values();\n  }\n\n  // --- OWNER FUNCTIONS ---\n\n  function offerOwnership(address value) external onlyOwner {\n    pendingOwner = value;\n  }\n\n  function acceptOwnership() external {\n    require(msg.sender == pendingOwner, \"!pendingOwner\");\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n\n  function setDelay(uint value) external onlyOwner {\n    delay = value;\n  }\n\n  function setMaxGas(uint value) external onlyOwner {\n    maxGas = value;\n  }\n\n  function setDelayRate(address[] memory _strategies, uint value) external onlyOwner {\n    for (uint i; i < _strategies.length; ++i) {\n      delayRate[_strategies[i]] = value;\n    }\n  }\n\n  function changeOperatorStatus(address operator, bool status) external onlyOwner {\n    operators[operator] = status;\n  }\n\n  function changeStrategyStatus(address strategy, bool add) external {\n    require(operators[msg.sender], \"!operator\");\n\n    if (add) {\n      require(strategies.add(strategy), 'exist');\n    } else {\n      require(strategies.remove(strategy), '!exist');\n    }\n  }\n\n  // --- MAIN LOGIC ---\n\n  function lastRebalance(address strategy) public view returns (uint lastRebalanceTimestamp) {\n    lastRebalanceTimestamp = _lastRebalance[strategy];\n  }\n\n  function call(address[] memory _strategies) external returns (uint amountOfCalls) {\n    require(operators[msg.sender], \"!operator\");\n\n    uint strategiesLength = _strategies.length;\n    uint counter;\n    for (uint i; i < strategiesLength; ++i) {\n      address strategy = _strategies[i];\n\n      try IRebalancingStrategy(strategy).rebalance() {} catch Error(string memory _err) {\n        revert(string(abi.encodePacked(\"Strategy error: 0x\", _toAsciiString(strategy), \" \", _err)));\n      } catch (bytes memory _err) {\n        revert(string(abi.encodePacked(\"Strategy low-level error: 0x\", _toAsciiString(strategy), \" \", string(_err))));\n      }\n      _lastRebalance[strategy] = block.timestamp;\n      counter++;\n    }\n\n    return counter;\n  }\n\n  function checker() external view returns (bool canExec, bytes memory execPayload) {\n    uint _delay = delay;\n    uint strategiesLength = strategies.length();\n    address[] memory _strategies = new address[](strategiesLength);\n    uint counter;\n    for (uint i; i < strategiesLength; ++i) {\n      address strategy = strategies.at(i);\n\n      uint delayAdjusted = _delay;\n      uint _delayRate = delayRate[strategy];\n      if (_delayRate != 0) {\n        delayAdjusted = _delay * _delayRate / DELAY_RATE_DENOMINATOR;\n      }\n\n      if (IRebalancingStrategy(strategy).needRebalance() && lastRebalance(strategy) + delayAdjusted < block.timestamp) {\n        _strategies[i] = strategy;\n        counter++;\n      }\n    }\n    if (counter == 0) {\n      return (false, bytes(\"No ready strategies\"));\n    } else {\n      address[] memory strategiesResult = new address[](counter);\n      uint j;\n      for (uint i; i < strategiesLength; ++i) {\n        if (_strategies[i] != address(0)) {\n          strategiesResult[j] = _strategies[i];\n          ++j;\n        }\n      }\n      return (true, abi.encodeWithSelector(RebalanceResolver.call.selector, strategiesResult));\n    }\n  }\n\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n  function _toString(uint value) internal pure returns (string memory) {\n    if (value == 0) {\n      return \"0\";\n    }\n    uint temp = value;\n    uint digits;\n    while (temp != 0) {\n      digits++;\n      temp /= 10;\n    }\n    bytes memory buffer = new bytes(digits);\n    while (value != 0) {\n      digits -= 1;\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\n      value /= 10;\n    }\n    return string(buffer);\n  }\n\n  function _toAsciiString(address x) internal pure returns (string memory) {\n    bytes memory s = new bytes(40);\n    for (uint i = 0; i < 20; i++) {\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\n      bytes1 hi = bytes1(uint8(b) / 16);\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\n      s[2 * i] = _char(hi);\n      s[2 * i + 1] = _char(lo);\n    }\n    return string(s);\n  }\n\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\n    else return bytes1(uint8(b) + 0x57);\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 150
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}