{
  "language": "Solidity",
  "sources": {
    "@tetu_io/tetu-contracts-v2/contracts/infrastructure/ControllerV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/EnumerableMap.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title A central contract of the TETU platform.\n///        Holds all important contract addresses.\n///        Able to upgrade proxies with time-lock.\n/// @author belbix\ncontract ControllerV2 is ControllableV3, IController {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  using EnumerableMap for EnumerableMap.UintToUintMap;\n  using EnumerableMap for EnumerableMap.UintToAddressMap;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n  enum AddressType {\n    UNKNOWN, // 0\n    GOVERNANCE, // 1\n    TETU_VOTER, // 2\n    PLATFORM_VOTER, // 3\n    LIQUIDATOR, // 4\n    FORWARDER, // 5\n    INVEST_FUND, // 6\n    VE_DIST // 7\n  }\n\n  struct AddressAnnounce {\n    uint _type;\n    address newAddress;\n    uint timeLockAt;\n  }\n\n  struct ProxyAnnounce {\n    address proxy;\n    address implementation;\n    uint timeLockAt;\n  }\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant CONTROLLER_VERSION = \"2.0.1\";\n  uint public constant TIME_LOCK = 18 hours;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  // --- restrictions\n\n  /// @dev Gnosis safe multi signature wallet with maximum power under the platform.\n  address public override governance;\n  /// @dev Operators can execute not-critical functions of the platform.\n  EnumerableSet.AddressSet internal _operators;\n\n  // --- dependency\n\n  /// @dev Voter for distribute TETU to gauges.\n  address public override voter;\n  /// @dev External solution for sell any tokens with minimal gas usage.\n  address public override liquidator;\n  /// @dev Accumulate performance fees and distribute them properly.\n  address public override forwarder;\n  /// @dev Contract for holding assets for the Second Stage\n  address public override investFund;\n  /// @dev Contract for accumulate TETU rewards for veTETU and weekly distribute them.\n  address public override veDistributor;\n  /// @dev Special voter for platform attributes.\n  address public override platformVoter;\n\n  // --- elements\n\n  /// @dev Set of valid vaults\n  EnumerableSet.AddressSet internal _vaults;\n\n  // --- time locks\n\n  EnumerableMap.UintToUintMap internal _addressTimeLocks;\n  EnumerableMap.UintToAddressMap internal _addressAnnounces;\n\n  EnumerableMap.AddressToUintMap internal _proxyTimeLocks;\n  mapping(address => address) public proxyAnnounces;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event AddressChangeAnnounced(uint _type, address value);\n  event AddressChanged(uint _type, address oldAddress, address newAddress);\n  event AddressAnnounceRemove(uint _type);\n  event ProxyUpgradeAnnounced(address proxy, address implementation);\n  event ProxyUpgraded(address proxy, address implementation);\n  event ProxyAnnounceRemoved(address proxy);\n  event RegisterVault(address vault);\n  event VaultRemoved(address vault);\n  event OperatorAdded(address operator);\n  event OperatorRemoved(address operator);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(address _governance) external initializer {\n    require(_governance != address(0), \"WRONG_INPUT\");\n    governance = _governance;\n    __Controllable_init(address(this));\n    _operators.add(_governance);\n  }\n\n  // *************************************************************\n  //                     RESTRICTIONS\n  // *************************************************************\n\n  function _onlyGovernance() internal view {\n    require(msg.sender == governance, \"DENIED\");\n  }\n\n  function _onlyOperators() internal view {\n    require(_operators.contains(msg.sender), \"DENIED\");\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Return all announced address changes.\n  function addressAnnouncesList() external view returns (AddressAnnounce[] memory announces) {\n    uint length = _addressTimeLocks.length();\n    announces = new AddressAnnounce[](length);\n    for (uint i; i < length; ++i) {\n      (uint _type, uint timeLock) = _addressTimeLocks.at(i);\n      address newAddress = _addressAnnounces.get(_type);\n      announces[i] = AddressAnnounce(_type, newAddress, timeLock);\n    }\n  }\n\n  /// @dev Return all announced proxy upgrades.\n  function proxyAnnouncesList() external view returns (ProxyAnnounce[] memory announces) {\n    uint length = _proxyTimeLocks.length();\n    announces = new ProxyAnnounce[](length);\n    for (uint i; i < length; ++i) {\n      (address proxy, uint timeLock) = _proxyTimeLocks.at(i);\n      address implementation = proxyAnnounces[proxy];\n      announces[i] = ProxyAnnounce(proxy, implementation, timeLock);\n    }\n  }\n\n  /// @dev Return true if the value exist in the operator set.\n  function isOperator(address value) external view override returns (bool) {\n    return _operators.contains(value);\n  }\n\n  /// @dev Return all operators. Expect the array will have reasonable size.\n  function operatorsList() external view returns (address[] memory) {\n    return _operators.values();\n  }\n\n  /// @dev Return all vaults. Array can be too big for use this function.\n  function vaultsList() external view override returns (address[] memory) {\n    return _vaults.values();\n  }\n\n  /// @dev Vault set size.\n  function vaultsListLength() external view override returns (uint) {\n    return _vaults.length();\n  }\n\n  /// @dev Return vault with given id. Ordering can be changed with time!\n  function vaults(uint id) external view override returns (address) {\n    return _vaults.at(id);\n  }\n\n  /// @dev Return true if the vault valid.\n  function isValidVault(address _vault) external view override returns (bool) {\n    return _vaults.contains(_vault);\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLER || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //          SET ADDRESSES WITH TIME-LOCK PROTECTION\n  // *************************************************************\n\n  /// @dev Add announce information for given address type.\n  function announceAddressChange(AddressType _type, address value) external {\n    _onlyGovernance();\n    require(value != address(0), \"ZERO_VALUE\");\n    require(_addressAnnounces.set(uint(_type), value), \"ANNOUNCED\");\n    _addressTimeLocks.set(uint(_type), block.timestamp + TIME_LOCK);\n\n    emit AddressChangeAnnounced(uint(_type), value);\n  }\n\n  /// @dev Change time-locked address and remove lock info.\n  ///      Less strict for reduce governance actions.\n  function changeAddress(AddressType _type) external {\n    _onlyOperators();\n\n    address newAddress = _addressAnnounces.get(uint(_type));\n    uint timeLock = _addressTimeLocks.get(uint(_type));\n    // no need to check values - get for non-exist values will be reverted\n    address oldAddress;\n\n    if (_type == AddressType.GOVERNANCE) {\n      oldAddress = governance;\n      governance = newAddress;\n\n    } else if (_type == AddressType.TETU_VOTER) {\n      oldAddress = voter;\n      voter = newAddress;\n\n    } else if (_type == AddressType.LIQUIDATOR) {\n      oldAddress = liquidator;\n      liquidator = newAddress;\n\n    } else if (_type == AddressType.FORWARDER) {\n      _requireInterface(newAddress, InterfaceIds.I_FORWARDER);\n      oldAddress = forwarder;\n      forwarder = newAddress;\n\n    } else if (_type == AddressType.INVEST_FUND) {\n      oldAddress = investFund;\n      investFund = newAddress;\n\n    } else if (_type == AddressType.VE_DIST) {\n      _requireInterface(newAddress, InterfaceIds.I_VE_DISTRIBUTOR);\n      oldAddress = veDistributor;\n      veDistributor = newAddress;\n\n    } else if (_type == AddressType.PLATFORM_VOTER) {\n      _requireInterface(newAddress, InterfaceIds.I_PLATFORM_VOTER);\n      oldAddress = platformVoter;\n      platformVoter = newAddress;\n    } else {\n      revert(\"UNKNOWN\");\n    }\n\n    // skip time-lock for initialization\n    if (oldAddress != address(0)) {\n      require(timeLock < block.timestamp, \"LOCKED\");\n    }\n\n    _addressAnnounces.remove(uint(_type));\n    _addressTimeLocks.remove(uint(_type));\n\n    emit AddressChanged(uint(_type), oldAddress, newAddress);\n  }\n\n  /// @dev Remove announced address change.\n  function removeAddressAnnounce(AddressType _type) external {\n    _onlyOperators();\n\n    _addressAnnounces.remove(uint(_type));\n    _addressTimeLocks.remove(uint(_type));\n\n    emit AddressAnnounceRemove(uint(_type));\n  }\n\n  // *************************************************************\n  //          UPGRADE PROXIES WITH TIME-LOCK PROTECTION\n  // *************************************************************\n\n  function announceProxyUpgrade(\n    address[] memory proxies,\n    address[] memory implementations\n  ) external {\n    _onlyGovernance();\n    require(proxies.length == implementations.length, \"WRONG_INPUT\");\n\n    for (uint i; i < proxies.length; i++) {\n      address proxy = proxies[i];\n      address implementation = implementations[i];\n\n      require(implementation != address(0), \"ZERO_IMPL\");\n      require(_proxyTimeLocks.set(proxy, block.timestamp + TIME_LOCK), \"ANNOUNCED\");\n      proxyAnnounces[proxy] = implementation;\n\n      emit ProxyUpgradeAnnounced(proxy, implementation);\n    }\n  }\n\n  /// @dev Upgrade proxy. Less strict for reduce governance actions.\n  function upgradeProxy(address[] memory proxies) external {\n    _onlyOperators();\n\n    for (uint i; i < proxies.length; i++) {\n      address proxy = proxies[i];\n      uint timeLock = _proxyTimeLocks.get(proxy);\n      // Map get will revert on not exist key, no need to check to zero\n      address implementation = proxyAnnounces[proxy];\n\n      require(timeLock < block.timestamp, \"LOCKED\");\n\n      IProxyControlled(proxy).upgrade(implementation);\n\n      _proxyTimeLocks.remove(proxy);\n      delete proxyAnnounces[proxy];\n\n      emit ProxyUpgraded(proxy, implementation);\n    }\n  }\n\n  function removeProxyAnnounce(address proxy) external {\n    _onlyOperators();\n\n    _proxyTimeLocks.remove(proxy);\n    delete proxyAnnounces[proxy];\n\n    emit ProxyAnnounceRemoved(proxy);\n  }\n\n  // *************************************************************\n  //                     REGISTER ACTIONS\n  // *************************************************************\n\n  /// @dev Register vault in the system.\n  ///      Operator should do it as part of deployment process.\n  function registerVault(address vault) external {\n    _onlyOperators();\n\n    require(_vaults.add(vault), \"EXIST\");\n    emit RegisterVault(vault);\n  }\n\n  /// @dev Remove vault from the system. Only for critical cases.\n  function removeVault(address vault) external {\n    _onlyGovernance();\n\n    require(_vaults.remove(vault), \"NOT_EXIST\");\n    emit VaultRemoved(vault);\n  }\n\n  /// @dev Register new operator.\n  function registerOperator(address value) external {\n    _onlyGovernance();\n\n    require(_operators.add(value), \"EXIST\");\n    emit OperatorAdded(value);\n  }\n\n  /// @dev Remove operator.\n  function removeOperator(address value) external {\n    _onlyGovernance();\n\n    require(_operators.remove(value), \"NOT_EXIST\");\n    emit OperatorRemoved(value);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/infrastructure/ForwarderV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/EnumerableSet.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/ITetuLiquidator.sol\";\nimport \"../interfaces/IVoter.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../interfaces/IMultiPool.sol\";\nimport \"../interfaces/IBribe.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title This contract should contains a buffer of fees from strategies.\n///        Periodically sell rewards and distribute to their destinations.\n/// @author belbix\ncontract ForwarderV3 is ReentrancyGuard, ControllableV3, IForwarder {\n  using SafeERC20 for IERC20;\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant FORWARDER_VERSION = \"3.0.0\";\n  /// @dev Denominator for different ratios. It is default for the whole platform.\n  uint public constant RATIO_DENOMINATOR = 100_000;\n  /// @dev If slippage not defined for concrete token will be used 5% tolerance.\n  uint public constant DEFAULT_SLIPPAGE = 5_000;\n  /// @dev Max handled destinations from queue per call.\n  uint public constant MAX_DESTINATIONS = 50;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  // -- ratios\n\n  /// @dev Percent of tokens for Invest Fund\n  uint public toInvestFundRatio;\n  /// @dev Percent of tokens for gauges.\n  uint public toGaugesRatio;\n\n  // -- convert options\n\n  /// @dev We will convert all tokens to TETU and distribute to destinations.\n  address public tetu;\n  /// @dev Contract for bribes distribution\n  address public bribe;\n  /// @dev Minimum amount of TETU tokens for distribution.\n  uint public tetuThreshold;\n  /// @dev Specific slippages for volatile tokens.\n  mapping(address => uint) public tokenSlippage;\n\n  // -- registered destinations\n\n  /// @dev Tokens ready for distribution\n  ///      This Set need for easy handle tokens off-chain, can be removed for gas optimisation.\n  EnumerableSet.AddressSet internal _queuedTokens;\n  /// @dev Token => Set of destinations with positive balances for the given token\n  mapping(address => EnumerableSet.AddressSet) internal _destinationQueue;\n  /// @dev Destination => Tokens ready to distribute\n  mapping(address => EnumerableSet.AddressSet) internal _tokensPerDestination;\n  /// @dev Token => Destination => Registered amount\n  mapping(address => mapping(address => uint)) public amountPerDestination;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Distributed(\n    address sender,\n    address incomeToken,\n    uint queuedBalance,\n    uint tetuValue,\n    uint tetuBalance,\n    uint toInvestFund,\n    uint toGauges,\n    uint toBribes\n  );\n  event InvestFundRatioChanged(uint oldValue, uint newValue);\n  event GaugeRatioChanged(uint oldValue, uint newValue);\n  event TetuThresholdChanged(uint oldValue, uint newValue);\n  event SlippageChanged(address token, uint value);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(address controller_, address _tetu, address _bribe) external initializer {\n    _requireInterface(_bribe, InterfaceIds.I_BRIBE);\n    _requireERC20(_tetu);\n    __Controllable_init(controller_);\n    tetu = _tetu;\n    bribe = _bribe;\n    // 10k TETU by default\n    tetuThreshold = 10_000 * 1e18;\n  }\n\n  // *************************************************************\n  //                      GOV ACTIONS\n  // *************************************************************\n\n  /// @dev Check that sender is governance.\n  function _onlyGov() internal view {\n    require(isGovernance(msg.sender), \"DENIED\");\n  }\n\n  /// @dev Set specific token slippage for given token.\n  function setSlippage(address token, uint value) external {\n    _onlyGov();\n    require(value < RATIO_DENOMINATOR, \"TOO_HIGH\");\n\n    tokenSlippage[token] = value;\n    emit SlippageChanged(token, value);\n  }\n\n  /// @dev Set TETU threshold for distribution.\n  function setTetuThreshold(uint value) external {\n    _onlyGov();\n\n    emit TetuThresholdChanged(tetuThreshold, value);\n    tetuThreshold = value;\n  }\n\n  // *************************************************************\n  //                     VOTER ACTIONS\n  // *************************************************************\n\n  /// @dev Check that sender is platform voter.\n  function _onlyPlatformVoter() internal view {\n    require(msg.sender == IController(controller()).platformVoter(), \"DENIED\");\n  }\n\n  /// @dev veTETU holders can change proportion via special voter.\n  function setInvestFundRatio(uint value) external override {\n    _onlyPlatformVoter();\n    require(value <= RATIO_DENOMINATOR, \"TOO_HIGH\");\n\n    emit InvestFundRatioChanged(toInvestFundRatio, value);\n    toInvestFundRatio = value;\n  }\n\n  /// @dev veTETU holders can change proportion via special voter.\n  function setGaugesRatio(uint value) external override {\n    _onlyPlatformVoter();\n    require(value <= RATIO_DENOMINATOR, \"TOO_HIGH\");\n\n    emit GaugeRatioChanged(toGaugesRatio, value);\n    toGaugesRatio = value;\n  }\n\n  // *************************************************************\n  //                         VIEWS\n  // *************************************************************\n\n  /// @dev Size of array of tokens ready for distribution.\n  function queuedTokensLength() external view returns (uint) {\n    return _queuedTokens.length();\n  }\n\n  /// @dev Return queued token address for given id. Ordering can be changed between calls!\n  function queuedTokenAt(uint i) external view returns (address) {\n    return _queuedTokens.at(i);\n  }\n\n  /// @dev Size of array of tokens ready for distribution for given destination.\n  function tokenPerDestinationLength(address destination) public view override returns (uint) {\n    return _tokensPerDestination[destination].length();\n  }\n\n  /// @dev Return queued token address for given id and destination. Ordering can be changed between calls!\n  function tokenPerDestinationAt(address destination, uint i) external view override returns (address) {\n    return _tokensPerDestination[destination].at(i);\n  }\n\n  /// @dev Size of array of destinations for distribution for given token.\n  function destinationsLength(address incomeToken) external view returns (uint) {\n    return _destinationQueue[incomeToken].length();\n  }\n\n  /// @dev Return destination for given income token. Ordering can be changed between calls!\n  function destinationAt(address incomeToken, uint i) external view returns (address) {\n    return _destinationQueue[incomeToken].at(i);\n  }\n\n  /// @dev In case of too many queued destinations `targetTokenThreshold` should be lowered to reasonable value.\n  function getQueuedDestinations(address token) public view returns (\n    address[] memory queuedDestinations,\n    uint[] memory queuedAmounts,\n    uint balance\n  ){\n    EnumerableSet.AddressSet storage destinations = _destinationQueue[token];\n    mapping(address => uint) storage tokenPerDst = amountPerDestination[token];\n    uint length = Math.min(destinations.length(), MAX_DESTINATIONS);\n\n    queuedDestinations = new address[](length);\n    queuedAmounts = new uint[](length);\n    balance = 0;\n    for (uint i; i < length; ++i) {\n      address destination = destinations.at(i);\n      queuedDestinations[i] = destination;\n      uint amount = tokenPerDst[destination];\n      balance += amount;\n      queuedAmounts[i] = amount;\n    }\n  }\n\n  // *************************************************************\n  //                     REGISTER INCOME\n  // *************************************************************\n\n  /// @dev Strategy should call this on reward liquidation after compound part.\n  ///      Register tokens for the given destination.\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vaults,\n    bool isDistribute\n  ) external nonReentrant override {\n\n    for (uint i; i < tokens.length; ++i) {\n      address token = tokens[i];\n      uint amount = amounts[i];\n      IERC20(token).safeTransferFrom(msg.sender, address(this), amount);\n\n      amountPerDestination[token][vaults] += amount;\n      // suppose to be not unique, relatively cheap\n      _destinationQueue[token].add(vaults);\n      _tokensPerDestination[vaults].add(token);\n      _queuedTokens.add(token);\n    }\n\n    // call it on cheap network\n    if (isDistribute) {\n      _distributeAll(vaults);\n    }\n  }\n\n  // *************************************************************\n  //                      DISTRIBUTE\n  // *************************************************************\n\n  function distributeAll(address destination) external nonReentrant override {\n    _distributeAll(destination);\n  }\n\n  function _distributeAll(address destination) internal {\n    address[] memory tokens = _tokensPerDestination[destination].values();\n    uint length = tokens.length;\n    for (uint i; i < length; ++i) {\n      _distribute(tokens[i]);\n    }\n  }\n\n  /// @dev Try to distribute given income token using  a target token from converter.\n  ///      No strict access.\n  ///      We assume that amount will be distributed before accumulate huge value reasonable for arbitrage attack.\n  function distribute(address incomeToken) external nonReentrant override {\n    _distribute(incomeToken);\n  }\n\n  function _distribute(address incomeToken) internal {\n\n    (address[] memory vaults, uint[] memory queuedAmounts, uint queuedBalance)\n    = getQueuedDestinations(incomeToken);\n\n    IController controller_ = IController(controller());\n    address _tetu = tetu;\n\n    (uint tetuBalance, uint tetuValue) = _liquidate(controller_, incomeToken, _tetu, queuedBalance);\n\n    if (tetuBalance != 0) {\n      uint toInvestFund = tetuBalance * toInvestFundRatio / RATIO_DENOMINATOR;\n      uint toGauges = (tetuBalance - toInvestFund) * toGaugesRatio / RATIO_DENOMINATOR;\n      uint toBribes = (tetuBalance - toInvestFund) - toGauges;\n\n      if (toInvestFund != 0) {\n        IERC20(_tetu).safeTransfer(controller_.investFund(), toInvestFund);\n      }\n\n      if (toGauges != 0) {\n        address voter = controller_.voter();\n        IERC20(_tetu).safeApprove(voter, toGauges);\n        IVoter(voter).notifyRewardAmount(toGauges);\n      }\n\n      if (toBribes != 0) {\n        _distributeToBribes(\n          incomeToken,\n          _tetu,\n          vaults,\n          queuedAmounts,\n          queuedBalance,\n          toBribes\n        );\n      }\n\n      emit Distributed(\n        msg.sender,\n        incomeToken,\n        queuedBalance,\n        tetuValue,\n        tetuBalance,\n        toInvestFund,\n        toGauges,\n        toBribes\n      );\n    }\n  }\n\n  function _liquidate(\n    IController controller_,\n    address tokenIn,\n    address _tetu,\n    uint amount\n  ) internal returns (uint boughtTetu, uint tetuValue) {\n\n    if (tokenIn == _tetu) {\n      return (amount, amount);\n    }\n\n    boughtTetu = 0;\n    ITetuLiquidator _liquidator = ITetuLiquidator(controller_.liquidator());\n\n    (ITetuLiquidator.PoolData[] memory route, string memory error)\n    = _liquidator.buildRoute(tokenIn, _tetu);\n\n    if (route.length == 0) {\n      revert(error);\n    }\n\n    // calculate balance in tetu value for check threshold\n    tetuValue = _liquidator.getPriceForRoute(route, amount);\n\n    // if the value higher than threshold distribute to destinations\n    if (tetuValue > tetuThreshold) {\n\n      uint slippage = tokenSlippage[tokenIn];\n      if (slippage == 0) {\n        slippage = DEFAULT_SLIPPAGE;\n      }\n\n      uint tetuBalanceBefore = IERC20(_tetu).balanceOf(address(this));\n\n      _approveIfNeed(tokenIn, address(_liquidator), amount);\n      _liquidator.liquidateWithRoute(route, amount, slippage);\n\n      boughtTetu = IERC20(_tetu).balanceOf(address(this)) - tetuBalanceBefore;\n    }\n  }\n\n  // *************************************************************\n  //                      INTERNAL LOGIC\n  // *************************************************************\n\n\n  function _distributeToBribes(\n    address incomeToken,\n    address tokenToDistribute,\n    address[] memory vaults,\n    uint[] memory queuedAmounts,\n    uint queuedBalance,\n    uint toDistribute\n  ) internal {\n    address _bribe = bribe;\n    uint _epoch = IBribe(_bribe).epoch();\n    _approveIfNeed(tokenToDistribute, _bribe, toDistribute);\n\n    uint remaining = toDistribute;\n    for (uint i; i < vaults.length; i++) {\n      uint toSend = toDistribute * queuedAmounts[i] / queuedBalance;\n      // for avoid rounding issue send all remaining amount\n      if (i == vaults.length - 1) {\n        toSend = remaining;\n      } else {\n        remaining -= toSend;\n      }\n\n      _registerRewardInBribe(_bribe, vaults[i], tokenToDistribute);\n      IBribe(_bribe).notifyForNextEpoch(vaults[i], tokenToDistribute, toSend);\n      IBribe(_bribe).notifyDelayedRewards(vaults[i], tokenToDistribute, _epoch);\n\n      // clear queued data\n      _destinationQueue[incomeToken].remove(vaults[i]);\n      delete amountPerDestination[incomeToken][vaults[i]];\n      _tokensPerDestination[vaults[i]].remove(incomeToken);\n    }\n\n    if (IERC20(incomeToken).balanceOf(address(this)) == 0) {\n      _queuedTokens.remove(incomeToken);\n    }\n  }\n\n  function _registerRewardInBribe(address _bribe, address stakingToken, address rewardToken) internal {\n    if (!IMultiPool(_bribe).isRewardToken(stakingToken, rewardToken)) {\n      IMultiPool(_bribe).registerRewardToken(stakingToken, rewardToken);\n    }\n  }\n\n  function _approveIfNeed(address token, address dst, uint amount) internal {\n    if (IERC20(token).allowance(address(this), dst) < amount) {\n      IERC20(token).safeApprove(dst, 0);\n      IERC20(token).safeApprove(dst, type(uint).max);\n    }\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_FORWARDER || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IBribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IBribe {\n\n  function epoch() external view returns (uint);\n\n  function getReward(\n    address vault,\n    uint veId,\n    address[] memory tokens\n  ) external;\n\n  function getAllRewards(\n    address vault,\n    uint veId\n  ) external;\n\n  function getAllRewardsForTokens(\n    address[] memory vaults,\n    uint veId\n  ) external;\n\n  function deposit(address vault, uint amount, uint tokenId) external;\n\n  function withdraw(address vault, uint amount, uint tokenId) external;\n\n  function notifyRewardAmount(address vault, address token, uint amount) external;\n\n  function notifyForNextEpoch(address vault, address token, uint amount) external;\n\n  function notifyDelayedRewards(address vault, address token, uint _epoch) external;\n\n  function increaseEpoch() external;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IControllable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IControllable {\n\n  function isController(address _contract) external view returns (bool);\n\n  function isGovernance(address _contract) external view returns (bool);\n\n  function created() external view returns (uint256);\n\n  function createdBlock() external view returns (uint256);\n\n  function controller() external view returns (address);\n\n  function increaseRevision(address oldLogic) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IController {\n\n  // --- DEPENDENCY ADDRESSES\n  function governance() external view returns (address);\n\n  function voter() external view returns (address);\n\n  function liquidator() external view returns (address);\n\n  function forwarder() external view returns (address);\n\n  function investFund() external view returns (address);\n\n  function veDistributor() external view returns (address);\n\n  function platformVoter() external view returns (address);\n\n  // --- VAULTS\n\n  function vaults(uint id) external view returns (address);\n\n  function vaultsList() external view returns (address[] memory);\n\n  function vaultsListLength() external view returns (uint);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  // --- restrictions\n\n  function isOperator(address _adr) external view returns (bool);\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n  /**\n   * @dev Returns true if this contract implements the interface defined by\n   * `interfaceId`. See the corresponding\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n   * to learn more about how these ids are created.\n   *\n   * This function call must use less than 30 000 gas.\n   */\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n  /**\n   * @dev Returns the amount of tokens in existence.\n   */\n  function totalSupply() external view returns (uint);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint value);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() external view returns (string memory);\n\n  /**\n   * @dev Returns the symbol of the token.\n     */\n  function symbol() external view returns (string memory);\n\n  /**\n   * @dev Returns the decimals places of the token.\n     */\n  function decimals() external view returns (uint8);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n  /**\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  /**\n   * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n  function nonces(address owner) external view returns (uint256);\n\n  /**\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (interfaces/IERC4626.sol)\n\npragma solidity 0.8.17;\n\nimport \"./IERC20.sol\";\nimport \"./IERC20Metadata.sol\";\n\n/**\n * @dev Interface of the ERC4626 \"Tokenized Vault Standard\", as defined in\n * https://eips.ethereum.org/EIPS/eip-4626[ERC-4626].\n *\n * _Available since v4.7._\n */\ninterface IERC4626 is IERC20, IERC20Metadata {\n  event Deposit(address indexed sender, address indexed owner, uint256 assets, uint256 shares);\n\n  event Withdraw(\n    address indexed sender,\n    address indexed receiver,\n    address indexed owner,\n    uint256 assets,\n    uint256 shares\n  );\n\n  /**\n   * @dev Returns the address of the underlying token used for the Vault for accounting, depositing, and withdrawing.\n     *\n     * - MUST be an ERC-20 token contract.\n     * - MUST NOT revert.\n     */\n  function asset() external view returns (address assetTokenAddress);\n\n  /**\n   * @dev Returns the total amount of the underlying asset that is “managed” by Vault.\n     *\n     * - SHOULD include any compounding that occurs from yield.\n     * - MUST be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT revert.\n     */\n  function totalAssets() external view returns (uint256 totalManagedAssets);\n\n  /**\n   * @dev Returns the amount of shares that the Vault would exchange for the amount of assets provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n  function convertToShares(uint256 assets) external view returns (uint256 shares);\n\n  /**\n   * @dev Returns the amount of assets that the Vault would exchange for the amount of shares provided, in an ideal\n     * scenario where all the conditions are met.\n     *\n     * - MUST NOT be inclusive of any fees that are charged against assets in the Vault.\n     * - MUST NOT show any variations depending on the caller.\n     * - MUST NOT reflect slippage or other on-chain conditions, when performing the actual exchange.\n     * - MUST NOT revert.\n     *\n     * NOTE: This calculation MAY NOT reflect the “per-user” price-per-share, and instead should reflect the\n     * “average-user’s” price-per-share, meaning what the average user should expect to see when exchanging to and\n     * from.\n     */\n  function convertToAssets(uint256 shares) external view returns (uint256 assets);\n\n  /**\n   * @dev Returns the maximum amount of the underlying asset that can be deposited into the Vault for the receiver,\n     * through a deposit call.\n     *\n     * - MUST return a limited value if receiver is subject to some deposit limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of assets that may be deposited.\n     * - MUST NOT revert.\n     */\n  function maxDeposit(address receiver) external view returns (uint256 maxAssets);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their deposit at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of Vault shares that would be minted in a deposit\n     *   call in the same transaction. I.e. deposit should return the same or more shares as previewDeposit if called\n     *   in the same transaction.\n     * - MUST NOT account for deposit limits like those returned from maxDeposit and should always act as though the\n     *   deposit would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewDeposit SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n  function previewDeposit(uint256 assets) external view returns (uint256 shares);\n\n  /**\n   * @dev Mints shares Vault shares to receiver by depositing exactly amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   deposit execution, and are accounted for during deposit.\n     * - MUST revert if all of assets cannot be deposited (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n  function deposit(uint256 assets, address receiver) external returns (uint256 shares);\n\n  /**\n   * @dev Returns the maximum amount of the Vault shares that can be minted for the receiver, through a mint call.\n     * - MUST return a limited value if receiver is subject to some mint limit.\n     * - MUST return 2 ** 256 - 1 if there is no limit on the maximum amount of shares that may be minted.\n     * - MUST NOT revert.\n     */\n  function maxMint(address receiver) external view returns (uint256 maxShares);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their mint at the current block, given\n     * current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of assets that would be deposited in a mint call\n     *   in the same transaction. I.e. mint should return the same or fewer assets as previewMint if called in the\n     *   same transaction.\n     * - MUST NOT account for mint limits like those returned from maxMint and should always act as though the mint\n     *   would be accepted, regardless if the user has enough tokens approved, etc.\n     * - MUST be inclusive of deposit fees. Integrators should be aware of the existence of deposit fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewMint SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by minting.\n     */\n  function previewMint(uint256 shares) external view returns (uint256 assets);\n\n  /**\n   * @dev Mints exactly shares Vault shares to receiver by depositing amount of underlying tokens.\n     *\n     * - MUST emit the Deposit event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the mint\n     *   execution, and are accounted for during mint.\n     * - MUST revert if all of shares cannot be minted (due to deposit limit being reached, slippage, the user not\n     *   approving enough underlying tokens to the Vault contract, etc).\n     *\n     * NOTE: most implementations will require pre-approval of the Vault with the Vault’s underlying asset token.\n     */\n  function mint(uint256 shares, address receiver) external returns (uint256 assets);\n\n  /**\n   * @dev Returns the maximum amount of the underlying asset that can be withdrawn from the owner balance in the\n     * Vault, through a withdraw call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n  function maxWithdraw(address owner) external view returns (uint256 maxAssets);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their withdrawal at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no fewer than the exact amount of Vault shares that would be burned in a withdraw\n     *   call in the same transaction. I.e. withdraw should return the same or fewer shares as previewWithdraw if\n     *   called\n     *   in the same transaction.\n     * - MUST NOT account for withdrawal limits like those returned from maxWithdraw and should always act as though\n     *   the withdrawal would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToShares and previewWithdraw SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by depositing.\n     */\n  function previewWithdraw(uint256 assets) external view returns (uint256 shares);\n\n  /**\n   * @dev Burns shares from owner and sends exactly assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   withdraw execution, and are accounted for during withdraw.\n     * - MUST revert if all of assets cannot be withdrawn (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * Note that some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n  function withdraw(\n    uint256 assets,\n    address receiver,\n    address owner\n  ) external returns (uint256 shares);\n\n  /**\n   * @dev Returns the maximum amount of Vault shares that can be redeemed from the owner balance in the Vault,\n     * through a redeem call.\n     *\n     * - MUST return a limited value if owner is subject to some withdrawal limit or timelock.\n     * - MUST return balanceOf(owner) if owner is not subject to any withdrawal limit or timelock.\n     * - MUST NOT revert.\n     */\n  function maxRedeem(address owner) external view returns (uint256 maxShares);\n\n  /**\n   * @dev Allows an on-chain or off-chain user to simulate the effects of their redeemption at the current block,\n     * given current on-chain conditions.\n     *\n     * - MUST return as close to and no more than the exact amount of assets that would be withdrawn in a redeem call\n     *   in the same transaction. I.e. redeem should return the same or more assets as previewRedeem if called in the\n     *   same transaction.\n     * - MUST NOT account for redemption limits like those returned from maxRedeem and should always act as though the\n     *   redemption would be accepted, regardless if the user has enough shares, etc.\n     * - MUST be inclusive of withdrawal fees. Integrators should be aware of the existence of withdrawal fees.\n     * - MUST NOT revert.\n     *\n     * NOTE: any unfavorable discrepancy between convertToAssets and previewRedeem SHOULD be considered slippage in\n     * share price or some other type of condition, meaning the depositor will lose assets by redeeming.\n     */\n  function previewRedeem(uint256 shares) external view returns (uint256 assets);\n\n  /**\n   * @dev Burns exactly shares from owner and sends assets of underlying tokens to receiver.\n     *\n     * - MUST emit the Withdraw event.\n     * - MAY support an additional flow in which the underlying tokens are owned by the Vault contract before the\n     *   redeem execution, and are accounted for during redeem.\n     * - MUST revert if all of shares cannot be redeemed (due to withdrawal limit being reached, slippage, the owner\n     *   not having enough shares, etc).\n     *\n     * NOTE: some implementations will require pre-requesting to the Vault before a withdrawal may be performed.\n     * Those methods should be performed separately.\n     */\n  function redeem(\n    uint256 shares,\n    address receiver,\n    address owner\n  ) external returns (uint256 assets);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IForwarder {\n\n  function tokenPerDestinationLength(address destination) external view returns (uint);\n\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\n\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vault,\n    bool isDistribute\n  ) external;\n\n  function distributeAll(address destination) external;\n\n  function distribute(address token) external;\n\n  function setInvestFundRatio(uint value) external;\n\n  function setGaugesRatio(uint value) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IGauge {\n\n  function veIds(address stakingToken, address account) external view returns (uint);\n\n  function getReward(\n    address stakingToken,\n    address account,\n    address[] memory tokens\n  ) external;\n\n  function getAllRewards(\n    address stakingToken,\n    address account\n  ) external;\n\n  function getAllRewardsForTokens(\n    address[] memory stakingTokens,\n    address account\n  ) external;\n\n  function attachVe(address stakingToken, address account, uint veId) external;\n\n  function detachVe(address stakingToken, address account, uint veId) external;\n\n  function handleBalanceChange(address account) external;\n\n  function notifyRewardAmount(address stakingToken, address token, uint amount) external;\n\n  function addStakingToken(address token) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IMultiPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IMultiPool {\n\n  function totalSupply(address stakingToken) external view returns (uint);\n\n  function derivedSupply(address stakingToken) external view returns (uint);\n\n  function derivedBalances(address stakingToken, address account) external view returns (uint);\n\n  function balanceOf(address stakingToken, address account) external view returns (uint);\n\n  function rewardTokens(address stakingToken, uint id) external view returns (address);\n\n  function isRewardToken(address stakingToken, address token) external view returns (bool);\n\n  function rewardTokensLength(address stakingToken) external view returns (uint);\n\n  function derivedBalance(address stakingToken, address account) external view returns (uint);\n\n  function left(address stakingToken, address token) external view returns (uint);\n\n  function earned(address stakingToken, address token, address account) external view returns (uint);\n\n  function registerRewardToken(address stakingToken, address token) external;\n\n  function removeRewardToken(address stakingToken, address token) external;\n\n  function isStakeToken(address token) external view returns (bool);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IPlatformVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IPlatformVoter {\n\n  enum AttributeType {\n    UNKNOWN,\n    INVEST_FUND_RATIO,\n    GAUGE_RATIO,\n    STRATEGY_COMPOUND\n  }\n\n  struct Vote {\n    AttributeType _type;\n    address target;\n    uint weight;\n    uint weightedValue;\n    uint timestamp;\n  }\n\n  function detachTokenFromAll(uint tokenId, address owner) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IProxyControlled {\n\n  function initProxy(address _logic) external;\n\n  function upgrade(address _newImplementation) external;\n\n  function implementation() external view returns (address);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISplitter {\n\n  function init(address controller_, address _asset, address _vault) external;\n\n  // *************** ACTIONS **************\n\n  function withdrawAllToVault() external;\n\n  function withdrawToVault(uint256 amount) external;\n\n  function doHardWork() external;\n\n  function investAll() external;\n\n  // **************** VIEWS ***************\n\n  function asset() external view returns (address);\n\n  function vault() external view returns (address);\n\n  function totalAssets() external view returns (uint256);\n\n  function isHardWorking() external view returns (bool);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyStrict.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IStrategyStrict {\n\n  function NAME() external view returns (string memory);\n\n  function PLATFORM() external view returns (string memory);\n\n  function STRATEGY_VERSION() external view returns (string memory);\n\n  function asset() external view returns (address);\n\n  function vault() external view returns (address);\n\n  function compoundRatio() external view returns (uint);\n\n  function totalAssets() external view returns (uint);\n\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\n  function isReadyToHardWork() external view returns (bool);\n\n  function withdrawAllToVault() external;\n\n  function withdrawToVault(uint amount) external;\n\n  function investAll() external;\n\n  function doHardWork() external returns (uint earned, uint lost);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IStrategyV2 {\n\n  function NAME() external view returns (string memory);\n\n  function PLATFORM() external view returns (string memory);\n\n  function STRATEGY_VERSION() external view returns (string memory);\n\n  function asset() external view returns (address);\n\n  function splitter() external view returns (address);\n\n  function compoundRatio() external view returns (uint);\n\n  function totalAssets() external view returns (uint);\n\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\n  function isReadyToHardWork() external view returns (bool);\n\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-withdrawAllToSplitter]\n  function withdrawAllToSplitter() external returns (int totalAssetsDelta);\n\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-withdrawToSplitter]\n  function withdrawToSplitter(uint amount) external returns (int totalAssetsDelta);\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external returns (\n    int totalAssetsDelta\n  );\n\n  function doHardWork() external returns (uint earned, uint lost);\n\n  function setCompoundRatio(uint value) external;\n\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\n  ///         0 means no deposit is allowed at this moment\n  function capacity() external view returns (uint);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface ITetuLiquidator {\n\n  struct PoolData {\n    address pool;\n    address swapper;\n    address tokenIn;\n    address tokenOut;\n  }\n\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\n\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\n\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\n\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\n\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint slippage\n  ) external;\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint slippage\n  ) external;\n\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./IVaultInsurance.sol\";\nimport \"./IERC20.sol\";\n\ninterface ITetuVaultV2 {\n\n  function depositFee() external view returns (uint);\n\n  function withdrawFee() external view returns (uint);\n\n  function init(\n    address controller_,\n    IERC20 _asset,\n    string memory _name,\n    string memory _symbol,\n    address _gauge,\n    uint _buffer\n  ) external;\n\n  function setSplitter(address _splitter) external;\n\n  function coverLoss(uint amount) external;\n\n  function initInsurance(IVaultInsurance _insurance) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVaultInsurance {\n\n  function init(address _vault, address _asset) external;\n\n  function vault() external view returns (address);\n\n  function asset() external view returns (address);\n\n  function transferToVault(uint amount) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeDistributor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVeDistributor {\n\n  function rewardToken() external view returns (address);\n\n  function checkpoint() external;\n\n  function checkpointTotalSupply() external;\n\n  function claim(uint _tokenId) external returns (uint);\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeTetu.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVeTetu {\n\n  enum DepositType {\n    DEPOSIT_FOR_TYPE,\n    CREATE_LOCK_TYPE,\n    INCREASE_LOCK_AMOUNT,\n    INCREASE_UNLOCK_TIME,\n    MERGE_TYPE\n  }\n\n  struct Point {\n    int128 bias;\n    int128 slope; // # -dweight / dt\n    uint ts;\n    uint blk; // block\n  }\n  /* We cannot really do block numbers per se b/c slope is per time, not per block\n  * and per block could be fairly bad b/c Ethereum changes blocktimes.\n  * What we can do is to extrapolate ***At functions */\n\n  function attachments(uint tokenId) external view returns (uint);\n\n  function lockedAmounts(uint veId, address stakingToken) external view returns (uint);\n\n  function lockedDerivedAmount(uint veId) external view returns (uint);\n\n  function lockedEnd(uint veId) external view returns (uint);\n\n  function voted(uint tokenId) external view returns (uint);\n\n  function tokens(uint idx) external view returns (address);\n\n  function balanceOfNFT(uint) external view returns (uint);\n\n  function isApprovedOrOwner(address, uint) external view returns (bool);\n\n  function createLockFor(address _token, uint _value, uint _lockDuration, address _to) external returns (uint);\n\n  function userPointEpoch(uint tokenId) external view returns (uint);\n\n  function epoch() external view returns (uint);\n\n  function userPointHistory(uint tokenId, uint loc) external view returns (Point memory);\n\n  function pointHistory(uint loc) external view returns (Point memory);\n\n  function checkpoint() external;\n\n  function increaseAmount(address _token, uint _tokenId, uint _value) external;\n\n  function attachToken(uint tokenId) external;\n\n  function detachToken(uint tokenId) external;\n\n  function voting(uint tokenId) external;\n\n  function abstain(uint tokenId) external;\n\n  function totalSupplyAt(uint _block) external view returns (uint);\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/interfaces/IVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IVoter {\n\n  function ve() external view returns (address);\n\n  function attachTokenToGauge(address stakingToken, uint _tokenId, address account) external;\n\n  function detachTokenFromGauge(address stakingToken, uint _tokenId, address account) external;\n\n  function distribute(address stakingToken) external;\n\n  function notifyRewardAmount(uint amount) external;\n\n  function detachTokenFromAll(uint tokenId, address account) external;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/FixedPointMathLib.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-only\npragma solidity 0.8.17;\n\n/// @notice Arithmetic library with operations for fixed-point numbers.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/utils/FixedPointMathLib.sol)\n/// @author Inspired by USM (https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol)\nlibrary FixedPointMathLib {\n  /*//////////////////////////////////////////////////////////////\n  //SIMPLIFIED FIXED POINT OPERATIONS\n  //////////////////////////////////////////////////////////////*/\n\n  uint internal constant WAD = 1e18; // The scalar of ETH and most ERC20s.\n\n  function mulWadDown(uint x, uint y) internal pure returns (uint) {\n    return mulDivDown(x, y, WAD);\n    // Equivalent to (x * y) / WAD rounded down.\n  }\n\n  function mulWadUp(uint x, uint y) internal pure returns (uint) {\n    return mulDivUp(x, y, WAD);\n    // Equivalent to (x * y) / WAD rounded up.\n  }\n\n  function divWadDown(uint x, uint y) internal pure returns (uint) {\n    return mulDivDown(x, WAD, y);\n    // Equivalent to (x * WAD) / y rounded down.\n  }\n\n  function divWadUp(uint x, uint y) internal pure returns (uint) {\n    return mulDivUp(x, WAD, y);\n    // Equivalent to (x * WAD) / y rounded up.\n  }\n\n  function positiveInt128(int128 value) internal pure returns (int128) {\n    return value < 0 ? int128(0) : value;\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //LOW LEVEL FIXED POINT OPERATIONS\n  //////////////////////////////////////////////////////////////*/\n\n  function mulDivDown(\n    uint x,\n    uint y,\n    uint denominator\n  ) internal pure returns (uint z) {\n    assembly {\n    // Store x * y in z for now.\n      z := mul(x, y)\n\n    // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n        revert(0, 0)\n      }\n\n    // Divide z by the denominator.\n      z := div(z, denominator)\n    }\n  }\n\n  function mulDivUp(\n    uint x,\n    uint y,\n    uint denominator\n  ) internal pure returns (uint z) {\n    assembly {\n    // Store x * y in z for now.\n      z := mul(x, y)\n\n    // Equivalent to require(denominator != 0 && (x == 0 || (x * y) / x == y))\n      if iszero(and(iszero(iszero(denominator)), or(iszero(x), eq(div(z, x), y)))) {\n        revert(0, 0)\n      }\n\n    // First, divide z - 1 by the denominator and add 1.\n    // We allow z - 1 to underflow if z is 0, because we multiply the\n    // end result by 0 if z is zero, ensuring we return 0 if z is zero.\n      z := mul(iszero(iszero(z)), add(div(sub(z, 1), denominator), 1))\n    }\n  }\n\n  function rpow(\n    uint x,\n    uint n,\n    uint scalar\n  ) internal pure returns (uint z) {\n    assembly {\n      switch x\n      case 0 {\n        switch n\n        case 0 {\n        // 0 ** 0 = 1\n          z := scalar\n        }\n        default {\n        // 0 ** n = 0\n          z := 0\n        }\n      }\n      default {\n        switch mod(n, 2)\n        case 0 {\n        // If n is even, store scalar in z for now.\n          z := scalar\n        }\n        default {\n        // If n is odd, store x in z for now.\n          z := x\n        }\n\n      // Shifting right by 1 is like dividing by 2.\n        let half := shr(1, scalar)\n\n        for {\n        // Shift n right by 1 before looping to halve it.\n          n := shr(1, n)\n        } n {\n        // Shift n right by 1 each iteration to halve it.\n          n := shr(1, n)\n        } {\n        // Revert immediately if x ** 2 would overflow.\n        // Equivalent to iszero(eq(div(xx, x), x)) here.\n          if shr(128, x) {\n            revert(0, 0)\n          }\n\n        // Store x squared.\n          let xx := mul(x, x)\n\n        // Round to the nearest number.\n          let xxRound := add(xx, half)\n\n        // Revert if xx + half overflowed.\n          if lt(xxRound, xx) {\n            revert(0, 0)\n          }\n\n        // Set x to scaled xxRound.\n          x := div(xxRound, scalar)\n\n        // If n is even:\n          if mod(n, 2) {\n          // Compute z * x.\n            let zx := mul(z, x)\n\n          // If z * x overflowed:\n            if iszero(eq(div(zx, x), z)) {\n            // Revert if x is non-zero.\n              if iszero(iszero(x)) {\n                revert(0, 0)\n              }\n            }\n\n          // Round to the nearest number.\n            let zxRound := add(zx, half)\n\n          // Revert if zx + half overflowed.\n            if lt(zxRound, zx) {\n              revert(0, 0)\n            }\n\n          // Return properly scaled zxRound.\n            z := div(zxRound, scalar)\n          }\n        }\n      }\n    }\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  // GENERAL NUMBER UTILITIES\n  //////////////////////////////////////////////////////////////*/\n\n  function sqrt(uint x) internal pure returns (uint z) {\n    assembly {\n    // Start off with z at 1.\n      z := 1\n\n    // Used below to help find a nearby power of 2.\n      let y := x\n\n    // Find the lowest power of 2 that is at least sqrt(x).\n      if iszero(lt(y, 0x100000000000000000000000000000000)) {\n        y := shr(128, y) // Like dividing by 2 ** 128.\n        z := shl(64, z) // Like multiplying by 2 ** 64.\n      }\n      if iszero(lt(y, 0x10000000000000000)) {\n        y := shr(64, y) // Like dividing by 2 ** 64.\n        z := shl(32, z) // Like multiplying by 2 ** 32.\n      }\n      if iszero(lt(y, 0x100000000)) {\n        y := shr(32, y) // Like dividing by 2 ** 32.\n        z := shl(16, z) // Like multiplying by 2 ** 16.\n      }\n      if iszero(lt(y, 0x10000)) {\n        y := shr(16, y) // Like dividing by 2 ** 16.\n        z := shl(8, z) // Like multiplying by 2 ** 8.\n      }\n      if iszero(lt(y, 0x100)) {\n        y := shr(8, y) // Like dividing by 2 ** 8.\n        z := shl(4, z) // Like multiplying by 2 ** 4.\n      }\n      if iszero(lt(y, 0x10)) {\n        y := shr(4, y) // Like dividing by 2 ** 4.\n        z := shl(2, z) // Like multiplying by 2 ** 2.\n      }\n      if iszero(lt(y, 0x8)) {\n      // Equivalent to 2 ** z.\n        z := shl(1, z)\n      }\n\n    // Shifting right by 1 is like dividing by 2.\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n      z := shr(1, add(z, div(x, z)))\n\n    // Compute a rounded down version of z.\n      let zRoundDown := div(x, z)\n\n    // If zRoundDown is smaller, use it.\n      if lt(zRoundDown, z) {\n        z := zRoundDown\n      }\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/InterfaceIds.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for interface IDs\n/// @author bogdoslav\nlibrary InterfaceIds {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant INTERFACE_IDS_LIB_VERSION = \"1.0.0\";\n\n  /// default notation:\n  /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\n\n  /// As type({Interface}).interfaceId can be changed,\n  /// when some functions changed at the interface,\n  /// so used hardcoded interface identifiers\n\n  bytes4 public constant I_VOTER = bytes4(keccak256(\"IVoter\"));\n  bytes4 public constant I_BRIBE = bytes4(keccak256(\"IBribe\"));\n  bytes4 public constant I_GAUGE = bytes4(keccak256(\"IGauge\"));\n  bytes4 public constant I_VE_TETU = bytes4(keccak256(\"IVeTetu\"));\n  bytes4 public constant I_SPLITTER = bytes4(keccak256(\"ISplitter\"));\n  bytes4 public constant I_FORWARDER = bytes4(keccak256(\"IForwarder\"));\n  bytes4 public constant I_MULTI_POOL = bytes4(keccak256(\"IMultiPool\"));\n  bytes4 public constant I_CONTROLLER = bytes4(keccak256(\"IController\"));\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\"ITetuERC165\"));\n  bytes4 public constant I_STRATEGY_V2 = bytes4(keccak256(\"IStrategyV2\"));\n  bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\"IControllable\"));\n  bytes4 public constant I_TETU_VAULT_V2 = bytes4(keccak256(\"ITetuVaultV2\"));\n  bytes4 public constant I_PLATFORM_VOTER = bytes4(keccak256(\"IPlatformVoter\"));\n  bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\"IVeDistributor\"));\n  bytes4 public constant I_TETU_CONVERTER = bytes4(keccak256(\"ITetuConverter\"));\n  bytes4 public constant I_VAULT_INSURANCE = bytes4(keccak256(\"IVaultInsurance\"));\n  bytes4 public constant I_STRATEGY_STRICT = bytes4(keccak256(\"IStrategyStrict\"));\n  bytes4 public constant I_ERC4626 = bytes4(keccak256(\"IERC4626\"));\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/lib/SlotsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\n/// @author bogdoslav\nlibrary SlotsLib {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant SLOT_LIB_VERSION = \"1.0.0\";\n\n  // ************* GETTERS *******************\n\n  /// @dev Gets a slot as bytes32\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as an address\n  function getAddress(bytes32 slot) internal view returns (address result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot as uint256\n  function getUint(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  // ************* ARRAY GETTERS *******************\n\n  /// @dev Gets an array length\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\n    assembly {\n      result := sload(slot)\n    }\n  }\n\n  /// @dev Gets a slot array by index as address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  /// @dev Gets a slot array by index as uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      result := sload(pointer)\n    }\n  }\n\n  // ************* SETTERS *******************\n\n  /// @dev Sets a slot with bytes32\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, bytes32 value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with address\n  /// @notice Check address for 0 at the setter\n  function set(bytes32 slot, address value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  /// @dev Sets a slot with uint\n  function set(bytes32 slot, uint value) internal {\n    assembly {\n      sstore(slot, value)\n    }\n  }\n\n  // ************* ARRAY SETTERS *******************\n\n  /// @dev Sets a slot array at index with address\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, address value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets a slot array at index with uint\n  /// @notice First slot is array length, elements ordered backward in memory\n  /// @notice This is unsafe, without checking array length.\n  function setAt(bytes32 slot, uint index, uint value) internal {\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\n    assembly {\n      sstore(pointer, value)\n    }\n  }\n\n  /// @dev Sets an array length\n  function setLength(bytes32 slot, uint length) internal {\n    assembly {\n      sstore(slot, length)\n    }\n  }\n\n  /// @dev Pushes an address to the array\n  function push(bytes32 slot, address value) internal {\n    uint length = arrayLength(slot);\n    setAt(slot, length, value);\n    setLength(slot, length + 1);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n  /**\n   * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n  function isContract(address account) internal view returns (bool) {\n    // This method relies on extcodesize/address.code.length, which returns 0\n    // for contracts in construction, since the code is only stored at the end\n    // of the constructor execution.\n\n    return account.code.length > 0;\n  }\n\n  /**\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n  function sendValue(address payable recipient, uint256 amount) internal {\n    require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n    (bool success, ) = recipient.call{value: amount}(\"\");\n    require(success, \"Address: unable to send value, recipient may have reverted\");\n  }\n\n  /**\n   * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, 0, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value\n  ) internal returns (bytes memory) {\n    return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n  function functionCallWithValue(\n    address target,\n    bytes memory data,\n    uint256 value,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    require(address(this).balance >= value, \"Address: insufficient balance for call\");\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n    return functionStaticCall(target, data, \"Address: low-level static call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n  function functionStaticCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.staticcall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n    return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n  }\n\n  /**\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n  function functionDelegateCall(\n    address target,\n    bytes memory data,\n    string memory errorMessage\n  ) internal returns (bytes memory) {\n    (bool success, bytes memory returndata) = target.delegatecall(data);\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n  }\n\n  /**\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n  function verifyCallResultFromTarget(\n    address target,\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal view returns (bytes memory) {\n    if (success) {\n      if (returndata.length == 0) {\n        // only check isContract if the call was successful and the return data is empty\n        // otherwise we already know that it was a contract\n        require(isContract(target), \"Address: call to non-contract\");\n      }\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  /**\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n  function verifyCallResult(\n    bool success,\n    bytes memory returndata,\n    string memory errorMessage\n  ) internal pure returns (bytes memory) {\n    if (success) {\n      return returndata;\n    } else {\n      _revert(returndata, errorMessage);\n    }\n  }\n\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\n    // Look for revert reason and bubble it up if present\n    if (returndata.length > 0) {\n      // The easiest way to bubble the revert reason is using memory via assembly\n      /// @solidity memory-safe-assembly\n      assembly {\n        let returndata_size := mload(returndata)\n        revert(add(32, returndata), returndata_size)\n      }\n    } else {\n      revert(errorMessage);\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity 0.8.17;\nimport \"./Initializable.sol\";\n\n/**\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/utils/ContextUpgradeable.sol\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n  function __Context_init() internal onlyInitializing {\n  }\n\n  function __Context_init_unchained() internal onlyInitializing {\n  }\n  function _msgSender() internal view virtual returns (address) {\n    return msg.sender;\n  }\n\n  function _msgData() internal view virtual returns (bytes calldata) {\n    return msg.data;\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[50] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n  struct Counter {\n    // This variable should never be directly accessed by users of the library: interactions must be restricted to\n    // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n    // this feature: see https://github.com/ethereum/solidity/issues/4637\n    uint256 _value; // default: 0\n  }\n\n  function current(Counter storage counter) internal view returns (uint256) {\n    return counter._value;\n  }\n\n  function increment(Counter storage counter) internal {\n  unchecked {\n    counter._value += 1;\n  }\n  }\n\n  function decrement(Counter storage counter) internal {\n    uint256 value = counter._value;\n    require(value > 0, \"Counter: decrement overflow\");\n  unchecked {\n    counter._value = value - 1;\n  }\n  }\n\n  function reset(Counter storage counter) internal {\n    counter._value = 0;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n  enum RecoverError {\n    NoError,\n    InvalidSignature,\n    InvalidSignatureLength,\n    InvalidSignatureS,\n    InvalidSignatureV // Deprecated in v4.8\n  }\n\n  function _throwError(RecoverError error) private pure {\n    if (error == RecoverError.NoError) {\n      return; // no error: do nothing\n    } else if (error == RecoverError.InvalidSignature) {\n      revert(\"ECDSA: invalid signature\");\n    } else if (error == RecoverError.InvalidSignatureLength) {\n      revert(\"ECDSA: invalid signature length\");\n    } else if (error == RecoverError.InvalidSignatureS) {\n      revert(\"ECDSA: invalid signature 's' value\");\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n  function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n    if (signature.length == 65) {\n      bytes32 r;\n      bytes32 s;\n      uint8 v;\n      // ecrecover takes the signature parameters, and the only way to get them\n      // currently is to use assembly.\n      /// @solidity memory-safe-assembly\n      assembly {\n        r := mload(add(signature, 0x20))\n        s := mload(add(signature, 0x40))\n        v := byte(0, mload(add(signature, 0x60)))\n      }\n      return tryRecover(hash, v, r, s);\n    } else {\n      return (address(0), RecoverError.InvalidSignatureLength);\n    }\n  }\n\n  /**\n   * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n  function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, signature);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n  function tryRecover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address, RecoverError) {\n    bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n    uint8 v = uint8((uint256(vs) >> 255) + 27);\n    return tryRecover(hash, v, r, s);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n  function recover(\n    bytes32 hash,\n    bytes32 r,\n    bytes32 vs\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n  function tryRecover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address, RecoverError) {\n    // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n    // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n    // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n    // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n    //\n    // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n    // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n    // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n    // these malleable signatures as well.\n    if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n      return (address(0), RecoverError.InvalidSignatureS);\n    }\n\n    // If the signature is valid (and not malleable), return the signer address\n    address signer = ecrecover(hash, v, r, s);\n    if (signer == address(0)) {\n      return (address(0), RecoverError.InvalidSignature);\n    }\n\n    return (signer, RecoverError.NoError);\n  }\n\n  /**\n   * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n  function recover(\n    bytes32 hash,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal pure returns (address) {\n    (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n    _throwError(error);\n    return recovered;\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n  function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n    // 32 is the length in bytes of hash,\n    // enforced by the type signature above\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n  function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n  }\n\n  /**\n   * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n  function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n    return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/cryptography/EIP712.sol)\n\npragma solidity 0.8.17;\n\nimport \"./ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n    address private immutable _CACHED_THIS;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = block.chainid;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _CACHED_THIS = address(this);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _CACHED_THIS && block.chainid == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n  /* solhint-disable var-name-mixedcase */\n  bytes32 private _HASHED_NAME;\n  bytes32 private _HASHED_VERSION;\n  bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n  /* solhint-enable var-name-mixedcase */\n\n  /**\n   * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n  function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n    __EIP712_init_unchained(name, version);\n  }\n\n  function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n    bytes32 hashedName = keccak256(bytes(name));\n    bytes32 hashedVersion = keccak256(bytes(version));\n    _HASHED_NAME = hashedName;\n    _HASHED_VERSION = hashedVersion;\n  }\n\n  /**\n   * @dev Returns the domain separator for the current chain.\n     */\n  function _domainSeparatorV4() internal view returns (bytes32) {\n    return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n  }\n\n  function _buildDomainSeparator(\n    bytes32 typeHash,\n    bytes32 nameHash,\n    bytes32 versionHash\n  ) private view returns (bytes32) {\n    return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n  }\n\n  /**\n   * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n  function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n    return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n  }\n\n  /**\n   * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n  function _EIP712NameHash() internal virtual view returns (bytes32) {\n    return _HASHED_NAME;\n  }\n\n  /**\n   * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n  function _EIP712VersionHash() internal virtual view returns (bytes32) {\n    return _HASHED_VERSION;\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint256[50] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity 0.8.17;\n\nimport \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n  using EnumerableSet for EnumerableSet.Bytes32Set;\n\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Map type with\n  // bytes32 keys and values.\n  // The Map implementation uses private functions, and user-facing\n  // implementations (such as Uint256ToAddressMap) are just wrappers around\n  // the underlying Map.\n  // This means that we can only create new EnumerableMaps for types that fit\n  // in bytes32.\n\n  struct Bytes32ToBytes32Map {\n    // Storage of keys\n    EnumerableSet.Bytes32Set _keys;\n    mapping(bytes32 => bytes32) _values;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    bytes32 value\n  ) internal returns (bool) {\n    map._values[key] = value;\n    return map._keys.add(key);\n  }\n\n  /**\n   * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n    delete map._values[key];\n    return map._keys.remove(key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n    return map._keys.contains(key);\n  }\n\n  /**\n   * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n  function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n    return map._keys.length();\n  }\n\n  /**\n   * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n    bytes32 key = map._keys.at(index);\n    return (key, map._values[key]);\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n    bytes32 value = map._values[key];\n    if (value == bytes32(0)) {\n      return (contains(map, key), bytes32(0));\n    } else {\n      return (true, value);\n    }\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), \"EnumerableMap: nonexistent key\");\n    return value;\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    Bytes32ToBytes32Map storage map,\n    bytes32 key,\n    string memory errorMessage\n  ) internal view returns (bytes32) {\n    bytes32 value = map._values[key];\n    require(value != 0 || contains(map, key), errorMessage);\n    return value;\n  }\n\n  // UintToUintMap\n\n  struct UintToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    UintToUintMap storage map,\n    uint256 key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(UintToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(key)));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    UintToUintMap storage map,\n    uint256 key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(key), errorMessage));\n  }\n\n  // UintToAddressMap\n\n  struct UintToAddressMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    UintToAddressMap storage map,\n    uint256 key,\n    address value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n    return remove(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n    return contains(map._inner, bytes32(key));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(UintToAddressMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (uint256(key), address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n    return (success, address(uint160(uint256(value))));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key)))));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    UintToAddressMap storage map,\n    uint256 key,\n    string memory errorMessage\n  ) internal view returns (address) {\n    return address(uint160(uint256(get(map._inner, bytes32(key), errorMessage))));\n  }\n\n  // AddressToUintMap\n\n  struct AddressToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    AddressToUintMap storage map,\n    address key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n    return remove(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n    return contains(map._inner, bytes32(uint256(uint160(key))));\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(AddressToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (address(uint160(uint256(key))), uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    AddressToUintMap storage map,\n    address key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, bytes32(uint256(uint160(key))), errorMessage));\n  }\n\n  // Bytes32ToUintMap\n\n  struct Bytes32ToUintMap {\n    Bytes32ToBytes32Map _inner;\n  }\n\n  /**\n   * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n  function set(\n    Bytes32ToUintMap storage map,\n    bytes32 key,\n    uint256 value\n  ) internal returns (bool) {\n    return set(map._inner, key, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n  function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n    return remove(map._inner, key);\n  }\n\n  /**\n   * @dev Returns true if the key is in the map. O(1).\n     */\n  function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n    return contains(map._inner, key);\n  }\n\n  /**\n   * @dev Returns the number of elements in the map. O(1).\n     */\n  function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n    return length(map._inner);\n  }\n\n  /**\n   * @dev Returns the element stored at position `index` in the set. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n    (bytes32 key, bytes32 value) = at(map._inner, index);\n    return (key, uint256(value));\n  }\n\n  /**\n   * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n  function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n    (bool success, bytes32 value) = tryGet(map._inner, key);\n    return (success, uint256(value));\n  }\n\n  /**\n   * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n  function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n    return uint256(get(map._inner, key));\n  }\n\n  /**\n   * @dev Same as {get}, with a custom error message when `key` is not in the map.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryGet}.\n     */\n  function get(\n    Bytes32ToUintMap storage map,\n    bytes32 key,\n    string memory errorMessage\n  ) internal view returns (uint256) {\n    return uint256(get(map._inner, key, errorMessage));\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity 0.8.17;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n  // To implement this library for multiple types with as little code\n  // repetition as possible, we write it in terms of a generic Set type with\n  // bytes32 values.\n  // The Set implementation uses private functions, and user-facing\n  // implementations (such as AddressSet) are just wrappers around the\n  // underlying Set.\n  // This means that we can only create new EnumerableSets for types that fit\n  // in bytes32.\n\n  struct Set {\n    // Storage of set values\n    bytes32[] _values;\n    // Position of the value in the `values` array, plus 1 because index 0\n    // means a value is not in the set.\n    mapping(bytes32 => uint256) _indexes;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function _add(Set storage set, bytes32 value) private returns (bool) {\n    if (!_contains(set, value)) {\n      set._values.push(value);\n      // The value is stored at length-1, but we add 1 to all indexes\n      // and use 0 as a sentinel value\n      set._indexes[value] = set._values.length;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function _remove(Set storage set, bytes32 value) private returns (bool) {\n    // We read and store the value's index to prevent multiple reads from the same storage slot\n    uint256 valueIndex = set._indexes[value];\n\n    if (valueIndex != 0) {\n      // Equivalent to contains(set, value)\n      // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n      // the array, and then remove the last element (sometimes called as 'swap and pop').\n      // This modifies the order of the array, as noted in {at}.\n\n      uint256 toDeleteIndex = valueIndex - 1;\n      uint256 lastIndex = set._values.length - 1;\n\n      if (lastIndex != toDeleteIndex) {\n        bytes32 lastValue = set._values[lastIndex];\n\n        // Move the last value to the index where the value to delete is\n        set._values[toDeleteIndex] = lastValue;\n        // Update the index for the moved value\n        set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n      }\n\n      // Delete the slot where the moved value was stored\n      set._values.pop();\n\n      // Delete the index for the deleted slot\n      delete set._indexes[value];\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function _contains(Set storage set, bytes32 value) private view returns (bool) {\n    return set._indexes[value] != 0;\n  }\n\n  /**\n   * @dev Returns the number of values on the set. O(1).\n     */\n  function _length(Set storage set) private view returns (uint256) {\n    return set._values.length;\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function _at(Set storage set, uint256 index) private view returns (bytes32) {\n    return set._values[index];\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function _values(Set storage set) private view returns (bytes32[] memory) {\n    return set._values;\n  }\n\n  // Bytes32Set\n\n  struct Bytes32Set {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _add(set._inner, value);\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n    return _remove(set._inner, value);\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n    return _contains(set._inner, value);\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(Bytes32Set storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n    return _at(set._inner, index);\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    bytes32[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // AddressSet\n\n  struct AddressSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(AddressSet storage set, address value) internal returns (bool) {\n    return _add(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(AddressSet storage set, address value) internal returns (bool) {\n    return _remove(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(AddressSet storage set, address value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(uint256(uint160(value))));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(AddressSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(AddressSet storage set, uint256 index) internal view returns (address) {\n    return address(uint160(uint256(_at(set._inner, index))));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(AddressSet storage set) internal view returns (address[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    address[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n\n  // UintSet\n\n  struct UintSet {\n    Set _inner;\n  }\n\n  /**\n   * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n  function add(UintSet storage set, uint256 value) internal returns (bool) {\n    return _add(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n  function remove(UintSet storage set, uint256 value) internal returns (bool) {\n    return _remove(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns true if the value is in the set. O(1).\n     */\n  function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n    return _contains(set._inner, bytes32(value));\n  }\n\n  /**\n   * @dev Returns the number of values in the set. O(1).\n     */\n  function length(UintSet storage set) internal view returns (uint256) {\n    return _length(set._inner);\n  }\n\n  /**\n   * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n  function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n    return uint256(_at(set._inner, index));\n  }\n\n  /**\n   * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n  function values(UintSet storage set) internal view returns (uint256[] memory) {\n    bytes32[] memory store = _values(set._inner);\n    uint256[] memory result;\n\n    /// @solidity memory-safe-assembly\n    assembly {\n      result := store\n    }\n\n    return result;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n  /**\n   * @dev See {IERC165-supportsInterface}.\n     */\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == type(IERC165).interfaceId;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/ERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"./Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./ERC20.sol\";\nimport \"./ECDSA.sol\";\nimport \"./EIP712.sol\";\nimport \"./Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity 0.8.17;\n\nimport \"./ERC20Upgradeable.sol\";\nimport \"./ECDSAUpgradeable.sol\";\nimport \"./EIP712Upgradeable.sol\";\nimport \"./CountersUpgradeable.sol\";\nimport \"./Initializable.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20Permit, EIP712Upgradeable {\n  using CountersUpgradeable for CountersUpgradeable.Counter;\n\n  mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 private constant _PERMIT_TYPEHASH =\n  keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n  /**\n   * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n  // solhint-disable-next-line var-name-mixedcase\n  bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n  /**\n   * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n  function __ERC20Permit_init(string memory name) internal onlyInitializing {\n    __EIP712_init_unchained(name, \"1\");\n  }\n\n  function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n  /**\n   * @dev See {IERC20Permit-permit}.\n     */\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) public virtual override {\n    require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n    bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n    bytes32 hash = _hashTypedDataV4(structHash);\n\n    address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n    require(signer == owner, \"ERC20Permit: invalid signature\");\n\n    _approve(owner, spender, value);\n  }\n\n  /**\n   * @dev See {IERC20Permit-nonces}.\n     */\n  function nonces(address owner) public view virtual override returns (uint256) {\n    return _nonces[owner].current();\n  }\n\n  /**\n   * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n  // solhint-disable-next-line func-name-mixedcase\n  function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n    return _domainSeparatorV4();\n  }\n\n  /**\n   * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n  function _useNonce(address owner) internal virtual returns (uint256 current) {\n    CountersUpgradeable.Counter storage nonce = _nonces[owner];\n    current = nonce.current();\n    nonce.increment();\n  }\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint256[49] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Metadata.sol\";\nimport \"./ContextUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20, IERC20Metadata {\n  mapping(address => uint256) private _balances;\n\n  mapping(address => mapping(address => uint256)) internal _allowances;\n\n  uint256 private _totalSupply;\n\n  string private _name;\n  string private _symbol;\n\n  /**\n   * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n  function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n    __ERC20_init_unchained(name_, symbol_);\n  }\n\n  function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n    _name = name_;\n    _symbol = symbol_;\n  }\n\n  /**\n   * @dev Returns the name of the token.\n     */\n  function name() public view virtual override returns (string memory) {\n    return _name;\n  }\n\n  /**\n   * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n  function symbol() public view virtual override returns (string memory) {\n    return _symbol;\n  }\n\n  /**\n   * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n  function decimals() public view virtual override returns (uint8) {\n    return 18;\n  }\n\n  /**\n   * @dev See {IERC20-totalSupply}.\n     */\n  function totalSupply() public view virtual override returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n   * @dev See {IERC20-balanceOf}.\n     */\n  function balanceOf(address account) public view virtual override returns (uint256) {\n    return _balances[account];\n  }\n\n  /**\n   * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n  function transfer(address to, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _transfer(owner, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-allowance}.\n     */\n  function allowance(address owner, address spender) public view virtual override returns (uint256) {\n    return _allowances[owner][spender];\n  }\n\n  /**\n   * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n  function approve(address spender, uint256 amount) public virtual override returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, amount);\n    return true;\n  }\n\n  /**\n   * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 amount\n  ) public virtual override returns (bool) {\n    address spender = _msgSender();\n    _spendAllowance(from, spender, amount);\n    _transfer(from, to, amount);\n    return true;\n  }\n\n  /**\n   * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n  function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    _approve(owner, spender, allowance(owner, spender) + addedValue);\n    return true;\n  }\n\n  /**\n   * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n  function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n    address owner = _msgSender();\n    uint256 currentAllowance = allowance(owner, spender);\n    require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n  unchecked {\n    _approve(owner, spender, currentAllowance - subtractedValue);\n  }\n\n    return true;\n  }\n\n  /**\n   * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n  function _transfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {\n    require(from != address(0), \"ERC20: transfer from the zero address\");\n    require(to != address(0), \"ERC20: transfer to the zero address\");\n\n    _beforeTokenTransfer(from, to, amount);\n\n    uint256 fromBalance = _balances[from];\n    require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n  unchecked {\n    _balances[from] = fromBalance - amount;\n    // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n    // decrementing then incrementing.\n    _balances[to] += amount;\n  }\n\n    emit Transfer(from, to, amount);\n\n    _afterTokenTransfer(from, to, amount);\n  }\n\n  /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n  function _mint(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: mint to the zero address\");\n\n    _beforeTokenTransfer(address(0), account, amount);\n\n    _totalSupply += amount;\n  unchecked {\n    // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n    _balances[account] += amount;\n  }\n    emit Transfer(address(0), account, amount);\n\n    _afterTokenTransfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n  function _burn(address account, uint256 amount) internal virtual {\n    require(account != address(0), \"ERC20: burn from the zero address\");\n\n    _beforeTokenTransfer(account, address(0), amount);\n\n    uint256 accountBalance = _balances[account];\n    require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n  unchecked {\n    _balances[account] = accountBalance - amount;\n    // Overflow not possible: amount <= accountBalance <= totalSupply.\n    _totalSupply -= amount;\n  }\n\n    emit Transfer(account, address(0), amount);\n\n    _afterTokenTransfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n  function _approve(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    require(owner != address(0), \"ERC20: approve from the zero address\");\n    require(spender != address(0), \"ERC20: approve to the zero address\");\n\n    _allowances[owner][spender] = amount;\n    emit Approval(owner, spender, amount);\n  }\n\n  /**\n   * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n  function _spendAllowance(\n    address owner,\n    address spender,\n    uint256 amount\n  ) internal virtual {\n    uint256 currentAllowance = allowance(owner, spender);\n    if (currentAllowance != type(uint256).max) {\n      require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n    unchecked {\n      _approve(owner, spender, currentAllowance - amount);\n    }\n    }\n  }\n\n  /**\n   * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n  function _beforeTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint256 amount\n  ) internal virtual {}\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint256[45] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\n\npragma solidity 0.8.17;\n\nimport \"./Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n  /**\n   * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n  uint8 private _initialized;\n\n  /**\n   * @dev Indicates that the contract is in the process of being initialized.\n     */\n  bool private _initializing;\n\n  /**\n   * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n  event Initialized(uint8 version);\n\n  /**\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\n     * constructor.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier initializer() {\n    bool isTopLevelCall = !_initializing;\n    require(\n      (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n      \"Initializable: contract is already initialized\"\n    );\n    _initialized = 1;\n    if (isTopLevelCall) {\n      _initializing = true;\n    }\n    _;\n    if (isTopLevelCall) {\n      _initializing = false;\n      emit Initialized(1);\n    }\n  }\n\n  /**\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n  modifier reinitializer(uint8 version) {\n    require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n    _initialized = version;\n    _initializing = true;\n    _;\n    _initializing = false;\n    emit Initialized(version);\n  }\n\n  /**\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n  modifier onlyInitializing() {\n    require(_initializing, \"Initializable: contract is not initializing\");\n    _;\n  }\n\n  /**\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n  function _disableInitializers() internal virtual {\n    require(!_initializing, \"Initializable: contract is initializing\");\n    if (_initialized != type(uint8).max) {\n      _initialized = type(uint8).max;\n      emit Initialized(type(uint8).max);\n    }\n  }\n\n  /**\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n  function _getInitializedVersion() internal view returns (uint8) {\n    return _initialized;\n  }\n\n  /**\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n  function _isInitializing() internal view returns (bool) {\n    return _initializing;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n  enum Rounding {\n    Down, // Toward negative infinity\n    Up, // Toward infinity\n    Zero // Toward zero\n  }\n\n  /**\n   * @dev Returns the largest of two numbers.\n     */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n     */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b) / 2 can overflow.\n    return (a & b) + (a ^ b) / 2;\n  }\n\n  /**\n   * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n    // (a + b - 1) / b can overflow on addition, so we distribute.\n    return a == 0 ? 0 : (a - 1) / b + 1;\n  }\n\n  /**\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator\n  ) internal pure returns (uint256 result) {\n  unchecked {\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n    // variables such that product = prod1 * 2^256 + prod0.\n    uint256 prod0; // Least significant 256 bits of the product\n    uint256 prod1; // Most significant 256 bits of the product\n    assembly {\n      let mm := mulmod(x, y, not(0))\n      prod0 := mul(x, y)\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n    }\n\n    // Handle non-overflow cases, 256 by 256 division.\n    if (prod1 == 0) {\n      return prod0 / denominator;\n    }\n\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\n    require(denominator > prod1, \"Math: mulDiv overflow\");\n\n    ///////////////////////////////////////////////\n    // 512 by 256 division.\n    ///////////////////////////////////////////////\n\n    // Make division exact by subtracting the remainder from [prod1 prod0].\n    uint256 remainder;\n    assembly {\n    // Compute remainder using mulmod.\n      remainder := mulmod(x, y, denominator)\n\n    // Subtract 256 bit number from 512 bit number.\n      prod1 := sub(prod1, gt(remainder, prod0))\n      prod0 := sub(prod0, remainder)\n    }\n\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n    // See https://cs.stackexchange.com/q/138556/92363.\n\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\n    uint256 twos = denominator & (~denominator + 1);\n    assembly {\n    // Divide denominator by twos.\n      denominator := div(denominator, twos)\n\n    // Divide [prod1 prod0] by twos.\n      prod0 := div(prod0, twos)\n\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n      twos := add(div(sub(0, twos), twos), 1)\n    }\n\n    // Shift in bits from prod1 into prod0.\n    prod0 |= prod1 * twos;\n\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n    // four bits. That is, denominator * inv = 1 mod 2^4.\n    uint256 inverse = (3 * denominator) ^ 2;\n\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n    // in modular arithmetic, doubling the correct bits in each step.\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n    // is no longer required.\n    result = prod0 * inverse;\n    return result;\n  }\n  }\n\n  /**\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n  function mulDiv(\n    uint256 x,\n    uint256 y,\n    uint256 denominator,\n    Rounding rounding\n  ) internal pure returns (uint256) {\n    uint256 result = mulDiv(x, y, denominator);\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n      result += 1;\n    }\n    return result;\n  }\n\n  /**\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n  function sqrt(uint256 a) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n    //\n    // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n    //\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n    // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n    // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n    //\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n    uint256 result = 1 << (log2(a) >> 1);\n\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n    // into the expected uint128 result.\n  unchecked {\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    result = (result + a / result) >> 1;\n    return min(result, a / result);\n  }\n  }\n\n  /**\n   * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = sqrt(a);\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 128;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 64;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 32;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 16;\n    }\n    if (value >> 8 > 0) {\n      value >>= 8;\n      result += 8;\n    }\n    if (value >> 4 > 0) {\n      value >>= 4;\n      result += 4;\n    }\n    if (value >> 2 > 0) {\n      value >>= 2;\n      result += 2;\n    }\n    if (value >> 1 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log2(value);\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >= 10**64) {\n      value /= 10**64;\n      result += 64;\n    }\n    if (value >= 10**32) {\n      value /= 10**32;\n      result += 32;\n    }\n    if (value >= 10**16) {\n      value /= 10**16;\n      result += 16;\n    }\n    if (value >= 10**8) {\n      value /= 10**8;\n      result += 8;\n    }\n    if (value >= 10**4) {\n      value /= 10**4;\n      result += 4;\n    }\n    if (value >= 10**2) {\n      value /= 10**2;\n      result += 2;\n    }\n    if (value >= 10**1) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log10(value);\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\n  }\n  }\n\n  /**\n   * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n  function log256(uint256 value) internal pure returns (uint256) {\n    uint256 result = 0;\n  unchecked {\n    if (value >> 128 > 0) {\n      value >>= 128;\n      result += 16;\n    }\n    if (value >> 64 > 0) {\n      value >>= 64;\n      result += 8;\n    }\n    if (value >> 32 > 0) {\n      value >>= 32;\n      result += 4;\n    }\n    if (value >> 16 > 0) {\n      value >>= 16;\n      result += 2;\n    }\n    if (value >> 8 > 0) {\n      result += 1;\n    }\n  }\n    return result;\n  }\n\n  /**\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n  unchecked {\n    uint256 result = log256(value);\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n  }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n  /**\n   * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n  function _delegate(address implementation) internal virtual {\n    assembly {\n    // Copy msg.data. We take full control of memory in this inline assembly\n    // block because it will not return to Solidity code. We overwrite the\n    // Solidity scratch pad at memory position 0.\n      calldatacopy(0, 0, calldatasize())\n\n    // Call the implementation.\n    // out and outsize are 0 because we don't know the size yet.\n      let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n    // Copy the returned data.\n      returndatacopy(0, 0, returndatasize())\n\n      switch result\n      // delegatecall returns 0 on error.\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return (0, returndatasize())\n      }\n    }\n  }\n\n  /**\n   * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n  function _implementation() internal view virtual returns (address);\n\n  /**\n   * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n  function _fallback() internal virtual {\n    _beforeFallback();\n    _delegate(_implementation());\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n  fallback() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n  receive() external payable virtual {\n    _fallback();\n  }\n\n  /**\n   * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n  function _beforeFallback() internal virtual {}\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (security/ReentrancyGuard.sol)\n\npragma solidity 0.8.17;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n  // Booleans are more expensive than uint256 or any type that takes up a full\n  // word because each write operation emits an extra SLOAD to first read the\n  // slot's contents, replace the bits taken up by the boolean, and then write\n  // back. This is the compiler's defense against contract upgrades and\n  // pointer aliasing, and it cannot be disabled.\n\n  // The values being non-zero value makes deployment a bit more expensive,\n  // but in exchange the refund on every call to nonReentrant will be lower in\n  // amount. Since refunds are capped to a percentage of the total\n  // transaction's gas, it is best to keep them low in cases like this one, to\n  // increase the likelihood of the full refund coming into effect.\n  uint256 private constant _NOT_ENTERED = 1;\n  uint256 private constant _ENTERED = 2;\n\n  uint256 private _status;\n\n  constructor() {\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n  modifier nonReentrant() {\n    _nonReentrantBefore();\n    _;\n    _nonReentrantAfter();\n  }\n\n  function _nonReentrantBefore() private {\n    // On the first call to nonReentrant, _status will be _NOT_ENTERED\n    require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n    // Any calls to nonReentrant after this point will fail\n    _status = _ENTERED;\n  }\n\n  function _nonReentrantAfter() private {\n    // By storing the original value once again, a refund is triggered (see\n    // https://eips.ethereum.org/EIPS/eip-2200)\n    _status = _NOT_ENTERED;\n  }\n\n  /**\n   * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n  function _reentrancyGuardEntered() internal view returns (bool) {\n    return _status == _ENTERED;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n  using Address for address;\n\n  function safeTransfer(\n    IERC20 token,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n  }\n\n  function safeTransferFrom(\n    IERC20 token,\n    address from,\n    address to,\n    uint256 value\n  ) internal {\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n  }\n\n  /**\n   * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n  function safeApprove(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    // safeApprove should only be called when setting an initial allowance,\n    // or when resetting it to zero. To increase and decrease it, use\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n    require(\n      (value == 0) || (token.allowance(address(this), spender) == 0),\n      \"SafeERC20: approve from non-zero to non-zero allowance\"\n    );\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n  }\n\n  function safeIncreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n\n  function safeDecreaseAllowance(\n    IERC20 token,\n    address spender,\n    uint256 value\n  ) internal {\n  unchecked {\n    uint256 oldAllowance = token.allowance(address(this), spender);\n    require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n    uint256 newAllowance = oldAllowance - value;\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n  }\n  }\n\n  function safePermit(\n    IERC20Permit token,\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) internal {\n    uint256 nonceBefore = token.nonces(owner);\n    token.permit(owner, spender, value, deadline, v, r, s);\n    uint256 nonceAfter = token.nonces(owner);\n    require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n  }\n\n  /**\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n    // the target address contains contract code and also asserts for success in the low-level call.\n\n    bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n    if (returndata.length > 0) {\n      // Return data is optional\n      require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Math.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n  bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n  uint8 private constant _ADDRESS_LENGTH = 20;\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n  function toString(uint256 value) internal pure returns (string memory) {\n  unchecked {\n    uint256 length = Math.log10(value) + 1;\n    string memory buffer = new string(length);\n    uint256 ptr;\n    /// @solidity memory-safe-assembly\n    assembly {\n      ptr := add(buffer, add(32, length))\n    }\n    while (true) {\n      ptr--;\n      /// @solidity memory-safe-assembly\n      assembly {\n        mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n      }\n      value /= 10;\n      if (value == 0) break;\n    }\n    return buffer;\n  }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n  function toHexString(uint256 value) internal pure returns (string memory) {\n  unchecked {\n    return toHexString(value, Math.log256(value) + 1);\n  }\n  }\n\n  /**\n   * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n  function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n    bytes memory buffer = new bytes(2 * length + 2);\n    buffer[0] = \"0\";\n    buffer[1] = \"x\";\n    for (uint256 i = 2 * length + 1; i > 1; --i) {\n      buffer[i] = _SYMBOLS[value & 0xf];\n      value >>= 4;\n    }\n    require(value == 0, \"Strings: hex length insufficient\");\n    return string(buffer);\n  }\n\n  /**\n   * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n  function toHexString(address addr) internal pure returns (string memory) {\n    return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/ControllableV3.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Initializable.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/SlotsLib.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Implement basic functionality for any contract that require strict control\n/// @dev Can be used with upgradeable pattern.\n///      Require call __Controllable_init() in any case.\n/// @author belbix\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\n  using SlotsLib for bytes32;\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant CONTROLLABLE_VERSION = \"3.0.0\";\n\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.controller\")) - 1);\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created\")) - 1);\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.created_block\")) - 1);\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.revision\")) - 1);\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\"eip1967.controllable.prev_logic\")) - 1);\n\n  event ContractInitialized(address controller, uint ts, uint block);\n  event RevisionIncreased(uint value, address oldLogic);\n\n  /// @dev Prevent implementation init\n  constructor() {\n    _disableInitializers();\n  }\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  ///         Save block.timestamp in the \"created\" variable\n  /// @dev Use it only once after first logic setup\n  /// @param controller_ Controller address\n  function __Controllable_init(address controller_) internal onlyInitializing {\n    require(controller_ != address(0), \"Zero controller\");\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\n    require(IController(controller_).governance() != address(0), \"Zero governance\");\n    _CONTROLLER_SLOT.set(controller_);\n    _CREATED_SLOT.set(block.timestamp);\n    _CREATED_BLOCK_SLOT.set(block.number);\n    emit ContractInitialized(controller_, block.timestamp, block.number);\n  }\n\n  /// @dev Return true if given address is controller\n  function isController(address _value) public override view returns (bool) {\n    return _value == controller();\n  }\n\n  /// @notice Return true if given address is setup as governance in Controller\n  function isGovernance(address _value) public override view returns (bool) {\n    return IController(controller()).governance() == _value;\n  }\n\n  /// @dev Contract upgrade counter\n  function revision() external view returns (uint){\n    return _REVISION_SLOT.getUint();\n  }\n\n  /// @dev Previous logic implementation\n  function previousImplementation() external view returns (address){\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\n  }\n\n  // ************* SETTERS/GETTERS *******************\n\n  /// @notice Return controller address saved in the contract slot\n  function controller() public view override returns (address) {\n    return _CONTROLLER_SLOT.getAddress();\n  }\n\n  /// @notice Return creation timestamp\n  /// @return Creation timestamp\n  function created() external view override returns (uint256) {\n    return _CREATED_SLOT.getUint();\n  }\n\n  /// @notice Return creation block number\n  /// @return Creation block number\n  function createdBlock() external override view returns (uint256) {\n    return _CREATED_BLOCK_SLOT.getUint();\n  }\n\n  /// @dev Revision should be increased on each contract upgrade\n  function increaseRevision(address oldLogic) external override {\n    require(msg.sender == address(this), \"Increase revision forbidden\");\n    uint r = _REVISION_SLOT.getUint() + 1;\n    _REVISION_SLOT.set(r);\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\n    emit RevisionIncreased(r, oldLogic);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/ProxyControlled.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IControllable.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"./UpgradeableProxy.sol\";\nimport \"../interfaces/IERC165.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title EIP1967 Upgradable proxy implementation.\n/// @dev Only Controller has access and should implement time-lock for upgrade action.\n/// @author belbix\ncontract ProxyControlled is UpgradeableProxy, IProxyControlled {\n\n  /// @notice Version of the contract\n  /// @dev Should be incremented when contract changed\n  string public constant PROXY_CONTROLLED_VERSION = \"1.0.1\";\n\n  /// @dev Initialize proxy implementation. Need to call after deploy new proxy.\n  function initProxy(address _logic) external override {\n    //make sure that given logic is controllable and not inited\n    require(IERC165(_logic).supportsInterface(InterfaceIds.I_CONTROLLABLE), \"Proxy: Wrong implementation\");\n    _init(_logic);\n  }\n\n  /// @notice Upgrade contract logic\n  /// @dev Upgrade allowed only for Controller and should be done only after time-lock period\n  /// @param _newImplementation Implementation address\n  function upgrade(address _newImplementation) external override {\n    require(IERC165(_newImplementation).supportsInterface(InterfaceIds.I_CONTROLLABLE), \"Proxy: Wrong implementation\");\n    require(IControllable(address(this)).isController(msg.sender), \"Proxy: Forbidden\");\n    IControllable(address(this)).increaseRevision(_implementation());\n    _upgradeTo(_newImplementation);\n    // the new contract must have the same ABI and you must have the power to change it again\n    require(IControllable(address(this)).isController(msg.sender), \"Proxy: Wrong implementation\");\n  }\n\n  /// @notice Return current logic implementation\n  function implementation() external override view returns (address) {\n    return _implementation();\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/proxy/UpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Proxy.sol\";\nimport \"../openzeppelin/Address.sol\";\n\n/// @title OpenZeppelin https://github.com/OpenZeppelin/openzeppelin-contracts/blob/release-v3.4/contracts/proxy/UpgradeableProxy.sol\n/// @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n///      implementation address that can be changed. This address is stored in storage in the location specified by\n///      https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n///      implementation behind the proxy.\n///      Upgradeability is only provided internally through {_upgradeTo}. For an externally upgradeable proxy see\n///      {TransparentUpgradeableProxy}.\nabstract contract UpgradeableProxy is Proxy {\n\n  /// @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n  ///      If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n  ///      function call, and allows initializating the storage of the proxy like a Solidity constructor.\n  constructor() payable {\n    assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n  }\n\n  /// @dev Emitted when the implementation is upgraded.\n  event Upgraded(address indexed implementation);\n\n  ///@dev Storage slot with the address of the current implementation.\n  ///     This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n  ///     validated in the constructor.\n  bytes32 private constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n  /// @dev Post deploy initialisation for compatability with EIP-1167 factory\n  function _init(address _logic) internal {\n    require(_implementation() == address(0), \"Already inited\");\n    _setImplementation(_logic);\n  }\n\n  /// @dev Returns the current implementation address.\n  function _implementation() internal view virtual override returns (address impl) {\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      impl := sload(slot)\n    }\n  }\n\n  /// @dev Upgrades the proxy to a new implementation.\n  ///      Emits an {Upgraded} event.\n  function _upgradeTo(address newImplementation) internal virtual {\n    _setImplementation(newImplementation);\n    emit Upgraded(newImplementation);\n  }\n\n  /// @dev Stores a new address in the EIP1967 implementation slot.\n  function _setImplementation(address newImplementation) private {\n    require(Address.isContract(newImplementation), \"UpgradeableProxy: new implementation is not a contract\");\n\n    bytes32 slot = _IMPLEMENTATION_SLOT;\n\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      sstore(slot, newImplementation)\n    }\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Abstract contract for base strategy functionality\n/// @author belbix\nabstract contract StrategyBaseV2 is IStrategyV2, ControllableV3 {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant STRATEGY_BASE_VERSION = \"2.0.3\";\n  /// @dev Denominator for compound ratio\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\n  /// @dev Denominator for fee calculation.\n  uint internal constant FEE_DENOMINATOR = 100_000;\n\n  // *************************************************************\n  //                        ERRORS\n  // *************************************************************\n\n  string internal constant WRONG_CONTROLLER = \"SB: Wrong controller\";\n  string internal constant DENIED = \"SB: Denied\";\n  string internal constant TOO_HIGH = \"SB: Too high\";\n  string internal constant IMPACT_TOO_HIGH = \"SB: Impact too high\";\n  string internal constant WRONG_AMOUNT = \"SB: Wrong amount\";\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Linked splitter\n  address public override splitter;\n  /// @dev Percent of profit for autocompound inside this strategy.\n  uint public override compoundRatio;\n  /// @notice Balances of not-reward amounts\n  /// @dev Any amounts transferred to the strategy for investing or withdrawn back are registered here\n  ///      As result it's possible to distinct invested amounts from rewards, airdrops and other profits\n  mapping(address => uint) public baseAmounts;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event WithdrawAllToSplitter(uint amount);\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\n  event EmergencyExit(address sender, uint amount);\n  event ManualClaim(address sender);\n  event InvestAll(uint balance);\n  event DepositToPool(uint amount);\n  event WithdrawFromPool(uint amount);\n  event WithdrawAllFromPool(uint amount);\n  event Claimed(address token, uint amount);\n  event CompoundRatioChanged(uint oldValue, uint newValue);\n  /// @notice {baseAmounts} of {asset} is changed on the {amount} value\n  event UpdateBaseAmounts(address asset, int amount);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __StrategyBase_init(\n    address controller_,\n    address _splitter\n  ) public onlyInitializing {\n    _requireInterface(_splitter, InterfaceIds.I_SPLITTER);\n    __Controllable_init(controller_);\n\n    require(IControllable(_splitter).isController(controller_), WRONG_CONTROLLER);\n\n    asset = ISplitter(_splitter).asset();\n    splitter = _splitter;\n  }\n\n  // *************************************************************\n  //                     RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Restrict access only for operators\n  function _onlyOperators() internal view {\n    require(IController(controller()).isOperator(msg.sender), DENIED);\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of underlying assets under control of this strategy.\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this)) + investedAssets();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_STRATEGY_V2 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                   VOTER ACTIONS\n  // *************************************************************\n\n  /// @dev PlatformVoter can change compound ratio for some strategies.\n  ///      A strategy can implement another logic for some uniq cases.\n  function setCompoundRatio(uint value) external virtual override {\n    require(msg.sender == IController(controller()).platformVoter(), DENIED);\n    require(value <= COMPOUND_DENOMINATOR, TOO_HIGH);\n    emit CompoundRatioChanged(compoundRatio, value);\n    compoundRatio = value;\n  }\n\n  // *************************************************************\n  //                   OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev In case of any issue operator can withdraw all from pool.\n  function emergencyExit() external {\n    _onlyOperators();\n\n    _emergencyExitFromPool();\n\n    address _asset = asset; // gas saving\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    _decreaseBaseAmount(_asset, baseAmounts[_asset]); // reset base amount\n    IERC20(_asset).safeTransfer(splitter, balance);\n    emit EmergencyExit(msg.sender, balance);\n  }\n\n  /// @dev Manual claim rewards.\n  function claim() external {\n    _onlyOperators();\n\n    _claim();\n    emit ManualClaim(msg.sender);\n  }\n\n  // *************************************************************\n  //                    DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  /// @notice Stakes everything the strategy holds into the reward pool.\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external override returns (\n    int totalAssetsDelta\n  ) {\n    require(msg.sender == splitter, DENIED);\n\n    address _asset = asset; // gas saving\n    uint balance = IERC20(_asset).balanceOf(address(this));\n\n    _increaseBaseAmount(_asset, amount_, balance);\n\n    if (balance > 0) {\n      totalAssetsDelta = _depositToPool(balance, updateTotalAssetsBeforeInvest_);\n    }\n    emit InvestAll(balance);\n\n    return totalAssetsDelta;\n  }\n\n  /// @dev Withdraws all underlying assets to the vault\n  /// @return Return [totalAssets-before-withdraw - totalAssets-before-call-of-withdrawAllToSplitter]\n  function withdrawAllToSplitter() external override returns (int) {\n    address _splitter = splitter;\n    address _asset = asset; // gas saving\n    require(msg.sender == _splitter, DENIED);\n\n    uint balance = IERC20(_asset).balanceOf(address(this));\n\n    (uint investedAssetsUSD, uint assetPrice, int totalAssetsDelta) = _withdrawAllFromPool();\n\n    balance = _checkWithdrawImpact(\n      _asset,\n      balance,\n      investedAssetsUSD,\n      assetPrice,\n      _splitter\n    );\n\n    {\n      // we cannot withdraw more than the base amount value\n      // if any additional amount exist on the balance (i.e. airdrops)\n      // it should be processed by hardwork at first (split on compound/forwarder)\n      uint baseAmount = baseAmounts[_asset];\n      if (balance > baseAmount) {\n        balance = baseAmount;\n      }\n    }\n\n    if (balance != 0) {\n      _decreaseBaseAmount(_asset, balance);\n      IERC20(_asset).safeTransfer(_splitter, balance);\n    }\n    emit WithdrawAllToSplitter(balance);\n\n    return totalAssetsDelta;\n  }\n\n  /// @dev Withdraws some assets to the splitter\n  /// @return totalAssetsDelta =[totalAssets-before-withdraw - totalAssets-before-call-of-withdrawAllToSplitter]\n  function withdrawToSplitter(uint amount) external override returns (int totalAssetsDelta) {\n    address _splitter = splitter;\n    address _asset = asset; // gas saving\n    require(msg.sender == _splitter, DENIED);\n\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (amount > balance) {\n      uint investedAssetsUSD;\n      uint assetPrice;\n\n      (investedAssetsUSD, assetPrice, totalAssetsDelta) = _withdrawFromPool(amount - balance);\n      balance = _checkWithdrawImpact(\n        _asset,\n        balance,\n        investedAssetsUSD,\n        assetPrice,\n        _splitter\n      );\n    }\n\n    uint amountAdjusted = Math.min(amount, balance);\n    if (amountAdjusted != 0) {\n      _decreaseBaseAmount(_asset, amountAdjusted);\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\n    }\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\n\n    return totalAssetsDelta;\n  }\n\n\n  // *************************************************************\n  //                  baseAmounts modifications\n  // *************************************************************\n\n  /// @notice Decrease {baseAmounts} of the {asset} on {amount_}\n  ///         The {amount_} can be greater then total base amount value because it can includes rewards.\n  ///         We assume here, that base amounts are spent first, then rewards and any other profit-amounts\n  function _decreaseBaseAmount(address asset_, uint amount_) internal {\n    uint baseAmount = baseAmounts[asset_];\n    require(baseAmount >= amount_, WRONG_AMOUNT);\n    baseAmounts[asset_] = baseAmount - amount_;\n    emit UpdateBaseAmounts(asset_, -int(baseAmount));\n  }\n\n  /// @notice Increase {baseAmounts} of the {asset} on {amount_}, ensure that current {assetBalance_} >= {amount_}\n  /// @param assetBalance_ Current balance of the {asset} to check if {amount_} > the balance. Pass 0 to skip the check\n  function _increaseBaseAmount(address asset_, uint amount_, uint assetBalance_) internal {\n    baseAmounts[asset_] += amount_;\n    emit UpdateBaseAmounts(asset_, int(amount_));\n    require(assetBalance_ >= amount_, WRONG_AMOUNT);\n  }\n\n  // *************************************************************\n  //                       HELPERS\n  // *************************************************************\n\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\n  ///         Revert if the amount is different from expected too much (high price impact)\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\n  /// @param investedAssetsUSD Expected amount in USD, decimals are same to {_asset}\n  /// @param assetPrice Price of the asset, decimals 18\n  /// @return balance Current asset balance of the strategy\n  function _checkWithdrawImpact(\n    address _asset,\n    uint balanceBefore,\n    uint investedAssetsUSD,\n    uint assetPrice,\n    address _splitter\n  ) internal view returns (uint balance) {\n    balance = IERC20(_asset).balanceOf(address(this));\n    if (assetPrice != 0 && investedAssetsUSD != 0) {\n\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\n      uint difference = investedAssetsUSD > withdrewUSD ? investedAssetsUSD - withdrewUSD : 0;\n\n      require(difference * FEE_DENOMINATOR / investedAssetsUSD <= priceChangeTolerance, IMPACT_TOO_HIGH);\n    }\n  }\n\n  // *************************************************************\n  //                       VIRTUAL\n  // These functions must be implemented in the strategy contract\n  // *************************************************************\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\n  ///                                       It can be false if we know exactly, that the amount is already actual.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function _depositToPool(\n    uint amount,\n    bool updateTotalAssetsBeforeInvest_\n  ) internal virtual returns (\n    int totalAssetsDelta\n  );\n\n  /// @dev Withdraw given amount from the pool.\n  /// @return investedAssetsUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawFromPool(uint amount) internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  );\n\n  /// @dev Withdraw all from the pool.\n  /// @return investedAssetsUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawAllFromPool]\n  function _withdrawAllFromPool() internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  );\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  ///      Withdraw assets without impact checking.\n  function _emergencyExitFromPool() internal virtual;\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal virtual;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyStrictBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/IForwarder.sol\";\nimport \"../interfaces/IERC4626.sol\";\nimport \"../interfaces/IStrategyStrict.sol\";\nimport \"../tools/TetuERC165.sol\";\n\n/// @title Abstract contract for base strict strategy functionality\n/// @author AlehNat\nabstract contract StrategyStrictBase is IStrategyStrict, TetuERC165 {\n  using SafeERC20 for IERC20;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant STRICT_STRATEGY_BASE_VERSION = \"1.0.0\";\n\n  // *************************************************************\n  //                        ERRORS\n  // *************************************************************\n\n  string internal constant WRONG_CONTROLLER = \"SB: Wrong controller\";\n  string internal constant DENIED = \"SB: Denied\";\n  string internal constant TOO_HIGH = \"SB: Too high\";\n  string internal constant IMPACT_TOO_HIGH = \"SB: Impact too high\";\n  string internal constant WRONG_AMOUNT = \"SB: Wrong amount\";\n  string internal constant ALREADY_INITIALIZED = \"SB: Already initialized\";\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Linked vault\n  address public override vault;\n  /// @dev Percent of profit for autocompound inside this strategy.\n  uint public override compoundRatio;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event WithdrawAllToVault(uint amount);\n  event WithdrawToVault(uint amount, uint sent, uint balance);\n  event EmergencyExit(address sender, uint amount);\n  event ManualClaim(address sender);\n  event InvestAll(uint balance);\n  event DepositToPool(uint amount);\n  event WithdrawFromPool(uint amount);\n  event WithdrawAllFromPool(uint amount);\n  event Claimed(address token, uint amount);\n  event CompoundRatioChanged(uint oldValue, uint newValue);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Initialize with the vault. Can be called only once.\n  function init(address _vault) external {\n    require(vault == address(0), ALREADY_INITIALIZED);\n    _requireInterface(_vault, InterfaceIds.I_ERC4626);\n    asset = IERC4626(_vault).asset();\n    vault = _vault;\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of underlying assets under control of this strategy.\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this)) + investedAssets();\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_STRATEGY_STRICT || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                    DEPOSIT/WITHDRAW\n  // *************************************************************\n\n  /// @dev Stakes everything the strategy holds into the reward pool.\n  function investAll() external override {\n    require(msg.sender == vault, DENIED);\n    address _asset = asset; // gas saving\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (balance > 0) {\n      _depositToPool(balance);\n    }\n    emit InvestAll(balance);\n  }\n\n  /// @dev Withdraws all underlying assets to the vault\n  function withdrawAllToVault() external override {\n    address _vault = vault;\n    address _asset = asset; // gas saving\n    require(msg.sender == _vault, DENIED);\n    _withdrawAllFromPool();\n    uint balance = IERC20(_asset).balanceOf(address(this));\n\n    if (balance != 0) {\n      IERC20(_asset).safeTransfer(_vault, balance);\n    }\n    emit WithdrawAllToVault(balance);\n  }\n\n  /// @dev Withdraws some assets to the vault\n  function withdrawToVault(uint amount) external override {\n    address _vault = vault;\n    address _asset = asset; // gas saving\n    require(msg.sender == _vault, DENIED);\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (amount > balance) {\n      _withdrawFromPool(amount - balance);\n      balance = IERC20(_asset).balanceOf(address(this));\n    }\n\n    uint amountAdjusted = Math.min(amount, balance);\n    if (amountAdjusted != 0) {\n      IERC20(_asset).safeTransfer(_vault, amountAdjusted);\n    }\n    emit WithdrawToVault(amount, amountAdjusted, balance);\n  }\n\n  // *************************************************************\n  //                       VIRTUAL\n  // These functions must be implemented in the strategy contract\n  // *************************************************************\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view virtual returns (uint);\n\n  /// @dev Deposit given amount to the pool.\n  function _depositToPool(uint amount) internal virtual;\n\n  /// @dev Withdraw given amount from the pool.\n  /// @return investedAssetsUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  function _withdrawFromPool(uint amount) internal virtual returns (uint investedAssetsUSD, uint assetPrice);\n\n  /// @dev Withdraw all from the pool.\n  /// @return investedAssetsUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\n  /// @return assetPrice Price of the strategy {asset}.\n  function _withdrawAllFromPool() internal virtual returns (uint investedAssetsUSD, uint assetPrice);\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  ///      Withdraw assets without impact checking.\n  function _emergencyExitFromPool() internal virtual;\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal virtual;\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/ControllerMinimal.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\ncontract ControllerMinimal is TetuERC165, IController {\n\n  address public override governance;\n  address public override voter;\n  address public override liquidator;\n  address public override forwarder;\n  address public override investFund;\n  address public override veDistributor;\n  address public override platformVoter;\n  address[] public override vaults;\n  mapping(address => bool) public operators;\n\n  constructor (address governance_) {\n    governance = governance_;\n    operators[governance_] = true;\n  }\n\n  function setVoter(address _voter) external {\n    voter = _voter;\n  }\n\n  function setPlatformVoter(address _voter) external {\n    platformVoter = _voter;\n  }\n\n  function setLiquidator(address value) external {\n    liquidator = value;\n  }\n\n  function setInvestFund(address value) external {\n    investFund = value;\n  }\n\n  function setForwarder(address value) external {\n    forwarder = value;\n  }\n\n  function setVeDistributor(address value) external {\n    veDistributor = value;\n  }\n\n  function addVault(address vault) external {\n    vaults.push(vault);\n  }\n\n  function updateProxies(address[] memory proxies, address[] memory newLogics) external {\n    require(proxies.length == newLogics.length, \"Wrong arrays\");\n    for (uint i; i < proxies.length; i++) {\n      IProxyControlled(proxies[i]).upgrade(newLogics[i]);\n    }\n  }\n\n  function vaultsList() external view override returns (address[] memory) {\n    return vaults;\n  }\n\n  function vaultsListLength() external override view returns (uint) {\n    return vaults.length;\n  }\n\n  function isValidVault(address _vault) external view override returns (bool) {\n    for (uint i; i < vaults.length; i++) {\n      if (_vault == vaults[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function isOperator(address _adr) external view override returns (bool) {\n    return operators[_adr];\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_CONTROLLER || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/IMockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IMockToken {\n\n  function decimals() external view returns (uint8);\n\n  function mint(address to, uint amount) external;\n\n  function burn(address from, uint amount) external;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../proxy/ControllableV3.sol\";\n\ncontract MockGauge is ControllableV3 {\n\n  function init(address controller_) external initializer {\n    __Controllable_init(controller_);\n  }\n\n  function handleBalanceChange(address) external {\n    // noop\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_GAUGE || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/IERC20.sol\";\n\ncontract MockPool {\n\n  function withdraw(address token, uint amount) external {\n    IERC20(token).transfer(msg.sender, amount);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockSplitter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\ncontract MockSplitter is ISplitter, ControllableV3 {\n\n  address public override asset;\n  address public override vault;\n  uint public slippage;\n\n  function init(address controller_, address _asset, address _vault) external initializer override {\n    __Controllable_init(controller_);\n    asset = _asset;\n    vault = _vault;\n  }\n\n  function setSlippage(uint value) external {\n    slippage = value;\n  }\n\n  function withdrawAllToVault() external override {\n    withdrawToVault(IERC20(asset).balanceOf(address(this)));\n  }\n\n  function withdrawToVault(uint256 amount) public override {\n    uint toSend = amount - amount * slippage / 1000;\n    if (slippage != 0) {\n      IERC20(asset).transfer(controller(), amount - toSend);\n    }\n    IERC20(asset).transfer(vault, toSend);\n  }\n\n  function doHardWork() external override {\n    // noop\n  }\n\n  function investAll() external override {\n    // noop\n  }\n\n  function totalAssets() external view override returns (uint256) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  function isHardWorking() external pure override returns (bool) {\n    return false;\n  }\n\n  function lost(uint amount) external {\n    IERC20(asset).transfer(msg.sender, amount);\n  }\n\n  function coverLoss(uint amount) external {\n    ITetuVaultV2(vault).coverLoss(amount);\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_SPLITTER || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../strategy/StrategyBaseV2.sol\";\nimport \"./MockPool.sol\";\nimport \"./MockToken.sol\";\n\ncontract MockStrategy is StrategyBaseV2 {\n\n  string public constant override NAME = \"mock strategy\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  bool public override isReadyToHardWork;\n\n  uint internal slippage;\n  uint internal slippageDeposit;\n  uint internal hardWorkSlippage;\n  uint internal lastEarned;\n  uint internal lastLost;\n  uint internal _capacity;\n  int internal _totalAssetsDelta;\n\n  MockPool public pool;\n\n  function init(\n    address controller_,\n    address _splitter\n  ) external initializer {\n    __StrategyBase_init(controller_, _splitter);\n    splitter = _splitter;\n    isReadyToHardWork = true;\n    _capacity = type(uint).max; // unlimited capacity by default\n    pool = new MockPool();\n  }\n\n  function doHardWork() external override returns (uint earned, uint lost) {\n    pool.withdraw(asset, investedAssets());\n    uint _slippage = IERC20(asset).balanceOf(address(this)) * hardWorkSlippage / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n    if (lastEarned != 0) {\n      uint toCompound = lastEarned * compoundRatio / COMPOUND_DENOMINATOR;\n      MockToken(asset).mint(address(this), toCompound);\n      address forwarder = IController(controller()).forwarder();\n      if (forwarder != address(0)) {\n        MockToken(asset).mint(address(this), lastEarned - toCompound);\n\n        address[] memory tokens = new address[](1);\n        tokens[0] = asset;\n        uint[] memory amounts = new uint[](1);\n        amounts[0] = lastEarned - toCompound;\n        IForwarder(forwarder).registerIncome(tokens, amounts, ISplitter(splitter).vault(), true);\n      }\n    }\n    IERC20(asset).transfer(address(pool), IERC20(asset).balanceOf(address(this)));\n    return (lastEarned, Math.max(lastLost, _slippage));\n  }\n\n  /// @dev Amount of underlying assets invested to the pool.\n  function investedAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(pool));\n  }\n\n  /// @dev Deposit given amount to the pool.\n  function _depositToPool(\n    uint amount,\n    bool updateTotalAssetsBeforeInvest_\n  ) internal override returns (\n    int totalAssetsDelta\n  ) {\n    uint _slippage = amount * slippageDeposit / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n    if (amount - _slippage != 0) {\n      IERC20(asset).transfer(address(pool), amount - _slippage);\n    }\n\n    return updateTotalAssetsBeforeInvest_\n      ? _totalAssetsDelta\n      : int(0);\n  }\n\n  /// @dev Withdraw given amount from the pool.\n  function _withdrawFromPool(uint amount) internal override returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    assetPrice = 1e18;\n    investedAssetsUSD = amount;\n    totalAssetsDelta = _totalAssetsDelta;\n\n    pool.withdraw(asset, amount);\n    uint _slippage = amount * slippage / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n  }\n\n  /// @dev Withdraw all from the pool.\n  function _withdrawAllFromPool() internal override returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    assetPrice = 1e18;\n    investedAssetsUSD = 0; // investedAssets();\n    totalAssetsDelta = _totalAssetsDelta;\n\n    pool.withdraw(asset, investedAssets());\n    uint _slippage = totalAssets() * slippage / 100_000;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n\n    return (investedAssetsUSD, assetPrice, _totalAssetsDelta);\n  }\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  function _emergencyExitFromPool() internal override {\n    pool.withdraw(asset, investedAssets());\n  }\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal override {\n    // noop\n  }\n\n  function setLast(uint earned, uint lost) external {\n    lastEarned = earned;\n    lastLost = lost;\n  }\n\n  function setSlippage(uint value) external {\n    slippage = value;\n  }\n\n  function setSlippageDeposit(uint value) external {\n    slippageDeposit = value;\n  }\n\n  function setSlippageHardWork(uint value) external {\n    hardWorkSlippage = value;\n  }\n\n  function setReady(bool value) external {\n    isReadyToHardWork = value;\n  }\n\n  function setCompoundRatioManual(uint ratio) external {\n    compoundRatio = ratio;\n  }\n\n  function setBaseAmount(address asset_, uint amount_) external {\n    baseAmounts[asset_] = amount_;\n  }\n\n  /// @notice Max amount that can be deposited to the strategy, see SCB-593\n  function capacity() external view override returns (uint) {\n    return _capacity;\n  }\n\n  function setCapacity(uint capacity_) external {\n    _capacity = capacity_;\n  }\n\n  function setTotalAssetsDelta(int totalAssetsDelta_) external {\n    _totalAssetsDelta = totalAssetsDelta_;\n  }\n\n\n  ////////////////////////////////////////////////////////\n  ///           Access to internal functions\n  ////////////////////////////////////////////////////////\n  function checkWithdrawImpactAccessForTests(\n    address _asset,\n    uint balanceBefore,\n    uint investedAssetsUSD,\n    uint assetPrice,\n    address _splitter\n  ) external view returns (uint balance) {\n    return _checkWithdrawImpact(_asset, balanceBefore, investedAssetsUSD, assetPrice, _splitter);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockStrategySimple.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../proxy/ControllableV3.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/IERC20.sol\";\n\ncontract MockStrategySimple is ControllableV3, IStrategyV2 {\n\n  string public constant override NAME = \"mock strategy\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  address public override splitter;\n  address public override asset;\n  bool public override isReadyToHardWork;\n  uint public override compoundRatio;\n\n  uint internal slippage;\n  uint internal lastEarned;\n  uint internal lastLost;\n\n  uint internal _capacity;\n\n  function init(\n    address controller_,\n    address _splitter,\n    address _asset\n  ) external initializer {\n    __Controllable_init(controller_);\n    splitter = _splitter;\n    asset = _asset;\n    isReadyToHardWork = true;\n    _capacity = type(uint).max; // unlimited capacity by default\n  }\n\n  function totalAssets() public view override returns (uint) {\n    return IERC20(asset).balanceOf(address(this));\n  }\n\n  function withdrawAllToSplitter() external override returns (int totalAssetsDelta) {\n    return withdrawToSplitter(totalAssets());\n  }\n\n  function withdrawToSplitter(uint amount) public override returns (int totalAssetsDelta) {\n    uint _slippage = amount * slippage / 100;\n    if (_slippage != 0) {\n      IERC20(asset).transfer(controller(), _slippage);\n    }\n    IERC20(asset).transfer(splitter, amount - _slippage);\n    return 0;\n  }\n\n  function investAll(\n    uint amount_,\n    bool updateTotalAssetsBeforeInvest_\n  ) external override returns (\n    int totalAssetsDelta\n  ) {\n    amount_; // hide warning\n    updateTotalAssetsBeforeInvest_; // hide warning\n    // noop\n    return totalAssetsDelta;\n  }\n\n  function doHardWork() external view override returns (uint earned, uint lost) {\n    return (lastEarned, lastLost);\n  }\n\n  function setLast(uint earned, uint lost) external {\n    lastEarned = earned;\n    lastLost = lost;\n  }\n\n  function setSlippage(uint value) external {\n    slippage = value;\n  }\n\n  function setCompoundRatio(uint value) external override {\n    compoundRatio = value;\n  }\n\n  /// @notice Max amount that can be deposited to the strategy, see SCB-593\n  function capacity() external view override returns (uint) {\n    return _capacity;\n  }\n\n  function setCapacity(uint capacity_) external {\n    _capacity = capacity_;\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/MockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC20Upgradeable.sol\";\n\ncontract MockToken is ERC20Upgradeable {\n\n  uint8 internal _decimals;\n\n  constructor(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  )  {\n    _init(name_, symbol_, decimals_);\n  }\n\n  function _init(\n    string memory name_,\n    string memory symbol_,\n    uint8 decimals_\n  ) internal initializer {\n    __ERC20_init(name_, symbol_);\n    _decimals = decimals_;\n  }\n\n  function decimals() public view override returns (uint8) {\n    return _decimals;\n  }\n\n  function mint(address to, uint amount) external {\n    _mint(to, amount);\n  }\n\n  function burn(address from, uint amount) external {\n    _burn(from, amount);\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/test/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n////// /nix/store/im7ll7dx8gsw2da9k5xwbf8pbjfli2hc-multicall-df1e59d/src/Multicall.sol\n/* pragma solidity >=0.5.0; */\n/* pragma experimental ABIEncoderV2; */\n\n/// @title Multicall - Aggregate results from multiple read-only function calls\n/// @author Michael Elliot <mike@makerdao.com>\n/// @author Joshua Levine <joshua@makerdao.com>\n/// @author Nick Johnson <arachnid@notdot.net>\ncontract Multicall {\n  struct Call {\n    address target;\n    bytes callData;\n  }\n\n  function aggregate(Call[] memory calls) public returns (uint256 blockNumber, bytes[] memory returnData) {\n    blockNumber = block.number;\n    returnData = new bytes[](calls.length);\n    for (uint256 i = 0; i < calls.length; i++) {\n      (bool success, bytes memory ret) = calls[i].target.call(calls[i].callData);\n      require(success);\n      returnData[i] = ret;\n    }\n  }\n\n  // Helper functions\n  function getEthBalance(address addr) public view returns (uint256 balance) {\n    balance = addr.balance;\n  }\n\n  function getBlockHash(uint256 blockNumber) public view returns (bytes32 blockHash) {\n    blockHash = blockhash(blockNumber);\n  }\n\n  function getLastBlockHash() public view returns (bytes32 blockHash) {\n    blockHash = blockhash(block.number - 1);\n  }\n\n  function getCurrentBlockTimestamp() public view returns (uint256 timestamp) {\n    timestamp = block.timestamp;\n  }\n\n  function getCurrentBlockDifficulty() public view returns (uint256 difficulty) {\n    difficulty = block.difficulty;\n  }\n\n  function getCurrentBlockGasLimit() public view returns (uint256 gaslimit) {\n    gaslimit = block.gaslimit;\n  }\n\n  function getCurrentBlockCoinbase() public view returns (address coinbase) {\n    coinbase = block.coinbase;\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/tools/TetuERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC165.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\n/// @author bogdoslav\nabstract contract TetuERC165 is ERC165 {\n\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                        HELPER FUNCTIONS\n  // *************************************************************\n  /// @author bogdoslav\n\n  /// @dev Checks what interface with id is supported by contract.\n  /// @return bool. Do not throws\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\n      return isSupported;\n    } catch {\n    }\n    return false;\n  }\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\n    require(_isInterfaceSupported(contractAddress, interfaceId), \"Interface is not supported\");\n  }\n\n  /// @dev Checks what address is ERC20.\n  /// @return bool. Do not throws\n  function _isERC20(address contractAddress) internal view returns (bool) {\n    require(contractAddress != address(0), \"Zero address\");\n    // check what address is contract\n    uint codeSize;\n    assembly {\n      codeSize := extcodesize(contractAddress)\n    }\n    if (codeSize == 0) return false;\n\n    bool totalSupplySupported;\n    try IERC20(contractAddress).totalSupply() returns (uint) {\n      totalSupplySupported = true;\n    } catch {\n    }\n\n    bool balanceSupported;\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\n      balanceSupported = true;\n    } catch {\n    }\n\n    return totalSupplySupported && balanceSupported;\n  }\n\n\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\n  function _requireERC20(address contractAddress) internal view {\n    require(_isERC20(contractAddress), \"Not ERC20\");\n  }\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/ERC4626.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC20Permit.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../interfaces/IERC4626.sol\";\nimport \"../lib/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author belbix - adopted to proxy pattern + added ReentrancyGuard\n/// @author AlehNat - removed upgradeable logic\nabstract contract ERC4626 is ERC20Permit, ReentrancyGuard, IERC4626 {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n\n  /// @dev The address of the underlying token used for the Vault uses for accounting,\n  ///      depositing, and withdrawing\n  IERC20 internal _asset;\n\n  constructor(\n    IERC20 asset_,\n    string memory _name,\n    string memory _symbol\n  ) ERC20(_name, _symbol) ERC20Permit(_name) {\n    _asset = asset_;\n  }\n\n\n  function decimals() public view override(IERC20Metadata, ERC20) returns (uint8) {\n    return IERC20Metadata(address(_asset)).decimals();\n  }\n\n  function asset() external view override returns (address) {\n    return address(_asset);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //             DEPOSIT/WITHDRAWAL LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n  /// @dev Mints vault shares to receiver by depositing exactly amount of assets.\n  function deposit(\n    uint assets,\n    address receiver\n  ) public nonReentrant virtual override returns (uint shares) {\n    require(assets <= maxDeposit(receiver), \"MAX\");\n\n    shares = previewDeposit(assets);\n    // Check for rounding error since we round down in previewDeposit.\n    require(shares != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function mint(\n    uint shares,\n    address receiver\n  ) public nonReentrant virtual override returns (uint assets) {\n    require(shares <= maxMint(receiver), \"MAX\");\n\n    assets = previewMint(shares);\n    // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function withdraw(\n    uint assets,\n    address receiver,\n    address owner\n  ) public nonReentrant virtual override returns (uint shares) {\n    require(assets <= maxWithdraw(owner), \"MAX\");\n\n    shares = previewWithdraw(assets);\n    // No need to check for rounding error, previewWithdraw rounds up.\n\n    if (msg.sender != owner) {\n      uint allowed = _allowances[owner][msg.sender];\n      // Saves gas for limited approvals.\n      if (allowed != type(uint).max) _allowances[owner][msg.sender] = allowed - shares;\n    }\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset.safeTransfer(receiver, assets);\n  }\n\n  /// @dev Redeems shares from owner and sends assets to receiver.\n  function redeem(\n    uint shares,\n    address receiver,\n    address owner\n  ) public nonReentrant virtual override returns (uint assets) {\n    require(shares <= maxRedeem(owner), \"MAX\");\n\n    if (msg.sender != owner) {\n      uint allowed = _allowances[owner][msg.sender];\n      // Saves gas for limited approvals.\n      if (allowed != type(uint).max) _allowances[owner][msg.sender] = allowed - shares;\n    }\n\n    assets = previewRedeem(shares);\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset.safeTransfer(receiver, assets);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //                  ACCOUNTING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n  /// @dev Total amount of the underlying asset that is “managed” by Vault\n  function totalAssets() public view virtual override returns (uint);\n\n  function convertToShares(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n  }\n\n  function convertToAssets(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n  }\n\n  function previewDeposit(uint assets) public view virtual override returns (uint) {\n    return convertToShares(assets);\n  }\n\n  function previewMint(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n  }\n\n  function previewWithdraw(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n  }\n\n  function previewRedeem(uint shares) public view virtual override returns (uint) {\n    return convertToAssets(shares);\n  }\n\n  ///////////////////////////////////////////////////////////////\n  //           DEPOSIT/WITHDRAWAL LIMIT LOGIC\n  ///////////////////////////////////////////////////////////////\n\n  function maxDeposit(address) public view virtual override returns (uint) {\n    return type(uint).max - 1;\n  }\n\n  function maxMint(address) public view virtual override returns (uint) {\n    return type(uint).max - 1;\n  }\n\n  function maxWithdraw(address owner) public view virtual override returns (uint) {\n    return convertToAssets(balanceOf(owner));\n  }\n\n  function maxRedeem(address owner) public view virtual override returns (uint) {\n    return balanceOf(owner);\n  }\n\n  ///////////////////////////////////////////////////////////////\n  //                INTERNAL HOOKS LOGIC\n  ///////////////////////////////////////////////////////////////\n\n  function beforeWithdraw(uint assets, uint shares) internal virtual {}\n\n  function afterDeposit(uint assets, uint shares) internal virtual {}\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/ERC4626Strict.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./ERC4626.sol\";\nimport \"../interfaces/IStrategyStrict.sol\";\nimport \"../tools/TetuERC165.sol\";\n\ncontract ERC4626Strict is ERC4626, TetuERC165 {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VAULT_VERSION = \"1.0.0\";\n  /// @dev Denominator for buffer calculation. 100% of the buffer amount.\n  uint constant public BUFFER_DENOMINATOR = 100_000;\n\n  // *************************************************************\n  //                        VARIABLES\n  // *************************************************************\n\n  /// @dev Connected strategy. Can not be changed.\n  IStrategyStrict public immutable strategy;\n  /// @dev Percent of assets that will always stay in this vault.\n  uint public immutable buffer;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Invest(address splitter, uint amount);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  constructor(\n    IERC20 asset_,\n    string memory _name,\n    string memory _symbol,\n    address _strategy,\n    uint _buffer\n  ) ERC4626(asset_, _name, _symbol){\n    // buffer is 5% max\n    require(_buffer <= BUFFER_DENOMINATOR / 20, \"!BUFFER\");\n    _requireERC20(address(asset_));\n    buffer = _buffer;\n    _requireInterface(_strategy, InterfaceIds.I_STRATEGY_STRICT);\n    strategy = IStrategyStrict(_strategy);\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of the underlying asset that is “managed” by Vault\n  function totalAssets() public view override returns (uint) {\n    return _asset.balanceOf(address(this)) + strategy.totalAssets();\n  }\n\n  /// @dev Amount of assets under control of strategy.\n  function strategyAssets() external view returns (uint) {\n    return strategy.totalAssets();\n  }\n\n  /// @dev Price of 1 full share\n  function sharePrice() external view returns (uint) {\n    uint units = 10 ** uint256(decimals());\n    uint totalSupply_ = totalSupply();\n    return totalSupply_ == 0\n    ? units\n    : units * totalAssets() / totalSupply_;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_ERC4626 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                 DEPOSIT LOGIC\n  // *************************************************************\n\n  /// @dev Calculate available to invest amount and send this amount to strategy\n  function afterDeposit(uint /*assets*/, uint /*shares*/) internal override {\n    IStrategyStrict _strategy = strategy;\n    IERC20 asset_ = _asset;\n\n    uint256 toInvest = _availableToInvest(_strategy, asset_);\n    // invest only when buffer is filled\n    if (toInvest > 0) {\n      asset_.safeTransfer(address(_strategy), toInvest);\n      _strategy.investAll();\n      emit Invest(address(_strategy), toInvest);\n    }\n  }\n\n  /// @notice Returns amount of assets ready to invest to the strategy\n  function _availableToInvest(IStrategyStrict _strategy, IERC20 asset_) internal view returns (uint) {\n    uint _buffer = buffer;\n    uint assetsInVault = asset_.balanceOf(address(this));\n    uint assetsInStrategy = _strategy.totalAssets();\n    uint wantInvestTotal = (assetsInVault + assetsInStrategy)\n    * (BUFFER_DENOMINATOR - _buffer) / BUFFER_DENOMINATOR;\n    if (assetsInStrategy >= wantInvestTotal) {\n      return 0;\n    } else {\n      uint remainingToInvest = wantInvestTotal - assetsInStrategy;\n      return remainingToInvest <= assetsInVault ? remainingToInvest : assetsInVault;\n    }\n  }\n\n\n  // *************************************************************\n  //                 WITHDRAW LOGIC\n  // *************************************************************\n\n  /// @dev Withdraw all available shares for tx sender.\n  ///      The revert is expected if the balance is higher than `maxRedeem`\n  ///      It suppose to be used only on UI - for on-chain interactions withdraw concrete amount with properly checks.\n  function withdrawAll() external {\n    redeem(balanceOf(msg.sender), msg.sender, msg.sender);\n  }\n\n  /// @dev Internal hook for getting necessary assets from strategy.\n  function beforeWithdraw(uint assets, uint shares) internal override {\n    uint balance = _asset.balanceOf(address(this));\n    // if not enough balance in the vault withdraw from strategies\n    if (balance < assets) {\n      _processWithdrawFromStrategy(\n        assets,\n        shares,\n        totalSupply(),\n        buffer,\n        strategy,\n        balance\n      );\n    }\n  }\n\n  /// @dev Do necessary calculation for withdrawing from strategy and move assets to vault.\n  function _processWithdrawFromStrategy(\n    uint assetsNeed,\n    uint shares,\n    uint totalSupply_,\n    uint _buffer,\n    IStrategyStrict _strategy,\n    uint assetsInVault\n  ) internal {\n    // withdraw everything from the strategy to accurately check the share value\n    if (shares == totalSupply_) {\n      _strategy.withdrawAllToVault();\n    } else {\n      uint assetsInStrategy = _strategy.totalAssets();\n\n      // we should always have buffer amount inside the vault\n      // assume `assetsNeed` can not be higher than entire balance\n      uint expectedBuffer = (assetsInStrategy + assetsInVault - assetsNeed) * _buffer / BUFFER_DENOMINATOR;\n\n      // this code should not be called if `assetsInVault` higher than `assetsNeed`\n      uint missing = Math.min(expectedBuffer + assetsNeed - assetsInVault, assetsInStrategy);\n      // if zero should be resolved on strategy side\n      _strategy.withdrawToVault(missing);\n    }\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/ERC4626Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ERC20PermitUpgradeable.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../interfaces/IERC4626.sol\";\nimport \"../lib/FixedPointMathLib.sol\";\n\n/// @notice Minimal ERC4626 tokenized Vault implementation.\n/// @author Solmate (https://github.com/Rari-Capital/solmate/blob/main/src/mixins/ERC4626.sol)\n/// @author belbix - adopted to proxy pattern + added ReentrancyGuard\nabstract contract ERC4626Upgradeable is ERC20PermitUpgradeable, ReentrancyGuard, IERC4626 {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n\n  /// @dev The address of the underlying token used for the Vault uses for accounting,\n  ///      depositing, and withdrawing\n  IERC20 internal _asset;\n\n  function __ERC4626_init(\n    IERC20 asset_,\n    string memory _name,\n    string memory _symbol\n  ) internal onlyInitializing {\n    __ERC20_init(_name, _symbol);\n    _asset = asset_;\n  }\n\n  function decimals() public view override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {\n    return IERC20Metadata(address(_asset)).decimals();\n  }\n\n  function asset() external view override returns (address) {\n    return address(_asset);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //             DEPOSIT/WITHDRAWAL LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n  /// @dev Mints vault shares to receiver by depositing exactly amount of assets.\n  function deposit(\n    uint assets,\n    address receiver\n  ) public nonReentrant virtual override returns (uint shares) {\n    require(assets <= maxDeposit(receiver), \"MAX\");\n\n    shares = previewDeposit(assets);\n    // Check for rounding error since we round down in previewDeposit.\n    require(shares != 0, \"ZERO_SHARES\");\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function mint(\n    uint shares,\n    address receiver\n  ) public nonReentrant virtual override returns (uint assets) {\n    require(shares <= maxMint(receiver), \"MAX\");\n\n    assets = previewMint(shares);\n    // No need to check for rounding error, previewMint rounds up.\n\n    // Need to transfer before minting or ERC777s could reenter.\n    _asset.safeTransferFrom(msg.sender, address(this), assets);\n\n    _mint(receiver, shares);\n\n    emit Deposit(msg.sender, receiver, assets, shares);\n\n    afterDeposit(assets, shares);\n  }\n\n  function withdraw(\n    uint assets,\n    address receiver,\n    address owner\n  ) public nonReentrant virtual override returns (uint shares) {\n    require(assets <= maxWithdraw(owner), \"MAX\");\n\n    shares = previewWithdraw(assets);\n    // No need to check for rounding error, previewWithdraw rounds up.\n\n    if (msg.sender != owner) {\n      uint allowed = _allowances[owner][msg.sender];\n      // Saves gas for limited approvals.\n      if (allowed != type(uint).max) _allowances[owner][msg.sender] = allowed - shares;\n    }\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset.safeTransfer(receiver, assets);\n  }\n\n  /// @dev Redeems shares from owner and sends assets to receiver.\n  function redeem(\n    uint shares,\n    address receiver,\n    address owner\n  ) public nonReentrant virtual override returns (uint assets) {\n    require(shares <= maxRedeem(owner), \"MAX\");\n\n    if (msg.sender != owner) {\n      uint allowed = _allowances[owner][msg.sender];\n      // Saves gas for limited approvals.\n      if (allowed != type(uint).max) _allowances[owner][msg.sender] = allowed - shares;\n    }\n\n    assets = previewRedeem(shares);\n    // Check for rounding error since we round down in previewRedeem.\n    require(assets != 0, \"ZERO_ASSETS\");\n\n    beforeWithdraw(assets, shares);\n\n    _burn(owner, shares);\n\n    emit Withdraw(msg.sender, receiver, owner, assets, shares);\n\n    _asset.safeTransfer(receiver, assets);\n  }\n\n  /*//////////////////////////////////////////////////////////////\n  //                  ACCOUNTING LOGIC\n  //////////////////////////////////////////////////////////////*/\n\n  /// @dev Total amount of the underlying asset that is “managed” by Vault\n  function totalAssets() public view virtual override returns (uint);\n\n  function convertToShares(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? assets : assets.mulDivDown(supply, totalAssets());\n  }\n\n  function convertToAssets(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? shares : shares.mulDivDown(totalAssets(), supply);\n  }\n\n  function previewDeposit(uint assets) public view virtual override returns (uint) {\n    return convertToShares(assets);\n  }\n\n  function previewMint(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? shares : shares.mulDivUp(totalAssets(), supply);\n  }\n\n  function previewWithdraw(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    // Saves an extra SLOAD if totalSupply is non-zero.\n    return supply == 0 ? assets : assets.mulDivUp(supply, totalAssets());\n  }\n\n  function previewRedeem(uint shares) public view virtual override returns (uint) {\n    return convertToAssets(shares);\n  }\n\n  ///////////////////////////////////////////////////////////////\n  //           DEPOSIT/WITHDRAWAL LIMIT LOGIC\n  ///////////////////////////////////////////////////////////////\n\n  function maxDeposit(address) public view virtual override returns (uint) {\n    return type(uint).max - 1;\n  }\n\n  function maxMint(address) public view virtual override returns (uint) {\n    return type(uint).max - 1;\n  }\n\n  function maxWithdraw(address owner) public view virtual override returns (uint) {\n    return convertToAssets(balanceOf(owner));\n  }\n\n  function maxRedeem(address owner) public view virtual override returns (uint) {\n    return balanceOf(owner);\n  }\n\n  ///////////////////////////////////////////////////////////////\n  //                INTERNAL HOOKS LOGIC\n  ///////////////////////////////////////////////////////////////\n\n  function beforeWithdraw(uint assets, uint shares) internal virtual {}\n\n  function afterDeposit(uint assets, uint shares) internal virtual {}\n\n  /**\n * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[49] private __gap;\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/StrategySplitterV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/ReentrancyGuard.sol\";\nimport \"../openzeppelin/Math.sol\";\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../openzeppelin/EnumerableMap.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/IStrategyV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/IProxyControlled.sol\";\nimport \"../proxy/ControllableV3.sol\";\n\n/// @title Proxy solution for connection a vault with multiple strategies\n///        Version 2 has auto-rebalance logic adopted to strategies with fees.\n/// @author belbix\ncontract StrategySplitterV2 is ControllableV3, ReentrancyGuard, ISplitter {\n  using SafeERC20 for IERC20;\n  using EnumerableMap for EnumerableMap.AddressToUintMap;\n\n  // *********************************************\n  //                  CONSTANTS\n  // *********************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant SPLITTER_VERSION = \"2.0.2\";\n  /// @dev APR denominator. Represent 100% APR.\n  uint public constant APR_DENOMINATOR = 100_000;\n  /// @dev Delay between hardwork calls for a strategy.\n  uint public constant HARDWORK_DELAY = 12 hours;\n  /// @dev How much APR history elements will be counted in average APR calculation.\n  uint public constant HISTORY_DEEP = 3;\n  /// @dev Time lock for adding new strategies.\n  uint public constant TIME_LOCK = 18 hours;\n\n\n  // *********************************************\n  //                 VARIABLES\n  // *********************************************\n\n  /// @dev Underlying asset\n  address public override asset;\n  /// @dev Connected vault\n  address public override vault;\n  /// @dev Array of strategies under control\n  address[] public strategies;\n  /// @dev Paused strategies\n  mapping(address => bool) public pausedStrategies;\n  /// @dev Current strategies average APRs. Uses for deposit/withdraw ordering.\n  mapping(address => uint) public strategiesAPR;\n  /// @dev Strategies APR history. Uses for calculate average APR.\n  mapping(address => uint[]) public strategiesAPRHistory;\n  /// @dev Last strategies doHardWork call timestamp. Uses for calls delay.\n  mapping(address => uint) public lastHardWorks;\n  /// @dev Flag represents doHardWork call. Need for not call HW on deposit again in connected vault.\n  bool public override isHardWorking;\n  /// @dev Strategy => timestamp. Strategies scheduled for adding.\n  EnumerableMap.AddressToUintMap internal _scheduledStrategies;\n  /// @dev Changed to true after a strategy adding\n  bool internal inited;\n  /// @dev How much underlying can be invested to the strategy\n  mapping(address => uint) public strategyCapacity;\n\n  // *********************************************\n  //                  EVENTS\n  // *********************************************\n\n  event StrategyAdded(address strategy, uint apr);\n  event StrategyRemoved(address strategy);\n  event Rebalance(\n    address topStrategy,\n    address lowStrategy,\n    uint percent,\n    uint slippageTolerance,\n    uint slippage,\n    uint lowStrategyBalance\n  );\n  event HardWork(\n    address sender,\n    address strategy,\n    uint tvl,\n    uint earned,\n    uint lost,\n    uint apr,\n    uint avgApr\n  );\n  event StrategyScheduled(address strategy, uint startTime, uint timeLock);\n  event ScheduledStrategyRemove(address strategy);\n  event ManualAprChanged(address sender, address strategy, uint newApr, uint oldApr);\n  event Paused(address strategy, address sender);\n  event ContinueInvesting(address strategy, uint apr, address sender);\n  event Loss(address strategy, uint amount);\n  event Invested(address strategy, uint amount);\n  event WithdrawFromStrategy(address strategy);\n  event SetStrategyCapacity(address strategy, uint capacity);\n\n  // *********************************************\n  //                 INIT\n  // *********************************************\n\n  /// @dev Initialize contract after setup it as proxy implementation\n  function init(address controller_, address _asset, address _vault) external initializer override {\n    __Controllable_init(controller_);\n    _requireERC20(_asset);\n    asset = _asset;\n    _requireInterface(_vault, InterfaceIds.I_TETU_VAULT_V2);\n    vault = _vault;\n  }\n\n  // *********************************************\n  //                 RESTRICTIONS\n  // *********************************************\n\n  /// @dev Restrict access only for governance\n  function _onlyGov() internal view {\n    require(isGovernance(msg.sender), \"SS: Denied\");\n  }\n\n  /// @dev Restrict access only for operators\n  function _onlyOperators() internal view {\n    require(IController(controller()).isOperator(msg.sender), \"SS: Denied\");\n  }\n\n  /// @dev Restrict access only for vault\n  function _onlyVault() internal view {\n    require(msg.sender == vault, \"SS: Denied\");\n  }\n\n  /// @dev Restrict access only for operators or vault\n  function _onlyOperatorsOrVault() internal view {\n    require(msg.sender == vault || IController(controller()).isOperator(msg.sender), \"SS: Denied\");\n  }\n\n  // *********************************************\n  //                    VIEWS\n  // *********************************************\n\n  /// @dev Amount of underlying assets under control of splitter.\n  function totalAssets() public view override returns (uint256){\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    uint length = strategies.length;\n    for (uint i = 0; i < length; i++) {\n      balance += IStrategyV2(strategies[i]).totalAssets();\n    }\n    return balance;\n  }\n\n  /// @dev Return maximum available balance to withdraw without calling more than 1 strategy\n  function maxCheapWithdraw() external view returns (uint) {\n    address _asset = asset;\n    uint strategyBalance;\n    if (strategies.length != 0) {\n      strategyBalance = IStrategyV2(strategies[0]).totalAssets();\n    }\n    return strategyBalance + IERC20(_asset).balanceOf(address(this));\n  }\n\n  /// @dev Length of strategy array\n  function strategiesLength() external view returns (uint) {\n    return strategies.length;\n  }\n\n  /// @dev Returns strategy array\n  function allStrategies() external view returns (address[] memory) {\n    return strategies;\n  }\n\n  /// @dev Length of APR history for given strategy\n  function strategyAPRHistoryLength(address strategy) external view returns (uint) {\n    return strategiesAPRHistory[strategy].length;\n  }\n\n  /// @dev Return all scheduled strategies with start lock time.\n  function scheduledStrategies() external view returns (address[] memory _strategies, uint[] memory locks) {\n    uint length = _scheduledStrategies.length();\n    _strategies = new address[](length);\n    locks = new uint[](length);\n    for (uint i; i < length; ++i) {\n      (_strategies[i], locks[i]) = _scheduledStrategies.at(i);\n    }\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_SPLITTER || super.supportsInterface(interfaceId);\n  }\n\n  // *********************************************\n  //                GOV ACTIONS\n  // *********************************************\n\n  /// @dev Schedule strategy for adding in the splitter.\n  ///      Not inited splitter(without strategies) not require scheduling.\n  function scheduleStrategies(address[] memory _strategies) external {\n    _onlyGov();\n\n    for (uint i; i < _strategies.length; i++) {\n      require(_scheduledStrategies.set(_strategies[i], block.timestamp), \"SS: Exist\");\n      emit StrategyScheduled(_strategies[i], block.timestamp, TIME_LOCK);\n    }\n  }\n\n  /// @dev Remove scheduled strategies.\n  function removeScheduledStrategies(address[] memory _strategies) external {\n    _onlyGov();\n\n    for (uint i; i < _strategies.length; i++) {\n      require(_scheduledStrategies.remove(_strategies[i]), \"SS: Not exist\");\n      emit ScheduledStrategyRemove(_strategies[i]);\n    }\n  }\n\n  /// @dev Add new managed strategy. Should be an uniq address.\n  ///      Strategy should have the same underlying asset with current contract.\n  function addStrategies(address[] memory _strategies, uint[] memory expectedAPR) external {\n    // only initial action will require strict access\n    // already scheduled strategies can be added by anyone\n    require(_strategies.length == expectedAPR.length, \"WRONG_INPUT\");\n\n    bool _inited = inited;\n    address[] memory existStrategies = strategies;\n    address[] memory addedStrategies = new address[](_strategies.length);\n    for (uint i = 0; i < _strategies.length; i++) {\n      address strategy = _strategies[i];\n      uint apr = expectedAPR[i];\n\n      // --- restrictions ----------\n\n      require(IStrategyV2(strategy).asset() == asset, \"SS: Wrong asset\");\n      require(IStrategyV2(strategy).splitter() == address(this), \"SS: Wrong splitter\");\n      require(IControllable(strategy).isController(controller()), \"SS: Wrong controller\");\n      require(!_contains(existStrategies, strategy), \"SS: Already exist\");\n      require(!_contains(addedStrategies, strategy), \"SS: Duplicate\");\n      require(IProxyControlled(strategy).implementation() != address(0), \"SS: Wrong proxy\");\n      // allow add strategies without time lock only for the fist call (assume the splitter is new)\n      if (_inited) {\n        (bool found, uint startTime) = _scheduledStrategies.tryGet(strategy);\n        require(found && startTime != 0 && startTime + TIME_LOCK < block.timestamp, \"SS: Time lock\");\n        _scheduledStrategies.remove(strategy);\n      } else {\n        // only initial action requires strict access\n        _onlyGov();\n      }\n      // ----------------------------\n\n      strategies.push(strategy);\n      _setStrategyAPR(strategy, apr);\n      addedStrategies[i] = strategy;\n      lastHardWorks[strategy] = block.timestamp;\n      emit StrategyAdded(strategy, apr);\n    }\n    _sortStrategiesByAPR();\n    if (!_inited) {\n      inited = true;\n    }\n  }\n\n  /// @dev Remove given strategy, reset APR and withdraw all underlying to this contract\n  function removeStrategies(address[] memory strategies_) external {\n    _onlyGov();\n\n    for (uint i = 0; i < strategies_.length; i++) {\n      _removeStrategy(strategies_[i]);\n    }\n    _sortStrategiesByAPR();\n  }\n\n  function _removeStrategy(address strategy) internal {\n    uint length = strategies.length;\n    require(length > 0, \"SS: Empty strategies\");\n    uint idx;\n    bool found;\n    for (uint256 i = 0; i < length; i++) {\n      if (strategies[i] == strategy) {\n        idx = i;\n        found = true;\n        break;\n      }\n    }\n    require(found, \"SS: Strategy not found\");\n    if (length > 1) {\n      strategies[idx] = strategies[length - 1];\n    }\n    strategies.pop();\n\n    _setStrategyAPR(strategy, 0);\n\n    // for expensive strategies should be called before removing\n    IStrategyV2(strategy).withdrawAllToSplitter();\n    emit StrategyRemoved(strategy);\n  }\n\n  /// @dev Withdraw some percent from strategy with lowest APR and deposit to strategy with highest APR.\n  ///      Strict access because possible losses during deposit/withdraw.\n  /// @param percent Range of 1-100\n  /// @param slippageTolerance Range of 0-100_000\n  function rebalance(uint percent, uint slippageTolerance) external {\n    _onlyGov();\n\n    uint balance = totalAssets();\n    uint length = strategies.length;\n    require(length > 1, \"SS: Length\");\n    require(percent <= 100, \"SS: Percent\");\n\n\n    address lowStrategy;\n\n    uint lowStrategyBalance;\n    for (uint i = length; i > 1; i--) {\n      lowStrategy = strategies[i - 1];\n      lowStrategyBalance = IStrategyV2(lowStrategy).totalAssets();\n      if (lowStrategyBalance == 0) {\n        continue;\n      }\n      break;\n    }\n    require(lowStrategyBalance != 0, \"SS: No strategies\");\n\n    int totalAssetsDelta = (percent == 100)\n      ? IStrategyV2(lowStrategy).withdrawAllToSplitter()\n      : IStrategyV2(lowStrategy).withdrawToSplitter(lowStrategyBalance * percent / 100);\n    if (totalAssetsDelta != 0) {\n      balance = _fixTotalAssets(balance, totalAssetsDelta);\n    }\n    uint balanceAfterWithdraw = totalAssets();\n\n    (address topStrategy,) = _investToTopStrategy(\n      false // we assume here, that total-assets-amount of the strategy was just updated in withdraw above\n    );\n\n    uint balanceAfterInvest = totalAssets();\n    uint slippage;\n    // slippage for withdraw\n    if (balanceAfterWithdraw < balance) {\n      uint loss = balance - balanceAfterWithdraw;\n      ITetuVaultV2(vault).coverLoss(loss);\n      emit Loss(lowStrategy, loss);\n      slippage = loss * 100_000 / balance;\n      require(slippage <= slippageTolerance, \"SS: Slippage withdraw\");\n    }\n    // slippage for invest\n    if (balanceAfterInvest < balanceAfterWithdraw) {\n      uint loss = balanceAfterWithdraw - balanceAfterInvest;\n      ITetuVaultV2(vault).coverLoss(loss);\n      emit Loss(topStrategy, loss);\n      slippage += loss * 100_000 / balanceAfterWithdraw;\n      require(slippage <= slippageTolerance, \"SS: Slippage deposit\");\n    }\n\n    emit Rebalance(\n      topStrategy,\n      lowStrategy,\n      percent,\n      slippageTolerance,\n      slippage,\n      lowStrategyBalance\n    );\n  }\n\n  // *********************************************\n  //                OPERATOR ACTIONS\n  // *********************************************\n\n  function setAPRs(address[] memory _strategies, uint[] memory aprs) external {\n    _onlyOperators();\n    require(_strategies.length == aprs.length, \"WRONG_INPUT\");\n    for (uint i; i < aprs.length; i++) {\n      address strategy = _strategies[i];\n      require(!pausedStrategies[strategy], \"SS: Paused\");\n      uint oldAPR = strategiesAPR[strategy];\n      _setStrategyAPR(strategy, aprs[i]);\n      emit ManualAprChanged(msg.sender, strategy, aprs[i], oldAPR);\n    }\n    _sortStrategiesByAPR();\n  }\n\n  /// @dev Pause investing. For withdraw need to call emergencyExit() on the strategy.\n  function pauseInvesting(address strategy) external {\n    _onlyOperators();\n    require(!pausedStrategies[strategy], \"SS: Paused\");\n\n    pausedStrategies[strategy] = true;\n    uint oldAPR = strategiesAPR[strategy];\n    _setStrategyAPR(strategy, 0);\n    _sortStrategiesByAPR();\n    emit ManualAprChanged(msg.sender, strategy, 0, oldAPR);\n    emit Paused(strategy, msg.sender);\n  }\n\n  /// @dev Resumes the ability to invest for given strategy.\n  function continueInvesting(address strategy, uint apr) external {\n    _onlyOperators();\n    require(pausedStrategies[strategy], \"SS: Not paused\");\n\n    pausedStrategies[strategy] = false;\n    _setStrategyAPR(strategy, apr);\n    _sortStrategiesByAPR();\n    emit ManualAprChanged(msg.sender, strategy, apr, 0);\n    emit ContinueInvesting(strategy, apr, msg.sender);\n  }\n\n  function setStrategyCapacity(address strategy, uint capacity) external {\n    _onlyOperators();\n    strategyCapacity[strategy] = capacity;\n    emit SetStrategyCapacity(strategy, capacity);\n  }\n\n  // *********************************************\n  //                VAULT ACTIONS\n  // *********************************************\n\n  /// @dev Invest to the first strategy in the array. Assume this strategy has highest APR.\n  function investAll() external override {\n    _onlyVault();\n\n    if (strategies.length != 0) {\n      // calculate total-assets of all strategies\n      uint totalAssetsBefore = totalAssets();\n\n      (address strategy, int totalAssetsDelta) = _investToTopStrategy(true);\n      if (totalAssetsDelta != 0) {\n        totalAssetsBefore = _fixTotalAssets(totalAssetsBefore, totalAssetsDelta);\n      }\n\n      uint totalAssetsAfter = totalAssets();\n      if (totalAssetsAfter < totalAssetsBefore) {\n        ITetuVaultV2(msg.sender).coverLoss(totalAssetsBefore - totalAssetsAfter);\n        emit Loss(strategy, totalAssetsBefore - totalAssetsAfter);\n      }\n    }\n  }\n\n  /// @dev Try to withdraw all from all strategies. May be too expensive to handle in one tx.\n  function withdrawAllToVault() external override {\n    _onlyVault();\n\n    address _asset = asset;\n    uint balance = totalAssets();\n    uint balanceBefore = balance;\n    uint balanceAfter;\n    uint totalLoss;\n\n    uint length = strategies.length;\n    for (uint i = 0; i < length; i++) {\n      int totalAssetsDelta = IStrategyV2(strategies[i]).withdrawAllToSplitter();\n      emit WithdrawFromStrategy(strategies[i]);\n      if (totalAssetsDelta != 0) {\n        balanceBefore = _fixTotalAssets(balanceBefore, totalAssetsDelta);\n      }\n\n      // register possible loses\n      balanceAfter = totalAssets();\n      if (balanceAfter < balanceBefore) {\n        emit Loss(strategies[i], balanceBefore - balanceAfter);\n        totalLoss += balanceBefore - balanceAfter;\n      }\n      balanceBefore = balanceAfter;\n    }\n\n    balanceAfter = IERC20(_asset).balanceOf(address(this));\n\n    address _vault = vault;\n    // if we withdrew less than expected try to cover loss from vault insurance\n    if (totalLoss != 0) {\n      ITetuVaultV2(_vault).coverLoss(totalLoss);\n    }\n\n    if (balanceAfter > 0) {\n      IERC20(_asset).safeTransfer(_vault, balanceAfter);\n    }\n  }\n\n  /// @dev Cascade withdraw from strategies start from lower APR until reach the target amount.\n  ///      For large amounts with multiple strategies may not be possible to process this function.\n  function withdrawToVault(uint256 amount) external override {\n    _onlyVault();\n\n    uint totalLoss;\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    if (balance < amount) {\n      uint remainingAmount = amount - balance;\n      uint length = strategies.length;\n      for (uint i = length; i > 0; i--) {\n        IStrategyV2 strategy = IStrategyV2(strategies[i - 1]);\n\n        uint strategyBalance = strategy.totalAssets();\n        uint balanceBefore = strategyBalance + balance;\n\n        // withdraw from strategy\n        int totalAssetsDelta = (strategyBalance <= remainingAmount)\n          ? strategy.withdrawAllToSplitter()\n          : strategy.withdrawToSplitter(remainingAmount);\n        if (totalAssetsDelta != 0) {\n          balanceBefore = _fixTotalAssets(balanceBefore, totalAssetsDelta);\n        }\n        emit WithdrawFromStrategy(address(strategy));\n\n        uint currentBalance = IERC20(_asset).balanceOf(address(this));\n        // assume that we can not decrease splitter balance during withdraw process\n        uint withdrew = currentBalance - balance;\n        balance = currentBalance;\n\n        remainingAmount = withdrew <= remainingAmount ? remainingAmount - withdrew : 0;\n\n        uint balanceAfter = strategy.totalAssets() + balance;\n\n        // register loss\n        if (balanceAfter < balanceBefore) {\n          emit Loss(address(strategy), balanceBefore - balanceAfter);\n          totalLoss += balanceBefore - balanceAfter;\n        }\n\n        if (balance >= amount) {\n          break;\n        }\n      }\n    }\n\n    address _vault = vault;\n    // if we withdrew less than expected try to cover loss from vault insurance\n    if (totalLoss != 0) {\n      ITetuVaultV2(_vault).coverLoss(totalLoss);\n    }\n\n    if (balance != 0) {\n      IERC20(_asset).safeTransfer(_vault, Math.min(amount, balance));\n    }\n  }\n\n  /// @notice Calculate totalAssets-before-deposit/withdraw as {totalAssets_} + {delta}\n  ///         Insurance covers losses during deposit/withdraw but doesn't cover losses because of price changes.\n  ///         The selected strategy updates totalAssets before the depositing/withdrawing,\n  ///         we need to use updated value to calculate the losses.\n  ///             Looses-to-cover = [totalAssets-after-deposit/withdraw - totalAssets-before-deposit/withdraw]\n  /// @param totalAssets_ totalAssets-before-call-of-deposit/withdraw-function\n  /// @param delta_ [totalAssets-before-deposit/withdraw - totalAssets-before-call-of-deposit/withdraw-function]\n  /// @return totalAssetsOut totalAssets-before-deposit/withdraw\n  function _fixTotalAssets(uint totalAssets_, int delta_) internal pure returns (uint totalAssetsOut) {\n    if (delta_ > 0) {\n      totalAssetsOut = totalAssets_ + uint(delta_);\n    } else {\n      require(totalAssets_ >= uint(- delta_), \"SS: patch\"); // protection from mistakes in strategy\n      totalAssetsOut = totalAssets_ - uint(- delta_);\n    }\n  }\n\n  // *********************************************\n  //                HARD WORKS\n  // *********************************************\n\n  /// @dev Call hard works for all strategies.\n  function doHardWork() external override {\n    _onlyOperatorsOrVault();\n\n    // prevent recursion\n    isHardWorking = true;\n    uint length = strategies.length;\n    bool needReorder;\n    for (uint i = 0; i < length; i++) {\n      bool result = _doHardWorkForStrategy(strategies[i], false);\n      if (result) {\n        needReorder = true;\n      }\n    }\n    if (needReorder) {\n      _sortStrategiesByAPR();\n    }\n    isHardWorking = false;\n  }\n\n  /// @dev Call hard work for given strategy.\n  function doHardWorkForStrategy(address strategy, bool push) external {\n    _onlyOperators();\n\n    // prevent recursion\n    isHardWorking = true;\n    bool result = _doHardWorkForStrategy(strategy, push);\n    if (result) {\n      _sortStrategiesByAPR();\n    }\n    isHardWorking = false;\n  }\n\n  function _doHardWorkForStrategy(address strategy, bool push) internal returns (bool) {\n    uint lastHardWork = lastHardWorks[strategy];\n\n    if (\n      (\n      lastHardWork + HARDWORK_DELAY < block.timestamp\n      && IStrategyV2(strategy).isReadyToHardWork()\n      && !pausedStrategies[strategy]\n      )\n      || push\n    ) {\n      uint sinceLastHardWork = block.timestamp - lastHardWork;\n      uint tvl = IStrategyV2(strategy).totalAssets();\n      if (tvl != 0) {\n        (uint earned, uint lost) = IStrategyV2(strategy).doHardWork();\n        uint apr;\n        if (earned > lost) {\n          apr = computeApr(tvl, earned - lost, sinceLastHardWork);\n        }\n        uint lostForCovering = lost > earned ? lost - earned : 0;\n        if (lostForCovering > 0) {\n          ITetuVaultV2(vault).coverLoss(lostForCovering);\n        }\n\n        strategiesAPRHistory[strategy].push(apr);\n        uint avgApr = averageApr(strategy);\n        strategiesAPR[strategy] = avgApr;\n        lastHardWorks[strategy] = block.timestamp;\n\n        emit HardWork(\n          msg.sender,\n          strategy,\n          tvl,\n          earned,\n          lost,\n          apr,\n          avgApr\n        );\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function averageApr(address strategy) public view returns (uint) {\n    uint[] storage history = strategiesAPRHistory[strategy];\n    uint aprSum;\n    uint length = history.length;\n    uint count = Math.min(HISTORY_DEEP, length);\n    if (count != 0) {\n      for (uint i; i < count; i++) {\n        aprSum += history[length - i - 1];\n      }\n      return aprSum / count;\n    }\n    return 0;\n  }\n\n  /// @dev https://www.investopedia.com/terms/a/apr.asp\n  ///      TVL and rewards should be in the same currency and with the same decimals\n  function computeApr(uint tvl, uint earned, uint duration) public pure returns (uint) {\n    if (tvl == 0 || duration == 0) {\n      return 0;\n    }\n    return earned * 1e18 * APR_DENOMINATOR * uint(365) / tvl / (duration * 1e18 / 1 days);\n  }\n\n  /// @dev Insertion sorting algorithm for using with arrays fewer than 10 elements.\n  ///      Based on https://medium.com/coinmonks/sorting-in-solidity-without-comparison-4eb47e04ff0d\n  ///      Sort strategies array by APR values from strategiesAPR map. Highest to lowest.\n  function _sortStrategiesByAPR() internal {\n  unchecked {\n    uint length = strategies.length;\n    for (uint i = 1; i < length; i++) {\n      address key = strategies[i];\n      uint j = i - 1;\n      while ((int(j) >= 0) && strategiesAPR[strategies[j]] < strategiesAPR[key]) {\n        strategies[j + 1] = strategies[j];\n        j--;\n      }\n      strategies[j + 1] = key;\n    }\n  }\n  }\n\n  /// @dev Return true if given item found in address array\n  function _contains(address[] memory array, address _item) internal pure returns (bool) {\n    for (uint256 i = 0; i < array.length; i++) {\n      if (array[i] == _item) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function _setStrategyAPR(address strategy, uint apr) internal {\n    strategiesAPR[strategy] = apr;\n    // need to override last values of history for properly calculate average apr\n    for (uint i; i < HISTORY_DEEP; i++) {\n      strategiesAPRHistory[strategy].push(apr);\n    }\n  }\n\n  /// @param updateTotalAssetsBeforeInvest TotalAssets of strategy should be updated before investing.\n  ///                                      The increment of {TotalAssets} should be returned as {totalAssetsDelta}\n  /// @return strategy Selected strategy or zero\n  /// @return totalAssetsDelta The {strategy} can update its totalAssets amount internally before depositing {amount_}\n  ///                          Return [totalAssets-before-deposit - totalAssets-before-call-of-investAll]\n  function _investToTopStrategy(\n    bool updateTotalAssetsBeforeInvest\n  ) internal returns (\n    address strategy,\n    int totalAssetsDelta\n  ) {\n    address _asset = asset;\n    uint balance = IERC20(_asset).balanceOf(address(this));\n    // no actions for zero balance, return empty strategy\n    if (balance != 0) {\n      uint length = strategies.length;\n      for (uint i; i < length; ++i) {\n        strategy = strategies[i];\n        if (pausedStrategies[strategy]) {\n          continue;\n        }\n\n        // There are strategy capacities of two kinds: external (from splitter) and internal (from strategy)\n        // We should use minimum value (but: zero external capacity means no capacity)\n        uint capacity = strategyCapacity[strategy];\n        if (capacity == 0) {\n          capacity = IStrategyV2(strategies[i]).capacity();\n        } else {\n          capacity = Math.min(capacity, IStrategyV2(strategies[i]).capacity());\n        }\n\n        uint strategyBalance = IStrategyV2(strategy).totalAssets();\n        uint toInvest;\n        if (capacity > strategyBalance) {\n          toInvest = Math.min(capacity - strategyBalance, balance);\n        }\n\n        IERC20(_asset).safeTransfer(strategy, toInvest);\n        totalAssetsDelta = IStrategyV2(strategy).investAll(toInvest, updateTotalAssetsBeforeInvest);\n        balance -= toInvest;\n        emit Invested(strategy, toInvest);\n      }\n    }\n\n    return (strategy, totalAssetsDelta);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/TetuVaultV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/Math.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/IGauge.sol\";\nimport \"../proxy/ControllableV3.sol\";\nimport \"./ERC4626Upgradeable.sol\";\n\n/// @title Vault for storing underlying tokens and managing them with strategy splitter.\n/// @author belbix\ncontract TetuVaultV2 is ERC4626Upgradeable, ControllableV3, ITetuVaultV2 {\n  using SafeERC20 for IERC20;\n  using FixedPointMathLib for uint;\n\n  // *************************************************************\n  //                        CONSTANTS\n  // *************************************************************\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant VAULT_VERSION = \"2.0.1\";\n  /// @dev Denominator for buffer calculation. 100% of the buffer amount.\n  uint constant public BUFFER_DENOMINATOR = 100_000;\n  /// @dev Denominator for fee calculation.\n  uint constant public FEE_DENOMINATOR = 100_000;\n  /// @dev Max 1% fee.\n  uint constant public MAX_FEE = FEE_DENOMINATOR / 100;\n\n  // *************************************************************\n  //                        VARIABLES\n  //                Keep names and ordering!\n  //                 Add only in the bottom.\n  // *************************************************************\n\n  /// @dev Strategy splitter. Should be setup after deploy.\n  ISplitter public splitter;\n  /// @dev Connected gauge for stakeless rewards\n  IGauge public gauge;\n  /// @dev Dedicated contract for holding insurance for covering share price loss.\n  IVaultInsurance public insurance;\n  /// @dev Percent of assets that will always stay in this vault.\n  uint public buffer;\n\n  /// @dev Maximum amount for withdraw. Max UINT256 by default.\n  uint public maxWithdrawAssets;\n  /// @dev Maximum amount for redeem. Max UINT256 by default.\n  uint public maxRedeemShares;\n  /// @dev Maximum amount for deposit. Max UINT256 by default.\n  uint public maxDepositAssets;\n  /// @dev Maximum amount for mint. Max UINT256 by default.\n  uint public maxMintShares;\n  /// @dev Fee for deposit/mint actions. Zero by default.\n  uint public override depositFee;\n  /// @dev Fee for withdraw/redeem actions. Zero by default.\n  uint public override withdrawFee;\n\n  /// @dev Trigger doHardwork on invest action. Enabled by default.\n  bool public doHardWorkOnInvest;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event Init(\n    address controller,\n    address asset,\n    string name,\n    string symbol,\n    address gauge,\n    uint buffer\n  );\n  event SplitterSetup(address splitter);\n  event BufferChanged(uint oldValue, uint newValue);\n  event Invest(address splitter, uint amount);\n  event MaxWithdrawChanged(uint maxAssets, uint maxShares);\n  event MaxDepositChanged(uint maxAssets, uint maxShares);\n  event FeeChanged(uint depositFee, uint withdrawFee);\n  event DoHardWorkOnInvestChanged(bool oldValue, bool newValue);\n  event FeeTransfer(uint amount);\n  event LossCovered(uint amount);\n\n  // *************************************************************\n  //                        INIT\n  // *************************************************************\n\n  /// @dev Proxy initialization. Call it after contract deploy.\n  function init(\n    address controller_,\n    IERC20 asset_,\n    string memory _name,\n    string memory _symbol,\n    address _gauge,\n    uint _buffer\n  ) external initializer override {\n    require(_buffer <= BUFFER_DENOMINATOR, \"!BUFFER\");\n    require(_gauge != address(0), \"!GAUGE\");\n    require(IControllable(_gauge).isController(controller_), \"!GAUGE_CONTROLLER\");\n\n    _requireERC20(address(asset_));\n    __ERC4626_init(asset_, _name, _symbol);\n    __Controllable_init(controller_);\n\n    _requireInterface(_gauge, InterfaceIds.I_GAUGE);\n    gauge = IGauge(_gauge);\n    buffer = _buffer;\n\n    // set defaults\n    maxWithdrawAssets = type(uint).max;\n    maxRedeemShares = type(uint).max;\n    maxDepositAssets = type(uint).max - 1;\n    maxMintShares = type(uint).max - 1;\n    doHardWorkOnInvest = true;\n\n    emit Init(\n      controller_,\n      address(asset_),\n      _name,\n      _symbol,\n      _gauge,\n      _buffer\n    );\n  }\n\n  function initInsurance(IVaultInsurance _insurance) external override {\n    require(address(insurance) == address(0), \"INITED\");\n    _requireInterface(address(_insurance), InterfaceIds.I_VAULT_INSURANCE);\n\n    require(_insurance.vault() == address(this), \"!VAULT\");\n    require(_insurance.asset() == address(_asset), \"!ASSET\");\n    insurance = _insurance;\n  }\n\n  // *************************************************************\n  //                      GOV ACTIONS\n  // *************************************************************\n\n  /// @dev Set new buffer value. Should be lower than denominator.\n  function setBuffer(uint _buffer) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n    require(_buffer <= BUFFER_DENOMINATOR, \"BUFFER\");\n\n    emit BufferChanged(buffer, _buffer);\n    buffer = _buffer;\n  }\n\n  /// @dev Set maximum available to deposit amounts.\n  ///      Could be zero values in emergency case when need to pause malicious actions.\n  function setMaxDeposit(uint maxAssets, uint maxShares) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n\n    maxDepositAssets = maxAssets;\n    maxMintShares = maxShares;\n    emit MaxDepositChanged(maxAssets, maxShares);\n  }\n\n  /// @dev Set maximum available to withdraw amounts.\n  ///      Could be zero values in emergency case when need to pause malicious actions.\n  function setMaxWithdraw(uint maxAssets, uint maxShares) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n\n    maxWithdrawAssets = maxAssets;\n    maxRedeemShares = maxShares;\n    emit MaxWithdrawChanged(maxAssets, maxShares);\n  }\n\n  /// @dev Set deposit/withdraw fees\n  function setFees(uint _depositFee, uint _withdrawFee) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n    require(_depositFee <= MAX_FEE && _withdrawFee <= MAX_FEE, \"TOO_HIGH\");\n\n    depositFee = _depositFee;\n    withdrawFee = _withdrawFee;\n    emit FeeChanged(_depositFee, _withdrawFee);\n  }\n\n  /// @dev If activated will call doHardWork on splitter on each invest action.\n  function setDoHardWorkOnInvest(bool value) external {\n    require(isGovernance(msg.sender), \"DENIED\");\n    emit DoHardWorkOnInvestChanged(doHardWorkOnInvest, value);\n    doHardWorkOnInvest = value;\n  }\n\n  /// @dev Set splitter address. Can not change exist splitter.\n  function setSplitter(address _splitter) external override {\n    IERC20 asset_ = _asset;\n    require(address(splitter) == address(0), \"DENIED\");\n    _requireInterface(_splitter, InterfaceIds.I_SPLITTER);\n    require(ISplitter(_splitter).asset() == address(asset_), \"WRONG_UNDERLYING\");\n    require(ISplitter(_splitter).vault() == address(this), \"WRONG_VAULT\");\n    require(IControllable(_splitter).isController(controller()), \"WRONG_CONTROLLER\");\n    asset_.approve(_splitter, type(uint).max);\n    splitter = ISplitter(_splitter);\n    emit SplitterSetup(_splitter);\n  }\n\n  // *************************************************************\n  //                        VIEWS\n  // *************************************************************\n\n  /// @dev Total amount of the underlying asset that is “managed” by Vault\n  function totalAssets() public view override returns (uint) {\n    return _asset.balanceOf(address(this)) + splitter.totalAssets();\n  }\n\n  /// @dev Amount of assets under control of strategy splitter.\n  function splitterAssets() external view returns (uint) {\n    return splitter.totalAssets();\n  }\n\n  /// @dev Price of 1 full share\n  function sharePrice() external view returns (uint) {\n    uint units = 10 ** uint256(decimals());\n    uint totalSupply_ = totalSupply();\n    return totalSupply_ == 0\n    ? units\n    : units * totalAssets() / totalSupply_;\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_TETU_VAULT_V2 || super.supportsInterface(interfaceId);\n  }\n\n  // *************************************************************\n  //                 DEPOSIT LOGIC\n  // *************************************************************\n\n  function previewDeposit(uint assets) public view virtual override returns (uint) {\n    uint shares = convertToShares(assets);\n    return shares - (shares * depositFee / FEE_DENOMINATOR);\n  }\n\n  function previewMint(uint shares) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    if (supply != 0) {\n      uint assets = shares.mulDivUp(totalAssets(), supply);\n      return assets * FEE_DENOMINATOR / (FEE_DENOMINATOR - depositFee);\n    } else {\n      return shares * FEE_DENOMINATOR / (FEE_DENOMINATOR - depositFee);\n    }\n  }\n\n  /// @dev Calculate available to invest amount and send this amount to splitter\n  function afterDeposit(uint assets, uint) internal override {\n    address _splitter = address(splitter);\n    IERC20 asset_ = _asset;\n    uint _depositFee = depositFee;\n    // send fee to insurance contract\n    if (_depositFee != 0) {\n      uint toFees = assets * _depositFee / FEE_DENOMINATOR;\n      asset_.safeTransfer(address(insurance), toFees);\n      emit FeeTransfer(toFees);\n    }\n    uint256 toInvest = _availableToInvest(_splitter, asset_);\n    // invest only when buffer is filled\n    if (toInvest > 0) {\n\n      // need to check recursive hardworks\n      if (doHardWorkOnInvest && !ISplitter(_splitter).isHardWorking()) {\n        ISplitter(_splitter).doHardWork();\n      }\n\n      asset_.safeTransfer(_splitter, toInvest);\n      ISplitter(_splitter).investAll();\n      emit Invest(_splitter, toInvest);\n    }\n  }\n\n  /// @notice Returns amount of assets ready to invest to the splitter\n  function _availableToInvest(address _splitter, IERC20 asset_) internal view returns (uint) {\n    uint _buffer = buffer;\n    if (_splitter == address(0) || _buffer == BUFFER_DENOMINATOR) {\n      return 0;\n    }\n    uint assetsInVault = asset_.balanceOf(address(this));\n    uint assetsInSplitter = ISplitter(_splitter).totalAssets();\n    uint wantInvestTotal = (assetsInVault + assetsInSplitter)\n    * (BUFFER_DENOMINATOR - _buffer) / BUFFER_DENOMINATOR;\n    if (assetsInSplitter >= wantInvestTotal) {\n      return 0;\n    } else {\n      uint remainingToInvest = wantInvestTotal - assetsInSplitter;\n      return remainingToInvest <= assetsInVault ? remainingToInvest : assetsInVault;\n    }\n  }\n\n  // *************************************************************\n  //                 WITHDRAW LOGIC\n  // *************************************************************\n\n  /// @dev Withdraw all available shares for tx sender.\n  ///      The revert is expected if the balance is higher than `maxRedeem`\n  function withdrawAll() external {\n    redeem(balanceOf(msg.sender), msg.sender, msg.sender);\n  }\n\n  function previewWithdraw(uint assets) public view virtual override returns (uint) {\n    uint supply = totalSupply();\n    uint _totalAssets = totalAssets();\n    if (_totalAssets == 0) {\n      return assets;\n    }\n    uint shares = assets.mulDivUp(supply, _totalAssets);\n    shares = shares * FEE_DENOMINATOR / (FEE_DENOMINATOR - withdrawFee);\n    return supply == 0 ? assets : shares;\n  }\n\n  function previewRedeem(uint shares) public view virtual override returns (uint) {\n    shares = shares - (shares * withdrawFee / FEE_DENOMINATOR);\n    return convertToAssets(shares);\n  }\n\n  function maxDeposit(address) public view override returns (uint) {\n    return maxDepositAssets;\n  }\n\n  function maxMint(address) public view override returns (uint) {\n    return maxMintShares;\n  }\n\n  function maxWithdraw(address owner) public view override returns (uint) {\n    uint assets = convertToAssets(balanceOf(owner));\n    assets -= assets * withdrawFee / FEE_DENOMINATOR;\n    return Math.min(maxWithdrawAssets, assets);\n  }\n\n  function maxRedeem(address owner) public view override returns (uint) {\n    return Math.min(maxRedeemShares, balanceOf(owner));\n  }\n\n  /// @dev Internal hook for getting necessary assets from splitter.\n  function beforeWithdraw(\n    uint assets,\n    uint shares\n  ) internal override {\n    uint _withdrawFee = withdrawFee;\n    uint fromSplitter;\n    if (_withdrawFee != 0) {\n      // add fee amount\n      fromSplitter = assets * FEE_DENOMINATOR / (FEE_DENOMINATOR - _withdrawFee);\n    } else {\n      fromSplitter = assets;\n    }\n\n    IERC20 asset_ = _asset;\n    uint balance = asset_.balanceOf(address(this));\n    // if not enough balance in the vault withdraw from strategies\n    if (balance < fromSplitter) {\n      _processWithdrawFromSplitter(\n        fromSplitter,\n        shares,\n        totalSupply(),\n        buffer,\n        splitter,\n        balance\n      );\n    }\n    balance = asset_.balanceOf(address(this));\n    require(assets <= balance, \"SLIPPAGE\");\n\n    // send fee amount to insurance for keep correct calculations\n    // in case of compensation it will lead to double transfer\n    // but we assume that it will be rare case\n    if (_withdrawFee != 0) {\n      // we should compensate possible slippage from user fee too\n      uint toFees = Math.min(fromSplitter - assets, balance - assets);\n      if (toFees != 0) {\n        asset_.safeTransfer(address(insurance), toFees);\n        emit FeeTransfer(toFees);\n      }\n    }\n  }\n\n  /// @dev Do necessary calculation for withdrawing from splitter and move assets to vault.\n  ///      If splitter not defined must not be called.\n  function _processWithdrawFromSplitter(\n    uint assetsNeed,\n    uint shares,\n    uint totalSupply_,\n    uint _buffer,\n    ISplitter _splitter,\n    uint assetsInVault\n  ) internal {\n    // withdraw everything from the splitter to accurately check the share value\n    if (shares == totalSupply_) {\n      _splitter.withdrawAllToVault();\n    } else {\n      uint assetsInSplitter = _splitter.totalAssets();\n\n      // we should always have buffer amount inside the vault\n      // assume `assetsNeed` can not be higher than entire balance\n      uint expectedBuffer = (assetsInSplitter + assetsInVault - assetsNeed) * _buffer / BUFFER_DENOMINATOR;\n\n      // this code should not be called if `assetsInVault` higher than `assetsNeed`\n      uint missing = Math.min(expectedBuffer + assetsNeed - assetsInVault, assetsInSplitter);\n      // if zero should be resolved on splitter side\n      _splitter.withdrawToVault(missing);\n    }\n  }\n\n  // *************************************************************\n  //                 INSURANCE LOGIC\n  // *************************************************************\n\n  function coverLoss(uint amount) external override {\n    require(msg.sender == address(splitter), \"!SPLITTER\");\n    IVaultInsurance _insurance = insurance;\n    uint balance = _asset.balanceOf(address(_insurance));\n    uint fromFees = Math.min(amount, balance);\n    _insurance.transferToVault(fromFees);\n    emit LossCovered(fromFees);\n  }\n\n  // *************************************************************\n  //                 GAUGE HOOK\n  // *************************************************************\n\n  /// @dev Connect this vault to the gauge for non-contract addresses.\n  function _afterTokenTransfer(\n    address from,\n    address to,\n    uint\n  ) internal override {\n    gauge.handleBalanceChange(from);\n    gauge.handleBalanceChange(to);\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/VaultFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IController.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../interfaces/ISplitter.sol\";\nimport \"../proxy/ProxyControlled.sol\";\nimport \"./VaultInsurance.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Factory for vaults.\n/// @author belbix\ncontract VaultFactory is TetuERC165 {\n\n  // *************************************************************\n  //                        VARIABLES\n  // *************************************************************\n\n  /// @dev Platform controller, need for restrictions.\n  address public immutable controller;\n\n  /// @dev TetuVaultV2 contract address\n  address public vaultImpl;\n  /// @dev VaultInsurance contract address\n  address public vaultInsuranceImpl;\n  /// @dev StrategySplitterV2 contract address\n  address public splitterImpl;\n\n  /// @dev Array of deployed vaults.\n  address[] public deployedVaults;\n\n  // *************************************************************\n  //                        EVENTS\n  // *************************************************************\n\n  event VaultDeployed(\n    address sender,\n    address asset,\n    string name,\n    string symbol,\n    address gauge,\n    uint buffer,\n    address vaultProxy,\n    address vaultLogic,\n    address insurance,\n    address splitterProxy,\n    address splitterLogic\n  );\n  event VaultImplChanged(address value);\n  event VaultInsuranceImplChanged(address value);\n  event SplitterImplChanged(address value);\n\n  constructor(\n    address _controller,\n    address _vaultImpl,\n    address _vaultInsuranceImpl,\n    address _splitterImpl\n  ) {\n    _requireInterface(_controller, InterfaceIds.I_CONTROLLER);\n    _requireInterface(_vaultImpl, InterfaceIds.I_TETU_VAULT_V2);\n    _requireInterface(_vaultInsuranceImpl, InterfaceIds.I_VAULT_INSURANCE);\n    _requireInterface(_splitterImpl, InterfaceIds.I_SPLITTER);\n\n    controller = _controller;\n    vaultImpl = _vaultImpl;\n    vaultInsuranceImpl = _vaultInsuranceImpl;\n    splitterImpl = _splitterImpl;\n  }\n\n  function deployedVaultsLength() external view returns (uint) {\n    return deployedVaults.length;\n  }\n\n  // *************************************************************\n  //                        RESTRICTIONS\n  // *************************************************************\n\n  /// @dev Only governance\n  modifier onlyGov() {\n    require(msg.sender == IController(controller).governance(), \"!GOV\");\n    _;\n  }\n\n  /// @dev Only platform operators\n  modifier onlyOperator() {\n    require(IController(controller).isOperator(msg.sender), \"!OPERATOR\");\n    _;\n  }\n\n  // *************************************************************\n  //                        GOV ACTIONS\n  // *************************************************************\n\n  /// @dev Set TetuVaultV2 contract address\n  function setVaultImpl(address value) external onlyGov {\n    _requireInterface(value, InterfaceIds.I_TETU_VAULT_V2);\n    vaultImpl = value;\n    emit VaultImplChanged(value);\n  }\n\n  /// @dev Set VaultInsurance contract address\n  function setVaultInsuranceImpl(address value) external onlyGov {\n    _requireInterface(value, InterfaceIds.I_VAULT_INSURANCE);\n    vaultInsuranceImpl = value;\n    emit VaultInsuranceImplChanged(value);\n  }\n\n  /// @dev Set StrategySplitterV2 contract address\n  function setSplitterImpl(address value) external onlyGov {\n    _requireInterface(value, InterfaceIds.I_SPLITTER);\n    splitterImpl = value;\n    emit SplitterImplChanged(value);\n  }\n\n  // *************************************************************\n  //                    OPERATOR ACTIONS\n  // *************************************************************\n\n  /// @dev Create and init vault with given attributes.\n  function createVault(\n    IERC20 asset,\n    string memory name,\n    string memory symbol,\n    address gauge,\n    uint buffer\n  ) external onlyOperator {\n    // clone vault implementations\n    address vaultProxy = address(new ProxyControlled());\n    address vaultLogic = vaultImpl;\n    // init proxy\n    IProxyControlled(vaultProxy).initProxy(vaultLogic);\n    // init vault\n    ITetuVaultV2(vaultProxy).init(\n      controller,\n      asset,\n      name,\n      symbol,\n      gauge,\n      buffer\n    );\n    // clone insurance\n    VaultInsurance insurance = new VaultInsurance();\n    // init insurance\n    insurance.init(vaultProxy, address(asset));\n    // set insurance to vault\n    ITetuVaultV2(vaultProxy).initInsurance(insurance);\n\n    // clone splitter\n    address splitterProxy = address(new ProxyControlled());\n    address splitterLogic = splitterImpl;\n    // init proxy\n    IProxyControlled(splitterProxy).initProxy(splitterLogic);\n    // init splitter\n    ISplitter(splitterProxy).init(controller, address(asset), vaultProxy);\n    // set splitter to vault\n    ITetuVaultV2(vaultProxy).setSplitter(splitterProxy);\n\n    deployedVaults.push(vaultProxy);\n\n    emit VaultDeployed(\n      msg.sender,\n      address(asset),\n      name,\n      symbol,\n      gauge,\n      buffer,\n      vaultProxy,\n      vaultLogic,\n      address(insurance),\n      splitterProxy,\n      splitterLogic\n    );\n  }\n\n}\n"
    },
    "@tetu_io/tetu-contracts-v2/contracts/vault/VaultInsurance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../openzeppelin/SafeERC20.sol\";\nimport \"../tools/TetuERC165.sol\";\nimport \"../interfaces/IERC20.sol\";\nimport \"../interfaces/IVaultInsurance.sol\";\nimport \"../interfaces/ITetuVaultV2.sol\";\nimport \"../lib/InterfaceIds.sol\";\n\n/// @title Simple dedicated contract for store vault fees\n/// @author belbix\ncontract VaultInsurance is TetuERC165, IVaultInsurance  {\n  using SafeERC20 for IERC20;\n\n  /// @dev Vault address\n  address public override vault;\n  /// @dev Vault underlying asset\n  address public override asset;\n\n  /// @dev Init contract with given attributes.\n  ///      Should be called from factory during creation process.\n  function init(address _vault, address _asset) external override {\n    require(vault == address(0) && asset == address(0), \"INITED\");\n    _requireInterface(_vault, InterfaceIds.I_TETU_VAULT_V2);\n    _requireERC20(_asset);\n\n    vault = _vault;\n    asset = _asset;\n  }\n\n  /// @dev Transfer tokens to vault in case of covering need.\n  function transferToVault(uint amount) external override {\n    require(msg.sender == vault, \"!VAULT\");\n    IERC20(asset).safeTransfer(msg.sender, amount);\n  }\n\n  /// @dev See {IERC165-supportsInterface}.\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n    return interfaceId == InterfaceIds.I_VAULT_INSURANCE || super.supportsInterface(interfaceId);\n  }\n\n}\n"
    },
    "contracts/integrations/aave/AggregatorInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice A source of asset price for AAVE3 price oracle\n/// @dev Restored from https://polygonscan.com/address/0xb023e699F5a33916Ea823A16485e259257cA8Bd1#code\ninterface AggregatorInterface {\n  function latestAnswer() external view returns (int256);\n\n  function latestTimestamp() external view returns (uint256);\n\n  function latestRound() external view returns (uint256);\n\n  function getAnswer(uint256 roundId) external view returns (int256);\n\n  function getTimestamp(uint256 roundId) external view returns (uint256);\n\n  event AnswerUpdated(int256 indexed current, uint256 indexed roundId, uint256 updatedAt);\n\n  event NewRound(uint256 indexed roundId, address indexed startedBy, uint256 startedAt);\n}"
    },
    "contracts/integrations/aave/IAave3PriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Restored from 0x69FA688f1Dc47d4B5d8029D5a35FB7a548310654 (events were removed)\ninterface IAave3PriceOracle {\n  /**\n   * @notice Returns the PoolAddressesProvider\n   * @return The address of the PoolAddressesProvider contract\n   */\n  function ADDRESSES_PROVIDER() external view returns (address);\n  /**\n   * @notice Returns the base currency address\n   * @dev Address 0x0 is reserved for USD as base currency.\n   * @return Returns the base currency address.\n   **/\n  function BASE_CURRENCY() external view returns (address);\n  /**\n   * @notice Returns the base currency unit\n   * @dev 1 ether for ETH, 1e8 for USD.\n   * @return Returns the base currency unit.\n   **/\n  function BASE_CURRENCY_UNIT() external view returns (uint256);\n  /**\n   * @notice Returns the asset price in the base currency\n   * @param asset The address of the asset\n   * @return The price of the asset\n   **/\n  function getAssetPrice(address asset) external view returns (uint256);\n  /**\n   * @notice Returns a list of prices from a list of assets addresses\n   * @param assets The list of assets addresses\n   * @return The prices of the given assets\n   */\n  function getAssetsPrices(address[] memory assets) external view returns (uint256[] memory);\n  /**\n   * @notice Returns the address of the fallback oracle\n   * @return The address of the fallback oracle\n   */\n  function getFallbackOracle() external view returns (address);\n  /**\n   * @notice Returns the address of the source for an asset address\n   * @param asset The address of the asset\n   * @return The address of the source\n   */\n  function getSourceOfAsset(address asset) external view returns (address);\n  function setAssetSources(address[] memory assets, address[] memory sources) external;\n  function setFallbackOracle(address fallbackOracle) external;\n}\n"
    },
    "contracts/integrations/balancer/IBalancerBoostedAavePool.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"./IPoolSwapStructs.sol\";\n\n/// @notice Restored from Balancer Aave Boosted Pool (DAI) (bb-am-DAI) https://polygonscan.com/address/0x178E029173417b1F9C8bC16DCeC6f697bC323746\ninterface IBalancerBoostedAavePool {\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n  event PausedStateChanged(bool paused);\n  event RecoveryModeStateChanged(bool enabled);\n  event SwapFeePercentageChanged(uint256 swapFeePercentage);\n  event TargetsSet(address indexed token, uint256 lowerTarget, uint256 upperTarget);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function balanceOf(address account) external view returns (uint256);\n  function decimals() external view returns (uint8);\n  function decreaseAllowance(address spender, uint256 amount) external returns (bool);\n  function disableRecoveryMode() external;\n  function enableRecoveryMode() external;\n  function getActionId(bytes4 selector) external view returns (bytes32);\n  function getAuthorizer() external view returns (address);\n  function getBptIndex() external view returns (uint256);\n  function getDomainSeparator() external view returns (bytes32);\n  function getMainIndex() external view returns (uint256);\n\n  function getMainToken() external view returns (address);\n\n  function getNextNonce(address account) external view returns (uint256);\n  function getOwner() external view returns (address);\n\n  function getPausedState() external view returns (\n    bool paused,\n    uint256 pauseWindowEndTime,\n    uint256 bufferPeriodEndTime\n  );\n\n  function getPoolId() external view returns (bytes32);\n\n  function getProtocolFeesCollector() external view returns (address);\n\n  function getRate() external view returns (uint256);\n\n  function getScalingFactors() external view returns (uint256[] memory);\n  function getSwapFeePercentage() external view returns (uint256);\n\n  function getTargets() external view returns (uint256 lowerTarget, uint256 upperTarget);\n  function getVault() external view returns (address);\n  function getVirtualSupply() external view returns (uint256);\n  function getWrappedIndex() external view returns (uint256);\n\n  function getWrappedToken() external view returns (address);\n\n  /**\n   * @notice Return the conversion rate between the wrapped and main tokens.\n     * @dev This is an 18-decimal fixed point value.\n     */\n  function getWrappedTokenRate() external view returns (uint256);\n\n  function inRecoveryMode() external view returns (bool);\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n\n  function initialize() external;\n  function name() external view returns (string memory);\n  function nonces(address owner) external view returns (uint256);\n\n  function onExitPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onJoinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onSwap(\n    IPoolSwapStructs.SwapRequest memory request,\n    uint256[] memory balances,\n    uint256 indexIn,\n    uint256 indexOut\n  ) external returns (uint256);\n\n  function pause() external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function setAssetManagerPoolConfig(address token, bytes memory poolConfig) external;\n  function setSwapFeePercentage(uint256 swapFeePercentage) external;\n  function setTargets(uint256 newLowerTarget, uint256 newUpperTarget) external;\n  function symbol() external view returns (string memory);\n  function totalSupply() external view returns (uint256);\n\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  function unpause() external;\n}\n\ninterface AaveLinearPool {\n  struct ConstructorArgs {\n    address vault;\n    string name;\n    string symbol;\n    address mainToken;\n    address wrappedToken;\n    address assetManager;\n    uint256 upperTarget;\n    uint256 swapFeePercentage;\n    uint256 pauseWindowDuration;\n    uint256 bufferPeriodDuration;\n    address owner;\n  }\n}\n"
    },
    "contracts/integrations/balancer/IBalancerBoostedAaveStablePool.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"./IPoolSwapStructs.sol\";\n\n/// @notice Restored from https://polygonscan.com/address/0x48e6b98ef6329f8f0a30ebb8c7c960330d648085\ninterface IBalancerBoostedAaveStablePool {\n  event AmpUpdateStarted(\n    uint256 startValue,\n    uint256 endValue,\n    uint256 startTime,\n    uint256 endTime\n  );\n  event AmpUpdateStopped(uint256 currentValue);\n  event Approval(\n    address indexed owner,\n    address indexed spender,\n    uint256 value\n  );\n  event PausedStateChanged(bool paused);\n  event ProtocolFeePercentageCacheUpdated(\n    uint256 indexed feeType,\n    uint256 protocolFeePercentage\n  );\n  event RecoveryModeStateChanged(bool enabled);\n  event SwapFeePercentageChanged(uint256 swapFeePercentage);\n  event TokenRateCacheUpdated(uint256 indexed tokenIndex, uint256 rate);\n  event TokenRateProviderSet(\n    uint256 indexed tokenIndex,\n    address indexed provider,\n    uint256 cacheDuration\n  );\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  function DELEGATE_PROTOCOL_SWAP_FEES_SENTINEL() external view returns (uint256);\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address spender, uint256 amount) external returns (bool);\n  function balanceOf(address account) external view returns (uint256);\n  function decimals() external view returns (uint8);\n  function decreaseAllowance(address spender, uint256 amount) external returns (bool);\n  function disableRecoveryMode() external;\n  function enableRecoveryMode() external;\n  function getActionId(bytes4 selector) external view returns (bytes32);\n\n  /**\n   * @dev Returns the effective BPT supply.\n     *\n     * In other pools, this would be the same as `totalSupply`, but there are two key differences here:\n     *  - this pool pre-mints BPT and holds it in the Vault as a token, and as such we need to subtract the Vault's\n     *    balance to get the total \"circulating supply\". This is called the 'virtualSupply'.\n     *  - the Pool owes debt to the Protocol in the form of unminted BPT, which will be minted immediately before the\n     *    next join or exit. We need to take these into account since, even if they don't yet exist, they will\n     *    effectively be included in any Pool operation that involves BPT.\n     *\n     * In the vast majority of cases, this function should be used instead of `totalSupply()`.\n     */\n  function getActualSupply() external view returns (uint256);\n  function getAmplificationParameter() external view returns (\n    uint256 value,\n    bool isUpdating,\n    uint256 precision\n  );\n  function getAuthorizer() external view returns (address);\n  function getBptIndex() external view returns (uint256);\n  function getDomainSeparator() external view returns (bytes32);\n  function getLastJoinExitData() external view returns (\n    uint256 lastJoinExitAmplification,\n    uint256 lastPostJoinExitInvariant\n  );\n  function getMinimumBpt() external pure returns (uint256);\n  function getNextNonce(address account) external view returns (uint256);\n  function getOwner() external view returns (address);\n  function getPausedState() external view returns (\n    bool paused,\n    uint256 pauseWindowEndTime,\n    uint256 bufferPeriodEndTime\n  );\n  function getPoolId() external view returns (bytes32);\n  function getProtocolFeePercentageCache(uint256 feeType) external view returns (uint256);\n  function getProtocolFeesCollector() external view returns (address);\n  function getProtocolSwapFeeDelegation() external view returns (bool);\n  function getRate() external view returns (uint256);\n  function getRateProviders() external view returns (address[] memory);\n  function getScalingFactors() external view returns (uint256[] memory);\n  function getSwapFeePercentage() external view returns (uint256);\n  function getTokenRate(address token) external view returns (uint256);\n  function getTokenRateCache(address token) external view returns (\n    uint256 rate,\n    uint256 oldRate,\n    uint256 duration,\n    uint256 expires\n  );\n\n  function getVault() external view returns (address);\n  function inRecoveryMode() external view returns (bool);\n  function increaseAllowance(address spender, uint256 addedValue) external returns (bool);\n  function isTokenExemptFromYieldProtocolFee(address token) external view returns (bool);\n  function name() external view returns (string memory);\n  function nonces(address owner) external view returns (uint256);\n\n  function onExitPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onJoinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256[] memory, uint256[] memory);\n\n  function onSwap(\n    IPoolSwapStructs.SwapRequest memory swapRequest,\n    uint256[] memory balances,\n    uint256 indexIn,\n    uint256 indexOut\n  ) external returns (uint256);\n\n  function pause() external;\n\n  function permit(\n    address owner,\n    address spender,\n    uint256 value,\n    uint256 deadline,\n    uint8 v,\n    bytes32 r,\n    bytes32 s\n  ) external;\n\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function setAssetManagerPoolConfig(address token, bytes memory poolConfig) external;\n  function setSwapFeePercentage(uint256 swapFeePercentage) external;\n  function setTokenRateCacheDuration(address token, uint256 duration) external;\n\n  function startAmplificationParameterUpdate(uint256 rawEndValue, uint256 endTime) external;\n  function stopAmplificationParameterUpdate() external;\n  function symbol() external view returns (string memory);\n  function totalSupply() external view returns (uint256);\n  function transfer(address recipient, uint256 amount) external returns (bool);\n  function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n  function unpause() external;\n  function updateProtocolFeePercentageCache() external;\n  function updateTokenRateCache(address token) external;\n}\n\ninterface ComposableStablePool {\n  struct NewPoolParams {\n    address vault;\n    address protocolFeeProvider;\n    string name;\n    string symbol;\n    address[] tokens;\n    address[] rateProviders;\n    uint256[] tokenRateCacheDurations;\n    bool[] exemptFromYieldProtocolFeeFlags;\n    uint256 amplificationParameter;\n    uint256 swapFeePercentage;\n    uint256 pauseWindowDuration;\n    uint256 bufferPeriodDuration;\n    address owner;\n  }\n}"
    },
    "contracts/integrations/balancer/IBalancerGauge.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IBalancerGauge {\n  function decimals() external view returns (uint256);\n  function version() external view returns (string memory);\n\n  function last_claim() external view returns (uint256);\n  function claimed_reward(address _addr, address _token) external view returns (uint256);\n  function claimable_reward(address _addr, address _token) external view returns (uint256);\n  function claimable_reward_write(address _addr, address _token) external returns (uint256);\n\n  function reward_contract() external view returns (address);\n  function reward_data(address _token) external view returns (\n    address token,\n    address distributor,\n    uint256 period_finish,\n    uint256 rate,\n    uint256 last_update,\n    uint256 integral\n  );\n  function reward_tokens(uint256 arg0) external view returns (address);\n  function reward_balances(address arg0) external view returns (uint256);\n  function rewards_receiver(address arg0) external view returns (address);\n  function reward_integral(address arg0) external view returns (uint256);\n  function reward_integral_for(address arg0, address arg1) external view returns (uint256);\n  function set_rewards_receiver(address _receiver) external;\n  function set_rewards(\n    address _reward_contract,\n    bytes32 _claim_sig,\n    address[8] memory _reward_tokens\n  ) external;\n\n  function claim_rewards() external;\n  function claim_rewards(address _addr) external;\n  function claim_rewards(address _addr, address _receiver) external;\n\n  function deposit(uint256 _value) external;\n  function deposit(uint256 _value, address _addr) external;\n  function deposit(uint256 _value, address _addr, bool _claim_rewards) external;\n\n  function withdraw(uint256 _value) external;\n  function withdraw(uint256 _value, bool _claim_rewards) external;\n\n  function transfer(address _to, uint256 _value) external returns (bool);\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\n\n  function allowance(address owner, address spender) external view returns (uint256);\n  function approve(address _spender, uint256 _value) external returns (bool);\n\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _value,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external returns (bool);\n\n  function increaseAllowance(address _spender, uint256 _added_value) external returns (bool);\n  function decreaseAllowance(address _spender, uint256 _subtracted_value) external returns (bool);\n\n  function initialize(\n    address _lp_token,\n    address _reward_contract,\n    bytes32 _claim_sig\n  ) external;\n\n  function lp_token() external view returns (address);\n\n  function balanceOf(address arg0) external view returns (uint256);\n  function totalSupply() external view returns (uint256);\n  function name() external view returns (string memory);\n  function symbol() external view returns (string memory);\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n  function nonces(address arg0) external view returns (uint256);\n  function claim_sig() external view returns (bytes memory);\n}\n"
    },
    "contracts/integrations/balancer/IBalancerHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./IBVault.sol\";\n\ninterface IBalancerHelper {\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    IBVault.ExitPoolRequest memory request\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n  function queryJoin(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    IBVault.JoinPoolRequest memory request\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\n\n  function vault() external view returns (address);\n}\n"
    },
    "contracts/integrations/balancer/IBVault.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\n\ninterface IAsset {\n}\n\ninterface IBVault {\n  // Internal Balance\n  //\n  // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\n  // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\n  // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\n  // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\n  //\n  // Internal Balance management features batching, which means a single contract call can be used to perform multiple\n  // operations of different kinds, with different senders and recipients, at once.\n\n  /**\n   * @dev Returns `user`'s Internal Balance for a set of tokens.\n     */\n  function getInternalBalance(address user, IERC20[] calldata tokens) external view returns (uint256[] memory);\n\n  /**\n   * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\n     * it lets integrators reuse a user's Vault allowance.\n     *\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\n     */\n  function manageUserBalance(UserBalanceOp[] calldata ops) external payable;\n\n  /**\n   * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\n     without manual WETH wrapping or unwrapping.\n     */\n  struct UserBalanceOp {\n    UserBalanceOpKind kind;\n    IAsset asset;\n    uint256 amount;\n    address sender;\n    address payable recipient;\n  }\n\n  // There are four possible operations in `manageUserBalance`:\n  //\n  // - DEPOSIT_INTERNAL\n  // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\n  // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\n  // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\n  // relevant for relayers).\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - WITHDRAW_INTERNAL\n  // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\n  //\n  // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\n  // it to the recipient as ETH.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_INTERNAL\n  // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `InternalBalanceChanged` event.\n  //\n  //\n  // - TRANSFER_EXTERNAL\n  // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\n  // relayers, as it lets them reuse a user's Vault allowance.\n  //\n  // Reverts if the ETH sentinel value is passed.\n  //\n  // Emits an `ExternalBalanceTransfer` event.\n\n  enum UserBalanceOpKind {DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL}\n\n  /**\n   * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\n     * interacting with Pools using Internal Balance.\n     *\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\n     * address.\n     */\n  event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\n\n  /**\n   * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\n     */\n  event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\n\n  // Pools\n  //\n  // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\n  // functionality:\n  //\n  //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\n  // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\n  // which increase with the number of registered tokens.\n  //\n  //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\n  // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\n  // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\n  // independent of the number of registered tokens.\n  //\n  //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\n  // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\n\n  enum PoolSpecialization {GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN}\n\n  /**\n   * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\n     * changed.\n     *\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\n     *\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\n     * multiple Pools may share the same contract.\n     *\n     * Emits a `PoolRegistered` event.\n     */\n  function registerPool(PoolSpecialization specialization) external returns (bytes32);\n\n  /**\n   * @dev Emitted when a Pool is registered by calling `registerPool`.\n     */\n  event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\n\n  /**\n   * @dev Returns a Pool's contract address and specialization setting.\n     */\n  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\n\n  /**\n   * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\n     * exit by receiving registered tokens, and can only swap registered tokens.\n     *\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\n     * ascending order.\n     *\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\n     * Asset Manager should not be made lightly.\n     *\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\n     * different Asset Manager.\n     *\n     * Emits a `TokensRegistered` event.\n     */\n  function registerTokens(\n    bytes32 poolId,\n    IERC20[] calldata tokens,\n    address[] calldata assetManagers\n  ) external;\n\n  /**\n   * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\n     */\n  event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\n\n  /**\n   * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\n     *\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\n     * must be deregistered in the same `deregisterTokens` call.\n     *\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\n     *\n     * Emits a `TokensDeregistered` event.\n     */\n  function deregisterTokens(bytes32 poolId, IERC20[] calldata tokens) external;\n\n  /**\n   * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\n     */\n  event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\n\n  /**\n   * @dev Returns detailed information for a Pool's registered token.\n     *\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\n     * equals the sum of `cash` and `managed`.\n     *\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\n     * `managed` or `total` balance to be greater than 2^112 - 1.\n     *\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\n     * change for this purpose, and will update `lastChangeBlock`.\n     *\n     * `assetManager` is the Pool's token Asset Manager.\n     */\n  function getPoolTokenInfo(bytes32 poolId, IERC20 token)\n  external\n  view\n  returns (\n    uint256 cash,\n    uint256 managed,\n    uint256 lastChangeBlock,\n    address assetManager\n  );\n\n  /**\n   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\n     * the tokens' `balances` changed.\n     *\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\n     *\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\n     * order as passed to `registerTokens`.\n     *\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\n     * instead.\n     */\n  function getPoolTokens(bytes32 poolId)\n  external\n  view\n  returns (\n    IERC20[] memory tokens,\n    uint256[] memory balances,\n    uint256 lastChangeBlock\n  );\n\n  /**\n   * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\n     * Pool shares.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\n     * these maximums.\n     *\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\n     * back to the caller (not the sender, which is important for relayers).\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\n     *\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\n     *\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\n     * directly to the Pool's contract, as is `recipient`.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     *\n     * See https://dev.balancer.fi/resources/joins-and-exits/pool-joins\n     */\n  function joinPool(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    JoinPoolRequest calldata request\n  ) external payable;\n\n  enum JoinKind {INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT}\n\n  /// @notice WeightedPool ExitKinds\n  enum ExitKind {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT}\n  /// @notice Composable Stable V2 ExitKinds\n  enum ExitKindComposableStable {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT, EXACT_BPT_IN_FOR_ALL_TOKENS_OUT}\n\n\n  struct JoinPoolRequest {\n    IAsset[] assets;\n    uint256[] maxAmountsIn;\n    bytes userData;\n    bool fromInternalBalance;\n  }\n\n  /**\n   * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\n     * `getPoolTokenInfo`).\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\n     * it just enforces these minimums.\n     *\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\n     *\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\n     *\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\n     * do so will trigger a revert.\n     *\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\n     * `tokens` array. This array must match the Pool's registered tokens.\n     *\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\n     * passed directly to the Pool's contract.\n     *\n     * Emits a `PoolBalanceChanged` event.\n     */\n  function exitPool(\n    bytes32 poolId,\n    address sender,\n    address payable recipient,\n    ExitPoolRequest calldata request\n  ) external;\n\n  struct ExitPoolRequest {\n    IAsset[] assets;\n    uint256[] minAmountsOut;\n    bytes userData;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\n     */\n  event PoolBalanceChanged(\n    bytes32 indexed poolId,\n    address indexed liquidityProvider,\n    IERC20[] tokens,\n    int256[] deltas,\n    uint256[] protocolFeeAmounts\n  );\n\n  enum PoolBalanceChangeKind {JOIN, EXIT}\n\n  // Swaps\n  //\n  // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\n  // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\n  // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\n  //\n  // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\n  // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\n  // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\n  // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\n  // individual swaps.\n  //\n  // There are two swap kinds:\n  //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\n  // `onSwap` hook) the amount of tokens out (to send to the recipient).\n  //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\n  // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\n  //\n  // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\n  // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\n  // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\n  // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\n  // the final intended token.\n  //\n  // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\n  // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\n  // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\n  // much less gas than they would otherwise.\n  //\n  // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\n  // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\n  // updating the Pool's internal accounting).\n  //\n  // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\n  // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\n  // minimum amount of tokens to receive (by passing a negative value) is specified.\n  //\n  // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\n  // this point in time (e.g. if the transaction failed to be included in a block promptly).\n  //\n  // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\n  // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\n  // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\n  // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\n  //\n  // Finally, Internal Balance can be used when either sending or receiving tokens.\n\n  enum SwapKind {GIVEN_IN, GIVEN_OUT}\n\n  /**\n   * @dev Performs a swap with a single Pool.\n     *\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\n     * taken from the Pool, which must be greater than or equal to `limit`.\n     *\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\n     * sent to the Pool, which must be less than or equal to `limit`.\n     *\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\n     *\n     * Emits a `Swap` event.\n     */\n  function swap(\n    SingleSwap calldata singleSwap,\n    FundManagement calldata funds,\n    uint256 limit,\n    uint256 deadline\n  ) external payable returns (uint256);\n\n  /**\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\n     * the `kind` value.\n     *\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct SingleSwap {\n    bytes32 poolId;\n    SwapKind kind;\n    IAsset assetIn;\n    IAsset assetOut;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\n     *\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\n     * the same index in the `assets` array.\n     *\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\n     * `amountOut` depending on the swap kind.\n     *\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\n     *\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\n     * or unwrapped from WETH by the Vault.\n     *\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\n     *\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\n     * equivalent `swap` call.\n     *\n     * Emits `Swap` events.\n     */\n  function batchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds,\n    int256[] calldata limits,\n    uint256 deadline\n  ) external payable returns (int256[] memory);\n\n  /**\n   * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\n     *\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\n     * from the previous swap, depending on the swap kind.\n     *\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\n     * used to extend swap behavior.\n     */\n  struct BatchSwapStep {\n    bytes32 poolId;\n    uint256 assetInIndex;\n    uint256 assetOutIndex;\n    uint256 amount;\n    bytes userData;\n  }\n\n  /**\n   * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\n     */\n  event Swap(\n    bytes32 indexed poolId,\n    IERC20 indexed tokenIn,\n    IERC20 indexed tokenOut,\n    uint256 amountIn,\n    uint256 amountOut\n  );\n\n  /**\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\n     * `recipient` account.\n     *\n     * If the caller is not `sender`, it must be an authorized relayer for them.\n     *\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\n     * `joinPool`.\n     *\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\n     * transferred. This matches the behavior of `exitPool`.\n     *\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\n     * revert.\n     */\n  struct FundManagement {\n    address sender;\n    bool fromInternalBalance;\n    address payable recipient;\n    bool toInternalBalance;\n  }\n\n  /**\n   * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\n     *\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\n     * receives are the same that an equivalent `batchSwap` call would receive.\n     *\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\n     * approve them for the Vault, or even know a user's address.\n     *\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\n     * eth_call instead of eth_sendTransaction.\n     */\n  function queryBatchSwap(\n    SwapKind kind,\n    BatchSwapStep[] calldata swaps,\n    IAsset[] calldata assets,\n    FundManagement calldata funds\n  ) external returns (int256[] memory assetDeltas);\n\n  // BasePool.sol\n\n  /**\n* @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\n     *\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\n     * data, such as the protocol swap fee percentage and Pool balances.\n     *\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\n     * explicitly use eth_call instead of eth_sendTransaction.\n     */\n  function queryExit(\n    bytes32 poolId,\n    address sender,\n    address recipient,\n    uint256[] memory balances,\n    uint256 lastChangeBlock,\n    uint256 protocolSwapFeePercentage,\n    bytes memory userData\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\n\n\n}\n"
    },
    "contracts/integrations/balancer/IChildChainLiquidityGaugeFactory.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\n/// @notice ChildChainLiquidityGaugeFactory, restored for 0x3b8cA519122CdD8efb272b0D3085453404B25bD0\n/// @dev See https://dev.balancer.fi/resources/vebal-and-gauges/gauges\ninterface IChildChainLiquidityGaugeFactory {\n  event RewardsOnlyGaugeCreated(\n    address indexed gauge,\n    address indexed pool,\n    address streamer\n  );\n\n  function create(address pool) external returns (address);\n\n  function getChildChainStreamerImplementation() external view returns (address);\n  function getGaugeImplementation() external view returns (address);\n  function getGaugePool(address gauge) external view returns (address);\n  function getGaugeStreamer(address gauge) external view returns (address);\n  function getPoolGauge(address pool) external view returns (address);\n  function getPoolStreamer(address pool) external view returns (address);\n  function isGaugeFromFactory(address gauge) external view returns (bool);\n  function isStreamerFromFactory(address streamer) external view returns (bool);\n}\n\n"
    },
    "contracts/integrations/balancer/IPoolSwapStructs.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IPoolSwapStructs {\n  struct SwapRequest {\n    uint8 kind;\n    address tokenIn;\n    address tokenOut;\n    uint256 amount;\n    bytes32 poolId;\n    uint256 lastChangeBlock;\n    address from;\n    address to;\n    bytes userData;\n  }\n}"
    },
    "contracts/integrations/balancer/IRateProvider.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\ninterface IRateProvider {\n    /**\n     * @dev Returns an 18 decimal fixed point number that is the exchange rate of the token to some other underlying\n     * token. The meaning of this rate depends on the context.\n     */\n    function getRate() external view returns (uint256);\n}\n"
    },
    "contracts/integrations/dystopia/IBribe.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface IBribe {\n\n  function notifyRewardAmount(address token, uint amount) external;\n\n  function _deposit(uint amount, uint tokenId) external;\n\n  function _withdraw(uint amount, uint tokenId) external;\n\n  function getRewardForOwner(uint tokenId, address[] memory tokens) external;\n\n}\n"
    },
    "contracts/integrations/dystopia/IGauge.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface IGauge {\n\n  function veIds(address stakingToken, address account) external view returns (uint);\n\n  function getReward(\n    address stakingToken,\n    address account,\n    address[] memory tokens\n  ) external;\n\n  function getAllRewards(\n    address stakingToken,\n    address account\n  ) external;\n\n  function getAllRewardsForTokens(\n    address[] memory stakingTokens,\n    address account\n  ) external;\n\n  function attachVe(address stakingToken, address account, uint veId) external;\n\n  function detachVe(address stakingToken, address account, uint veId) external;\n\n  function handleBalanceChange(address account) external;\n\n  function notifyRewardAmount(address stakingToken, address token, uint amount) external;\n\n  function addStakingToken(address token) external;\n\n  function depositAll(uint tokenId) external;\n\n  function withdrawAll() external;\n\n  function withdraw(uint amount) external;\n\n  function balanceOf(address account) external view returns (uint);\n\n  function rewardTokensLength() external view returns (uint);\n\n  function rewardTokens(uint id) external view returns (address);\n\n  function claimFees() external returns (uint claimed0, uint claimed1);\n\n  function getReward(address account, address[] memory tokens) external;\n\n  function bribe() external view returns (address);\n\n\n}\n"
    },
    "contracts/integrations/dystopia/IPair.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface IPair {\n\n  // Structure to capture time period observations every 30 minutes, used for local oracles\n  struct Observation {\n    uint timestamp;\n    uint reserve0Cumulative;\n    uint reserve1Cumulative;\n  }\n\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n\n  function burn(address to) external returns (uint amount0, uint amount1);\n\n  function mint(address to) external returns (uint liquidity);\n\n  function getReserves() external view returns (uint112 _reserve0, uint112 _reserve1, uint32 _blockTimestampLast);\n\n  function getAmountOut(uint, address) external view returns (uint);\n\n  function claimFees() external returns (uint, uint);\n\n  function tokens() external view returns (address, address);\n\n  function token0() external view returns (address);\n\n  function token1() external view returns (address);\n\n  function totalSupply() external view returns (uint256);\n}\n"
    },
    "contracts/integrations/dystopia/IRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface IRouter {\n    function factory() external view returns (address);\n    function WMATIC() external view returns (address);\n\n    function addLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint amountADesired,\n        uint amountBDesired,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidity);\n    function addLiquidityMATIC(\n        address token,\n        bool stable,\n        uint amountTokenDesired,\n        uint amountTokenMin,\n        uint amountMATICMin,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountMATIC, uint liquidity);\n    function removeLiquidity(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityMATIC(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMATICMin,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountMATIC);\n    function removeLiquidityWithPermit(\n        address tokenA,\n        address tokenB,\n        bool stable,\n        uint liquidity,\n        uint amountAMin,\n        uint amountBMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountA, uint amountB);\n    function removeLiquidityMATICWithPermit(\n        address token,\n        bool stable,\n        uint liquidity,\n        uint amountTokenMin,\n        uint amountMATICMin,\n        address to,\n        uint deadline,\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\n    ) external returns (uint amountToken, uint amountMATIC);\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n    function swapExactMATICForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n    function swapTokensForExactMATIC(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapExactTokensForMATIC(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n        external\n        returns (uint[] memory amounts);\n    function swapMATICForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n        external\n        payable\n        returns (uint[] memory amounts);\n\n  function quoteRemoveLiquidity(\n    address tokenA,\n    address tokenB,\n    bool stable,\n    uint liquidity\n  ) external view returns (uint amountA, uint amountB);\n    function quoteAddLiquidity(\n    address tokenA,\n    address tokenB,\n    bool stable,\n    uint amountADesired,\n    uint amountBDesired\n  ) external view returns (uint amountA, uint amountB, uint liquidity);\n\n    function pairFor(address tokenA, address tokenB, bool stable) external view returns (address pair);\n    function sortTokens(address tokenA, address tokenB) external pure returns (address token0, address token1);\n    function quoteLiquidity(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut, bool stable);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn, bool stable);\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n    function getReserves(address tokenA, address tokenB, bool stable) external view returns (uint reserveA, uint reserveB);\n\n    function swapExactTokensForTokensSimple(\n        uint amountIn,\n        uint amountOutMin,\n        address tokenFrom,\n        address tokenTo,\n        bool stable,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n}\n"
    },
    "contracts/integrations/dystopia/IVoter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface IVoter {\n\n  function ve() external view returns (address);\n\n  function attachTokenToGauge(uint _tokenId, address account) external;\n\n  function detachTokenFromGauge(uint _tokenId, address account) external;\n\n  function emitDeposit(uint _tokenId, address account, uint amount) external;\n\n  function emitWithdraw(uint _tokenId, address account, uint amount) external;\n\n  function distribute(address _gauge) external;\n\n  function notifyRewardAmount(uint amount) external;\n\n  function gauges(address pool) external view returns (address gauge);\n\n\n}\n"
    },
    "contracts/integrations/quickswap/IDragonLair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\n\ninterface IDragonLair {\n\n  function quick() external view returns (IERC20);\n\n  // Enter the lair. Pay some QUICK. Earn some dragon QUICK.\n  function enter(uint256 _quickAmount) external;\n\n  // Leave the lair. Claim back your QUICK.\n  function leave(uint256 _dQuickAmount) external;\n\n  // returns the total amount of QUICK an address has in the contract including fees earned\n  function QUICKBalance(address _account) external view returns (uint256 quickAmount_);\n\n  //returns how much QUICK someone gets for depositing dQUICK\n  function dQUICKForQUICK(uint256 _dQuickAmount) external view returns (uint256 quickAmount_);\n\n  //returns how much dQUICK someone gets for depositing QUICK\n  function QUICKForDQUICK(uint256 _quickAmount) external view returns (uint256 dQuickAmount_);\n}\n"
    },
    "contracts/integrations/quickswap/IStakingBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\n\n/// @notice Common methods from quickswap-core, IStakingDualRewards and IStakingRewards\n/// @dev This interface allows us to use QuickswapDepositor for two different kinds of the rewards pools\ninterface IStakingBase {\n  function lastTimeRewardApplicable() external view returns (uint256);\n  function totalSupply() external view returns (uint256);\n  function balanceOf(address account) external view returns (uint256);\n\n  function stake(uint256 amount) external;\n  function withdraw(uint256 amount) external;\n  function getReward() external;\n  function exit() external;\n  function stakingToken() external view returns (IERC20);\n\n  function periodFinish() external view returns (uint256);\n}\n"
    },
    "contracts/integrations/quickswap/IStakingDualRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"./IStakingBase.sol\";\n\ninterface IStakingDualRewards is IStakingBase {\n  /////////////////////////////////////////////////\n  /// quickswap-core, IStakingDualRewards\n  /////////////////////////////////////////////////\n  // Views\n  function rewardPerTokenA() external view returns (uint256);\n  function rewardPerTokenB() external view returns (uint256);\n\n  function earnedA(address account) external view returns (uint256);\n  function earnedB(address account) external view returns (uint256);\n\n  /////////////////////////////////////////////////\n  /// quickswap-core, StakingDualRewards\n  /////////////////////////////////////////////////\n  function rewardsTokenA() external view returns (IERC20);\n  function rewardsTokenB() external view returns (IERC20);\n  function rewardRateA() external view returns (uint256);\n  function rewardRateB() external view returns (uint256);\n}\n"
    },
    "contracts/integrations/quickswap/IStakingRewards.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"./IStakingBase.sol\";\n\ninterface IStakingRewards is IStakingBase {\n/////////////////////////////////////////////////\n/// quickswap-core, IStakingRewards\n/////////////////////////////////////////////////\n\n  // Views\n  function rewardPerToken() external view returns (uint256);\n  function earned(address account) external view returns (uint256);\n\n  /////////////////////////////////////////////////\n  /// quickswap-core, StakingRewards\n  /////////////////////////////////////////////////\n  function rewardsToken() external view returns (IERC20);\n  function rewardRate() external view returns (uint256);\n}"
    },
    "contracts/integrations/quickswap/IStakingRewardsFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface IStakingRewardsFactory {\n  // info about rewards for a particular staking token\n  struct StakingRewardsInfo {\n    address stakingRewards;\n    uint rewardAmount;\n    uint duration;\n  }\n\n  function rewardsToken() external view returns (address);\n\n  function stakingRewardsGenesis() external view returns (uint);\n\n  function stakingTokens(uint256 idx) external view returns (address);\n\n  function stakingRewardsInfoByStakingToken(address _adr) external view returns (StakingRewardsInfo memory);\n\n}\n"
    },
    "contracts/integrations/quickswap/IStakingRewardsFactoryV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface IStakingRewardsFactoryV2 {\n  // info about rewards for a particular staking token\n  struct StakingRewardsInfo {\n    address stakingRewards;\n    address rewardsTokenA;\n    address rewardsTokenB;\n    uint256 rewardAmountA;\n    uint256 rewardAmountB;\n    uint256 duration;\n  }\n\n  function stakingRewardsGenesis() external view returns (uint);\n\n  function stakingTokens(uint256 idx) external view returns (address);\n\n  function stakingRewardsInfoByStakingToken(address _adr) external view returns (StakingRewardsInfo memory);\n\n}\n"
    },
    "contracts/integrations/tetu-v1/ISmartVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ISmartVault {\n  function DEPOSIT_FEE_DENOMINATOR() external view returns (uint256);\n\n  function LOCK_PENALTY_DENOMINATOR() external view returns (uint256);\n\n  function TO_INVEST_DENOMINATOR() external view returns (uint256);\n\n  function VERSION() external view returns (string memory);\n\n  function active() external view returns (bool);\n\n  function addRewardToken(address rt) external;\n\n  function alwaysInvest() external view returns (bool);\n\n  function availableToInvestOut() external view returns (uint256);\n\n  function changeActivityStatus(bool _active) external;\n\n  function changeAlwaysInvest(bool _active) external;\n\n  function changeDoHardWorkOnInvest(bool _active) external;\n\n  function changePpfsDecreaseAllowed(bool _value) external;\n\n  function changeProtectionMode(bool _active) external;\n\n  function deposit(uint256 amount) external;\n\n  function depositAndInvest(uint256 amount) external;\n\n  function depositFeeNumerator() external view returns (uint256);\n\n  function depositFor(uint256 amount, address holder) external;\n\n  function disableLock() external;\n\n  function doHardWork() external;\n\n  function doHardWorkOnInvest() external view returns (bool);\n\n  function duration() external view returns (uint256);\n\n  function earned(address rt, address account) external view returns (uint256);\n\n  function earnedWithBoost(address rt, address account) external view returns (uint256);\n\n  function exit() external;\n\n  function getAllRewards() external;\n\n  function getAllRewardsAndRedirect(address owner) external;\n\n  function getPricePerFullShare() external view returns (uint256);\n\n  function getReward(address rt) external;\n\n  function getRewardTokenIndex(address rt) external view returns (uint256);\n\n  function initializeSmartVault(\n    string memory _name,\n    string memory _symbol,\n    address _controller,\n    address __underlying,\n    uint256 _duration,\n    bool _lockAllowed,\n    address _rewardToken,\n    uint256 _depositFee\n  ) external;\n\n  function lastTimeRewardApplicable(address rt) external view returns (uint256);\n\n  function lastUpdateTimeForToken(address) external view returns (uint256);\n\n  function lockAllowed() external view returns (bool);\n\n  function lockPenalty() external view returns (uint256);\n\n  function notifyRewardWithoutPeriodChange(address _rewardToken, uint256 _amount) external;\n\n  function notifyTargetRewardAmount(address _rewardToken, uint256 amount) external;\n\n  function overrideName(string memory value) external;\n\n  function overrideSymbol(string memory value) external;\n\n  function periodFinishForToken(address) external view returns (uint256);\n\n  function ppfsDecreaseAllowed() external view returns (bool);\n\n  function protectionMode() external view returns (bool);\n\n  function rebalance() external;\n\n  function removeRewardToken(address rt) external;\n\n  function rewardPerToken(address rt) external view returns (uint256);\n\n  function rewardPerTokenStoredForToken(address) external view returns (uint256);\n\n  function rewardRateForToken(address) external view returns (uint256);\n\n  function rewardTokens() external view returns (address[] memory);\n\n  function rewardTokensLength() external view returns (uint256);\n\n  function rewardsForToken(address, address) external view returns (uint256);\n\n  function setLockPenalty(uint256 _value) external;\n\n  function setRewardsRedirect(address owner, address receiver) external;\n\n  function setLockPeriod(uint256 _value) external;\n\n  function setStrategy(address newStrategy) external;\n\n  function setToInvest(uint256 _value) external;\n\n  function stop() external;\n\n  function strategy() external view returns (address);\n\n  function toInvest() external view returns (uint256);\n\n  function underlying() external view returns (address);\n\n  function underlyingBalanceInVault() external view returns (uint256);\n\n  function underlyingBalanceWithInvestment() external view returns (uint256);\n\n  function underlyingBalanceWithInvestmentForHolder(address holder) external view returns (uint256);\n\n  function underlyingUnit() external view returns (uint256);\n\n  function userBoostTs(address) external view returns (uint256);\n\n  function userLastDepositTs(address) external view returns (uint256);\n\n  function userLastWithdrawTs(address) external view returns (uint256);\n\n  function userLockTs(address) external view returns (uint256);\n\n  function userRewardPerTokenPaidForToken(address, address) external view returns (uint256);\n\n  function withdraw(uint256 numberOfShares) external;\n\n  function withdrawAllToVault() external;\n\n  function getAllRewardsFor(address rewardsReceiver) external;\n\n  function lockPeriod() external view returns (uint256);\n}\n"
    },
    "contracts/integrations/tetu-v1/ITetuV1Controller.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface ITetuV1Controller {\n\n\n  function VERSION() external view returns (string memory);\n\n  function addHardWorker(address _worker) external;\n\n  function addStrategiesToSplitter(\n    address _splitter,\n    address[] memory _strategies\n  ) external;\n\n  function addStrategy(address _strategy) external;\n\n  function addVaultsAndStrategies(\n    address[] memory _vaults,\n    address[] memory _strategies\n  ) external;\n\n  function announcer() external view returns (address);\n\n  function bookkeeper() external view returns (address);\n\n  function changeWhiteListStatus(address[] memory _targets, bool status)\n  external;\n\n  function controllerTokenMove(\n    address _recipient,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function dao() external view returns (address);\n\n  function distributor() external view returns (address);\n\n  function doHardWork(address _vault) external;\n\n  function feeRewardForwarder() external view returns (address);\n\n  function fund() external view returns (address);\n\n  function fundDenominator() external view returns (uint256);\n\n  function fundKeeperTokenMove(\n    address _fund,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function fundNumerator() external view returns (uint256);\n\n  function fundToken() external view returns (address);\n\n  function governance() external view returns (address);\n\n  function hardWorkers(address) external view returns (bool);\n\n  function initialize() external;\n\n  function isAllowedUser(address _adr) external view returns (bool);\n\n  function isDao(address _adr) external view returns (bool);\n\n  function isHardWorker(address _adr) external view returns (bool);\n\n  function isPoorRewardConsumer(address _adr) external view returns (bool);\n\n  function isRewardDistributor(address _adr) external view returns (bool);\n\n  function isValidStrategy(address _strategy) external view returns (bool);\n\n  function isValidVault(address _vault) external view returns (bool);\n\n  function mintAndDistribute(uint256 totalAmount, bool mintAllAvailable)\n  external;\n\n  function mintHelper() external view returns (address);\n\n  function psDenominator() external view returns (uint256);\n\n  function psNumerator() external view returns (uint256);\n\n  function psVault() external view returns (address);\n\n  function pureRewardConsumers(address) external view returns (bool);\n\n  function rebalance(address _strategy) external;\n\n  function removeHardWorker(address _worker) external;\n\n  function rewardDistribution(address) external view returns (bool);\n\n  function rewardToken() external view returns (address);\n\n  function setAnnouncer(address _newValue) external;\n\n  function setBookkeeper(address newValue) external;\n\n  function setDao(address newValue) external;\n\n  function setDistributor(address _distributor) external;\n\n  function setFeeRewardForwarder(address _feeRewardForwarder) external;\n\n  function setFund(address _newValue) external;\n\n  function setFundNumeratorDenominator(uint256 numerator, uint256 denominator)\n  external;\n\n  function setFundToken(address _newValue) external;\n\n  function setGovernance(address newValue) external;\n\n  function setMintHelper(address _newValue) external;\n\n  function setPSNumeratorDenominator(uint256 numerator, uint256 denominator)\n  external;\n\n  function setPsVault(address _newValue) external;\n\n  function setPureRewardConsumers(address[] memory _targets, bool _flag)\n  external;\n\n  function setRewardDistribution(\n    address[] memory _newRewardDistribution,\n    bool _flag\n  ) external;\n\n  function setRewardToken(address _newValue) external;\n\n  function setVaultController(address _newValue) external;\n\n  function setVaultStrategyBatch(\n    address[] memory _vaults,\n    address[] memory _strategies\n  ) external;\n\n  function strategies(address) external view returns (bool);\n\n  function strategyTokenMove(\n    address _strategy,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  function upgradeTetuProxyBatch(\n    address[] memory _contracts,\n    address[] memory _implementations\n  ) external;\n\n  function vaultController() external view returns (address);\n\n  function vaults(address) external view returns (bool);\n\n  function whiteList(address) external view returns (bool);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IUniswapV2Factory {\n  event PairCreated(address indexed token0, address indexed token1, address pair, uint);\n\n  function feeTo() external view returns (address);\n  function feeToSetter() external view returns (address);\n\n  function getPair(address tokenA, address tokenB) external view returns (address pair);\n  function allPairs(uint) external view returns (address pair);\n  function allPairsLength() external view returns (uint);\n\n  function createPair(address tokenA, address tokenB) external returns (address pair);\n\n  function setFeeTo(address) external;\n  function setFeeToSetter(address) external;\n}"
    },
    "contracts/integrations/uniswap/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IUniswapV2Pair {\n  event Approval(address indexed owner, address indexed spender, uint value);\n  event Transfer(address indexed from, address indexed to, uint value);\n\n  function name() external pure returns (string memory);\n  function symbol() external pure returns (string memory);\n  function decimals() external pure returns (uint8);\n  function totalSupply() external view returns (uint);\n  function balanceOf(address owner) external view returns (uint);\n  function allowance(address owner, address spender) external view returns (uint);\n\n  function approve(address spender, uint value) external returns (bool);\n  function transfer(address to, uint value) external returns (bool);\n  function transferFrom(address from, address to, uint value) external returns (bool);\n\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\n  function PERMIT_TYPEHASH() external pure returns (bytes32);\n  function nonces(address owner) external view returns (uint);\n\n  function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n  event Mint(address indexed sender, uint amount0, uint amount1);\n  event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\n  event Swap(\n    address indexed sender,\n    uint amount0In,\n    uint amount1In,\n    uint amount0Out,\n    uint amount1Out,\n    address indexed to\n  );\n  event Sync(uint112 reserve0, uint112 reserve1);\n\n  function MINIMUM_LIQUIDITY() external pure returns (uint);\n  function factory() external view returns (address);\n  function token0() external view returns (address);\n  function token1() external view returns (address);\n  function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\n  function price0CumulativeLast() external view returns (uint);\n  function price1CumulativeLast() external view returns (uint);\n  function kLast() external view returns (uint);\n\n  function mint(address to) external returns (uint liquidity);\n  function burn(address to) external returns (uint amount0, uint amount1);\n  function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\n  function skim(address to) external;\n  function sync() external;\n\n  function initialize(address, address) external;\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\ninterface IUniswapV2Router01 {\n  function factory() external pure returns (address);\n  function WETH() external pure returns (address);\n\n  function addLiquidity(\n    address tokenA,\n    address tokenB,\n    uint amountADesired,\n    uint amountBDesired,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountA, uint amountB, uint liquidity);\n  function addLiquidityETH(\n    address token,\n    uint amountTokenDesired,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\n  function removeLiquidity(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountA, uint amountB);\n  function removeLiquidityETH(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountToken, uint amountETH);\n  function removeLiquidityWithPermit(\n    address tokenA,\n    address tokenB,\n    uint liquidity,\n    uint amountAMin,\n    uint amountBMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  ) external returns (uint amountA, uint amountB);\n  function removeLiquidityETHWithPermit(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  ) external returns (uint amountToken, uint amountETH);\n  function swapExactTokensForTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n  function swapTokensForExactTokens(\n    uint amountOut,\n    uint amountInMax,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external returns (uint[] memory amounts);\n  function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  payable\n  returns (uint[] memory amounts);\n  function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\n  external\n  returns (uint[] memory amounts);\n  function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\n  external\n  returns (uint[] memory amounts);\n  function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\n  external\n  payable\n  returns (uint[] memory amounts);\n\n  function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n  function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n  function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n  function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n  function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}\n"
    },
    "contracts/integrations/uniswap/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport './IUniswapV2Router01.sol';\n\n/// @notice Roter release 2, currently recommended version\n/// @dev https://docs.quickswap.exchange/reference/smart-contracts/router02\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\n  function removeLiquidityETHSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline\n  ) external returns (uint amountETH);\n  function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\n    address token,\n    uint liquidity,\n    uint amountTokenMin,\n    uint amountETHMin,\n    address to,\n    uint deadline,\n    bool approveMax, uint8 v, bytes32 r, bytes32 s\n  ) external returns (uint amountETH);\n\n  function swapExactTokensForTokensSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n  function swapExactETHForTokensSupportingFeeOnTransferTokens(\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external payable;\n  function swapExactTokensForETHSupportingFeeOnTransferTokens(\n    uint amountIn,\n    uint amountOutMin,\n    address[] calldata path,\n    address to,\n    uint deadline\n  ) external;\n}\n"
    },
    "contracts/interfaces/converter/AppDataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nlibrary AppDataTypes {\n\n  enum ConversionKind {\n    UNKNOWN_0,\n    SWAP_1,\n    BORROW_2\n  }\n\n  /// @notice Input params for BorrowManager.findPool (stack is too deep problem)\n  struct InputConversionParams {\n    address collateralAsset;\n    address borrowAsset;\n\n    /// @notice Encoded entry kind and additional params if necessary (set of params depends on the kind)\n    ///         See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n    bytes entryData;\n\n    uint countBlocks;\n    /// @notice Amount of {sourceToken} to be converted to {targetToken}\n    uint collateralAmount;\n  }\n\n  /// @notice Explain how a given lending pool can make specified conversion\n  struct ConversionPlan {\n    /// @notice Template adapter contract that implements required strategy.\n    address converter;\n    /// @notice Current collateral factor [0..1e18], where 1e18 is corresponded to CF=1\n    uint liquidationThreshold18;\n\n    /// @notice Amount to borrow in terms of borrow asset\n    uint amountToBorrow;\n    /// @notice Amount to be used as collateral in terms of collateral asset\n    uint collateralAmount;\n\n    /// @notice Cost for the period calculated using borrow rate in terms of borrow tokens, decimals 36\n    /// @dev It doesn't take into account supply increment and rewards\n    uint borrowCost36;\n    /// @notice Potential supply increment after borrow period recalculated to Borrow Token, decimals 36\n    uint supplyIncomeInBorrowAsset36;\n    /// @notice Potential rewards amount after borrow period in terms of Borrow Tokens, decimals 36\n    uint rewardsAmountInBorrowAsset36;\n    /// @notice Amount of collateral in terms of borrow asset, decimals 36\n    uint amountCollateralInBorrowAsset36;\n\n    /// @notice Loan-to-value, decimals = 18 (wad)\n    uint ltv18;\n    /// @notice How much borrow asset we can borrow in the pool (in borrow tokens)\n    uint maxAmountToBorrow;\n    /// @notice How much collateral asset can be supplied (in collateral tokens).\n    ///         type(uint).max - unlimited, 0 - no supply is possible\n    uint maxAmountToSupply;\n  }\n\n  struct PricesAndDecimals {\n    /// @notice Price of the collateral asset (decimals same as the decimals of {priceBorrow})\n    uint priceCollateral;\n    /// @notice Price of the borrow asset (decimals same as the decimals of {priceCollateral})\n    uint priceBorrow;\n    /// @notice 10**{decimals of the collateral asset}\n    uint rc10powDec;\n    /// @notice 10**{decimals of the borrow asset}\n    uint rb10powDec;\n  }\n}\n"
    },
    "contracts/interfaces/converter/EntryKinds.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\nlibrary EntryKinds {\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\n\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\n  ///         C2 should be used as collateral to make a borrow B.\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\n\n  /// @notice Borrow given amount using min possible collateral\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\n\n  /// @notice Decode entryData, extract first uint - entry kind\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\n    if (entryData_.length == 0) {\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\n    }\n    return abi.decode(entryData_, (uint));\n  }\n}\n"
    },
    "contracts/interfaces/converter/IBorrowManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"./AppDataTypes.sol\";\n\n/// @notice Manage list of available lending platforms\n///         Manager of pool-adapters.\n///         Pool adapter is an instance of a converter provided by the lending platform\n///         linked to one of platform's pools, address of user contract, collateral and borrow tokens.\n///         The pool adapter is real borrower of funds for AAVE, Compound and other lending protocols.\n///         Pool adapters are created using minimal-proxy pattern, see\n///         https://blog.openzeppelin.com/deep-dive-into-the-minimal-proxy-contract/\ninterface IBorrowManager {\n\n  /// @notice Register a pool adapter for (pool, user, collateral) if the adapter wasn't created before\n  /// @param user_ Address of the caller contract who requires access to the pool adapter\n  /// @return Address of registered pool adapter\n  function registerPoolAdapter(\n    address converter_,\n    address user_,\n    address collateral_,\n    address borrowToken_\n  ) external returns (address);\n\n  /// @notice Get pool adapter or 0 if the pool adapter is not registered\n  function getPoolAdapter(\n    address converter_,\n    address user_,\n    address collateral_,\n    address borrowToken_\n  ) external view returns (address);\n\n  /// @dev Returns true for NORMAL pool adapters and for active DIRTY pool adapters (=== borrow position is opened).\n  function isPoolAdapter(address poolAdapter_) external view returns (bool);\n\n  /// @notice Notify borrow manager that the pool adapter with the given params is \"dirty\".\n  ///         The pool adapter should be excluded from the list of ready-to-borrow pool adapters.\n  /// @dev \"Dirty\" means that a liquidation happens inside. The borrow position should be closed during health checking.\n  function markPoolAdapterAsDirty (\n    address converter_,\n    address user_,\n    address collateral_,\n    address borrowToken_\n  ) external;\n\n  /// @notice Register new lending platform with available pairs of assets\n  ///         OR add new pairs of assets to the exist lending platform\n  /// @param platformAdapter_ Implementation of IPlatformAdapter attached to the specified pool\n  /// @param leftAssets_  Supported pairs of assets. The pairs are set using two arrays: left and right\n  /// @param rightAssets_  Supported pairs of assets. The pairs are set using two arrays: left and right\n  function addAssetPairs(\n    address platformAdapter_,\n    address[] calldata leftAssets_,\n    address[] calldata rightAssets_\n  ) external;\n\n  /// @notice Remove available pairs of asset from the platform adapter.\n  ///         The platform adapter will be unregistered after removing last supported pair of assets\n  function removeAssetPairs(\n    address platformAdapter_,\n    address[] calldata leftAssets_,\n    address[] calldata rightAssets_\n  ) external;\n\n  /// @notice Set target health factors for the assets.\n  ///         If target health factor is not assigned to the asset, target-health-factor from controller is used.\n  ///         See explanation of health factor value in IController\n  /// @param healthFactors2_ Health factor must be greater or equal then 1, decimals 2\n  function setTargetHealthFactors(address[] calldata assets_, uint16[] calldata healthFactors2_) external;\n\n  /// @notice Return target health factor with decimals 2 for the asset\n  ///         If there is no custom value for asset, target health factor from the controller should be used\n  function getTargetHealthFactor2(address asset) external view returns (uint16);\n\n  /// @notice Reward APR is taken into account with given factor\n  ///         Result APR = borrow-apr - supply-apr - [REWARD-FACTOR]/Denominator * rewards-APR\n  function setRewardsFactor(uint rewardsFactor_) external;\n\n  /// @notice Find lending pool capable of providing {targetAmount} and having best normalized borrow rate\n  /// @return converter Result template-pool-adapter or 0 if a pool is not found\n  /// @return collateralAmountOut Amount that should be provided as a collateral\n  /// @return amountToBorrowOut Amount that should be borrowed\n  /// @return apr18 Annual Percentage Rate == (total cost - total income) / amount of collateral, decimals 18\n  function findConverter(AppDataTypes.InputConversionParams memory params) external view returns (\n    address converter,\n    uint collateralAmountOut,\n    uint amountToBorrowOut,\n    int apr18\n  );\n\n  /// @notice Get platformAdapter to which the converter belongs\n  function getPlatformAdapter(address converter_) external view returns (address);\n}\n"
    },
    "contracts/interfaces/converter/IConverterController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @notice Keep and provide addresses of all application contracts\ninterface IConverterController {\n  function governance() external view returns (address);\n\n  /// @notice min allowed health factor with decimals 2\n  function minHealthFactor2() external view returns (uint16);\n  function setMinHealthFactor2(uint16 value_) external;\n\n  /// @notice max allowed health factor with decimals 2\n  function maxHealthFactor2() external view returns (uint16);\n  function setMaxHealthFactor2(uint16 value_) external;\n\n  /// @notice target health factor with decimals 2\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\n  ///      or additional borrow and restore the health factor to the given target value\n  function targetHealthFactor2() external view returns (uint16);\n  function setTargetHealthFactor2(uint16 value_) external;\n\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\n  function blocksPerDay() external view returns (uint);\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\n  /// @notice Check if it's time to call updateBlocksPerDay()\n  /// @param periodInSeconds_ Period of auto-update in seconds\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\n  /// @notice Recalculate blocksPerDay value\n  /// @param periodInSeconds_ Period of auto-update in seconds\n  function updateBlocksPerDay(uint periodInSeconds_) external;\n\n\n  ///////////////////////////////////////////////////////\n  ///        Core application contracts\n  ///////////////////////////////////////////////////////\n\n  function tetuConverter() external view returns (address);\n  function borrowManager() external view returns (address);\n  function debtMonitor() external view returns (address);\n  function tetuLiquidator() external view returns (address);\n  function swapManager() external view returns (address);\n  function priceOracle() external view returns (address);\n\n  ///////////////////////////////////////////////////////\n  ///        External contracts\n  ///////////////////////////////////////////////////////\n  /// @notice A keeper to control health and efficiency of the borrows\n  function keeper() external view returns (address);\n\n}\n"
    },
    "contracts/interfaces/converter/IPlatformAdapter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"./AppDataTypes.sol\";\n\n/// @notice Adapter for lending platform attached to the given platform's pool.\ninterface IPlatformAdapter {\n\n  /// @notice Get pool data required to select best lending pool\n  /// @param healthFactor2_ Health factor (decimals 2) to be able to calculate max borrow amount\n  ///                       See IController for explanation of health factors.\n  function getConversionPlan(\n    AppDataTypes.InputConversionParams memory params_,\n    uint16 healthFactor2_\n  ) external view returns (\n    AppDataTypes.ConversionPlan memory plan\n  );\n\n  /// @notice Full list of supported converters\n  function converters() external view returns (address[] memory);\n\n  /// @notice Initialize {poolAdapter_} created from {converter_} using minimal proxy pattern\n  function initializePoolAdapter(\n    address converter_,\n    address poolAdapter_,\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) external;\n\n  /// @notice Estimate value of variable borrow rate after borrowing {amountToBorrow_}\n  function getBorrowRateAfterBorrow(address borrowAsset_, uint amountToBorrow_) external view returns (uint);\n\n  /// @notice True if the platform is frozen and new borrowing is not possible (at this moment)\n  function frozen() external view returns (bool);\n\n  /// @notice Set platform to frozen/unfrozen state. In frozen state any new borrowing is forbidden.\n  function setFrozen(bool frozen_) external;\n}\n"
    },
    "contracts/interfaces/converter/IPriceOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IPriceOracle {\n  /// @notice Return asset price in USD, decimals 18\n  function getAssetPrice(address asset) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/converter/ITetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n/// @notice Main contract of the TetuConverter application\n/// @dev Borrower (strategy) makes all operations via this contract only.\ninterface ITetuConverter {\n  function controller() external view returns (address);\n\n  /// @notice Find possible borrow strategies and provide \"cost of money\" as interest for the period for each strategy\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param amountIn_  The meaning depends on entryData\n  ///                   For entryKind=0 it's max available amount of collateral\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\n  /// @return converters Array of available converters ordered in ascending order of APR.\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\n  ///                    This address should be passed to borrow-function during conversion.\n  ///                    The length of array is always equal to the count of available lending platforms.\n  ///                    Last items in array can contain zero addresses (it means they are not used)\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\n  /// @return amountToBorrowsOut Amounts that should be borrowed\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\n  function findBorrowStrategies(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountToBorrowsOut,\n    int[] memory aprs18\n  );\n\n  /// @notice Find best swap strategy and provide \"cost of money\" as interest for the period\n  /// @dev This is writable function with read-only behavior.\n  ///      It should be writable to be able to simulate real swap and get a real APR.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param sourceAmount_ Max amount that can be swapped.\n  ///                      This amount must be approved to TetuConverter before the call.\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\n  function findSwapStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external returns (\n    address converter,\n    uint sourceAmountOut,\n    uint targetAmountOut,\n    int apr18\n  );\n\n  /// @notice Find best conversion strategy (swap or borrow) and provide \"cost of money\" as interest for the period.\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\n  /// @dev This is writable function with read-only behavior.\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 is used by default\n  /// @param sourceAmount_ Max amount of {sourceToken_} that can be converted.\n  ///        The amount must be approved to TetuConverter before calling this function.\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\n  function findConversionStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external returns (\n    address converter,\n    uint collateralAmountOut,\n    uint amountToBorrowOut,\n    int apr18\n  );\n\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\n  /// @param converter_ A converter received from findBestConversionStrategy.\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\n  ///                          This amount must be approved to TetuConverter before the call.\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\n  /// @param receiver_ A receiver of borrowed amount\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\n  function borrow(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_\n  ) external returns (\n    uint borrowedAmountOut\n  );\n\n  /// @notice Full or partial repay of the borrow\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\n  ///                       You can know exact total amount of debt using {getStatusCurrent}.\n  ///                       if the amount exceed total amount of the debt:\n  ///                       - the debt will be fully repaid\n  ///                       - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\n  ///         If TetuConverter is not able to make the swap, it reverts\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\n  ///                                 This amount is returned back to the collateralReceiver_\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\n  function repay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_\n  ) external returns (\n    uint collateralAmountOut,\n    uint returnedBorrowAmountOut,\n    uint swappedLeftoverCollateralOut,\n    uint swappedLeftoverBorrowOut\n  );\n\n  /// @notice Estimate result amount after making full or partial repay\n  /// @dev It works in exactly same way as repay() but don't make actual repay\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\n  /// @param user_ user whose amount-to-repay will be calculated\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\n  function quoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_\n  ) external returns (\n    uint collateralAmountOut\n  );\n\n  /// @notice Update status in all opened positions\n  ///         and calculate exact total amount of borrowed and collateral assets\n  /// @param user_ user whose debts will be updated and returned\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\n  function getDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) external returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  );\n\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\n  /// @dev Actual debt amount can be a little LESS then the amount returned by this function.\n  ///      I.e. AAVE's pool adapter returns (amount of debt + tiny addon ~ 1 cent)\n  ///      The addon is required to workaround dust-tokens problem.\n  ///      After repaying the remaining amount is transferred back on the balance of the caller strategy.\n  /// @param user_ user whose debts will be returned\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\n  function getDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  );\n\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\n  /// @param user_ user whose debts will be returned\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\n  ///                                           even if all borrowed amount will be returned.\n  ///                                           If this amount is not 0, you ask to get too much collateral.\n  function estimateRepay(\n    address user_,\n    address collateralAsset_,\n    uint collateralAmountRequired_,\n    address borrowAsset_\n  ) external view returns (\n    uint borrowAssetAmount,\n    uint unobtainableCollateralAssetAmount\n  );\n\n  /// @notice Transfer all reward tokens to {receiver_}\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\n  function claimRewards(address receiver_) external returns (\n    address[] memory rewardTokensOut,\n    uint[] memory amountsOut\n  );\n\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\n  ///                      It should be transferred on balance of the TetuConverter before the function call\n  /// @param receiver_ Result amount will be sent to this address\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\n  function safeLiquidate(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    address receiver_,\n    uint priceImpactToleranceSource_,\n    uint priceImpactToleranceTarget_\n  ) external returns (\n    uint amountOut\n  );\n\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\n  function isConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    uint priceImpactTolerance_\n  ) external view returns (bool);\n}"
    },
    "contracts/interfaces/converter/ITetuConverterCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice TetuConverter sends callback notifications to its user via this interface\ninterface ITetuConverterCallback {\n  /// @notice TetuConverter calls this function health factor is unhealthy and TetuConverter need more tokens to fix it.\n  ///         The borrow must send either required collateral-asset amount OR required borrow-asset amount.\n  /// @param collateralAsset_ Collateral asset of the borrow to identify the borrow on the borrower's side\n  /// @param requiredAmountCollateralAsset_ What amount of collateral asset the Borrower should send to TetuConverter\n  /// @param borrowAsset_ Borrow asset of the borrow to identify the borrow on the borrower's side\n  /// @param requiredAmountBorrowAsset_ What amount of borrow asset the Borrower should send back to TetuConverter\n  /// @return amountOut Exact amount that borrower has sent to balance of TetuConverter\n  ///                   It should be equal to either to requiredAmountBorrowAsset_ or to requiredAmountCollateralAsset_\n  /// @return isCollateral What is amountOut: true - collateral asset, false - borrow asset\n  function requireAmountBack (\n    address collateralAsset_,\n    uint requiredAmountCollateralAsset_,\n    address borrowAsset_,\n    uint requiredAmountBorrowAsset_\n  ) external returns (\n    uint amountOut,\n    bool isCollateral\n  );\n\n  /// @notice TetuConverter calls this function when it makes additional borrow (using exist collateral).\n  ///         The given amount has already be sent to balance of the user, the user just should use it.\n  /// @param collateralAsset_ Collateral asset of the borrow to identify the borrow on the borrower's side\n  /// @param borrowAsset_ Borrow asset of the borrow to identify the borrow on the borrower's side\n  /// @param amountBorrowAssetSentToBorrower_ This amount has been sent to the borrower's balance\n  function onTransferBorrowedAmount (\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountBorrowAssetSentToBorrower_\n  ) external;\n}\n"
    },
    "contracts/interfaces/IERC20Extended.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.17;\n\ninterface IERC20Extended {\n  function name() external view returns (string memory);\n\n  function symbol() external view returns (string memory);\n\n  function decimals() external view returns (uint8);\n\n\n  /**\n    * @dev Returns the amount of tokens in existence.\n    */\n  function totalSupply() external view returns (uint256);\n\n  /**\n   * @dev Returns the amount of tokens owned by `account`.\n   */\n  function balanceOf(address account) external view returns (uint256);\n\n  /**\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transfer(address recipient, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Returns the remaining number of tokens that `spender` will be\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\n   * zero by default.\n   *\n   * This value changes when {approve} or {transferFrom} are called.\n   */\n  function allowance(address owner, address spender) external view returns (uint256);\n\n  /**\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\n   * that someone may use both the old and the new allowance by unfortunate\n   * transaction ordering. One possible solution to mitigate this race\n   * condition is to first reduce the spender's allowance to 0 and set the\n   * desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   *\n   * Emits an {Approval} event.\n   */\n  function approve(address spender, uint256 amount) external returns (bool);\n\n  /**\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\n   * allowance mechanism. `amount` is then deducted from the caller's\n   * allowance.\n   *\n   * Returns a boolean value indicating whether the operation succeeded.\n   *\n   * Emits a {Transfer} event.\n   */\n  function transferFrom(\n    address sender,\n    address recipient,\n    uint256 amount\n  ) external returns (bool);\n\n  /**\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\n   * another (`to`).\n   *\n   * Note that `value` may be zero.\n   */\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n  /**\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n   * a call to {approve}. `value` is the new allowance.\n   */\n  event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/interfaces/IMockToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ninterface IMockToken {\n\n  function decimals() external view returns (uint8);\n\n  function mint(address to, uint amount) external;\n\n  function burn(address from, uint amount) external;\n}\n"
    },
    "contracts/interfaces/IWmatic.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.5.0;\n\ninterface IWmatic {\n\n  function balanceOf(address target) external view returns (uint256);\n\n  function deposit() external payable;\n\n  function withdraw(uint256 wad) external;\n\n  function totalSupply() external view returns (uint256);\n\n  function approve(address guy, uint256 wad) external returns (bool);\n\n  function transfer(address dst, uint256 wad) external returns (bool);\n\n  function transferFrom(address src, address dst, uint256 wad) external returns (bool);\n\n}\n"
    },
    "contracts/strategies/balancer/BalancerComposableStableDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"../DepositorBase.sol\";\nimport \"./BalancerLogicLib.sol\";\nimport \"../../tools/TokenAmountsLib.sol\";\nimport \"../../tools/AppErrors.sol\";\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../integrations/balancer/IBalancerHelper.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAavePool.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAaveStablePool.sol\";\nimport \"../../integrations/balancer/IChildChainLiquidityGaugeFactory.sol\";\nimport \"../../integrations/balancer/IBalancerGauge.sol\";\n\n\n/// @title Depositor for Composable Stable Pool with several embedded linear pools like \"Balancer Boosted Aave USD\"\n/// @dev See https://app.balancer.fi/#/polygon/pool/0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b\n///            bb-am-DAI (DAI + amDAI) + bb-am-USDC (USDC + amUSDC) + bb-am-USDT (USDT + amUSDT)\n///      See https://docs.balancer.fi/products/balancer-pools/boosted-pools for explanation of Boosted Pools on BalanceR.\n///      Terms\n///         bb-a-USD = pool bpt\n///         bb-a-DAI, bb-a-USDC, etc = underlying bpt\nabstract contract BalancerComposableStableDepositor is DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant BALANCER_COMPOSABLE_STABLE_DEPOSITOR_VERSION = \"1.0.0\";\n\n  /// @dev https://dev.balancer.fi/references/contracts/deployment-addresses\n  IBVault private constant BALANCER_VAULT = IBVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\n  address private constant BALANCER_HELPER = 0x239e55F427D44C3cc793f49bFB507ebe76638a2b;\n  /// @notice ChildChainLiquidityGaugeFactory allows to get gauge address by pool id\n  /// @dev see https://dev.balancer.fi/resources/vebal-and-gauges/gauges\n  address private constant CHILD_CHAIN_LIQUIDITY_GAUGE_FACTORY = 0x3b8cA519122CdD8efb272b0D3085453404B25bD0;\n\n  /// @notice i.e. for \"Balancer Boosted Aave USD\": 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b\n  bytes32 public poolId;\n  IBalancerGauge private _gauge;\n  address[] private _rewardTokens;\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  function __BalancerBoostedAaveUsdDepositor_init(\n    bytes32 poolId_,\n    address[] memory rewardTokens_\n  ) internal onlyInitializing {\n    poolId = poolId_;\n\n    _gauge = IBalancerGauge(\n      IChildChainLiquidityGaugeFactory(\n        CHILD_CHAIN_LIQUIDITY_GAUGE_FACTORY\n      ).getPoolGauge(BalancerLogicLib.getPoolAddress(poolId_))\n    );\n    // infinite approve of pool-BPT to the gauge todo is it safe for the external gauge?\n    IERC20(BalancerLogicLib.getPoolAddress(poolId_)).safeApprove(address(_gauge), type(uint).max);\n\n    // we can get list of reward tokens from the gauge, but it's more cheaper to get it outside\n    _rewardTokens = rewardTokens_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    return BalancerLogicLib.depositorPoolAssets(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Returns pool weights\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\n  /// @return totalWeight Total sum of all items of {weights}\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    return BalancerLogicLib.depositorPoolWeights(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of DAI, USDC, USDT\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \"Balancer Boosted Aave USD\" we return:\n  ///                     0: balance DAI + (balance amDAI recalculated to DAI)\n  ///                     1: balance USDC + (amUSDC recalculated to USDC)\n  ///                     2: balance USDT + (amUSDT recalculated to USDT)\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reservesOut) {\n    reservesOut =  BalancerLogicLib.depositorPoolReserves(BALANCER_VAULT, poolId);\n  }\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() override internal virtual view returns (uint liquidityOut) {\n    liquidityOut = _gauge.balanceOf(address(this))\n      + IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId)).balanceOf(address(this));\n  }\n\n  //// @notice Total amount of liquidity (LP tokens) in the depositor\n  function _depositorTotalSupply() override internal view returns (uint totalSupplyOut) {\n    totalSupplyOut = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId)).getActualSupply();\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  ///         i.e. for \"Balancer Boosted Aave USD\" we have DAI, USDC, USDT\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    bytes32 _poolId = poolId; // gas saving\n    IBalancerBoostedAaveStablePool pool = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(_poolId));\n\n    // join to the pool, receive pool-BPTs\n    (amountsConsumedOut, liquidityOut) = BalancerLogicLib.depositorEnter(BALANCER_VAULT, _poolId, amountsDesired_);\n\n    // stake all available pool-BPTs to the gauge\n    // we can have pool-BPTs on depositor's balance after previous exit, stake them too\n    _gauge.deposit(pool.balanceOf(address(this)));\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then should make full exit\n  /// @param liquidityAmount_ Max amount to withdraw in bpt. Actual withdrawn amount will be less,\n  ///                         so it worth to add a gap to this amount, i.e. 1%\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function _depositorExit(uint liquidityAmount_) override internal virtual returns (\n    uint[] memory amountsOut\n  ) {\n    bytes32 _poolId = poolId; // gas saving\n    IBalancerGauge __gauge = _gauge; // gas saving\n    IBalancerBoostedAaveStablePool pool = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(_poolId));\n\n    // we need to withdraw pool-BPTs from the _gauge\n    // at first, let's try to use exist pool-BPTs on the depositor balance, probably it's enough\n    // we can have pool-BPTs on depositor's balance after previous exit, see BalancerLogicLib.depositorExit\n    uint depositorBalance = pool.balanceOf(address(this));\n    uint gaugeBalance = __gauge.balanceOf(address(this));\n\n    uint liquidityToWithdraw = liquidityAmount_ > depositorBalance\n      ? liquidityAmount_ - depositorBalance\n      : 0;\n\n    // calculate how much pool-BPTs we should withdraw from the gauge\n    if (liquidityToWithdraw > 0) {\n      if (liquidityToWithdraw > gaugeBalance) {\n        liquidityToWithdraw = gaugeBalance;\n      }\n    }\n\n    // un-stake required pool-BPTs from the gauge\n    if (liquidityToWithdraw > 0) {\n      __gauge.withdraw(liquidityToWithdraw);\n    }\n\n    // withdraw the liquidity from the pool\n    amountsOut = (liquidityAmount_ >= depositorBalance + gaugeBalance)\n      ? BalancerLogicLib.depositorExitFull(BALANCER_VAULT, _poolId)\n      : BalancerLogicLib.depositorExit(BALANCER_VAULT, _poolId, liquidityToWithdraw);\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then full exit is required\n  ///      we emulate is at normal exit + conversion of remain BPT directly to the main asset\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function _depositorQuoteExit(uint liquidityAmount_) override internal virtual returns (uint[] memory amountsOut) {\n    uint liquidity = _depositorLiquidity();\n    if (liquidity == 0) {\n      // there is no liquidity, output is zero\n      return new uint[](_depositorPoolAssets().length);\n    } else {\n      // BalancerLogicLib.depositorQuoteExit takes into account the cost of unused BPT\n      // so we don't need a special logic here for the full exit\n      return BalancerLogicLib.depositorQuoteExit(\n        BALANCER_VAULT,\n        IBalancerHelper(BALANCER_HELPER),\n        poolId,\n        liquidityAmount_\n      );\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Claim all possible rewards.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    return BalancerLogicLib.depositorClaimRewards(_gauge, _rewardTokens);\n  }\n\n  /// @dev Returns reward token addresses array.\n  function rewardTokens() external view returns (address[] memory tokens) {\n    return _rewardTokens;\n  }\n\n\n  /// @dev This empty reserved space is put in place to allow future versions to add new\n  /// variables without shifting down storage in the inheritance chain.\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n  uint[16] private __gap; // TODO 16 ???\n}\n"
    },
    "contracts/strategies/balancer/BalancerComposableStableStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./BalancerComposableStableDepositor.sol\";\n\n/// @title Converter Strategy with Quickswap for reward pool StakingDualRewards\n/// @dev deprecated, we don't use it - no rewards...\ncontract BalancerComposableStableStrategy is ConverterStrategyBase, BalancerComposableStableDepositor {\n  string public constant override NAME = \"Balancer Boosted Aave USD Strategy\";\n  string public constant override PLATFORM = \"Balancer\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n  bytes32 public constant POOL_ID = 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b;\n\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_\n  ) external initializer {\n    // we can take address of the reward tokens using gauge and gauge.reward_contract\n    // it worth to encode these array to avoid calculation in init\n    address[] memory rewardTokens = new address[](1);\n    rewardTokens[0] = 0x9a71012B13CA4d3D0Cdc72A177DF3ef03b0E76A3;\n\n    __BalancerBoostedAaveUsdDepositor_init(POOL_ID, rewardTokens);\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n  }\n}\n"
    },
    "contracts/strategies/balancer/BalancerLogicLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\nimport \"../../tools/AppErrors.sol\";\nimport \"../../tools/AppLib.sol\";\nimport \"../../tools/TokenAmountsLib.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAavePool.sol\";\nimport \"../../integrations/balancer/IBalancerBoostedAaveStablePool.sol\";\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../integrations/balancer/IBalancerHelper.sol\";\nimport \"../../integrations/balancer/IBalancerGauge.sol\";\n\n/// @notice Functions of BalancerComposableStableDepositor\n/// @dev Many of functions are declared as external to reduce contract size\nlibrary BalancerLogicLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Types\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev local vars in getAmountsToDeposit to avoid stack too deep\n  struct LocalGetAmountsToDeposit {\n    /// @notice Decimals of {tokens_}, 0 for BPT\n    uint[] decimals;\n    /// @notice Length of {tokens_} array\n    uint len;\n    /// @notice amountBPT / underlyingAmount, decimals 18, 0 for BPT\n    uint[] rates;\n  }\n\n  /// @notice Local variables required inside _depositorEnter/Exit/QuoteExit, avoid stack too deep\n  struct DepositorLocal {\n    uint bptIndex;\n    uint len;\n    IERC20[] tokens;\n    uint[] balances;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Asset related utils\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate amounts of {tokens} to be deposited to POOL_ID in proportions according to the {balances}\n  /// @param amountsDesired_ Desired amounts of tokens. The order of the tokens is exactly the same as in {tokens}.\n  ///                        But the array has length 3, not 4, because there is no amount for bb-am-USD here.\n  /// @param tokens_ All bb-am-* tokens (including bb-am-USD) received through getPoolTokens\n  ///                           The order of the tokens is exactly the same as in getPoolTokens-results\n  /// @param balances_ Balances of bb-am-* pools in terms of bb-am-USD tokens (received through getPoolTokens)\n  ///                           The order of the tokens is exactly the same as in {tokens}\n  /// @param totalUnderlying_ Total amounts of underlying assets (DAI, USDC, etc) in embedded linear pools.\n  ///                         The array should have same order of tokens as {tokens_}, value for BPT token is not used\n  /// @param indexBpt_ Index of BPT token inside {balances_}, {tokens_} and {totalUnderlying_} arrays\n  /// @return amountsOut Desired amounts in proper proportions for depositing.\n  ///         The order of the tokens is exactly the same as in results of getPoolTokens, 0 for BPT\n  ///         i.e. DAI, BB-AM-USD, USDC, USDT\n  function getAmountsToDeposit(\n    uint[] memory amountsDesired_,\n    IERC20[] memory tokens_,\n    uint[] memory balances_,\n    uint[] memory totalUnderlying_,\n    uint indexBpt_\n  ) internal view returns (\n    uint[] memory amountsOut\n  ) {\n    LocalGetAmountsToDeposit memory p;\n    // check not zero balances, cache index of bbAmUSD, save 10**decimals to array\n    p.len = tokens_.length;\n    require(p.len == balances_.length, AppErrors.WRONG_LENGTHS);\n    require(p.len == amountsDesired_.length || p.len - 1 == amountsDesired_.length, AppErrors.WRONG_LENGTHS);\n\n    p.decimals = new uint[](p.len);\n    p.rates = new uint[](p.len);\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexBpt_) {\n        require(balances_[i] != 0, AppErrors.ZERO_BALANCE);\n        p.decimals[i] = 10**IERC20Metadata(address(tokens_[i])).decimals();\n\n        // Let's calculate a rate: amountBPT / underlyingAmount, decimals 18\n        p.rates[i] = balances_[i] * 1e18 / totalUnderlying_[i];\n      }\n    }\n\n    amountsOut = new uint[](p.len - 1);\n\n    // The balances set proportions of underlying-bpt, i.e. bb-am-DAI : bb-am-USDC : bb-am-USDT\n    // Our task is find amounts of DAI : USDC : USDT that won't change that proportions after deposit.\n    // We have arbitrary desired amounts, i.e. DAI = X, USDC = Y, USDT = Z\n    // For each token: assume that it can be used in full.\n    // If so, what amounts will have other tokens in this case according to the given proportions?\n    // i.e. DAI = X = 100.0 => USDC = 200.0, USDT = 400.0. We need: Y >= 200, Z >= 400\n    // or   USDC = Y = 100.0 => DAI = 50.0, USDT = 200.0. We need: X >= 50, Z >= 200\n    // If any amount is less then expected, the token cannot be used in full.\n    // A token with min amount can be used in full, let's try to find its index.\n    uint i3; // [0 : len - 1]\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (indexBpt_ == i) continue;\n\n      uint amountInBpt18 = amountsDesired_[i3] * p.rates[i];\n\n      uint j; // [0 : len]\n      uint j3; // [0 : len - 1]\n      for (; j < p.len; j = AppLib.uncheckedInc(j)) {\n        if (indexBpt_ == j) continue;\n\n        // alpha = balancesDAI / balancesUSDC * decimalsDAI / decimalsUSDC\n        // amountDAI = amountUSDC * alpha * rateUSDC / rateDAI\n        amountsOut[j3] = amountInBpt18 * balances_[j] / p.rates[j] * p.decimals[j] / balances_[i] / p.decimals[i];\n        if (amountsOut[j3] > amountsDesired_[j3]) break;\n        j3++;\n      }\n\n      if (j == p.len) break;\n      i3++;\n    }\n  }\n\n\n  /// @notice Calculate total amount of underlying asset for each token except BPT\n  /// @dev Amount is calculated as MainTokenAmount + WrappedTokenAmount * WrappedTokenRate, see AaveLinearPool src\n  function getTotalAssetAmounts(IBVault vault_, IERC20[] memory tokens_, uint indexBpt_) internal view returns (\n    uint[] memory amountsOut\n  ) {\n    uint len = tokens_.length;\n    amountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i != indexBpt_) {\n        IBalancerBoostedAavePool linearPool = IBalancerBoostedAavePool(address(tokens_[i]));\n        (, uint[] memory balances, ) = vault_.getPoolTokens(linearPool.getPoolId());\n\n        amountsOut[i] =\n          balances[linearPool.getMainIndex()]\n          + balances[linearPool.getWrappedIndex()] * linearPool.getWrappedTokenRate() / 1e18;\n      }\n    }\n  }\n\n  /// @notice Split {liquidityAmount_} by assets according to proportions of their total balances\n  /// @param liquidityAmount_ Amount to withdraw in bpt\n  /// @param balances_ Balances received from getPoolTokens\n  /// @param bptIndex_ Index of pool-pbt inside {balances_}\n  /// @return bptAmountsOut Amounts of underlying-BPT. The array doesn't include an amount for pool-bpt\n  ///         Total amount of {bptAmountsOut}-items is equal to {liquidityAmount_}\n  function getBtpAmountsOut(\n    uint liquidityAmount_,\n    uint[] memory balances_,\n    uint bptIndex_\n  ) internal pure returns (uint[] memory bptAmountsOut) {\n    // we assume here, that len >= 2\n    // we don't check it because StableMath.sol in balancer has _MIN_TOKENS = 2;\n    uint len = balances_.length;\n    bptAmountsOut = new uint[](len - 1);\n\n    // compute total balance, skip pool-bpt\n    uint totalBalances;\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex_) continue;\n      totalBalances += balances_[i];\n      // temporary save incomplete amounts to bptAmountsOut\n      bptAmountsOut[k] = liquidityAmount_ * balances_[i];\n      ++k;\n    }\n\n    // finalize computation of bptAmountsOut using known totalBalances\n    uint total;\n    for (k = 0; k < len - 1; k = AppLib.uncheckedInc(k)) {\n      if (k == len - 2) {\n        // leftovers => last item\n        bptAmountsOut[k] = total > liquidityAmount_\n          ? 0\n          : liquidityAmount_ - total;\n      } else {\n        bptAmountsOut[k] /= totalBalances;\n        total += bptAmountsOut[k];\n      }\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Depositor view logic\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of DAI, USDC, USDT\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \"Balancer Boosted Aave USD\" we return:\n  ///                     0: balance DAI + (balance amDAI recalculated to DAI)\n  ///                     1: balance USDC + (amUSDC recalculated to USDC)\n  ///                     2: balance USDT + (amUSDT recalculated to USDT)\n  function depositorPoolReserves(IBVault vault_, bytes32 poolId_) external view returns (uint[] memory reservesOut) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    uint bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n    uint len = tokens.length;\n    reservesOut = new uint[](len - 1); // exclude pool-BPT\n\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex) continue;\n      IBalancerBoostedAavePool linearPool = IBalancerBoostedAavePool(address(tokens[i]));\n\n      // Each bb-am-* returns (main-token, wrapped-token, bb-am-itself), the order of tokens is arbitrary\n      // i.e. (DAI + amDAI + bb-am-DAI) or (bb-am-USDC, amUSDC, USDC)\n\n      // get balances of all tokens of bb-am-XXX token, i.e. balances of (DAI, amDAI, bb-am-DAI)\n      (, uint256[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\n      uint mainIndex = linearPool.getMainIndex(); // DAI\n      uint wrappedIndex = linearPool.getWrappedIndex(); // amDAI\n\n      reservesOut[k] = balances[mainIndex] + balances[wrappedIndex] * linearPool.getWrappedTokenRate() / 1e18;\n      ++k;\n    }\n  }\n\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\n  function depositorPoolAssets(IBVault vault_, bytes32 poolId_) external view returns (address[] memory poolAssets) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    uint bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n    uint len = tokens.length;\n\n    poolAssets = new address[](len - 1);\n    uint k;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == bptIndex) continue;\n\n      poolAssets[k] = IBalancerBoostedAavePool(address(tokens[i])).getMainToken();\n      ++k;\n    }\n  }\n\n  /// @notice Returns pool weights\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\n  /// @return totalWeight Total sum of all items of {weights}\n  function depositorPoolWeights(IBVault vault_, bytes32 poolId_) external view returns (\n    uint[] memory weights,\n    uint totalWeight\n  ) {\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\n    totalWeight = tokens.length - 1; // totalWeight is equal to length of output array here\n    weights = new uint[](totalWeight);\n    for (uint i; i < totalWeight; i = AppLib.uncheckedInc(i)) {\n      weights[i] = 1;\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Depositor enter, exit logic\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  ///         i.e. for \"Balancer Boosted Aave USD\" we have DAI, USDC, USDT\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\n  function depositorEnter(IBVault vault_, bytes32 poolId_, uint[] memory amountsDesired_) external returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    DepositorLocal memory p;\n\n    // The implementation below assumes, that getPoolTokens returns the assets in following order:\n    //    bb-am-dai, bb-am-usd, bb-am-usdc, bb-am-usdt\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n    p.bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n\n    // temporary save current liquidity\n    liquidityOut = IBalancerBoostedAaveStablePool(address(p.tokens[p.bptIndex])).balanceOf(address(this));\n\n    // Original amounts can have any values.\n    // But we need amounts in such proportions that won't move the current balances\n    {\n      uint[] memory underlying = BalancerLogicLib.getTotalAssetAmounts(vault_, p.tokens, p.bptIndex);\n      amountsConsumedOut = BalancerLogicLib.getAmountsToDeposit(amountsDesired_, p.tokens, p.balances, underlying, p.bptIndex);\n    }\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n      sender: address(this),\n      fromInternalBalance: false,\n      recipient: payable(address(this)),\n      toInternalBalance: false\n    });\n\n    // swap all tokens XX => bb-am-XX\n    // we need two arrays with same amounts: amountsToDeposit (with 0 for BB-AM-USD) and userDataAmounts (no BB-AM-USD)\n    uint[] memory amountsToDeposit = new uint[](p.len);\n    uint[] memory userDataAmounts = new uint[](p.len - 1); // no bpt\n    uint k;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      amountsToDeposit[i] = BalancerLogicLib.swap(\n        vault_,\n        IBalancerBoostedAavePool(address(p.tokens[i])).getPoolId(),\n        IBalancerBoostedAavePool(address(p.tokens[i])).getMainToken(),\n        address(p.tokens[i]),\n        amountsConsumedOut[k],\n        funds\n      );\n      userDataAmounts[k] = amountsToDeposit[i];\n      AppLib.approveIfNeeded(address(p.tokens[i]), amountsToDeposit[i], address(vault_));\n      ++k;\n    }\n\n    // add liquidity to balancer\n    vault_.joinPool(\n      poolId_,\n      address(this),\n      address(this),\n      IBVault.JoinPoolRequest({\n        assets: asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\n        maxAmountsIn: amountsToDeposit,\n        userData: abi.encode(IBVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, userDataAmounts, 0),\n        fromInternalBalance: false\n      })\n    );\n\n    uint liquidityAfter = IERC20(address(p.tokens[p.bptIndex])).balanceOf(address(this));\n\n    liquidityOut = liquidityAfter > liquidityOut\n      ? liquidityAfter - liquidityOut\n      : 0;\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @param liquidityAmount_ Amount to withdraw in bpt\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorExit(IBVault vault_, bytes32 poolId_, uint liquidityAmount_) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IBalancerBoostedAaveStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n\n    require(liquidityAmount_ <= p.tokens[p.bptIndex].balanceOf(address(this)), AppErrors.NOT_ENOUGH_BALANCE);\n\n    // BalancerR can spend a bit less amount of liquidity than {liquidityAmount_}\n    // i.e. we if liquidityAmount_ = 2875841, we can have leftovers = 494 after exit\n    vault_.exitPool(\n      poolId_,\n      address(this),\n      payable(address(this)),\n      IBVault.ExitPoolRequest({\n        assets: asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\n        minAmountsOut: new uint[](p.len), // todo: no limits?\n        userData: abi.encode(\n            IBVault.ExitKindComposableStable.BPT_IN_FOR_EXACT_TOKENS_OUT,\n            BalancerLogicLib.getBtpAmountsOut(liquidityAmount_, p.balances, p.bptIndex),\n            liquidityAmount_\n          ),\n          toInternalBalance: false\n        })\n    );\n\n    // now we have amBbXXX tokens; swap them to XXX assets\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n      sender: address(this),\n      fromInternalBalance: false,\n      recipient: payable(address(this)),\n      toInternalBalance: false\n    });\n\n    amountsOut = new uint[](p.len - 1);\n    uint k;\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      uint amountIn = p.tokens[i].balanceOf(address(this));\n      if (amountIn != 0) {\n        amountsOut[k] = swap(\n          vault_,\n          IBalancerBoostedAavePool(address(p.tokens[i])).getPoolId(),\n          address(p.tokens[i]),\n          IBalancerBoostedAavePool(address(p.tokens[i])).getMainToken(),\n          amountIn,\n          funds\n        );\n      }\n      ++k;\n    }\n  }\n\n  /// @notice Withdraw all available amount of LP-tokens from the pool\n  ///         BalanceR doesn't allow to withdraw exact amount, so it's allowed to leave dust amount on the balance\n  /// @dev We make at most N attempts to withdraw (not more, each attempt takes a lot of gas).\n  ///      Each attempt reduces available balance at ~1e4 times.\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///                    The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorExitFull(IBVault vault_, bytes32 poolId_) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IBalancerBoostedAaveStablePool(getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n    amountsOut = new uint[](p.len - 1);\n\n    // we can create funds_ once and use it several times\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n      sender: address(this),\n      fromInternalBalance: false,\n      recipient: payable(address(this)),\n      toInternalBalance: false\n    });\n\n    uint liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\n    if (liquidityAmount > 0) {\n      uint liquidityThreshold = 10**IERC20Metadata(address(p.tokens[p.bptIndex])).decimals() / 100;\n\n      // we can make at most N attempts to withdraw amounts from the balanceR pool\n      for (uint i = 0; i < 2; ++i) {\n        vault_.exitPool(\n          poolId_,\n          address(this),\n          payable(address(this)),\n          IBVault.ExitPoolRequest({\n            assets: asIAsset(p.tokens),\n            minAmountsOut: new uint[](p.len), // todo: no limits?\n            userData: abi.encode(\n                IBVault.ExitKindComposableStable.BPT_IN_FOR_EXACT_TOKENS_OUT,\n                BalancerLogicLib.getBtpAmountsOut(liquidityAmount, p.balances, p.bptIndex),\n                liquidityAmount\n              ),\n            toInternalBalance: false\n          })\n        );\n        liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\n        if (liquidityAmount < liquidityThreshold || i == 1) {\n          break;\n        }\n        (, p.balances,) = vault_.getPoolTokens(poolId_);\n      }\n\n      // now we have amBbXXX tokens; swap them to XXX assets\n      uint k;\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n        if (i == p.bptIndex) continue;\n\n        uint amountIn = p.tokens[i].balanceOf(address(this));\n        if (amountIn != 0) {\n          amountsOut[k] = swap(\n            vault_,\n            IBalancerBoostedAavePool(address(p.tokens[i])).getPoolId(),\n            address(p.tokens[i]),\n            IBalancerBoostedAavePool(address(p.tokens[i])).getMainToken(),\n            amountIn,\n            funds\n          );\n        }\n        ++k;\n      }\n    }\n\n    uint depositorBalance = p.tokens[p.bptIndex].balanceOf(address(this));\n    if (depositorBalance > 0) {\n      uint k = 0;\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n        if (i == p.bptIndex) continue;\n\n        // we assume here, that the depositorBalance is small\n        // so we can directly swap it to any single asset without changing of pool resources proportions\n        amountsOut[k] += _convertSmallBptRemainder(vault_, poolId_, p, funds, depositorBalance, i);\n        break;\n      }\n    }\n\n    return amountsOut;\n  }\n\n  /// @notice convert remained SMALL amount of bpt => am-bpt => main token of the am-bpt\n  /// @return amountOut Received amount of am-bpt's main token\n  function _convertSmallBptRemainder(\n    IBVault vault_,\n    bytes32 poolId_,\n    DepositorLocal memory p,\n    IBVault.FundManagement memory funds,\n    uint bptAmountIn_,\n    uint indexTargetAmBpt_\n  ) internal returns (uint amountOut) {\n    uint amountAmBpt = BalancerLogicLib.swap(\n      vault_,\n      poolId_,\n      address(p.tokens[p.bptIndex]),\n      address(p.tokens[indexTargetAmBpt_]),\n      bptAmountIn_,\n      funds\n    );\n    amountOut = swap(\n      vault_,\n      IBalancerBoostedAavePool(address(p.tokens[indexTargetAmBpt_])).getPoolId(),\n      address(p.tokens[indexTargetAmBpt_]),\n      IBalancerBoostedAavePool(address(p.tokens[indexTargetAmBpt_])).getMainToken(),\n      amountAmBpt,\n      funds\n    );\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\n  function depositorQuoteExit(\n    IBVault vault_,\n    IBalancerHelper helper_,\n    bytes32 poolId_,\n    uint liquidityAmount_\n  ) external returns (\n    uint[] memory amountsOut\n  ) {\n    DepositorLocal memory p;\n\n    p.bptIndex = IBalancerBoostedAaveStablePool(BalancerLogicLib.getPoolAddress(poolId_)).getBptIndex();\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\n    p.len = p.tokens.length;\n\n    // bpt - amount of unconverted bpt\n    // let's temporary save total amount of converted BPT there\n    (uint256 bpt, uint[] memory amountsBpt) = helper_.queryExit(\n      poolId_,\n      address(this),\n      payable(address(this)),\n      IBVault.ExitPoolRequest({\n        assets: asIAsset(p.tokens),\n        minAmountsOut: new uint[](p.len), // todo: no limits?\n        userData: abi.encode(\n          IBVault.ExitKindComposableStable.BPT_IN_FOR_EXACT_TOKENS_OUT,\n          BalancerLogicLib.getBtpAmountsOut(liquidityAmount_, p.balances, p.bptIndex),\n          liquidityAmount_\n        ),\n        toInternalBalance: false\n      })\n    );\n\n    // amount of unconverted bpt, we need to take them into account for correct calculation of investedAssets amount\n    bpt = bpt < liquidityAmount_\n      ? liquidityAmount_ - bpt\n      : 0;\n\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\n      sender: address(this),\n      fromInternalBalance: false,\n      recipient: payable(address(this)),\n      toInternalBalance: false\n    });\n    IBVault.BatchSwapStep[] memory steps = new IBVault.BatchSwapStep[](p.len - 1);\n    IAsset[] memory assets = new IAsset[](2 * (p.len - 1));\n    uint k;\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      if (bpt != 0) {\n        // take into account the cost of unused BPT by directly converting them to first available amBPT\n        int[] memory deltas = _convertBptToAmBpt(vault_, poolId_, p.tokens[p.bptIndex], bpt, p.tokens[i], funds);\n        if (deltas[0] > 0) {\n          bpt = (bpt < uint(deltas[0]))\n            ? bpt - uint(deltas[0])\n            : 0;\n          amountsBpt[i] += (deltas[1] < 0)\n            ? uint(-deltas[1])\n            : 0;\n        }\n      }\n      IBalancerBoostedAavePool linearPool = IBalancerBoostedAavePool(address(p.tokens[i]));\n      steps[k].poolId = linearPool.getPoolId();\n      steps[k].assetInIndex = 2 * k + 1;\n      steps[k].assetOutIndex = 2 * k;\n      steps[k].amount = amountsBpt[i];\n\n      assets[2 * k] = IAsset(linearPool.getMainToken());\n      assets[2 * k + 1] = IAsset(address(p.tokens[i]));\n      ++k;\n    }\n\n    int[] memory assetDeltas = vault_.queryBatchSwap(IBVault.SwapKind.GIVEN_IN, steps, assets, funds);\n\n    amountsOut = new uint[](p.len - 1);\n    k = 0;\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.bptIndex) continue;\n      amountsOut[k] = assetDeltas[2 * k] < 0\n        ? uint256(-assetDeltas[2 * k])\n        : 0;\n\n      ++k;\n    }\n  }\n\n  function _convertBptToAmBpt(\n    IBVault vault_,\n    bytes32 poolId_,\n    IERC20 bptToken,\n    uint amountBpt,\n    IERC20 amBptToken,\n    IBVault.FundManagement memory funds\n  ) internal returns (\n    int[] memory assetDeltas\n  ) {\n    IAsset[] memory assets = new IAsset[](2);\n    assets[0] = IAsset(address(bptToken));\n    assets[1] = IAsset(address(amBptToken));\n\n    IBVault.BatchSwapStep[] memory steps = new IBVault.BatchSwapStep[](1);\n    steps[0].poolId = poolId_;\n    steps[0].assetInIndex = 0;\n    steps[0].assetOutIndex = 1;\n    steps[0].amount = amountBpt;\n\n    return vault_.queryBatchSwap(IBVault.SwapKind.GIVEN_IN, steps, assets, funds);\n  }\n\n  /// @notice Swap given {amountIn_} of {assetIn_} to {assetOut_} using the given BalanceR pool\n  function swap(\n    IBVault vault_,\n    bytes32 poolId_,\n    address assetIn_,\n    address assetOut_,\n    uint amountIn_,\n    IBVault.FundManagement memory funds_\n  ) internal returns (uint amountOut) {\n    uint balanceBefore = IERC20(assetOut_).balanceOf(address(this));\n\n    IERC20(assetIn_).approve(address(vault_), amountIn_);\n    vault_.swap(\n      IBVault.SingleSwap({\n        poolId: poolId_,\n        kind: IBVault.SwapKind.GIVEN_IN,\n        assetIn: IAsset(assetIn_),\n        assetOut: IAsset(assetOut_),\n        amount: amountIn_,\n        userData: bytes(\"\")\n      }),\n      funds_,\n      1,\n      block.timestamp\n    );\n\n    // we assume here, that the balance cannot be decreased\n    amountOut = IERC20(assetOut_).balanceOf(address(this)) - balanceBefore;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Rewards\n  /////////////////////////////////////////////////////////////////////\n\n  function depositorClaimRewards(IBalancerGauge gauge_, address[] memory rewardTokens_) external returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    uint len = rewardTokens_.length;\n\n    tokensOut = new address[](len);\n    amountsOut = new uint[](len);\n\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\n      tokensOut[i] = rewardTokens_[i];\n\n      // temporary store current reward balance\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this));\n    }\n\n    gauge_.claim_rewards();\n\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this)) - amountsOut[i];\n    }\n\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Utils\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Returns the address of a Pool's contract.\n  ///      Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\n  function getPoolAddress(bytes32 id) internal pure returns (address) {\n    // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\n    // since the logical shift already sets the upper bits to zero.\n    return address(uint160(uint(id) >> (12 * 8)));\n  }\n\n  /// @dev see balancer-labs, ERC20Helpers.sol\n  function asIAsset(IERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {\n    // solhint-disable-next-line no-inline-assembly\n    assembly {\n      assets := tokens\n    }\n  }\n}"
    },
    "contracts/strategies/ConverterStrategyBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol\";\nimport \"../interfaces/converter/ITetuConverter.sol\";\nimport \"../interfaces/converter/ITetuConverterCallback.sol\";\nimport \"../interfaces/converter/IPriceOracle.sol\";\nimport \"../interfaces/converter/IConverterController.sol\";\nimport \"../tools/TokenAmountsLib.sol\";\nimport \"../tools/AppLib.sol\";\nimport \"./ConverterStrategyBaseLib.sol\";\nimport \"./DepositorBase.sol\";\n\n/////////////////////////////////////////////////////////////////////\n///                        TERMS\n///  Main asset: the asset deposited to the vault by users\n///  Secondary assets: all assets deposited to the internal pool except the main asset\n///  Base amounts: not rewards; amounts deposited to vault, amounts deposited after compound\n///                Base amounts can be converted one to another\n/////////////////////////////////////////////////////////////////////\n\n/// @title Abstract contract for base Converter strategy functionality\n/// @notice All depositor assets must be correlated (ie USDC/USDT/DAI)\n/// @author bogdoslav, dvpublic\nabstract contract ConverterStrategyBase is ITetuConverterCallback, DepositorBase, StrategyBaseV2 {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\n  struct RecycleLocalParams {\n    address asset;\n    uint compoundRatio;\n    IForwarder forwarder;\n    uint[] amountsToForward;\n    uint liquidationThreshold;\n    uint amountToCompound;\n    uint amountToForward;\n    address rewardToken;\n    address[] tokens;\n  }\n\n  struct ConvertAfterWithdrawLocalParams {\n    address asset;\n    ITetuConverter tetuConverter;\n    ITetuLiquidator liquidator;\n    uint collateral;\n    uint spentAmountIn;\n    uint receivedAmountOut;\n    uint liquidationThreshold;\n  }\n\n  struct WithdrawUniversalLocal {\n    uint[] reserves;\n    uint totalSupply;\n    uint depositorLiquidity;\n    ConverterStrategyBaseLib.LiquidityAmountRatioInputParams p;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        CONSTANTS\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant CONVERTER_STRATEGY_BASE_VERSION = \"1.0.0\";\n\n  uint private constant REINVEST_THRESHOLD_DENOMINATOR = 100_000;\n\n  /////////////////////////////////////////////////////////////////////\n  //                        VARIABLES\n  //                Keep names and ordering!\n  // Add only in the bottom and don't forget to decrease gap variable\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Amount of underlying assets invested to the pool.\n  uint private _investedAssets;\n\n  /// @dev Linked Tetu Converter\n  ITetuConverter public converter;\n\n  /// @notice Minimum token amounts that can be liquidated\n  mapping(address => uint) public liquidationThresholds;\n\n  /// @notice Percent of asset amount that can be not invested, it's allowed to just keep it on balance\n  ///         decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\n  /// @dev We need this threshold to avoid numerous conversions of small amounts\n  uint public reinvestThresholdPercent;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        Events\n  /////////////////////////////////////////////////////////////////////\n  event LiquidationThresholdChanged(address token, uint amount);\n  event ReinvestThresholdPercentChanged(uint amount);\n  event ReturnMainAssetToConverter(uint amount);\n  event OnDepositorEnter(uint[] amounts, uint[] consumedAmounts);\n  event OnDepositorExit(uint liquidityAmount, uint[] withdrawnAmounts);\n  event OnDepositorEmergencyExit(uint[] withdrawnAmounts);\n\n  /// @notice Recycle was made\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\n  /// @param receivedAmounts Received amounts of the tokens\n  ///        This array has +1 item at the end: received amount of the main asset\n  /// @param spentAmounts Spent amounts of the tokens\n  /// @param amountsToForward Amounts to be sent to forwarder\n  event Recycle(\n    address[] rewardTokens,\n    uint[] receivedAmounts,\n    uint[] spentAmounts,\n    uint[] amountsToForward\n  );\n\n  /////////////////////////////////////////////////////////////////////\n  //                Initialization and configuration\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Initialize contract after setup it as proxy implementation\n  function __ConverterStrategyBase_init(\n    address controller_,\n    address splitter_,\n    address converter_\n  ) internal onlyInitializing {\n    __StrategyBase_init(controller_, splitter_);\n    converter = ITetuConverter(converter_);\n  }\n\n  function setLiquidationThreshold(address token, uint amount) external {\n    _onlyOperators();\n    liquidationThresholds[token] = amount;\n    emit LiquidationThresholdChanged(token, amount);\n  }\n\n  /// @param percent_ New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\n  function setReinvestThresholdPercent(uint percent_) external {\n    _onlyOperators();\n    require(percent_ <= REINVEST_THRESHOLD_DENOMINATOR, AppErrors.WRONG_VALUE);\n\n    reinvestThresholdPercent = percent_;\n    emit ReinvestThresholdPercentChanged(percent_);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                     Deposit to the pool\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Amount of underlying assets converted to pool assets and invested to the pool.\n  function investedAssets() override public view virtual returns (uint) {\n    return _investedAssets;\n  }\n\n  /// @notice Deposit given amount to the pool.\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    int totalAssetsDelta\n  ){\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(updateTotalAssetsBeforeInvest_);\n\n    // skip deposit for small amounts\n    if (amount_ > reinvestThresholdPercent * updatedInvestedAssets / REINVEST_THRESHOLD_DENOMINATOR) {\n      address[] memory tokens = _depositorPoolAssets();\n      uint indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, asset);\n\n      // prepare array of amounts ready to deposit, borrow missed amounts\n      (uint[] memory amounts, uint[] memory borrowedAmounts, uint collateral) = _beforeDeposit(\n        converter,\n        amount_,\n        tokens,\n        indexAsset\n      );\n\n      // make deposit, actually consumed amounts can be different from the desired amounts\n      (uint[] memory consumedAmounts,) = _depositorEnter(amounts);\n      emit OnDepositorEnter(amounts, consumedAmounts);\n\n      // adjust base-amounts\n      _updateBaseAmounts(tokens, borrowedAmounts, consumedAmounts, indexAsset, -int(collateral));\n\n      // adjust _investedAssets\n      _updateInvestedAssets();\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///               Convert amounts before deposit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Prepare {tokenAmounts} to be passed to depositorEnter\n  /// @param amount_ The amount of main asset that should be invested\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return tokenAmounts Amounts of depositor's assets ready to invest (this array can be passed to depositorEnter)\n  /// @return borrowedAmounts Amounts that were borrowed to prepare {tokenAmounts}\n  /// @return spentCollateral Total collateral spent to get {borrowedAmounts}\n  function _beforeDeposit(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) internal virtual returns (\n    uint[] memory tokenAmounts,\n    uint[] memory borrowedAmounts,\n    uint spentCollateral\n  ) {\n    // calculate required collaterals for each token and temporary save them to tokenAmounts\n    // save to tokenAmounts[indexAsset_] already correct value\n    (uint[] memory weights, uint totalWeight) = _depositorPoolWeights();\n    tokenAmounts = ConverterStrategyBaseLib.getCollaterals(\n      amount_,\n      tokens_,\n      weights,\n      totalWeight,\n      indexAsset_,\n      IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle())\n    );\n\n    // make borrow and save amounts of tokens available for deposit to tokenAmounts\n    // total collateral amount spent for borrowing\n    uint len = tokens_.length;\n    borrowedAmounts = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset_) continue;\n\n      if (tokenAmounts[i] > 0) {\n        uint collateral;\n        AppLib.approveIfNeeded(tokens_[indexAsset_], tokenAmounts[i], address(tetuConverter_));\n        (collateral, borrowedAmounts[i]) = ConverterStrategyBaseLib.openPosition(\n          tetuConverter_,\n          \"\", // fixed collateral amount, max possible borrow amount // todo possibility to customize entry kind\n          tokens_[indexAsset_],\n          tokens_[i],\n          tokenAmounts[i]\n        );\n        // collateral should be equal to tokenAmounts[i] here because we use default entry kind\n        spentCollateral += collateral;\n\n        // zero amount are possible (conversion is not available) but it's not suitable for depositor\n        require(borrowedAmounts[i] != 0, AppErrors.ZERO_AMOUNT_BORROWED);\n      }\n      tokenAmounts[i] = IERC20(tokens_[i]).balanceOf(address(this));\n    }\n\n    return (tokenAmounts, borrowedAmounts, spentCollateral);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                     Withdraw from the pool\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Withdraw given amount from the pool.\n  /// @param amount Amount to be withdrawn in terms of the asset.\n  /// @return investedAssetsUSD The value that we should receive after withdrawing (in USD, decimals of the {asset})\n  /// @return assetPrice Price of the {asset} from the price oracle\n  /// @return totalAssetsDelta The {strategy} updates its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawFromPool(uint amount) override internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(true);\n\n    require(updatedInvestedAssets != 0, AppErrors.NO_INVESTMENTS);\n    (investedAssetsUSD, assetPrice) = _withdrawUniversal(amount, false, updatedInvestedAssets);\n  }\n\n  /// @notice Withdraw all from the pool.\n  /// @return investedAssetsUSD The value that we should receive after withdrawing\n  /// @return assetPrice Price of the {asset} taken from the price oracle\n  /// @return totalAssetsDelta The {strategy} updates its totalAssets amount internally before withdrawing\n  ///                          Return [totalAssets-before-withdraw - totalAssets-before-call-of-_withdrawFromPool]\n  function _withdrawAllFromPool() override internal virtual returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    uint updatedInvestedAssets;\n    (updatedInvestedAssets, totalAssetsDelta) = _updateInvestedAssetsAndGetDelta(true);\n\n    (investedAssetsUSD, assetPrice) = _withdrawUniversal(0, true, updatedInvestedAssets);\n  }\n\n  /// @param amount Amount to be withdrawn. 0 is ok if we withdraw all.\n  /// @param all Withdraw all\n  /// @param investedAssets_ Current amount of invested assets\n  /// @return investedAssetsUSD The value that we should receive after withdrawing\n  /// @return assetPrice Price of the {asset} taken from the price oracle\n  function _withdrawUniversal(uint amount, bool all, uint investedAssets_) internal returns (\n    uint investedAssetsUSD,\n    uint assetPrice\n  ) {\n    WithdrawUniversalLocal memory vars;\n\n    // _investedAssets value is deprecated, prices can be changed since last update\n    // so we need to recalculate _investedAssets\n    // to simplify testing, we pass recalculated version as a function param\n    vars.p.investedAssets = investedAssets_;\n\n    if ((all || amount != 0) && vars.p.investedAssets != 0) {\n      vars.p.tokens = _depositorPoolAssets();\n      vars.p.indexAsset = ConverterStrategyBaseLib.getAssetIndex(vars.p.tokens, asset);\n      vars.p.converter = converter;\n      uint len = vars.p.tokens.length;\n      vars.depositorLiquidity = _depositorLiquidity();\n\n      // temporary save liquidityRatioOut to liquidityAmount\n      (uint liquidityAmount, uint[] memory amountsToConvert) = ConverterStrategyBaseLib.getLiquidityAmountRatio(\n        all ? 0 : amount,\n        baseAmounts,\n        address(this),\n        vars.p\n      );\n      if (liquidityAmount != 0) {\n        // liquidityAmount temporary contains ratio...\n        liquidityAmount = liquidityAmount * vars.depositorLiquidity / 1e18;\n      }\n\n      {\n        IPriceOracle priceOracle = IPriceOracle(IConverterController(vars.p.converter.controller()).priceOracle());\n        assetPrice = priceOracle.getAssetPrice(vars.p.tokens[vars.p.indexAsset]);\n      }\n\n      uint[] memory withdrawnAmounts;\n      uint expectedAmountMainAsset;\n      if (liquidityAmount != 0) {\n        // get reserves and totalSupply before withdraw\n        vars.reserves = _depositorPoolReserves();\n        vars.totalSupply = _depositorTotalSupply();\n\n        // make withdraw\n        withdrawnAmounts = _depositorExit(liquidityAmount);\n        emit OnDepositorExit(liquidityAmount, withdrawnAmounts);\n\n        // estimate, how many assets should be withdrawn\n        // the depositor is able to use less liquidity than it was asked\n        // (i.e. Balancer-depositor leaves some BPT unused)\n        // so, we need to fix liquidityAmount on this amount\n\n        // we assume here, that liquidity cannot increase in _depositorExit\n        uint depositorLiquidityDelta = vars.depositorLiquidity - _depositorLiquidity();\n        if (liquidityAmount > depositorLiquidityDelta) {\n          liquidityAmount = depositorLiquidityDelta;\n        }\n\n        // now we can estimate expected amount of assets to be withdrawn\n        uint[] memory expectedWithdrawAmounts = ConverterStrategyBaseLib.getExpectedWithdrawnAmounts(\n          vars.reserves,\n          liquidityAmount,\n          vars.totalSupply\n        );\n\n        expectedAmountMainAsset = ConverterStrategyBaseLib.getExpectedAmountMainAsset(\n          vars.p,\n          expectedWithdrawAmounts,\n          amountsToConvert\n        );\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n          amountsToConvert[i] += withdrawnAmounts[i];\n        }\n      } else {\n        withdrawnAmounts = new uint[](len);\n        // we don't need to withdraw any amounts from the pool, available converted amounts are enough for us\n        expectedAmountMainAsset = ConverterStrategyBaseLib.getExpectedAmountMainAsset(\n          vars.p,\n          withdrawnAmounts, // array with all zero values\n          amountsToConvert\n        );\n      }\n\n      // convert amounts to main asset and update base amounts\n      (uint collateral, uint[] memory repaid) = _convertAfterWithdraw(vars.p.tokens, vars.p.indexAsset, amountsToConvert);\n      _updateBaseAmounts(vars.p.tokens, withdrawnAmounts, repaid, vars.p.indexAsset, int(collateral));\n\n      investedAssetsUSD = expectedAmountMainAsset * assetPrice / 1e18;\n\n      // adjust _investedAssets\n      _updateInvestedAssets();\n    }\n\n    return (investedAssetsUSD, assetPrice);\n  }\n\n  /// @notice If pool supports emergency withdraw need to call it for emergencyExit()\n  function _emergencyExitFromPool() override internal virtual {\n    uint[] memory withdrawnAmounts = _depositorEmergencyExit();\n    emit OnDepositorEmergencyExit(withdrawnAmounts);\n\n    address[] memory tokens = _depositorPoolAssets();\n    uint indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, asset);\n\n    // convert amounts to main asset and update base amounts\n    (uint collateral, uint[] memory repaid) = _convertAfterWithdrawAll(tokens, indexAsset);\n    _updateBaseAmounts(tokens, withdrawnAmounts, repaid, indexAsset, int(collateral));\n\n    // adjust _investedAssets\n    _updateInvestedAssets();\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///               Convert amounts after withdraw\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Convert all available amounts of {tokens_} to the main {asset}\n  /// @dev todo SCB-587\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return collateralOut Total amount of collateral returned after closing positions\n  /// @return repaidAmounts What amounts were spent in exchange of the {collateralOut}\n  function _convertAfterWithdrawAll(address[] memory tokens_, uint indexAsset_) internal returns (\n    uint collateralOut,\n    uint[] memory repaidAmounts\n  ){\n    uint[] memory amountsToConvert = ConverterStrategyBaseLib.getAvailableBalances(tokens_, indexAsset_);\n\n    // convert amounts to the main asset\n    (collateralOut, repaidAmounts) = _convertAfterWithdraw(tokens_, indexAsset_, amountsToConvert);\n  }\n\n  /// @notice Convert {amountsToConvert_} to the main {asset}\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n  /// @param indexAsset_ Index of main {asset} in {tokens}\n  /// @return collateralOut Total amount of collateral returned after closing positions\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\n  function _convertAfterWithdraw(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_\n  ) internal returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.convertAfterWithdraw(\n      ConverterStrategyBaseLib.ConvertAfterWithdrawInputParams({\n        tetuConverter: converter,\n        liquidator: ITetuLiquidator(IController(controller()).liquidator()),\n        liquidationThreshold: liquidationThresholds[tokens_[indexAsset_]],\n        tokens: tokens_,\n        indexAsset: indexAsset_,\n        amountsToConvert: amountsToConvert_\n     })\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                 Update base amounts\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Update base amounts after withdraw\n  /// @param receivedAmounts_ Received amounts of not main-asset\n  /// @param spentAmounts_ Spent amounts of not main-asset\n  /// @param indexAsset_ Index of the asset in {tokens_} with different update logic (using {amountAsset_})\n  /// @param amountAsset_ Base amount of the asset with index indexAsset_ should be adjusted to {amountAsset_}\n  function _updateBaseAmounts(\n    address[] memory tokens_,\n    uint[] memory receivedAmounts_,\n    uint[] memory spentAmounts_,\n    uint indexAsset_,\n    int amountAsset_\n  ) internal {\n    uint len = tokens_.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      uint receivedAmount = receivedAmounts_[i];\n      uint spentAmount = spentAmounts_[i];\n      if (i == indexAsset_) {\n        if (amountAsset_ > 0) {\n          receivedAmount += uint(amountAsset_);\n        } else {\n          spentAmount += uint(-amountAsset_);\n        }\n      }\n      _updateBaseAmountsForAsset(tokens_[i], receivedAmount, spentAmount);\n    }\n  }\n\n  function _updateBaseAmountsForAsset(address asset_, uint received_, uint spent_) internal {\n    if (received_ > spent_) {\n      _increaseBaseAmount(asset_, received_ - spent_, _balance(asset_));\n    } else if (spent_ > received_) {\n      _decreaseBaseAmount(asset_, spent_ - received_);\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                 Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards\n  /// @dev The post-processing is rewards conversion to the main asset\n  /// @param tokens_ List of rewards claimed from the internal pool\n  /// @param amounts_ Amounts of rewards claimed from the internal pool\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\n  /// @param amountsOut Amounts of available rewards\n  function _prepareRewardsList(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    uint[] memory amounts_\n  ) internal returns(\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    // Rewards from TetuConverter\n    (address[] memory tokens2, uint[] memory amounts2) = tetuConverter_.claimRewards(address(this));\n\n    // Join arrays and recycle tokens\n    (tokensOut, amountsOut) = TokenAmountsLib.unite(tokens_, amounts_, tokens2, amounts2);\n\n    // {amounts} contain just received values, but probably we already had some tokens on balance\n    uint len = tokensOut.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      amountsOut[i] = IERC20(tokensOut[i]).balanceOf(address(this)) - baseAmounts[tokensOut[i]];\n    }\n  }\n\n  /// @notice Claim all possible rewards.\n  function _claim() override internal virtual {\n    // get rewards from the Depositor\n    (address[] memory depositorRewardTokens, uint[] memory depositorRewardAmounts) = _depositorClaimRewards();\n\n    (address[] memory rewardTokens, uint[] memory amounts) = _prepareRewardsList(\n      converter,\n      depositorRewardTokens,\n      depositorRewardAmounts\n    );\n\n    uint len = rewardTokens.length;\n    if (len > 0) {\n      (uint[] memory received, uint[] memory spent, uint[] memory amountsToForward) = _recycle(rewardTokens, amounts);\n\n      _updateBaseAmounts(rewardTokens, received, spent, type(uint).max, 0); // max - we don't need to exclude any asset\n      // received has a length equal to rewardTokens.length + 1\n      // last item contains amount of the {asset} received after swapping\n      _updateBaseAmountsForAsset(asset, received[len], 0);\n\n      // send forwarder-part of the rewards to the forwarder\n      ConverterStrategyBaseLib.sendTokensToForwarder(controller(), splitter, rewardTokens, amountsToForward);\n    }\n  }\n\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards divided on two parts: to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just added to baseAmounts\n  /// All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder.\n  /// @dev {_recycle} is implemented as separate (inline) function to simplify unit testing\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @return receivedAmounts Received amounts of the tokens\n  ///         This array has +1 item at the end: received amount of the main asset\n  ///                                            there was no possibility to use separate var for it, stack too deep\n  /// @return spentAmounts Spent amounts of the tokens\n  /// @return amountsToForward Amounts to be sent to forwarder\n  function _recycle(address[] memory rewardTokens_, uint[] memory rewardAmounts_) internal returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    (receivedAmounts, spentAmounts, amountsToForward) = ConverterStrategyBaseLib.recycle(\n      asset,\n      compoundRatio,\n      _depositorPoolAssets(),\n      ITetuLiquidator(IController(controller()).liquidator()),\n      liquidationThresholds,\n      baseAmounts,\n      rewardTokens_,\n      rewardAmounts_\n    );\n    emit Recycle(\n      rewardTokens_,\n      receivedAmounts,\n      spentAmounts,\n      amountsToForward\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Hardwork\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice A virtual handler to make any action before hardwork\n  function _preHardWork(bool reInvest) internal virtual {}\n\n  /// @notice A virtual handler to make any action after hardwork\n  function _postHardWork() internal virtual {}\n\n  /// @notice Is strategy ready to hard work\n  function isReadyToHardWork() override external virtual view returns (bool) {\n    // check claimable amounts and compare with thresholds\n    return true;\n  }\n\n  /// @notice Do hard work\n  function doHardWork() override public returns (uint, uint) {\n    return _doHardWork(true);\n  }\n\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\n  function _handleRewards() internal virtual returns (uint earned, uint lost) {\n    uint assetBalanceBefore = _balance(asset);\n    _claim();\n    uint assetBalanceAfterClaim = _balance(asset);\n    if (assetBalanceAfterClaim > assetBalanceBefore) {\n      earned = assetBalanceAfterClaim - assetBalanceBefore;\n    } else {\n      lost = assetBalanceBefore - assetBalanceAfterClaim;\n    }\n\n    return (earned, lost);\n  }\n\n  /// @return earned Earned amount in terms of {asset}\n  /// @return lost Lost amount in terms of {asset}\n  function _doHardWork(bool reInvest) internal returns (uint earned, uint lost) {\n    uint investedAssetsLocal = _updateInvestedAssets();\n\n    _preHardWork(reInvest);\n\n    (earned, lost) = _handleRewards();\n    uint assetBalance = _balance(asset);\n\n    // re-invest income\n    if (reInvest && assetBalance > reinvestThresholdPercent * investedAssetsLocal / REINVEST_THRESHOLD_DENOMINATOR) {\n\n      uint assetInUseBefore = investedAssetsLocal + assetBalance;\n      _depositToPool(assetBalance, false);\n      uint assetInUseAfter = _investedAssets + _balance(asset);\n\n      if (assetInUseAfter > assetInUseBefore) {\n        earned += assetInUseAfter - assetInUseBefore;\n      } else {\n        lost += assetInUseBefore - assetInUseAfter;\n      }\n    }\n\n    _postHardWork();\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///               InvestedAssets Calculations\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Updates cached _investedAssets to actual value\n  /// @dev Should be called after deposit / withdraw / claim; virtual - for ut\n  function _updateInvestedAssets() internal returns (uint investedAssetsOut) {\n    investedAssetsOut = _calcInvestedAssets();\n    _investedAssets = investedAssetsOut;\n  }\n\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return Invested asset amount under control (in terms of {asset})\n  function _calcInvestedAssets() internal returns (uint) {\n    uint liquidity = _depositorLiquidity();\n\n    address[] memory tokens = _depositorPoolAssets();\n    uint indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, asset);\n\n    uint[] memory amountsOut = liquidity == 0\n      ? new uint[](tokens.length)\n      : _depositorQuoteExit(liquidity);\n\n    return ConverterStrategyBaseLib.calcInvestedAssets(tokens, amountsOut, indexAsset, converter, baseAmounts);\n  }\n\n  function calcInvestedAssets() external returns (uint) {\n    return _calcInvestedAssets();\n  }\n\n  /// @notice Update invested assets and return delta [new-investedAssets - old-investedAssets]\n  /// @param updateTotalAssetsBeforeInvest_ If false - skip update, return delta = 0\n  function _updateInvestedAssetsAndGetDelta(bool updateTotalAssetsBeforeInvest_) internal returns (\n    uint updatedInvestedAssets,\n    int totalAssetsDelta\n  ) {\n    uint __investedAssets = _investedAssets;\n    updatedInvestedAssets = updateTotalAssetsBeforeInvest_\n      ? _updateInvestedAssets()\n      : __investedAssets;\n    totalAssetsDelta = updateTotalAssetsBeforeInvest_\n      ? int(updatedInvestedAssets) - int(__investedAssets)\n      : int(0);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///               ITetuConverterCallback\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice TetuConverter calls this function health factor is unhealthy and TetuConverter need more tokens to fix it.\n  ///         The borrow must send either required collateral-asset amount OR required borrow-asset amount.\n  /// @dev The implementation below always sends {collateralAsset_}\n  /// @param collateralAsset_ Collateral asset of the borrow to identify the borrow on the borrower's side\n  /// @param requiredAmountCollateralAsset_ What amount of collateral asset the Borrower should send to TetuConverter\n  /// @return amountOut Exact amount that borrower has sent to balance of TetuConverter\n  ///                   It should be equal to either to requiredAmountBorrowAsset_ or to requiredAmountCollateralAsset_\n  /// @return isCollateral What is amountOut: true - collateral asset, false - borrow asset\n  function requireAmountBack(\n    address collateralAsset_,\n    uint requiredAmountCollateralAsset_,\n    address /*borrowAsset_*/,\n    uint /*requiredAmountBorrowAsset_*/\n  ) external override returns (\n    uint amountOut,\n    bool isCollateral\n  ) {\n    address _converter = address(converter);\n    require(msg.sender == _converter, AppErrors.ONLY_TETU_CONVERTER);\n    require(collateralAsset_ == asset, AppErrors.WRONG_ASSET);\n\n    amountOut = 0;\n    uint assetBalance = _balance(collateralAsset_);\n\n    if (assetBalance >= requiredAmountCollateralAsset_) {\n      amountOut = requiredAmountCollateralAsset_;\n    } else {\n      // we assume if withdraw less amount then requiredAmountCollateralAsset_\n      // it will be rebalanced in the next call\n      _withdrawFromPool(requiredAmountCollateralAsset_ - assetBalance);\n      uint balanceAfterWithdraw = _balance(collateralAsset_);\n      amountOut = balanceAfterWithdraw > requiredAmountCollateralAsset_\n        ? requiredAmountCollateralAsset_\n        : balanceAfterWithdraw;\n    }\n\n    IERC20(collateralAsset_).safeTransfer(_converter, amountOut);\n    isCollateral = true;\n    emit ReturnMainAssetToConverter(amountOut);\n  }\n\n  function onTransferBorrowedAmount(\n    address /*collateralAsset_*/,\n    address /*borrowAsset_*/,\n    uint /*amountBorrowAssetSentToBorrower_*/\n  ) override pure external {\n    // noop; will deposit amount received at the next hardwork\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///                Others\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Unlimited capacity by default\n  function capacity() external virtual view returns (uint) {\n    return 2**255; // almost same as type(uint).max but more gas efficient\n  }\n\n\n  /**\n* @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n  uint[50] private __gap;\n\n}\n"
    },
    "contracts/strategies/ConverterStrategyBaseLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\";\nimport \"../interfaces/converter/IPriceOracle.sol\";\nimport \"../interfaces/converter/ITetuConverter.sol\";\nimport \"../interfaces/converter/IConverterController.sol\";\nimport \"../interfaces/converter/EntryKinds.sol\";\nimport \"../tools/AppErrors.sol\";\nimport \"../tools/AppLib.sol\";\nimport \"../tools/TokenAmountsLib.sol\";\n\nlibrary ConverterStrategyBaseLib {\n  using SafeERC20 for IERC20;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        DATA TYPES\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\n  struct RecycleLocalParams {\n    uint amountToCompound;\n    uint amountToForward;\n    address rewardToken;\n    uint liquidationThresholdAsset;\n    uint len;\n    uint baseAmountIn;\n    uint totalRewardAmounts;\n  }\n\n  /// @notice Input params for {_recycle}, workaround for stack too deep\n  struct RecycleInputParams {\n    address asset;\n    uint compoundRatio;\n    address[] tokens;\n    ITetuLiquidator liquidator;\n    address[] rewardTokens;\n    uint[] rewardAmounts;\n  }\n\n  /// @notice Input params for {getLiquidityAmountRatio}\n  /// @dev Workaround for stack too deep in {_withdrawUniversal}\n  struct LiquidityAmountRatioInputParams {\n    /// @notice Results of {_depositorPoolAssets}\n    address[] tokens;\n    /// @notice Index of the main asset in {tokens_}\n    uint indexAsset;\n    ITetuConverter converter;\n    /// @notice Total amount of invested assets of the strategy\n    uint investedAssets;\n  }\n\n  struct OpenPositionLocal {\n    uint entryKind;\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n  }\n\n  struct OpenPositionEntryKind2Local {\n    address[] converters;\n    uint[] collateralsRequired;\n    uint[] amountsToBorrow;\n    uint collateral;\n    uint amountToBorrow;\n    uint c1;\n    uint c3;\n    uint ratio;\n    uint alpha;\n  }\n\n  struct CalcInvestedAssetsLocal {\n    uint len;\n    uint[] prices;\n    uint[] decs;\n    uint[] debts;\n  }\n\n  struct ConvertAfterWithdrawInputParams {\n    ITetuConverter tetuConverter;\n    ITetuLiquidator liquidator;\n    uint liquidationThreshold;\n    /// @notice Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\n    address[] tokens;\n    /// Index of main {asset} in {tokens}\n    uint indexAsset;\n    uint[] amountsToConvert;\n  }\n\n  struct ConvertAfterWithdrawLocalParams {\n    address asset;\n    uint collateral;\n    uint spentAmountIn;\n    uint receivedAmountOut;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                        Constants\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice approx one month for average block time 2 sec\n  uint private constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\n  uint private constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\n  uint private constant COMPOUND_DENOMINATOR = 100_000;\n  uint private constant _ASSET_LIQUIDATION_SLIPPAGE = 500; // 0.5%\n  uint private constant PRICE_IMPACT_TOLERANCE = 2_000; // 2%\n\n  /////////////////////////////////////////////////////////////////////\n  ///                         Events\n  /////////////////////////////////////////////////////////////////////\n  /// @notice A borrow was made\n  event OpenPosition(\n    address converter,\n    address collateralAsset,\n    uint collateralAmount,\n    address borrowAsset,\n    uint borrowedAmount,\n    address recepient\n  );\n\n  /// @notice Some borrow(s) was/were repaid\n  event ClosePosition(\n    address collateralAsset,\n    address borrowAsset,\n    uint amountRepay,\n    address recepient,\n    uint returnedAssetAmountOut,\n    uint returnedBorrowAmountOut\n  );\n\n  /// @notice A liquidation was made\n  event Liquidation(\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint spentAmountIn,\n    uint receivedAmountOut\n  );\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      View functions\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Get amount of assets that we expect to receive after withdrawing\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\n  ///                  one of assets must be {asset_}\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\n  function getExpectedWithdrawnAmounts(\n    uint[] memory reserves_,\n    uint liquidityAmount_,\n    uint totalSupply_\n  ) external pure returns (\n    uint[] memory withdrawnAmountsOut\n  ) {\n    uint ratio = totalSupply_ == 0\n      ? 0\n      : (liquidityAmount_ >= totalSupply_\n        ? 1e18\n        : 1e18 * liquidityAmount_ / totalSupply_\n    ); // we need brackets here for npm.run.coverage\n\n    uint len = reserves_.length;\n    withdrawnAmountsOut = new uint[](len);\n\n    if (ratio != 0) {\n      for (uint i; i < len; ++i) {\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\n      }\n    }\n  }\n\n  /// @notice For each {token_} calculate a part of {amount_} to be used as collateral according to the weights.\n  ///         I.e. we have 300 USDC, we need to split it on 100 USDC, 100 USDT, 100 DAI\n  ///         USDC is main asset, USDT and DAI should be borrowed. We check amounts of USDT and DAI on the balance\n  ///         and return collaterals reduced on that amounts. For main asset, we return full amount always (100 USDC).\n  function getCollaterals(\n    uint amount_,\n    address[] memory tokens_,\n    uint[] memory weights_,\n    uint totalWeight_,\n    uint indexAsset_,\n    IPriceOracle priceOracle\n  ) external view returns (\n    uint[] memory tokenAmountsOut\n  ) {\n    uint len = tokens_.length;\n    tokenAmountsOut = new uint[](len);\n\n    // get token prices and decimals\n    (uint[] memory prices, uint[] memory decs) = _getPricesAndDecs(priceOracle, tokens_, len);\n\n    // split the amount on tokens proportionally to the weights\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      uint amountAssetForToken = amount_ * weights_[i] / totalWeight_;\n\n      if (i == indexAsset_) {\n        tokenAmountsOut[i] = amountAssetForToken;\n      } else {\n        // if we have some tokens on balance then we need to use only a part of the collateral\n        uint tokenAmountToBeBorrowed =  amountAssetForToken\n          * prices[indexAsset_]\n          * decs[i]\n          / prices[i]\n          / decs[indexAsset_];\n\n        uint tokenBalance = IERC20(tokens_[i]).balanceOf(address(this));\n        if (tokenBalance < tokenAmountToBeBorrowed) {\n          tokenAmountsOut[i] = amountAssetForToken * (tokenAmountToBeBorrowed - tokenBalance) / tokenAmountToBeBorrowed;\n        }\n      }\n    }\n  }\n\n  /// @return prices Prices with decimals 18\n  /// @return decs 10**decimals\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\n    uint[] memory prices,\n    uint[] memory decs\n  ) {\n    prices = new uint[](len);\n    decs = new uint[](len);\n    {\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        decs[i] = 10**IERC20Metadata(tokens_[i]).decimals();\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\n      }\n    }\n  }\n\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\n    uint len = tokens_.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (tokens_[i] == asset_) {\n        return i;\n      }\n    }\n    return type(uint).max;\n  }\n\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\n  function getAvailableBalances(\n    address[] memory tokens_,\n    uint indexAsset\n  ) external view returns (uint[] memory) {\n    uint len = tokens_.length;\n    uint[] memory amountsToConvert = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) continue;\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this));\n    }\n    return amountsToConvert;\n  }\n\n  /// @notice Get a ratio to calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\n  ///         User needs to withdraw {targetAmount_} in main asset.\n  ///         There are two kinds of available liquidity:\n  ///         1) liquidity in the pool - {depositorLiquidity_}\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\n  ///         To withdraw {targetAmount_} we need\n  ///         1) Reconvert converted amounts back to main asset\n  ///         2) IF result amount is not necessary - extract withdraw some liquidity from the pool\n  ///            and also convert it to the main asset.\n  /// @dev This is a writable function with read-only behavior (because of the quote-call)\n  /// @param targetAmount_ Required amount of main asset to be withdrawn from the strategy\n  ///                      0 - withdraw all\n  /// @param baseAmounts_ Available balances of the converted assets\n  /// @param strategy_ Address of the strategy\n  /// @param params_ To withdraw all set params_.investedAssets to zero\n  function getLiquidityAmountRatio(\n    uint targetAmount_,\n    mapping(address => uint) storage baseAmounts_,\n    address strategy_,\n    LiquidityAmountRatioInputParams memory params_\n  ) external returns (\n    uint liquidityRatioOut,\n    uint[] memory amountsToConvertOut\n  ) {\n    bool all = targetAmount_ == 0;\n    uint investedAssets = params_.investedAssets;\n\n    uint len = params_.tokens.length;\n    amountsToConvertOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == params_.indexAsset) continue;\n\n      uint baseAmount = baseAmounts_[params_.tokens[i]];\n      if (baseAmount != 0) {\n        // let's estimate collateral that we received back after repaying baseAmount\n        uint expectedCollateral = params_.converter.quoteRepay(\n          strategy_,\n          params_.tokens[params_.indexAsset],\n          params_.tokens[i],\n          baseAmount\n        );\n\n        if (all || targetAmount_ != 0) {\n          // We always repay WHOLE available baseAmount even if it gives us much more amount then we need.\n          // We cannot repay a part of it because converter doesn't allow to know\n          // what amount should be repaid to get given amount of collateral.\n          // And it's too dangerous to assume that we can calculate this amount\n          // by reducing baseAmount proportionally to expectedCollateral/targetAmount_\n          amountsToConvertOut[i] = baseAmount;\n        }\n\n        if (targetAmount_ > expectedCollateral) {\n          targetAmount_ -= expectedCollateral;\n        } else {\n          targetAmount_ = 0;\n        }\n\n        if (investedAssets > expectedCollateral) {\n          investedAssets -= expectedCollateral;\n        } else {\n          investedAssets = 0;\n        }\n      }\n    }\n\n    require(all || investedAssets > 0, AppErrors.WITHDRAW_TOO_MUCH);\n\n    liquidityRatioOut = all\n      ? 1e18\n      : ((targetAmount_ == 0)\n        ? 0\n        : 1e18\n          * 101 // add 1% on top...\n          * targetAmount_ / investedAssets // a part of amount that we are going to withdraw\n          / 100 // .. add 1% on top\n      );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Borrow and close positions\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\n  ///         Max possible collateral should be approved before calling of this function.\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\n  ///                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\n  /// @param amountIn_ Meaning depends on {entryData_}.\n  function openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    OpenPositionLocal memory vars;\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\n    vars.entryKind = EntryKinds.getEntryKind(entryData_);\n    if (vars.entryKind == EntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\n      return openPositionEntryKind2(\n        tetuConverter_,\n        entryData_,\n        collateralAsset_,\n        borrowAsset_,\n        amountIn_\n      );\n    } else {\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\n        entryData_,\n        collateralAsset_,\n        amountIn_,\n        borrowAsset_,\n        _LOAN_PERIOD_IN_BLOCKS\n      );\n\n      uint len = vars.converters.length;\n      if (len > 0) {\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\n          vars.collateral;\n          vars.amountToBorrow;\n          if (vars.entryKind == EntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\n            // we have exact amount of total collateral amount\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\n              ? amountIn_\n              : vars.collateralsRequired[i];\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\n              ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\n              : vars.amountsToBorrow[i];\n            amountIn_ -= vars.collateral;\n          } else {\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\n            // we have exact amount of total amount-to-borrow\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\n              ? amountIn_\n              : vars.amountsToBorrow[i];\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\n              ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\n              : vars.collateralsRequired[i];\n            amountIn_ -= vars.amountToBorrow;\n          }\n\n          if (vars.amountToBorrow != 0) {\n            borrowedAmountOut += tetuConverter_.borrow(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n            collateralAmountOut += vars.collateral;\n            emit OpenPosition(\n              vars.converters[i],\n              collateralAsset_,\n              vars.collateral,\n              borrowAsset_,\n              vars.amountToBorrow,\n              address(this)\n            );\n          }\n\n          if (amountIn_ == 0) break;\n        }\n      }\n\n      //!! console.log('>>> BORROW collateralAmount collateralAsset', collateralAmount, collateralAsset);\n      //!! console.log('>>> BORROW borrowedAmount borrowAsset', borrowedAmountOut, borrowAsset);\n      return (collateralAmountOut, borrowedAmountOut);\n    }\n  }\n\n  function openPositionEntryKind2(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_\n  ) internal returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    OpenPositionEntryKind2Local memory vars;\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow, ) = tetuConverter_.findBorrowStrategies(\n      entryData_,\n      collateralAsset_,\n      amountIn_,\n      borrowAsset_,\n      _LOAN_PERIOD_IN_BLOCKS\n    );\n\n    collateralAmountOut = 0; // hide warning\n    borrowedAmountOut = 0; // hide warning\n\n\n    uint len = vars.converters.length;\n    if (len > 0) {\n      // we should split amountIn on two amounts with proportions x:y\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\n      // calculate prices conversion ratio using price oracle, decimals 18\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\n\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\n        // and give us required proportions in result\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\n        // but if lending platform doesn't have enough liquidity\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\n        vars.c1 = x * vars.c3 / y;\n        vars.ratio = vars.collateralsRequired[i] + vars.c1 > amountIn_\n          ? 1e18 * amountIn_ / (vars.collateralsRequired[i] + vars.c1)\n          : 1e18;\n        vars.collateral = vars.collateralsRequired[i] * vars.ratio / 1e18;\n        vars.amountToBorrow = vars.amountsToBorrow[i] * vars.ratio / 1e18;\n\n        require(\n          tetuConverter_.borrow(\n            vars.converters[i],\n            collateralAsset_,\n            vars.collateral,\n            borrowAsset_,\n            vars.amountToBorrow,\n            address(this)\n          ) == vars.amountToBorrow,\n          AppErrors.WRONG_VALUE\n        );\n        emit OpenPosition(\n          vars.converters[i],\n          collateralAsset_,\n          vars.collateral,\n          borrowAsset_,\n          vars.amountToBorrow,\n          address(this)\n        );\n\n        borrowedAmountOut += vars.amountToBorrow;\n        collateralAmountOut += vars.collateral;\n\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\n        vars.c1 = x * vars.c3 / y;\n\n        if (amountIn_ > vars.c1 + vars.collateral) {\n          amountIn_ -= (vars.c1 + vars.collateral);\n        } else {\n          break;\n        }\n      }\n\n      //!! console.log('>>> BORROW collateralAmount collateralAsset', collateralAmount, collateralAsset);\n      //!! console.log('>>> BORROW borrowedAmount borrowAsset', borrowedAmountOut, borrowAsset);\n      return (collateralAmountOut, borrowedAmountOut);\n    }\n  }\n\n  /// @notice Get ratio18 = collateral / borrow\n  function _getCollateralToBorrowRatio(\n    ITetuConverter tetuConverter_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) internal view returns (uint){\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle());\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\n    return 1e18 * priceBorrow * 10**IERC20Metadata(collateralAsset_).decimals()\n                / priceCollateral / 10**IERC20Metadata(borrowAsset_).decimals();\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function _closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) internal returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n    //!! console.log(\"_closePosition\");\n\n    // We shouldn't try to pay more than we actually need to repay\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\n    // Let's limit amountToRepay by needToRepay-amount\n    (uint needToRepay,) = tetuConverter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset);\n\n    uint amountRepay = amountToRepay < needToRepay\n      ? amountToRepay\n      : needToRepay;\n\n    // Make full/partial repayment\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\n    IERC20(borrowAsset).safeTransfer(address(tetuConverter_), amountRepay);\n    uint returnedBorrowAmountOut;\n\n    (returnedAssetAmountOut, returnedBorrowAmountOut,,) = tetuConverter_.repay(\n      collateralAsset,\n      borrowAsset,\n      amountRepay,\n      address(this)\n    );\n    emit ClosePosition(\n      collateralAsset,\n      borrowAsset,\n      amountRepay,\n      address(this),\n      returnedAssetAmountOut,\n      returnedBorrowAmountOut\n    );\n    uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\n\n    // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (dust tokens)\n    repaidAmountOut = balanceBefore > balanceAfter\n      ? balanceBefore - balanceAfter\n      : 0;\n\n    require(returnedBorrowAmountOut == 0, AppErrors.REPAY_MAKES_SWAP);\n  }\n\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\n  /// @return repaidAmountOut Amount that was actually repaid\n  function closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint repaidAmountOut\n  ) {\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                         Liquidation\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  function liquidate(\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdForTokenOut_ // todo Probably it worth to use threshold for amount IN? it would be more gas efficient\n  ) external returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    return _liquidate(liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdForTokenOut_);\n  }\n\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\n  function _liquidate(\n    ITetuLiquidator liquidator_,\n    address tokenIn_,\n    address tokenOut_,\n    uint amountIn_,\n    uint slippage_,\n    uint liquidationThresholdForTokenOut_ // todo Probably it worth to use threshold for amount IN? it would be more gas efficient\n  ) internal returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\n\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\n\n    // calculate balance in out value for check threshold\n    uint amountOut = liquidator_.getPriceForRoute(route, amountIn_);\n\n    // if the expected value is higher than threshold distribute to destinations\n    if (amountOut > liquidationThresholdForTokenOut_) {\n      // we need to approve each time, liquidator address can be changed in controller\n      AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\n\n      uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\n\n      liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\n\n      // temporary save balance of token out after  liquidation to spentAmountIn\n      uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\n\n      // assign correct values to\n      receivedAmountOut = balanceAfter > balanceBefore\n      ? balanceAfter - balanceBefore\n      : 0;\n      spentAmountIn = amountIn_;\n\n      emit Liquidation(\n        tokenIn_,\n        tokenOut_,\n        amountIn_,\n        spentAmountIn,\n        receivedAmountOut\n      );\n    }\n\n    return (spentAmountIn, receivedAmountOut);\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      Recycle rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\n  /// We have two kinds of rewards:\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\n  /// 2) any other rewards\n  /// All received rewards are immediately \"recycled\".\n  /// It means, they are divided on two parts: to forwarder, to compound\n  ///   Compound-part of Rewards-2 can be liquidated\n  ///   Compound part of Rewards-1 should be just added to baseAmounts\n  /// All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder.\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\n  /// @param liquidationThresholds_ Liquidation thresholds for rewards tokens\n  /// @param baseAmounts_ Base amounts for rewards tokens\n  ///                     The base amounts allow to separate just received and previously received rewards.\n  /// @return receivedAmounts Received amounts of the tokens\n  ///         This array has +1 item at the end: received amount of the main asset\n  ///                                            there was no possibility to use separate var for it, stack too deep\n  /// @return spentAmounts Spent amounts of the tokens\n  /// @return amountsToForward Amounts to be sent to forwarder\n  function recycle(\n    address asset_,\n    uint compoundRatio_,\n    address[] memory tokens_,\n    ITetuLiquidator liquidator_,\n    mapping(address => uint) storage liquidationThresholds_,\n    mapping(address => uint) storage baseAmounts_,\n    address[] memory rewardTokens_,\n    uint[] memory rewardAmounts_\n  ) external returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    RecycleInputParams memory p = RecycleInputParams({\n      asset: asset_,\n      compoundRatio: compoundRatio_,\n      tokens: tokens_,\n      liquidator: liquidator_,\n      rewardTokens: rewardTokens_,\n      rewardAmounts: rewardAmounts_\n    });\n    (receivedAmounts, spentAmounts, amountsToForward) = _recycle(p, liquidationThresholds_, baseAmounts_);\n  }\n\n  /// @dev Implementation of {recycle}, input params are packed to a struct to avoid stack too deep.\n  function _recycle(\n    RecycleInputParams memory params,\n    mapping(address => uint) storage liquidationThresholds,\n    mapping(address => uint) storage baseAmounts\n  ) internal returns (\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    RecycleLocalParams memory p;\n\n    p.len = params.rewardTokens.length;\n    require(p.len == params.rewardAmounts.length, AppErrors.WRONG_LENGTHS);\n\n    p.liquidationThresholdAsset = liquidationThresholds[params.asset];\n\n    amountsToForward = new uint[](p.len);\n    receivedAmounts = new uint[](p.len + 1);\n    spentAmounts = new uint[](p.len);\n\n    // split each amount on two parts: a part-to-compound and a part-to-transfer-to-the-forwarder\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\n      p.rewardToken = params.rewardTokens[i];\n      p.amountToCompound = params.rewardAmounts[i] * params.compoundRatio / COMPOUND_DENOMINATOR;\n\n      if (p.amountToCompound > 0) {\n        if (ConverterStrategyBaseLib.getAssetIndex(params.tokens, p.rewardToken) != type(uint).max) {\n          // The asset is in the list of depositor's assets, liquidation is not allowed\n          receivedAmounts[i] += p.amountToCompound;\n        } else {\n          p.baseAmountIn = baseAmounts[p.rewardToken];\n          p.totalRewardAmounts = p.amountToCompound + p.baseAmountIn; // total amount that can be liquidated\n\n          if (p.totalRewardAmounts < liquidationThresholds[p.rewardToken]) {\n            // amount is too small, liquidation is not allowed\n            receivedAmounts[i] += p.amountToCompound;\n          } else {\n            // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\n            // We assume here, that {token} cannot be equal to {_asset}\n            // because the {_asset} is always included to the list of depositor's assets\n            (uint spentAmountIn, uint receivedAmountOut) = _liquidate(\n              params.liquidator,\n              p.rewardToken,\n              params.asset,\n              p.totalRewardAmounts,\n              _REWARD_LIQUIDATION_SLIPPAGE,\n              p.liquidationThresholdAsset\n            );\n\n            // Adjust amounts after liquidation\n            if (receivedAmountOut > 0) {\n              receivedAmounts[p.len] += receivedAmountOut;\n            }\n            if (spentAmountIn == 0) {\n              receivedAmounts[i] += p.amountToCompound;\n            } else {\n              require(spentAmountIn == p.amountToCompound + p.baseAmountIn, AppErrors.WRONG_VALUE);\n              spentAmounts[i] += p.baseAmountIn;\n            }\n          }\n        }\n      }\n\n      p.amountToForward = params.rewardAmounts[i] - p.amountToCompound;\n      amountsToForward[i] = p.amountToForward;\n    }\n\n    return (receivedAmounts, spentAmounts, amountsToForward);\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      calcInvestedAssets\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Calculate amount we will receive when we withdraw all from pool\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\n  /// @return amountOut Invested asset amount under control (in terms of {asset})\n  function calcInvestedAssets(\n    address[] memory tokens,\n    uint[] memory amountsOut,\n    uint indexAsset,\n    ITetuConverter converter_,\n    mapping(address => uint) storage baseAmounts\n  ) external returns (\n    uint amountOut\n  ) {\n    CalcInvestedAssetsLocal memory v;\n    v.len = tokens.length;\n\n    // calculate prices, decimals\n    (v.prices, v.decs) = _getPricesAndDecs(\n      IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\n      tokens,\n      v.len\n    );\n\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n      if (i == indexAsset) {\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\n        amountOut += amountsOut[i];\n      } else {\n        // available amount to repay\n        uint toRepay = baseAmounts[tokens[i]] + amountsOut[i];\n\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(address(this), tokens[indexAsset], tokens[i]);\n        amountOut += collateral;\n        if (toRepay >= toPay) {\n          amountOut += (toRepay - toPay) * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        } else {\n          // there is not enough amount to pay the debt\n          // let's register a debt and try to resolve it later below\n          if (v.debts.length == 0) {\n            v.debts = new uint[](v.len); // lazy initialization\n          }\n          // to pay the following amount we need to swap some other asset at first\n          v.debts[i] = toPay - toRepay;\n        }\n      }\n    }\n\n    if (v.debts.length == v.len) {\n      // we assume here, that it would be always profitable to save collateral\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\n        if (v.debts[i] == 0) continue;\n\n        // estimatedAssets should be reduced on the debt-value\n        uint debtInAsset = v.debts[i] * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\n        if (debtInAsset > amountOut) {\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\n          amountOut = 0;\n        } else {\n          amountOut -= debtInAsset;\n        }\n      }\n    }\n\n    return amountOut;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      convertAfterWithdraw\n  /////////////////////////////////////////////////////////////////////\n  /// @notice Convert {p.amountsToConvert_} to the main asset\n  /// @return collateralOut Total amount of collateral returned after closing positions\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\n  function convertAfterWithdraw(ConvertAfterWithdrawInputParams memory p) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    ConvertAfterWithdrawLocalParams memory vars;\n    vars.asset = p.tokens[p.indexAsset];\n\n    uint len = p.tokens.length;\n    repaidAmountsOut = new uint[](len);\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.indexAsset) continue;\n      (vars.collateral, repaidAmountsOut[i]) = _closePosition(\n        p.tetuConverter,\n        vars.asset,\n        p.tokens[i],\n        p.amountsToConvert[i]\n      );\n      collateralOut += vars.collateral;\n    }\n\n    // Manually swap remain leftovers\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == p.indexAsset) continue;\n      if (p.amountsToConvert[i] > repaidAmountsOut[i]) {\n        (vars.spentAmountIn, vars.receivedAmountOut) = _liquidate(\n          p.liquidator,\n          p.tokens[i],\n          vars.asset,\n          p.amountsToConvert[i] - repaidAmountsOut[i],\n          _ASSET_LIQUIDATION_SLIPPAGE,\n          p.liquidationThreshold\n        );\n        if (vars.receivedAmountOut != 0) {\n          collateralOut += vars.receivedAmountOut;\n        }\n        if (vars.spentAmountIn != 0) {\n          repaidAmountsOut[i] += vars.spentAmountIn;\n          require(\n            p.tetuConverter.isConversionValid(\n              p.tokens[i],\n              vars.spentAmountIn,\n              vars.asset,\n              vars.receivedAmountOut,\n              PRICE_IMPACT_TOLERANCE\n            ),\n            AppErrors.PRICE_IMPACT\n          );\n        }\n      }\n    }\n\n    return (collateralOut, repaidAmountsOut);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      sendTokensToForwarder\n  /////////////////////////////////////////////////////////////////////\n  function sendTokensToForwarder(\n    address controller_,\n    address splitter_,\n    address[] memory tokens_,\n    uint[] memory amounts_\n  ) external {\n    uint len = tokens_.length;\n    IForwarder forwarder = IForwarder(IController(controller_).forwarder());\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      AppLib.approveIfNeeded(tokens_[i], amounts_[i], address(forwarder));\n    }\n\n    forwarder.registerIncome(tokens_, amounts_, ISplitter(splitter_).vault(), true);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                      getExpectedAmountMainAsset\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Calculate expected amount of the main asset after withdrawing\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\n  /// @return amountOut Expected amount of the main asset\n  function getExpectedAmountMainAsset(\n    LiquidityAmountRatioInputParams memory vars,\n    uint[] memory withdrawnAmounts_,\n    uint[] memory amountsToConvert_\n  ) external returns (\n    uint amountOut\n  ) {\n    uint len = vars.tokens.length;\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\n      if (i == vars.indexAsset) {\n        amountOut += withdrawnAmounts_[i];\n      } else {\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\n        if (amount != 0) {\n          amountOut += vars.converter.quoteRepay(address(this), vars.tokens[vars.indexAsset], vars.tokens[i], amount);\n        }\n      }\n    }\n\n    return amountOut;\n  }\n}"
    },
    "contracts/strategies/DepositorBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\nimport \"../tools/ERC20Helpers.sol\";\n\n/// @title Abstract base Depositor contract.\n/// @notice Converter strategies should inherit xDepositor.\n/// @notice All communication with external pools should be done at inherited contract\n/// @author bogdoslav\nabstract contract DepositorBase is ERC20Helpers {\n  using SafeERC20 for IERC20;\n\n  /// @notice Version of this contract. Adjust manually on each code modification.\n  string internal constant DEPOSITOR_BASE_VERSION = \"1.0.0\";\n\n  /// @notice Returns pool assets\n  function _depositorPoolAssets() internal virtual view returns (address[] memory assets);\n\n  /// @notice Returns pool token proportions\n  function _depositorPoolWeights() internal virtual view returns (uint[] memory weights, uint total);\n\n  /// @notice Returns pool token reserves\n  function _depositorPoolReserves() internal virtual view returns (uint[] memory reserves);\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() internal virtual view returns (uint);\n\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() internal view virtual returns (uint);\n\n  /// @notice Deposit given amount to the pool.\n  /// @dev Depositor must care about tokens approval by itself.\n  function _depositorEnter(uint[] memory amountsDesired_) internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  );\n\n  /// @notice Withdraw given lp amount from the pool.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @notice Quotes output for given lp amount from the pool.\n  /// @dev Write function with read-only behavior. BalanceR's depositor requires not-view.\n  /// @param liquidityAmount Amount of liquidity to be converted\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorQuoteExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\n\n  /// @dev If pool supports emergency withdraw need to call it for emergencyExit()\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\n  function _depositorEmergencyExit() internal virtual returns (uint[] memory amountsOut) {\n    return _depositorExit(_depositorLiquidity());\n  }\n\n  /// @notice Claim all possible rewards.\n  function _depositorClaimRewards() internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts\n  );\n}\n"
    },
    "contracts/strategies/dystopia/DystopiaConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./DystopiaDepositor.sol\";\n\n/// @title Converter Strategy with Dystopia Depositor\n/// @author bogdoslav\ncontract DystopiaConverterStrategy is ConverterStrategyBase, DystopiaDepositor {\n\n  string public constant override NAME = \"Dystopia Converter Strategy\";\n  string public constant override PLATFORM = \"Dystopia\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n  address constant public _DYSTOPIA_ROUTER = 0xbE75Dd16D029c6B32B7aD57A0FD9C1c20Dd2862e;\n  address constant public _DYSTOPIA_VOTER = 0x649BdF58B09A0Cd4Ac848b42c4B5e1390A72A49A;\n\n  /// @dev Reward Tokens\n  address[] internal _rewardTokens;\n\n  function init(\n    address controller_,\n    address splitter_,\n    address[] memory  rewardTokens_,\n    address converter_,\n    address tokenA_,\n    address tokenB_,\n    bool stable_\n  ) external initializer {\n\n    __DystopiaDepositor_init(_DYSTOPIA_ROUTER, tokenA_, tokenB_, stable_, _DYSTOPIA_VOTER);\n\n    __ConverterStrategyBase_init(\n      controller_,\n      splitter_,\n      converter_\n    );\n\n    _rewardTokens = rewardTokens_;\n  }\n\n  /// @dev Returns reward token addresses array.\n  function rewardTokens() external view returns (address[] memory tokens) {\n    return _rewardTokens;\n  }\n}\n"
    },
    "contracts/strategies/dystopia/DystopiaDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"../../integrations/dystopia/IRouter.sol\";\nimport \"../../integrations/dystopia/IPair.sol\";\nimport \"../../integrations/dystopia/IVoter.sol\";\nimport \"../../integrations/dystopia/IGauge.sol\";\nimport \"../../integrations/dystopia/IBribe.sol\";\nimport \"../../tools/TokenAmountsLib.sol\";\nimport \"../../tools/AppLib.sol\";\nimport \"../DepositorBase.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title Dystopia Depositor for ConverterStrategies\n/// @author bogdoslav\ncontract DystopiaDepositor is DepositorBase, Initializable {\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant DYSTOPIA_DEPOSITOR_VERSION = \"1.0.0\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Variables\n  /////////////////////////////////////////////////////////////////////\n\n  address public depositorRouter;\n\n  /// @notice A pair of tokens A and B registered in the router\n  address public depositorPair;\n\n  bool public depositorStable;\n\n  address internal _depositorGauge;\n  address private _depositorTokenA;\n  address private _depositorTokenB;\n\n  /// @notice false: _depositorTokenA == depositorPair.token0\n  ///         true:  _depositorTokenA == depositorPair.token1\n  bool private _depositorSwapTokens;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  // @notice tokens must be MockTokens\n  function __DystopiaDepositor_init(\n    address router,\n    address tokenA,\n    address tokenB,\n    bool stable,\n    address voter\n  ) internal onlyInitializing {\n    depositorRouter = router;\n    _depositorTokenA = tokenA;\n    _depositorTokenB = tokenB;\n    depositorStable = stable;\n\n    address _depositorPair = IRouter(router).pairFor(tokenA, tokenB, stable);\n    depositorPair = _depositorPair;\n    _depositorSwapTokens = tokenA == IPair(_depositorPair).token1();\n    _depositorGauge = IVoter(voter).gauges(_depositorPair);\n    require(_depositorGauge != address(0), 'DD: No Gauge');\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns pool assets\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    poolAssets = new address[](2);\n    poolAssets[0] = _depositorTokenA;\n    poolAssets[1] = _depositorTokenB;\n  }\n\n  /// @notice Returns pool weights in percents (50/50%)\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    weights = new uint[](2);\n    weights[0] = 1; // 50%\n    weights[1] = 1; // 50%\n    totalWeight = 2; // 100%\n  }\n\n  /// @notice Returns pool weights in percents\n  /// @return reserves Reserves for: _depositorTokenA, _depositorTokenB\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    reserves = new uint[](2);\n    if (_depositorSwapTokens) {\n      (reserves[1], reserves[0],) = IPair(depositorPair).getReserves();\n    } else {\n      (reserves[0], reserves[1],) = IPair(depositorPair).getReserves();\n    }\n  }\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return IERC20(_depositorGauge).balanceOf(address(this));\n  }\n\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() override internal view returns (uint) {\n    return IPair(depositorPair).totalSupply();\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit, claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Deposit given amount to the pool.\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidity\n  ) {\n    uint amount0 = amountsDesired_[0];\n    uint amount1 = amountsDesired_[1];\n\n    console.log('/// !!! DEPOSITOR deposit amount0', amount0);\n    console.log('/// !!! DEPOSITOR deposit amount1', amount1);\n\n    amountsConsumed = new uint[](2);\n\n    if (amount0 == 0 || amount1 == 0) {\n      return (amountsConsumed, 0);\n    }\n\n    address tokenA = _depositorTokenA;\n    address tokenB = _depositorTokenB;\n    address router = depositorRouter;\n    bool stable = depositorStable;\n\n    AppLib.approveIfNeeded(tokenA, amount0, router);\n    AppLib.approveIfNeeded(tokenB, amount1, router);\n\n    (amountsConsumed[0], amountsConsumed[1], liquidity) = IRouter(router).addLiquidity(\n      tokenA,\n      tokenB,\n      stable,\n      amount0,\n      amount1,\n      0,\n      0,\n      address(this),\n      block.timestamp\n    );\n\n    // Stake to the Gauge\n    AppLib.approveIfNeeded(depositorPair, type(uint).max / 2, _depositorGauge); // TODO: make infinite approve in init\n    IGauge(_depositorGauge).depositAll(0);\n\n  }\n\n  /// @notice Withdraw given lp amount from the pool.\n  /// @dev if requested liquidityAmount >= invested, then should make full exit\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    amountsOut = new uint[](2);\n    if (liquidityAmount == 0) {\n      return amountsOut;\n    }\n\n    uint totalLiquidity = _depositorLiquidity();\n    if (liquidityAmount > totalLiquidity) {\n      liquidityAmount = totalLiquidity;\n    }\n\n    // Unstake from the gauge\n    IGauge(_depositorGauge).withdraw(liquidityAmount);\n\n    // Remove liquidity\n    address router = depositorRouter;\n\n    AppLib.approveIfNeeded(depositorPair, liquidityAmount, router);\n\n    (amountsOut[0], amountsOut[1]) = IRouter(router).removeLiquidity(\n      _depositorTokenA,\n      _depositorTokenB,\n      depositorStable,\n      liquidityAmount,\n      1,\n      1,\n      address(this),\n      block.timestamp\n    );\n\n    console.log('/// !!! DEPOSITOR withdraw amountsOut[0]', amountsOut[0]);\n    console.log('/// !!! DEPOSITOR withdraw amountsOut[1]', amountsOut[1]);\n  }\n\n  /// @notice Quotes output for given lp amount from the pool.\n  /// @dev if requested liquidityAmount >= invested, then should make full exit\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    amountsOut = new uint[](2);\n    if (liquidityAmount == 0) {\n      return amountsOut;\n    }\n\n    uint totalLiquidity = _depositorLiquidity();\n    if (liquidityAmount > totalLiquidity) {\n      liquidityAmount = totalLiquidity;\n    }\n\n    (amountsOut[0], amountsOut[1]) = IRouter(depositorRouter).quoteRemoveLiquidity(\n      _depositorTokenA,\n      _depositorTokenB,\n      depositorStable,\n      liquidityAmount\n    );\n  }\n\n\n  /// @dev Claim all possible rewards.\n  function _depositorClaimRewards() override internal virtual returns (address[] memory tokens, uint[] memory amounts) {\n    IGauge gauge = IGauge(_depositorGauge);\n    gauge.claimFees(); // sends fees to bribe\n\n    uint len = gauge.rewardTokensLength();\n    amounts = new uint[](len);\n    tokens = new address[](len);\n\n    for (uint i = 0; i < len; i++) {\n      address token = gauge.rewardTokens(i);\n      tokens[i] = token;\n      // temporary store current token balance\n      amounts[i] = IERC20(token).balanceOf(address(this));\n    }\n\n    gauge.getReward(address(this), tokens);\n\n    for (uint i = 0; i < len; i++) {\n      amounts[i] = IERC20(tokens[i]).balanceOf(address(this)) - amounts[i];\n    }\n    (tokens, amounts) = TokenAmountsLib.filterZeroAmounts(tokens, amounts);\n\n  }\n\n\n\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint[16] private __gap;\n\n}\n"
    },
    "contracts/strategies/quickswap/QuickswapConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./QuickswapDepositor.sol\";\nimport \"../../integrations/quickswap/IStakingRewards.sol\";\n\n///// @title Converter Strategy with Quickswap for reward pool StakingRewards\n///// @dev deprecated, we don't use it - no rewards...\n//contract QuickswapConverterStrategy is ConverterStrategyBase, QuickswapDepositor {\n//\n//  string public constant override NAME = \"Quickswap Converter Strategy\";\n//  string public constant override PLATFORM = \"Quickswap\";\n//  string public constant override STRATEGY_VERSION = \"1.0.0\";\n//\n//  /// @dev https://github.com/QuickSwap/quickswap-core\n//  address constant public _QUICKSWAP_ROUTER = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;\n//\n//  address[] public _rewardTokens;\n//\n//  /// @param rewardsPool_ Implementation of IStakingRewards, see DownloadQuickPoolsPure.ts\n//  /// @param converter_ An address of TetuConverter contract\n//  function init(\n//    address controller_,\n//    address splitter_,\n//    address rewardsPool_,\n//    address converter_,\n//    address tokenA_,\n//    address tokenB_\n//  ) external initializer {\n//    __QuickswapDepositor_init(_QUICKSWAP_ROUTER, tokenA_, tokenB_, rewardsPool_);\n//    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n//    _rewardTokens = _getRewardTokens(rewardsPool_);\n//  }\n//\n//  /// @dev Returns reward token addresses array.\n//  function rewardTokens() external view returns (address[] memory tokens) {\n//    return _rewardTokens;\n//  }\n//\n//  /////////////////////////////////////////////////////////////////////\n//  ////   Implementation of claim-rewards-abstract-functions for IStakingRewards\n//  /////////////////////////////////////////////////////////////////////\n//\n//  /// @notice List of rewards tokens\n//  function _getRewardTokens(address rewardsPool_) internal override view returns (address[] memory rewardTokensOut) {\n//    rewardTokensOut = new address[](1);\n//    rewardTokensOut[0] = address(IStakingRewards(rewardsPool_).rewardsToken());\n//  }\n//\n//  /// @notice True if any reward token can be claimed for the given address\n//  function _hasAnyRewards(address rewardsPool_, address user_) internal override view returns (bool) {\n//    return IStakingRewards(rewardsPool_).earned(user_) != 0;\n//  }\n//}\n"
    },
    "contracts/strategies/quickswap/QuickswapDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"../DepositorBase.sol\";\nimport \"../../tools/TokenAmountsLib.sol\";\nimport \"../../tools/AppErrors.sol\";\nimport \"../../tools/Uniswap2Lib.sol\";\nimport \"../../tools/AppLib.sol\";\nimport \"../../integrations/uniswap/IUniswapV2Pair.sol\";\nimport \"../../integrations/uniswap/IUniswapV2Factory.sol\";\nimport \"../../integrations/uniswap/IUniswapV2Router02.sol\";\nimport \"../../integrations/quickswap/IStakingBase.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @title Quickswap Depositor for ConverterStrategies\n/// @notice Put two amounts to the pool, get LP tokens in exchange,\n///         stake the LP tokens in the reward pool, claim the rewards by request\n/// @dev The contract is abstract because it can be used with two different rewards pool -\n///      both with IStakingRewards and IStakingDualRewards, but the strategy should implement few functions\n///      that depend on the variant of reward pool.\nabstract contract QuickswapDepositor is DepositorBase, Initializable {\n  using SafeERC20 for IERC20;\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant QUICKSWAP_DEPOSITOR_VERSION = \"1.0.0\";\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Variables\n  /////////////////////////////////////////////////////////////////////\n  IUniswapV2Pair public depositorPair;\n  IUniswapV2Router02 public router;\n  address public tokenA;\n  address public tokenB;\n  /// @notice false: _depositorTokenA == depositorPair.token0\n  ///         true:  _depositorTokenA == depositorPair.token1\n  bool private _depositorSwapTokens;\n\n  /// @notice IStakingRewards or IStakingDualRewards depending on implementation\n  address internal _rewardsPool;\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  function __QuickswapDepositor_init(\n    address router_,\n    address tokenA_,\n    address tokenB_,\n    address rewardsPool_\n  ) internal onlyInitializing {\n    require(\n      router_ != address(0)\n      && rewardsPool_ != address(0)\n      && tokenA_ != address(0)\n      && tokenB_ != address(0),\n      AppErrors.ZERO_ADDRESS\n    );\n\n    router = IUniswapV2Router02(router_);\n    tokenA = tokenA_;\n    tokenB = tokenB_;\n\n    IUniswapV2Factory factory = IUniswapV2Factory(IUniswapV2Router02(router_).factory());\n    address pair = factory.getPair(tokenA_, tokenB_);\n    require(pair != address(0), AppErrors.UNISWAP_PAIR_NOT_FOUND);\n    depositorPair = IUniswapV2Pair(pair);\n\n    _depositorSwapTokens = tokenA == IUniswapV2Pair(pair).token1();\n\n    _rewardsPool = rewardsPool_;\n\n    // infinity approve,  2**255 is more gas-efficient than type(uint).max\n    IERC20(address(depositorPair)).approve(_rewardsPool, 2**255);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                       View\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Returns pool assets\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\n    poolAssets = new address[](2);\n    poolAssets[0] = tokenA;\n    poolAssets[1] = tokenB;\n  }\n\n  /// @notice Returns pool weights in percents (50/50%)\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    weights = new uint[](2);\n    weights[0] = 1; // 50%\n    weights[1] = 1; // 50%\n    totalWeight = 2; // 100%\n  }\n\n  /// @notice Returns pool weights in percents\n  /// @return reserves Reserves for: _depositorTokenA, _depositorTokenB\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    IUniswapV2Pair _depositorPair = depositorPair; // gas saving\n\n    reserves = new uint[](2);\n    if (_depositorSwapTokens) {\n      (reserves[1], reserves[0],) = _depositorPair.getReserves();\n    } else {\n      (reserves[0], reserves[1],) = _depositorPair.getReserves();\n    }\n  }\n\n  /// @notice Returns depositor's pool shares / lp token amount\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    console.log(\"_depositorLiquidity\", IStakingBase(_rewardsPool).balanceOf(address(this)));\n    // All LP tokens were staked into the rewards pool\n    return IStakingBase(_rewardsPool).balanceOf(address(this));\n  }\n\n  //// @notice Total amount of liquidity (LP tokens) in the depositor\n  function _depositorTotalSupply() override internal view returns (uint) {\n    console.log(\"_depositorTotalSupply\", depositorPair.totalSupply());\n    return depositorPair.totalSupply();\n  }\n\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Enter, exit\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice Deposit given amount to the pool.\n  /// @param amountsDesired_ Amounts of token A and B on the balance of the depositor\n  /// @return amountsConsumedOut Amounts of token A and B deposited to the internal pool\n  /// @return liquidityOut Total amount of liquidity added to the internal pool\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    uint amount0 = amountsDesired_[0];\n    uint amount1 = amountsDesired_[1];\n\n    console.log('/// !!! DEPOSITOR deposit amount0', amount0);\n    console.log('/// !!! DEPOSITOR deposit amount1', amount1);\n\n    amountsConsumedOut = new uint[](2);\n\n    if (amount0 == 0 || amount1 == 0) {\n      return (amountsConsumedOut, 0);\n    }\n\n    address _tokenA = tokenA; // gas saving\n    address _tokenB = tokenB; // gas saving\n    IUniswapV2Router02 _router = router; // gas saving\n\n    AppLib.approveIfNeeded(_tokenA, amount0, address(_router));\n    AppLib.approveIfNeeded(_tokenB, amount1, address(_router));\n\n    (amountsConsumedOut[0], amountsConsumedOut[1], liquidityOut) = _router.addLiquidity(\n      _tokenA,\n      _tokenB,\n      amount0,\n      amount1,\n      0, // todo\n      0, // todo\n      address(this),\n      block.timestamp\n    );\n    console.log(\"_depositorEnter.amountsConsumedOut[0]\", amountsConsumedOut[0]);\n    console.log(\"_depositorEnter.amountsConsumedOut[1]\", amountsConsumedOut[1]);\n    console.log(\"_depositorEnter.liquidityOut\", liquidityOut);\n    console.log(\"_depositorEnter.depositorPair balance\", IERC20(address(depositorPair)).balanceOf(address(this)));\n\n    // stake the liquidity to the rewards pool\n    // infinity approve was made in initialization\n    IStakingBase(_rewardsPool).stake(liquidityOut);\n    console.log(\"_depositorEnter.depositorPair balance after staking\", IERC20(address(depositorPair)).balanceOf(address(this)));\n  }\n\n  /// @notice Withdraw given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then should make full exit\n  function _depositorExit(uint liquidityAmount_) override internal virtual returns (uint[] memory amountsOut) {\n    console.log(\"_depositorExit.liquidityAmount_\", liquidityAmount_);\n    amountsOut = new uint[](2);\n    if (liquidityAmount_ == 0) {\n      return amountsOut;\n    }\n\n    uint totalLiquidity = _depositorLiquidity();\n    if (liquidityAmount_ > totalLiquidity) {\n      liquidityAmount_ = totalLiquidity;\n    }\n    console.log(\"_depositorExit.liquidityAmount_ updated\", liquidityAmount_);\n\n    // unstake the liquidity from the rewards pool\n    console.log(\"_depositorEnter.depositorPair balance before unstaking\", IERC20(address(depositorPair)).balanceOf(address(this)));\n    IStakingBase(_rewardsPool).withdraw(liquidityAmount_);\n    console.log(\"_depositorEnter.depositorPair balance after unstaking\", IERC20(address(depositorPair)).balanceOf(address(this)));\n\n    // Remove liquidity\n    IUniswapV2Router02 _router = router; // gas saving\n\n    AppLib.approveIfNeeded(address(depositorPair), liquidityAmount_, address(_router));\n    (amountsOut[0], amountsOut[1]) = _router.removeLiquidity(\n      tokenA,\n      tokenB,\n      liquidityAmount_,\n      1, // todo\n      1, // todo\n      address(this),\n      block.timestamp\n    );\n\n    console.log('/// !!! DEPOSITOR withdraw amountsOut[0]', amountsOut[0]);\n    console.log('/// !!! DEPOSITOR withdraw amountsOut[1]', amountsOut[1]);\n  }\n\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\n  /// @dev if requested liquidityAmount >= invested, then should make full exit\n  function _depositorQuoteExit(uint liquidityAmount_) override internal virtual returns (uint[] memory amountsOut) {\n    console.log(\"_depositorQuoteExit\", liquidityAmount_);\n    amountsOut = new uint[](2);\n    if (liquidityAmount_ == 0) {\n      return amountsOut;\n    }\n\n    uint totalLiquidity = _depositorLiquidity();\n    if (liquidityAmount_ > totalLiquidity) {\n      liquidityAmount_ = totalLiquidity;\n    }\n\n    (amountsOut[0], amountsOut[1]) = Uniswap2Lib.quoteRemoveLiquidity(\n      router,\n      address(this),\n      tokenA,\n      tokenB,\n      liquidityAmount_\n    );\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ////   Abstract functions\n  ///    The implementation depends on the rewards pool kind:\n  ///    IStakingRewards and IStakingDualRewards have different implementations.\n  /////////////////////////////////////////////////////////////////////\n\n  /// @notice List of rewards tokens\n  function _getRewardTokens(address rewardsPool_) internal virtual view returns (address[] memory rewardTokensOut);\n\n  /// @notice True if any reward token can be claimed with not zero amount for the given address\n  function _hasAnyRewards(address rewardsPool_, address user_) internal virtual view returns (bool);\n\n  /////////////////////////////////////////////////////////////////////\n  ///             Claim rewards\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Claim all possible rewards.\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    IStakingBase __rewardsPool = IStakingBase(_rewardsPool); // gas saving\n\n    if (_hasAnyRewards(address(__rewardsPool), address(this))) {\n      tokensOut = _getRewardTokens(address(__rewardsPool));\n      uint len = tokensOut.length;\n      amountsOut = new uint[](len);\n\n      // temporary save exist balances of reward-tokens to amountsOut\n      for (uint i; i < len; ++i) {\n        amountsOut[i] = IERC20(tokensOut[i]).balanceOf(address(this));\n      }\n\n      __rewardsPool.getReward();\n\n      // get amounts of the claimed rewards\n      for (uint i; i < len; ++i) {\n        amountsOut[i] = IERC20(tokensOut[i]).balanceOf(address(this)) - amountsOut[i];\n      }\n    }\n\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\n  }\n\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n   */\n  uint[16] private __gap;\n\n}\n"
    },
    "contracts/strategies/quickswap/QuickswapDualConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../ConverterStrategyBase.sol\";\nimport \"./QuickswapDepositor.sol\";\nimport \"../../integrations/quickswap/IStakingDualRewards.sol\";\n\n///// @title Converter Strategy with Quickswap for reward pool StakingDualRewards\n///// @dev deprecated, we don't use it - no rewards...\n//contract QuickswapDualConverterStrategy is ConverterStrategyBase, QuickswapDepositor {\n//\n//  string public constant override NAME = \"Quickswap Converter Strategy\";\n//  string public constant override PLATFORM = \"Quickswap\";\n//  string public constant override STRATEGY_VERSION = \"1.0.0\";\n//\n//  /// @dev https://github.com/QuickSwap/quickswap-core\n//  address constant public _QUICKSWAP_ROUTER = 0xa5E0829CaCEd8fFDD4De3c43696c57F7D7A678ff;\n//\n//  address[] public _rewardTokens;\n//\n//  /// @param rewardsPool_ Implementation of IStakingRewards\n//  function init(\n//    address controller_,\n//    address splitter_,\n//    address rewardsPool_,\n//    address converter_,\n//    address tokenA_,\n//    address tokenB_\n//  ) external initializer {\n//    __QuickswapDepositor_init(_QUICKSWAP_ROUTER, tokenA_, tokenB_, rewardsPool_);\n//    __ConverterStrategyBase_init(controller_, splitter_, converter_);\n//    _rewardTokens = _getRewardTokens(rewardsPool_);\n//  }\n//\n//  /// @dev Returns reward token addresses array.\n//  function rewardTokens() external view returns (address[] memory tokens) {\n//    return _rewardTokens;\n//  }\n//\n//  /////////////////////////////////////////////////////////////////////\n//  ////   Implementation of claim-rewards-abstract-functions for IStakingDualRewards\n//  /////////////////////////////////////////////////////////////////////\n//\n//  /// @notice List of rewards tokens\n//  function _getRewardTokens(address rewardsPool_) internal override view returns (address[] memory rewardTokensOut) {\n//    IStakingDualRewards rewardsPool = IStakingDualRewards(rewardsPool_);\n//    rewardTokensOut = new address[](2);\n//    rewardTokensOut[0] = address(rewardsPool.rewardsTokenA());\n//    rewardTokensOut[1] = address(rewardsPool.rewardsTokenB());\n//  }\n//\n//  /// @notice True if any reward token can be claimed for the given address\n//  function _hasAnyRewards(address rewardsPool_, address user_) internal override view returns (bool) {\n//    IStakingDualRewards rewardsPool = IStakingDualRewards(rewardsPool_);\n//    return rewardsPool.earnedA(user_) != 0 || rewardsPool.earnedB(user_) != 0;\n//  }\n//}\n"
    },
    "contracts/strategies/tetu-v1/TetuV1SingleTokenStrictStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyStrictBase.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"../../integrations/tetu-v1/ISmartVault.sol\";\nimport \"../../tools/AppLib.sol\";\nimport \"../../tools/ERC20Helpers.sol\";\nimport \"../../integrations/balancer/IRateProvider.sol\";\n\n/// @title Simple auto compounding strategy for TETU V1 vaults.\n/// @author AlehNat\ncontract TetuV1SingleTokenStrictStrategy is StrategyStrictBase, IRateProvider, ERC20Helpers {\n  using SafeERC20 for IERC20;\n\n  string public constant override NAME = \"TetuV1 Single Token Strict Strategy\";\n  string public constant override PLATFORM = \"TETU\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  uint private constant _ASSET_LIQUIDATION_SLIPPAGE = 5000; // 5%\n\n  // in this strategy TETU V1 vault is used as a pool\n  ISmartVault public immutable pool;\n  ITetuLiquidator public immutable liquidator;\n  address public immutable xTetuAddress;\n\n  bool public override isReadyToHardWork;\n\n  constructor(address _pool, address _liquidator, address _xTetuAddress) {\n    pool = ISmartVault(_pool);\n    liquidator = ITetuLiquidator(_liquidator);\n    xTetuAddress = _xTetuAddress;\n    isReadyToHardWork = true;\n  }\n\n\n  // uint earned, uint lost is it in USD?\n  function doHardWork() external override returns (uint earned, uint lost) {\n    // if we have some asset in the strategy we need to deposit it to the pool to not liquidate it.\n    uint assetBalanceBeforeClaim = _balance(asset);\n    if (assetBalanceBeforeClaim > 0) {\n      _depositToPool(assetBalanceBeforeClaim);\n    }\n\n    uint strategyBalanceBefore = pool.underlyingBalanceWithInvestmentForHolder(address(this));\n\n    _claim();\n    _unwrapXTetu();\n    _liquidateReward();\n    uint assetBalance = _balance(asset);\n    if (assetBalance > 0) {\n      _depositToPool(assetBalance);\n    }\n    earned = 0;\n    lost = 0;\n\n    uint strategyBalanceAfter = pool.underlyingBalanceWithInvestmentForHolder(address(this));\n\n    if(strategyBalanceAfter > strategyBalanceBefore) {\n      earned = strategyBalanceAfter - strategyBalanceBefore;\n    } else {\n      lost = strategyBalanceBefore - strategyBalanceAfter;\n    }\n  }\n\n  /// @dev Deposit given amount to the pool.\n  function _depositToPool(uint amount) internal override {\n    IERC20(asset).safeIncreaseAllowance(address(pool), amount);\n    pool.depositAndInvest(amount);\n  }\n\n  /// @dev Withdraw given amount from the pool.\n  /// @return investedAssetsUSD and assetPrice are not used in this strategy (0,0)\n  function _withdrawFromPool(uint amount) internal override returns (uint investedAssetsUSD, uint assetPrice) {\n    pool.withdraw(amount);\n    return (0, 0);\n  }\n\n  /// @dev Withdraw all from the pool.\n  /// @return investedAssetsUSD and assetPrice are not used in this strategy returns (0,0)\n  function _withdrawAllFromPool() internal override returns (uint investedAssetsUSD, uint assetPrice) {\n    uint totalBalance = _balance(address (pool));\n    return _withdrawFromPool(totalBalance);\n  }\n\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\n  ///      Withdraw assets without impact checking.\n  function _emergencyExitFromPool() internal override {\n    _withdrawAllFromPool();\n  }\n\n  /// @dev Claim all possible rewards.\n  function _claim() internal override {\n    pool.getAllRewards();\n  }\n\n  function _unwrapXTetu() internal {\n    uint xTetuBalance = _balance(xTetuAddress);\n    if (xTetuBalance > 0) {\n      ISmartVault(xTetuAddress).withdraw(xTetuBalance);\n    }\n  }\n\n  function _liquidateReward() internal {\n    address [] memory rewardTokens = pool.rewardTokens();\n    for(uint i = 0; i < rewardTokens.length; i = AppLib.uncheckedInc(i)) {\n      address rewardToken = rewardTokens[i];\n      uint rewardBalance = _balance(rewardToken);\n      if (rewardBalance > 0) {\n        IERC20(rewardToken).safeIncreaseAllowance(address(liquidator), rewardBalance);\n        liquidator.liquidate(rewardToken, asset, rewardBalance, _ASSET_LIQUIDATION_SLIPPAGE);\n      }\n    }\n  }\n\n  function getRate() external view override returns (uint256) {\n    uint assetPrecision = 10 ** IERC20Metadata(asset).decimals();\n    return IERC4626(vault).convertToAssets(assetPrecision) * 1e18 / assetPrecision;\n  }\n\n  function investedAssets() public view override returns (uint) {\n    return pool.underlyingBalanceWithInvestmentForHolder(address(this));\n  }\n\n}\n"
    },
    "contracts/test/aave/Aave3AggregatorInterfaceMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/aave/AggregatorInterface.sol\";\n\n/// @notice A source of asset's price for AAVE3 price oracle\n///         See price oracle 0xb023e699F5a33916Ea823A16485e259257cA8Bd1\ncontract Aave3AggregatorInterfaceMock is AggregatorInterface {\n  int256 public price;\n  uint public round;\n  mapping(uint => uint) roundToTimestamp;\n  mapping(uint => int256) roundToPrice;\n\n  constructor (int256 price_) {\n    price = price_;\n    round = 1;\n    roundToTimestamp[round] = block.timestamp;\n    roundToPrice[round] = price_;\n  }\n\n  function setPrice(int256 price_) external {\n    price = price_;\n    round += 1;\n    roundToTimestamp[round] = block.timestamp;\n    roundToPrice[round] = price_;\n  }\n\n  // ---------------  AggregatorInterface ----------------------------------------------------------\n  function latestAnswer() external override view returns (int256) {\n    return price;\n  }\n\n  function latestTimestamp() external override view returns (uint256) {\n    return roundToTimestamp[round];\n  }\n\n  function latestRound() external override view returns (uint256) {\n    return round;\n  }\n\n  function getAnswer(uint256 roundId) external override view returns (int256) {\n    return roundToPrice[roundId];\n  }\n\n  function getTimestamp(uint256 roundId) external override view returns (uint256) {\n    return roundToTimestamp[roundId];\n  }\n}"
    },
    "contracts/test/balancer/BalancerComposableStableDepositorFacade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/balancer/IBVault.sol\";\nimport \"../../strategies/balancer/BalancerComposableStableDepositor.sol\";\n\n/// @notice Provide direct access to internal functions of {BalancerBoostedAaveStableDepositor}\ncontract BalancerComposableStableDepositorFacade is BalancerComposableStableDepositor {\n  function init(\n    bytes32 poolId,\n    address[] memory rewardTokens_\n  ) external initializer {\n    __BalancerBoostedAaveUsdDepositor_init(poolId, rewardTokens_);\n  }\n\n  function _depositorPoolAssetsAccess() external virtual view returns (address[] memory poolAssets) {\n    return _depositorPoolAssets();\n  }\n\n  function _depositorPoolWeightsAccess() external virtual view returns (uint[] memory weights, uint totalWeight) {\n    return _depositorPoolWeights();\n  }\n\n  function _depositorPoolReservesAccess() external virtual view returns (uint[] memory reserves) {\n    return _depositorPoolReserves();\n  }\n\n  function _depositorLiquidityAccess() external virtual view returns (uint) {\n    return _depositorLiquidity();\n  }\n\n  function _depositorTotalSupplyAccess() external view returns (uint) {\n    return _depositorTotalSupply();\n  }\n\n  uint[] public lastAmountsConsumedOut;\n  uint public lastAmountsConsumedOutLength;\n  uint public lastLiquidityOut;\n  function _depositorEnterAccess(uint[] memory amountsDesired_) external virtual returns (\n    uint[] memory amountsConsumedOut,\n    uint liquidityOut\n  ) {\n    (amountsConsumedOut, liquidityOut) = _depositorEnter(amountsDesired_);\n    // let's store results of _depositorEnter last call to public members\n    (lastAmountsConsumedOut, lastLiquidityOut) = (amountsConsumedOut, liquidityOut);\n    lastAmountsConsumedOutLength = lastAmountsConsumedOut.length;\n  }\n\n  uint[] public lastAmountsOut;\n  uint public lastAmountsOutLength;\n  uint public lastLiquidityAmountIn;\n  function _depositorExitAccess(uint liquidityAmount_) external returns (uint[] memory) {\n    lastLiquidityAmountIn = liquidityAmount_ == 0  // 0 means that we should withdraw all liquidity\n      ? _depositorLiquidity()\n      : liquidityAmount_;\n    lastAmountsOut = _depositorExit(lastLiquidityAmountIn);\n    lastAmountsOutLength = lastAmountsOut.length;\n    return lastAmountsOut;\n  }\n\n  uint[] public lastQuoteExitAmountsOut;\n  uint public lastQuoteExitAmountsOutLength;\n  function _depositorQuoteExitAccess(uint liquidityAmount_) external returns (uint[] memory) {\n    lastQuoteExitAmountsOut = _depositorQuoteExit(\n      liquidityAmount_ == 0  // 0 means that we should withdraw all liquidity\n        ? _depositorLiquidity()\n        : liquidityAmount_\n    );\n    lastQuoteExitAmountsOutLength = lastQuoteExitAmountsOut.length;\n    return lastQuoteExitAmountsOut;\n  }\n\n  uint[] public lastRewardsAmountsOut;\n  address[] public lastRewardsTokensOut;\n  uint public lastRewardsAmountsOutLength;\n  uint public lastRewardsTokensOutLength;\n  function _depositorClaimRewardsAccess() external virtual returns (\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    (tokensOut, amountsOut) = _depositorClaimRewards();\n    lastRewardsAmountsOut = amountsOut;\n    lastRewardsTokensOut = tokensOut;\n    lastRewardsAmountsOutLength = amountsOut.length;\n    lastRewardsTokensOutLength = tokensOut.length;\n  }\n}\n"
    },
    "contracts/test/balancer/BalancerLogicLibFacade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"../../strategies/balancer/BalancerLogicLib.sol\";\n\n/// @notice Provide external access to all functions of BalancerLogicLib\ncontract BalancerLogicLibFacade {\n  function getAmountsToDeposit(\n    uint[] memory amountsDesired_,\n    IERC20[] memory tokens_,\n    uint[] memory balances_,\n    uint[] memory totalUnderlying_,\n    uint indexBpt_\n  ) external view returns (\n    uint[] memory amountsOut\n  ) {\n    return BalancerLogicLib.getAmountsToDeposit(amountsDesired_, tokens_, balances_, totalUnderlying_, indexBpt_);\n  }\n\n  function getTotalAssetAmounts(IBVault vault_, IERC20[] memory tokens_, uint indexBpt_) external view returns (\n    uint[] memory amountsOut\n  ) {\n    return BalancerLogicLib.getTotalAssetAmounts(vault_, tokens_, indexBpt_);\n  }\n\n  function getBtpAmountsOut(\n    uint liquidityAmount_,\n    uint[] memory balances_,\n    uint bptIndex_\n  ) external pure returns (uint[] memory) {\n    return BalancerLogicLib.getBtpAmountsOut(liquidityAmount_, balances_, bptIndex_);\n  }\n}"
    },
    "contracts/test/BalancerComposableStableStrategyAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/balancer/BalancerComposableStableStrategy.sol\";\n\n/// @notice Provide direct access to BalancerComposableStableStrategy internal functions\ncontract BalancerComposableStableStrategyAccess is BalancerComposableStableStrategy {\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  ///  Set up\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function setBaseAmountAccess(address token_, uint amount_) external {\n    baseAmounts[token_] = amount_;\n  }\n\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n  ///  Access to internal functions\n  //////////////////////////////////////////////////////////////////////////////////////////////////////\n\n  function _depositToPoolAccess(uint amount_, bool updateTotalAssetsBeforeInvest_) external returns (\n    int totalAssetsDelta\n  ) {\n    return _depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n  }\n\n  function _withdrawFromPoolAccess(uint amount) external returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    return _withdrawFromPool(amount);\n  }\n\n  function _withdrawAllFromPoolAccess() external returns (\n    uint investedAssetsUSD,\n    uint assetPrice,\n    int totalAssetsDelta\n  ) {\n    return _withdrawAllFromPool();\n  }\n}"
    },
    "contracts/test/DepositorTestBase.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/DepositorBase.sol\";\n\n\n/// @title Abstract Depositor Test Base contract.\n/// @author bogdoslav\nabstract contract DepositorTestBase is DepositorBase {\n\n  address[] private _claimedRewardTokens;\n  uint[] private _claimedRewardAmounts;\n\n  /// @dev Deposit given amount to the pool.\n  /// @notice Depositor must care about tokens approval by itself.\n  function depositorEnter(uint[] memory amountsDesired_)\n  external returns (uint[] memory amountsConsumed, uint liquidityOut) {\n    return _depositorEnter(amountsDesired_);\n  }\n\n  /// @dev Withdraw given lp amount from the pool.\n  /// @notice if requested liquidityAmount >= invested, then should make full exit\n  function depositorExit(uint liquidityAmount)\n  external returns (uint[] memory amountsOut) {\n    return _depositorExit(liquidityAmount);\n  }\n\n  /// @dev Quotes output for given lp amount from the pool.\n  function depositorQuoteExit(uint liquidityAmount) external returns (uint[] memory amountsOut) {\n    return _depositorQuoteExit(liquidityAmount);\n  }\n\n  /// @dev If pool supports emergency withdraw need to call it for emergencyExit()\n  function depositorEmergencyExit()\n  external returns (uint[] memory amountsOut) {\n    return _depositorEmergencyExit();\n  }\n\n  /// @dev Claim all possible rewards.\n  function depositorClaimRewards()\n  external returns (address[] memory rewardTokens, uint[] memory rewardAmounts) {\n    (rewardTokens, rewardAmounts) = _depositorClaimRewards();\n    _claimedRewardTokens = rewardTokens;\n    _claimedRewardAmounts = rewardAmounts;\n  }\n\n  function claimedRewardTokens()\n  external view returns (address[] memory) {\n    return _claimedRewardTokens;\n  }\n\n  function claimedRewardAmounts()\n  external view returns (uint[] memory) {\n    return _claimedRewardAmounts;\n  }\n\n  /// @dev Returns depositor's pool shares / lp token amount\n  function depositorLiquidity() external view returns (uint) {\n    return _depositorLiquidity();\n\n  }\n\n  /// @dev Returns pool token reserves\n  function depositorPoolReserves() external view returns (uint[] memory reserves) {\n    return _depositorPoolReserves();\n  }\n\n  /// @dev Returns pool token assets\n  function depositorPoolAssets() external view returns (address[] memory assets) {\n    return _depositorPoolAssets();\n  }\n\n  /// @dev Returns pool token weights\n  function depositorPoolWeights() external view returns (uint[] memory weights, uint total) {\n    return _depositorPoolWeights();\n  }\n\n\n}\n"
    },
    "contracts/test/DummyERC4626Strict.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/ERC4626Strict.sol\";\n\n\ncontract DummyERC4626Strict is ERC4626Strict {\n    constructor(IERC20 asset_,\n        string memory _name,\n        string memory _symbol,\n        address _strategy,\n        uint _buffer)  ERC4626Strict(asset_, _name, _symbol, _strategy, _buffer){}\n}\n"
    },
    "contracts/test/DystopiaDepositorTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/DepositorBase.sol\";\nimport \"../strategies/dystopia/DystopiaDepositor.sol\";\nimport \"./DepositorTestBase.sol\";\n\n/// @title Dystopia Depositor Test contract.\n/// @author bogdoslav\ncontract DystopiaDepositorTest is DepositorTestBase, DystopiaDepositor {\n  constructor(address router, address tokenA, address tokenB, bool stable, address voter)\n  initializer {\n    __DystopiaDepositor_init(router, tokenA, tokenB, stable, voter);\n  }\n\n  function depositorGauge() external view returns (address) {\n    return _depositorGauge;\n  }\n}\n"
    },
    "contracts/test/facades/ConverterStrategyBaseLibFacade.sol": {
      "content": "// SPDX-License-Identifier: ISC\npragma solidity 0.8.17;\n\nimport \"../../interfaces/converter/IPriceOracle.sol\";\nimport \"../../strategies/ConverterStrategyBaseLib.sol\";\n\n/// @notice Provide public access to internal functions of ConverterStrategyBaseLib\ncontract ConverterStrategyBaseLibFacade {\n  function getExpectedWithdrawnAmounts(\n    uint[] memory reserves_,\n    uint liquidityAmount_,\n    uint totalSupply_\n  ) external pure returns (\n    uint[] memory withdrawnAmountsOut\n  ) {\n    return ConverterStrategyBaseLib.getExpectedWithdrawnAmounts(reserves_, liquidityAmount_, totalSupply_);\n  }\n\n  mapping (address => uint) public baseAmounts;\n  function setBaseAmounts(address asset, uint amount) external {\n    baseAmounts[asset] = amount;\n  }\n\n  function getLiquidityAmountRatio(\n    uint targetAmount_,\n    address strategy_,\n    ConverterStrategyBaseLib.LiquidityAmountRatioInputParams memory params_\n  ) external returns (\n    uint liquidityRatioOut,\n    uint[] memory amountsToConvertOut\n  ) {\n    return ConverterStrategyBaseLib.getLiquidityAmountRatio(targetAmount_, baseAmounts, strategy_, params_);\n  }\n\n  function getCollaterals(\n    uint amount_,\n    address[] memory tokens_,\n    uint[] memory weights_,\n    uint totalWeight_,\n    uint indexAsset_,\n    IPriceOracle priceOracle\n  ) external view returns (uint[] memory tokenAmountsOut) {\n    return ConverterStrategyBaseLib.getCollaterals(\n      amount_,\n      tokens_,\n      weights_,\n      totalWeight_,\n      indexAsset_,\n      priceOracle\n    );\n  }\n\n  function openPosition(\n    ITetuConverter tetuConverter_,\n    bytes memory entryData_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountIn_\n  ) external returns (\n    uint collateralAmountOut,\n    uint borrowedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.openPosition(\n      tetuConverter_,\n      entryData_,\n      collateralAsset_,\n      borrowAsset_,\n      amountIn_\n    );\n  }\n\n  function closePosition(\n    ITetuConverter tetuConverter_,\n    address collateralAsset,\n    address borrowAsset,\n    uint amountToRepay\n  ) external returns (\n    uint returnedAssetAmountOut,\n    uint leftoverOut\n  ) {\n    return ConverterStrategyBaseLib.closePosition(\n      tetuConverter_,\n      collateralAsset,\n      borrowAsset,\n      amountToRepay\n    );\n  }\n\n  function liquidate(\n    ITetuLiquidator liquidator_,\n    address tokenIn,\n    address tokenOut,\n    uint amountIn,\n    uint slippage,\n    uint rewardLiquidationThresholdForTokenOut\n  ) external returns (\n    uint spentAmountIn,\n    uint receivedAmountOut\n  ) {\n    return ConverterStrategyBaseLib.liquidate(\n      liquidator_,\n      tokenIn,\n      tokenOut,\n      amountIn,\n      slippage,\n      rewardLiquidationThresholdForTokenOut\n    );\n  }\n\n  function getAssetIndex(address[] memory tokens_, address asset_) external pure returns (uint) {\n    return ConverterStrategyBaseLib.getAssetIndex(tokens_, asset_);\n  }\n\n  function getAvailableBalances(\n    address[] memory tokens_,\n    uint indexAsset\n  ) external view returns (uint[] memory) {\n    return ConverterStrategyBaseLib.getAvailableBalances(tokens_, indexAsset);\n  }\n\n  function calcInvestedAssets(\n    address[] memory tokens,\n    uint[] memory amountsOut,\n    uint indexAsset,\n    ITetuConverter converter_\n  ) external returns (\n    uint amountOut\n  ) {\n    return ConverterStrategyBaseLib.calcInvestedAssets(\n      tokens,\n      amountsOut,\n      indexAsset,\n      converter_,\n      baseAmounts\n    );\n  }\n}"
    },
    "contracts/test/facades/Uniswap2LibFacade.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../../integrations/uniswap/IUniswapV2Router02.sol\";\nimport \"../../tools/Uniswap2Lib.sol\";\n\n/// @notice Provide direct access to Uniswal2Lib functions for unit tests\ncontract Uniswap2LibFacade {\n  function quoteRemoveLiquidity(\n    IUniswapV2Router02 router_,\n    address user_,\n    address tokenA_,\n    address tokenB_,\n    uint liquidity_\n  ) external view returns(\n    uint amountAOut,\n    uint amountBOut\n  ) {\n    return Uniswap2Lib.quoteRemoveLiquidity(router_, user_, tokenA_, tokenB_, liquidity_);\n  }\n}"
    },
    "contracts/test/MockConverterStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../strategies/ConverterStrategyBase.sol\";\nimport \"./MockDepositor.sol\";\n\n/// @title Mock Converter Strategy with MockDepositor\n/// @author bogdoslav\ncontract MockConverterStrategy is ConverterStrategyBase, MockDepositor {\n\n  string public constant override NAME = \"mock converter strategy\";\n  string public constant override PLATFORM = \"test\";\n  string public constant override STRATEGY_VERSION = \"1.0.0\";\n\n  function init(\n    address controller_,\n    address splitter_,\n    address converter_,\n    address[] memory depositorTokens_,\n    uint[] memory depositorWeights_,\n    uint[] memory depositorReserves_\n  ) external initializer {\n\n    __MockDepositor_init(\n      depositorTokens_,\n      depositorWeights_,\n      depositorReserves_\n    );\n\n    __ConverterStrategyBase_init(\n      controller_,\n      splitter_,\n      converter_\n    );\n  }\n\n\n  //////////////////////////////////////////////////////////////////////\n  ///    Provide direct access to internal functions for tests\n  //////////////////////////////////////////////////////////////////////\n  function _updateBaseAmountsAccess(\n    address[] memory tokens_,\n    uint[] memory receivedAmounts_,\n    uint[] memory spentAmounts_,\n    uint indexAsset_,\n    int amountAsset_\n  ) external {\n    return _updateBaseAmounts(tokens_, receivedAmounts_, spentAmounts_, indexAsset_, amountAsset_);\n  }\n\n  function _convertAfterWithdrawAccess(\n    address[] memory tokens_,\n    uint indexAsset_,\n    uint[] memory amountsToConvert_\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return _convertAfterWithdraw(tokens_, indexAsset_, amountsToConvert_);\n  }\n\n  function _convertAfterWithdrawAllAccess(\n    address[] memory tokens_,\n    uint indexAsset_\n  ) external returns (\n    uint collateralOut,\n    uint[] memory repaidAmountsOut\n  ) {\n    return _convertAfterWithdrawAll(tokens_, indexAsset_);\n  }\n\n  function closePositionTestAccess(address collateralAsset, address borrowAsset, uint amountToRepay) external returns (\n    uint returnedAssetAmount,\n    uint leftover\n  ) {\n    return ConverterStrategyBaseLib.closePosition(converter, collateralAsset, borrowAsset, amountToRepay);\n  }\n\n  function updateInvestedAssetsTestAccess() external {\n    _updateInvestedAssets();\n  }\n\n  function withdrawFromPoolTestAccess(uint amount, uint investedAssets_) external returns (\n    uint investedAssetsUSD,\n    uint assetPrice\n  ) {\n    return _withdrawUniversal(amount, false, investedAssets_);\n  }\n\n  function _withdrawAllFromPoolTestAccess(uint investedAssets_) external returns (\n    uint investedAssetsUSD,\n    uint assetPrice\n  ) {\n    return _withdrawUniversal(0, true, investedAssets_);\n  }\n\n  function _doHardWorkAccess(bool reInvest) external returns (uint earned, uint lost) {\n    return _doHardWork(reInvest);\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// _handleRewards, mocked version + accessor\n  /////////////////////////////////////////////////////////////////////////////////////\n  function _handleRewards() internal override returns (uint earned, uint lost) {\n    if (handleRewardsParams.initialized) {\n      console.log(\"_handleRewards.mocked-version is called\");\n      if (handleRewardsParams.assetBalanceChange > 0) {\n       IERC20(asset).transferFrom(\n          handleRewardsParams.providerBalanceChange,\n          address(this),\n          uint(handleRewardsParams.assetBalanceChange)\n        );\n      } else if (handleRewardsParams.assetBalanceChange < 0) {\n        IERC20(asset).transfer(\n          handleRewardsParams.providerBalanceChange,\n          uint(-handleRewardsParams.assetBalanceChange)\n        );\n      }\n      return (handleRewardsParams.earned, handleRewardsParams.lost);\n    } else {\n      return super._handleRewards();\n    }\n  }\n  function _handleRewardsAccess() external virtual returns (uint earned, uint lost) {\n    return _handleRewards();\n  }\n\n  struct MockedHandleRewardsParams {\n    bool initialized;\n    uint earned;\n    uint lost;\n    int assetBalanceChange;\n    address providerBalanceChange;\n  }\n  MockedHandleRewardsParams private handleRewardsParams;\n  function setMockedHandleRewardsResults(\n    uint earned,\n    uint lost,\n    int assetBalanceChange,\n    address providerBalanceChange\n  ) external {\n    handleRewardsParams =  MockedHandleRewardsParams({\n      initialized: true,\n      earned: earned,\n      lost: lost,\n      assetBalanceChange: assetBalanceChange,\n      providerBalanceChange: providerBalanceChange\n    });\n  }\n\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// _depositToPool mock\n  /////////////////////////////////////////////////////////////////////////////////////\n  struct MockedDepositToPoolParams {\n    bool initialized;\n    int balanceChange;\n    address providerBalanceChange;\n    int totalAssetsDelta;\n  }\n  MockedDepositToPoolParams public depositToPoolParams;\n  function _depositToPoolAccess(uint amount_, bool updateTotalAssetsBeforeInvest_) external returns(\n    int totalAssetsDelta\n  ) {\n    return _depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n  }\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\n    int totalAssetsDelta\n  ){\n    if (depositToPoolParams.initialized) {\n      console.log(\"_depositToPool.mocked-version is called\");\n      if (depositToPoolParams.balanceChange > 0) {\n        IERC20(asset).transferFrom(\n          depositToPoolParams.providerBalanceChange,\n          address(this),\n          uint(depositToPoolParams.balanceChange)\n        );\n      } else if (depositToPoolParams.balanceChange < 0) {\n        IERC20(asset).transfer(\n          depositToPoolParams.providerBalanceChange,\n          uint(-depositToPoolParams.balanceChange)\n        );\n      }\n      totalAssetsDelta = depositToPoolParams.totalAssetsDelta;\n    } else {\n      totalAssetsDelta = super._depositToPool(amount_, updateTotalAssetsBeforeInvest_);\n    }\n  }\n  function setMockedDepositToPool(int balanceChange, address providerBalanceChange, int totalAssetsDelta_) external {\n    depositToPoolParams = MockedDepositToPoolParams({\n      initialized: true,\n      balanceChange: balanceChange,\n      providerBalanceChange: providerBalanceChange,\n      totalAssetsDelta: totalAssetsDelta_\n    });\n  }\n  /////////////////////////////////////////////////////////////////////////////////////\n  /// Others\n  /////////////////////////////////////////////////////////////////////////////////////\n\n  function _recycleAccess(address[] memory tokens, uint[] memory amounts) external virtual returns(\n    uint[] memory receivedAmounts,\n    uint[] memory spentAmounts,\n    uint[] memory amountsToForward\n  ) {\n    return _recycle(tokens, amounts);\n  }\n\n  function _beforeDepositAccess(\n    ITetuConverter tetuConverter_,\n    uint amount_,\n    address[] memory tokens_,\n    uint indexAsset_\n  ) external returns (\n    uint[] memory tokenAmounts,\n    uint[] memory borrowedAmounts,\n    uint spentCollateral\n  ) {\n    return _beforeDeposit(tetuConverter_, amount_, tokens_, indexAsset_);\n  }\n\n  function setBaseAmountAccess(address token_, uint amount_) external {\n    baseAmounts[token_] = amount_;\n  }\n\n  function _prepareRewardsListAccess(\n    ITetuConverter tetuConverter_,\n    address[] memory tokens_,\n    uint[] memory amounts_\n  ) external returns(\n    address[] memory tokensOut,\n    uint[] memory amountsOut\n  ) {\n    return _prepareRewardsList(tetuConverter_, tokens_, amounts_);\n  }\n\n  function _emergencyExitFromPoolAccess() external {\n    _emergencyExitFromPool();\n  }\n\n  function _updateInvestedAssetsAndGetDeltaAccess(bool updateTotalAssetsBeforeInvest_) external returns (\n    uint updatedInvestedAssets,\n    int totalAssetsDelta\n  ) {\n    return _updateInvestedAssetsAndGetDelta(updateTotalAssetsBeforeInvest_);\n  }\n}\n"
    },
    "contracts/test/MockDepositor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../strategies/DepositorBase.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/IMockToken.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\";\nimport \"hardhat/console.sol\";\n\n/// @title Mock contract for base Depositor.\ncontract MockDepositor is DepositorBase, Initializable {\n\n  /// @dev Version of this contract. Adjust manually on each code modification.\n  string public constant DEPOSITOR_MOCK_VERSION = \"1.0.0\";\n\n  uint[] private _depositorReserves;\n  uint[] private _depositorWeights;\n\n  address[] private _depositorAssets;\n\n  /// @notice total amount of active LP tokens.\n  uint public totalSupply;\n  uint private depositorLiquidity;\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Initialization\n  /////////////////////////////////////////////////////////////////////\n\n  // @notice tokens must be MockTokens\n  function __MockDepositor_init(\n    address[] memory tokens_,\n    uint[] memory depositorWeights_,\n    uint[] memory depositorReserves_\n  ) internal onlyInitializing {\n    require(tokens_.length == depositorReserves_.length, \"depositorReserves_.length\");\n    require(tokens_.length == depositorWeights_.length, \"depositorWeights_.length\");\n\n    uint tokensLength = tokens_.length;\n    for (uint i = 0; i < tokensLength; ++i) {\n      _depositorAssets.push(tokens_[i]);\n      _depositorWeights.push(depositorWeights_[i]);\n      _depositorReserves.push(depositorReserves_[i]);\n    }\n    console.log(\"__MockDepositor_init\", tokensLength, _depositorAssets.length, _depositorWeights.length);\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorTotalSupply\n  /////////////////////////////////////////////////////////////////////\n  function setTotalSupply(uint totalSupply_) external {\n    totalSupply = totalSupply_;\n  }\n  //// @notice Total amount of LP tokens in the depositor\n  function _depositorTotalSupply() override internal view returns (uint) {\n    return totalSupply;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorLiquidity\n  /////////////////////////////////////////////////////////////////////\n\n  function _depositorLiquidity() override internal virtual view returns (uint) {\n    return depositorLiquidity;\n  }\n\n  function setDepositorLiquidity(uint depositorLiquidity_) external {\n    depositorLiquidity = depositorLiquidity_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   Misc\n  /////////////////////////////////////////////////////////////////////\n\n  /// @dev Returns pool assets\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory) {\n    console.log(\"_depositorPoolAssets\");\n    return _depositorAssets;\n  }\n\n  /// @dev Returns pool weights\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\n    console.log(\"_depositorPoolWeights\", _depositorWeights.length);\n    weights = _depositorWeights;\n    uint len = weights.length;\n    totalWeight = 0;\n    for(uint i = 0; i < len; i++) {\n      totalWeight += weights[i];\n    }\n  }\n\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\n    reserves = new uint[](_depositorReserves.length);\n    for (uint i = 0; i < _depositorReserves.length; ++i) {\n      reserves[i] = _depositorReserves[i];\n    }\n  }\n\n  function setDepositorPoolReserves(uint[] memory depositorReserves_) external {\n    _depositorReserves = depositorReserves_;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorEnter\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorEnterParams {\n    uint[] amountsDesired;\n    uint[] amountsConsumed;\n    uint liquidityOut;\n  }\n  DepositorEnterParams public depositorEnterParams;\n\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\n    uint[] memory amountsConsumed,\n    uint liquidityOut\n  ) {\n    require(_depositorAssets.length == amountsDesired_.length);\n\n    uint len = amountsDesired_.length;\n    amountsConsumed = new uint[](len);\n\n    for (uint i = 0; i < len; ++i) {\n      require(amountsDesired_[i] == depositorEnterParams.amountsDesired[i], \"_depositorEnter input params\");\n      IMockToken token = IMockToken(_depositorAssets[i]);\n      token.burn(address(this), depositorEnterParams.amountsConsumed[i]);\n      amountsConsumed[i] = depositorEnterParams.amountsConsumed[i];\n    }\n\n    liquidityOut = depositorEnterParams.liquidityOut;\n    depositorLiquidity += liquidityOut;\n  }\n\n  function setDepositorEnter(uint[] memory amountsDesired_, uint[] memory amountsConsumed_, uint liquidityOut_) external {\n    depositorEnterParams.liquidityOut = liquidityOut_;\n\n    uint len = _depositorAssets.length;\n    depositorEnterParams.amountsDesired = new uint[](len);\n    depositorEnterParams.amountsConsumed = new uint[](len);\n    for (uint i = 0; i < len; ++i) {\n      depositorEnterParams.amountsDesired[i] = amountsDesired_[i];\n      depositorEnterParams.amountsConsumed[i] = amountsConsumed_[i];\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorExit\n  /////////////////////////////////////////////////////////////////////\n\n  struct DepositorExitParams {\n    uint liquidityAmount;\n    uint[] amountsOut;\n  }\n  DepositorExitParams public depositorExitParams;\n\n  function _depositorExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\n    console.log(\"MockDepositor._depositorExit liquidityAmount\", liquidityAmount, depositorExitParams.liquidityAmount);\n    require(liquidityAmount == depositorExitParams.liquidityAmount, \"_depositorExit input params\");\n\n    uint len = _depositorAssets.length;\n    amountsOut = new uint[](len);\n\n    for (uint i = 0; i < len; ++i) {\n      IMockToken token = IMockToken(_depositorAssets[i]);\n      token.mint(address(this), depositorExitParams.amountsOut[i]);\n      amountsOut[i] = depositorExitParams.amountsOut[i];\n    }\n\n    // we need to modify depositorLiquidity for tests with _updateInvestedAssets\n    if (depositorLiquidity >= liquidityAmount) {\n      depositorLiquidity -= liquidityAmount;\n    }\n  }\n\n  function setDepositorExit(uint liquidityAmount_, uint[] memory amountsOut_) external {\n    console.log(\"MockDepositor.setDepositorExit liquidityAmount\", liquidityAmount_);\n    depositorExitParams.liquidityAmount = liquidityAmount_;\n    depositorExitParams.amountsOut = new uint[](amountsOut_.length);\n    for (uint i = 0; i < amountsOut_.length; ++i) {\n      depositorExitParams.amountsOut[i] = amountsOut_[i];\n    }\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorQuoteExit\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorQuoteExitParams {\n    uint liquidityAmount;\n    uint[] amountsOut;\n  }\n  /// @notice keccak256(liquidityAmount + 1) => results\n  mapping(bytes32 => DepositorQuoteExitParams) public depositorQuoteExitParams;\n\n  /// @dev Quotes output for given lp amount from the pool.\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual view returns (uint[] memory amountsOut) {\n    bytes32 key = keccak256(abi.encodePacked(liquidityAmount + 1));\n    DepositorQuoteExitParams memory p = depositorQuoteExitParams[key];\n    if (p.liquidityAmount == liquidityAmount) {\n      console.log(\"_depositorQuoteExit liquidityAmount\", liquidityAmount, p.liquidityAmount);\n\n      uint len = _depositorAssets.length;\n      amountsOut = new uint[](len);\n      for (uint i = 0; i < len; ++i) {\n        amountsOut[i] = p.amountsOut[i];\n      }\n    } else {\n      console.log(\"_depositorQuoteExit.missed liquidityAmount\", liquidityAmount);\n      revert(\"_depositorQuoteExit.missed liquidityAmount\");\n    }\n\n    return amountsOut;\n  }\n\n  function setDepositorQuoteExit(uint liquidityAmount_, uint[] memory amountsOut_) external {\n    console.log(\"setDepositorQuoteExit, liquidityAmount_\", liquidityAmount_);\n    bytes32 key = keccak256(abi.encodePacked(liquidityAmount_ + 1));\n\n    DepositorQuoteExitParams memory p = DepositorQuoteExitParams({\n      liquidityAmount: liquidityAmount_,\n      amountsOut: new uint[](amountsOut_.length)\n    });\n\n    for (uint i = 0; i < amountsOut_.length; ++i) {\n      p.amountsOut[i] = amountsOut_[i];\n    }\n\n    depositorQuoteExitParams[key] = p;\n  }\n\n  /////////////////////////////////////////////////////////////////////\n  ///                   _depositorClaimRewards\n  /////////////////////////////////////////////////////////////////////\n  struct DepositorClaimRewardsParams {\n    address[] rewardTokens;\n    uint[] rewardAmounts;\n  }\n  DepositorClaimRewardsParams internal depositorClaimRewardsParams;\n\n  function _depositorClaimRewards() override internal virtual returns (\n    address[] memory rewardTokens,\n    uint[] memory rewardAmounts\n  ) {\n    uint len = depositorClaimRewardsParams.rewardTokens.length;\n    rewardTokens = new address[](len);\n    rewardAmounts = new uint[](len);\n\n    for (uint i = 0; i < len; ++i) {\n      IMockToken token = IMockToken(depositorClaimRewardsParams.rewardTokens[i]);\n      uint amount = depositorClaimRewardsParams.rewardAmounts[i];\n      token.mint(address(this), amount);\n\n      rewardTokens[i] = depositorClaimRewardsParams.rewardTokens[i];\n      rewardAmounts[i] = depositorClaimRewardsParams.rewardAmounts[i];\n    }\n    return (rewardTokens, rewardAmounts);\n  }\n\n  function setDepositorClaimRewards(address[] memory rewardTokens_, uint[] memory rewardAmounts_) external {\n    uint len = rewardTokens_.length;\n    depositorClaimRewardsParams.rewardTokens = new address[](len);\n    depositorClaimRewardsParams.rewardAmounts = new uint[](len);\n    for (uint i = 0; i < len; ++i) {\n      depositorClaimRewardsParams.rewardTokens[i] = rewardTokens_[i];\n      depositorClaimRewardsParams.rewardAmounts[i] = rewardAmounts_[i];\n    }\n  }\n}\n"
    },
    "contracts/test/MockForwarder.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\ncontract MockForwarder is IForwarder {\n  address[] private lastRegisterIncomeTokens;\n  uint[] private lastRegisterIncomeAmounts;\n\n  function tokenPerDestinationLength(address destination) external pure returns (uint) {\n    destination;\n    return 0;\n  }\n\n  function tokenPerDestinationAt(address destination, uint i) external pure returns (address) {\n    destination;\n    i;\n\n    return address(0);\n  }\n\n  function registerIncome(\n    address[] memory tokens,\n    uint[] memory amounts,\n    address vault,\n    bool isDistribute\n  ) external {\n    console.log(\"registerIncome\", gasleft());\n    lastRegisterIncomeTokens = tokens;\n    lastRegisterIncomeAmounts = amounts;\n    // move all tokens to the balance of the IForwarder\n    for (uint i = 0; i < tokens.length; ++i) {\n      IERC20(tokens[i]).transferFrom(msg.sender, address(this), amounts[i]);\n    }\n    vault;\n    isDistribute;\n    console.log(\"registerIncome.end\", gasleft());\n  }\n\n  function getLastRegisterIncomeResults() external view returns (\n    address[] memory tokens,\n    uint[] memory amounts\n  ) {\n    return (lastRegisterIncomeTokens, lastRegisterIncomeAmounts);\n  }\n\n  function distributeAll(address destination) external pure {\n    destination;\n  }\n\n  function distribute(address token) external pure {\n    token;\n  }\n\n  function setInvestFundRatio(uint value) external pure {\n    value;\n  }\n\n  function setGaugesRatio(uint value) external pure {\n    value;\n  }\n\n  function supportsInterface(bytes4) public pure returns (bool) {\n    return true;\n  }\n}"
    },
    "contracts/test/MockLiquidator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\n\ncontract MockLiquidator is ITetuLiquidator {\n\n  uint price = 100_000 * 1e18;\n  string error = \"\";\n  uint routeLength = 1;\n\n  function setPrice(uint value) external {\n    price = value;\n  }\n\n  function setError(string memory value) external {\n    error = value;\n  }\n\n  function setRouteLength(uint value) external {\n    routeLength = value;\n  }\n\n  function getPrice(address, address, uint) external view override returns (uint) {\n    return price;\n  }\n\n  function getPriceForRoute(PoolData[] memory, uint) external view override returns (uint) {\n    return price;\n  }\n\n  function isRouteExist(address, address) external pure override returns (bool) {\n    return true;\n  }\n\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view override returns (PoolData[] memory route, string memory errorMessage) {\n    if (routeLength == 1) {\n      route = new PoolData[](1);\n      route[0].tokenIn = tokenIn;\n      route[0].tokenOut = tokenOut;\n    } else {\n      route = new PoolData[](0);\n    }\n    return (route, error);\n  }\n\n  function liquidate(\n    address,\n    address tokenOut,\n    uint amount,\n    uint\n  ) external override {\n    IERC20(tokenOut).transfer(msg.sender, amount);\n  }\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint\n  ) external override {\n    IERC20(route[0].tokenIn).transferFrom(msg.sender, address(this), amount);\n    IERC20(route[route.length - 1].tokenOut).transfer(msg.sender, amount);\n  }\n\n  function addLargestPools(PoolData[] memory /*_pools*/, bool /*rewrite*/) external pure {\n    // noop\n  }\n\n  function addBlueChipsPools(PoolData[] memory /*_pools*/, bool /*rewrite*/) external pure {\n    // noop\n  }\n\n}\n"
    },
    "contracts/test/MockTetuConverter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../interfaces/converter/ITetuConverter.sol\";\nimport \"../interfaces/converter/ITetuConverterCallback.sol\";\nimport \"../interfaces/IERC20Extended.sol\";\nimport \"hardhat/console.sol\";\n\n/// @notice Mock of ITetuConverter, each function saves input params and has customizable output value\n///         Some functions can be not implemented\n/// @dev We assume, that in each test only single function is called, so we can setup behavior before the call\n///      and check results after the call on the side of the script\ncontract MockTetuConverter is ITetuConverter {\n  //////////////////////////////////////////////////////////\n  ///  Controller\n  //////////////////////////////////////////////////////////\n  address public _controller;\n  function controller() external view returns (address) {\n    return _controller;\n  }\n  function setController(address controller_) external {\n    _controller = controller_;\n  }\n\n\n  //////////////////////////////////////////////////////////\n  ///  findBorrowStrategy\n  //////////////////////////////////////////////////////////\n  struct FindBorrowStrategyOutputParams {\n    bytes entryData;\n    address[] converters;\n    uint[] collateralAmountsOut;\n    uint[] amountsToBorrowOut;\n    int[] aprs18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n    uint periodInBlocks;\n  }\n  /// @notice keccak256(entryData, sourceToken, targetToken) => results\n  mapping(bytes32 => FindBorrowStrategyOutputParams) public findBorrowStrategyOutputParams;\n  function findBorrowStrategies(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint amountIn_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address[] memory converters,\n    uint[] memory collateralAmountsOut,\n    uint[] memory amountsToBorrowOut,\n    int[] memory aprs18\n  ) {\n    periodInBlocks_;\n    console.log(\"MockTetuConverterSingleCall.findBorrowStrategy token,amountIn\", sourceToken_, amountIn_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindBorrowStrategyOutputParams memory p = findBorrowStrategyOutputParams[key];\n    if (sourceToken_ == p.sourceToken) {\n      return (\n        p.converters,\n        p.collateralAmountsOut,\n        p.amountsToBorrowOut,\n        p.aprs18\n      );\n    } else {\n      console.log(\"findBorrowStrategy.missed\", sourceToken_, amountIn_, targetToken_);\n      return (converters, collateralAmountsOut, amountsToBorrowOut, aprs18);\n    }\n  }\n  function setFindBorrowStrategyOutputParams(\n    bytes memory entryData_,\n    address[] memory converters_,\n    uint[] memory collateralAmountsOut_,\n    uint[] memory amountToBorrowsOut_,\n    int[] memory aprs18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external {\n    console.log(\"setFindBorrowStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    findBorrowStrategyOutputParams[key] = FindBorrowStrategyOutputParams({\n      entryData: entryData_,\n      converters: converters_,\n      collateralAmountsOut: collateralAmountsOut_,\n      amountsToBorrowOut: amountToBorrowsOut_,\n      aprs18: aprs18_,\n      sourceAmount: sourceAmount_,\n      sourceToken: sourceToken_,\n      targetToken: targetToken_,\n      periodInBlocks: periodInBlocks_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  findSwapStrategy\n  //////////////////////////////////////////////////////////\n  struct FindSwapStrategyOutputParams {\n    bytes entryData;\n    address converter;\n    uint sourceAmountOut;\n    uint targetAmountOut;\n    int apr18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n  }\n  /// @notice keccak256(entryData_, sourceToken, targetToken) => results\n  mapping(bytes32 => FindSwapStrategyOutputParams) public findSwapStrategyOutputParams;\n  function findSwapStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external view returns (\n    address converter,\n    uint sourceAmountOut,\n    uint targetAmountOut,\n    int apr18\n  ) {\n    console.log(\"MockTetuConverterSingleCall.findSwapStrategy token,amount\", sourceToken_, sourceAmount_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindSwapStrategyOutputParams memory p = findSwapStrategyOutputParams[key];\n    if (sourceToken_ == p.sourceToken) {\n      return (p.converter, p.sourceAmountOut, p.targetAmountOut, p.apr18);\n    } else {\n      console.log(\"findSwapStrategy.missed\", sourceToken_, sourceAmount_, targetToken_);\n      return (converter, sourceAmountOut, targetAmountOut, apr18);\n    }\n  }\n\n  function setFindSwapStrategyOutputParams(\n    bytes memory entryData_,\n    address converter_,\n    uint sourceAmountOut_,\n    uint targetAmountOut_,\n    int apr18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_\n  ) external {\n    console.log(\"setFindSwapStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(sourceToken_, targetToken_));\n    findSwapStrategyOutputParams[key] = FindSwapStrategyOutputParams({\n      entryData: entryData_,\n      converter: converter_,\n      sourceAmountOut: sourceAmountOut_,\n      targetAmountOut: targetAmountOut_,\n      apr18: apr18_,\n      sourceToken: sourceToken_,\n      sourceAmount: sourceAmount_,\n      targetToken: targetToken_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  findConversionStrategy\n  //////////////////////////////////////////////////////////\n  struct FindConversionStrategyOutputParams {\n    bytes entryData;\n    address converter;\n    uint amountToBorrowOut;\n    uint collateralAmountOut;\n    int apr18;\n\n    address sourceToken;\n    uint sourceAmount;\n    address targetToken;\n    uint periodInBlocks;\n  }\n  /// @notice keccak256(entryData, sourceToken, targetToken) => results\n  mapping(bytes32 => FindConversionStrategyOutputParams) public findConversionStrategyOutputParams;\n  function findConversionStrategy(\n    bytes memory entryData_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external view returns (\n    address converter,\n    uint collateralAmountOut,\n    uint amountToBorrowOut,\n    int apr18\n  ) {\n    periodInBlocks_;\n    console.log(\"MockTetuConverterSingleCall.findConversionStrategy token,amount\", sourceToken_, sourceAmount_);\n\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    FindConversionStrategyOutputParams memory p = findConversionStrategyOutputParams[key];\n    if (sourceToken_ == p.sourceToken) {\n      return (p.converter, p.collateralAmountOut, p.amountToBorrowOut, p.apr18);\n    } else {\n      console.log(\"findConversionStrategy.missed\", sourceToken_, sourceAmount_, targetToken_);\n      return (converter, collateralAmountOut, amountToBorrowOut, apr18);\n    }\n  }\n  function setFindConversionStrategyOutputParams(\n    bytes memory entryData_,\n    address converter_,\n    uint collateralAmountOut_,\n    uint amountToBorrowOut_,\n    int apr18_,\n    address sourceToken_,\n    uint sourceAmount_,\n    address targetToken_,\n    uint periodInBlocks_\n  ) external {\n    console.log(\"setFindConversionStrategyOutputParams\", sourceToken_, sourceAmount_, targetToken_);\n    bytes32 key = keccak256(abi.encodePacked(entryData_, sourceToken_, targetToken_));\n    findConversionStrategyOutputParams[key] = FindConversionStrategyOutputParams({\n      entryData: entryData_,\n      converter: converter_,\n      collateralAmountOut: collateralAmountOut_,\n      amountToBorrowOut: amountToBorrowOut_,\n      apr18: apr18_,\n      sourceAmount: sourceAmount_,\n      sourceToken: sourceToken_,\n      targetToken: targetToken_,\n      periodInBlocks: periodInBlocks_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  borrow\n  //////////////////////////////////////////////////////////\n  struct BorrowParams {\n    uint borrowedAmountOut;\n\n    address converter;\n    address collateralAsset;\n    uint collateralAmount;\n    address borrowAsset;\n    uint amountToBorrow;\n    address receiver;\n  }\n  /// @notice keccak256(converter_, collateralAsset_, collateralAmount_, borrowAsset_) => results\n  mapping(bytes32 => BorrowParams) public borrowParams;\n\n  function borrow(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_\n  ) external returns (\n    uint borrowedAmountOut\n  ) {\n    console.log(\"MockTetuConverterSingleCall.borrow token,amount\", collateralAsset_, collateralAmount_);\n    bytes32 key = keccak256(abi.encodePacked(converter_, collateralAsset_, collateralAmount_, borrowAsset_));\n    BorrowParams memory p = borrowParams[key];\n    if (converter_ == p.converter\n      && collateralAsset_ == p.collateralAsset\n      && collateralAmount_ == p.collateralAmount\n      && borrowAsset_ == p.borrowAsset\n    ) {\n      IERC20Extended(collateralAsset_).transferFrom(msg.sender, address(this), collateralAmount_);\n\n      uint balance = IERC20Extended(borrowAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverterSingleCall.borrow.balance, amountToBorrow_\", balance, amountToBorrow_);\n      require(balance >= amountToBorrow_, \"MockTetuConverterSingleCall.borrow.balance\");\n      IERC20Extended(borrowAsset_).transfer(receiver_, amountToBorrow_);\n\n      return p.borrowedAmountOut;\n    } else {\n      console.log(\"MockTetuConverterSingleCall.borrow.missed, amountToBorrow_\", collateralAsset_, collateralAmount_, borrowAsset_);\n      return 0;\n    }\n  }\n  function setBorrowParams(\n    address converter_,\n    address collateralAsset_,\n    uint collateralAmount_,\n    address borrowAsset_,\n    uint amountToBorrow_,\n    address receiver_,\n    uint borrowedAmountOut_\n  ) external {\n    console.log(\"setBorrowParams\", collateralAsset_, collateralAmount_, borrowAsset_);\n    bytes32 key = keccak256(abi.encodePacked(converter_, collateralAsset_, collateralAmount_, borrowAsset_));\n    borrowParams[key] = BorrowParams({\n      converter: converter_,\n      collateralAsset: collateralAsset_,\n      collateralAmount: collateralAmount_,\n      borrowAsset: borrowAsset_,\n      amountToBorrow: amountToBorrow_,\n      receiver: receiver_,\n      borrowedAmountOut: borrowedAmountOut_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  repay\n  //////////////////////////////////////////////////////////\n  struct RepayParams {\n    address collateralAsset;\n    address borrowAsset;\n    uint amountToRepay;\n    address receiver;\n    uint collateralAmountOut;\n    uint returnedBorrowAmountOut;\n    uint swappedLeftoverCollateralOut;\n    uint swappedLeftoverBorrowOut;\n  }\n  /// @notice keccak256(collateralAsset_, borrowAsset_, amountToRepay_) => results\n  mapping(bytes32 => RepayParams) public repayParams;\n\n  function repay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_\n  ) external returns (\n    uint collateralAmountOut,\n    uint returnedBorrowAmountOut,\n    uint swappedLeftoverCollateralOut,\n    uint swappedLeftoverBorrowOut\n  ) {\n    console.log(\"MockTetuConverterSingleCall.repay collateral,borrow,amount\", collateralAsset_, borrowAsset_, amountToRepay_);\n\n    require(IERC20Extended(borrowAsset_).balanceOf(address(this)) == amountToRepay_, \"MockTetuConverterSingleCall.repay.amountToRepay_\");\n\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    RepayParams memory p = repayParams[key];\n    if (collateralAsset_ == p.collateralAsset\n      && borrowAsset_ == p.borrowAsset\n      && amountToRepay_ == p.amountToRepay\n    ) {\n      // transfer collateral back to the strategy\n      uint balanceCollateral = IERC20Extended(collateralAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverterSingleCall.repay balanceCollateral, collateralAmountOut\", balanceCollateral, p.collateralAmountOut);\n      require(\n        balanceCollateral >= p.collateralAmountOut,\n        \"MockTetuConverterSingleCall.repay.collateralAmountOut\"\n      );\n      IERC20Extended(collateralAsset_).transfer(receiver_, p.collateralAmountOut);\n\n      // needToRepay was bigger than amountRepaid\n      // we need to return the leftover back to the strategy\n      uint balanceBorrow = IERC20Extended(borrowAsset_).balanceOf(address(this));\n      console.log(\"MockTetuConverterSingleCall.repay balanceBorrow, returnedBorrowAmountOut\", balanceBorrow, p.returnedBorrowAmountOut);\n      if (p.returnedBorrowAmountOut != 0) {\n        require(\n          balanceBorrow >= p.returnedBorrowAmountOut,\n          \"MockTetuConverterSingleCall.repay.returnedBorrowAmountOut\"\n        );\n        IERC20Extended(borrowAsset_).transfer(receiver_, p.returnedBorrowAmountOut);\n      }\n\n      return (\n        p.collateralAmountOut,\n        p.returnedBorrowAmountOut,\n        p.swappedLeftoverCollateralOut,\n        p.swappedLeftoverBorrowOut\n      );\n    } else {\n      console.log(\"MockTetuConverterSingleCall.repay.missed collateral,borrow,amountToRepay\", collateralAsset_, borrowAsset_, amountToRepay_);\n      return (collateralAmountOut, returnedBorrowAmountOut, swappedLeftoverCollateralOut, swappedLeftoverBorrowOut);\n    }\n  }\n\n  function setRepay(\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    address receiver_,\n    uint collateralAmountOut_,\n    uint returnedBorrowAmountOut_,\n    uint swappedLeftoverCollateralOut_,\n    uint swappedLeftoverBorrowOut_\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    repayParams[key] = RepayParams({\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      amountToRepay: amountToRepay_,\n      receiver: receiver_,\n      collateralAmountOut: collateralAmountOut_,\n      returnedBorrowAmountOut: returnedBorrowAmountOut_,\n      swappedLeftoverCollateralOut: swappedLeftoverCollateralOut_,\n      swappedLeftoverBorrowOut: swappedLeftoverBorrowOut_\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  quoteRepay\n  //////////////////////////////////////////////////////////\n  struct QuoteRepayParams {\n    address user;\n    address collateralAsset;\n    address borrowAsset;\n    uint amountToRepay;\n    uint collateralAmountOut;\n  }\n  /// @notice keccak256(collateralAsset_, borrowAsset_, amountToRepay_) => results\n  mapping(bytes32 => QuoteRepayParams) public quoteRepayParams;\n\n  function quoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_\n  ) external view returns (\n    uint collateralAmountOut\n  ) {\n    user_; // hide warning\n    console.log(\"MockTetuConverterSingleCall.quoteRepay collateral,borrow,amount\", collateralAsset_, borrowAsset_, amountToRepay_);\n\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    QuoteRepayParams memory p = quoteRepayParams[key];\n    if (p.collateralAsset == collateralAsset_) {\n      return p.collateralAmountOut;\n    } else {\n      console.log(\"MockTetuConverterSingleCall.quoteRepay.missed amountToRepay_,collateralAsset_,borrowAsset_\", amountToRepay_, collateralAsset_, borrowAsset_);\n      return 0;\n    }\n  }\n  function setQuoteRepay(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint amountToRepay_,\n    uint collateralAmountOut\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(collateralAsset_, borrowAsset_, amountToRepay_));\n    quoteRepayParams[key] = QuoteRepayParams({\n      user: user_,\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      amountToRepay: amountToRepay_,\n      collateralAmountOut: collateralAmountOut\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  getDebtAmountCurrent\n  //////////////////////////////////////////////////////////\n  struct GetDebtAmountParams {\n    address user;\n    address collateralAsset;\n    address borrowAsset;\n    uint totalDebtAmountOut;\n    uint totalCollateralAmountOut;\n  }\n\n  /// @notice keccak256(user_, collateralAsset_, borrowAsset_) => results\n  mapping(bytes32 => GetDebtAmountParams) public getDebtAmountCurrentParams;\n  function getDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) {\n    console.log(\"MockTetuConverterSingleCall.getDebtAmountCurrent user,collateral,borrow\", user_, collateralAsset_, borrowAsset_);\n\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_));\n    GetDebtAmountParams memory p = getDebtAmountCurrentParams[key];\n    if (\n      p.user == user_\n      && p.collateralAsset == collateralAsset_\n      && p.borrowAsset == borrowAsset_\n    ) {\n      console.log(\"MockTetuConverterSingleCall.getDebtAmountCurrent totalDebtAmountOut,totalCollateralAmountOut\",\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut\n      );\n      return (\n        p.totalDebtAmountOut,\n        p.totalCollateralAmountOut\n      );\n    } else {\n      console.log(\"MockTetuConverterSingleCall.getDebtAmountCurrent.missed user,collateral,borrow\", user_, collateralAsset_, borrowAsset_);\n      return (0, 0);\n    }\n  }\n  function setGetDebtAmountCurrent(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(user_, collateralAsset_, borrowAsset_));\n    getDebtAmountCurrentParams[key] = GetDebtAmountParams({\n      user: user_,\n      collateralAsset: collateralAsset_,\n      borrowAsset: borrowAsset_,\n      totalCollateralAmountOut: totalCollateralAmountOut,\n      totalDebtAmountOut: totalDebtAmountOut\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  getDebtAmountStored\n  //////////////////////////////////////////////////////////\n  GetDebtAmountParams public getDebtAmountStoredParams;\n  function getDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_\n  ) external view returns (\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) {\n    console.log(\"MockTetuConverterSingleCall.getDebtAmountStored user,collateral,borrow\", user_, collateralAsset_, borrowAsset_);\n\n    if (\n      getDebtAmountStoredParams.user == user_\n      && getDebtAmountStoredParams.collateralAsset == collateralAsset_\n      && getDebtAmountStoredParams.borrowAsset == borrowAsset_\n    ) {\n      return (\n        getDebtAmountStoredParams.totalDebtAmountOut,\n        getDebtAmountStoredParams.totalCollateralAmountOut\n      );\n    } else {\n      return (0, 0);\n    }\n  }\n  function setGetDebtAmountStored(\n    address user_,\n    address collateralAsset_,\n    address borrowAsset_,\n    uint totalDebtAmountOut,\n    uint totalCollateralAmountOut\n  ) external {\n    getDebtAmountStoredParams.user = user_;\n    getDebtAmountStoredParams.collateralAsset = collateralAsset_;\n    getDebtAmountStoredParams.borrowAsset = borrowAsset_;\n    getDebtAmountStoredParams.totalCollateralAmountOut = totalCollateralAmountOut;\n    getDebtAmountStoredParams.totalDebtAmountOut = totalDebtAmountOut;\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  estimateRepay\n  //////////////////////////////////////////////////////////\n  function estimateRepay(\n    address user_,\n    address collateralAsset_,\n    uint collateralAmountRequired_,\n    address borrowAsset_\n  ) external pure returns (\n    uint borrowAssetAmount,\n    uint unobtainableCollateralAssetAmount\n  ) {\n    user_;\n    collateralAsset_;\n    collateralAmountRequired_;\n    borrowAsset_;\n    borrowAssetAmount;\n    unobtainableCollateralAssetAmount;\n    revert (\"estimateRepay is not implemented\");\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  claimRewards\n  //////////////////////////////////////////////////////////\n  struct ClaimRewardsParams {\n    address[] rewardTokensOut;\n    uint[] amountsOut;\n  }\n  ClaimRewardsParams private claimRewardsParams;\n\n  function claimRewards(address receiver_) external returns (\n    address[] memory rewardTokensOut,\n    uint[] memory amountsOut\n  ) {\n    for (uint i = 0; i < claimRewardsParams.rewardTokensOut.length; ++i) {\n      uint balance = IERC20Extended(claimRewardsParams.rewardTokensOut[i]).balanceOf(address(this));\n      console.log(\"claimRewards asset, balance, amountOut\", claimRewardsParams.rewardTokensOut[i], balance, claimRewardsParams.amountsOut[i]);\n      IERC20Extended(claimRewardsParams.rewardTokensOut[i]).transfer(receiver_, claimRewardsParams.amountsOut[i]);\n    }\n    return (claimRewardsParams.rewardTokensOut, claimRewardsParams.amountsOut);\n  }\n\n  function setClaimRewards(address[] memory rewardTokensOut, uint[] memory amountsOut) external {\n    claimRewardsParams = ClaimRewardsParams({\n      rewardTokensOut: rewardTokensOut,\n      amountsOut: amountsOut\n    });\n  }\n\n  //////////////////////////////////////////////////////////\n  ///  Safe liquidation\n  //////////////////////////////////////////////////////////\n  function safeLiquidate(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    address receiver_,\n    uint priceImpactToleranceSource_,\n    uint priceImpactToleranceTarget_\n  ) external pure returns (\n    uint amountOut\n  ) {\n    assetIn_;\n    amountIn_;\n    assetOut_;\n    receiver_;\n    priceImpactToleranceSource_;\n    priceImpactToleranceTarget_;\n    amountOut;\n    revert(\"safeLiquidate is not implemented\");\n  }\n\n  struct IsConversionValidParams {\n    address assetIn;\n    uint amountIn;\n    address assetOut;\n    uint amountOut;\n    bool result;\n  }\n  /// @notice keccak256(assetIn_, amountIn_, assetOut_, amountOut_) => results\n  mapping(bytes32 => IsConversionValidParams) public isConversionValidParams;\n  function isConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    uint priceImpactTolerance_\n  ) external view returns (bool) {\n    bytes32 key = keccak256(abi.encodePacked(assetIn_, amountIn_, assetOut_, amountOut_));\n    priceImpactTolerance_;\n    IsConversionValidParams memory p = isConversionValidParams[key];\n    if (p.assetIn == assetIn_) {\n      return p.result;\n    } else {\n      console.log(\"isConversionValid assetIn\", assetIn_, amountIn_);\n      console.log(\"isConversionValid assetOut\", assetOut_, amountOut_);\n      revert(\"isConversionValid is missed\");\n    }\n  }\n  function setIsConversionValid(\n    address assetIn_,\n    uint amountIn_,\n    address assetOut_,\n    uint amountOut_,\n    bool result_\n  ) external {\n    console.log(\"setIsConversionValid assetIn\", assetIn_, amountIn_);\n    console.log(\"setIsConversionValid assetOut\", assetOut_, amountOut_);\n    bytes32 key = keccak256(abi.encodePacked(assetIn_, amountIn_, assetOut_, amountOut_));\n    isConversionValidParams[key] = IsConversionValidParams({\n      assetIn: assetIn_,\n      amountIn: amountIn_,\n      assetOut: assetOut_,\n      amountOut: amountOut_,\n      result: result_\n    });\n  }\n}"
    },
    "contracts/test/MockTetuConverterController.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\ncontract MockTetuConverterController {\n  address public priceOracle;\n  constructor(address priceOracle_) {\n     priceOracle = priceOracle_;\n  }\n}"
    },
    "contracts/test/MockTetuLiquidatorSingleCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"hardhat/console.sol\";\n\n/// @notice Mock of ITetuLiquidator, each function saves input params and has customizable output value\n///         Some functions can be not implemented\n/// @dev We assume, that in each test only single function is called, so we can setup behavior before the call\n///      and check results after the call on the side of the script\ncontract MockTetuLiquidatorSingleCall is ITetuLiquidator {\n\n\n  ///////////////////////////////////////////////////\n  ///               build route\n  ///////////////////////////////////////////////////\n  struct BuildRouteParams {\n    address tokenIn;\n    address tokenOut;\n    address pool;\n    address swapper;\n    string errorMessage;\n  }\n  /// @notice keccak256(tokenIn, tokenOut) => results\n  mapping(bytes32 => BuildRouteParams) public buildRouteParams;\n  function buildRoute(\n    address tokenIn,\n    address tokenOut\n  ) external view override returns (\n    PoolData[] memory route,\n    string memory errorMessage\n  ) {\n    console.log(\"MockTetuLiquidatorSingleCall.buildRoute\", tokenIn, tokenOut);\n    bytes32 key = keccak256(abi.encodePacked(tokenIn, tokenOut));\n    BuildRouteParams memory p = buildRouteParams[key];\n\n    if (bytes(p.errorMessage).length != 0) {\n      console.log(\"MockTetuLiquidatorSingleCall.buildRoute.error\");\n      return (route, p.errorMessage);\n    } else {\n      if (tokenIn == p.tokenIn && tokenOut == p.tokenOut) {\n        route = new PoolData[](1);\n        route[0].tokenIn = p.tokenIn;\n        route[0].tokenOut = p.tokenOut;\n        route[0].pool = p.pool;\n        route[0].swapper = p.swapper;\n        return (route, errorMessage);\n      } else {\n        console.log(\"MockTetuLiquidatorSingleCall.buildRoute.error.not.found\", tokenIn, tokenOut);\n        return (route, \"route not found\");\n      }\n    }\n  }\n  function setBuildRoute(\n    address tokenIn,\n    address tokenOut,\n    address pool,\n    address swapper,\n    string memory errorMessage\n  ) external {\n    console.log(\"setBuildRoute\", tokenIn, tokenOut);\n    bytes32 key = keccak256(abi.encodePacked(tokenIn, tokenOut));\n    buildRouteParams[key] = BuildRouteParams({\n      errorMessage: errorMessage,\n      tokenIn: tokenIn,\n      tokenOut: tokenOut,\n      pool: pool,\n      swapper: swapper\n    });\n  }\n\n  ///////////////////////////////////////////////////\n  ///               Get price for route\n  ///////////////////////////////////////////////////\n  struct GetPriceForRouteParams {\n    address tokenIn;\n    address tokenOut;\n    address pool;\n    address swapper;\n    uint amount;\n    uint priceOut;\n  }\n  /// @notice keccak256(tokenIn, tokenOut, pool, swapper, amount) => results\n  mapping(bytes32 => GetPriceForRouteParams) public getPriceForRouteParams;\n\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view override returns (uint) {\n    //console.log(\"MockTetuLiquidatorSingleCall.getPriceForRoute amount route.length\", amount, route.length);\n    //console.log(\"MockTetuLiquidatorSingleCall.getPriceForRoute tokenIn, tokenOut\", route[0].tokenIn, route[0].tokenOut);\n    //console.log(\"MockTetuLiquidatorSingleCall.getPriceForRoute pool, swapper\", route[0].pool, route[0].swapper);\n\n    bytes32 key = keccak256(abi.encodePacked(route[0].tokenIn, route[0].tokenOut, route[0].pool, route[0].swapper, amount));\n    GetPriceForRouteParams memory p = getPriceForRouteParams[key];\n\n    if (route.length == 1 && route[0].tokenOut == p.tokenOut) {\n      //console.log(\"MockTetuLiquidatorSingleCall.getPriceForRoute.data\");\n      return p.priceOut;\n    } else {\n      console.log(\"MockTetuLiquidatorSingleCall.getPriceForRoute.missed amount\", amount);\n      return 0;\n    }\n  }\n  function setGetPriceForRoute(\n    address tokenIn,\n    address tokenOut,\n    address pool,\n    address swapper,\n    uint amount,\n    uint priceOut\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(tokenIn, tokenOut, pool, swapper, amount));\n    getPriceForRouteParams[key] = GetPriceForRouteParams({\n      tokenIn: tokenIn,\n      tokenOut: tokenOut,\n      pool: pool,\n      swapper: swapper,\n      amount: amount,\n      priceOut: priceOut\n    });\n  }\n\n  ///////////////////////////////////////////////////\n  ///               liquidateWithRoute\n  ///////////////////////////////////////////////////\n  struct LiquidateWithRouteParams {\n    address tokenIn;\n    address tokenOut;\n    address pool;\n    address swapper;\n    uint amount;\n    uint slippage;\n    uint amountOut;\n  }\n  /// @notice keccak256(tokenIn, tokenOut, pool, swapper, amount) => results\n  mapping(bytes32 => LiquidateWithRouteParams) public liquidateWithRouteParams;\n\n  function liquidateWithRoute(\n    PoolData[] memory route,\n    uint amount,\n    uint /*slippage*/\n  ) external override {\n    //console.log(\"MockTetuLiquidatorSingleCall.liquidateWithRoute\");\n\n    bytes32 key = keccak256(abi.encodePacked(route[0].tokenIn, route[0].tokenOut, route[0].pool, route[0].swapper, amount));\n    LiquidateWithRouteParams memory p = liquidateWithRouteParams[key];\n\n    if (route.length == 1 && route[0].tokenOut == p.tokenOut) {\n      console.log(\"MockTetuLiquidatorSingleCall.liquidateWithRoute.data.1 balanceIn amount\", IERC20(route[0].tokenIn).balanceOf(msg.sender), amount);\n      IERC20(route[0].tokenIn).transferFrom(msg.sender, address(this), amount);\n\n      console.log(\"MockTetuLiquidatorSingleCall.liquidateWithRoute.data.2 balanceOut amount\", IERC20(route[0].tokenOut).balanceOf(address(this)), p.amountOut);\n      IERC20(route[0].tokenOut).transfer(msg.sender, p.amountOut);\n\n    } else {\n      console.log(\"MockTetuLiquidatorSingleCall.liquidateWithRoute.missed\");\n    }\n  }\n  function setLiquidateWithRoute(\n    address tokenIn,\n    address tokenOut,\n    address pool,\n    address swapper,\n    uint amount,\n    uint amountOut\n  ) external {\n    bytes32 key = keccak256(abi.encodePacked(tokenIn, tokenOut, pool, swapper, amount));\n    liquidateWithRouteParams[key] = LiquidateWithRouteParams({\n      tokenIn: tokenIn,\n      tokenOut: tokenOut,\n      pool: pool,\n      swapper: swapper,\n      amount: amount,\n      slippage: 0,\n      amountOut: amountOut\n    });\n  }\n\n  ///////////////////////////////////////////////////\n  ///               Get price\n  ///////////////////////////////////////////////////\n  function getPrice(address tokenIn, address tokenOut, uint amount) external pure override returns (uint) {\n    tokenIn;\n    tokenOut;\n    amount;\n    revert(\"get Price is not implemented\");\n  }\n\n  ///////////////////////////////////////////////////\n  ///               liquidate\n  ///////////////////////////////////////////////////\n  function liquidate(\n    address tokenIn,\n    address tokenOut,\n    uint amount,\n    uint slippage\n  ) external override {\n    tokenIn;\n    tokenOut;\n    slippage;\n    IERC20(tokenOut).transfer(msg.sender, amount);\n    revert(\"liquidate is not implemented\");\n  }\n\n  ///////////////////////////////////////////////////\n  ///               Is route exists\n  ///////////////////////////////////////////////////\n  function isRouteExist(address tokenIn, address tokenOut) external pure override returns (bool) {\n    tokenIn;\n    tokenOut;\n    revert(\"isRouteExist is not implemented\");\n  }\n\n  ///////////////////////////////////////////////////\n  ///               addLargestPools\n  ///////////////////////////////////////////////////\n  function addLargestPools(PoolData[] memory /*_pools*/, bool /*rewrite*/) external pure {\n    // noop\n    revert(\"addLargestPools is not implemented\");\n  }\n\n  ///////////////////////////////////////////////////\n  ///               addBlueChipsPools\n  ///////////////////////////////////////////////////\n  function addBlueChipsPools(PoolData[] memory /*_pools*/, bool /*rewrite*/) external pure {\n    // noop\n    revert(\"addBlueChipsPools is not implemented\");\n  }\n\n}\n"
    },
    "contracts/test/PriceOracleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\nimport \"../interfaces/converter/IPriceOracle.sol\";\nimport \"hardhat/console.sol\";\n\ncontract PriceOracleMock is IPriceOracle {\n  /// how much 1 token costs in USD, decimals 18\n  mapping(address => uint256) public prices;\n\n  constructor(address[] memory assets, uint[] memory pricesInUSD) {\n    _changePrices(assets, pricesInUSD);\n  }\n  ///////////////////////////////////////////////////////\n  ///           Set up\n  ///////////////////////////////////////////////////////\n  function changePrices(address[] memory assets, uint[] memory pricesInUSD) external {\n    _changePrices(assets, pricesInUSD);\n  }\n\n  function _changePrices(address[] memory assets, uint[] memory pricesInUSD) internal {\n    require(assets.length == pricesInUSD.length, \"wrong lengths\");\n    for (uint i = 0; i < assets.length; ++i) {\n      prices[assets[i]] = pricesInUSD[i];\n      console.log(\"Price for %d is %d USD\", assets[i], pricesInUSD[i]);\n    }\n  }\n\n  ///////////////////////////////////////////////////////\n  ///           IPriceOracle\n  ///////////////////////////////////////////////////////\n\n  /// @notice Return asset price in USD, decimals 18\n  function getAssetPrice(address asset) external view override returns (uint256) {\n    console.log(\"PriceOracleMock.getAssetPrice\", asset, prices[asset]);\n    return prices[asset];\n  }\n}\n"
    },
    "contracts/test/TokenAmountsLibTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../tools/TokenAmountsLib.sol\";\n\n/// @author bogdoslav\ncontract TokenAmountsLibTest {\n\n    function filterZeroAmounts(\n        address[] memory tokens,\n        uint[] memory amounts\n    ) external pure returns (\n        address[] memory t,\n        uint[] memory a\n    ) {\n        return TokenAmountsLib.filterZeroAmounts(tokens, amounts);\n    }\n\n    /// @dev unites tokens2 and amounts2 in to tokens & amounts\n    function unite(\n        address[] memory tokens1,\n        uint[] memory amounts1,\n        address[] memory tokens2,\n        uint[] memory amounts2\n    ) external pure returns (\n        address[] memory allTokens,\n        uint[] memory allAmounts\n    ) {\n        return TokenAmountsLib.unite(tokens1, amounts1, tokens2, amounts2);\n    }\n\n    /// @dev prints tokens & amounts\n    function print(\n        address[] memory tokens,\n        uint[] memory amounts\n    ) external view {\n        TokenAmountsLib.print(\"test\", tokens, amounts);\n    }\n\n}\n"
    },
    "contracts/tools/AppErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\n/// @notice List of all errors generated by the application\n///         Each error should have unique code TS-XXX and descriptive comment\nlibrary AppErrors {\n  /// @notice Provided address should be not zero\n  string public constant ZERO_ADDRESS = \"TS-1 zero address\";\n\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\n  string public constant UNISWAP_PAIR_NOT_FOUND = \"TS-2 pair not found\";\n\n  /// @notice Lengths not matched\n  string public constant WRONG_LENGTHS = \"TS-4 wrong lengths\";\n\n  /// @notice Unexpected zero balance\n  string public constant ZERO_BALANCE = \"TS-5 zero balance\";\n\n  string public constant ITEM_NOT_FOUND = \"TS-6 not found\";\n\n  string public constant NOT_ENOUGH_BALANCE = \"TS-7 not enough balance\";\n\n  /// @notice Price oracle returns zero price\n  string public constant ZERO_PRICE = \"TS-8 zero price\";\n\n  string public constant WRONG_VALUE = \"TS-9 wrong value\";\n\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\n  string public constant ZERO_AMOUNT_BORROWED = \"TS-10 zero borrowed amount\";\n\n  string public constant WITHDRAW_TOO_MUCH  = \"TS-11 try to withdraw too much\";\n\n  string public constant UNKNOWN_ENTRY_KIND = \"TS-12 unknown entry kind\";\n\n  string public constant ONLY_TETU_CONVERTER = \"TS-13 only TetuConverter\";\n\n  string public constant WRONG_ASSET = \"TS-14 wrong asset\";\n\n  string public constant NO_LIQUIDATION_ROUTE = \"TS-15 No liquidation route\";\n\n  string public constant PRICE_IMPACT = \"TS-16 price impact\";\n\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\n  string public constant REPAY_MAKES_SWAP = \"TS-17 can not convert back\";\n\n  string public constant NO_INVESTMENTS = \"TS-18 no investments\";\n}"
    },
    "contracts/tools/AppLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\n/// @notice Common internal utils\nlibrary AppLib {\n  using SafeERC20 for IERC20;\n\n  /// @notice Unchecked increment for for-cycles\n  function uncheckedInc(uint i) internal pure returns (uint) {\n    unchecked {\n      return i + 1;\n    }\n  }\n\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\n  /// @dev Should NOT be used for third-party pools\n  function approveIfNeeded(address token, uint amount, address spender) internal {\n    if (IERC20(token).allowance(address(this), spender) < amount) {\n      IERC20(token).safeApprove(spender, 0);\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\n      IERC20(token).safeApprove(spender, 2**255);\n    }\n  }\n}"
    },
    "contracts/tools/ERC20Helpers.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\";\n\n/// @title Contract with helper functions.\n/// @author bogdoslav\ncontract ERC20Helpers {\n  using SafeERC20 for IERC20;\n\n  function _balance(address token) internal view returns (uint) {\n    return IERC20(token).balanceOf(address(this));\n  }\n\n  /// @notice Should be used for third-party pools\n  function _safeApprove(address token, uint amount, address spender) internal {\n    IERC20(token).safeApprove(spender, 0);\n    IERC20(token).safeApprove(spender, amount);\n  }\n}\n"
    },
    "contracts/tools/TokenAmountsLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"hardhat/console.sol\";\n\npragma solidity 0.8.17;\n\n/// @title Library for clearing / joining token addresses & amounts arrays\n/// @author bogdoslav\nlibrary TokenAmountsLib {\n\n    function uncheckedInc(uint i) internal pure returns (uint) {\n        unchecked {\n            return i + 1;\n        }\n    }\n\n    /// @notice Version of the contract\n    /// @dev Should be incremented when contract changed\n    string internal constant TOKEN_AMOUNTS_LIB_VERSION = \"1.0.0\";\n\n    function filterZeroAmounts(\n        address[] memory tokens,\n        uint[] memory amounts\n    ) internal pure returns (\n        address[] memory t,\n        uint[] memory a\n    ) {\n        require (tokens.length == amounts.length, 'TAL: Arrays mismatch');\n        uint len2 = 0;\n        uint len = tokens.length;\n        for (uint i = 0; i < len; i++) {\n            if (amounts[i] != 0) len2++;\n        }\n\n        t = new address[](len2);\n        a = new uint[](len2);\n\n        uint j = 0;\n        for (uint i = 0; i < len; i++) {\n            uint amount = amounts[i];\n            if (amount != 0) {\n                t[j] = tokens[i];\n                a[j] = amount;\n                j++;\n            }\n        }\n    }\n\n    /// @dev unites tokens2 and amounts2 in to tokens & amounts\n    /// @notice zero amount tokens will be filtered!\n    function unite(\n        address[] memory tokens1,\n        uint[] memory amounts1,\n        address[] memory tokens2,\n        uint[] memory amounts2\n    ) internal pure returns (\n        address[] memory allTokens,\n        uint[] memory allAmounts\n    ) {\n        uint tokens1Length = tokens1.length;\n        uint tokens2Length = tokens2.length;\n\n        require(tokens1Length == amounts1.length && tokens2Length == amounts2.length, 'TAL: Arrays mismatch');\n\n        uint maxLength = tokens1Length + tokens2Length;\n        address[] memory tokens = new address[](maxLength);\n        uint[] memory amounts = new uint[](maxLength);\n\n        uint unitedLength = 0;\n\n        // join tokens1\n        for (uint i1 = 0; i1 < tokens1Length; i1++) {\n\n            uint amount1 = amounts1[i1];\n            if (amount1 == 0) continue;\n            address token1 = tokens1[i1];\n            bool united = false;\n\n            for (uint i = 0; i < unitedLength; i++) {\n                if (token1 == tokens[i]) {\n                    amounts[i] += amount1;\n                    united = true;\n                    break;\n                }\n            }\n            if (!united) {\n                tokens[unitedLength] = token1;\n                amounts[unitedLength] = amount1;\n                unitedLength++;\n            }\n        }\n\n        // join tokens2\n        for (uint i2 = 0; i2 < tokens2Length; i2++) {\n\n            uint amount2 = amounts2[i2];\n            if (amount2 == 0) continue;\n            address token2 = tokens2[i2];\n            bool united = false;\n\n            for (uint i = 0; i < unitedLength; i++) {\n                if (token2 == tokens[i]) {\n                    amounts[i] += amount2;\n                    united = true;\n                    break;\n                }\n            }\n            if (!united) {\n                tokens[unitedLength] = token2;\n                amounts[unitedLength] = amount2;\n                unitedLength++;\n            }\n        }\n\n        // copy united tokens to result array\n        allTokens = new address[](unitedLength);\n        allAmounts = new uint[](unitedLength);\n        for (uint i; i < unitedLength; i++) {\n            allTokens[i] = tokens[i];\n            allAmounts[i] = amounts[i];\n        }\n\n    }\n\n    /// @dev prints tokens & amounts\n    function print(\n        string memory header_,\n        address[] memory tokens,\n        uint[] memory amounts\n    ) internal view {\n        require (tokens.length == amounts.length, 'TAL: Arrays mismatch');\n        uint len = tokens.length;\n        if (len == 0) {\n            console.log('-[EMPTY ARRAY]-');\n            return;\n        }\n        console.log(header_);\n        console.log('---------------');\n\n        for (uint i = 0; i < len; i++) {\n            address token = tokens[i];\n            if (token == address(0)) {\n                console.log('addr(0)\\t', amounts[i]);\n            } else {\n                uint size;\n                assembly {\n                    size := extcodesize(token)\n                }\n\n                if (size == 0) {\n                    console.log('!code\\t', amounts[i], token);\n\n                } else {\n\n                    bool symbolFound = false;\n                    try IERC20Metadata(token).symbol() returns (string memory symbol) {\n                        console.log(symbol, '\\t', amounts[i]);\n                        symbolFound = true;\n                    } catch {\n                    }\n                    if (!symbolFound) {\n                        console.log('!symbol\\t', amounts[i], token);\n                    }\n                }\n\n            }\n        }\n        console.log('---------------\\n');\n\n    }\n\n    /// @notice Print tokens and tokens balances of the {strategy_}\n    function printBalances(\n        string memory header_,\n        address[] memory tokens_,\n        address strategy_\n    ) internal view {\n        uint len = tokens_.length;\n        uint[] memory tokenAmounts = new uint[](len);\n        for (uint i = 0; i < len; ++i) {\n            tokenAmounts[i] = IERC20(tokens_[i]).balanceOf(strategy_);\n        }\n        TokenAmountsLib.print(header_, tokens_, tokenAmounts);\n\n    }\n}\n"
    },
    "contracts/tools/Typechain.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.8.17;\n\n// import contracts here from node_moules to include it in to typechain\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockToken.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/proxy/ProxyControlled.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/Multicall.sol\";\n\n// for hardhat chain quick tests\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/ControllerMinimal.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockGauge.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockStrategy.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockStrategySimple.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/test/MockSplitter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/TetuVaultV2.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/VaultInsurance.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/StrategySplitterV2.sol\";\n\n// for TokenUtils / Tests\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeTetu.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IPlatformVoter.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVeDistributor.sol\";\n\n//\nimport \"@tetu_io/tetu-contracts-v2/contracts/vault/VaultFactory.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/infrastructure/ForwarderV3.sol\";\nimport \"@tetu_io/tetu-contracts-v2/contracts/infrastructure/ControllerV2.sol\";\n\n\ncontract ___typechain___ {}\n"
    },
    "contracts/tools/Uniswap2Lib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.17;\n\nimport \"../integrations/uniswap/IUniswapV2Router02.sol\";\nimport \"../integrations/uniswap/IUniswapV2Factory.sol\";\nimport \"../integrations/uniswap/IUniswapV2Pair.sol\";\n\nimport \"hardhat/console.sol\";\n\n/// @notice Helper utils for Uniswap2\nlibrary Uniswap2Lib {\n\n  /// @notice What amounts of tokens A an B we will receive if we call removeLiquidity(liquidity_)\n  /// @dev The implementation is made on the base of DystRouter01.quoteRemoveLiquidity\n  function quoteRemoveLiquidity(\n    IUniswapV2Router02 router_,\n    address /*user_*/,\n    address tokenA_,\n    address tokenB_,\n    uint liquidity_\n  ) internal view returns(\n    uint amountAOut,\n    uint amountBOut\n  ) {\n    console.log(\"quoteRemoveLiquidity\", liquidity_);\n    IUniswapV2Pair pair = IUniswapV2Pair(IUniswapV2Factory(router_.factory()).getPair(tokenA_, tokenB_));\n\n    if (address(pair) == address(0)) {\n      return (0, 0);\n    }\n    console.log(\"quoteRemoveLiquidity.pair\", address(pair));\n\n    (uint reserve0, uint reserve1,) = pair.getReserves();\n    (uint reserveA, uint reserveB) = tokenA_ == pair.token0()\n      ? (reserve0, reserve1)\n      : (reserve1, reserve0);\n\n    console.log(\"quoteRemoveLiquidity.reserves\", reserveA, reserveB);\n\n    uint totalSupply = pair.totalSupply();\n    console.log(\"quoteRemoveLiquidity.totalSupply\", totalSupply);\n    // using balances ensures pro-rata distribution\n    amountAOut = liquidity_ * reserveA / totalSupply;\n    // using balances ensures pro-rata distribution\n    amountBOut = liquidity_ * reserveB / totalSupply;\n    console.log(\"quoteRemoveLiquidity.amountAOut, amountBOut\", amountAOut, amountBOut);\n  }\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 150
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}