{
  "address": "0x421AbA1614Fc2D6C02610DBa96Ff93e8243bb001",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        },
        {
          "internalType": "int24",
          "name": "lowerTick_",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick_",
          "type": "int24"
        },
        {
          "internalType": "uint256",
          "name": "amount0Desired_",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1Desired_",
          "type": "uint256"
        }
      ],
      "name": "addLiquidityPreview",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount0Consumed",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1Consumed",
          "type": "uint256"
        },
        {
          "internalType": "uint128",
          "name": "liquidityOut",
          "type": "uint128"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtRatioX96",
          "type": "uint160"
        },
        {
          "internalType": "int24",
          "name": "lowerTick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick",
          "type": "int24"
        },
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "name": "getAmountsForLiquidity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amount0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint160",
          "name": "sqrtRatioX96",
          "type": "uint160"
        },
        {
          "internalType": "int24",
          "name": "lowerTick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick",
          "type": "int24"
        },
        {
          "internalType": "uint256",
          "name": "amount0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "amount1",
          "type": "uint256"
        }
      ],
      "name": "getLiquidityForAmounts",
      "outputs": [
        {
          "internalType": "uint128",
          "name": "liquidity",
          "type": "uint128"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IPool",
          "name": "pool",
          "type": "IPool"
        },
        {
          "internalType": "int24",
          "name": "tickLower",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "tickUpper",
          "type": "int24"
        }
      ],
      "name": "getPreviousTicks",
      "outputs": [
        {
          "internalType": "int24[2]",
          "name": "ticks",
          "type": "int24[2]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        }
      ],
      "name": "getPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IPool",
          "name": "pool",
          "type": "IPool"
        }
      ],
      "name": "getTickSpacing",
      "outputs": [
        {
          "internalType": "int24",
          "name": "",
          "type": "int24"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "a",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "b",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "denominator",
          "type": "uint256"
        }
      ],
      "name": "mulDiv",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "result",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x3465a5518dd044131454a7dc97593b0bcd8602f47fb6ef71e8f269e91a48ad7e",
  "receipt": {
    "to": null,
    "from": "0xF1dCce3a6c321176C62b71c091E3165CC9C3816E",
    "contractAddress": "0x421AbA1614Fc2D6C02610DBa96Ff93e8243bb001",
    "transactionIndex": 16,
    "gasUsed": "1379375",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000040000000000000000000000000000000080000000004100000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000000000000100000000000000000000000000000280000000000100000",
    "blockHash": "0x0e7a955fd91b143d9250d62d1c1951935cda925eeeb0b53c5d17825e0c050e37",
    "transactionHash": "0x3465a5518dd044131454a7dc97593b0bcd8602f47fb6ef71e8f269e91a48ad7e",
    "logs": [
      {
        "transactionIndex": 16,
        "blockNumber": 50652769,
        "transactionHash": "0x3465a5518dd044131454a7dc97593b0bcd8602f47fb6ef71e8f269e91a48ad7e",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000f1dcce3a6c321176c62b71c091e3165cc9c3816e",
          "0x000000000000000000000000b9ede6f94d192073d8eaf85f8db677133d483249"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000f506b6745a4c00000000000000000000000000000000000000000000000000bf10cd4e8f896cd10000000000000000000000000000000000000000000000062a637bfc7c4d11d4000000000000000000000000000000000000000000000000be1bc6981b2f20d10000000000000000000000000000000000000000000000062b5882b2f0a75dd4",
        "logIndex": 71,
        "blockHash": "0x0e7a955fd91b143d9250d62d1c1951935cda925eeeb0b53c5d17825e0c050e37"
      }
    ],
    "blockNumber": 50652769,
    "cumulativeGasUsed": "2547632",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 5,
  "solcInputHash": "beebd18f82b76c6876687623c23a6793",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"lowerTick_\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick_\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"amount0Desired_\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Desired_\",\"type\":\"uint256\"}],\"name\":\"addLiquidityPreview\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0Consumed\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1Consumed\",\"type\":\"uint256\"},{\"internalType\":\"uint128\",\"name\":\"liquidityOut\",\"type\":\"uint128\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtRatioX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"},{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"name\":\"getAmountsForLiquidity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint160\",\"name\":\"sqrtRatioX96\",\"type\":\"uint160\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"},{\"internalType\":\"uint256\",\"name\":\"amount0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"amount1\",\"type\":\"uint256\"}],\"name\":\"getLiquidityForAmounts\",\"outputs\":[{\"internalType\":\"uint128\",\"name\":\"liquidity\",\"type\":\"uint128\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"IPool\"},{\"internalType\":\"int24\",\"name\":\"tickLower\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"tickUpper\",\"type\":\"int24\"}],\"name\":\"getPreviousTicks\",\"outputs\":[{\"internalType\":\"int24[2]\",\"name\":\"ticks\",\"type\":\"int24[2]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"}],\"name\":\"getPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IPool\",\"name\":\"pool\",\"type\":\"IPool\"}],\"name\":\"getTickSpacing\",\"outputs\":[{\"internalType\":\"int24\",\"name\":\"\",\"type\":\"int24\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"a\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"b\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"denominator\",\"type\":\"uint256\"}],\"name\":\"mulDiv\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"result\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"getPrice(address,address)\":{\"returns\":{\"_0\":\"price with decimals of paired token\"}},\"mulDiv(uint256,uint256,uint256)\":{\"details\":\"Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\",\"params\":{\"a\":\"The multiplicand\",\"b\":\"The multiplier\",\"denominator\":\"The divisor\"},\"returns\":{\"result\":\"The 256-bit result\"}}},\"stateVariables\":{\"MAX_SQRT_RATIO\":{\"details\":\"The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\"},\"MAX_TICK\":{\"details\":\"The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\"},\"MIN_SQRT_RATIO\":{\"details\":\"The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\"},\"MIN_TICK\":{\"details\":\"The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\"}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getAmountsForLiquidity(uint160,int24,int24,uint128)\":{\"notice\":\"Computes the token0 and token1 value for a given amount of liquidity, the current pool prices and the prices at the tick boundaries\"},\"getLiquidityForAmounts(uint160,int24,int24,uint256,uint256)\":{\"notice\":\"Computes the maximum amount of liquidity received for a given amount of token0, token1, the current pool prices and the prices at the tick boundaries\"},\"getPrice(address,address)\":{\"notice\":\"Calculates price in pool\"},\"mulDiv(uint256,uint256,uint256)\":{\"notice\":\"Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/kyber/KyberLib.sol\":\"KyberLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/IERC721.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC721/IERC721.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../../utils/introspection/IERC165.sol\\\";\\n\\n/**\\n * @dev Required interface of an ERC721 compliant contract.\\n */\\ninterface IERC721 is IERC165 {\\n    /**\\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\\n     */\\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\\n\\n    /**\\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\\n     */\\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\\n\\n    /**\\n     * @dev Returns the number of tokens in ``owner``'s account.\\n     */\\n    function balanceOf(address owner) external view returns (uint256 balance);\\n\\n    /**\\n     * @dev Returns the owner of the `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function ownerOf(uint256 tokenId) external view returns (address owner);\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\\n\\n    /**\\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must exist and be owned by `from`.\\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Transfers `tokenId` token from `from` to `to`.\\n     *\\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\\n     *\\n     * Requirements:\\n     *\\n     * - `from` cannot be the zero address.\\n     * - `to` cannot be the zero address.\\n     * - `tokenId` token must be owned by `from`.\\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\\n     * The approval is cleared when the token is transferred.\\n     *\\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\\n     *\\n     * Requirements:\\n     *\\n     * - The caller must own the token or be an approved operator.\\n     * - `tokenId` must exist.\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address to, uint256 tokenId) external;\\n\\n    /**\\n     * @dev Approve or remove `operator` as an operator for the caller.\\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\\n     *\\n     * Requirements:\\n     *\\n     * - The `operator` cannot be the caller.\\n     *\\n     * Emits an {ApprovalForAll} event.\\n     */\\n    function setApprovalForAll(address operator, bool approved) external;\\n\\n    /**\\n     * @dev Returns the account approved for `tokenId` token.\\n     *\\n     * Requirements:\\n     *\\n     * - `tokenId` must exist.\\n     */\\n    function getApproved(uint256 tokenId) external view returns (address operator);\\n\\n    /**\\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\\n     *\\n     * See {setApprovalForAll}\\n     */\\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x5bce51e11f7d194b79ea59fe00c9e8de9fa2c5530124960f29a24d4c740a3266\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC721.sol\\\";\\n\\n/**\\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\\n * @dev See https://eips.ethereum.org/EIPS/eip-721\\n */\\ninterface IERC721Metadata is IERC721 {\\n    /**\\n     * @dev Returns the token collection name.\\n     */\\n    function name() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the token collection symbol.\\n     */\\n    function symbol() external view returns (string memory);\\n\\n    /**\\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\\n     */\\n    function tokenURI(uint256 tokenId) external view returns (string memory);\\n}\\n\",\"keccak256\":\"0x75b829ff2f26c14355d1cba20e16fe7b29ca58eb5fef665ede48bc0f9c6c74b9\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/introspection/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n    /**\\n     * @dev Returns true if this contract implements the interface defined by\\n     * `interfaceId`. See the corresponding\\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n     * to learn more about how these ids are created.\\n     *\\n     * This function call must use less than 30 000 gas.\\n     */\\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0x447a5f3ddc18419d41ff92b3773fb86471b1db25773e07f877f548918a185bf1\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x5f43ed533d0fc4dc2f8f081d2c4b77960f3e908d5f7359096b385e5673f1ba0c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n     */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n     */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n     */\\n  function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x953f20efa64081a325109a0e03602b889d2819c2b51c1e1fb21a062feeda74f3\",\"license\":\"MIT\"},\"contracts/integrations/kyber/IBasePositionManager.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport {IERC721Metadata} from '@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol';\\r\\nimport {IRouterTokenHelper} from './IRouterTokenHelper.sol';\\r\\nimport {IBasePositionManagerEvents} from './base_position_manager/IBasePositionManagerEvents.sol';\\r\\n\\r\\ninterface IBasePositionManager is IRouterTokenHelper, IBasePositionManagerEvents {\\r\\n  struct Position {\\r\\n    // the nonce for permits\\r\\n    uint96 nonce;\\r\\n    // the address that is approved for spending this token\\r\\n    address operator;\\r\\n    // the ID of the pool with which this token is connected\\r\\n    uint80 poolId;\\r\\n    // the tick range of the position\\r\\n    int24 tickLower;\\r\\n    int24 tickUpper;\\r\\n    // the liquidity of the position\\r\\n    uint128 liquidity;\\r\\n    // the current rToken that the position owed\\r\\n    uint256 rTokenOwed;\\r\\n    // fee growth per unit of liquidity as of the last update to liquidity\\r\\n    uint256 feeGrowthInsideLast;\\r\\n  }\\r\\n\\r\\n  struct PoolInfo {\\r\\n    address token0;\\r\\n    uint24 fee;\\r\\n    address token1;\\r\\n  }\\r\\n\\r\\n  /// @notice Params for the first time adding liquidity, mint new nft to sender\\r\\n  /// @param token0 the token0 of the pool\\r\\n  /// @param token1 the token1 of the pool\\r\\n  ///   - must make sure that token0 < token1\\r\\n  /// @param fee the pool's fee in fee units\\r\\n  /// @param tickLower the position's lower tick\\r\\n  /// @param tickUpper the position's upper tick\\r\\n  ///   - must make sure tickLower < tickUpper, and both are in tick distance\\r\\n  /// @param ticksPrevious the nearest tick that has been initialized and lower than or equal to\\r\\n  ///   the tickLower and tickUpper, use to help insert the tickLower and tickUpper if haven't initialized\\r\\n  /// @param amount0Desired the desired amount for token0\\r\\n  /// @param amount1Desired the desired amount for token1\\r\\n  /// @param amount0Min min amount of token 0 to add\\r\\n  /// @param amount1Min min amount of token 1 to add\\r\\n  /// @param recipient the owner of the position\\r\\n  /// @param deadline time that the transaction will be expired\\r\\n  struct MintParams {\\r\\n    address token0;\\r\\n    address token1;\\r\\n    uint24 fee;\\r\\n    int24 tickLower;\\r\\n    int24 tickUpper;\\r\\n    int24[2] ticksPrevious;\\r\\n    uint256 amount0Desired;\\r\\n    uint256 amount1Desired;\\r\\n    uint256 amount0Min;\\r\\n    uint256 amount1Min;\\r\\n    address recipient;\\r\\n    uint256 deadline;\\r\\n  }\\r\\n\\r\\n  /// @notice Params for adding liquidity to the existing position\\r\\n  /// @param tokenId id of the position to increase its liquidity\\r\\n  /// @param ticksPrevious the nearest tick that has been initialized and lower than or equal to\\r\\n  ///   the tickLower and tickUpper, use to help insert the tickLower and tickUpper if haven't initialized\\r\\n  ///   only needed if the position has been closed and the owner wants to add more liquidity\\r\\n  /// @param amount0Desired the desired amount for token0\\r\\n  /// @param amount1Desired the desired amount for token1\\r\\n  /// @param amount0Min min amount of token 0 to add\\r\\n  /// @param amount1Min min amount of token 1 to add\\r\\n  /// @param deadline time that the transaction will be expired\\r\\n  struct IncreaseLiquidityParams {\\r\\n    uint256 tokenId;\\r\\n    int24[2] ticksPrevious;\\r\\n    uint256 amount0Desired;\\r\\n    uint256 amount1Desired;\\r\\n    uint256 amount0Min;\\r\\n    uint256 amount1Min;\\r\\n    uint256 deadline;\\r\\n  }\\r\\n\\r\\n  /// @notice Params for remove liquidity from the existing position\\r\\n  /// @param tokenId id of the position to remove its liquidity\\r\\n  /// @param amount0Min min amount of token 0 to receive\\r\\n  /// @param amount1Min min amount of token 1 to receive\\r\\n  /// @param deadline time that the transaction will be expired\\r\\n  struct RemoveLiquidityParams {\\r\\n    uint256 tokenId;\\r\\n    uint128 liquidity;\\r\\n    uint256 amount0Min;\\r\\n    uint256 amount1Min;\\r\\n    uint256 deadline;\\r\\n  }\\r\\n\\r\\n  /// @notice Burn the rTokens to get back token0 + token1 as fees\\r\\n  /// @param tokenId id of the position to burn r token\\r\\n  /// @param amount0Min min amount of token 0 to receive\\r\\n  /// @param amount1Min min amount of token 1 to receive\\r\\n  /// @param deadline time that the transaction will be expired\\r\\n  struct BurnRTokenParams {\\r\\n    uint256 tokenId;\\r\\n    uint256 amount0Min;\\r\\n    uint256 amount1Min;\\r\\n    uint256 deadline;\\r\\n  }\\r\\n\\r\\n  /// @notice Creates a new pool if it does not exist, then unlocks if it has not been unlocked\\r\\n  /// @param token0 the token0 of the pool\\r\\n  /// @param token1 the token1 of the pool\\r\\n  /// @param fee the fee for the pool\\r\\n  /// @param currentSqrtP the initial price of the pool\\r\\n  /// @return pool returns the pool address\\r\\n  function createAndUnlockPoolIfNecessary(\\r\\n    address token0,\\r\\n    address token1,\\r\\n    uint24 fee,\\r\\n    uint160 currentSqrtP\\r\\n  ) external payable returns (address pool);\\r\\n\\r\\n  function mint(MintParams calldata params)\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n      uint256 tokenId,\\r\\n      uint128 liquidity,\\r\\n      uint256 amount0,\\r\\n      uint256 amount1\\r\\n    );\\r\\n\\r\\n  function addLiquidity(IncreaseLiquidityParams calldata params)\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n      uint128 liquidity,\\r\\n      uint256 amount0,\\r\\n      uint256 amount1,\\r\\n      uint256 additionalRTokenOwed\\r\\n    );\\r\\n\\r\\n  function removeLiquidity(RemoveLiquidityParams calldata params)\\r\\n    external\\r\\n    returns (\\r\\n      uint256 amount0,\\r\\n      uint256 amount1,\\r\\n      uint256 additionalRTokenOwed\\r\\n    );\\r\\n\\r\\n  function burnRTokens(BurnRTokenParams calldata params)\\r\\n    external\\r\\n    returns (\\r\\n      uint256 rTokenQty,\\r\\n      uint256 amount0,\\r\\n      uint256 amount1\\r\\n    );\\r\\n\\r\\n  /**\\r\\n   * @dev Burn the token by its owner\\r\\n   * @notice All liquidity should be removed before burning\\r\\n   */\\r\\n  function burn(uint256 tokenId) external payable;\\r\\n\\r\\n  function syncFeeGrowth(uint256 tokenId) external returns (uint256 additionalRTokenOwed);\\r\\n\\r\\n  function positions(uint256 tokenId)\\r\\n    external\\r\\n    view\\r\\n    returns (Position memory pos, PoolInfo memory info);\\r\\n\\r\\n  function addressToPoolId(address pool) external view returns (uint80);\\r\\n\\r\\n  function isRToken(address token) external view returns (bool);\\r\\n\\r\\n  function nextPoolId() external view returns (uint80);\\r\\n\\r\\n  function nextTokenId() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @dev Returns true if this contract implements the interface defined by\\r\\n   * `interfaceId`. See the corresponding\\r\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\r\\n   * to learn more about how these ids are created.\\r\\n   *\\r\\n   * This function call must use less than 30 000 gas.\\r\\n   */\\r\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\r\\n}\\r\\n\",\"keccak256\":\"0x1edd4bf1e7fdb23e4f39d3e8c2efb23b76a90f60bf7e13d49dd89e80a6e36646\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/kyber/IFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\n/// @title KyberSwap v2 factory\\r\\n/// @notice Deploys KyberSwap v2 pools and manages control over government fees\\r\\ninterface IFactory {\\r\\n  /// @notice Emitted when a pool is created\\r\\n  /// @param token0 First pool token by address sort order\\r\\n  /// @param token1 Second pool token by address sort order\\r\\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\r\\n  /// @param tickDistance Minimum number of ticks between initialized ticks\\r\\n  /// @param pool The address of the created pool\\r\\n  event PoolCreated(\\r\\n    address indexed token0,\\r\\n    address indexed token1,\\r\\n    uint24 indexed swapFeeUnits,\\r\\n    int24 tickDistance,\\r\\n    address pool\\r\\n  );\\r\\n\\r\\n  /// @notice Emitted when a new fee is enabled for pool creation via the factory\\r\\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\r\\n  /// @param tickDistance Minimum number of ticks between initialized ticks for pools created with the given fee\\r\\n  event SwapFeeEnabled(uint24 indexed swapFeeUnits, int24 indexed tickDistance);\\r\\n\\r\\n  /// @notice Emitted when vesting period changes\\r\\n  /// @param vestingPeriod The maximum time duration for which LP fees\\r\\n  /// are proportionally burnt upon LP removals\\r\\n  event VestingPeriodUpdated(uint32 vestingPeriod);\\r\\n\\r\\n  /// @notice Emitted when configMaster changes\\r\\n  /// @param oldConfigMaster configMaster before the update\\r\\n  /// @param newConfigMaster configMaster after the update\\r\\n  event ConfigMasterUpdated(address oldConfigMaster, address newConfigMaster);\\r\\n\\r\\n  /// @notice Emitted when fee configuration changes\\r\\n  /// @param feeTo Recipient of government fees\\r\\n  /// @param governmentFeeUnits Fee amount, in fee units,\\r\\n  /// to be collected out of the fee charged for a pool swap\\r\\n  event FeeConfigurationUpdated(address feeTo, uint24 governmentFeeUnits);\\r\\n\\r\\n  /// @notice Emitted when whitelist feature is enabled\\r\\n  event WhitelistEnabled();\\r\\n\\r\\n  /// @notice Emitted when whitelist feature is disabled\\r\\n  event WhitelistDisabled();\\r\\n\\r\\n  /// @notice Returns the maximum time duration for which LP fees\\r\\n  /// are proportionally burnt upon LP removals\\r\\n  function vestingPeriod() external view returns (uint32);\\r\\n\\r\\n  /// @notice Returns the tick distance for a specified fee.\\r\\n  /// @dev Once added, cannot be updated or removed.\\r\\n  /// @param swapFeeUnits Swap fee, in fee units.\\r\\n  /// @return The tick distance. Returns 0 if fee has not been added.\\r\\n  function feeAmountTickDistance(uint24 swapFeeUnits) external view returns (int24);\\r\\n\\r\\n  /// @notice Returns the address which can update the fee configuration\\r\\n  function configMaster() external view returns (address);\\r\\n\\r\\n  /// @notice Returns the keccak256 hash of the Pool creation code\\r\\n  /// This is used for pre-computation of pool addresses\\r\\n  function poolInitHash() external view returns (bytes32);\\r\\n\\r\\n  /// @notice Returns the pool oracle contract for twap\\r\\n  function poolOracle() external view returns (address);\\r\\n\\r\\n  /// @notice Fetches the recipient of government fees\\r\\n  /// and current government fee charged in fee units\\r\\n  function feeConfiguration() external view returns (address _feeTo, uint24 _governmentFeeUnits);\\r\\n\\r\\n  /// @notice Returns the status of whitelisting feature of NFT managers\\r\\n  /// If true, anyone can mint liquidity tokens\\r\\n  /// Otherwise, only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\r\\n  function whitelistDisabled() external view returns (bool);\\r\\n\\r\\n  //// @notice Returns all whitelisted NFT managers\\r\\n  /// If the whitelisting feature is turned on,\\r\\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\r\\n  function getWhitelistedNFTManagers() external view returns (address[] memory);\\r\\n\\r\\n  /// @notice Checks if sender is a whitelisted NFT manager\\r\\n  /// If the whitelisting feature is turned on,\\r\\n  /// only whitelisted NFT manager(s) are allowed to mint liquidity tokens\\r\\n  /// @param sender address to be checked\\r\\n  /// @return true if sender is a whistelisted NFT manager, false otherwise\\r\\n  function isWhitelistedNFTManager(address sender) external view returns (bool);\\r\\n\\r\\n  /// @notice Returns the pool address for a given pair of tokens and a swap fee\\r\\n  /// @dev Token order does not matter\\r\\n  /// @param tokenA Contract address of either token0 or token1\\r\\n  /// @param tokenB Contract address of the other token\\r\\n  /// @param swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\r\\n  /// @return pool The pool address. Returns null address if it does not exist\\r\\n  function getPool(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint24 swapFeeUnits\\r\\n  ) external view returns (address pool);\\r\\n\\r\\n  /// @notice Fetch parameters to be used for pool creation\\r\\n  /// @dev Called by the pool constructor to fetch the parameters of the pool\\r\\n  /// @return factory The factory address\\r\\n  /// @return poolOracle The pool oracle for twap\\r\\n  /// @return token0 First pool token by address sort order\\r\\n  /// @return token1 Second pool token by address sort order\\r\\n  /// @return swapFeeUnits Fee to be collected upon every swap in the pool, in fee units\\r\\n  /// @return tickDistance Minimum number of ticks between initialized ticks\\r\\n  function parameters()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      address factory,\\r\\n      address poolOracle,\\r\\n      address token0,\\r\\n      address token1,\\r\\n      uint24 swapFeeUnits,\\r\\n      int24 tickDistance\\r\\n    );\\r\\n\\r\\n  /// @notice Creates a pool for the given two tokens and fee\\r\\n  /// @param tokenA One of the two tokens in the desired pool\\r\\n  /// @param tokenB The other of the two tokens in the desired pool\\r\\n  /// @param swapFeeUnits Desired swap fee for the pool, in fee units\\r\\n  /// @dev Token order does not matter. tickDistance is determined from the fee.\\r\\n  /// Call will revert under any of these conditions:\\r\\n  ///     1) pool already exists\\r\\n  ///     2) invalid swap fee\\r\\n  ///     3) invalid token arguments\\r\\n  /// @return pool The address of the newly created pool\\r\\n  function createPool(\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint24 swapFeeUnits\\r\\n  ) external returns (address pool);\\r\\n\\r\\n  /// @notice Enables a fee amount with the given tickDistance\\r\\n  /// @dev Fee amounts may never be removed once enabled\\r\\n  /// @param swapFeeUnits The fee amount to enable, in fee units\\r\\n  /// @param tickDistance The distance between ticks to be enforced for all pools created with the given fee amount\\r\\n  function enableSwapFee(uint24 swapFeeUnits, int24 tickDistance) external;\\r\\n\\r\\n  /// @notice Updates the address which can update the fee configuration\\r\\n  /// @dev Must be called by the current configMaster\\r\\n  function updateConfigMaster(address) external;\\r\\n\\r\\n  /// @notice Updates the vesting period\\r\\n  /// @dev Must be called by the current configMaster\\r\\n  function updateVestingPeriod(uint32) external;\\r\\n\\r\\n  /// @notice Updates the address receiving government fees and fee quantity\\r\\n  /// @dev Only configMaster is able to perform the update\\r\\n  /// @param feeTo Address to receive government fees collected from pools\\r\\n  /// @param governmentFeeUnits Fee amount, in fee units,\\r\\n  /// to be collected out of the fee charged for a pool swap\\r\\n  function updateFeeConfiguration(address feeTo, uint24 governmentFeeUnits) external;\\r\\n\\r\\n  /// @notice Enables the whitelisting feature\\r\\n  /// @dev Only configMaster is able to perform the update\\r\\n  function enableWhitelist() external;\\r\\n\\r\\n  /// @notice Disables the whitelisting feature\\r\\n  /// @dev Only configMaster is able to perform the update\\r\\n  function disableWhitelist() external;\\r\\n}\\r\\n\",\"keccak256\":\"0xfcea701d7a47511a726696953028c945c4ca3b0c60648a1d7a1101e660796798\",\"license\":\"MIT\"},\"contracts/integrations/kyber/IKyberSwapElasticLM.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport {IERC721} from '@openzeppelin/contracts/token/ERC721/IERC721.sol';\\r\\n\\r\\ninterface IKyberSwapElasticLM {\\r\\n  struct RewardData {\\r\\n    address rewardToken;\\r\\n    uint256 rewardUnclaimed;\\r\\n  }\\r\\n\\r\\n  struct LMPoolInfo {\\r\\n    address poolAddress;\\r\\n    uint32 startTime;\\r\\n    uint32 endTime;\\r\\n    uint256 totalSecondsClaimed; // scaled by (1 << 96)\\r\\n    RewardData[] rewards;\\r\\n    uint256 feeTarget;\\r\\n    uint256 numStakes;\\r\\n  }\\r\\n\\r\\n  struct PositionInfo {\\r\\n    address owner;\\r\\n    uint256 liquidity;\\r\\n  }\\r\\n\\r\\n  struct StakeInfo {\\r\\n    uint128 secondsPerLiquidityLast;\\r\\n    uint256[] rewardLast;\\r\\n    uint256[] rewardPending;\\r\\n    uint256[] rewardHarvested;\\r\\n    int256 feeFirst;\\r\\n    uint256 liquidity;\\r\\n  }\\r\\n\\r\\n  // input data in harvestMultiplePools function\\r\\n  struct HarvestData {\\r\\n    uint256[] pIds;\\r\\n  }\\r\\n\\r\\n  // avoid stack too deep error\\r\\n  struct RewardCalculationData {\\r\\n    uint128 secondsPerLiquidityNow;\\r\\n    int256 feeNow;\\r\\n    uint256 vestingVolume;\\r\\n    uint256 totalSecondsUnclaimed;\\r\\n    uint256 secondsPerLiquidity;\\r\\n    uint256 secondsClaim; // scaled by (1 << 96)\\r\\n  }\\r\\n\\r\\n  // nftId => Position info\\r\\n  function positions(uint nftId) external view returns (PositionInfo memory);\\r\\n\\r\\n  function admin() external view returns(address);\\r\\n\\r\\n  function updateOperator(address user, bool grantOrRevoke) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Add new pool to LM\\r\\n   * @param poolAddr pool address\\r\\n   * @param startTime start time of liquidity mining\\r\\n   * @param endTime end time of liquidity mining\\r\\n   * @param rewardTokens reward token list for pool\\r\\n   * @param rewardAmounts reward amount of list token\\r\\n   * @param feeTarget fee target for pool\\r\\n   *\\r\\n   */\\r\\n  function addPool(\\r\\n    address poolAddr,\\r\\n    uint32 startTime,\\r\\n    uint32 endTime,\\r\\n    address[] calldata rewardTokens,\\r\\n    uint256[] calldata rewardAmounts,\\r\\n    uint256 feeTarget\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Renew a pool to start another LM program\\r\\n   * @param pId pool id to update\\r\\n   * @param startTime start time of liquidity mining\\r\\n   * @param endTime end time of liquidity mining\\r\\n   * @param rewardAmounts reward amount of list token\\r\\n   * @param feeTarget fee target for pool\\r\\n   *\\r\\n   */\\r\\n  function renewPool(\\r\\n    uint256 pId,\\r\\n    uint32 startTime,\\r\\n    uint32 endTime,\\r\\n    uint256[] calldata rewardAmounts,\\r\\n    uint256 feeTarget\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Deposit NFT\\r\\n   * @param nftIds list nft id\\r\\n   *\\r\\n   */\\r\\n  function deposit(uint256[] calldata nftIds) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Deposit NFTs into the pool and join farms if applicable\\r\\n   * @param pId pool id to join farm\\r\\n   * @param nftIds List of NFT ids from BasePositionManager, should match with the pId\\r\\n   *\\r\\n   */\\r\\n  function depositAndJoin(uint256 pId, uint256[] calldata nftIds) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Withdraw NFT, must exit all pool before call.\\r\\n   * @param nftIds list nft id\\r\\n   *\\r\\n   */\\r\\n  function withdraw(uint256[] calldata nftIds) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Join pools\\r\\n   * @param pId pool id to join\\r\\n   * @param nftIds nfts to join\\r\\n   * @param liqs list liquidity value to join each nft\\r\\n   *\\r\\n   */\\r\\n  function join(uint256 pId, uint256[] calldata nftIds, uint256[] calldata liqs) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Exit from pools\\r\\n   * @param pId pool ids to exit\\r\\n   * @param nftIds list nfts id\\r\\n   * @param liqs list liquidity value to exit from each nft\\r\\n   *\\r\\n   */\\r\\n  function exit(uint256 pId, uint256[] calldata nftIds, uint256[] calldata liqs) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Claim rewards for a list of pools for a list of nft positions\\r\\n   * @param nftIds List of NFT ids to harvest\\r\\n   * @param datas List of pool ids to harvest for each nftId, encoded into bytes\\r\\n   */\\r\\n  function harvestMultiplePools(uint256[] calldata nftIds, bytes[] calldata datas) external;\\r\\n\\r\\n  /**\\r\\n   * @dev remove liquidity from elastic for a list of nft position, also update on farm\\r\\n   * @param nftId to remove\\r\\n   * @param liquidity liquidity amount to remove from nft\\r\\n   * @param amount0Min expected min amount of token0 should receive\\r\\n   * @param amount1Min expected min amount of token1 should receive\\r\\n   * @param deadline deadline of this tx\\r\\n   * @param isReceiveNative should unwrap native or not\\r\\n   * @param claimFeeAndRewards also claim LP Fee and farm rewards\\r\\n   */\\r\\n  function removeLiquidity(\\r\\n    uint256 nftId,\\r\\n    uint128 liquidity,\\r\\n    uint256 amount0Min,\\r\\n    uint256 amount1Min,\\r\\n    uint256 deadline,\\r\\n    bool isReceiveNative,\\r\\n    bool[2] calldata claimFeeAndRewards\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Claim fee from elastic for a list of nft positions\\r\\n   * @param nftIds List of NFT ids to claim\\r\\n   * @param amount0Min expected min amount of token0 should receive\\r\\n   * @param amount1Min expected min amount of token1 should receive\\r\\n   * @param poolAddress address of Elastic pool of those nfts\\r\\n   * @param isReceiveNative should unwrap native or not\\r\\n   * @param deadline deadline of this tx\\r\\n   */\\r\\n  function claimFee(\\r\\n    uint256[] calldata nftIds,\\r\\n    uint256 amount0Min,\\r\\n    uint256 amount1Min,\\r\\n    address poolAddress,\\r\\n    bool isReceiveNative,\\r\\n    uint256 deadline\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Operator only. Call to withdraw all reward from list pools.\\r\\n   * @param rewards list reward address erc20 token\\r\\n   * @param amounts amount to withdraw\\r\\n   *\\r\\n   */\\r\\n  function emergencyWithdrawForOwner(\\r\\n    address[] calldata rewards,\\r\\n    uint256[] calldata amounts\\r\\n  ) external;\\r\\n\\r\\n  /**\\r\\n   * @dev Withdraw NFT, can call any time, reward will be reset. Must enable this func by operator\\r\\n   * @param pIds list pool to withdraw\\r\\n   *\\r\\n   */\\r\\n  function emergencyWithdraw(uint256[] calldata pIds) external;\\r\\n\\r\\n  /**\\r\\n   * @dev get list of pool that this nft joined\\r\\n   * @param nftId to get\\r\\n   */\\r\\n  function getJoinedPools(uint256 nftId) external view returns (uint256[] memory poolIds);\\r\\n\\r\\n  /**\\r\\n   * @dev get list of pool that this nft joined, only in a specific range\\r\\n   * @param nftId to get\\r\\n   * @param fromIndex index from\\r\\n   * @param toIndex index to\\r\\n   */\\r\\n  function getJoinedPoolsInRange(\\r\\n    uint256 nftId,\\r\\n    uint256 fromIndex,\\r\\n    uint256 toIndex\\r\\n  ) external view returns (uint256[] memory poolIds);\\r\\n\\r\\n  /**\\r\\n   * @dev get user's info (staked info) of a nft in a pool\\r\\n   * @param nftId to get\\r\\n   * @param pId to get\\r\\n   */\\r\\n  function getUserInfo(\\r\\n    uint256 nftId,\\r\\n    uint256 pId\\r\\n  )\\r\\n  external\\r\\n  view\\r\\n  returns (uint256 liquidity, uint256[] memory rewardPending, uint256[] memory rewardLast);\\r\\n\\r\\n  /**\\r\\n   * @dev get pool info\\r\\n   * @param pId to get\\r\\n   */\\r\\n  function getPoolInfo(\\r\\n    uint256 pId\\r\\n  )\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    address poolAddress,\\r\\n    uint32 startTime,\\r\\n    uint32 endTime,\\r\\n    uint256 totalSecondsClaimed,\\r\\n    uint256 feeTarget,\\r\\n    uint256 numStakes,\\r\\n  //index reward => reward data\\r\\n    address[] memory rewardTokens,\\r\\n    uint256[] memory rewardUnclaimeds\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @dev get list of deposited nfts of an address\\r\\n   * @param user address of user to get\\r\\n   */\\r\\n  function getDepositedNFTs(address user) external view returns (uint256[] memory listNFTs);\\r\\n\\r\\n  function nft() external view returns (IERC721);\\r\\n\\r\\n  function poolLength() external view returns (uint256);\\r\\n\\r\\n  function getRewardCalculationData(\\r\\n    uint256 nftId,\\r\\n    uint256 pId\\r\\n  ) external view returns (RewardCalculationData memory data);\\r\\n}\\r\\n\",\"keccak256\":\"0x35930c8b91552ee8e143ff0050415273283da6b2693743ac507631371b662d66\",\"license\":\"MIT\"},\"contracts/integrations/kyber/IPool.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport {IPoolActions} from './pool/IPoolActions.sol';\\r\\nimport {IPoolEvents} from './pool/IPoolEvents.sol';\\r\\nimport {IPoolStorage} from './pool/IPoolStorage.sol';\\r\\n\\r\\ninterface IPool is IPoolActions, IPoolEvents, IPoolStorage {}\\r\\n\",\"keccak256\":\"0x844cc97514d40654ab584b5d907d836850a308d03b3cc33365f0d01c54a21180\",\"license\":\"MIT\"},\"contracts/integrations/kyber/IRouterTokenHelper.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IRouterTokenHelper {\\r\\n  /// @notice Unwraps the contract's WETH balance and sends it to recipient as ETH.\\r\\n  /// @dev The minAmount parameter prevents malicious contracts from stealing WETH from users.\\r\\n  /// @param minAmount The minimum amount of WETH to unwrap\\r\\n  /// @param recipient The address receiving ETH\\r\\n  function unwrapWeth(uint256 minAmount, address recipient) external payable;\\r\\n\\r\\n  /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\\r\\n  /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\\r\\n  /// that use ether for the input amount\\r\\n  function refundEth() external payable;\\r\\n\\r\\n  /// @notice Transfers the full amount of a token held by this contract to recipient\\r\\n  /// @dev The minAmount parameter prevents malicious contracts from stealing the token from users\\r\\n  /// @param token The contract address of the token which will be transferred to `recipient`\\r\\n  /// @param minAmount The minimum amount of token required for a transfer\\r\\n  /// @param recipient The destination address of the token\\r\\n  function transferAllTokens(\\r\\n    address token,\\r\\n    uint256 minAmount,\\r\\n    address recipient\\r\\n  ) external payable;\\r\\n}\\r\\n\",\"keccak256\":\"0x6abab0e9db2ba0ddaa929864eed83b4dd884d23b2fb7c0e8da1f46026029fb23\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/kyber/ITicksFeesReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface ITicksFeesReader {\\r\\n  function getTotalFeesOwedToPosition(\\r\\n    address posManager,\\r\\n    address pool,\\r\\n    uint256 tokenId\\r\\n  ) external view returns (uint256 token0Owed, uint256 token1Owed);\\r\\n}\\r\\n\",\"keccak256\":\"0x9801801237a2422e55e2886e4ed54508b5d98056901aebe9ac699df7e153592c\",\"license\":\"MIT\"},\"contracts/integrations/kyber/base_position_manager/IBasePositionManagerEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IBasePositionManagerEvents {\\r\\n  /// @notice Emitted when a token is minted for a given position\\r\\n  /// @param tokenId the newly minted tokenId\\r\\n  /// @param poolId poolId of the token\\r\\n  /// @param liquidity liquidity minted to the position range\\r\\n  /// @param amount0 token0 quantity needed to mint the liquidity\\r\\n  /// @param amount1 token1 quantity needed to mint the liquidity\\r\\n  event MintPosition(\\r\\n    uint256 indexed tokenId,\\r\\n    uint80 indexed poolId,\\r\\n    uint128 liquidity,\\r\\n    uint256 amount0,\\r\\n    uint256 amount1\\r\\n  );\\r\\n\\r\\n  /// @notice Emitted when a token is burned\\r\\n  /// @param tokenId id of the token\\r\\n  event BurnPosition(uint256 indexed tokenId);\\r\\n\\r\\n  /// @notice Emitted when add liquidity\\r\\n  /// @param tokenId id of the token\\r\\n  /// @param liquidity the increase amount of liquidity\\r\\n  /// @param amount0 token0 quantity needed to increase liquidity\\r\\n  /// @param amount1 token1 quantity needed to increase liquidity\\r\\n  /// @param additionalRTokenOwed additional rToken earned\\r\\n  event AddLiquidity(\\r\\n    uint256 indexed tokenId,\\r\\n    uint128 liquidity,\\r\\n    uint256 amount0,\\r\\n    uint256 amount1,\\r\\n    uint256 additionalRTokenOwed\\r\\n  );\\r\\n\\r\\n  /// @notice Emitted when remove liquidity\\r\\n  /// @param tokenId id of the token\\r\\n  /// @param liquidity the decease amount of liquidity\\r\\n  /// @param amount0 token0 quantity returned when remove liquidity\\r\\n  /// @param amount1 token1 quantity returned when remove liquidity\\r\\n  /// @param additionalRTokenOwed additional rToken earned\\r\\n  event RemoveLiquidity(\\r\\n    uint256 indexed tokenId,\\r\\n    uint128 liquidity,\\r\\n    uint256 amount0,\\r\\n    uint256 amount1,\\r\\n    uint256 additionalRTokenOwed\\r\\n  );\\r\\n\\r\\n  /// @notice Emitted when burn position's RToken\\r\\n  /// @param tokenId id of the token\\r\\n  /// @param rTokenBurn amount of position's RToken burnt\\r\\n  event BurnRToken(uint256 indexed tokenId, uint256 rTokenBurn);\\r\\n\\r\\n  /// @notice Emitted when sync fee growth\\r\\n  /// @param tokenId id of the token\\r\\n  /// @param additionalRTokenOwed additional rToken earned\\r\\n  event SyncFeeGrowth(uint256 indexed tokenId, uint256 additionalRTokenOwed);\\r\\n}\\r\\n\",\"keccak256\":\"0x05310caa18bd99fa2762a472ea82bfdc978c289a17ab2212ea180cfa5be398f2\",\"license\":\"MIT\"},\"contracts/integrations/kyber/oracle/IPoolOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IPoolOracle {\\r\\n  /// @notice Owner withdrew funds in the pool oracle in case some funds are stuck there\\r\\n  event OwnerWithdrew(\\r\\n    address indexed owner,\\r\\n    address indexed token,\\r\\n    uint256 indexed amount\\r\\n  );\\r\\n\\r\\n  /// @notice Emitted by the Pool Oracle for increases to the number of observations that can be stored\\r\\n  /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\\r\\n  /// just before a mint/swap/burn.\\r\\n  /// @param pool The pool address to update\\r\\n  /// @param observationCardinalityNextOld The previous value of the next observation cardinality\\r\\n  /// @param observationCardinalityNextNew The updated value of the next observation cardinality\\r\\n  event IncreaseObservationCardinalityNext(\\r\\n    address pool,\\r\\n    uint16 observationCardinalityNextOld,\\r\\n    uint16 observationCardinalityNextNew\\r\\n  );\\r\\n\\r\\n  /// @notice Initalize observation data for the caller.\\r\\n  function initializeOracle(uint32 time)\\r\\n    external\\r\\n    returns (uint16 cardinality, uint16 cardinalityNext);\\r\\n\\r\\n  /// @notice Write a new oracle entry into the array\\r\\n  ///   and update the observation index and cardinality\\r\\n  /// Read the Oralce.write function for more details\\r\\n  function writeNewEntry(\\r\\n    uint16 index,\\r\\n    uint32 blockTimestamp,\\r\\n    int24 tick,\\r\\n    uint128 liquidity,\\r\\n    uint16 cardinality,\\r\\n    uint16 cardinalityNext\\r\\n  )\\r\\n    external\\r\\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated);\\r\\n\\r\\n  /// @notice Write a new oracle entry into the array, take the latest observaion data as inputs\\r\\n  ///   and update the observation index and cardinality\\r\\n  /// Read the Oralce.write function for more details\\r\\n  function write(\\r\\n    uint32 blockTimestamp,\\r\\n    int24 tick,\\r\\n    uint128 liquidity\\r\\n  )\\r\\n    external\\r\\n    returns (uint16 indexUpdated, uint16 cardinalityUpdated);\\r\\n\\r\\n  /// @notice Increase the maximum number of price observations that this pool will store\\r\\n  /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\\r\\n  /// the input observationCardinalityNext.\\r\\n  /// @param pool The pool address to be updated\\r\\n  /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\\r\\n  function increaseObservationCardinalityNext(\\r\\n    address pool,\\r\\n    uint16 observationCardinalityNext\\r\\n  )\\r\\n    external;\\r\\n\\r\\n  /// @notice Returns the accumulator values as of each time seconds ago from the latest block time in the array of `secondsAgos`\\r\\n  /// @dev Reverts if `secondsAgos` > oldest observation\\r\\n  /// @dev It fetches the latest current tick data from the pool\\r\\n  /// Read the Oracle.observe function for more details\\r\\n  function observeFromPool(\\r\\n    address pool,\\r\\n    uint32[] memory secondsAgos\\r\\n  )\\r\\n    external view\\r\\n    returns (int56[] memory tickCumulatives);\\r\\n\\r\\n  /// @notice Returns the accumulator values as the time seconds ago from the latest block time of secondsAgo\\r\\n  /// @dev Reverts if `secondsAgo` > oldest observation\\r\\n  /// @dev It fetches the latest current tick data from the pool\\r\\n  /// Read the Oracle.observeSingle function for more details\\r\\n  function observeSingleFromPool(\\r\\n    address pool,\\r\\n    uint32 secondsAgo\\r\\n  )\\r\\n    external view\\r\\n    returns (int56 tickCumulative);\\r\\n\\r\\n  /// @notice Return the latest pool observation data given the pool address\\r\\n  function getPoolObservation(address pool)\\r\\n    external view\\r\\n    returns (bool initialized, uint16 index, uint16 cardinality, uint16 cardinalityNext);\\r\\n\\r\\n  /// @notice Returns data about a specific observation index\\r\\n  /// @param pool The pool address of the observations array to fetch\\r\\n  /// @param index The element of the observations array to fetch\\r\\n  /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\\r\\n  /// ago, rather than at a specific index in the array.\\r\\n  /// @return blockTimestamp The timestamp of the observation,\\r\\n  /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\\r\\n  /// Returns initialized whether the observation has been initialized and the values are safe to use\\r\\n  function getObservationAt(address pool, uint256 index)\\r\\n    external view\\r\\n    returns (\\r\\n      uint32 blockTimestamp,\\r\\n      int56 tickCumulative,\\r\\n      bool initialized\\r\\n    );\\r\\n}\\r\\n\",\"keccak256\":\"0x36bc5ec5c0db80e5016a222909c41c3cf20e180f28072660949235150f9392c4\",\"license\":\"MIT\"},\"contracts/integrations/kyber/pool/IPoolActions.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IPoolActions {\\r\\n  /// @notice Sets the initial price for the pool and seeds reinvestment liquidity\\r\\n  /// @dev Assumes the caller has sent the necessary token amounts\\r\\n  /// required for initializing reinvestment liquidity prior to calling this function\\r\\n  /// @param initialSqrtP the initial sqrt price of the pool\\r\\n  /// @param qty0 token0 quantity sent to and locked permanently in the pool\\r\\n  /// @param qty1 token1 quantity sent to and locked permanently in the pool\\r\\n  function unlockPool(uint160 initialSqrtP) external returns (uint256 qty0, uint256 qty1);\\r\\n\\r\\n  /// @notice Adds liquidity for the specified recipient/tickLower/tickUpper position\\r\\n  /// @dev Any token0 or token1 owed for the liquidity provision have to be paid for when\\r\\n  /// the IMintCallback#mintCallback is called to this method's caller\\r\\n  /// The quantity of token0/token1 to be sent depends on\\r\\n  /// tickLower, tickUpper, the amount of liquidity, and the current price of the pool.\\r\\n  /// Also sends reinvestment tokens (fees) to the recipient for any fees collected\\r\\n  /// while the position is in range\\r\\n  /// Reinvestment tokens have to be burnt via #burnRTokens in exchange for token0 and token1\\r\\n  /// @param recipient Address for which the added liquidity is credited to\\r\\n  /// @param tickLower Recipient position's lower tick\\r\\n  /// @param tickUpper Recipient position's upper tick\\r\\n  /// @param ticksPrevious The nearest tick that is initialized and <= the lower & upper ticks\\r\\n  /// @param qty Liquidity quantity to mint\\r\\n  /// @param data Data (if any) to be passed through to the callback\\r\\n  /// @return qty0 token0 quantity sent to the pool in exchange for the minted liquidity\\r\\n  /// @return qty1 token1 quantity sent to the pool in exchange for the minted liquidity\\r\\n  /// @return feeGrowthInside position's updated feeGrowthInside value\\r\\n  function mint(\\r\\n    address recipient,\\r\\n    int24 tickLower,\\r\\n    int24 tickUpper,\\r\\n    int24[2] calldata ticksPrevious,\\r\\n    uint128 qty,\\r\\n    bytes calldata data\\r\\n  )\\r\\n    external\\r\\n    returns (\\r\\n      uint256 qty0,\\r\\n      uint256 qty1,\\r\\n      uint256 feeGrowthInside\\r\\n    );\\r\\n\\r\\n  /// @notice Remove liquidity from the caller\\r\\n  /// Also sends reinvestment tokens (fees) to the caller for any fees collected\\r\\n  /// while the position is in range\\r\\n  /// Reinvestment tokens have to be burnt via #burnRTokens in exchange for token0 and token1\\r\\n  /// @param tickLower Position's lower tick for which to burn liquidity\\r\\n  /// @param tickUpper Position's upper tick for which to burn liquidity\\r\\n  /// @param qty Liquidity quantity to burn\\r\\n  /// @return qty0 token0 quantity sent to the caller\\r\\n  /// @return qty1 token1 quantity sent to the caller\\r\\n  /// @return feeGrowthInside position's updated feeGrowthInside value\\r\\n  function burn(\\r\\n    int24 tickLower,\\r\\n    int24 tickUpper,\\r\\n    uint128 qty\\r\\n  )\\r\\n    external\\r\\n    returns (\\r\\n      uint256 qty0,\\r\\n      uint256 qty1,\\r\\n      uint256 feeGrowthInside\\r\\n    );\\r\\n\\r\\n  /// @notice Burns reinvestment tokens in exchange to receive the fees collected in token0 and token1\\r\\n  /// @param qty Reinvestment token quantity to burn\\r\\n  /// @param isLogicalBurn true if burning rTokens without returning any token0/token1\\r\\n  ///         otherwise should transfer token0/token1 to sender\\r\\n  /// @return qty0 token0 quantity sent to the caller for burnt reinvestment tokens\\r\\n  /// @return qty1 token1 quantity sent to the caller for burnt reinvestment tokens\\r\\n  function burnRTokens(uint256 qty, bool isLogicalBurn)\\r\\n    external\\r\\n    returns (uint256 qty0, uint256 qty1);\\r\\n\\r\\n  /// @notice Swap token0 -> token1, or vice versa\\r\\n  /// @dev This method's caller receives a callback in the form of ISwapCallback#swapCallback\\r\\n  /// @dev swaps will execute up to limitSqrtP or swapQty is fully used\\r\\n  /// @param recipient The address to receive the swap output\\r\\n  /// @param swapQty The swap quantity, which implicitly configures the swap as exact input (>0), or exact output (<0)\\r\\n  /// @param isToken0 Whether the swapQty is specified in token0 (true) or token1 (false)\\r\\n  /// @param limitSqrtP the limit of sqrt price after swapping\\r\\n  /// could be MAX_SQRT_RATIO-1 when swapping 1 -> 0 and MIN_SQRT_RATIO+1 when swapping 0 -> 1 for no limit swap\\r\\n  /// @param data Any data to be passed through to the callback\\r\\n  /// @return qty0 Exact token0 qty sent to recipient if < 0. Minimally received quantity if > 0.\\r\\n  /// @return qty1 Exact token1 qty sent to recipient if < 0. Minimally received quantity if > 0.\\r\\n  function swap(\\r\\n    address recipient,\\r\\n    int256 swapQty,\\r\\n    bool isToken0,\\r\\n    uint160 limitSqrtP,\\r\\n    bytes calldata data\\r\\n  ) external returns (int256 qty0, int256 qty1);\\r\\n\\r\\n  /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\r\\n  /// @dev The caller of this method receives a callback in the form of IFlashCallback#flashCallback\\r\\n  /// @dev Fees collected are sent to the feeTo address if it is set in Factory\\r\\n  /// @param recipient The address which will receive the token0 and token1 quantities\\r\\n  /// @param qty0 token0 quantity to be loaned to the recipient\\r\\n  /// @param qty1 token1 quantity to be loaned to the recipient\\r\\n  /// @param data Any data to be passed through to the callback\\r\\n  function flash(\\r\\n    address recipient,\\r\\n    uint256 qty0,\\r\\n    uint256 qty1,\\r\\n    bytes calldata data\\r\\n  ) external;\\r\\n\\r\\n\\r\\n  /// @notice sync fee of position\\r\\n  /// @param tickLower Position's lower tick\\r\\n  /// @param tickUpper Position's upper tick\\r\\n  function tweakPosZeroLiq(int24 tickLower, int24 tickUpper)\\r\\n    external returns(uint256 feeGrowthInsideLast);\\r\\n}\\r\\n\",\"keccak256\":\"0xc6300703f4b1446da2e8619d8fb2d1718a0d5ae5ec702ae6c059bb9833c173eb\",\"license\":\"MIT\"},\"contracts/integrations/kyber/pool/IPoolEvents.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\ninterface IPoolEvents {\\r\\n  /// @notice Emitted only once per pool when #initialize is first called\\r\\n  /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\r\\n  /// @param sqrtP The initial price of the pool\\r\\n  /// @param tick The initial tick of the pool\\r\\n  event Initialize(uint160 sqrtP, int24 tick);\\r\\n\\r\\n  /// @notice Emitted when liquidity is minted for a given position\\r\\n  /// @dev transfers reinvestment tokens for any collected fees earned by the position\\r\\n  /// @param sender address that minted the liquidity\\r\\n  /// @param owner address of owner of the position\\r\\n  /// @param tickLower position's lower tick\\r\\n  /// @param tickUpper position's upper tick\\r\\n  /// @param qty liquidity minted to the position range\\r\\n  /// @param qty0 token0 quantity needed to mint the liquidity\\r\\n  /// @param qty1 token1 quantity needed to mint the liquidity\\r\\n  event Mint(\\r\\n    address sender,\\r\\n    address indexed owner,\\r\\n    int24 indexed tickLower,\\r\\n    int24 indexed tickUpper,\\r\\n    uint128 qty,\\r\\n    uint256 qty0,\\r\\n    uint256 qty1\\r\\n  );\\r\\n\\r\\n  /// @notice Emitted when a position's liquidity is removed\\r\\n  /// @dev transfers reinvestment tokens for any collected fees earned by the position\\r\\n  /// @param owner address of owner of the position\\r\\n  /// @param tickLower position's lower tick\\r\\n  /// @param tickUpper position's upper tick\\r\\n  /// @param qty liquidity removed\\r\\n  /// @param qty0 token0 quantity withdrawn from removal of liquidity\\r\\n  /// @param qty1 token1 quantity withdrawn from removal of liquidity\\r\\n  event Burn(\\r\\n    address indexed owner,\\r\\n    int24 indexed tickLower,\\r\\n    int24 indexed tickUpper,\\r\\n    uint128 qty,\\r\\n    uint256 qty0,\\r\\n    uint256 qty1\\r\\n  );\\r\\n\\r\\n  /// @notice Emitted when reinvestment tokens are burnt\\r\\n  /// @param owner address which burnt the reinvestment tokens\\r\\n  /// @param qty reinvestment token quantity burnt\\r\\n  /// @param qty0 token0 quantity sent to owner for burning reinvestment tokens\\r\\n  /// @param qty1 token1 quantity sent to owner for burning reinvestment tokens\\r\\n  event BurnRTokens(address indexed owner, uint256 qty, uint256 qty0, uint256 qty1);\\r\\n\\r\\n  /// @notice Emitted for swaps by the pool between token0 and token1\\r\\n  /// @param sender Address that initiated the swap call, and that received the callback\\r\\n  /// @param recipient Address that received the swap output\\r\\n  /// @param deltaQty0 Change in pool's token0 balance\\r\\n  /// @param deltaQty1 Change in pool's token1 balance\\r\\n  /// @param sqrtP Pool's sqrt price after the swap\\r\\n  /// @param liquidity Pool's liquidity after the swap\\r\\n  /// @param currentTick Log base 1.0001 of pool's price after the swap\\r\\n  event Swap(\\r\\n    address indexed sender,\\r\\n    address indexed recipient,\\r\\n    int256 deltaQty0,\\r\\n    int256 deltaQty1,\\r\\n    uint160 sqrtP,\\r\\n    uint128 liquidity,\\r\\n    int24 currentTick\\r\\n  );\\r\\n\\r\\n  /// @notice Emitted by the pool for any flash loans of token0/token1\\r\\n  /// @param sender The address that initiated the flash loan, and that received the callback\\r\\n  /// @param recipient The address that received the flash loan quantities\\r\\n  /// @param qty0 token0 quantity loaned to the recipient\\r\\n  /// @param qty1 token1 quantity loaned to the recipient\\r\\n  /// @param paid0 token0 quantity paid for the flash, which can exceed qty0 + fee\\r\\n  /// @param paid1 token1 quantity paid for the flash, which can exceed qty0 + fee\\r\\n  event Flash(\\r\\n    address indexed sender,\\r\\n    address indexed recipient,\\r\\n    uint256 qty0,\\r\\n    uint256 qty1,\\r\\n    uint256 paid0,\\r\\n    uint256 paid1\\r\\n  );\\r\\n}\\r\\n\",\"keccak256\":\"0xfe327a00775a36f7150326ca77b1d6108115c7012c29545a4244bbda1eb6f712\",\"license\":\"MIT\"},\"contracts/integrations/kyber/pool/IPoolStorage.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.8.0;\\r\\n\\r\\nimport {IERC20} from '@openzeppelin/contracts/token/ERC20/IERC20.sol';\\r\\n\\r\\nimport {IFactory} from '../IFactory.sol';\\r\\nimport {IPoolOracle} from '../oracle/IPoolOracle.sol';\\r\\n\\r\\ninterface IPoolStorage {\\r\\n  /// @notice The contract that deployed the pool, which must adhere to the IFactory interface\\r\\n  /// @return The contract address\\r\\n  function factory() external view returns (IFactory);\\r\\n\\r\\n  /// @notice The oracle contract that stores necessary data for price oracle\\r\\n  /// @return The contract address\\r\\n  function poolOracle() external view returns (IPoolOracle);\\r\\n\\r\\n  /// @notice The first of the two tokens of the pool, sorted by address\\r\\n  /// @return The token contract address\\r\\n  function token0() external view returns (IERC20);\\r\\n\\r\\n  /// @notice The second of the two tokens of the pool, sorted by address\\r\\n  /// @return The token contract address\\r\\n  function token1() external view returns (IERC20);\\r\\n\\r\\n  /// @notice The fee to be charged for a swap in basis points\\r\\n  /// @return The swap fee in basis points\\r\\n  function swapFeeUnits() external view returns (uint24);\\r\\n\\r\\n  /// @notice The pool tick distance\\r\\n  /// @dev Ticks can only be initialized and used at multiples of this value\\r\\n  /// It remains an int24 to avoid casting even though it is >= 1.\\r\\n  /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\\r\\n  /// @return The tick distance\\r\\n  function tickDistance() external view returns (int24);\\r\\n\\r\\n  /// @notice Maximum gross liquidity that an initialized tick can have\\r\\n  /// @dev This is to prevent overflow the pool's active base liquidity (uint128)\\r\\n  /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\r\\n  /// @return The max amount of liquidity per tick\\r\\n  function maxTickLiquidity() external view returns (uint128);\\r\\n\\r\\n  /// @notice Look up information about a specific tick in the pool\\r\\n  /// @param tick The tick to look up\\r\\n  /// @return liquidityGross total liquidity amount from positions that uses this tick as a lower or upper tick\\r\\n  /// liquidityNet how much liquidity changes when the pool tick crosses above the tick\\r\\n  /// feeGrowthOutside the fee growth on the other side of the tick relative to the current tick\\r\\n  /// secondsPerLiquidityOutside the seconds per unit of liquidity  spent on the other side of the tick relative to the current tick\\r\\n  function ticks(int24 tick)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint128 liquidityGross,\\r\\n      int128 liquidityNet,\\r\\n      uint256 feeGrowthOutside,\\r\\n      uint128 secondsPerLiquidityOutside\\r\\n    );\\r\\n\\r\\n  /// @notice Returns the previous and next initialized ticks of a specific tick\\r\\n  /// @dev If specified tick is uninitialized, the returned values are zero.\\r\\n  /// @param tick The tick to look up\\r\\n  function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\\r\\n\\r\\n  /// @notice Returns the information about a position by the position's key\\r\\n  /// @return liquidity the liquidity quantity of the position\\r\\n  /// @return feeGrowthInsideLast fee growth inside the tick range as of the last mint / burn action performed\\r\\n  function getPositions(\\r\\n    address owner,\\r\\n    int24 tickLower,\\r\\n    int24 tickUpper\\r\\n  ) external view returns (uint128 liquidity, uint256 feeGrowthInsideLast);\\r\\n\\r\\n  /// @notice Fetches the pool's prices, ticks and lock status\\r\\n  /// @return sqrtP sqrt of current price: sqrt(token1/token0)\\r\\n  /// @return currentTick pool's current tick\\r\\n  /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\\r\\n  /// @return locked true if pool is locked, false otherwise\\r\\n  function getPoolState()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint160 sqrtP,\\r\\n      int24 currentTick,\\r\\n      int24 nearestCurrentTick,\\r\\n      bool locked\\r\\n    );\\r\\n\\r\\n  /// @notice Fetches the pool's liquidity values\\r\\n  /// @return baseL pool's base liquidity without reinvest liqudity\\r\\n  /// @return reinvestL the liquidity is reinvested into the pool\\r\\n  /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\\r\\n  function getLiquidityState()\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      uint128 baseL,\\r\\n      uint128 reinvestL,\\r\\n      uint128 reinvestLLast\\r\\n    );\\r\\n\\r\\n  /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\\r\\n  function getFeeGrowthGlobal() external view returns (uint256);\\r\\n\\r\\n  /// @return secondsPerLiquidityGlobal All-time seconds per unit of liquidity of the pool\\r\\n  /// @return lastUpdateTime The timestamp in which secondsPerLiquidityGlobal was last updated\\r\\n  function getSecondsPerLiquidityData()\\r\\n    external\\r\\n    view\\r\\n    returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\\r\\n\\r\\n  /// @notice Calculates and returns the active time per unit of liquidity until current block.timestamp\\r\\n  /// @param tickLower The lower tick (of a position)\\r\\n  /// @param tickUpper The upper tick (of a position)\\r\\n  /// @return secondsPerLiquidityInside active time (multiplied by 2^96)\\r\\n  /// between the 2 ticks, per unit of liquidity.\\r\\n  function getSecondsPerLiquidityInside(int24 tickLower, int24 tickUpper)\\r\\n    external\\r\\n    view\\r\\n    returns (uint128 secondsPerLiquidityInside);\\r\\n}\\r\\n\",\"keccak256\":\"0x6a2400c1fce45f8569623bfb8aeadcb96ba2d80b3002d329d5d9cbe4827ebb2b\",\"license\":\"MIT\"},\"contracts/strategies/kyber/KyberLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"../../integrations/kyber/IPool.sol\\\";\\r\\nimport \\\"../../integrations/kyber/IBasePositionManager.sol\\\";\\r\\nimport \\\"../../integrations/kyber/IKyberSwapElasticLM.sol\\\";\\r\\nimport \\\"../../integrations/kyber/ITicksFeesReader.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\r\\n\\r\\nlibrary KyberLib {\\r\\n  uint8 internal constant RESOLUTION = 96;\\r\\n  uint internal constant Q96 = 0x1000000000000000000000000;\\r\\n  uint private constant TWO_96 = 2 ** 96;\\r\\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\r\\n  uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\\r\\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\r\\n  uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\\r\\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\r\\n  int24 internal constant MIN_TICK = - 887272;\\r\\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\r\\n  int24 internal constant MAX_TICK = - MIN_TICK;\\r\\n\\r\\n  function getPreviousTicks(IPool pool, int24 tickLower, int24 tickUpper) external view returns (int24[2] memory ticks) {\\r\\n    (ticks[0],) = _getNearestInitializedTicks(pool, tickLower);\\r\\n    (ticks[1],) = _getNearestInitializedTicks(pool, tickUpper);\\r\\n  }\\r\\n\\r\\n  function _getNearestInitializedTicks(IPool pool, int24 tick) internal view returns (int24 previous, int24 next) {\\r\\n    require(MIN_TICK <= tick && tick <= MAX_TICK, 'tick not in range');\\r\\n    // if queried tick already initialized, fetch and return values\\r\\n    (previous, next) = pool.initializedTicks(tick);\\r\\n    if (previous != 0 || next != 0) return (previous, next);\\r\\n\\r\\n    // search downtick from MAX_TICK\\r\\n    if (tick > 0) {\\r\\n      previous = MAX_TICK;\\r\\n      while (previous > tick) {\\r\\n        (previous, ) = pool.initializedTicks(previous);\\r\\n      }\\r\\n      (, next) = pool.initializedTicks(previous);\\r\\n    } else {\\r\\n      // search uptick from MIN_TICK\\r\\n      next = MIN_TICK;\\r\\n      while (next < tick) {\\r\\n        (, next) = pool.initializedTicks(next);\\r\\n      }\\r\\n      (previous, ) = pool.initializedTicks(next);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function getTickSpacing(IPool pool) external view returns (int24) {\\r\\n    return pool.tickDistance();\\r\\n  }\\r\\n\\r\\n  function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\\r\\n    IPool pool = IPool(pool_);\\r\\n    (uint160 sqrtRatioX96, , ,) = pool.getPoolState();\\r\\n    liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\\r\\n    (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\r\\n  /// pool prices and the prices at the tick boundaries\\r\\n  function getLiquidityForAmounts(\\r\\n    uint160 sqrtRatioX96,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    uint amount0,\\r\\n    uint amount1\\r\\n  ) public pure returns (uint128 liquidity) {\\r\\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\\r\\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n\\r\\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\\r\\n      liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\\r\\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\\r\\n      uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\\r\\n      uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\\r\\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\r\\n    } else {\\r\\n      liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\r\\n  /// pool prices and the prices at the tick boundaries\\r\\n  function getAmountsForLiquidity(\\r\\n    uint160 sqrtRatioX96,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    uint128 liquidity\\r\\n  ) public pure returns (uint amount0, uint amount1) {\\r\\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\\r\\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\\r\\n\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n\\r\\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\\r\\n      amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\r\\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\\r\\n      amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\\r\\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\\r\\n    } else {\\r\\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\\r\\n  /// @param a The multiplicand\\r\\n  /// @param b The multiplier\\r\\n  /// @param denominator The divisor\\r\\n  /// @return result The 256-bit result\\r\\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\r\\n  function mulDiv(\\r\\n    uint a,\\r\\n    uint b,\\r\\n    uint denominator\\r\\n  ) public pure returns (uint result) {\\r\\n    unchecked {\\r\\n      // 512-bit multiply [prod1 prod0] = a * b\\r\\n      // Compute the product mod 2**256 and mod 2**256 - 1\\r\\n      // then use the Chinese Remainder Theorem to reconstruct\\r\\n      // the 512 bit result. The result is stored in two 256\\r\\n      // variables such that product = prod1 * 2**256 + prod0\\r\\n      uint prod0;\\r\\n      // Least significant 256 bits of the product\\r\\n      uint prod1;\\r\\n      // Most significant 256 bits of the product\\r\\n      assembly {\\r\\n        let mm := mulmod(a, b, not(0))\\r\\n        prod0 := mul(a, b)\\r\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n      }\\r\\n\\r\\n      // Handle non-overflow cases, 256 by 256 division\\r\\n      if (prod1 == 0) {\\r\\n        require(denominator > 0);\\r\\n        assembly {\\r\\n          result := div(prod0, denominator)\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n\\r\\n      // Make sure the result is less than 2**256.\\r\\n      // Also prevents denominator == 0\\r\\n      require(denominator > prod1);\\r\\n\\r\\n      ///////////////////////////////////////////////\\r\\n      // 512 by 256 division.\\r\\n      ///////////////////////////////////////////////\\r\\n\\r\\n      // Make division exact by subtracting the remainder from [prod1 prod0]\\r\\n      // Compute remainder using mulmod\\r\\n      uint remainder;\\r\\n      assembly {\\r\\n        remainder := mulmod(a, b, denominator)\\r\\n      }\\r\\n      // Subtract 256 bit number from 512 bit number\\r\\n      assembly {\\r\\n        prod1 := sub(prod1, gt(remainder, prod0))\\r\\n        prod0 := sub(prod0, remainder)\\r\\n      }\\r\\n\\r\\n      // Factor powers of two out of denominator\\r\\n      // Compute largest power of two divisor of denominator.\\r\\n      // Always >= 1.\\r\\n      // EDIT for 0.8 compatibility:\\r\\n      // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\\r\\n      uint twos = denominator & (~denominator + 1);\\r\\n\\r\\n      // Divide denominator by power of two\\r\\n      assembly {\\r\\n        denominator := div(denominator, twos)\\r\\n      }\\r\\n\\r\\n      // Divide [prod1 prod0] by the factors of two\\r\\n      assembly {\\r\\n        prod0 := div(prod0, twos)\\r\\n      }\\r\\n      // Shift in bits from prod1 into prod0. For this we need\\r\\n      // to flip `twos` such that it is 2**256 / twos.\\r\\n      // If twos is zero, then it becomes one\\r\\n      assembly {\\r\\n        twos := add(div(sub(0, twos), twos), 1)\\r\\n      }\\r\\n      prod0 |= prod1 * twos;\\r\\n\\r\\n      // Invert denominator mod 2**256\\r\\n      // Now that denominator is an odd number, it has an inverse\\r\\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\r\\n      // Compute the inverse by starting with a seed that is correct\\r\\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\\r\\n      uint inv = (3 * denominator) ^ 2;\\r\\n      // Now use Newton-Raphson iteration to improve the precision.\\r\\n      // Thanks to Hensel's lifting lemma, this also works in modular\\r\\n      // arithmetic, doubling the correct bits in each step.\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**8\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**16\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**32\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**64\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**128\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**256\\r\\n\\r\\n      // Because the division is now exact we can divide by multiplying\\r\\n      // with the modular inverse of denominator. This will give us the\\r\\n      // correct result modulo 2**256. Since the precoditions guarantee\\r\\n      // that the outcome is less than 2**256, this is the final result.\\r\\n      // We don't need to compute the high bits of the result and prod1\\r\\n      // is no longer required.\\r\\n      result = prod0 * inv;\\r\\n      return result;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\\r\\n  /// @param a The multiplicand\\r\\n  /// @param b The multiplier\\r\\n  /// @param denominator The divisor\\r\\n  /// @return result The 256-bit result\\r\\n  function mulDivRoundingUp(\\r\\n    uint a,\\r\\n    uint b,\\r\\n    uint denominator\\r\\n  ) internal pure returns (uint result) {\\r\\n    result = mulDiv(a, b, denominator);\\r\\n    if (mulmod(a, b, denominator) > 0) {\\r\\n      require(result < type(uint).max);\\r\\n      result++;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates price in pool\\r\\n  /// @return price with decimals of paired token\\r\\n  function getPrice(address pool_, address tokenIn) public view returns (uint) {\\r\\n    IPool pool = IPool(pool_);\\r\\n    address token0 = address(pool.token0());\\r\\n    address token1 = address(pool.token1());\\r\\n\\r\\n    uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\\r\\n    uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\\r\\n    (uint160 sqrtPriceX96,,,) = pool.getPoolState();\\r\\n\\r\\n    uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\\r\\n\\r\\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\\r\\n    uint purePrice;\\r\\n    uint precision;\\r\\n    if (tokenIn == token0) {\\r\\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\\r\\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\\r\\n      purePrice = part * part;\\r\\n    } else {\\r\\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\\r\\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\\r\\n      purePrice = part * part;\\r\\n    }\\r\\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\r\\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param amount0 The amount0 being sent in\\r\\n  /// @return liquidity The amount of returned liquidity\\r\\n  function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\\r\\n    return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\r\\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param amount1 The amount1 being sent in\\r\\n  /// @return liquidity The amount of returned liquidity\\r\\n  function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param liquidity The liquidity being valued\\r\\n  /// @return amount0 The amount0\\r\\n  function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param liquidity The liquidity being valued\\r\\n  /// @return amount1 The amount1\\r\\n  function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\\r\\n  }\\r\\n\\r\\n  function _countDigits(uint n) internal pure returns (uint) {\\r\\n    if (n == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint count = 0;\\r\\n    while (n != 0) {\\r\\n      n = n / 10;\\r\\n      ++count;\\r\\n    }\\r\\n    return count;\\r\\n  }\\r\\n\\r\\n  function _min(uint a, uint b) internal pure returns (uint) {\\r\\n    return a < b ? a : b;\\r\\n  }\\r\\n\\r\\n  function _max(uint a, uint b) internal pure returns (uint) {\\r\\n    return a > b ? a : b;\\r\\n  }\\r\\n\\r\\n  function _toUint128(uint x) private pure returns (uint128 y) {\\r\\n    require((y = uint128(x)) == x);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\\r\\n  /// @dev Throws if |tick| > max tick\\r\\n  /// @param tick The input tick for the above formula\\r\\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\r\\n  /// at the given tick\\r\\n  function _getSqrtRatioAtTick(int24 tick)\\r\\n  internal\\r\\n  pure\\r\\n  returns (uint160 sqrtPriceX96)\\r\\n  {\\r\\n    uint256 absTick =\\r\\n      tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\\r\\n\\r\\n    // EDIT: 0.8 compatibility\\r\\n    require(absTick <= uint256(int256(MAX_TICK)), \\\"T\\\");\\r\\n\\r\\n    uint256 ratio =\\r\\n      absTick & 0x1 != 0\\r\\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\\r\\n        : 0x100000000000000000000000000000000;\\r\\n    if (absTick & 0x2 != 0)\\r\\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\r\\n    if (absTick & 0x4 != 0)\\r\\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\r\\n    if (absTick & 0x8 != 0)\\r\\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\r\\n    if (absTick & 0x10 != 0)\\r\\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\r\\n    if (absTick & 0x20 != 0)\\r\\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\r\\n    if (absTick & 0x40 != 0)\\r\\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\r\\n    if (absTick & 0x80 != 0)\\r\\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\r\\n    if (absTick & 0x100 != 0)\\r\\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\r\\n    if (absTick & 0x200 != 0)\\r\\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\r\\n    if (absTick & 0x400 != 0)\\r\\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\r\\n    if (absTick & 0x800 != 0)\\r\\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\r\\n    if (absTick & 0x1000 != 0)\\r\\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\r\\n    if (absTick & 0x2000 != 0)\\r\\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\r\\n    if (absTick & 0x4000 != 0)\\r\\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\r\\n    if (absTick & 0x8000 != 0)\\r\\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\r\\n    if (absTick & 0x10000 != 0)\\r\\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\r\\n    if (absTick & 0x20000 != 0)\\r\\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\r\\n    if (absTick & 0x40000 != 0)\\r\\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\r\\n    if (absTick & 0x80000 != 0)\\r\\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\r\\n\\r\\n    if (tick > 0) ratio = type(uint256).max / ratio;\\r\\n\\r\\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\r\\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\r\\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\r\\n    sqrtPriceX96 = uint160(\\r\\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\r\\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\r\\n  /// ever return.\\r\\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\r\\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\r\\n  function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\r\\n    // second inequality must be < because the price can never reach the price at the max tick\\r\\n    require(\\r\\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\\r\\n      \\\"R\\\"\\r\\n    );\\r\\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\\r\\n\\r\\n    uint256 r = ratio;\\r\\n    uint256 msb = 0;\\r\\n\\r\\n    assembly {\\r\\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(5, gt(r, 0xFFFFFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(4, gt(r, 0xFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(3, gt(r, 0xFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(2, gt(r, 0xF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(1, gt(r, 0x3))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := gt(r, 0x1)\\r\\n      msb := or(msb, f)\\r\\n    }\\r\\n\\r\\n    if (msb >= 128) r = ratio >> (msb - 127);\\r\\n    else r = ratio << (127 - msb);\\r\\n\\r\\n    int256 log_2 = (int256(msb) - 128) << 64;\\r\\n\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(63, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(62, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(61, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(60, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(59, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(58, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(57, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(56, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(55, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(54, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(53, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(52, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(51, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(50, f))\\r\\n    }\\r\\n\\r\\n    tick = _getFinalTick(log_2, sqrtPriceX96);\\r\\n  }\\r\\n\\r\\n  function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\r\\n    // 128.128 number\\r\\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\\r\\n\\r\\n    int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\r\\n    int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\r\\n\\r\\n    tick = (tickLow == tickHi)\\r\\n      ? tickLow\\r\\n      : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow);\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x63639e89a04e4e1171b175920615c3c30dcf606d03d8de0a171dbaa9283b700b\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x6117fc61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100775760003560e01c80630337236a1461007c57806317c22c3c146100ac5780632a279b28146100e35780637127e2491461010b5780638b72d3601461012b578063aa9a091214610151578063ac41865a14610172575b600080fd5b61008f61008a366004611319565b610185565b6040516001600160801b0390911681526020015b60405180910390f35b6100bf6100ba366004611319565b610262565b6040805193845260208401929092526001600160801b0316908201526060016100a3565b6100f66100f1366004611374565b610302565b604080519283526020830191909152016100a3565b61011e6101193660046113dc565b6103b8565b6040516100a39190611427565b61013e610139366004611460565b6103ea565b60405160029190910b81526020016100a3565b61016461015f36600461147d565b610454565b6040519081526020016100a3565b6101646101803660046114a9565b610508565b600080610191866109ac565b9050600061019e866109ac565b9050806001600160a01b0316826001600160a01b031611156101bc57905b816001600160a01b0316886001600160a01b0316116101e7576101e0828287610dc7565b9250610257565b806001600160a01b0316886001600160a01b0316101561024957600061020e898388610dc7565b9050600061021d848b88610e3a565b9050806001600160801b0316826001600160801b03161061023e5780610240565b815b94505050610257565b610254828286610e3a565b92505b505095945050505050565b6000806000808890506000816001600160a01b031663217ac2376040518163ffffffff1660e01b8152600401608060405180830381865afa1580156102ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102cf91906114e2565b50505090506102e1818a8a8a8a610185565b92506102ef818a8a86610302565b909b909a50929850919650505050505050565b6000806000610310866109ac565b9050600061031d866109ac565b9050806001600160a01b0316826001600160a01b0316111561033b57905b816001600160a01b0316886001600160a01b0316116103665761035f828287610e70565b93506103ad565b806001600160a01b0316886001600160a01b0316101561039f5761038b888287610e70565b9350610398828987610eda565b92506103ad565b6103aa828287610eda565b92505b505094509492505050565b6103c06112d4565b6103ca8484610f24565b5060020b81526103da8483610f24565b5060020b60208201529392505050565b6000816001600160a01b03166348626a8c6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561042a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044e919061153b565b92915050565b600080806000198587098587029250828110838203039150508060000361048d576000841161048257600080fd5b508290049050610501565b80841161049957600080fd5b600084868809851960019081018716968790049682860381900495909211909303600082900391909104909201919091029190911760038402600290811880860282030280860282030280860282030280860282030280860282030280860290910302029150505b9392505050565b6000808390506000816001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa15801561054e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105729190611558565b90506000826001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105b4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105d89190611558565b90506000826001600160a01b0316866001600160a01b03161461065c57816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610633573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106579190611575565b6106be565b826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561069a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106be9190611575565b60ff1690506000826001600160a01b0316876001600160a01b03161461074557826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561071c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107409190611575565b6107a7565b836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610783573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a79190611575565b60ff1690506000856001600160a01b031663217ac2376040518163ffffffff1660e01b8152600401608060405180830381865afa1580156107ec573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081091906114e2565b5050509050600060128310610826576001610850565b61085061083485600a611692565b61083f85600a611692565b61084991906116b4565b600161122b565b90506000610866836001600160a01b0316611241565b9050600080886001600160a01b03168c6001600160a01b0316036108ee5786601d841061089457600061089f565b61089f84601d6116c8565b6108a991906116db565b6108b490600a611692565b90506000600160601b6108d0836001600160a01b0389166116ee565b6108da91906116b4565b90506108e681806116ee565b925050610954565b86601d84116108fe576000610909565b610909601d856116c8565b61091391906116db565b61091e90600a611692565b905060006001600160a01b03861661093a83600160601b6116ee565b61094491906116b4565b905061095081806116ee565b9250505b670de0b6b3a7640000811161096a57600161097c565b61097c670de0b6b3a7640000826116b4565b8161098786856116b4565b61099191906116b4565b61099b91906116b4565b9d9c50505050505050505050505050565b60008060008360020b126109c3578260020b6109d0565b8260020b6109d090611705565b90506109df620d89e719611721565b60020b811115610a1a5760405162461bcd60e51b81526020600482015260016024820152601560fa1b60448201526064015b60405180910390fd5b600081600116600003610a3157600160801b610a43565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b031690506002821615610a78576080610a73826ffff97272373d413259a46990580e213a6116ee565b901c90505b6004821615610aa2576080610a9d826ffff2e50f5f656932ef12357cf3c7fdcc6116ee565b901c90505b6008821615610acc576080610ac7826fffe5caca7e10e4e61c3624eaa0941cd06116ee565b901c90505b6010821615610af6576080610af1826fffcb9843d60f6159c9db58835c9266446116ee565b901c90505b6020821615610b20576080610b1b826fff973b41fa98c081472e6896dfb254c06116ee565b901c90505b6040821615610b4a576080610b45826fff2ea16466c96a3843ec78b326b528616116ee565b901c90505b6080821615610b74576080610b6f826ffe5dee046a99a2a811c461f1969c30536116ee565b901c90505b610100821615610b9f576080610b9a826ffcbe86c7900a88aedcffc83b479aa3a46116ee565b901c90505b610200821615610bca576080610bc5826ff987a7253ac413176f2b074cf7815e546116ee565b901c90505b610400821615610bf5576080610bf0826ff3392b0822b70005940c7a398e4b70f36116ee565b901c90505b610800821615610c20576080610c1b826fe7159475a2c29b7443b29c7fa6e889d96116ee565b901c90505b611000821615610c4b576080610c46826fd097f3bdfd2022b8845ad8f792aa58256116ee565b901c90505b612000821615610c76576080610c71826fa9f746462d870fdf8a65dc1f90e061e56116ee565b901c90505b614000821615610ca1576080610c9c826f70d869a156d2a1b890bb3df62baf32f76116ee565b901c90505b618000821615610ccc576080610cc7826f31be135f97d08fd981231505542fcfa66116ee565b901c90505b62010000821615610cf8576080610cf3826f09aa508b5b7a84e1c677de54f3e99bc96116ee565b901c90505b62020000821615610d23576080610d1e826e5d6af8dedb81196699c329225ee6046116ee565b901c90505b62040000821615610d4d576080610d48826d2216e584f5fa1ea926041bedfe986116ee565b901c90505b62080000821615610d75576080610d70826b048a170391f7dc42444e8fa26116ee565b901c90505b60008460020b1315610d9057610d8d816000196116b4565b90505b610d9f64010000000082611743565b15610dab576001610dae565b60005b610dbf9060ff16602083901c6116db565b949350505050565b6000826001600160a01b0316846001600160a01b03161115610de7579192915b6000610e0a856001600160a01b0316856001600160a01b0316600160601b610454565b9050610e31610e2c8483610e1e8989611757565b6001600160a01b0316610454565b611279565b95945050505050565b6000826001600160a01b0316846001600160a01b03161115610e5a579192915b610dbf610e2c83600160601b610e1e8888611757565b6000826001600160a01b0316846001600160a01b03161115610e90579192915b610dbf6001610ecb600160601b600160e01b03606086901b16610eb38888611757565b6001600160a01b0316876001600160a01b0316611294565b866001600160a01b0316611294565b6000826001600160a01b0316846001600160a01b03161115610efa579192915b610dbf6001600160801b038316610f118686611757565b6001600160a01b0316600160601b611294565b600080600283900b620d89e71913801590610f515750610f47620d89e719611721565b60020b8360020b13155b610f915760405162461bcd60e51b81526020600482015260116024820152707469636b206e6f7420696e2072616e676560781b6044820152606401610a11565b60405163c0ac75cf60e01b8152600284900b60048201526001600160a01b0385169063c0ac75cf906024016040805180830381865afa158015610fd8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ffc919061177e565b9092509050600282900b15158061101757508060020b600014155b6112245760008360020b131561112c57611034620d89e719611721565b91505b8260020b8260020b13156110b85760405163c0ac75cf60e01b8152600283900b60048201526001600160a01b0385169063c0ac75cf906024016040805180830381865afa15801561108c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110b0919061177e565b509150611037565b60405163c0ac75cf60e01b8152600283900b60048201526001600160a01b0385169063c0ac75cf906024016040805180830381865afa1580156110ff573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611123919061177e565b91506112249050565b50620d89e7195b8260020b8160020b12156111b55760405163c0ac75cf60e01b8152600282900b60048201526001600160a01b0385169063c0ac75cf906024016040805180830381865afa158015611188573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ac919061177e565b91506111339050565b60405163c0ac75cf60e01b8152600282900b60048201526001600160a01b0385169063c0ac75cf906024016040805180830381865afa1580156111fc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611220919061177e565b5091505b9250929050565b600081831161123a5781610501565b5090919050565b60008160000361125357506000919050565b60005b821561044e57611267600a846116b4565b9250611272816117ad565b9050611256565b806001600160801b038116811461128f57600080fd5b919050565b60006112a1848484610454565b9050600082806112b3576112b361169e565b84860911156105015760001981106112ca57600080fd5b80610e31816117ad565b60405180604001604052806002906020820280368337509192915050565b6001600160a01b038116811461130757600080fd5b50565b8060020b811461130757600080fd5b600080600080600060a0868803121561133157600080fd5b853561133c816112f2565b9450602086013561134c8161130a565b9350604086013561135c8161130a565b94979396509394606081013594506080013592915050565b6000806000806080858703121561138a57600080fd5b8435611395816112f2565b935060208501356113a58161130a565b925060408501356113b58161130a565b915060608501356001600160801b03811681146113d157600080fd5b939692955090935050565b6000806000606084860312156113f157600080fd5b83356113fc816112f2565b9250602084013561140c8161130a565b9150604084013561141c8161130a565b809150509250925092565b60408101818360005b600280821061143f5750611457565b8251900b835260209283019290910190600101611430565b50505092915050565b60006020828403121561147257600080fd5b8135610501816112f2565b60008060006060848603121561149257600080fd5b505081359360208301359350604090920135919050565b600080604083850312156114bc57600080fd5b82356114c7816112f2565b915060208301356114d7816112f2565b809150509250929050565b600080600080608085870312156114f857600080fd5b8451611503816112f2565b60208601519094506115148161130a565b60408601519093506115258161130a565b606086015190925080151581146113d157600080fd5b60006020828403121561154d57600080fd5b81516105018161130a565b60006020828403121561156a57600080fd5b8151610501816112f2565b60006020828403121561158757600080fd5b815160ff8116811461050157600080fd5b634e487b7160e01b600052601160045260246000fd5b600181815b808511156115e95781600019048211156115cf576115cf611598565b808516156115dc57918102915b93841c93908002906115b3565b509250929050565b6000826116005750600161044e565b8161160d5750600061044e565b8160018114611623576002811461162d57611649565b600191505061044e565b60ff84111561163e5761163e611598565b50506001821b61044e565b5060208310610133831016604e8410600b841016171561166c575081810a61044e565b61167683836115ae565b806000190482111561168a5761168a611598565b029392505050565b600061050183836115f1565b634e487b7160e01b600052601260045260246000fd5b6000826116c3576116c361169e565b500490565b8181038181111561044e5761044e611598565b8082018082111561044e5761044e611598565b808202811582820484141761044e5761044e611598565b6000600160ff1b820161171a5761171a611598565b5060000390565b60008160020b627fffff19810361173a5761173a611598565b60000392915050565b6000826117525761175261169e565b500690565b6001600160a01b0382811682821603908082111561177757611777611598565b5092915050565b6000806040838503121561179157600080fd5b825161179c8161130a565b60208401519092506114d78161130a565b6000600182016117bf576117bf611598565b506001019056fea2646970667358221220bf5142b5dc288ec997919b6dc54b837983344ed446791fc79690ea241d1647dd64736f6c63430008110033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100775760003560e01c80630337236a1461007c57806317c22c3c146100ac5780632a279b28146100e35780637127e2491461010b5780638b72d3601461012b578063aa9a091214610151578063ac41865a14610172575b600080fd5b61008f61008a366004611319565b610185565b6040516001600160801b0390911681526020015b60405180910390f35b6100bf6100ba366004611319565b610262565b6040805193845260208401929092526001600160801b0316908201526060016100a3565b6100f66100f1366004611374565b610302565b604080519283526020830191909152016100a3565b61011e6101193660046113dc565b6103b8565b6040516100a39190611427565b61013e610139366004611460565b6103ea565b60405160029190910b81526020016100a3565b61016461015f36600461147d565b610454565b6040519081526020016100a3565b6101646101803660046114a9565b610508565b600080610191866109ac565b9050600061019e866109ac565b9050806001600160a01b0316826001600160a01b031611156101bc57905b816001600160a01b0316886001600160a01b0316116101e7576101e0828287610dc7565b9250610257565b806001600160a01b0316886001600160a01b0316101561024957600061020e898388610dc7565b9050600061021d848b88610e3a565b9050806001600160801b0316826001600160801b03161061023e5780610240565b815b94505050610257565b610254828286610e3a565b92505b505095945050505050565b6000806000808890506000816001600160a01b031663217ac2376040518163ffffffff1660e01b8152600401608060405180830381865afa1580156102ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906102cf91906114e2565b50505090506102e1818a8a8a8a610185565b92506102ef818a8a86610302565b909b909a50929850919650505050505050565b6000806000610310866109ac565b9050600061031d866109ac565b9050806001600160a01b0316826001600160a01b0316111561033b57905b816001600160a01b0316886001600160a01b0316116103665761035f828287610e70565b93506103ad565b806001600160a01b0316886001600160a01b0316101561039f5761038b888287610e70565b9350610398828987610eda565b92506103ad565b6103aa828287610eda565b92505b505094509492505050565b6103c06112d4565b6103ca8484610f24565b5060020b81526103da8483610f24565b5060020b60208201529392505050565b6000816001600160a01b03166348626a8c6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561042a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061044e919061153b565b92915050565b600080806000198587098587029250828110838203039150508060000361048d576000841161048257600080fd5b508290049050610501565b80841161049957600080fd5b600084868809851960019081018716968790049682860381900495909211909303600082900391909104909201919091029190911760038402600290811880860282030280860282030280860282030280860282030280860282030280860290910302029150505b9392505050565b6000808390506000816001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa15801561054e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105729190611558565b90506000826001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa1580156105b4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105d89190611558565b90506000826001600160a01b0316866001600160a01b03161461065c57816001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610633573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106579190611575565b6106be565b826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561069a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106be9190611575565b60ff1690506000826001600160a01b0316876001600160a01b03161461074557826001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa15801561071c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107409190611575565b6107a7565b836001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015610783573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107a79190611575565b60ff1690506000856001600160a01b031663217ac2376040518163ffffffff1660e01b8152600401608060405180830381865afa1580156107ec573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061081091906114e2565b5050509050600060128310610826576001610850565b61085061083485600a611692565b61083f85600a611692565b61084991906116b4565b600161122b565b90506000610866836001600160a01b0316611241565b9050600080886001600160a01b03168c6001600160a01b0316036108ee5786601d841061089457600061089f565b61089f84601d6116c8565b6108a991906116db565b6108b490600a611692565b90506000600160601b6108d0836001600160a01b0389166116ee565b6108da91906116b4565b90506108e681806116ee565b925050610954565b86601d84116108fe576000610909565b610909601d856116c8565b61091391906116db565b61091e90600a611692565b905060006001600160a01b03861661093a83600160601b6116ee565b61094491906116b4565b905061095081806116ee565b9250505b670de0b6b3a7640000811161096a57600161097c565b61097c670de0b6b3a7640000826116b4565b8161098786856116b4565b61099191906116b4565b61099b91906116b4565b9d9c50505050505050505050505050565b60008060008360020b126109c3578260020b6109d0565b8260020b6109d090611705565b90506109df620d89e719611721565b60020b811115610a1a5760405162461bcd60e51b81526020600482015260016024820152601560fa1b60448201526064015b60405180910390fd5b600081600116600003610a3157600160801b610a43565b6ffffcb933bd6fad37aa2d162d1a5940015b6001600160881b031690506002821615610a78576080610a73826ffff97272373d413259a46990580e213a6116ee565b901c90505b6004821615610aa2576080610a9d826ffff2e50f5f656932ef12357cf3c7fdcc6116ee565b901c90505b6008821615610acc576080610ac7826fffe5caca7e10e4e61c3624eaa0941cd06116ee565b901c90505b6010821615610af6576080610af1826fffcb9843d60f6159c9db58835c9266446116ee565b901c90505b6020821615610b20576080610b1b826fff973b41fa98c081472e6896dfb254c06116ee565b901c90505b6040821615610b4a576080610b45826fff2ea16466c96a3843ec78b326b528616116ee565b901c90505b6080821615610b74576080610b6f826ffe5dee046a99a2a811c461f1969c30536116ee565b901c90505b610100821615610b9f576080610b9a826ffcbe86c7900a88aedcffc83b479aa3a46116ee565b901c90505b610200821615610bca576080610bc5826ff987a7253ac413176f2b074cf7815e546116ee565b901c90505b610400821615610bf5576080610bf0826ff3392b0822b70005940c7a398e4b70f36116ee565b901c90505b610800821615610c20576080610c1b826fe7159475a2c29b7443b29c7fa6e889d96116ee565b901c90505b611000821615610c4b576080610c46826fd097f3bdfd2022b8845ad8f792aa58256116ee565b901c90505b612000821615610c76576080610c71826fa9f746462d870fdf8a65dc1f90e061e56116ee565b901c90505b614000821615610ca1576080610c9c826f70d869a156d2a1b890bb3df62baf32f76116ee565b901c90505b618000821615610ccc576080610cc7826f31be135f97d08fd981231505542fcfa66116ee565b901c90505b62010000821615610cf8576080610cf3826f09aa508b5b7a84e1c677de54f3e99bc96116ee565b901c90505b62020000821615610d23576080610d1e826e5d6af8dedb81196699c329225ee6046116ee565b901c90505b62040000821615610d4d576080610d48826d2216e584f5fa1ea926041bedfe986116ee565b901c90505b62080000821615610d75576080610d70826b048a170391f7dc42444e8fa26116ee565b901c90505b60008460020b1315610d9057610d8d816000196116b4565b90505b610d9f64010000000082611743565b15610dab576001610dae565b60005b610dbf9060ff16602083901c6116db565b949350505050565b6000826001600160a01b0316846001600160a01b03161115610de7579192915b6000610e0a856001600160a01b0316856001600160a01b0316600160601b610454565b9050610e31610e2c8483610e1e8989611757565b6001600160a01b0316610454565b611279565b95945050505050565b6000826001600160a01b0316846001600160a01b03161115610e5a579192915b610dbf610e2c83600160601b610e1e8888611757565b6000826001600160a01b0316846001600160a01b03161115610e90579192915b610dbf6001610ecb600160601b600160e01b03606086901b16610eb38888611757565b6001600160a01b0316876001600160a01b0316611294565b866001600160a01b0316611294565b6000826001600160a01b0316846001600160a01b03161115610efa579192915b610dbf6001600160801b038316610f118686611757565b6001600160a01b0316600160601b611294565b600080600283900b620d89e71913801590610f515750610f47620d89e719611721565b60020b8360020b13155b610f915760405162461bcd60e51b81526020600482015260116024820152707469636b206e6f7420696e2072616e676560781b6044820152606401610a11565b60405163c0ac75cf60e01b8152600284900b60048201526001600160a01b0385169063c0ac75cf906024016040805180830381865afa158015610fd8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ffc919061177e565b9092509050600282900b15158061101757508060020b600014155b6112245760008360020b131561112c57611034620d89e719611721565b91505b8260020b8260020b13156110b85760405163c0ac75cf60e01b8152600283900b60048201526001600160a01b0385169063c0ac75cf906024016040805180830381865afa15801561108c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110b0919061177e565b509150611037565b60405163c0ac75cf60e01b8152600283900b60048201526001600160a01b0385169063c0ac75cf906024016040805180830381865afa1580156110ff573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611123919061177e565b91506112249050565b50620d89e7195b8260020b8160020b12156111b55760405163c0ac75cf60e01b8152600282900b60048201526001600160a01b0385169063c0ac75cf906024016040805180830381865afa158015611188573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111ac919061177e565b91506111339050565b60405163c0ac75cf60e01b8152600282900b60048201526001600160a01b0385169063c0ac75cf906024016040805180830381865afa1580156111fc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611220919061177e565b5091505b9250929050565b600081831161123a5781610501565b5090919050565b60008160000361125357506000919050565b60005b821561044e57611267600a846116b4565b9250611272816117ad565b9050611256565b806001600160801b038116811461128f57600080fd5b919050565b60006112a1848484610454565b9050600082806112b3576112b361169e565b84860911156105015760001981106112ca57600080fd5b80610e31816117ad565b60405180604001604052806002906020820280368337509192915050565b6001600160a01b038116811461130757600080fd5b50565b8060020b811461130757600080fd5b600080600080600060a0868803121561133157600080fd5b853561133c816112f2565b9450602086013561134c8161130a565b9350604086013561135c8161130a565b94979396509394606081013594506080013592915050565b6000806000806080858703121561138a57600080fd5b8435611395816112f2565b935060208501356113a58161130a565b925060408501356113b58161130a565b915060608501356001600160801b03811681146113d157600080fd5b939692955090935050565b6000806000606084860312156113f157600080fd5b83356113fc816112f2565b9250602084013561140c8161130a565b9150604084013561141c8161130a565b809150509250925092565b60408101818360005b600280821061143f5750611457565b8251900b835260209283019290910190600101611430565b50505092915050565b60006020828403121561147257600080fd5b8135610501816112f2565b60008060006060848603121561149257600080fd5b505081359360208301359350604090920135919050565b600080604083850312156114bc57600080fd5b82356114c7816112f2565b915060208301356114d7816112f2565b809150509250929050565b600080600080608085870312156114f857600080fd5b8451611503816112f2565b60208601519094506115148161130a565b60408601519093506115258161130a565b606086015190925080151581146113d157600080fd5b60006020828403121561154d57600080fd5b81516105018161130a565b60006020828403121561156a57600080fd5b8151610501816112f2565b60006020828403121561158757600080fd5b815160ff8116811461050157600080fd5b634e487b7160e01b600052601160045260246000fd5b600181815b808511156115e95781600019048211156115cf576115cf611598565b808516156115dc57918102915b93841c93908002906115b3565b509250929050565b6000826116005750600161044e565b8161160d5750600061044e565b8160018114611623576002811461162d57611649565b600191505061044e565b60ff84111561163e5761163e611598565b50506001821b61044e565b5060208310610133831016604e8410600b841016171561166c575081810a61044e565b61167683836115ae565b806000190482111561168a5761168a611598565b029392505050565b600061050183836115f1565b634e487b7160e01b600052601260045260246000fd5b6000826116c3576116c361169e565b500490565b8181038181111561044e5761044e611598565b8082018082111561044e5761044e611598565b808202811582820484141761044e5761044e611598565b6000600160ff1b820161171a5761171a611598565b5060000390565b60008160020b627fffff19810361173a5761173a611598565b60000392915050565b6000826117525761175261169e565b500690565b6001600160a01b0382811682821603908082111561177757611777611598565b5092915050565b6000806040838503121561179157600080fd5b825161179c8161130a565b60208401519092506114d78161130a565b6000600182016117bf576117bf611598565b506001019056fea2646970667358221220bf5142b5dc288ec997919b6dc54b837983344ed446791fc79690ea241d1647dd64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "getPrice(address,address)": {
        "returns": {
          "_0": "price with decimals of paired token"
        }
      },
      "mulDiv(uint256,uint256,uint256)": {
        "details": "Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv",
        "params": {
          "a": "The multiplicand",
          "b": "The multiplier",
          "denominator": "The divisor"
        },
        "returns": {
          "result": "The 256-bit result"
        }
      }
    },
    "stateVariables": {
      "MAX_SQRT_RATIO": {
        "details": "The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)"
      },
      "MAX_TICK": {
        "details": "The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128"
      },
      "MIN_SQRT_RATIO": {
        "details": "The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)"
      },
      "MIN_TICK": {
        "details": "The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128"
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getAmountsForLiquidity(uint160,int24,int24,uint128)": {
        "notice": "Computes the token0 and token1 value for a given amount of liquidity, the current pool prices and the prices at the tick boundaries"
      },
      "getLiquidityForAmounts(uint160,int24,int24,uint256,uint256)": {
        "notice": "Computes the maximum amount of liquidity received for a given amount of token0, token1, the current pool prices and the prices at the tick boundaries"
      },
      "getPrice(address,address)": {
        "notice": "Calculates price in pool"
      },
      "mulDiv(uint256,uint256,uint256)": {
        "notice": "Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint or denominator == 0"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}