{
  "address": "0xf696eAB7b15f3C8A32582093Fc204884B5630508",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "investedAssetsBefore",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "investedAssetsOut",
          "type": "uint256"
        }
      ],
      "name": "FixPriceChanges",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "LiquidationThresholdChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "ReinvestThresholdPercentChanged",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lossCovered",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lossUncovered",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "investedAssetsBefore",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "investedAssetsAfter",
          "type": "uint256"
        }
      ],
      "name": "UncoveredLoss",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "sentAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "unsentAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "balance",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "totalAssets",
          "type": "uint256"
        }
      ],
      "name": "UnsentAmountToInsurance",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "HARDWORK_LOSS_TOLERANCE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PRICE_CHANGE_PROFIT_TOLERANCE",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ITetuConverter",
          "name": "converter",
          "type": "ITetuConverter"
        },
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getAssetPriceFromConverter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "tokens_",
          "type": "address[]"
        },
        {
          "internalType": "uint256",
          "name": "indexAsset",
          "type": "uint256"
        }
      ],
      "name": "getAvailableBalances",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ITetuConverter",
          "name": "converter",
          "type": "ITetuConverter"
        },
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "getOracleAssetsPrices",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "priceA",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "priceB",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xe4f81c5c9d57eca165755c3ab1990091fbf563f5e4e7d64523790c587a287349",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0xf696eAB7b15f3C8A32582093Fc204884B5630508",
    "transactionIndex": 44,
    "gasUsed": "2926498",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000400000008000000000000000800000000000800000000100000000000000000000000000000000000000000000000000000800100080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000008000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x8f71213bcf6c56d93129fc9b523b3ac2c0189b2f751376d979deae6b819ce46b",
    "transactionHash": "0xe4f81c5c9d57eca165755c3ab1990091fbf563f5e4e7d64523790c587a287349",
    "logs": [
      {
        "transactionIndex": 44,
        "blockNumber": 46246024,
        "transactionHash": "0xe4f81c5c9d57eca165755c3ab1990091fbf563f5e4e7d64523790c587a287349",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bbbbb8c4364ec2ce52c59d2ed3e56f307e529a94",
          "0x00000000000000000000000083d69448f88bf9c701c1b93f43e1f753d39b2632"
        ],
        "data": "0x00000000000000000000000000000000000000000000000001424eaacd80ac0000000000000000000000000000000000000000000000000a8d3d14331a5459c00000000000000000000000000000000000000000000004c9658330bb76372e2900000000000000000000000000000000000000000000000a8bfac5884cd3adc00000000000000000000000000000000000000000000004c966c57f6643b7da29",
        "logIndex": 208,
        "blockHash": "0x8f71213bcf6c56d93129fc9b523b3ac2c0189b2f751376d979deae6b819ce46b"
      }
    ],
    "blockNumber": 46246024,
    "cumulativeGasUsed": "12994183",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 10,
  "solcInputHash": "558b39190e0fb33c747b822350e63a15",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investedAssetsBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investedAssetsOut\",\"type\":\"uint256\"}],\"name\":\"FixPriceChanges\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LiquidationThresholdChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReinvestThresholdPercentChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lossCovered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lossUncovered\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investedAssetsBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investedAssetsAfter\",\"type\":\"uint256\"}],\"name\":\"UncoveredLoss\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"sentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"unsentAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"balance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"totalAssets\",\"type\":\"uint256\"}],\"name\":\"UnsentAmountToInsurance\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"HARDWORK_LOSS_TOLERANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PRICE_CHANGE_PROFIT_TOLERANCE\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITetuConverter\",\"name\":\"converter\",\"type\":\"ITetuConverter\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getAssetPriceFromConverter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens_\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"indexAsset\",\"type\":\"uint256\"}],\"name\":\"getAvailableBalances\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITetuConverter\",\"name\":\"converter\",\"type\":\"ITetuConverter\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getOracleAssetsPrices\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"priceA\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"priceB\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"calcInvestedAssets(address[],uint256[],uint256,ITetuConverter)\":{\"details\":\"This is writable function because we need to update current balances in the internal protocols.\",\"params\":{\"indexAsset\":\"Index of the underlying (main asset) in {tokens}\"},\"returns\":{\"amountOut\":\"Invested asset amount under control (in terms of underlying)\"}},\"claimConverterRewards(ITetuConverter,address[],address[],uint256[],uint256[])\":{\"details\":\"The post-processing is rewards conversion to the main asset\",\"params\":{\"amountsOut\":\"Amounts of available rewards\",\"rewardTokens_\":\"Amounts of rewards claimed from the internal pool\",\"tokensOut\":\"List of available rewards - not zero amounts, reward tokens don't repeat\",\"tokens_\":\"tokens received from {_depositorPoolAssets}\"}},\"getLiquidityAmount(uint256,address,address[],uint256,ITetuConverter,uint256,uint256)\":{\"details\":\"This is a writable function with read-only behavior (because of the quote-call)\",\"params\":{\"strategy_\":\"Address of the strategy\",\"targetAmount_\":\"Required amount of main asset to be withdrawn from the strategy; 0 - withdraw all\"},\"returns\":{\"amountsToConvertOut\":\"Amounts of {tokens} that should be converted to the main asset\",\"resultAmount\":\"Amount of liquidity that should be withdrawn from the pool, cannot exceed depositorLiquidity\"}},\"getTokenAmountsPair(ITetuConverter,uint256,address,address,uint256[2])\":{\"params\":{\"liquidationThresholdsAB\":\"[liquidityThreshold of token A, liquidityThreshold of tokenB]\"},\"returns\":{\"loss\":\"New total assets - old total assets\",\"tokenAmounts\":\"Balances of the token A and token B.                     If any balance is zero it's not possible to enter to the pool, so return empty array (len 0)\"}},\"postWithdrawActions(ITetuConverter,address[],uint256,uint256[],uint256,uint256,uint256[],uint256[])\":{\"params\":{\"amountsToConvert\":\"Amounts of {tokens} to be converted, they are located on the balance before withdraw\",\"withdrawnAmounts\":\"Amounts of {tokens} that were withdrew from the pool\"}},\"sendToInsurance(address,uint256,address,uint256)\":{\"params\":{\"totalAssets_\":\"Total strategy balance = balance of underlying + current invested assets amount\"},\"returns\":{\"sentAmount\":\"Amount of underlying sent to the insurance\",\"unsentAmount\":\"Missed part of the {amount} that were not sent to the insurance\"}}},\"stateVariables\":{\"HARDWORK_LOSS_TOLERANCE\":{\"details\":\"0.5% of max loss for strategy TVL\"},\"PRICE_CHANGE_PROFIT_TOLERANCE\":{\"details\":\"0.5% of max profit for strategy TVL\"}},\"version\":1},\"userdoc\":{\"events\":{\"UncoveredLoss(uint256,uint256,uint256,uint256)\":{\"notice\":\"Compensation of losses is not carried out completely\"},\"UnsentAmountToInsurance(uint256,uint256,uint256,uint256)\":{\"notice\":\"Payment to insurance was carried out only partially\"}},\"kind\":\"user\",\"methods\":{\"HARDWORK_LOSS_TOLERANCE()\":{\"notice\":\"Same value as StrategySplitterV2.HARDWORK_LOSS_TOLERANCE\"},\"PRICE_CHANGE_PROFIT_TOLERANCE()\":{\"notice\":\"Limit max amount of profit that can be send to insurance after price changing\"},\"calcInvestedAssets(address[],uint256[],uint256,ITetuConverter)\":{\"notice\":\"Calculate amount we will receive when we withdraw all from pool\"},\"claimConverterRewards(ITetuConverter,address[],address[],uint256[],uint256[])\":{\"notice\":\"Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\"},\"coverLossAfterPriceChanging(uint256,uint256,IStrategyV3.BaseState storage)\":{\"notice\":\"Register income and cover possible loss after price changing, emit FixPriceChanges\"},\"getAvailableBalances(address[],uint256)\":{\"notice\":\"Get balances of the {tokens_} except balance of the token at {indexAsset} position\"},\"getLiquidityAmount(uint256,address,address[],uint256,ITetuConverter,uint256,uint256)\":{\"notice\":\"Calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18         User needs to withdraw {targetAmount_} in main asset.         There are two kinds of available liquidity:         1) liquidity in the pool - {depositorLiquidity_}         2) Converted amounts on balance of the strategy - {baseAmounts_}         To withdraw {targetAmount_} we need         1) Reconvert converted amounts back to main asset         2) IF result amount is not necessary - withdraw some liquidity from the pool            and also convert it to the main asset.\"},\"getOracleAssetsPrices(ITetuConverter,address,address)\":{\"notice\":\"Get prices of {tokenA} and {tokenB}\"},\"getTokenAmountsPair(ITetuConverter,uint256,address,address,uint256[2])\":{\"notice\":\"Calculate the token amounts for deposit and amount of loss (as old-total-asset - new-total-asset)\"},\"postWithdrawActions(ITetuConverter,address[],uint256,uint256[],uint256,uint256,uint256[],uint256[])\":{\"notice\":\"Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\"},\"postWithdrawActionsEmpty(ITetuConverter,address[],uint256,uint256[])\":{\"notice\":\"return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\"},\"sendToInsurance(address,uint256,address,uint256)\":{\"notice\":\"Send given amount of underlying to the insurance\"}},\"notice\":\"Continuation of ConverterStrategyBaseLib (workaround for size limits)\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/ConverterStrategyBaseLib2.sol\":\"ConverterStrategyBaseLib2\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IController {\\n\\n  // --- DEPENDENCY ADDRESSES\\n  function governance() external view returns (address);\\n\\n  function voter() external view returns (address);\\n\\n  function liquidator() external view returns (address);\\n\\n  function forwarder() external view returns (address);\\n\\n  function investFund() external view returns (address);\\n\\n  function veDistributor() external view returns (address);\\n\\n  function platformVoter() external view returns (address);\\n\\n  // --- VAULTS\\n\\n  function vaults(uint id) external view returns (address);\\n\\n  function vaultsList() external view returns (address[] memory);\\n\\n  function vaultsListLength() external view returns (uint);\\n\\n  function isValidVault(address _vault) external view returns (bool);\\n\\n  // --- restrictions\\n\\n  function isOperator(address _adr) external view returns (bool);\\n\\n\\n}\\n\",\"keccak256\":\"0x86716b8a4775605c31b8bb9f90f8f4a18b709ff4435182f3a148803368060a8c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x5f43ed533d0fc4dc2f8f081d2c4b77960f3e908d5f7359096b385e5673f1ba0c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n     */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n     */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n     */\\n  function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x953f20efa64081a325109a0e03602b889d2819c2b51c1e1fb21a062feeda74f3\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x9f69f84d864c2a84de9321871aa52f6f70d14afe46badbcd37c0d4f22af75e7b\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IForwarder {\\n\\n  function tetu() external view returns (address);\\n  function tetuThreshold() external view returns (uint);\\n\\n  function tokenPerDestinationLength(address destination) external view returns (uint);\\n\\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\\n\\n  function amountPerDestination(address token, address destination) external view returns (uint amount);\\n\\n  function registerIncome(\\n    address[] memory tokens,\\n    uint[] memory amounts,\\n    address vault,\\n    bool isDistribute\\n  ) external;\\n\\n  function distributeAll(address destination) external;\\n\\n  function distribute(address token) external;\\n\\n  function setInvestFundRatio(uint value) external;\\n\\n  function setGaugesRatio(uint value) external;\\n\\n}\\n\",\"keccak256\":\"0x687c497fc034e8d64bca403bac1bf4cd7bd1f107df414c2657325c1b3ab92822\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ISplitter {\\n\\n  function init(address controller_, address _asset, address _vault) external;\\n\\n  // *************** ACTIONS **************\\n\\n  function withdrawAllToVault() external;\\n\\n  function withdrawToVault(uint256 amount) external;\\n\\n  function coverPossibleStrategyLoss(uint earned, uint lost) external;\\n\\n  function doHardWork() external;\\n\\n  function investAll() external;\\n\\n  // **************** VIEWS ***************\\n\\n  function asset() external view returns (address);\\n\\n  function vault() external view returns (address);\\n\\n  function totalAssets() external view returns (uint256);\\n\\n  function isHardWorking() external view returns (bool);\\n\\n  function strategies(uint i) external view returns (address);\\n\\n  function strategiesLength() external view returns (uint);\\n\\n  function HARDWORK_DELAY() external view returns (uint);\\n\\n  function lastHardWorks(address strategy) external view returns (uint);\\n\\n  function pausedStrategies(address strategy) external view returns (bool);\\n\\n  function pauseInvesting(address strategy) external;\\n\\n  function continueInvesting(address strategy, uint apr) external;\\n\\n}\\n\",\"keccak256\":\"0x68f37a5089c98097159e7f18ef04c42d15e10e6c11602e47bc6092708c11e5fc\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IStrategyV2 {\\n\\n  function NAME() external view returns (string memory);\\n\\n  function strategySpecificName() external view returns (string memory);\\n\\n  function PLATFORM() external view returns (string memory);\\n\\n  function STRATEGY_VERSION() external view returns (string memory);\\n\\n  function asset() external view returns (address);\\n\\n  function splitter() external view returns (address);\\n\\n  function compoundRatio() external view returns (uint);\\n\\n  function totalAssets() external view returns (uint);\\n\\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\\n  function isReadyToHardWork() external view returns (bool);\\n\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawAllToSplitter() external returns (uint strategyLoss);\\n\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawToSplitter(uint amount) external returns (uint strategyLoss);\\n\\n  /// @notice Stakes everything the strategy holds into the reward pool.\\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\\n  ///                                       It can be false if we know exactly, that the amount is already actual.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function investAll(\\n    uint amount_,\\n    bool updateTotalAssetsBeforeInvest_\\n  ) external returns (\\n    uint strategyLoss\\n  );\\n\\n  function doHardWork() external returns (uint earned, uint lost);\\n\\n  function setCompoundRatio(uint value) external;\\n\\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\\n  ///         0 means no deposit is allowed at this moment\\n  function capacity() external view returns (uint);\\n\\n  /// @notice {performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\\n  function performanceReceiver() external view returns (address);\\n\\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\\n  /// @dev use FEE_DENOMINATOR\\n  function performanceFee() external view returns (uint);\\n}\\n\",\"keccak256\":\"0xc7dac6097df7310b510f1027ef9c1bd3ccd6a202ca69582f68233ee798f7c312\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IStrategyV2.sol\\\";\\n\\ninterface IStrategyV3 is IStrategyV2 {\\n  struct BaseState {\\n    /// @dev Underlying asset\\n    address asset;\\n\\n    /// @dev Linked splitter\\n    address splitter;\\n\\n    /// @notice {performanceFee}% of total profit is sent to {performanceReceiver} before compounding\\n    /// @dev governance by default\\n    address performanceReceiver;\\n\\n    /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\\n    /// @dev {DEFAULT_PERFORMANCE_FEE} by default, FEE_DENOMINATOR is used\\n    uint performanceFee;\\n\\n    /// @notice Ratio to split performance fee on toPerf + toInsurance, [0..100_000]\\n    ///         100_000 - send full amount toPerf, 0 - send full amount toInsurance.\\n    uint performanceFeeRatio;\\n\\n    /// @dev Percent of profit for autocompound inside this strategy.\\n    uint compoundRatio;\\n\\n    /// @dev Represent specific name for this strategy. Should include short strategy name and used assets. Uniq across the vault.\\n    string strategySpecificName;\\n  }\\n}\\n\",\"keccak256\":\"0xe8a0179a82c40ba0c372486c5ebcc7df6431216c8c0d91cc408fb8f881e72f70\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface ITetuLiquidator {\\n\\n  struct PoolData {\\n    address pool;\\n    address swapper;\\n    address tokenIn;\\n    address tokenOut;\\n  }\\n\\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\\n\\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\\n\\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\\n\\n  function buildRoute(\\n    address tokenIn,\\n    address tokenOut\\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\\n\\n  function liquidate(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n  function liquidateWithRoute(\\n    PoolData[] memory route,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n\\n}\\n\",\"keccak256\":\"0xd5fe6f3ab750cc2d23f573597db5607c701e74c39e13c20c07a921a26c6d5012\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IVaultInsurance.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISplitter.sol\\\";\\n\\ninterface ITetuVaultV2 {\\n\\n  function splitter() external view returns (ISplitter);\\n\\n  function insurance() external view returns (IVaultInsurance);\\n\\n  function depositFee() external view returns (uint);\\n\\n  function withdrawFee() external view returns (uint);\\n\\n  function init(\\n    address controller_,\\n    IERC20 _asset,\\n    string memory _name,\\n    string memory _symbol,\\n    address _gauge,\\n    uint _buffer\\n  ) external;\\n\\n  function setSplitter(address _splitter) external;\\n\\n  function coverLoss(uint amount) external;\\n\\n  function initInsurance(IVaultInsurance _insurance) external;\\n\\n}\\n\",\"keccak256\":\"0x9e77a10b32a52f826d28d17c420f776fd289e5e4f925ec87f7177a1ce224a412\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IVaultInsurance {\\n\\n  function init(address _vault, address _asset) external;\\n\\n  function vault() external view returns (address);\\n\\n  function asset() external view returns (address);\\n\\n  function transferToVault(uint amount) external;\\n\\n}\\n\",\"keccak256\":\"0x6461572763b1f6decec1dee9d2ffe8ca152369bdc68255ec083cb3da3ce507a1\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        // only check isContract if the call was successful and the return data is empty\\n        // otherwise we already know that it was a contract\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n    // Look for revert reason and bubble it up if present\\n    if (returndata.length > 0) {\\n      // The easiest way to bubble the revert reason is using memory via assembly\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xcc7eeaafd4384e04ff39e0c01f0a6794736c34cad529751b8abd7b088ecc2e83\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n  enum Rounding {\\n    Down, // Toward negative infinity\\n    Up, // Toward infinity\\n    Zero // Toward zero\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b - 1) / b can overflow on addition, so we distribute.\\n    return a == 0 ? 0 : (a - 1) / b + 1;\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n  unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly {\\n      let mm := mulmod(x, y, not(0))\\n      prod0 := mul(x, y)\\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n      return prod0 / denominator;\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly {\\n    // Compute remainder using mulmod.\\n      remainder := mulmod(x, y, denominator)\\n\\n    // Subtract 256 bit number from 512 bit number.\\n      prod1 := sub(prod1, gt(remainder, prod0))\\n      prod0 := sub(prod0, remainder)\\n    }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n    // See https://cs.stackexchange.com/q/138556/92363.\\n\\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\\n    uint256 twos = denominator & (~denominator + 1);\\n    assembly {\\n    // Divide denominator by twos.\\n      denominator := div(denominator, twos)\\n\\n    // Divide [prod1 prod0] by twos.\\n      prod0 := div(prod0, twos)\\n\\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n      twos := add(div(sub(0, twos), twos), 1)\\n    }\\n\\n    // Shift in bits from prod1 into prod0.\\n    prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n    uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n    // in modular arithmetic, doubling the correct bits in each step.\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n    result = prod0 * inverse;\\n    return result;\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator,\\n    Rounding rounding\\n  ) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n  unchecked {\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    return min(result, a / result);\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = sqrt(a);\\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 128;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 64;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 32;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 16;\\n    }\\n    if (value >> 8 > 0) {\\n      value >>= 8;\\n      result += 8;\\n    }\\n    if (value >> 4 > 0) {\\n      value >>= 4;\\n      result += 4;\\n    }\\n    if (value >> 2 > 0) {\\n      value >>= 2;\\n      result += 2;\\n    }\\n    if (value >> 1 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log2(value);\\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >= 10**64) {\\n      value /= 10**64;\\n      result += 64;\\n    }\\n    if (value >= 10**32) {\\n      value /= 10**32;\\n      result += 32;\\n    }\\n    if (value >= 10**16) {\\n      value /= 10**16;\\n      result += 16;\\n    }\\n    if (value >= 10**8) {\\n      value /= 10**8;\\n      result += 8;\\n    }\\n    if (value >= 10**4) {\\n      value /= 10**4;\\n      result += 4;\\n    }\\n    if (value >= 10**2) {\\n      value /= 10**2;\\n      result += 2;\\n    }\\n    if (value >= 10**1) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log10(value);\\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 16;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 8;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 4;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 2;\\n    }\\n    if (value >> 8 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log256(value);\\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n  }\\n  }\\n}\\n\",\"keccak256\":\"0x2c5be0f4a60126b08e20f40586958ec1b76a27b69406c4b0db19e9dc6f771cfc\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n  unchecked {\\n    uint256 oldAllowance = token.allowance(address(this), spender);\\n    require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n    uint256 newAllowance = oldAllowance - value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n  }\\n\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x2378ee07b24e40c75781b27b2aa0812769c0000964e2d2501e3d234d3285dd18\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/SafeERC20.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\n\\nlibrary StrategyLib {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Denominator for fee calculation.\\n  uint internal constant FEE_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        EVENTS\\n  // *************************************************************\\n\\n  event CompoundRatioChanged(uint oldValue, uint newValue);\\n  event StrategySpecificNameChanged(string name);\\n  event EmergencyExit(address sender, uint amount);\\n  event ManualClaim(address sender);\\n  event InvestAll(uint balance);\\n  event WithdrawAllToSplitter(uint amount);\\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\\n\\n  // *************************************************************\\n  //                        ERRORS\\n  // *************************************************************\\n\\n  string internal constant DENIED = \\\"SB: Denied\\\";\\n  string internal constant TOO_HIGH = \\\"SB: Too high\\\";\\n  string internal constant WRONG_VALUE = \\\"SB: Wrong value\\\";\\n  /// @dev Denominator for compound ratio\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        CHECKS AND EMITS\\n  // *************************************************************\\n\\n  function _checkCompoundRatioChanged(address controller, uint oldValue, uint newValue) external {\\n    onlyPlatformVoter(controller);\\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\\n    emit CompoundRatioChanged(oldValue, newValue);\\n  }\\n\\n  function _checkStrategySpecificNameChanged(address controller, string calldata newName) external {\\n    onlyOperators(controller);\\n    emit StrategySpecificNameChanged(newName);\\n  }\\n\\n  function _checkManualClaim(address controller) external {\\n    onlyOperators(controller);\\n    emit ManualClaim(msg.sender);\\n  }\\n\\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\\n    onlySplitter(splitter);\\n    assetBalance = IERC20(asset).balanceOf(address(this));\\n    emit InvestAll(assetBalance);\\n  }\\n\\n  // *************************************************************\\n  //                     RESTRICTIONS\\n  // *************************************************************\\n\\n  /// @dev Restrict access only for operators\\n  function onlyOperators(address controller) public view {\\n    require(IController(controller).isOperator(msg.sender), DENIED);\\n  }\\n\\n  /// @dev Restrict access only for governance\\n  function onlyGovernance(address controller) public view {\\n    require(IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for platform voter\\n  function onlyPlatformVoter(address controller) public view {\\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for splitter\\n  function onlySplitter(address splitter) public view {\\n    require(splitter == msg.sender, DENIED);\\n  }\\n\\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_) external view {\\n    onlyGovernance(controller);\\n    require(fee_ <= 100_000, TOO_HIGH);\\n    require(receiver_ != address(0), WRONG_VALUE);\\n  }\\n\\n  // *************************************************************\\n  //                       HELPERS\\n  // *************************************************************\\n\\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\\n  ///         Revert if the amount is different from expected too much (high price impact)\\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\\n  /// @param assetPrice Price of the asset, decimals 18\\n  /// @return balance Current asset balance of the strategy\\n  function checkWithdrawImpact(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) public view returns (uint balance) {\\n    balance = IERC20(_asset).balanceOf(address(this));\\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\\n\\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\\n    }\\n  }\\n\\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\\n    onlyOperators(controller);\\n\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    IERC20(asset).safeTransfer(splitter, balance);\\n    emit EmergencyExit(msg.sender, balance);\\n  }\\n\\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\\n    onlySplitter(splitter);\\n    return IERC20(asset).balanceOf(address(this));\\n  }\\n\\n  function _withdrawAllToSplitterPostActions(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) external {\\n    uint balance = checkWithdrawImpact(\\n      _asset,\\n      balanceBefore,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n\\n    if (balance != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, balance);\\n    }\\n    emit WithdrawAllToSplitter(balance);\\n  }\\n\\n  function _withdrawToSplitterPostActions(\\n    uint amount,\\n    uint balance,\\n    address _asset,\\n    address _splitter\\n  ) external {\\n    uint amountAdjusted = Math.min(amount, balance);\\n    if (amountAdjusted != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\\n    }\\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\\n  }\\n}\\n\",\"keccak256\":\"0x81940f83bfee07d985fc82504e764db61673f99ae82e1d323f64f51843b7ef9f\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/// @notice Keep and provide addresses of all application contracts\\ninterface IConverterController {\\n  function governance() external view returns (address);\\n\\n  // ********************* Health factor explanation  ****************\\n  // For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\\n  // For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\\n  // We set min-health-factor = 1.1, target-health-factor = 1.3\\n  // For collateral 100 we will borrow 100/1.3 = 76.92\\n  //\\n  // Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\\n  // Collateral * LT    85         65.45\\n  // Borrow value       65.38      65.38         but borrow value is the same as before\\n  // Health factor      1.3        1.001         liquidation almost happens here (!)\\n  //\\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\\n  // and the borrow value won't change at the same time, the liquidation happens at that point.\\n  // Min health factor marks the point at which a rebalancing must be made asap.\\n  // *****************************************************************\\n\\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\\n  function minHealthFactor2() external view returns (uint16);\\n  function setMinHealthFactor2(uint16 value_) external;\\n\\n  /// @notice target health factor with decimals 2\\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\\n  ///      or additional borrow and restore the health factor to the given target value\\n  function targetHealthFactor2() external view returns (uint16);\\n  function setTargetHealthFactor2(uint16 value_) external;\\n\\n  /// @notice max allowed health factor with decimals 2\\n  /// @dev For future versions, currently max health factor is not used\\n  function maxHealthFactor2() external view returns (uint16);\\n  /// @dev For future versions, currently max health factor is not used\\n  function setMaxHealthFactor2(uint16 value_) external;\\n\\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\\n  function blocksPerDay() external view returns (uint);\\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\\n  /// @notice Check if it's time to call updateBlocksPerDay()\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\\n  /// @notice Recalculate blocksPerDay value\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function updateBlocksPerDay(uint periodInSeconds_) external;\\n\\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\\n  function paused() external view returns (bool);\\n\\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\\n  function isWhitelisted(address user_) external view returns (bool);\\n\\n  /// @notice The size of the gap by which the debt should be increased upon repayment\\n  ///         Such gaps are required by AAVE pool adapters to workaround dust tokens problem\\n  ///         and be able to make full repayment.\\n  /// @dev Debt gap is applied as following: toPay = debt * (DEBT_GAP_DENOMINATOR + debtGap) / DEBT_GAP_DENOMINATOR\\n  function debtGap() external view returns (uint);\\n\\n  //-----------------------------------------------------\\n  //        Core application contracts\\n  //-----------------------------------------------------\\n\\n  function tetuConverter() external view returns (address);\\n  function borrowManager() external view returns (address);\\n  function debtMonitor() external view returns (address);\\n  function tetuLiquidator() external view returns (address);\\n  function swapManager() external view returns (address);\\n  function priceOracle() external view returns (address);\\n\\n  //-----------------------------------------------------\\n  //        External contracts\\n  //-----------------------------------------------------\\n  /// @notice A keeper to control health and efficiency of the borrows\\n  function keeper() external view returns (address);\\n  /// @notice Controller of tetu-contracts-v2, that is allowed to update proxy contracts\\n  function proxyUpdater() external view returns (address);\\n}\\n\",\"keccak256\":\"0xefb20480cab050b2e178982481efc65babd931bdb6aeb4f0e10c58684cee43f1\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterControllerProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IConverterControllerProvider {\\n  function controller() external view returns (address);\\n}\\n\",\"keccak256\":\"0x71dce61809acb75f9078290e90033ffe816a51f18b7cb296d161e278c36eec86\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IPriceOracle {\\n  /// @notice Return asset price in USD, decimals 18\\n  function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb11e653eb4d6d7c41f29ee1e3e498253cfa8df1aec3ff31ab527009b79bdb705\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IConverterControllerProvider.sol\\\";\\n\\n/// @notice Main contract of the TetuConverter application\\n/// @dev Borrower (strategy) makes all operations via this contract only.\\ninterface ITetuConverter is IConverterControllerProvider {\\n\\n  /// @notice Find possible borrow strategies and provide \\\"cost of money\\\" as interest for the period for each strategy\\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converters Array of available converters ordered in ascending order of APR.\\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\\n  ///                    This address should be passed to borrow-function during conversion.\\n  ///                    The length of array is always equal to the count of available lending platforms.\\n  ///                    Last items in array can contain zero addresses (it means they are not used)\\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\\n  /// @return amountToBorrowsOut Amounts that should be borrowed\\n  ///                            This amount is not zero if corresponded converter is not zero.\\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\\n  function findBorrowStrategies(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external view returns (\\n    address[] memory converters,\\n    uint[] memory collateralAmountsOut,\\n    uint[] memory amountToBorrowsOut,\\n    int[] memory aprs18\\n  );\\n\\n  /// @notice Find best swap strategy and provide \\\"cost of money\\\" as interest for the period\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findSwapStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_\\n  ) external returns (\\n    address converter,\\n    uint sourceAmountOut,\\n    uint targetAmountOut,\\n    int apr18\\n  );\\n\\n  /// @notice Find best conversion strategy (swap or borrow) and provide \\\"cost of money\\\" as interest for the period.\\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findConversionStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external returns (\\n    address converter,\\n    uint collateralAmountOut,\\n    uint amountToBorrowOut,\\n    int apr18\\n  );\\n\\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\\n  ///      Only whitelisted users are allowed to make borrows\\n  /// @param converter_ A converter received from findBestConversionStrategy.\\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\\n  ///                          This amount must be approved to TetuConverter before the call.\\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\\n  /// @param receiver_ A receiver of borrowed amount\\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\\n  function borrow(\\n    address converter_,\\n    address collateralAsset_,\\n    uint collateralAmount_,\\n    address borrowAsset_,\\n    uint amountToBorrow_,\\n    address receiver_\\n  ) external returns (\\n    uint borrowedAmountOut\\n  );\\n\\n  /// @notice Full or partial repay of the borrow\\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        You can know exact total amount of debt using {getStatusCurrent}.\\n  ///        if the amount exceed total amount of the debt:\\n  ///           - the debt will be fully repaid\\n  ///           - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\\n  ///        This amount should be calculated with taking into account possible debt gap,\\n  ///        You should call getDebtAmountCurrent(debtGap = true) to get this amount.\\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\\n  ///         If TetuConverter is not able to make the swap, it reverts\\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\\n  ///                                 This amount is returned back to the collateralReceiver_\\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\\n  function repay(\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_,\\n    address receiver_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint returnedBorrowAmountOut,\\n    uint swappedLeftoverCollateralOut,\\n    uint swappedLeftoverBorrowOut\\n  );\\n\\n  /// @notice Estimate result amount after making full or partial repay\\n  /// @dev It works in exactly same way as repay() but don't make actual repay\\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\\n  /// @param user_ user whose amount-to-repay will be calculated\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        This amount should be calculated without possible debt gap.\\n  ///        In this way it's differ from {repay}\\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\\n  /// @return swappedAmountOut A part of {collateralAmountOut} that were received by direct swap\\n  function quoteRepay(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint swappedAmountOut\\n  );\\n\\n  /// @notice Update status in all opened positions\\n  ///         After this call getDebtAmount will be able to return exact amount to repay\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountCurrent(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountStored(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external view returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\\n  /// @param user_ user whose debts will be returned\\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\\n  ///                                           even if all borrowed amount will be returned.\\n  ///                                           If this amount is not 0, you ask to get too much collateral.\\n  function estimateRepay(\\n    address user_,\\n    address collateralAsset_,\\n    uint collateralAmountRequired_,\\n    address borrowAsset_\\n  ) external view returns (\\n    uint borrowAssetAmount,\\n    uint unobtainableCollateralAssetAmount\\n  );\\n\\n  /// @notice Transfer all reward tokens to {receiver_}\\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\\n  function claimRewards(address receiver_) external returns (\\n    address[] memory rewardTokensOut,\\n    uint[] memory amountsOut\\n  );\\n\\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\\n  ///                      It should be transferred on balance of the TetuConverter before the function call\\n  /// @param receiver_ Result amount will be sent to this address\\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\\n  function safeLiquidate(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    address receiver_,\\n    uint priceImpactToleranceSource_,\\n    uint priceImpactToleranceTarget_\\n  ) external returns (\\n    uint amountOut\\n  );\\n\\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\\n  function isConversionValid(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    uint amountOut_,\\n    uint priceImpactTolerance_\\n  ) external view returns (bool);\\n\\n  /// @notice Close given borrow and return collateral back to the user, governance only\\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\\n  /// @param poolAdapter_ The pool adapter that represents the borrow\\n  /// @param closePosition Close position after repay\\n  ///        Usually it should be true, because the function always tries to repay all debt\\n  ///        false can be used if user doesn't have enough amount to pay full debt\\n  ///              and we are trying to pay \\\"as much as possible\\\"\\n  /// @return collateralAmountOut Amount of collateral returned to the user\\n  /// @return repaidAmountOut Amount of borrow asset paid to the lending platform\\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\\n    uint collateralAmountOut,\\n    uint repaidAmountOut\\n  );\\n\\n  /// @notice Get active borrows of the user with given collateral/borrowToken\\n  /// @dev Simple access to IDebtMonitor.getPositions\\n  /// @return poolAdaptersOut The instances of IPoolAdapter\\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external view returns (\\n    address[] memory poolAdaptersOut\\n  );\\n\\n  /// @notice Save token from TC-balance to {receiver}\\n  /// @dev Normally TetuConverter doesn't have any tokens on balance, they can appear there accidentally only\\n  function salvage(address receiver, address token, uint amount) external;\\n}\\n\",\"keccak256\":\"0xd30f740004b39189b18ab99299e9d673ff48b754e053415130a6eda95558fa7d\",\"license\":\"MIT\"},\"contracts/libs/AppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice List of all errors generated by the application\\n///         Each error should have unique code TS-XXX and descriptive comment\\nlibrary AppErrors {\\n  /// @notice Provided address should be not zero\\n  string public constant ZERO_ADDRESS = \\\"TS-1 zero address\\\";\\n\\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\\n  string public constant UNISWAP_PAIR_NOT_FOUND = \\\"TS-2 pair not found\\\";\\n\\n  /// @notice Lengths not matched\\n  string public constant WRONG_LENGTHS = \\\"TS-4 wrong lengths\\\";\\n\\n  /// @notice Unexpected zero balance\\n  string public constant ZERO_BALANCE = \\\"TS-5 zero balance\\\";\\n\\n  string public constant ITEM_NOT_FOUND = \\\"TS-6 not found\\\";\\n\\n  string public constant NOT_ENOUGH_BALANCE = \\\"TS-7 not enough balance\\\";\\n\\n  /// @notice Price oracle returns zero price\\n  string public constant ZERO_PRICE = \\\"TS-8 zero price\\\";\\n\\n  string public constant WRONG_VALUE = \\\"TS-9 wrong value\\\";\\n\\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\\n  string public constant ZERO_AMOUNT_BORROWED = \\\"TS-10 zero borrowed amount\\\";\\n\\n  string public constant WITHDRAW_TOO_MUCH = \\\"TS-11 try to withdraw too much\\\";\\n\\n  string public constant UNKNOWN_ENTRY_KIND = \\\"TS-12 unknown entry kind\\\";\\n\\n  string public constant ONLY_TETU_CONVERTER = \\\"TS-13 only TetuConverter\\\";\\n\\n  string public constant WRONG_ASSET = \\\"TS-14 wrong asset\\\";\\n\\n  string public constant NO_LIQUIDATION_ROUTE = \\\"TS-15 No liquidation route\\\";\\n\\n  string public constant PRICE_IMPACT = \\\"TS-16 price impact\\\";\\n\\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\\n  string public constant REPAY_MAKES_SWAP = \\\"TS-17 can not convert back\\\";\\n\\n  string public constant NO_INVESTMENTS = \\\"TS-18 no investments\\\";\\n\\n  string public constant INCORRECT_LENGTHS = \\\"TS-19 lengths\\\";\\n\\n  /// @notice We expect increasing of the balance, but it was decreased\\n  string public constant BALANCE_DECREASE = \\\"TS-20 balance decrease\\\";\\n\\n  /// @notice Prices changed and invested assets amount was increased on S, value of S is too high\\n  string public constant EARNED_AMOUNT_TOO_HIGH = \\\"TS-21 earned too high\\\";\\n\\n  string public constant GOVERNANCE_ONLY = \\\"TS-22 governance only\\\";\\n\\n  /// @notice BorrowLib has recursive call, sub-calls are not allowed\\n  ///         This error can happen if allowed proportion is too small, i.e. 0.0004 : (1-0.0004)\\n  ///         Such situation can happen if amount to swap is almost equal to the amount of the token in the current tick,\\n  ///         so swap will move us close to the border between ticks.\\n  ///         It was decided, that it's ok to have revert in that case\\n  ///         We can change this behavior by changing BorrowLib.rebalanceRepayBorrow implementation:\\n  ///             if amount-to-repay passed to _repayDebt is too small to be used,\\n  ///             we should increase it min amount required to make repay successfully (amount must be > threshold)\\n  string public constant NOT_ALLOWED = \\\"TS-23 not allowed\\\";\\n\\n  string public constant ZERO_VALUE = \\\"TS-24 zero value\\\";\\n\\n  string public constant INCORRECT_SWAP_BY_AGG_PARAM = \\\"TS-25 swap by agg\\\";\\n\\n  string public constant OVER_COLLATERAL_DETECTED = \\\"TS-27 over-collateral\\\";\\n\\n  string public constant NOT_IMPLEMENTED = \\\"TS-28 not implemented\\\";\\n\\n  /// @notice You are not allowed to make direct debt if a NOT-DUST reverse debt exists and visa verse.\\n  string public constant OPPOSITE_DEBT_EXISTS = \\\"TS-29 opposite debt exists\\\";\\n\\n  string public constant INVALID_VALUE = \\\"TS-30 invalid value\\\";\\n\\n\\n\\n  string public constant TOO_HIGH = \\\"TS-32 too high value\\\";\\n}\\n\",\"keccak256\":\"0xe853be9ab228424c9b35d1aab918f415c5bdf6d7abd8e41aa96e879958d28576\",\"license\":\"MIT\"},\"contracts/libs/AppLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\\\";\\n\\n/// @notice Common internal utils\\nlibrary AppLib {\\n  using SafeERC20 for IERC20;\\n\\n  /// @notice 1% gap to cover possible liquidation inefficiency\\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\\n  uint internal constant GAP_CONVERSION = 1_000;\\n  /// @dev Absolute value for any token\\n  uint internal constant DEFAULT_LIQUIDATION_THRESHOLD = 100_000;\\n  uint internal constant DENOMINATOR = 100_000;\\n\\n  /// @notice Any amount less than the following is dust\\n  uint public constant DUST_AMOUNT_TOKENS = 100;\\n\\n  /// @notice Unchecked increment for for-cycles\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\n    unchecked {\\n      return i + 1;\\n    }\\n  }\\n\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\n  /// @dev Should NOT be used for third-party pools\\n  function approveIfNeeded(address token, uint amount, address spender) internal {\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\n      IERC20(token).safeApprove(spender, 0);\\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\\n      IERC20(token).safeApprove(spender, 2 ** 255);\\n    }\\n  }\\n\\n  function balance(address token) internal view returns (uint) {\\n    return IERC20(token).balanceOf(address(this));\\n  }\\n\\n  /// @return prices Asset prices in USD, decimals 18\\n  /// @return decs 10**decimals\\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\\n    uint[] memory prices,\\n    uint[] memory decs\\n  ) {\\n    prices = new uint[](len);\\n    decs = new uint[](len);\\n    {\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\\n    uint len = tokens_.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (tokens_[i] == asset_) {\\n        return i;\\n      }\\n    }\\n    return type(uint).max;\\n  }\\n\\n  function _getLiquidator(address controller_) internal view returns (ITetuLiquidator) {\\n    return ITetuLiquidator(IController(controller_).liquidator());\\n  }\\n\\n  function _getPriceOracle(ITetuConverter converter_) internal view returns (IPriceOracle) {\\n    return IPriceOracle(IConverterController(converter_.controller()).priceOracle());\\n  }\\n\\n  function _getLiquidationThreshold(uint threshold) internal pure returns (uint) {\\n    return threshold > AppLib.DEFAULT_LIQUIDATION_THRESHOLD\\n      ? threshold\\n      : AppLib.DEFAULT_LIQUIDATION_THRESHOLD;\\n  }\\n}\\n\",\"keccak256\":\"0xec016f72613ef55c74ea52f23aae3249924fab8e5a19808399f942e4188fb035\",\"license\":\"MIT\"},\"contracts/libs/ConverterEntryKinds.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\\nlibrary ConverterEntryKinds {\\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\\n\\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\\n  ///         C2 should be used as collateral to make a borrow B.\\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\\n\\n  /// @notice Borrow given amount using min possible collateral\\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\\n\\n  /// @notice Decode entryData, extract first uint - entry kind\\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\\n    if (entryData_.length == 0) {\\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\\n    }\\n    return abi.decode(entryData_, (uint));\\n  }\\n}\\n\",\"keccak256\":\"0x42e53e67f20fe11a5f5209e21f2d9b2ebeacdb197ae506ac796920907ea679a2\",\"license\":\"MIT\"},\"contracts/libs/TokenAmountsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./AppErrors.sol\\\";\\n\\n/// @title Library for clearing / joining token addresses & amounts arrays\\n/// @author bogdoslav\\nlibrary TokenAmountsLib {\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \\\"1.0.1\\\";\\n\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\n    unchecked {\\n      return i + 1;\\n    }\\n  }\\n\\n  function filterZeroAmounts(\\n    address[] memory tokens,\\n    uint[] memory amounts\\n  ) internal pure returns (\\n    address[] memory t,\\n    uint[] memory a\\n  ) {\\n    require(tokens.length == amounts.length, AppErrors.INCORRECT_LENGTHS);\\n    uint len2 = 0;\\n    uint len = tokens.length;\\n    for (uint i = 0; i < len; i++) {\\n      if (amounts[i] != 0) len2++;\\n    }\\n\\n    t = new address[](len2);\\n    a = new uint[](len2);\\n\\n    uint j = 0;\\n    for (uint i = 0; i < len; i++) {\\n      uint amount = amounts[i];\\n      if (amount != 0) {\\n        t[j] = tokens[i];\\n        a[j] = amount;\\n        j++;\\n      }\\n    }\\n  }\\n\\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\\n  function combineArrays(\\n    address[] memory tokens0,\\n    uint[] memory amounts0,\\n    address[] memory tokens1,\\n    uint[] memory amounts1,\\n    address[] memory tokens2,\\n    uint[] memory amounts2\\n  ) internal pure returns (\\n    address[] memory allTokens,\\n    uint[] memory allAmounts\\n  ) {\\n    uint[] memory lens = new uint[](3);\\n    lens[0] = tokens0.length;\\n    lens[1] = tokens1.length;\\n    lens[2] = tokens2.length;\\n\\n    require(\\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\\n      AppErrors.INCORRECT_LENGTHS\\n    );\\n\\n    uint maxLength = lens[0] + lens[1] + lens[2];\\n    address[] memory tokensOut = new address[](maxLength);\\n    uint[] memory amountsOut = new uint[](maxLength);\\n    uint unitedLength;\\n\\n    for (uint step; step < 3; ++step) {\\n      uint[] memory amounts = step == 0\\n        ? amounts0\\n        : (step == 1\\n          ? amounts1\\n          : amounts2);\\n      address[] memory tokens = step == 0\\n        ? tokens0\\n        : (step == 1\\n          ? tokens1\\n          : tokens2);\\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\\n        uint amount1 = amounts[i1];\\n        address token1 = tokens[i1];\\n        bool united = false;\\n\\n        for (uint i = 0; i < unitedLength; i++) {\\n          if (token1 == tokensOut[i]) {\\n            amountsOut[i] += amount1;\\n            united = true;\\n            break;\\n          }\\n        }\\n\\n        if (!united) {\\n          tokensOut[unitedLength] = token1;\\n          amountsOut[unitedLength] = amount1;\\n          unitedLength++;\\n        }\\n      }\\n    }\\n\\n    // copy united tokens to result array\\n    allTokens = new address[](unitedLength);\\n    allAmounts = new uint[](unitedLength);\\n    for (uint i; i < unitedLength; i++) {\\n      allTokens[i] = tokensOut[i];\\n      allAmounts[i] = amountsOut[i];\\n    }\\n\\n  }\\n}\\n\",\"keccak256\":\"0x6be459b8106584d7f9d3ad9f7a9fe6afa86bc41c5915c2d708715dba75c6174a\",\"license\":\"MIT\"},\"contracts/strategies/ConverterStrategyBaseLib2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV3.sol\\\";\\nimport \\\"../libs/AppErrors.sol\\\";\\nimport \\\"../libs/AppLib.sol\\\";\\nimport \\\"../libs/TokenAmountsLib.sol\\\";\\nimport \\\"../libs/ConverterEntryKinds.sol\\\";\\n\\n/// @notice Continuation of ConverterStrategyBaseLib (workaround for size limits)\\nlibrary ConverterStrategyBaseLib2 {\\n  using SafeERC20 for IERC20;\\n\\n//region --------------------------------------- Data types\\n  struct CalcInvestedAssetsLocal {\\n    uint len;\\n    uint[] prices;\\n    uint[] decs;\\n    uint[] debts;\\n    address asset;\\n    address token;\\n  }\\n//endregion --------------------------------------- Data types\\n\\n//region --------------------------------------- CONSTANTS\\n  uint internal constant DENOMINATOR = 100_000;\\n\\n  /// @dev 0.5% of max loss for strategy TVL\\n  /// @notice Same value as StrategySplitterV2.HARDWORK_LOSS_TOLERANCE\\n  uint public constant HARDWORK_LOSS_TOLERANCE = 500;\\n\\n  /// @dev 0.5% of max profit for strategy TVL\\n  /// @notice Limit max amount of profit that can be send to insurance after price changing\\n  uint public constant PRICE_CHANGE_PROFIT_TOLERANCE = HARDWORK_LOSS_TOLERANCE;\\n\\n//endregion --------------------------------------- CONSTANTS\\n\\n//region----------------------------------------- EVENTS\\n  event LiquidationThresholdChanged(address token, uint amount);\\n  event ReinvestThresholdPercentChanged(uint amount);\\n  event FixPriceChanges(uint investedAssetsBefore, uint investedAssetsOut);\\n  /// @notice Compensation of losses is not carried out completely\\n  event UncoveredLoss(uint lossCovered, uint lossUncovered, uint investedAssetsBefore, uint investedAssetsAfter);\\n  /// @notice Payment to insurance was carried out only partially\\n  event UnsentAmountToInsurance(uint sentAmount, uint unsentAmount, uint balance, uint totalAssets);\\n\\n//endregion----------------------------------------- EVENTS\\n\\n//region----------------------------------------- MAIN LOGIC\\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\\n  function getAvailableBalances(\\n    address[] memory tokens_,\\n    uint indexAsset\\n  ) external view returns (uint[] memory) {\\n    uint len = tokens_.length;\\n    uint[] memory amountsToConvert = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) continue;\\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this));\\n    }\\n    return amountsToConvert;\\n  }\\n\\n\\n  /// @notice Calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\\n  ///         User needs to withdraw {targetAmount_} in main asset.\\n  ///         There are two kinds of available liquidity:\\n  ///         1) liquidity in the pool - {depositorLiquidity_}\\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\\n  ///         To withdraw {targetAmount_} we need\\n  ///         1) Reconvert converted amounts back to main asset\\n  ///         2) IF result amount is not necessary - withdraw some liquidity from the pool\\n  ///            and also convert it to the main asset.\\n  /// @dev This is a writable function with read-only behavior (because of the quote-call)\\n  /// @param targetAmount_ Required amount of main asset to be withdrawn from the strategy; 0 - withdraw all\\n  /// @param strategy_ Address of the strategy\\n  /// @return resultAmount Amount of liquidity that should be withdrawn from the pool, cannot exceed depositorLiquidity\\n  /// @return amountsToConvertOut Amounts of {tokens} that should be converted to the main asset\\n  function getLiquidityAmount(\\n    uint targetAmount_,\\n    address strategy_,\\n    address[] memory tokens,\\n    uint indexAsset,\\n    ITetuConverter converter,\\n    uint investedAssets,\\n    uint depositorLiquidity\\n  ) external returns (\\n    uint resultAmount,\\n    uint[] memory amountsToConvertOut\\n  ) {\\n    bool all = targetAmount_ == 0;\\n\\n    uint len = tokens.length;\\n    amountsToConvertOut = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) continue;\\n\\n      address token = tokens[i];\\n      uint balance = IERC20(token).balanceOf(address(this));\\n      if (balance != 0) {\\n        // let's estimate collateral that we received back after repaying balance-amount\\n        (uint expectedCollateral,) = converter.quoteRepay(strategy_, tokens[indexAsset], token, balance);\\n\\n        if (all || targetAmount_ != 0) {\\n          // We always repay WHOLE available balance-amount even if it gives us much more amount then we need.\\n          // We cannot repay a part of it because converter doesn't allow to know\\n          // what amount should be repaid to get given amount of collateral.\\n          // And it's too dangerous to assume that we can calculate this amount\\n          // by reducing balance-amount proportionally to expectedCollateral/targetAmount_\\n          amountsToConvertOut[i] = balance;\\n        }\\n\\n        targetAmount_ = targetAmount_ > expectedCollateral\\n          ? targetAmount_ - expectedCollateral\\n          : 0;\\n\\n        investedAssets = investedAssets > expectedCollateral\\n          ? investedAssets - expectedCollateral\\n          : 0;\\n      }\\n    }\\n\\n    uint liquidityRatioOut = all || investedAssets == 0\\n      ? 1e18\\n      : ((targetAmount_ == 0)\\n        ? 0\\n        : 1e18\\n        * 101 // add 1% on top...\\n        * targetAmount_ / investedAssets // a part of amount that we are going to withdraw\\n        / 100 // .. add 1% on top\\n      );\\n\\n    resultAmount = liquidityRatioOut != 0\\n      ? Math.min(liquidityRatioOut * depositorLiquidity / 1e18, depositorLiquidity)\\n      : 0;\\n  }\\n\\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\\n  /// @dev The post-processing is rewards conversion to the main asset\\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\\n  /// @param rewardTokens_ List of rewards claimed from the internal pool\\n  /// @param rewardTokens_ Amounts of rewards claimed from the internal pool\\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\\n  /// @param amountsOut Amounts of available rewards\\n  function claimConverterRewards(\\n    ITetuConverter converter_,\\n    address[] memory tokens_,\\n    address[] memory rewardTokens_,\\n    uint[] memory rewardAmounts_,\\n    uint[] memory balancesBefore\\n  ) external returns (\\n    address[] memory tokensOut,\\n    uint[] memory amountsOut\\n  ) {\\n    // Rewards from TetuConverter\\n    (address[] memory tokensTC, uint[] memory amountsTC) = converter_.claimRewards(address(this));\\n\\n    // Join arrays and recycle tokens\\n    (tokensOut, amountsOut) = TokenAmountsLib.combineArrays(\\n      rewardTokens_, rewardAmounts_,\\n      tokensTC, amountsTC,\\n      // by default, depositor assets have zero amounts here\\n      tokens_, new uint[](tokens_.length)\\n    );\\n\\n    // set fresh balances for depositor tokens\\n    uint len = tokensOut.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      for (uint j; j < tokens_.length; j = AppLib.uncheckedInc(j)) {\\n        if (tokensOut[i] == tokens_[j]) {\\n          amountsOut[i] = IERC20(tokens_[j]).balanceOf(address(this)) - balancesBefore[j];\\n        }\\n      }\\n    }\\n\\n    // filter zero amounts out\\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\\n  }\\n\\n  /// @notice Get prices of {tokenA} and {tokenB}\\n  function getOracleAssetsPrices(ITetuConverter converter, address tokenA, address tokenB) external view returns (\\n    uint priceA,\\n    uint priceB\\n  ) {\\n    IPriceOracle oracle = AppLib._getPriceOracle(converter);\\n    priceA = oracle.getAssetPrice(tokenA);\\n    priceB = oracle.getAssetPrice(tokenB);\\n  }\\n\\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\\n    return AppLib._getPriceOracle(converter).getAssetPrice(token);\\n  }\\n\\n  /// @notice Try to find zero amount\\n  /// @return True if {amounts_} array contains zero amount\\n  function findZeroAmount(uint[] memory amounts_) internal pure returns (bool) {\\n    uint len = amounts_.length;\\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (amounts_[i] == 0) return true;\\n    }\\n    return false;\\n  }\\n//endregion ----------------------------------------- MAIN LOGIC\\n\\n//region -------------------------------------------- Cover loss, send profit to insurance\\n  /// @notice Send given amount of underlying to the insurance\\n  /// @param totalAssets_ Total strategy balance = balance of underlying + current invested assets amount\\n  /// @return sentAmount Amount of underlying sent to the insurance\\n  /// @return unsentAmount Missed part of the {amount} that were not sent to the insurance\\n  function sendToInsurance(address asset, uint amount, address splitter, uint totalAssets_) external returns (\\n    uint sentAmount,\\n    uint unsentAmount\\n  ) {\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    uint amountToSend = Math.min(amount, balance);\\n    if (amountToSend != 0) {\\n      // max amount that can be send to insurance is limited by PRICE_CHANGE_PROFIT_TOLERANCE\\n\\n      // Amount limitation should be implemented in the same way as in StrategySplitterV2._coverLoss\\n      // Revert or cut amount in both cases\\n\\n      require(totalAssets_ != 0, AppErrors.ZERO_BALANCE);\\n      amountToSend = Math.min(amountToSend, PRICE_CHANGE_PROFIT_TOLERANCE * totalAssets_ / 100_000);\\n      //require(amountToSend <= PRICE_CHANGE_PROFIT_TOLERANCE * strategyBalance / 100_000, AppErrors.EARNED_AMOUNT_TOO_HIGH);\\n\\n      IERC20(asset).safeTransfer(address(ITetuVaultV2(ISplitter(splitter).vault()).insurance()), amountToSend);\\n    }\\n\\n    sentAmount = amountToSend;\\n    unsentAmount = amount > amountToSend\\n      ? amount - amountToSend\\n      : 0;\\n\\n    if (unsentAmount != 0) {\\n      emit UnsentAmountToInsurance(sentAmount, unsentAmount, balance, totalAssets_);\\n    }\\n  }\\n\\n  function _registerIncome(uint assetBefore, uint assetAfter) internal pure returns (uint earned, uint lost) {\\n    if (assetAfter > assetBefore) {\\n      earned = assetAfter - assetBefore;\\n    } else {\\n      lost = assetBefore - assetAfter;\\n    }\\n    return (earned, lost);\\n  }\\n\\n  /// @notice Register income and cover possible loss after price changing, emit FixPriceChanges\\n  function coverLossAfterPriceChanging(\\n    uint investedAssetsBefore,\\n    uint investedAssetsAfter,\\n    IStrategyV3.BaseState storage baseState\\n  ) external returns (uint earned) {\\n    uint lost;\\n    (earned, lost) = _registerIncome(investedAssetsBefore, investedAssetsAfter);\\n    if (lost != 0) {\\n      (uint lossToCover, uint lossUncovered) = getSafeLossToCover(\\n        lost,\\n        investedAssetsAfter + IERC20(baseState.asset).balanceOf(address(this)) // totalAssets\\n      );\\n      ISplitter(baseState.splitter).coverPossibleStrategyLoss(earned, lossToCover);\\n\\n      if (lossUncovered != 0) {\\n        emit UncoveredLoss(lossToCover, lossUncovered, investedAssetsBefore, investedAssetsAfter);\\n      }\\n    }\\n    emit FixPriceChanges(investedAssetsBefore, investedAssetsAfter);\\n  }\\n\\n  /// @notice Cut loss-value to safe value that doesn't produce revert inside splitter\\n  function getSafeLossToCover(uint loss, uint totalAssets_) internal pure returns (\\n    uint lossToCover,\\n    uint lossUncovered\\n  ) {\\n    // see StrategySplitterV2._declareStrategyIncomeAndCoverLoss, _coverLoss implementations\\n    lossToCover = Math.min(loss, HARDWORK_LOSS_TOLERANCE * totalAssets_ / 100_000);\\n    lossUncovered = loss > lossToCover\\n      ? loss - lossToCover\\n      : 0;\\n  }\\n//endregion -------------------------------------------- Cover loss, send profit to insurance\\n\\n//region ---------------------------------------- Setters\\n  function checkReinvestThresholdPercentChanged(address controller, uint percent_) external {\\n    StrategyLib.onlyOperators(controller);\\n    require(percent_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\\n    emit ReinvestThresholdPercentChanged(percent_);\\n  }\\n\\n  function checkLiquidationThresholdChanged(address controller, address token, uint amount) external {\\n    StrategyLib.onlyOperators(controller);\\n    emit LiquidationThresholdChanged(token, amount);\\n  }\\n//endregion ---------------------------------------- Setters\\n\\n//region ---------------------------------------- Withdraw helpers\\n  /// @notice Get amount of assets that we expect to receive after withdrawing\\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\\n  ///                  one of assets must be {asset_}\\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\\n  function getExpectedWithdrawnAmounts(\\n    uint[] memory reserves_,\\n    uint liquidityAmount_,\\n    uint totalSupply_\\n  ) internal pure returns (\\n    uint[] memory withdrawnAmountsOut\\n  ) {\\n    uint ratio = totalSupply_ == 0\\n      ? 0\\n      : (liquidityAmount_ >= totalSupply_\\n        ? 1e18\\n        : 1e18 * liquidityAmount_ / totalSupply_\\n      );\\n\\n    uint len = reserves_.length;\\n    withdrawnAmountsOut = new uint[](len);\\n\\n    if (ratio != 0) {\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\\n      }\\n    }\\n  }\\n\\n  /// @notice Calculate expected amount of the main asset after withdrawing\\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\\n  /// @return amountsOut Expected amounts of the main asset received after conversion withdrawnAmounts+amountsToConvert\\n  function getExpectedAmountMainAsset(\\n    address[] memory tokens,\\n    uint indexAsset,\\n    ITetuConverter converter,\\n    uint[] memory withdrawnAmounts_,\\n    uint[] memory amountsToConvert_\\n  ) internal returns (\\n    uint[] memory amountsOut\\n  ) {\\n    uint len = tokens.length;\\n    amountsOut = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) {\\n        amountsOut[i] = withdrawnAmounts_[i];\\n      } else {\\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\\n        if (amount != 0) {\\n          (amountsOut[i],) = converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\\n        }\\n      }\\n    }\\n\\n    return amountsOut;\\n  }\\n\\n  /// @notice Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\\n  /// @param amountsToConvert Amounts of {tokens} to be converted, they are located on the balance before withdraw\\n  /// @param withdrawnAmounts Amounts of {tokens} that were withdrew from the pool\\n  function postWithdrawActions(\\n    ITetuConverter converter,\\n    address[] memory tokens,\\n    uint indexAsset,\\n\\n    uint[] memory reservesBeforeWithdraw,\\n    uint liquidityAmountWithdrew,\\n    uint totalSupplyBeforeWithdraw,\\n\\n    uint[] memory amountsToConvert,\\n    uint[] memory withdrawnAmounts\\n  ) external returns (\\n    uint[] memory expectedMainAssetAmounts,\\n    uint[] memory _amountsToConvert\\n  ) {\\n    // estimate expected amount of assets to be withdrawn\\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\\n      reservesBeforeWithdraw,\\n      liquidityAmountWithdrew,\\n      totalSupplyBeforeWithdraw\\n    );\\n\\n    // from received amounts after withdraw calculate how much we receive from converter for them in terms of the underlying asset\\n    expectedMainAssetAmounts = getExpectedAmountMainAsset(\\n      tokens,\\n      indexAsset,\\n      converter,\\n      expectedWithdrawAmounts,\\n      amountsToConvert\\n    );\\n\\n    uint len = tokens.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      amountsToConvert[i] += withdrawnAmounts[i];\\n    }\\n\\n    return (expectedMainAssetAmounts, amountsToConvert);\\n  }\\n\\n  /// @notice return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\\n  function postWithdrawActionsEmpty(\\n    ITetuConverter converter,\\n    address[] memory tokens,\\n    uint indexAsset,\\n    uint[] memory amountsToConvert_\\n  ) external returns (\\n    uint[] memory expectedAmountsMainAsset\\n  ) {\\n    expectedAmountsMainAsset = getExpectedAmountMainAsset(\\n      tokens,\\n      indexAsset,\\n      converter,\\n      // there are no withdrawn amounts\\n      new uint[](tokens.length), // array with all zero values\\n      amountsToConvert_\\n    );\\n  }\\n//endregion ------------------------------------- Withdraw helpers\\n\\n//region---------------------------------------- calcInvestedAssets\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\n  /// @param indexAsset Index of the underlying (main asset) in {tokens}\\n  /// @return amountOut Invested asset amount under control (in terms of underlying)\\n  function calcInvestedAssets(\\n    address[] memory tokens,\\n    uint[] memory depositorQuoteExitAmountsOut,\\n    uint indexAsset,\\n    ITetuConverter converter_\\n  ) external returns (\\n    uint amountOut\\n  ) {\\n    return _calcInvestedAssets(tokens, depositorQuoteExitAmountsOut, indexAsset, converter_);\\n  }\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\n  /// @param indexAsset Index of the underlying (main asset) in {tokens}\\n  /// @return amountOut Invested asset amount under control (in terms of underlying)\\n  function _calcInvestedAssets(\\n    address[] memory tokens,\\n    uint[] memory depositorQuoteExitAmountsOut,\\n    uint indexAsset,\\n    ITetuConverter converter_\\n  ) internal returns (\\n    uint amountOut\\n  ) {\\n    CalcInvestedAssetsLocal memory v;\\n    v.len = tokens.length;\\n    v.asset = tokens[indexAsset];\\n\\n    // calculate prices, decimals\\n    (v.prices, v.decs) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(converter_), tokens, v.len);\\n\\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) {\\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\\n        amountOut += depositorQuoteExitAmountsOut[i];\\n      } else {\\n        v.token = tokens[i];\\n        // possible reverse debt: collateralAsset = tokens[i], borrowAsset = underlying\\n        // investedAssets is calculated using exact debts, debt-gaps are not taken into account\\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(address(this), v.token, v.asset, false);\\n        if (amountOut < toPay) {\\n          setDebt(v, indexAsset, toPay);\\n        } else {\\n          amountOut -= toPay;\\n        }\\n\\n        // available amount to repay\\n        uint toRepay = collateral + IERC20(v.token).balanceOf(address(this)) + depositorQuoteExitAmountsOut[i];\\n\\n        // direct debt: collateralAsset = underlying, borrowAsset = tokens[i]\\n        // investedAssets is calculated using exact debts, debt-gaps are not taken into account\\n        (toPay, collateral) = converter_.getDebtAmountCurrent(address(this), v.asset, v.token, false);\\n        amountOut += collateral;\\n\\n        if (toRepay >= toPay) {\\n          amountOut += (toRepay - toPay) * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\\n        } else {\\n          // there is not enough amount to pay the debt\\n          // let's register a debt and try to resolve it later below\\n          setDebt(v, i, toPay - toRepay);\\n        }\\n      }\\n    }\\n    if (v.debts.length == v.len) {\\n      // we assume here, that it would be always profitable to save collateral\\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n        if (v.debts[i] == 0) continue;\\n\\n        // estimatedAssets should be reduced on the debt-value\\n        // this estimation is approx and do not count price impact on the liquidation\\n        // we will able to count the real output only after withdraw process\\n        uint debtInAsset = v.debts[i] * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\\n        if (debtInAsset > amountOut) {\\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\\n          amountOut = 0;\\n        } else {\\n          amountOut -= debtInAsset;\\n        }\\n      }\\n    }\\n\\n    return amountOut;\\n  }\\n\\n  /// @notice Lazy initialization of v.debts, add {value} to {v.debts[index]}\\n  function setDebt(CalcInvestedAssetsLocal memory v, uint index, uint value) pure internal {\\n    if (v.debts.length == 0) {\\n      // lazy initialization\\n      v.debts = new uint[](v.len);\\n    }\\n\\n    // to pay the following amount we need to swap some other asset at first\\n    v.debts[index] += value;\\n  }\\n\\n  /// @notice Calculate the token amounts for deposit and amount of loss (as old-total-asset - new-total-asset)\\n  /// @param liquidationThresholdsAB [liquidityThreshold of token A, liquidityThreshold of tokenB]\\n  /// @return loss New total assets - old total assets\\n  /// @return tokenAmounts Balances of the token A and token B.\\n  ///                     If any balance is zero it's not possible to enter to the pool, so return empty array (len 0)\\n  function getTokenAmountsPair(\\n    ITetuConverter converter,\\n    uint totalAssets,\\n    address tokenA,\\n    address tokenB,\\n    uint[2] calldata liquidationThresholdsAB\\n  ) external returns (\\n    uint loss,\\n    uint[] memory tokenAmounts\\n  ) {\\n    tokenAmounts = new uint[](2);\\n    tokenAmounts[0] = AppLib.balance(tokenA);\\n    tokenAmounts[1] = AppLib.balance(tokenB);\\n\\n    address[] memory tokens = new address[](2);\\n    tokens[0] = tokenA;\\n    tokens[1] = tokenB;\\n\\n    uint[] memory amounts = new uint[](2);\\n    amounts[0] = tokenAmounts[0];\\n\\n    uint newTotalAssets = _calcInvestedAssets(tokens, amounts, 0, converter);\\n    return (\\n      newTotalAssets < totalAssets\\n        ? totalAssets - newTotalAssets\\n        : 0,\\n      (tokenAmounts[0] < AppLib._getLiquidationThreshold(liquidationThresholdsAB[0]))\\n      || (tokenAmounts[1] < AppLib._getLiquidationThreshold(liquidationThresholdsAB[1]))\\n        ? new uint[](0)\\n        : tokenAmounts\\n    );\\n  }\\n//endregion------------------------------------- calcInvestedAssets\\n}\\n\\n\",\"keccak256\":\"0x51a4417698212685ddb39d3e37184957a5ec6124134f62e74802b1c489e5d0a9\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x6133f961003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100ef5760003560e01c8063aac2718a116100a1578063d5ade5c111610070578063d5ade5c114610256578063e24a7eb214610269578063e99de4da14610289578063ec0cc4fd146102b757600080fd5b8063aac2718a146101b3578063ac2a37d6146101e8578063c9bce69014610216578063d2c3cf251461023657600080fd5b806309d28c57146100f4578063142395ef146101105780631997c9ee146100f45780636138ea85146101325780637a55caf31461015f5780637a9a23e51461017257806397783a6c146101a0575b600080fd5b6100fd6101f481565b6040519081526020015b60405180910390f35b81801561011c57600080fd5b5061013061012b36600461287a565b6102d7565b005b81801561013e57600080fd5b5061015261014d366004612a03565b610386565b6040516101079190612abd565b6100fd61016d366004612ad0565b6103e0565b81801561017e57600080fd5b5061019261018d366004612b09565b610460565b604051610107929190612be3565b6101526101ae366004612c08565b6104ed565b8180156101bf57600080fd5b506101d36101ce366004612c4c565b610600565b60408051928352602083019190915201610107565b8180156101f457600080fd5b50610208610203366004612c94565b61084b565b604051610107929190612cfd565b81801561022257600080fd5b506100fd610231366004612d16565b610a51565b81801561024257600080fd5b50610130610251366004612d95565b610a67565b6101d3610264366004612dc1565b610b53565b81801561027557600080fd5b506100fd610284366004612e0c565b610c4c565b81801561029557600080fd5b506102a96102a4366004612e38565b610dee565b604051610107929190612ef7565b8180156102c357600080fd5b506102086102d2366004612f57565b61101a565b60405163124fdbb760e21b8152733BEB969c0cd273eA1d7a39137a757Cf1c474510a9063493f6edc9061030e908690600401612fe0565b60006040518083038186803b15801561032657600080fd5b505af415801561033a573d6000803e3d6000fd5b5050604080516001600160a01b0386168152602081018590527f297f3fbc14027d2b4a4f7dac3dff2ad6b386024299045b0e163f131bb24b611d935001905060405180910390a1505050565b60606103d784848787516001600160401b038111156103a7576103a76128cb565b6040519080825280602002602001820160405280156103d0578160200160208202803683370190505b50866112d4565b95945050505050565b60006103eb836114b1565b6001600160a01b031663b3596f07836040518263ffffffff1660e01b81526004016104169190612fe0565b602060405180830381865afa158015610433573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104579190612ff4565b90505b92915050565b6060806000610470888888611576565b905061047f8a8a8d84896112d4565b8a5190935060005b818110156104da578581815181106104a1576104a161300d565b60200260200101518782815181106104bb576104bb61300d565b602002602001018181516104cf9190613039565b905250600101610487565b5085925050509850989650505050505050565b81516060906000816001600160401b0381111561050c5761050c6128cb565b604051908082528060200260200182016040528015610535578160200160208202803683370190505b50905060005b828110156105f7578085146105ef5785818151811061055c5761055c61300d565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161058f9190612fe0565b602060405180830381865afa1580156105ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105d09190612ff4565b8282815181106105e2576105e261300d565b6020026020010181815250505b60010161053b565b50949350505050565b6000806000866001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016106319190612fe0565b602060405180830381865afa15801561064e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106729190612ff4565b90506000610680878361167d565b905080156107d45760408051808201909152601181527054532d35207a65726f2062616c616e636560781b6020820152856106d75760405162461bcd60e51b81526004016106ce9190613070565b60405180910390fd5b506106fb81620186a06106ec886101f46130a3565b6106f691906130ba565b61167d565b90506107d4866001600160a01b031663fbfa77cf6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561073e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076291906130dc565b6001600160a01b03166389cf32046040518163ffffffff1660e01b8152600401602060405180830381865afa15801561079f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107c391906130dc565b6001600160a01b038a169083611693565b8093508087116107e55760006107ef565b6107ef8188613100565b92508215610840576040805185815260208101859052908101839052606081018690527f9f5451334f175461ca51eecfd14a2735a1b60706d05d76168e6fed6f597eb5bb9060800160405180910390a15b505094509492505050565b604080516002808252606080830184526000939092919060208301908036833701905050905061087a856116ea565b8160008151811061088d5761088d61300d565b6020026020010181815250506108a2846116ea565b816001815181106108b5576108b561300d565b60209081029190910101526040805160028082526060820190925260009181602001602082028036833701905050905085816000815181106108f9576108f961300d565b60200260200101906001600160a01b031690816001600160a01b031681525050848160018151811061092d5761092d61300d565b6001600160a01b039290921660209283029190910182015260408051600280825260608201835260009391929091830190803683370190505090508260008151811061097b5761097b61300d565b6020026020010151816000815181106109965761099661300d565b60200260200101818152505060006109b1838360008d61175a565b90508881106109c15760006109cb565b6109cb818a613100565b6109dc8760005b6020020135611c67565b856000815181106109ef576109ef61300d565b60200260200101511080610a265750610a098760016109d2565b85600181518110610a1c57610a1c61300d565b6020026020010151105b610a305784610a40565b6040805160008152602081019091525b945094505050509550959350505050565b60006103d78585858561175a565b949350505050565b60405163124fdbb760e21b8152733BEB969c0cd273eA1d7a39137a757Cf1c474510a9063493f6edc90610a9e908590600401612fe0565b60006040518083038186803b158015610ab657600080fd5b505af4158015610aca573d6000803e3d6000fd5b50505050620186a08111156040518060400160405280600f81526020016e53423a2057726f6e672076616c756560881b81525090610b1b5760405162461bcd60e51b81526004016106ce9190613070565b506040518181527fe4166dfcf23bbd3e3f764a99dc8fa740554c03c82d6019b81cf265f396f6f2fe9060200160405180910390a15050565b6000806000610b61866114b1565b60405163b3596f0760e01b81529091506001600160a01b0382169063b3596f0790610b90908890600401612fe0565b602060405180830381865afa158015610bad573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bd19190612ff4565b60405163b3596f0760e01b81529093506001600160a01b0382169063b3596f0790610c00908790600401612fe0565b602060405180830381865afa158015610c1d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c419190612ff4565b915050935093915050565b600080610c598585611c80565b90925090508015610dad5782546040516370a0823160e01b81526000918291610cee9185916001600160a01b03909116906370a0823190610c9e903090600401612fe0565b602060405180830381865afa158015610cbb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cdf9190612ff4565b610ce99089613039565b611cb0565b6001870154604051630855081f60e01b815260048101889052602481018490529294509092506001600160a01b031690630855081f90604401600060405180830381600087803b158015610d4157600080fd5b505af1158015610d55573d6000803e3d6000fd5b5050505080600014610daa576040805183815260208101839052908101889052606081018790527f79ebefb350a48e2a470929fdbef327f4d53ceaafdd43e30e288f0279aa70e5fd9060800160405180910390a15b50505b60408051868152602081018690527f3e60abe0a0e1f40e1cea1431e7b150cef698f6d8aa08b3d4e445d7a26bd93e2a910160405180910390a1509392505050565b606080600080886001600160a01b031663ef5cfb8c306040518263ffffffff1660e01b8152600401610e209190612fe0565b6000604051808303816000875af1158015610e3f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610e67919081019061316e565b91509150610ebb878784848c8d516001600160401b03811115610e8c57610e8c6128cb565b604051908082528060200260200182016040528015610eb5578160200160208202803683370190505b50611ce1565b8151919550935060005b81811015610ffe5760005b8a51811015610ff5578a8181518110610eeb57610eeb61300d565b60200260200101516001600160a01b0316878381518110610f0e57610f0e61300d565b60200260200101516001600160a01b031603610fed57878181518110610f3657610f3661300d565b60200260200101518b8281518110610f5057610f5061300d565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610f839190612fe0565b602060405180830381865afa158015610fa0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fc49190612ff4565b610fce9190613100565b868381518110610fe057610fe061300d565b6020026020010181815250505b600101610ed0565b50600101610ec5565b506110098585612208565b909b909a5098505050505050505050565b8451600090606090891590806001600160401b0381111561103d5761103d6128cb565b604051908082528060200260200182016040528015611066578160200160208202803683370190505b50925060005b818110156112355780891461122d5760008a828151811061108f5761108f61300d565b602002602001015190506000816001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016110c79190612fe0565b602060405180830381865afa1580156110e4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111089190612ff4565b9050801561122a5760008a6001600160a01b031663667df2498f8f8f815181106111345761113461300d565b60209081029190910101516040516001600160e01b031960e085901b1681526001600160a01b039283166004820152908216602482015290861660448201526064810185905260840160408051808303816000875af115801561119b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111bf9190613232565b50905085806111cd57508e15155b156111f257818785815181106111e5576111e561300d565b6020026020010181815250505b808f1161120057600061120c565b808f61120c9190613100565b9e50808a1161121c576000611226565b611226818b613100565b9950505b50505b60010161106c565b5060008280611242575086155b611282578b1561127b576064876112628e680579a814e10a7400006130a3565b61126c91906130ba565b61127691906130ba565b61128c565b600061128c565b670de0b6b3a76400005b90508060000361129d5760006112c3565b6112c3670de0b6b3a76400006112b388846130a3565b6112bd91906130ba565b8761167d565b945050505097509795505050505050565b8451606090806001600160401b038111156112f1576112f16128cb565b60405190808252806020026020018201604052801561131a578160200160208202803683370190505b50915060005b818110156114a65786810361136c578481815181106113415761134161300d565b602002602001015183828151811061135b5761135b61300d565b60200260200101818152505061149e565b60008482815181106113805761138061300d565b602002602001015186838151811061139a5761139a61300d565b60200260200101516113ac9190613039565b9050801561149c57866001600160a01b031663667df249308b8b815181106113d6576113d661300d565b60200260200101518c86815181106113f0576113f061300d565b60209081029190910101516040516001600160e01b031960e086901b1681526001600160a01b03938416600482015291831660248301529190911660448201526064810184905260840160408051808303816000875af1158015611458573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061147c9190613232565b5084838151811061148f5761148f61300d565b6020026020010181815250505b505b600101611320565b505095945050505050565b6000816001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa1580156114f1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061151591906130dc565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611552573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061045a91906130dc565b6060600082156115b857828410156115aa578261159b85670de0b6b3a76400006130a3565b6115a591906130ba565b6115bb565b670de0b6b3a76400006115bb565b60005b8551909150806001600160401b038111156115d8576115d86128cb565b604051908082528060200260200182016040528015611601578160200160208202803683370190505b50925081156116745760005b8181101561167257670de0b6b3a7640000838883815181106116315761163161300d565b602002602001015161164391906130a3565b61164d91906130ba565b84828151811061165f5761165f61300d565b602090810291909101015260010161160d565b505b50509392505050565b600081831061168c5781610457565b5090919050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b1790526116e59084906123f6565b505050565b6040516370a0823160e01b81526000906001600160a01b038316906370a0823190611719903090600401612fe0565b602060405180830381865afa158015611736573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061045a9190612ff4565b60006117a76040518060c001604052806000815260200160608152602001606081526020016060815260200160006001600160a01b0316815260200160006001600160a01b031681525090565b8551815285518690859081106117bf576117bf61300d565b60209081029190910101516001600160a01b031660808201526117ed6117e4846114b1565b825188906124c8565b6040830152602082015260005b8151811015611b33578481036118365785818151811061181c5761181c61300d565b60200260200101518361182f9190613039565b9250611b2b565b8681815181106118485761184861300d565b60209081029190910101516001600160a01b0390811660a08401819052608084015160405163dd27ede760e01b81523060048201526024810192909252821660448201526000606482018190529182919087169063dd27ede79060840160408051808303816000875af11580156118c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118e79190613232565b9150915081851015611903576118fe8488846126b6565b611910565b61190d8286613100565b94505b60008884815181106119245761192461300d565b60200260200101518560a001516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161195c9190612fe0565b602060405180830381865afa158015611979573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061199d9190612ff4565b6119a79084613039565b6119b19190613039565b608086015160a087015160405163dd27ede760e01b81523060048201526001600160a01b03928316602482015290821660448201526000606482015291925088169063dd27ede79060840160408051808303816000875af1158015611a1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a3e9190613232565b9093509150611a4d8287613039565b9550828110611b135784604001518481518110611a6c57611a6c61300d565b602002602001015185602001518981518110611a8a57611a8a61300d565b602002602001015186604001518a81518110611aa857611aa861300d565b602002602001015187602001518781518110611ac657611ac661300d565b60200260200101518685611ada9190613100565b611ae491906130a3565b611aee91906130a3565b611af891906130ba565b611b0291906130ba565b611b0c9087613039565b9550611b27565b611b278585611b228487613100565b6126b6565b5050505b6001016117fa565b508051606082015151036105f75760005b8151811015611c5d5781606001518181518110611b6357611b6361300d565b602002602001015160000315611c5557600082604001518281518110611b8b57611b8b61300d565b602002602001015183602001518781518110611ba957611ba961300d565b602002602001015184604001518881518110611bc757611bc761300d565b602002602001015185602001518581518110611be557611be561300d565b602002602001015186606001518681518110611c0357611c0361300d565b6020026020010151611c1591906130a3565b611c1f91906130a3565b611c2991906130ba565b611c3391906130ba565b905083811115611c465760009350611c53565b611c508185613100565b93505b505b600101611b44565b5050949350505050565b6000620186a08211611c7c57620186a061045a565b5090565b60008083831115611c9c57611c958484613100565b9150611ca9565b611ca68385613100565b90505b9250929050565b600080611cc784620186a06106ec866101f46130a3565b9150818411611cd7576000611ca6565b611ca68285613100565b604080516003808252608082019092526060918291600091602082018480368337019050509050885181600081518110611d1d57611d1d61300d565b602002602001018181525050865181600181518110611d3e57611d3e61300d565b602002602001018181525050845181600281518110611d5f57611d5f61300d565b602002602001018181525050875181600081518110611d8057611d8061300d565b6020026020010151148015611daf5750855181600181518110611da557611da561300d565b6020026020010151145b8015611dd55750835181600281518110611dcb57611dcb61300d565b6020026020010151145b6040518060400160405280600d81526020016c54532d3139206c656e6774687360981b81525090611e195760405162461bcd60e51b81526004016106ce9190613070565b50600081600281518110611e2f57611e2f61300d565b602002602001015182600181518110611e4a57611e4a61300d565b602002602001015183600081518110611e6557611e6561300d565b6020026020010151611e779190613039565b611e819190613039565b90506000816001600160401b03811115611e9d57611e9d6128cb565b604051908082528060200260200182016040528015611ec6578160200160208202803683370190505b5090506000826001600160401b03811115611ee357611ee36128cb565b604051908082528060200260200182016040528015611f0c578160200160208202803683370190505b5090506000805b60038110156120ce5760008115611f385781600114611f325789611f3a565b8b611f3a565b8d5b905060008215611f585782600114611f52578b611f5a565b8d611f5a565b8f5b905060005b888481518110611f7157611f7161300d565b60200260200101518110156120ba576000838281518110611f9457611f9461300d565b602002602001015190506000838381518110611fb257611fb261300d565b602002602001015190506000805b8881101561203f578a8181518110611fda57611fda61300d565b60200260200101516001600160a01b0316836001600160a01b03160361202d57838a828151811061200d5761200d61300d565b602002602001018181516120219190613039565b9052506001915061203f565b8061203781613256565b915050611fc0565b50806120a457818a89815181106120585761205861300d565b60200260200101906001600160a01b031690816001600160a01b0316815250508289898151811061208b5761208b61300d565b6020908102919091010152876120a081613256565b9850505b50505080806120b290613256565b915050611f5f565b505050806120c790613256565b9050611f13565b50806001600160401b038111156120e7576120e76128cb565b604051908082528060200260200182016040528015612110578160200160208202803683370190505b509650806001600160401b0381111561212b5761212b6128cb565b604051908082528060200260200182016040528015612154578160200160208202803683370190505b50955060005b818110156121f7578381815181106121745761217461300d565b602002602001015188828151811061218e5761218e61300d565b60200260200101906001600160a01b031690816001600160a01b0316815250508281815181106121c0576121c061300d565b60200260200101518782815181106121da576121da61300d565b6020908102919091010152806121ef81613256565b91505061215a565b505050505050965096945050505050565b60608082518451146040518060400160405280600d81526020016c54532d3139206c656e6774687360981b815250906122545760405162461bcd60e51b81526004016106ce9190613070565b508351600090815b818110156122a5578581815181106122765761227661300d565b6020026020010151600014612293578261228f81613256565b9350505b8061229d81613256565b91505061225c565b50816001600160401b038111156122be576122be6128cb565b6040519080825280602002602001820160405280156122e7578160200160208202803683370190505b509350816001600160401b03811115612302576123026128cb565b60405190808252806020026020018201604052801561232b578160200160208202803683370190505b5092506000805b828110156123eb57600087828151811061234e5761234e61300d565b60200260200101519050806000146123d8578882815181106123725761237261300d565b602002602001015187848151811061238c5761238c61300d565b60200260200101906001600160a01b031690816001600160a01b031681525050808684815181106123bf576123bf61300d565b6020908102919091010152826123d481613256565b9350505b50806123e381613256565b915050612332565b505050509250929050565b600061244b826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b031661273f9092919063ffffffff16565b8051909150156116e55780806020019051810190612469919061326f565b6116e55760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016106ce565b606080826001600160401b038111156124e3576124e36128cb565b60405190808252806020026020018201604052801561250c578160200160208202803683370190505b509150826001600160401b03811115612527576125276128cb565b604051908082528060200260200182016040528015612550578160200160208202803683370190505b50905060005b838110156126ad578481815181106125705761257061300d565b60200260200101516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156125b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125d99190613291565b6125e490600a613398565b8282815181106125f6576125f661300d565b602002602001018181525050856001600160a01b031663b3596f078683815181106126235761262361300d565b60200260200101516040518263ffffffff1660e01b81526004016126479190612fe0565b602060405180830381865afa158015612664573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126889190612ff4565b83828151811061269a5761269a61300d565b6020908102919091010152600101612556565b50935093915050565b82606001515160000361270c5782516001600160401b038111156126dc576126dc6128cb565b604051908082528060200260200182016040528015612705578160200160208202803683370190505b5060608401525b80836060015183815181106127235761272361300d565b602002602001018181516127379190613039565b905250505050565b6060610a5f848460008585600080866001600160a01b0316858760405161276691906133a7565b60006040518083038185875af1925050503d80600081146127a3576040519150601f19603f3d011682016040523d82523d6000602084013e6127a8565b606091505b50915091506127b9878383876127c4565b979650505050505050565b6060831561283357825160000361282c576001600160a01b0385163b61282c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016106ce565b5081610a5f565b610a5f83838151156128485781518083602001fd5b8060405162461bcd60e51b81526004016106ce9190613070565b6001600160a01b038116811461287757600080fd5b50565b60008060006060848603121561288f57600080fd5b833561289a81612862565b925060208401356128aa81612862565b929592945050506040919091013590565b80356128c681612862565b919050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715612909576129096128cb565b604052919050565b60006001600160401b0382111561292a5761292a6128cb565b5060051b60200190565b600082601f83011261294557600080fd5b8135602061295a61295583612911565b6128e1565b82815260059290921b8401810191818101908684111561297957600080fd5b8286015b8481101561299d57803561299081612862565b835291830191830161297d565b509695505050505050565b600082601f8301126129b957600080fd5b813560206129c961295583612911565b82815260059290921b840181019181810190868411156129e857600080fd5b8286015b8481101561299d57803583529183019183016129ec565b60008060008060808587031215612a1957600080fd5b8435612a2481612862565b935060208501356001600160401b0380821115612a4057600080fd5b612a4c88838901612934565b9450604087013593506060870135915080821115612a6957600080fd5b50612a76878288016129a8565b91505092959194509250565b600081518084526020808501945080840160005b83811015612ab257815187529582019590820190600101612a96565b509495945050505050565b6020815260006104576020830184612a82565b60008060408385031215612ae357600080fd5b8235612aee81612862565b91506020830135612afe81612862565b809150509250929050565b600080600080600080600080610100898b031215612b2657600080fd5b612b2f896128bb565b975060208901356001600160401b0380821115612b4b57600080fd5b612b578c838d01612934565b985060408b0135975060608b0135915080821115612b7457600080fd5b612b808c838d016129a8565b965060808b0135955060a08b0135945060c08b0135915080821115612ba457600080fd5b612bb08c838d016129a8565b935060e08b0135915080821115612bc657600080fd5b50612bd38b828c016129a8565b9150509295985092959890939650565b604081526000612bf66040830185612a82565b82810360208401526103d78185612a82565b60008060408385031215612c1b57600080fd5b82356001600160401b03811115612c3157600080fd5b612c3d85828601612934565b95602094909401359450505050565b60008060008060808587031215612c6257600080fd5b8435612c6d81612862565b9350602085013592506040850135612c8481612862565b9396929550929360600135925050565b600080600080600060c08688031215612cac57600080fd5b8535612cb781612862565b9450602086013593506040860135612cce81612862565b92506060860135612cde81612862565b915060c08601871015612cf057600080fd5b5092959194509260800190565b828152604060208201526000610a5f6040830184612a82565b60008060008060808587031215612d2c57600080fd5b84356001600160401b0380821115612d4357600080fd5b612d4f88838901612934565b95506020870135915080821115612d6557600080fd5b50612d72878288016129a8565b935050604085013591506060850135612d8a81612862565b939692955090935050565b60008060408385031215612da857600080fd5b8235612db381612862565b946020939093013593505050565b600080600060608486031215612dd657600080fd5b8335612de181612862565b92506020840135612df181612862565b91506040840135612e0181612862565b809150509250925092565b600080600060608486031215612e2157600080fd5b505081359360208301359350604090920135919050565b600080600080600060a08688031215612e5057600080fd5b8535612e5b81612862565b945060208601356001600160401b0380821115612e7757600080fd5b612e8389838a01612934565b95506040880135915080821115612e9957600080fd5b612ea589838a01612934565b94506060880135915080821115612ebb57600080fd5b612ec789838a016129a8565b93506080880135915080821115612edd57600080fd5b50612eea888289016129a8565b9150509295509295909350565b604080825283519082018190526000906020906060840190828701845b82811015612f395781516001600160a01b031684529284019290840190600101612f14565b50505083810382850152612f4d8186612a82565b9695505050505050565b600080600080600080600060e0888a031215612f7257600080fd5b873596506020880135612f8481612862565b955060408801356001600160401b03811115612f9f57600080fd5b612fab8a828b01612934565b955050606088013593506080880135612fc381612862565b9699959850939692959460a0840135945060c09093013592915050565b6001600160a01b0391909116815260200190565b60006020828403121561300657600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8082018082111561045a5761045a613023565b60005b8381101561306757818101518382015260200161304f565b50506000910152565b602081526000825180602084015261308f81604085016020870161304c565b601f01601f19169190910160400192915050565b808202811582820484141761045a5761045a613023565b6000826130d757634e487b7160e01b600052601260045260246000fd5b500490565b6000602082840312156130ee57600080fd5b81516130f981612862565b9392505050565b8181038181111561045a5761045a613023565b600082601f83011261312457600080fd5b8151602061313461295583612911565b82815260059290921b8401810191818101908684111561315357600080fd5b8286015b8481101561299d5780518352918301918301613157565b6000806040838503121561318157600080fd5b82516001600160401b038082111561319857600080fd5b818501915085601f8301126131ac57600080fd5b815160206131bc61295583612911565b82815260059290921b840181019181810190898411156131db57600080fd5b948201945b838610156132025785516131f381612862565b825294820194908201906131e0565b9188015191965090935050508082111561321b57600080fd5b5061322885828601613113565b9150509250929050565b6000806040838503121561324557600080fd5b505080516020909101519092909150565b60006001820161326857613268613023565b5060010190565b60006020828403121561328157600080fd5b815180151581146130f957600080fd5b6000602082840312156132a357600080fd5b815160ff811681146130f957600080fd5b600181815b808511156132ef5781600019048211156132d5576132d5613023565b808516156132e257918102915b93841c93908002906132b9565b509250929050565b6000826133065750600161045a565b816133135750600061045a565b816001811461332957600281146133335761334f565b600191505061045a565b60ff84111561334457613344613023565b50506001821b61045a565b5060208310610133831016604e8410600b8410161715613372575081810a61045a565b61337c83836132b4565b806000190482111561339057613390613023565b029392505050565b600061045760ff8416836132f7565b600082516133b981846020870161304c565b919091019291505056fea2646970667358221220b8de1297b81fac205217156da1266c85c0ed80777ff8b379a27c4e58219d0ecc64736f6c63430008110033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100ef5760003560e01c8063aac2718a116100a1578063d5ade5c111610070578063d5ade5c114610256578063e24a7eb214610269578063e99de4da14610289578063ec0cc4fd146102b757600080fd5b8063aac2718a146101b3578063ac2a37d6146101e8578063c9bce69014610216578063d2c3cf251461023657600080fd5b806309d28c57146100f4578063142395ef146101105780631997c9ee146100f45780636138ea85146101325780637a55caf31461015f5780637a9a23e51461017257806397783a6c146101a0575b600080fd5b6100fd6101f481565b6040519081526020015b60405180910390f35b81801561011c57600080fd5b5061013061012b36600461287a565b6102d7565b005b81801561013e57600080fd5b5061015261014d366004612a03565b610386565b6040516101079190612abd565b6100fd61016d366004612ad0565b6103e0565b81801561017e57600080fd5b5061019261018d366004612b09565b610460565b604051610107929190612be3565b6101526101ae366004612c08565b6104ed565b8180156101bf57600080fd5b506101d36101ce366004612c4c565b610600565b60408051928352602083019190915201610107565b8180156101f457600080fd5b50610208610203366004612c94565b61084b565b604051610107929190612cfd565b81801561022257600080fd5b506100fd610231366004612d16565b610a51565b81801561024257600080fd5b50610130610251366004612d95565b610a67565b6101d3610264366004612dc1565b610b53565b81801561027557600080fd5b506100fd610284366004612e0c565b610c4c565b81801561029557600080fd5b506102a96102a4366004612e38565b610dee565b604051610107929190612ef7565b8180156102c357600080fd5b506102086102d2366004612f57565b61101a565b60405163124fdbb760e21b815273__$ec217c54da363a68ad871e6868efec481c$__9063493f6edc9061030e908690600401612fe0565b60006040518083038186803b15801561032657600080fd5b505af415801561033a573d6000803e3d6000fd5b5050604080516001600160a01b0386168152602081018590527f297f3fbc14027d2b4a4f7dac3dff2ad6b386024299045b0e163f131bb24b611d935001905060405180910390a1505050565b60606103d784848787516001600160401b038111156103a7576103a76128cb565b6040519080825280602002602001820160405280156103d0578160200160208202803683370190505b50866112d4565b95945050505050565b60006103eb836114b1565b6001600160a01b031663b3596f07836040518263ffffffff1660e01b81526004016104169190612fe0565b602060405180830381865afa158015610433573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104579190612ff4565b90505b92915050565b6060806000610470888888611576565b905061047f8a8a8d84896112d4565b8a5190935060005b818110156104da578581815181106104a1576104a161300d565b60200260200101518782815181106104bb576104bb61300d565b602002602001018181516104cf9190613039565b905250600101610487565b5085925050509850989650505050505050565b81516060906000816001600160401b0381111561050c5761050c6128cb565b604051908082528060200260200182016040528015610535578160200160208202803683370190505b50905060005b828110156105f7578085146105ef5785818151811061055c5761055c61300d565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161058f9190612fe0565b602060405180830381865afa1580156105ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105d09190612ff4565b8282815181106105e2576105e261300d565b6020026020010181815250505b60010161053b565b50949350505050565b6000806000866001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016106319190612fe0565b602060405180830381865afa15801561064e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106729190612ff4565b90506000610680878361167d565b905080156107d45760408051808201909152601181527054532d35207a65726f2062616c616e636560781b6020820152856106d75760405162461bcd60e51b81526004016106ce9190613070565b60405180910390fd5b506106fb81620186a06106ec886101f46130a3565b6106f691906130ba565b61167d565b90506107d4866001600160a01b031663fbfa77cf6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561073e573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076291906130dc565b6001600160a01b03166389cf32046040518163ffffffff1660e01b8152600401602060405180830381865afa15801561079f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107c391906130dc565b6001600160a01b038a169083611693565b8093508087116107e55760006107ef565b6107ef8188613100565b92508215610840576040805185815260208101859052908101839052606081018690527f9f5451334f175461ca51eecfd14a2735a1b60706d05d76168e6fed6f597eb5bb9060800160405180910390a15b505094509492505050565b604080516002808252606080830184526000939092919060208301908036833701905050905061087a856116ea565b8160008151811061088d5761088d61300d565b6020026020010181815250506108a2846116ea565b816001815181106108b5576108b561300d565b60209081029190910101526040805160028082526060820190925260009181602001602082028036833701905050905085816000815181106108f9576108f961300d565b60200260200101906001600160a01b031690816001600160a01b031681525050848160018151811061092d5761092d61300d565b6001600160a01b039290921660209283029190910182015260408051600280825260608201835260009391929091830190803683370190505090508260008151811061097b5761097b61300d565b6020026020010151816000815181106109965761099661300d565b60200260200101818152505060006109b1838360008d61175a565b90508881106109c15760006109cb565b6109cb818a613100565b6109dc8760005b6020020135611c67565b856000815181106109ef576109ef61300d565b60200260200101511080610a265750610a098760016109d2565b85600181518110610a1c57610a1c61300d565b6020026020010151105b610a305784610a40565b6040805160008152602081019091525b945094505050509550959350505050565b60006103d78585858561175a565b949350505050565b60405163124fdbb760e21b815273__$ec217c54da363a68ad871e6868efec481c$__9063493f6edc90610a9e908590600401612fe0565b60006040518083038186803b158015610ab657600080fd5b505af4158015610aca573d6000803e3d6000fd5b50505050620186a08111156040518060400160405280600f81526020016e53423a2057726f6e672076616c756560881b81525090610b1b5760405162461bcd60e51b81526004016106ce9190613070565b506040518181527fe4166dfcf23bbd3e3f764a99dc8fa740554c03c82d6019b81cf265f396f6f2fe9060200160405180910390a15050565b6000806000610b61866114b1565b60405163b3596f0760e01b81529091506001600160a01b0382169063b3596f0790610b90908890600401612fe0565b602060405180830381865afa158015610bad573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bd19190612ff4565b60405163b3596f0760e01b81529093506001600160a01b0382169063b3596f0790610c00908790600401612fe0565b602060405180830381865afa158015610c1d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c419190612ff4565b915050935093915050565b600080610c598585611c80565b90925090508015610dad5782546040516370a0823160e01b81526000918291610cee9185916001600160a01b03909116906370a0823190610c9e903090600401612fe0565b602060405180830381865afa158015610cbb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610cdf9190612ff4565b610ce99089613039565b611cb0565b6001870154604051630855081f60e01b815260048101889052602481018490529294509092506001600160a01b031690630855081f90604401600060405180830381600087803b158015610d4157600080fd5b505af1158015610d55573d6000803e3d6000fd5b5050505080600014610daa576040805183815260208101839052908101889052606081018790527f79ebefb350a48e2a470929fdbef327f4d53ceaafdd43e30e288f0279aa70e5fd9060800160405180910390a15b50505b60408051868152602081018690527f3e60abe0a0e1f40e1cea1431e7b150cef698f6d8aa08b3d4e445d7a26bd93e2a910160405180910390a1509392505050565b606080600080886001600160a01b031663ef5cfb8c306040518263ffffffff1660e01b8152600401610e209190612fe0565b6000604051808303816000875af1158015610e3f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610e67919081019061316e565b91509150610ebb878784848c8d516001600160401b03811115610e8c57610e8c6128cb565b604051908082528060200260200182016040528015610eb5578160200160208202803683370190505b50611ce1565b8151919550935060005b81811015610ffe5760005b8a51811015610ff5578a8181518110610eeb57610eeb61300d565b60200260200101516001600160a01b0316878381518110610f0e57610f0e61300d565b60200260200101516001600160a01b031603610fed57878181518110610f3657610f3661300d565b60200260200101518b8281518110610f5057610f5061300d565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610f839190612fe0565b602060405180830381865afa158015610fa0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fc49190612ff4565b610fce9190613100565b868381518110610fe057610fe061300d565b6020026020010181815250505b600101610ed0565b50600101610ec5565b506110098585612208565b909b909a5098505050505050505050565b8451600090606090891590806001600160401b0381111561103d5761103d6128cb565b604051908082528060200260200182016040528015611066578160200160208202803683370190505b50925060005b818110156112355780891461122d5760008a828151811061108f5761108f61300d565b602002602001015190506000816001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016110c79190612fe0565b602060405180830381865afa1580156110e4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111089190612ff4565b9050801561122a5760008a6001600160a01b031663667df2498f8f8f815181106111345761113461300d565b60209081029190910101516040516001600160e01b031960e085901b1681526001600160a01b039283166004820152908216602482015290861660448201526064810185905260840160408051808303816000875af115801561119b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111bf9190613232565b50905085806111cd57508e15155b156111f257818785815181106111e5576111e561300d565b6020026020010181815250505b808f1161120057600061120c565b808f61120c9190613100565b9e50808a1161121c576000611226565b611226818b613100565b9950505b50505b60010161106c565b5060008280611242575086155b611282578b1561127b576064876112628e680579a814e10a7400006130a3565b61126c91906130ba565b61127691906130ba565b61128c565b600061128c565b670de0b6b3a76400005b90508060000361129d5760006112c3565b6112c3670de0b6b3a76400006112b388846130a3565b6112bd91906130ba565b8761167d565b945050505097509795505050505050565b8451606090806001600160401b038111156112f1576112f16128cb565b60405190808252806020026020018201604052801561131a578160200160208202803683370190505b50915060005b818110156114a65786810361136c578481815181106113415761134161300d565b602002602001015183828151811061135b5761135b61300d565b60200260200101818152505061149e565b60008482815181106113805761138061300d565b602002602001015186838151811061139a5761139a61300d565b60200260200101516113ac9190613039565b9050801561149c57866001600160a01b031663667df249308b8b815181106113d6576113d661300d565b60200260200101518c86815181106113f0576113f061300d565b60209081029190910101516040516001600160e01b031960e086901b1681526001600160a01b03938416600482015291831660248301529190911660448201526064810184905260840160408051808303816000875af1158015611458573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061147c9190613232565b5084838151811061148f5761148f61300d565b6020026020010181815250505b505b600101611320565b505095945050505050565b6000816001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa1580156114f1573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061151591906130dc565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611552573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061045a91906130dc565b6060600082156115b857828410156115aa578261159b85670de0b6b3a76400006130a3565b6115a591906130ba565b6115bb565b670de0b6b3a76400006115bb565b60005b8551909150806001600160401b038111156115d8576115d86128cb565b604051908082528060200260200182016040528015611601578160200160208202803683370190505b50925081156116745760005b8181101561167257670de0b6b3a7640000838883815181106116315761163161300d565b602002602001015161164391906130a3565b61164d91906130ba565b84828151811061165f5761165f61300d565b602090810291909101015260010161160d565b505b50509392505050565b600081831061168c5781610457565b5090919050565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b1790526116e59084906123f6565b505050565b6040516370a0823160e01b81526000906001600160a01b038316906370a0823190611719903090600401612fe0565b602060405180830381865afa158015611736573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061045a9190612ff4565b60006117a76040518060c001604052806000815260200160608152602001606081526020016060815260200160006001600160a01b0316815260200160006001600160a01b031681525090565b8551815285518690859081106117bf576117bf61300d565b60209081029190910101516001600160a01b031660808201526117ed6117e4846114b1565b825188906124c8565b6040830152602082015260005b8151811015611b33578481036118365785818151811061181c5761181c61300d565b60200260200101518361182f9190613039565b9250611b2b565b8681815181106118485761184861300d565b60209081029190910101516001600160a01b0390811660a08401819052608084015160405163dd27ede760e01b81523060048201526024810192909252821660448201526000606482018190529182919087169063dd27ede79060840160408051808303816000875af11580156118c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118e79190613232565b9150915081851015611903576118fe8488846126b6565b611910565b61190d8286613100565b94505b60008884815181106119245761192461300d565b60200260200101518560a001516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161195c9190612fe0565b602060405180830381865afa158015611979573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061199d9190612ff4565b6119a79084613039565b6119b19190613039565b608086015160a087015160405163dd27ede760e01b81523060048201526001600160a01b03928316602482015290821660448201526000606482015291925088169063dd27ede79060840160408051808303816000875af1158015611a1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a3e9190613232565b9093509150611a4d8287613039565b9550828110611b135784604001518481518110611a6c57611a6c61300d565b602002602001015185602001518981518110611a8a57611a8a61300d565b602002602001015186604001518a81518110611aa857611aa861300d565b602002602001015187602001518781518110611ac657611ac661300d565b60200260200101518685611ada9190613100565b611ae491906130a3565b611aee91906130a3565b611af891906130ba565b611b0291906130ba565b611b0c9087613039565b9550611b27565b611b278585611b228487613100565b6126b6565b5050505b6001016117fa565b508051606082015151036105f75760005b8151811015611c5d5781606001518181518110611b6357611b6361300d565b602002602001015160000315611c5557600082604001518281518110611b8b57611b8b61300d565b602002602001015183602001518781518110611ba957611ba961300d565b602002602001015184604001518881518110611bc757611bc761300d565b602002602001015185602001518581518110611be557611be561300d565b602002602001015186606001518681518110611c0357611c0361300d565b6020026020010151611c1591906130a3565b611c1f91906130a3565b611c2991906130ba565b611c3391906130ba565b905083811115611c465760009350611c53565b611c508185613100565b93505b505b600101611b44565b5050949350505050565b6000620186a08211611c7c57620186a061045a565b5090565b60008083831115611c9c57611c958484613100565b9150611ca9565b611ca68385613100565b90505b9250929050565b600080611cc784620186a06106ec866101f46130a3565b9150818411611cd7576000611ca6565b611ca68285613100565b604080516003808252608082019092526060918291600091602082018480368337019050509050885181600081518110611d1d57611d1d61300d565b602002602001018181525050865181600181518110611d3e57611d3e61300d565b602002602001018181525050845181600281518110611d5f57611d5f61300d565b602002602001018181525050875181600081518110611d8057611d8061300d565b6020026020010151148015611daf5750855181600181518110611da557611da561300d565b6020026020010151145b8015611dd55750835181600281518110611dcb57611dcb61300d565b6020026020010151145b6040518060400160405280600d81526020016c54532d3139206c656e6774687360981b81525090611e195760405162461bcd60e51b81526004016106ce9190613070565b50600081600281518110611e2f57611e2f61300d565b602002602001015182600181518110611e4a57611e4a61300d565b602002602001015183600081518110611e6557611e6561300d565b6020026020010151611e779190613039565b611e819190613039565b90506000816001600160401b03811115611e9d57611e9d6128cb565b604051908082528060200260200182016040528015611ec6578160200160208202803683370190505b5090506000826001600160401b03811115611ee357611ee36128cb565b604051908082528060200260200182016040528015611f0c578160200160208202803683370190505b5090506000805b60038110156120ce5760008115611f385781600114611f325789611f3a565b8b611f3a565b8d5b905060008215611f585782600114611f52578b611f5a565b8d611f5a565b8f5b905060005b888481518110611f7157611f7161300d565b60200260200101518110156120ba576000838281518110611f9457611f9461300d565b602002602001015190506000838381518110611fb257611fb261300d565b602002602001015190506000805b8881101561203f578a8181518110611fda57611fda61300d565b60200260200101516001600160a01b0316836001600160a01b03160361202d57838a828151811061200d5761200d61300d565b602002602001018181516120219190613039565b9052506001915061203f565b8061203781613256565b915050611fc0565b50806120a457818a89815181106120585761205861300d565b60200260200101906001600160a01b031690816001600160a01b0316815250508289898151811061208b5761208b61300d565b6020908102919091010152876120a081613256565b9850505b50505080806120b290613256565b915050611f5f565b505050806120c790613256565b9050611f13565b50806001600160401b038111156120e7576120e76128cb565b604051908082528060200260200182016040528015612110578160200160208202803683370190505b509650806001600160401b0381111561212b5761212b6128cb565b604051908082528060200260200182016040528015612154578160200160208202803683370190505b50955060005b818110156121f7578381815181106121745761217461300d565b602002602001015188828151811061218e5761218e61300d565b60200260200101906001600160a01b031690816001600160a01b0316815250508281815181106121c0576121c061300d565b60200260200101518782815181106121da576121da61300d565b6020908102919091010152806121ef81613256565b91505061215a565b505050505050965096945050505050565b60608082518451146040518060400160405280600d81526020016c54532d3139206c656e6774687360981b815250906122545760405162461bcd60e51b81526004016106ce9190613070565b508351600090815b818110156122a5578581815181106122765761227661300d565b6020026020010151600014612293578261228f81613256565b9350505b8061229d81613256565b91505061225c565b50816001600160401b038111156122be576122be6128cb565b6040519080825280602002602001820160405280156122e7578160200160208202803683370190505b509350816001600160401b03811115612302576123026128cb565b60405190808252806020026020018201604052801561232b578160200160208202803683370190505b5092506000805b828110156123eb57600087828151811061234e5761234e61300d565b60200260200101519050806000146123d8578882815181106123725761237261300d565b602002602001015187848151811061238c5761238c61300d565b60200260200101906001600160a01b031690816001600160a01b031681525050808684815181106123bf576123bf61300d565b6020908102919091010152826123d481613256565b9350505b50806123e381613256565b915050612332565b505050509250929050565b600061244b826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b031661273f9092919063ffffffff16565b8051909150156116e55780806020019051810190612469919061326f565b6116e55760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016106ce565b606080826001600160401b038111156124e3576124e36128cb565b60405190808252806020026020018201604052801561250c578160200160208202803683370190505b509150826001600160401b03811115612527576125276128cb565b604051908082528060200260200182016040528015612550578160200160208202803683370190505b50905060005b838110156126ad578481815181106125705761257061300d565b60200260200101516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156125b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125d99190613291565b6125e490600a613398565b8282815181106125f6576125f661300d565b602002602001018181525050856001600160a01b031663b3596f078683815181106126235761262361300d565b60200260200101516040518263ffffffff1660e01b81526004016126479190612fe0565b602060405180830381865afa158015612664573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126889190612ff4565b83828151811061269a5761269a61300d565b6020908102919091010152600101612556565b50935093915050565b82606001515160000361270c5782516001600160401b038111156126dc576126dc6128cb565b604051908082528060200260200182016040528015612705578160200160208202803683370190505b5060608401525b80836060015183815181106127235761272361300d565b602002602001018181516127379190613039565b905250505050565b6060610a5f848460008585600080866001600160a01b0316858760405161276691906133a7565b60006040518083038185875af1925050503d80600081146127a3576040519150601f19603f3d011682016040523d82523d6000602084013e6127a8565b606091505b50915091506127b9878383876127c4565b979650505050505050565b6060831561283357825160000361282c576001600160a01b0385163b61282c5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016106ce565b5081610a5f565b610a5f83838151156128485781518083602001fd5b8060405162461bcd60e51b81526004016106ce9190613070565b6001600160a01b038116811461287757600080fd5b50565b60008060006060848603121561288f57600080fd5b833561289a81612862565b925060208401356128aa81612862565b929592945050506040919091013590565b80356128c681612862565b919050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b0381118282101715612909576129096128cb565b604052919050565b60006001600160401b0382111561292a5761292a6128cb565b5060051b60200190565b600082601f83011261294557600080fd5b8135602061295a61295583612911565b6128e1565b82815260059290921b8401810191818101908684111561297957600080fd5b8286015b8481101561299d57803561299081612862565b835291830191830161297d565b509695505050505050565b600082601f8301126129b957600080fd5b813560206129c961295583612911565b82815260059290921b840181019181810190868411156129e857600080fd5b8286015b8481101561299d57803583529183019183016129ec565b60008060008060808587031215612a1957600080fd5b8435612a2481612862565b935060208501356001600160401b0380821115612a4057600080fd5b612a4c88838901612934565b9450604087013593506060870135915080821115612a6957600080fd5b50612a76878288016129a8565b91505092959194509250565b600081518084526020808501945080840160005b83811015612ab257815187529582019590820190600101612a96565b509495945050505050565b6020815260006104576020830184612a82565b60008060408385031215612ae357600080fd5b8235612aee81612862565b91506020830135612afe81612862565b809150509250929050565b600080600080600080600080610100898b031215612b2657600080fd5b612b2f896128bb565b975060208901356001600160401b0380821115612b4b57600080fd5b612b578c838d01612934565b985060408b0135975060608b0135915080821115612b7457600080fd5b612b808c838d016129a8565b965060808b0135955060a08b0135945060c08b0135915080821115612ba457600080fd5b612bb08c838d016129a8565b935060e08b0135915080821115612bc657600080fd5b50612bd38b828c016129a8565b9150509295985092959890939650565b604081526000612bf66040830185612a82565b82810360208401526103d78185612a82565b60008060408385031215612c1b57600080fd5b82356001600160401b03811115612c3157600080fd5b612c3d85828601612934565b95602094909401359450505050565b60008060008060808587031215612c6257600080fd5b8435612c6d81612862565b9350602085013592506040850135612c8481612862565b9396929550929360600135925050565b600080600080600060c08688031215612cac57600080fd5b8535612cb781612862565b9450602086013593506040860135612cce81612862565b92506060860135612cde81612862565b915060c08601871015612cf057600080fd5b5092959194509260800190565b828152604060208201526000610a5f6040830184612a82565b60008060008060808587031215612d2c57600080fd5b84356001600160401b0380821115612d4357600080fd5b612d4f88838901612934565b95506020870135915080821115612d6557600080fd5b50612d72878288016129a8565b935050604085013591506060850135612d8a81612862565b939692955090935050565b60008060408385031215612da857600080fd5b8235612db381612862565b946020939093013593505050565b600080600060608486031215612dd657600080fd5b8335612de181612862565b92506020840135612df181612862565b91506040840135612e0181612862565b809150509250925092565b600080600060608486031215612e2157600080fd5b505081359360208301359350604090920135919050565b600080600080600060a08688031215612e5057600080fd5b8535612e5b81612862565b945060208601356001600160401b0380821115612e7757600080fd5b612e8389838a01612934565b95506040880135915080821115612e9957600080fd5b612ea589838a01612934565b94506060880135915080821115612ebb57600080fd5b612ec789838a016129a8565b93506080880135915080821115612edd57600080fd5b50612eea888289016129a8565b9150509295509295909350565b604080825283519082018190526000906020906060840190828701845b82811015612f395781516001600160a01b031684529284019290840190600101612f14565b50505083810382850152612f4d8186612a82565b9695505050505050565b600080600080600080600060e0888a031215612f7257600080fd5b873596506020880135612f8481612862565b955060408801356001600160401b03811115612f9f57600080fd5b612fab8a828b01612934565b955050606088013593506080880135612fc381612862565b9699959850939692959460a0840135945060c09093013592915050565b6001600160a01b0391909116815260200190565b60006020828403121561300657600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b634e487b7160e01b600052601160045260246000fd5b8082018082111561045a5761045a613023565b60005b8381101561306757818101518382015260200161304f565b50506000910152565b602081526000825180602084015261308f81604085016020870161304c565b601f01601f19169190910160400192915050565b808202811582820484141761045a5761045a613023565b6000826130d757634e487b7160e01b600052601260045260246000fd5b500490565b6000602082840312156130ee57600080fd5b81516130f981612862565b9392505050565b8181038181111561045a5761045a613023565b600082601f83011261312457600080fd5b8151602061313461295583612911565b82815260059290921b8401810191818101908684111561315357600080fd5b8286015b8481101561299d5780518352918301918301613157565b6000806040838503121561318157600080fd5b82516001600160401b038082111561319857600080fd5b818501915085601f8301126131ac57600080fd5b815160206131bc61295583612911565b82815260059290921b840181019181810190898411156131db57600080fd5b948201945b838610156132025785516131f381612862565b825294820194908201906131e0565b9188015191965090935050508082111561321b57600080fd5b5061322885828601613113565b9150509250929050565b6000806040838503121561324557600080fd5b505080516020909101519092909150565b60006001820161326857613268613023565b5060010190565b60006020828403121561328157600080fd5b815180151581146130f957600080fd5b6000602082840312156132a357600080fd5b815160ff811681146130f957600080fd5b600181815b808511156132ef5781600019048211156132d5576132d5613023565b808516156132e257918102915b93841c93908002906132b9565b509250929050565b6000826133065750600161045a565b816133135750600061045a565b816001811461332957600281146133335761334f565b600191505061045a565b60ff84111561334457613344613023565b50506001821b61045a565b5060208310610133831016604e8410600b8410161715613372575081810a61045a565b61337c83836132b4565b806000190482111561339057613390613023565b029392505050565b600061045760ff8416836132f7565b600082516133b981846020870161304c565b919091019291505056fea2646970667358221220b8de1297b81fac205217156da1266c85c0ed80777ff8b379a27c4e58219d0ecc64736f6c63430008110033",
  "libraries": {
    "StrategyLib": "0x3BEB969c0cd273eA1d7a39137a757Cf1c474510a"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "calcInvestedAssets(address[],uint256[],uint256,ITetuConverter)": {
        "details": "This is writable function because we need to update current balances in the internal protocols.",
        "params": {
          "indexAsset": "Index of the underlying (main asset) in {tokens}"
        },
        "returns": {
          "amountOut": "Invested asset amount under control (in terms of underlying)"
        }
      },
      "claimConverterRewards(ITetuConverter,address[],address[],uint256[],uint256[])": {
        "details": "The post-processing is rewards conversion to the main asset",
        "params": {
          "amountsOut": "Amounts of available rewards",
          "rewardTokens_": "Amounts of rewards claimed from the internal pool",
          "tokensOut": "List of available rewards - not zero amounts, reward tokens don't repeat",
          "tokens_": "tokens received from {_depositorPoolAssets}"
        }
      },
      "getLiquidityAmount(uint256,address,address[],uint256,ITetuConverter,uint256,uint256)": {
        "details": "This is a writable function with read-only behavior (because of the quote-call)",
        "params": {
          "strategy_": "Address of the strategy",
          "targetAmount_": "Required amount of main asset to be withdrawn from the strategy; 0 - withdraw all"
        },
        "returns": {
          "amountsToConvertOut": "Amounts of {tokens} that should be converted to the main asset",
          "resultAmount": "Amount of liquidity that should be withdrawn from the pool, cannot exceed depositorLiquidity"
        }
      },
      "getTokenAmountsPair(ITetuConverter,uint256,address,address,uint256[2])": {
        "params": {
          "liquidationThresholdsAB": "[liquidityThreshold of token A, liquidityThreshold of tokenB]"
        },
        "returns": {
          "loss": "New total assets - old total assets",
          "tokenAmounts": "Balances of the token A and token B.                     If any balance is zero it's not possible to enter to the pool, so return empty array (len 0)"
        }
      },
      "postWithdrawActions(ITetuConverter,address[],uint256,uint256[],uint256,uint256,uint256[],uint256[])": {
        "params": {
          "amountsToConvert": "Amounts of {tokens} to be converted, they are located on the balance before withdraw",
          "withdrawnAmounts": "Amounts of {tokens} that were withdrew from the pool"
        }
      },
      "sendToInsurance(address,uint256,address,uint256)": {
        "params": {
          "totalAssets_": "Total strategy balance = balance of underlying + current invested assets amount"
        },
        "returns": {
          "sentAmount": "Amount of underlying sent to the insurance",
          "unsentAmount": "Missed part of the {amount} that were not sent to the insurance"
        }
      }
    },
    "stateVariables": {
      "HARDWORK_LOSS_TOLERANCE": {
        "details": "0.5% of max loss for strategy TVL"
      },
      "PRICE_CHANGE_PROFIT_TOLERANCE": {
        "details": "0.5% of max profit for strategy TVL"
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "UncoveredLoss(uint256,uint256,uint256,uint256)": {
        "notice": "Compensation of losses is not carried out completely"
      },
      "UnsentAmountToInsurance(uint256,uint256,uint256,uint256)": {
        "notice": "Payment to insurance was carried out only partially"
      }
    },
    "kind": "user",
    "methods": {
      "HARDWORK_LOSS_TOLERANCE()": {
        "notice": "Same value as StrategySplitterV2.HARDWORK_LOSS_TOLERANCE"
      },
      "PRICE_CHANGE_PROFIT_TOLERANCE()": {
        "notice": "Limit max amount of profit that can be send to insurance after price changing"
      },
      "calcInvestedAssets(address[],uint256[],uint256,ITetuConverter)": {
        "notice": "Calculate amount we will receive when we withdraw all from pool"
      },
      "claimConverterRewards(ITetuConverter,address[],address[],uint256[],uint256[])": {
        "notice": "Claim rewards from tetuConverter, generate result list of all available rewards and airdrops"
      },
      "coverLossAfterPriceChanging(uint256,uint256,IStrategyV3.BaseState storage)": {
        "notice": "Register income and cover possible loss after price changing, emit FixPriceChanges"
      },
      "getAvailableBalances(address[],uint256)": {
        "notice": "Get balances of the {tokens_} except balance of the token at {indexAsset} position"
      },
      "getLiquidityAmount(uint256,address,address[],uint256,ITetuConverter,uint256,uint256)": {
        "notice": "Calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18         User needs to withdraw {targetAmount_} in main asset.         There are two kinds of available liquidity:         1) liquidity in the pool - {depositorLiquidity_}         2) Converted amounts on balance of the strategy - {baseAmounts_}         To withdraw {targetAmount_} we need         1) Reconvert converted amounts back to main asset         2) IF result amount is not necessary - withdraw some liquidity from the pool            and also convert it to the main asset."
      },
      "getOracleAssetsPrices(ITetuConverter,address,address)": {
        "notice": "Get prices of {tokenA} and {tokenB}"
      },
      "getTokenAmountsPair(ITetuConverter,uint256,address,address,uint256[2])": {
        "notice": "Calculate the token amounts for deposit and amount of loss (as old-total-asset - new-total-asset)"
      },
      "postWithdrawActions(ITetuConverter,address[],uint256,uint256[],uint256,uint256,uint256[],uint256[])": {
        "notice": "Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}"
      },
      "postWithdrawActionsEmpty(ITetuConverter,address[],uint256,uint256[])": {
        "notice": "return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}"
      },
      "sendToInsurance(address,uint256,address,uint256)": {
        "notice": "Send given amount of underlying to the insurance"
      }
    },
    "notice": "Continuation of ConverterStrategyBaseLib (workaround for size limits)",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}