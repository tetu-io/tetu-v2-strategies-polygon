{
  "address": "0xDa780066A91015785D6BE266649fB3d26666dA44",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ts",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "block",
          "type": "uint256"
        }
      ],
      "name": "ContractInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "withdrawnAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "OnDepositorEmergencyExit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "consumedAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "OnDepositorEnter",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "liquidityAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "withdrawnAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "OnDepositorExit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "investedAssetsNewPrices",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "earnedByPrices",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "earnedHandleRewards",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lostHandleRewards",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "earnedDeposit",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lostDeposit",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "paidDebtToInsurance",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountPerf",
          "type": "uint256"
        }
      ],
      "name": "OnHardWorkEarnedLost",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "RevisionIncreased",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "ALGEBRA_DEPOSITOR_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CONTROLLABLE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CONVERTER_STRATEGY_BASE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "NAME",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PLATFORM",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "STRATEGY_BASE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "STRATEGY_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "asset",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "calcInvestedAssets",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "investedAssetsOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "capacity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "compoundRatio",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "converter",
      "outputs": [
        {
          "internalType": "contract ITetuConverter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "created",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createdBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "debtToInsurance",
      "outputs": [
        {
          "internalType": "int256",
          "name": "",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "doHardWork",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "earned",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lost",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "emergencyExit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getDefaultState",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "addr",
          "type": "address[]"
        },
        {
          "internalType": "int24[]",
          "name": "tickData",
          "type": "int24[]"
        },
        {
          "internalType": "uint256[]",
          "name": "nums",
          "type": "uint256[]"
        },
        {
          "internalType": "bool[]",
          "name": "boolValues",
          "type": "bool[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getFees",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "fee0",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "fee1",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getPropNotUnderlying18",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "slot",
          "type": "uint256"
        }
      ],
      "name": "getSlot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "result",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "getSpecificState",
      "outputs": [
        {
          "internalType": "uint256[]",
          "name": "nums",
          "type": "uint256[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "increaseRevision",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "controller_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "splitter_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "converter_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        },
        {
          "internalType": "int24",
          "name": "tickRange_",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "rebalanceTickRange_",
          "type": "int24"
        },
        {
          "internalType": "bool",
          "name": "isStablePool",
          "type": "bool"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "rewardToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "bonusRewardToken",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "pool",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "startTime",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "endTime",
              "type": "uint256"
            }
          ],
          "internalType": "struct IncentiveKey",
          "name": "key",
          "type": "tuple"
        },
        {
          "internalType": "uint256[4]",
          "name": "fuseThresholds",
          "type": "uint256[4]"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "updateTotalAssetsBeforeInvest_",
          "type": "bool"
        }
      ],
      "name": "investAll",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "strategyLoss",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "investedAssets",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_value",
          "type": "address"
        }
      ],
      "name": "isController",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_value",
          "type": "address"
        }
      ],
      "name": "isGovernance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isReadyToHardWork",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "liquidationThresholds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "needRebalance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "name": "onERC721Received",
      "outputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "assets_",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts_",
          "type": "uint256[]"
        }
      ],
      "name": "onTransferAmounts",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "performanceFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "performanceFeeRatio",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "performanceReceiver",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "previousImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "planEntryData",
          "type": "bytes"
        }
      ],
      "name": "quoteWithdrawByAgg",
      "outputs": [
        {
          "internalType": "address",
          "name": "tokenToSwap",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountToSwap",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bool",
          "name": "checkNeedRebalance",
          "type": "bool"
        }
      ],
      "name": "rebalanceNoSwaps",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "reinvestThresholdPercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "theAsset_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount_",
          "type": "uint256"
        }
      ],
      "name": "requirePayAmountBack",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "revision",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "setCompoundRatio",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "status",
          "type": "uint256"
        }
      ],
      "name": "setFuseStatus",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256[4]",
          "name": "values",
          "type": "uint256[4]"
        }
      ],
      "name": "setFuseThresholds",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "setLiquidationThreshold",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "percent_",
          "type": "uint256"
        }
      ],
      "name": "setReinvestThresholdPercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "strategyProfitHolder",
          "type": "address"
        }
      ],
      "name": "setStrategyProfitHolder",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        }
      ],
      "name": "setStrategySpecificName",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "done",
          "type": "uint256"
        }
      ],
      "name": "setWithdrawDone",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "fee_",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "receiver_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "ratio_",
          "type": "uint256"
        }
      ],
      "name": "setupPerformanceFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "splitter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "strategySpecificName",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalAssets",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawAllToSplitter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "strategyLoss",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "tokenToSwap_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "aggregator_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amountToSwap_",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "swapData",
          "type": "bytes"
        },
        {
          "internalType": "bytes",
          "name": "planEntryData",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "entryToPool",
          "type": "uint256"
        }
      ],
      "name": "withdrawByAggStep",
      "outputs": [
        {
          "internalType": "bool",
          "name": "completed",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawToSplitter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "strategyLoss",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x5ba5169e62de49d68b1bac9c688293d01769cc3ed6d20656f211f8fd9df398f6",
  "receipt": {
    "to": null,
    "from": "0xF1dCce3a6c321176C62b71c091E3165CC9C3816E",
    "contractAddress": "0xDa780066A91015785D6BE266649fB3d26666dA44",
    "transactionIndex": 110,
    "gasUsed": "5227904",
    "logsBloom": "0x00000000000000000000000002000000000000000000000000000000000000000000000000000000201000000001000040008000000000000000000000000000000000000000000000000000000040800000000000000000000100000000000000000000000000040000000000000000000000000000000080000000004000000000000000000000000000000000000000000000000080000000000000000000200000000000000000000000000400000000000000000000000000000000004000000000000000000001000000040000000000000000000000100000000000000000000000000000000000000000000000000000000000080000000000100000",
    "blockHash": "0x646e9c1d48beff2ebbd52ee6f2de5c43c39bcf58f806818134594a37647ce312",
    "transactionHash": "0x5ba5169e62de49d68b1bac9c688293d01769cc3ed6d20656f211f8fd9df398f6",
    "logs": [
      {
        "transactionIndex": 110,
        "blockNumber": 52238347,
        "transactionHash": "0x5ba5169e62de49d68b1bac9c688293d01769cc3ed6d20656f211f8fd9df398f6",
        "address": "0xDa780066A91015785D6BE266649fB3d26666dA44",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 412,
        "blockHash": "0x646e9c1d48beff2ebbd52ee6f2de5c43c39bcf58f806818134594a37647ce312"
      },
      {
        "transactionIndex": 110,
        "blockNumber": 52238347,
        "transactionHash": "0x5ba5169e62de49d68b1bac9c688293d01769cc3ed6d20656f211f8fd9df398f6",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000f1dcce3a6c321176c62b71c091e3165cc9c3816e",
          "0x00000000000000000000000069f5c4d08f6bc8cd29fe5f004d46fb566270868d"
        ],
        "data": "0x000000000000000000000000000000000000000000000000001bdc20614280000000000000000000000000000000000000000000000000017927c2e777c9a28600000000000000000000000000000000000000000000074ef1d6c794f02bba9a000000000000000000000000000000000000000000000001790be6c71687228600000000000000000000000000000000000000000000074ef1f2a3b5516e3a9a",
        "logIndex": 413,
        "blockHash": "0x646e9c1d48beff2ebbd52ee6f2de5c43c39bcf58f806818134594a37647ce312"
      }
    ],
    "blockNumber": 52238347,
    "cumulativeGasUsed": "21088294",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 14,
  "solcInputHash": "da1a131c81810b0ec86f8a1b7470ae1a",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"withdrawnAmounts\",\"type\":\"uint256[]\"}],\"name\":\"OnDepositorEmergencyExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"consumedAmounts\",\"type\":\"uint256[]\"}],\"name\":\"OnDepositorEnter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"withdrawnAmounts\",\"type\":\"uint256[]\"}],\"name\":\"OnDepositorExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investedAssetsNewPrices\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnedByPrices\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnedHandleRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lostHandleRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnedDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lostDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"paidDebtToInsurance\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountPerf\",\"type\":\"uint256\"}],\"name\":\"OnHardWorkEarnedLost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"RevisionIncreased\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"ALGEBRA_DEPOSITOR_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONTROLLABLE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONVERTER_STRATEGY_BASE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STRATEGY_BASE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STRATEGY_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcInvestedAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"investedAssetsOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compoundRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"converter\",\"outputs\":[{\"internalType\":\"contract ITetuConverter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"debtToInsurance\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doHardWork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lost\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getDefaultState\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"addr\",\"type\":\"address[]\"},{\"internalType\":\"int24[]\",\"name\":\"tickData\",\"type\":\"int24[]\"},{\"internalType\":\"uint256[]\",\"name\":\"nums\",\"type\":\"uint256[]\"},{\"internalType\":\"bool[]\",\"name\":\"boolValues\",\"type\":\"bool[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"fee0\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getPropNotUnderlying18\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"slot\",\"type\":\"uint256\"}],\"name\":\"getSlot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"result\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"getSpecificState\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"nums\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"increaseRevision\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"splitter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"converter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"},{\"internalType\":\"int24\",\"name\":\"tickRange_\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"rebalanceTickRange_\",\"type\":\"int24\"},{\"internalType\":\"bool\",\"name\":\"isStablePool\",\"type\":\"bool\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"rewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"bonusRewardToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"startTime\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"endTime\",\"type\":\"uint256\"}],\"internalType\":\"struct IncentiveKey\",\"name\":\"key\",\"type\":\"tuple\"},{\"internalType\":\"uint256[4]\",\"name\":\"fuseThresholds\",\"type\":\"uint256[4]\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"updateTotalAssetsBeforeInvest_\",\"type\":\"bool\"}],\"name\":\"investAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyLoss\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investedAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReadyToHardWork\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidationThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"needRebalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"}],\"name\":\"onTransferAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFeeRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"planEntryData\",\"type\":\"bytes\"}],\"name\":\"quoteWithdrawByAgg\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"tokenToSwap\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToSwap\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bool\",\"name\":\"checkNeedRebalance\",\"type\":\"bool\"}],\"name\":\"rebalanceNoSwaps\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvestThresholdPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"theAsset_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"requirePayAmountBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setCompoundRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"status\",\"type\":\"uint256\"}],\"name\":\"setFuseStatus\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256[4]\",\"name\":\"values\",\"type\":\"uint256[4]\"}],\"name\":\"setFuseThresholds\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setLiquidationThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent_\",\"type\":\"uint256\"}],\"name\":\"setReinvestThresholdPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"strategyProfitHolder\",\"type\":\"address\"}],\"name\":\"setStrategyProfitHolder\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setStrategySpecificName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"done\",\"type\":\"uint256\"}],\"name\":\"setWithdrawDone\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"name\":\"setupPerformanceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"splitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategySpecificName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllToSplitter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyLoss\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"tokenToSwap_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"aggregator_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountToSwap_\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"swapData\",\"type\":\"bytes\"},{\"internalType\":\"bytes\",\"name\":\"planEntryData\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"entryToPool\",\"type\":\"uint256\"}],\"name\":\"withdrawByAggStep\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"completed\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToSplitter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyLoss\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"claim()\":{\"details\":\"Manual claim rewards.\"},\"created()\":{\"returns\":{\"_0\":\"Creation timestamp\"}},\"createdBlock()\":{\"returns\":{\"_0\":\"Creation block number\"}},\"doHardWork()\":{\"returns\":{\"earned\":\"Earned amount in terms of {asset}\",\"lost\":\"Lost amount in terms of {asset}\"}},\"emergencyExit()\":{\"details\":\"In case of any issue operator can withdraw all from pool.\"},\"getDefaultState()\":{\"returns\":{\"addr\":\"[tokenA, tokenB, pool, profitHolder]\",\"boolValues\":\"[isStablePool, depositorSwapTokens]\",\"nums\":\"[totalLiquidity, fuse-status-tokenA, fuse-status-tokenB, withdrawDone, 4 thresholds of token A, 4 thresholds of token B]\",\"tickData\":\"[tickSpacing, lowerTick, upperTick, rebalanceTickRange]\"}},\"getFees()\":{\"returns\":{\"fee0\":\"and fee1.\"}},\"getPropNotUnderlying18()\":{\"returns\":{\"_0\":\"Proportion of the not-underlying [0...1e18]\"}},\"getSlot(uint256)\":{\"details\":\"Gets a slot as bytes32\"},\"getSpecificState()\":{\"returns\":{\"nums\":\"Balances of [tokenA, tokenB, rewardToken, bonusRewardToken] for profit holder\"}},\"increaseRevision(address)\":{\"details\":\"Revision should be increased on each contract upgrade\"},\"init(address,address,address,address,int24,int24,bool,(address,address,address,uint256,uint256),uint256[4])\":{\"params\":{\"controller_\":\"The address of the controller.\",\"converter_\":\"The address of the converter.\",\"pool_\":\"The address of the pool.\",\"rebalanceTickRange_\":\"The tick range for rebalancing.\",\"splitter_\":\"The address of the splitter.\",\"tickRange_\":\"The tick range for the liquidity position.\"}},\"investAll(uint256,bool)\":{\"params\":{\"updateTotalAssetsBeforeInvest_\":\"Recalculate total assets amount before depositing.                                       It can be false if we know exactly, that the amount is already actual.\"},\"returns\":{\"strategyLoss\":\"Loss should be covered from Insurance\"}},\"isController(address)\":{\"details\":\"Return true if given address is controller\"},\"isReadyToHardWork()\":{\"returns\":{\"_0\":\"A boolean indicating if the strategy is ready for hard work.\"}},\"needRebalance()\":{\"returns\":{\"_0\":\"A boolean indicating if the strategy needs rebalancing.\"}},\"onTransferAmounts(address[],uint256[])\":{\"params\":{\"amounts_\":\"Amount of {asset_} that has been sent to the user's balance\",\"assets_\":\"Any asset sent to the balance, i.e. inside repayTheBorrow\"}},\"performanceFee()\":{\"details\":\"use FEE_DENOMINATOR\"},\"previousImplementation()\":{\"details\":\"Previous logic implementation\"},\"rebalanceNoSwaps(bool)\":{\"params\":{\"checkNeedRebalance\":\"Revert if rebalance is not needed. Pass false to deposit after withdrawByAgg-iterations\"}},\"requirePayAmountBack(address,uint256)\":{\"params\":{\"amount_\":\"Required amount of {theAsset_}\",\"theAsset_\":\"Required asset (either collateral or borrow), it can be NOT underlying\"},\"returns\":{\"amountOut\":\"Amount that was send OR can be claimed on the next call.                   The caller should control own balance to know if the amount was actually send                   (because we need compatibility with exist not-NSR strategies)\"}},\"revision()\":{\"details\":\"Contract upgrade counter\"},\"setCompoundRatio(uint256)\":{\"details\":\"PlatformVoter can change compound ratio for some strategies.      A strategy can implement another logic for some uniq cases.\"},\"setFuseStatus(uint256)\":{\"params\":{\"status\":\"See PairBasedStrategyLib.FuseStatus enum for possible values\"}},\"setFuseThresholds(uint256[4])\":{\"params\":{\"values\":\"Price thresholds: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\"}},\"setLiquidationThreshold(address,uint256)\":{\"details\":\"Liquidation thresholds are used to detect dust in many cases, not only in liquidation case\",\"params\":{\"amount\":\"Min amount of token allowed to liquidate, token's decimals are used.\"}},\"setReinvestThresholdPercent(uint256)\":{\"params\":{\"percent_\":\"New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\"}},\"setStrategySpecificName(string)\":{\"details\":\"The name will be used for UI.\"},\"setWithdrawDone(uint256)\":{\"params\":{\"done\":\"0 - full withdraw required, 1 - full withdraw was done\"}},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"totalAssets()\":{\"details\":\"Total amount of underlying assets under control of this strategy.\"},\"withdrawAllToSplitter()\":{\"details\":\"Withdraws all underlying assets to the vault\",\"returns\":{\"strategyLoss\":\"Loss should be covered from Insurance\"}},\"withdrawByAggStep(address,address,uint256,bytes,bytes,uint256)\":{\"details\":\"All swap-by-agg data should be prepared using {quoteWithdrawByAgg} off-chain\",\"params\":{\"aggregator_\":\"Aggregator that should be used on next swap. 0 - use liquidator\",\"amountToSwap_\":\"Amount that should be swapped. 0 - no swap\",\"entryToPool\":\"Allow to enter to the pool at the end. Use false if you are going to make several iterations.                    It's possible to enter back to the pool by calling {rebalanceNoSwaps} at any moment                    0 - not allowed, 1 - allowed, 2 - allowed only if completed\",\"planEntryData\":\"PLAN_XXX + additional data, see IterationPlanKinds\",\"swapData\":\"Swap rote that was prepared off-chain.\",\"tokenToSwap_\":\"What token should be swapped to other\"},\"returns\":{\"completed\":\"All debts were closed, leftovers were swapped to the required proportions.\"}},\"withdrawToSplitter(uint256)\":{\"details\":\"Withdraws some assets to the splitter\",\"returns\":{\"strategyLoss\":\"Loss should be covered from Insurance\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"CONTROLLABLE_VERSION()\":{\"notice\":\"Version of the contract\"},\"capacity()\":{\"notice\":\"Unlimited capacity by default\"},\"controller()\":{\"notice\":\"Return controller address saved in the contract slot\"},\"created()\":{\"notice\":\"Return creation timestamp\"},\"createdBlock()\":{\"notice\":\"Return creation block number\"},\"doHardWork()\":{\"notice\":\"Do hard work with reinvesting\"},\"getDefaultState()\":{\"notice\":\"Returns the current state of the contract\"},\"getFees()\":{\"notice\":\"Returns the fees for the current state.\"},\"getPropNotUnderlying18()\":{\"notice\":\"Calculate proportions of [underlying, not-underlying] required by the internal pool of the strategy\"},\"init(address,address,address,address,int24,int24,bool,(address,address,address,uint256,uint256),uint256[4])\":{\"notice\":\"Initialize the strategy with the given parameters.\"},\"investAll(uint256,bool)\":{\"notice\":\"Stakes everything the strategy holds into the reward pool. amount_ Amount transferred to the strategy balance just before calling this function\"},\"investedAssets()\":{\"notice\":\"Amount of underlying assets converted to pool assets and invested to the pool.\"},\"isGovernance(address)\":{\"notice\":\"Return true if given address is setup as governance in Controller\"},\"isReadyToHardWork()\":{\"notice\":\"Check if the strategy is ready for hard work.\"},\"liquidationThresholds(address)\":{\"notice\":\"Minimum token amounts that can be liquidated\"},\"needRebalance()\":{\"notice\":\"Check if the strategy needs rebalancing.\"},\"onTransferAmounts(address[],uint256[])\":{\"notice\":\"TetuConverter calls this function when it sends any amount to user's balance\"},\"performanceFee()\":{\"notice\":\"A percent of total profit that is sent to the {performanceReceiver} before compounding\"},\"performanceReceiver()\":{\"notice\":\"{performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\"},\"quoteWithdrawByAgg(bytes)\":{\"notice\":\"Get info about a swap required by next call of {withdrawByAggStep} within the given plan\"},\"rebalanceNoSwaps(bool)\":{\"notice\":\"Rebalance using borrow/repay only, no swaps\"},\"requirePayAmountBack(address,uint256)\":{\"notice\":\"Converters asks to send some amount back.         The results depend on whether the required amount is on the balance:         1. The {amount_} exists on the balance: send the amount to TetuConverter, return {amount_}         2. The {amount_} doesn't exist on the balance. Try to receive the {amount_}.         2.1. if the required amount is received: return {amount_}         2.2. if less amount X (X < {amount_}) is received return X - gap         In the case 2 no amount is send to TetuConverter.         Converter should make second call of requirePayAmountBack({amountOut}) to receive the assets.\"},\"setFuseStatus(uint256)\":{\"notice\":\"Manually set status of the fuse\"},\"setFuseThresholds(uint256[4])\":{\"notice\":\"Set thresholds for the fuse: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]         Decimals 18. The thresholds are compared with prices from TetuConverter's price oracle.         Example: [0.9, 0.92, 1.08, 1.1]         Price falls below 0.9 - fuse is ON. Price rises back up to 0.92 - fuse is OFF.         Price raises more and reaches 1.1 - fuse is ON again. Price falls back and reaches 1.08 - fuse OFF again.\"},\"setWithdrawDone(uint256)\":{\"notice\":\"Set withdrawDone value.         When a fuse was triggered ON, all debts should be closed and asset should be converted to underlying.         After completion of the conversion withdrawDone can be set to 1.         So, {getFuseStatus} will return  withdrawDone=1 and you will know, that withdraw is not required\"},\"setupPerformanceFee(uint256,address,uint256)\":{\"notice\":\"Set performance fee, receiver and ratio\"},\"withdrawByAggStep(address,address,uint256,bytes,bytes,uint256)\":{\"notice\":\"Make withdraw iteration: [exit from the pool], [make 1 swap], [repay a debt], [enter to the pool]         Typical sequence of the actions is: exit from the pool, make 1 swap, repay 1 debt.         You can enter to the pool if you are sure that you won't have borrow + repay on AAVE3 in the same block.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/algebra/AlgebraConverterStrategy.sol\":\"AlgebraConverterStrategy\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IControllable {\\n\\n  function isController(address _contract) external view returns (bool);\\n\\n  function isGovernance(address _contract) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0xc2ef11f0141e7e1a5df255be2e1552044deed377349cb886908f3f10ded57fa8\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IController {\\n\\n  // --- DEPENDENCY ADDRESSES\\n  function governance() external view returns (address);\\n\\n  function voter() external view returns (address);\\n\\n  function liquidator() external view returns (address);\\n\\n  function forwarder() external view returns (address);\\n\\n  function investFund() external view returns (address);\\n\\n  function veDistributor() external view returns (address);\\n\\n  function platformVoter() external view returns (address);\\n\\n  // --- VAULTS\\n\\n  function vaults(uint id) external view returns (address);\\n\\n  function vaultsList() external view returns (address[] memory);\\n\\n  function vaultsListLength() external view returns (uint);\\n\\n  function isValidVault(address _vault) external view returns (bool);\\n\\n  // --- restrictions\\n\\n  function isOperator(address _adr) external view returns (bool);\\n\\n\\n}\\n\",\"keccak256\":\"0x86716b8a4775605c31b8bb9f90f8f4a18b709ff4435182f3a148803368060a8c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xaeca7db2074d7c66a20c609539e1f1656e67f6981bf01f83ad6aa8aa140c8d2e\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x5f43ed533d0fc4dc2f8f081d2c4b77960f3e908d5f7359096b385e5673f1ba0c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n     */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n     */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n     */\\n  function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x953f20efa64081a325109a0e03602b889d2819c2b51c1e1fb21a062feeda74f3\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x9f69f84d864c2a84de9321871aa52f6f70d14afe46badbcd37c0d4f22af75e7b\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IForwarder {\\n\\n  function tetu() external view returns (address);\\n  function tetuThreshold() external view returns (uint);\\n\\n  function tokenPerDestinationLength(address destination) external view returns (uint);\\n\\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\\n\\n  function amountPerDestination(address token, address destination) external view returns (uint amount);\\n\\n  function registerIncome(\\n    address[] memory tokens,\\n    uint[] memory amounts,\\n    address vault,\\n    bool isDistribute\\n  ) external;\\n\\n  function distributeAll(address destination) external;\\n\\n  function distribute(address token) external;\\n\\n  function setInvestFundRatio(uint value) external;\\n\\n  function setGaugesRatio(uint value) external;\\n\\n}\\n\",\"keccak256\":\"0x687c497fc034e8d64bca403bac1bf4cd7bd1f107df414c2657325c1b3ab92822\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ISplitter {\\n\\n  function init(address controller_, address _asset, address _vault) external;\\n\\n  // *************** ACTIONS **************\\n\\n  function withdrawAllToVault() external;\\n\\n  function withdrawToVault(uint256 amount) external;\\n\\n  function coverPossibleStrategyLoss(uint earned, uint lost) external;\\n\\n  function doHardWork() external;\\n\\n  function investAll() external;\\n\\n  // **************** VIEWS ***************\\n\\n  function asset() external view returns (address);\\n\\n  function vault() external view returns (address);\\n\\n  function totalAssets() external view returns (uint256);\\n\\n  function isHardWorking() external view returns (bool);\\n\\n  function strategies(uint i) external view returns (address);\\n\\n  function strategiesLength() external view returns (uint);\\n\\n  function HARDWORK_DELAY() external view returns (uint);\\n\\n  function lastHardWorks(address strategy) external view returns (uint);\\n\\n  function pausedStrategies(address strategy) external view returns (bool);\\n\\n  function pauseInvesting(address strategy) external;\\n\\n  function continueInvesting(address strategy, uint apr) external;\\n\\n  function rebalance(uint percent, uint lossTolerance) external;\\n\\n  function getStrategyCapacity(address strategy) external view returns (uint capacity);\\n\\n}\\n\",\"keccak256\":\"0x266c43734e3da96d9e5dcdd0f19c6dbd58fdc377c9cd361cb12da3e309fbb4ec\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IStrategyV2 {\\n\\n  function NAME() external view returns (string memory);\\n\\n  function strategySpecificName() external view returns (string memory);\\n\\n  function PLATFORM() external view returns (string memory);\\n\\n  function STRATEGY_VERSION() external view returns (string memory);\\n\\n  function asset() external view returns (address);\\n\\n  function splitter() external view returns (address);\\n\\n  function compoundRatio() external view returns (uint);\\n\\n  function totalAssets() external view returns (uint);\\n\\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\\n  function isReadyToHardWork() external view returns (bool);\\n\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawAllToSplitter() external returns (uint strategyLoss);\\n\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawToSplitter(uint amount) external returns (uint strategyLoss);\\n\\n  /// @notice Stakes everything the strategy holds into the reward pool.\\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\\n  ///                                       It can be false if we know exactly, that the amount is already actual.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function investAll(\\n    uint amount_,\\n    bool updateTotalAssetsBeforeInvest_\\n  ) external returns (\\n    uint strategyLoss\\n  );\\n\\n  function doHardWork() external returns (uint earned, uint lost);\\n\\n  function setCompoundRatio(uint value) external;\\n\\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\\n  ///         0 means no deposit is allowed at this moment\\n  function capacity() external view returns (uint);\\n\\n  /// @notice {performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\\n  function performanceReceiver() external view returns (address);\\n\\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\\n  /// @dev use FEE_DENOMINATOR\\n  function performanceFee() external view returns (uint);\\n}\\n\",\"keccak256\":\"0xc7dac6097df7310b510f1027ef9c1bd3ccd6a202ca69582f68233ee798f7c312\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IStrategyV2.sol\\\";\\n\\ninterface IStrategyV3 is IStrategyV2 {\\n  struct BaseState {\\n    /// @dev Underlying asset\\n    address asset;\\n\\n    /// @dev Linked splitter\\n    address splitter;\\n\\n    /// @notice {performanceFee}% of total profit is sent to {performanceReceiver} before compounding\\n    /// @dev governance by default\\n    address performanceReceiver;\\n\\n    /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\\n    /// @dev {DEFAULT_PERFORMANCE_FEE} by default, FEE_DENOMINATOR is used\\n    uint performanceFee;\\n\\n    /// @notice Ratio to split performance fee on toPerf + toInsurance, [0..100_000]\\n    ///         100_000 - send full amount toPerf, 0 - send full amount toInsurance.\\n    uint performanceFeeRatio;\\n\\n    /// @dev Percent of profit for autocompound inside this strategy.\\n    uint compoundRatio;\\n\\n    /// @dev Represent specific name for this strategy. Should include short strategy name and used assets. Uniq across the vault.\\n    string strategySpecificName;\\n  }\\n}\\n\",\"keccak256\":\"0xe8a0179a82c40ba0c372486c5ebcc7df6431216c8c0d91cc408fb8f881e72f70\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface ITetuLiquidator {\\n\\n  struct PoolData {\\n    address pool;\\n    address swapper;\\n    address tokenIn;\\n    address tokenOut;\\n  }\\n\\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\\n\\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\\n\\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\\n\\n  function buildRoute(\\n    address tokenIn,\\n    address tokenOut\\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\\n\\n  function liquidate(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n  function liquidateWithRoute(\\n    PoolData[] memory route,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n\\n}\\n\",\"keccak256\":\"0xd5fe6f3ab750cc2d23f573597db5607c701e74c39e13c20c07a921a26c6d5012\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IVaultInsurance.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISplitter.sol\\\";\\n\\ninterface ITetuVaultV2 {\\n\\n  function splitter() external view returns (ISplitter);\\n\\n  function insurance() external view returns (IVaultInsurance);\\n\\n  function depositFee() external view returns (uint);\\n\\n  function withdrawFee() external view returns (uint);\\n\\n  function init(\\n    address controller_,\\n    IERC20 _asset,\\n    string memory _name,\\n    string memory _symbol,\\n    address _gauge,\\n    uint _buffer\\n  ) external;\\n\\n  function setSplitter(address _splitter) external;\\n\\n  function coverLoss(uint amount) external;\\n\\n  function initInsurance(IVaultInsurance _insurance) external;\\n\\n}\\n\",\"keccak256\":\"0x9e77a10b32a52f826d28d17c420f776fd289e5e4f925ec87f7177a1ce224a412\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IVaultInsurance {\\n\\n  function init(address _vault, address _asset) external;\\n\\n  function vault() external view returns (address);\\n\\n  function asset() external view returns (address);\\n\\n  function transferToVault(uint amount) external;\\n\\n}\\n\",\"keccak256\":\"0x6461572763b1f6decec1dee9d2ffe8ca152369bdc68255ec083cb3da3ce507a1\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/lib/InterfaceIds.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\n/// @title Library for interface IDs\\n/// @author bogdoslav\\nlibrary InterfaceIds {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant INTERFACE_IDS_LIB_VERSION = \\\"1.0.1\\\";\\n\\n  /// default notation:\\n  /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\\n\\n  /// As type({Interface}).interfaceId can be changed,\\n  /// when some functions changed at the interface,\\n  /// so used hardcoded interface identifiers\\n\\n  bytes4 public constant I_VOTER = bytes4(keccak256(\\\"IVoter\\\"));\\n  bytes4 public constant I_BRIBE = bytes4(keccak256(\\\"IBribe\\\"));\\n  bytes4 public constant I_GAUGE = bytes4(keccak256(\\\"IGauge\\\"));\\n  bytes4 public constant I_VE_TETU = bytes4(keccak256(\\\"IVeTetu\\\"));\\n  bytes4 public constant I_SPLITTER = bytes4(keccak256(\\\"ISplitter\\\"));\\n  bytes4 public constant I_FORWARDER = bytes4(keccak256(\\\"IForwarder\\\"));\\n  bytes4 public constant I_MULTI_POOL = bytes4(keccak256(\\\"IMultiPool\\\"));\\n  bytes4 public constant I_CONTROLLER = bytes4(keccak256(\\\"IController\\\"));\\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\\\"ITetuERC165\\\"));\\n  bytes4 public constant I_STRATEGY_V2 = bytes4(keccak256(\\\"IStrategyV2\\\"));\\n  bytes4 public constant I_STRATEGY_V3 = bytes4(keccak256(\\\"IStrategyV3\\\"));\\n  bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\\\"IControllable\\\"));\\n  bytes4 public constant I_TETU_VAULT_V2 = bytes4(keccak256(\\\"ITetuVaultV2\\\"));\\n  bytes4 public constant I_PLATFORM_VOTER = bytes4(keccak256(\\\"IPlatformVoter\\\"));\\n  bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\\\"IVeDistributor\\\"));\\n  bytes4 public constant I_TETU_CONVERTER = bytes4(keccak256(\\\"ITetuConverter\\\"));\\n  bytes4 public constant I_VAULT_INSURANCE = bytes4(keccak256(\\\"IVaultInsurance\\\"));\\n  bytes4 public constant I_STRATEGY_STRICT = bytes4(keccak256(\\\"IStrategyStrict\\\"));\\n  bytes4 public constant I_ERC4626 = bytes4(keccak256(\\\"IERC4626\\\"));\\n\\n}\\n\",\"keccak256\":\"0x0b03305fffdb0ae7bca319c38ac0b43116765987cf61f529f156f46171e73de1\",\"license\":\"BUSL-1.1\"},\"@tetu_io/tetu-contracts-v2/contracts/lib/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as uint\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  // ************* ARRAY SETTERS *******************\\n\\n  /// @dev Sets a slot array at index with address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function setAt(bytes32 slot, uint index, address value) internal {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      sstore(pointer, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot array at index with uint\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function setAt(bytes32 slot, uint index, uint value) internal {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      sstore(pointer, value)\\n    }\\n  }\\n\\n  /// @dev Sets an array length\\n  function setLength(bytes32 slot, uint length) internal {\\n    assembly {\\n      sstore(slot, length)\\n    }\\n  }\\n\\n  /// @dev Pushes an address to the array\\n  function push(bytes32 slot, address value) internal {\\n    uint length = arrayLength(slot);\\n    setAt(slot, length, value);\\n    setLength(slot, length + 1);\\n  }\\n\\n}\\n\",\"keccak256\":\"0x883de721bbf73a85c494e45380b064b91ea2c5cd0b7a777cdacb544575761c8a\",\"license\":\"BUSL-1.1\"},\"@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\n\\nlibrary StringLib {\\n\\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n  function toString(uint value) external pure returns (string memory) {\\n    return _toString(value);\\n  }\\n\\n  function _toString(uint value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint temp = value;\\n    uint digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  function toAsciiString(address x) external pure returns (string memory) {\\n    return _toAsciiString(x);\\n  }\\n\\n  function _toAsciiString(address x) internal pure returns (string memory) {\\n    bytes memory s = new bytes(40);\\n    for (uint i = 0; i < 20; i++) {\\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n      bytes1 hi = bytes1(uint8(b) / 16);\\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n      s[2 * i] = _char(hi);\\n      s[2 * i + 1] = _char(lo);\\n    }\\n    return string(s);\\n  }\\n\\n  function char(bytes1 b) external pure returns (bytes1 c) {\\n    return _char(b);\\n  }\\n\\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n    else return bytes1(uint8(b) + 0x57);\\n  }\\n\\n}\\n\",\"keccak256\":\"0xe7fef8dd3d994fd08ac32e3eff07f39546cc58dc0101f5fc7c0efebfb4f3f01a\",\"license\":\"BUSL-1.1\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        // only check isContract if the call was successful and the return data is empty\\n        // otherwise we already know that it was a contract\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n    // Look for revert reason and bubble it up if present\\n    if (returndata.length > 0) {\\n      // The easiest way to bubble the revert reason is using memory via assembly\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xcc7eeaafd4384e04ff39e0c01f0a6794736c34cad529751b8abd7b088ecc2e83\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n     */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == type(IERC165).interfaceId;\\n  }\\n}\\n\",\"keccak256\":\"0xcaaf196e5c26fdcd072a9f0833b54cf9fbd12d08be59898f04611f685d31707a\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n  uint8 private _initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n  bool private _initializing;\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n  event Initialized(uint8 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier initializer() {\\n    bool isTopLevelCall = !_initializing;\\n    require(\\n      (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n      \\\"Initializable: contract is already initialized\\\"\\n    );\\n    _initialized = 1;\\n    if (isTopLevelCall) {\\n      _initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      _initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier reinitializer(uint8 version) {\\n    require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n    _initialized = version;\\n    _initializing = true;\\n    _;\\n    _initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n  modifier onlyInitializing() {\\n    require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n  function _disableInitializers() internal virtual {\\n    require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n    if (_initialized != type(uint8).max) {\\n      _initialized = type(uint8).max;\\n      emit Initialized(type(uint8).max);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n  function _getInitializedVersion() internal view returns (uint8) {\\n    return _initialized;\\n  }\\n\\n  /**\\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n  function _isInitializing() internal view returns (bool) {\\n    return _initializing;\\n  }\\n}\\n\",\"keccak256\":\"0x3c7a20b7e9d134311f43e27990f32c75ff6cb461a6136c4f83fc20734f1d82e0\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n  enum Rounding {\\n    Down, // Toward negative infinity\\n    Up, // Toward infinity\\n    Zero // Toward zero\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b - 1) / b can overflow on addition, so we distribute.\\n    return a == 0 ? 0 : (a - 1) / b + 1;\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n  unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly {\\n      let mm := mulmod(x, y, not(0))\\n      prod0 := mul(x, y)\\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n      return prod0 / denominator;\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly {\\n    // Compute remainder using mulmod.\\n      remainder := mulmod(x, y, denominator)\\n\\n    // Subtract 256 bit number from 512 bit number.\\n      prod1 := sub(prod1, gt(remainder, prod0))\\n      prod0 := sub(prod0, remainder)\\n    }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n    // See https://cs.stackexchange.com/q/138556/92363.\\n\\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\\n    uint256 twos = denominator & (~denominator + 1);\\n    assembly {\\n    // Divide denominator by twos.\\n      denominator := div(denominator, twos)\\n\\n    // Divide [prod1 prod0] by twos.\\n      prod0 := div(prod0, twos)\\n\\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n      twos := add(div(sub(0, twos), twos), 1)\\n    }\\n\\n    // Shift in bits from prod1 into prod0.\\n    prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n    uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n    // in modular arithmetic, doubling the correct bits in each step.\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n    result = prod0 * inverse;\\n    return result;\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator,\\n    Rounding rounding\\n  ) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n  unchecked {\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    return min(result, a / result);\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = sqrt(a);\\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 128;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 64;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 32;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 16;\\n    }\\n    if (value >> 8 > 0) {\\n      value >>= 8;\\n      result += 8;\\n    }\\n    if (value >> 4 > 0) {\\n      value >>= 4;\\n      result += 4;\\n    }\\n    if (value >> 2 > 0) {\\n      value >>= 2;\\n      result += 2;\\n    }\\n    if (value >> 1 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log2(value);\\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >= 10**64) {\\n      value /= 10**64;\\n      result += 64;\\n    }\\n    if (value >= 10**32) {\\n      value /= 10**32;\\n      result += 32;\\n    }\\n    if (value >= 10**16) {\\n      value /= 10**16;\\n      result += 16;\\n    }\\n    if (value >= 10**8) {\\n      value /= 10**8;\\n      result += 8;\\n    }\\n    if (value >= 10**4) {\\n      value /= 10**4;\\n      result += 4;\\n    }\\n    if (value >= 10**2) {\\n      value /= 10**2;\\n      result += 2;\\n    }\\n    if (value >= 10**1) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log10(value);\\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 16;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 8;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 4;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 2;\\n    }\\n    if (value >> 8 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log256(value);\\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n  }\\n  }\\n}\\n\",\"keccak256\":\"0x2c5be0f4a60126b08e20f40586958ec1b76a27b69406c4b0db19e9dc6f771cfc\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n  unchecked {\\n    uint256 oldAllowance = token.allowance(address(this), spender);\\n    require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n    uint256 newAllowance = oldAllowance - value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n  }\\n\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x2378ee07b24e40c75781b27b2aa0812769c0000964e2d2501e3d234d3285dd18\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/proxy/ControllableV3.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/Initializable.sol\\\";\\nimport \\\"../tools/TetuERC165.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../lib/SlotsLib.sol\\\";\\nimport \\\"../lib/InterfaceIds.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"3.0.1\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  /// @dev Prevent implementation init\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\\n    require(IController(controller_).governance() != address(0), \\\"Zero governance\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address _value) public override view returns (bool) {\\n    return _value == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address _value) public override view returns (bool) {\\n    return IController(controller()).governance() == _value;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view returns (uint){\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view returns (address){\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  /// @dev See {IERC165-supportsInterface}.\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n  /// @dev Gets a slot as bytes32\\n  function getSlot(uint slot) external view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x903c41cf5b652b90c959c47013f8ad949e435ec7e98fd021fef12388c78c05a2\",\"license\":\"BUSL-1.1\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV3.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IStrategyV3.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\nimport \\\"../interfaces/IForwarder.sol\\\";\\nimport \\\"../proxy/ControllableV3.sol\\\";\\nimport \\\"./StrategyLib2.sol\\\";\\n\\n/// @title Abstract contract for base strategy functionality\\n/// @author a17\\nabstract contract StrategyBaseV3 is IStrategyV3, ControllableV3 {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Version of this contract. Adjust manually on each code modification.\\n  string public constant STRATEGY_BASE_VERSION = \\\"3.0.1\\\";\\n\\n  // *************************************************************\\n  //                        VARIABLES\\n  //                Keep names and ordering!\\n  //                 Add only in the bottom.\\n  // *************************************************************\\n\\n  BaseState internal baseState;\\n\\n  // *************************************************************\\n  //                        INIT\\n  // *************************************************************\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  function __StrategyBase_init(\\n    address controller_,\\n    address splitter_\\n  ) internal onlyInitializing {\\n    _requireInterface(splitter_, InterfaceIds.I_SPLITTER);\\n    __Controllable_init(controller_);\\n    StrategyLib2.init(baseState, controller_, splitter_);\\n  }\\n\\n  // *************************************************************\\n  //                        VIEWS\\n  // *************************************************************\\n\\n  /// @dev Total amount of underlying assets under control of this strategy.\\n  function totalAssets() public view override returns (uint) {\\n    return IERC20(baseState.asset).balanceOf(address(this)) + investedAssets();\\n  }\\n\\n  /// @dev See {IERC165-supportsInterface}.\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == InterfaceIds.I_STRATEGY_V3 || interfaceId == InterfaceIds.I_STRATEGY_V2 || super.supportsInterface(interfaceId);\\n  }\\n\\n  function asset() external view returns (address) {\\n    return baseState.asset;\\n  }\\n\\n  function splitter() external view returns (address) {\\n    return baseState.splitter;\\n  }\\n\\n  function compoundRatio() external view returns (uint) {\\n    return baseState.compoundRatio;\\n  }\\n\\n  function performanceReceiver() external view returns (address) {\\n    return baseState.performanceReceiver;\\n  }\\n\\n  function performanceFee() external view returns (uint) {\\n    return baseState.performanceFee;\\n  }\\n\\n  function performanceFeeRatio() external view returns (uint) {\\n    return baseState.performanceFeeRatio;\\n  }\\n\\n  function strategySpecificName() external view returns (string memory) {\\n    return baseState.strategySpecificName;\\n  }\\n\\n  // *************************************************************\\n  //                   VOTER ACTIONS\\n  // *************************************************************\\n\\n  /// @dev PlatformVoter can change compound ratio for some strategies.\\n  ///      A strategy can implement another logic for some uniq cases.\\n  function setCompoundRatio(uint value) external virtual override {\\n    StrategyLib2._changeCompoundRatio(baseState, controller(), value);\\n  }\\n\\n  // *************************************************************\\n  //                   OPERATOR ACTIONS\\n  // *************************************************************\\n\\n  /// @dev The name will be used for UI.\\n  function setStrategySpecificName(string calldata name) external {\\n    StrategyLib2.onlyOperators(controller());\\n    StrategyLib2._changeStrategySpecificName(baseState, name);\\n  }\\n\\n  /// @dev In case of any issue operator can withdraw all from pool.\\n  function emergencyExit() external {\\n    // check inside lib call\\n\\n    _emergencyExitFromPool();\\n    StrategyLib2.sendOnEmergencyExit(controller(), baseState.asset, baseState.splitter);\\n  }\\n\\n  /// @dev Manual claim rewards.\\n  function claim() external {\\n    StrategyLib2._checkManualClaim(controller());\\n    _claim();\\n  }\\n\\n  // *************************************************************\\n  //                   GOVERNANCE ACTIONS\\n  // *************************************************************\\n\\n  /// @notice Set performance fee, receiver and ratio\\n  function setupPerformanceFee(uint fee_, address receiver_, uint ratio_) external {\\n    StrategyLib2.setupPerformanceFee(baseState, fee_, receiver_, ratio_, controller());\\n  }\\n\\n  // *************************************************************\\n  //                    DEPOSIT/WITHDRAW\\n  // *************************************************************\\n\\n  /// @notice Stakes everything the strategy holds into the reward pool.\\n  /// amount_ Amount transferred to the strategy balance just before calling this function\\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\\n  ///                                       It can be false if we know exactly, that the amount is already actual.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function investAll(\\n    uint /*amount_*/,\\n    bool updateTotalAssetsBeforeInvest_\\n  ) external override returns (\\n    uint strategyLoss\\n  ) {\\n    uint balance = StrategyLib2._checkInvestAll(baseState.splitter, baseState.asset);\\n\\n    if (balance > 0) {\\n      strategyLoss = _depositToPool(balance, updateTotalAssetsBeforeInvest_);\\n    }\\n\\n    return strategyLoss;\\n  }\\n\\n  /// @dev Withdraws all underlying assets to the vault\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawAllToSplitter() external override returns (uint strategyLoss) {\\n    address _splitter = baseState.splitter;\\n    address _asset = baseState.asset;\\n\\n    uint balance = StrategyLib2._checkSplitterSenderAndGetBalance(_splitter, _asset);\\n\\n    (uint expectedWithdrewUSD, uint assetPrice, uint _strategyLoss) = _withdrawAllFromPool();\\n\\n    StrategyLib2._withdrawAllToSplitterPostActions(\\n      _asset,\\n      balance,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n    return _strategyLoss;\\n  }\\n\\n  /// @dev Withdraws some assets to the splitter\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawToSplitter(uint amount) external override returns (uint strategyLoss) {\\n    address _splitter = baseState.splitter;\\n    address _asset = baseState.asset;\\n\\n    uint balance = StrategyLib2._checkSplitterSenderAndGetBalance(_splitter, _asset);\\n\\n    if (amount > balance) {\\n      uint expectedWithdrewUSD;\\n      uint assetPrice;\\n\\n      (expectedWithdrewUSD, assetPrice, strategyLoss) = _withdrawFromPool(amount - balance);\\n      balance = StrategyLib2.checkWithdrawImpact(\\n        _asset,\\n        balance,\\n        expectedWithdrewUSD,\\n        assetPrice,\\n        _splitter\\n      );\\n    }\\n\\n    StrategyLib2._withdrawToSplitterPostActions(\\n      amount,\\n      balance,\\n      _asset,\\n      _splitter\\n    );\\n    return strategyLoss;\\n  }\\n\\n  // *************************************************************\\n  //                       VIRTUAL\\n  // These functions must be implemented in the strategy contract\\n  // *************************************************************\\n\\n  /// @dev Amount of underlying assets invested to the pool.\\n  function investedAssets() public view virtual returns (uint);\\n\\n  /// @notice Deposit given amount to the pool.\\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\\n  ///                                       It can be false if we know exactly, that the amount is already actual.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function _depositToPool(\\n    uint amount,\\n    bool updateTotalAssetsBeforeInvest_\\n  ) internal virtual returns (\\n    uint strategyLoss\\n  );\\n\\n  /// @dev Withdraw given amount from the pool.\\n  /// @return expectedWithdrewUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\\n  /// @return assetPrice Price of the strategy {asset}.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function _withdrawFromPool(uint amount) internal virtual returns (\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    uint strategyLoss\\n  );\\n\\n  /// @dev Withdraw all from the pool.\\n  /// @return expectedWithdrewUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\\n  /// @return assetPrice Price of the strategy {asset}.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function _withdrawAllFromPool() internal virtual returns (\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    uint strategyLoss\\n  );\\n\\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\\n  ///      Withdraw assets without impact checking.\\n  function _emergencyExitFromPool() internal virtual;\\n\\n  /// @dev Claim all possible rewards.\\n  function _claim() internal virtual returns (address[] memory rewardTokens, uint[] memory amounts);\\n\\n  /// @dev This empty reserved space is put in place to allow future versions to add new\\n  ///      variables without shifting down storage in the inheritance chain.\\n  ///      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n  uint[50 - 7] private __gap;\\n}\\n\",\"keccak256\":\"0xe38a85a74609ad7047635c8d8fc37a12b4e5731903aa1dcc434a1705c09db06f\",\"license\":\"BUSL-1.1\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/SafeERC20.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\n\\nlibrary StrategyLib {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Denominator for fee calculation.\\n  uint internal constant FEE_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        EVENTS\\n  // *************************************************************\\n\\n  event CompoundRatioChanged(uint oldValue, uint newValue);\\n  event StrategySpecificNameChanged(string name);\\n  event EmergencyExit(address sender, uint amount);\\n  event ManualClaim(address sender);\\n  event InvestAll(uint balance);\\n  event WithdrawAllToSplitter(uint amount);\\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\\n\\n  // *************************************************************\\n  //                        ERRORS\\n  // *************************************************************\\n\\n  string internal constant DENIED = \\\"SB: Denied\\\";\\n  string internal constant TOO_HIGH = \\\"SB: Too high\\\";\\n  string internal constant WRONG_VALUE = \\\"SB: Wrong value\\\";\\n  /// @dev Denominator for compound ratio\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        CHECKS AND EMITS\\n  // *************************************************************\\n\\n  function _checkCompoundRatioChanged(address controller, uint oldValue, uint newValue) external {\\n    onlyPlatformVoter(controller);\\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\\n    emit CompoundRatioChanged(oldValue, newValue);\\n  }\\n\\n  function _checkStrategySpecificNameChanged(address controller, string calldata newName) external {\\n    onlyOperators(controller);\\n    emit StrategySpecificNameChanged(newName);\\n  }\\n\\n  function _checkManualClaim(address controller) external {\\n    onlyOperators(controller);\\n    emit ManualClaim(msg.sender);\\n  }\\n\\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\\n    onlySplitter(splitter);\\n    assetBalance = IERC20(asset).balanceOf(address(this));\\n    emit InvestAll(assetBalance);\\n  }\\n\\n  // *************************************************************\\n  //                     RESTRICTIONS\\n  // *************************************************************\\n\\n  /// @dev Restrict access only for operators\\n  function onlyOperators(address controller) public view {\\n    require(IController(controller).isOperator(msg.sender), DENIED);\\n  }\\n\\n  /// @dev Restrict access only for governance\\n  function onlyGovernance(address controller) public view {\\n    require(IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for platform voter\\n  function onlyPlatformVoter(address controller) public view {\\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for splitter\\n  function onlySplitter(address splitter) public view {\\n    require(splitter == msg.sender, DENIED);\\n  }\\n\\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_) external view {\\n    onlyGovernance(controller);\\n    require(fee_ <= 100_000, TOO_HIGH);\\n    require(receiver_ != address(0), WRONG_VALUE);\\n  }\\n\\n  // *************************************************************\\n  //                       HELPERS\\n  // *************************************************************\\n\\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\\n  ///         Revert if the amount is different from expected too much (high price impact)\\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\\n  /// @param assetPrice Price of the asset, decimals 18\\n  /// @return balance Current asset balance of the strategy\\n  function checkWithdrawImpact(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) public view returns (uint balance) {\\n    balance = IERC20(_asset).balanceOf(address(this));\\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\\n\\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\\n    }\\n  }\\n\\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\\n    onlyOperators(controller);\\n\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    IERC20(asset).safeTransfer(splitter, balance);\\n    emit EmergencyExit(msg.sender, balance);\\n  }\\n\\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\\n    onlySplitter(splitter);\\n    return IERC20(asset).balanceOf(address(this));\\n  }\\n\\n  function _withdrawAllToSplitterPostActions(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) external {\\n    uint balance = checkWithdrawImpact(\\n      _asset,\\n      balanceBefore,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n\\n    if (balance != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, balance);\\n    }\\n    emit WithdrawAllToSplitter(balance);\\n  }\\n\\n  function _withdrawToSplitterPostActions(\\n    uint amount,\\n    uint balance,\\n    address _asset,\\n    address _splitter\\n  ) external {\\n    uint amountAdjusted = Math.min(amount, balance);\\n    if (amountAdjusted != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\\n    }\\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\\n  }\\n}\\n\",\"keccak256\":\"0xa89e85b9acaeb5238c11c864167c152d0c33cf800fa3bb447e0629ed6fbff67c\",\"license\":\"BUSL-1.1\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib2.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/SafeERC20.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\nimport \\\"../interfaces/IStrategyV3.sol\\\";\\n\\nlibrary StrategyLib2 {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Denominator for fee calculation.\\n  uint internal constant FEE_DENOMINATOR = 100_000;\\n  /// @notice 10% of total profit is sent to {performanceReceiver} before compounding\\n  uint internal constant DEFAULT_PERFORMANCE_FEE = 10_000;\\n  address internal constant DEFAULT_PERF_FEE_RECEIVER = 0x9Cc199D4353b5FB3e6C8EEBC99f5139e0d8eA06b;\\n  /// @dev Denominator for compound ratio\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        ERRORS\\n  // *************************************************************\\n\\n  string internal constant DENIED = \\\"SB: Denied\\\";\\n  string internal constant TOO_HIGH = \\\"SB: Too high\\\";\\n  string internal constant WRONG_VALUE = \\\"SB: Wrong value\\\";\\n\\n  // *************************************************************\\n  //                        EVENTS\\n  // *************************************************************\\n\\n  event CompoundRatioChanged(uint oldValue, uint newValue);\\n  event StrategySpecificNameChanged(string name);\\n  event EmergencyExit(address sender, uint amount);\\n  event ManualClaim(address sender);\\n  event InvestAll(uint balance);\\n  event WithdrawAllToSplitter(uint amount);\\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\\n  event PerformanceFeeChanged(uint fee, address receiver, uint ratio);\\n\\n  // *************************************************************\\n  //                        CHECKS AND EMITS\\n  // *************************************************************\\n\\n  function _checkManualClaim(address controller) external {\\n    onlyOperators(controller);\\n    emit ManualClaim(msg.sender);\\n  }\\n\\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\\n    onlySplitter(splitter);\\n    assetBalance = IERC20(asset).balanceOf(address(this));\\n    emit InvestAll(assetBalance);\\n  }\\n\\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_, uint ratio_) internal {\\n    onlyGovernance(controller);\\n    require(fee_ <= FEE_DENOMINATOR, TOO_HIGH);\\n    require(receiver_ != address(0), WRONG_VALUE);\\n    require(ratio_ <= FEE_DENOMINATOR, TOO_HIGH);\\n    emit PerformanceFeeChanged(fee_, receiver_, ratio_);\\n  }\\n\\n  // *************************************************************\\n  //                        SETTERS\\n  // *************************************************************\\n\\n  function _changeCompoundRatio(IStrategyV3.BaseState storage baseState, address controller, uint newValue) external {\\n    onlyPlatformVoterOrGov(controller);\\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\\n\\n    uint oldValue = baseState.compoundRatio;\\n    baseState.compoundRatio = newValue;\\n\\n    emit CompoundRatioChanged(oldValue, newValue);\\n  }\\n\\n  function _changeStrategySpecificName(IStrategyV3.BaseState storage baseState, string calldata newName) external {\\n    baseState.strategySpecificName = newName;\\n    emit StrategySpecificNameChanged(newName);\\n  }\\n\\n  // *************************************************************\\n  //                     RESTRICTIONS\\n  // *************************************************************\\n\\n  /// @dev Restrict access only for operators\\n  function onlyOperators(address controller) public view {\\n    require(IController(controller).isOperator(msg.sender), DENIED);\\n  }\\n\\n  /// @dev Restrict access only for governance\\n  function onlyGovernance(address controller) public view {\\n    require(IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for platform voter\\n  function onlyPlatformVoterOrGov(address controller) public view {\\n    require(IController(controller).platformVoter() == msg.sender || IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for splitter\\n  function onlySplitter(address splitter) public view {\\n    require(splitter == msg.sender, DENIED);\\n  }\\n\\n  // *************************************************************\\n  //                       HELPERS\\n  // *************************************************************\\n\\n  function init(\\n    IStrategyV3.BaseState storage baseState,\\n    address controller_,\\n    address splitter_\\n  ) external {\\n    baseState.asset = ISplitter(splitter_).asset();\\n    baseState.splitter = splitter_;\\n    baseState.performanceReceiver = DEFAULT_PERF_FEE_RECEIVER;\\n    baseState.performanceFee = DEFAULT_PERFORMANCE_FEE;\\n\\n    require(IControllable(splitter_).isController(controller_), WRONG_VALUE);\\n  }\\n\\n  function setupPerformanceFee(IStrategyV3.BaseState storage baseState, uint fee_, address receiver_, uint ratio_, address controller_) external {\\n    _checkSetupPerformanceFee(controller_, fee_, receiver_, ratio_);\\n    baseState.performanceFee = fee_;\\n    baseState.performanceReceiver = receiver_;\\n    baseState.performanceFeeRatio = ratio_;\\n  }\\n\\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\\n  ///         Revert if the amount is different from expected too much (high price impact)\\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\\n  /// @param assetPrice Price of the asset, decimals 18\\n  /// @return balance Current asset balance of the strategy\\n  function checkWithdrawImpact(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) public view returns (uint balance) {\\n    balance = IERC20(_asset).balanceOf(address(this));\\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\\n\\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\\n    }\\n  }\\n\\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\\n    onlyOperators(controller);\\n\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    IERC20(asset).safeTransfer(splitter, balance);\\n    emit EmergencyExit(msg.sender, balance);\\n  }\\n\\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\\n    onlySplitter(splitter);\\n    return IERC20(asset).balanceOf(address(this));\\n  }\\n\\n  function _withdrawAllToSplitterPostActions(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) external {\\n    uint balance = checkWithdrawImpact(\\n      _asset,\\n      balanceBefore,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n\\n    if (balance != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, balance);\\n    }\\n    emit WithdrawAllToSplitter(balance);\\n  }\\n\\n  function _withdrawToSplitterPostActions(\\n    uint amount,\\n    uint balance,\\n    address _asset,\\n    address _splitter\\n  ) external {\\n    uint amountAdjusted = Math.min(amount, balance);\\n    if (amountAdjusted != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\\n    }\\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\\n  }\\n}\\n\",\"keccak256\":\"0x63704dba8a701606a0100190d2e46e4c7599571d0b21467b9cd8f87468a7947b\",\"license\":\"BUSL-1.1\"},\"@tetu_io/tetu-contracts-v2/contracts/tools/TetuERC165.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/ERC165.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../lib/InterfaceIds.sol\\\";\\n\\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\\n/// @author bogdoslav\\nabstract contract TetuERC165 is ERC165 {\\n\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\\n  }\\n\\n  // *************************************************************\\n  //                        HELPER FUNCTIONS\\n  // *************************************************************\\n  /// @author bogdoslav\\n\\n  /// @dev Checks what interface with id is supported by contract.\\n  /// @return bool. Do not throws\\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\\n    require(contractAddress != address(0), \\\"Zero address\\\");\\n    // check what address is contract\\n    uint codeSize;\\n    assembly {\\n      codeSize := extcodesize(contractAddress)\\n    }\\n    if (codeSize == 0) return false;\\n\\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\\n      return isSupported;\\n    } catch {\\n    }\\n    return false;\\n  }\\n\\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\\n    require(_isInterfaceSupported(contractAddress, interfaceId), \\\"Interface is not supported\\\");\\n  }\\n\\n  /// @dev Checks what address is ERC20.\\n  /// @return bool. Do not throws\\n  function _isERC20(address contractAddress) internal view returns (bool) {\\n    require(contractAddress != address(0), \\\"Zero address\\\");\\n    // check what address is contract\\n    uint codeSize;\\n    assembly {\\n      codeSize := extcodesize(contractAddress)\\n    }\\n    if (codeSize == 0) return false;\\n\\n    bool totalSupplySupported;\\n    try IERC20(contractAddress).totalSupply() returns (uint) {\\n      totalSupplySupported = true;\\n    } catch {\\n    }\\n\\n    bool balanceSupported;\\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\\n      balanceSupported = true;\\n    } catch {\\n    }\\n\\n    return totalSupplySupported && balanceSupported;\\n  }\\n\\n\\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\\n  function _requireERC20(address contractAddress) internal view {\\n    require(_isERC20(contractAddress), \\\"Not ERC20\\\");\\n  }\\n}\\n\",\"keccak256\":\"0xa6eb1009f769fbca986553c7f32af09c9e66c330b4b8c7b8344997001e2cd4f1\",\"license\":\"BUSL-1.1\"},\"@tetu_io/tetu-converter/contracts/interfaces/IBookkeeper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IBookkeeper {\\n  /// @notice Register a new loan\\n  /// @dev This function can be called by a pool adapter only\\n  /// @param collateralAmount Amount of supplied collateral for the new loan\\n  /// @param borrowedAmount Borrowed amount provided for the given {collateralAmount}\\n  function onBorrow(uint collateralAmount, uint borrowedAmount) external;\\n\\n  /// @notice Register loan payment\\n  /// @dev This function can be called by a pool adapter only\\n  /// @param withdrawnCollateral Amount of collateral received by the user during the repaying.\\n  /// @param paidAmount Amount paid by the user during the repaying.\\n  function onRepay(uint withdrawnCollateral, uint paidAmount) external;\\n\\n\\n  /// @notice Save checkpoint for all pool adapters of the given {user_}\\n  /// @return deltaGains Total amount of gains for the {tokens_} by all pool adapter\\n  /// @return deltaLosses Total amount of losses for the {tokens_} by all pool adapter\\n  function checkpoint(address[] memory tokens_) external returns (\\n    uint[] memory deltaGains,\\n    uint[] memory deltaLosses\\n  );\\n\\n  /// @notice Calculate deltas that user would receive if he creates a checkpoint at the moment\\n  /// @return deltaGains Total amount of gains for the {tokens_} by all pool adapter\\n  /// @return deltaLosses Total amount of losses for the {tokens_} by all pool adapter\\n  function previewCheckpoint(address user, address[] memory tokens_) external view returns (\\n    uint[] memory deltaGains,\\n    uint[] memory deltaLosses\\n  );\\n\\n  /// @notice Calculate total amount of gains and looses in underlying by all pool adapters of the signer\\n  ///         for the current period, start new period.\\n  /// @param underlying_ Asset in which we calculate gains and loss. Assume that it's either collateral or borrow asset.\\n  /// @return gains Total amount of gains (supply-profit) of the {user_} by all user's pool adapters\\n  /// @return losses Total amount of losses (paid increases to debt) of the {user_} by all user's pool adapters\\n  function startPeriod(address underlying_) external returns (\\n    uint gains,\\n    uint losses\\n  );\\n\\n  /// @notice Calculate total amount of gains and looses in underlying by all pool adapters of the {user_}\\n  ///         for the current period, DON'T start new period.\\n  /// @param underlying_ Asset in which we calculate gains and loss. Assume that it's either collateral or borrow asset.\\n  /// @return gains Total amount of gains (supply-profit) of the {user_} by all user's pool adapters\\n  /// @return losses Total amount of losses (paid increases to debt) of the {user_} by all user's pool adapters\\n  function previewPeriod(address underlying_, address user_) external view returns (uint gains, uint losses);\\n}\",\"keccak256\":\"0x98b7887d604ebcfaf28038c456c6c6893ce10f55b821f4c7c002dbc8055ea388\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/// @notice Keep and provide addresses of all application contracts\\ninterface IConverterController {\\n  function governance() external view returns (address);\\n\\n  // ********************* Health factor explanation  ****************\\n  // For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\\n  // For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\\n  // We set min-health-factor = 1.1, target-health-factor = 1.3\\n  // For collateral 100 we will borrow 100/1.3 = 76.92\\n  //\\n  // Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\\n  // Collateral * LT    85         65.45\\n  // Borrow value       65.38      65.38         but borrow value is the same as before\\n  // Health factor      1.3        1.001         liquidation almost happens here (!)\\n  //\\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\\n  // and the borrow value won't change at the same time, the liquidation happens at that point.\\n  // Min health factor marks the point at which a rebalancing must be made asap.\\n  // *****************************************************************\\n\\n  //#region ----------------------------------------------------- Configuration\\n\\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\\n  function minHealthFactor2() external view returns (uint16);\\n  function setMinHealthFactor2(uint16 value_) external;\\n\\n  /// @notice target health factor with decimals 2\\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\\n  ///      or additional borrow and restore the health factor to the given target value\\n  function targetHealthFactor2() external view returns (uint16);\\n  function setTargetHealthFactor2(uint16 value_) external;\\n\\n  /// @notice max allowed health factor with decimals 2\\n  /// @dev For future versions, currently max health factor is not used\\n  function maxHealthFactor2() external view returns (uint16);\\n  /// @dev For future versions, currently max health factor is not used\\n  function setMaxHealthFactor2(uint16 value_) external;\\n\\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\\n  function blocksPerDay() external view returns (uint);\\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\\n  /// @notice Check if it's time to call updateBlocksPerDay()\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\\n  /// @notice Recalculate blocksPerDay value\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function updateBlocksPerDay(uint periodInSeconds_) external;\\n\\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\\n  function paused() external view returns (bool);\\n\\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\\n  function isWhitelisted(address user_) external view returns (bool);\\n\\n  /// @notice The size of the gap by which the debt should be increased upon repayment\\n  ///         Such gaps are required by AAVE pool adapters to workaround dust tokens problem\\n  ///         and be able to make full repayment.\\n  /// @dev Debt gap is applied as following: toPay = debt * (DEBT_GAP_DENOMINATOR + debtGap) / DEBT_GAP_DENOMINATOR\\n  function debtGap() external view returns (uint);\\n\\n  /// @notice Allow to rebalance exist debts during burrow, see SCB-708\\n  ///         If the user already has a debt(s) for the given pair of collateral-borrow assets,\\n  ///         new borrow is made using exist pool adapter(s). Exist debt is rebalanced during the borrowing\\n  ///         in both directions, but the rebalancing is asymmetrically limited by thresholds\\n  ///         THRESHOLD_REBALANCE_XXX, see BorrowManager.\\n  function rebalanceOnBorrowEnabled() external view returns (bool);\\n\\n  //#endregion ----------------------------------------------------- Configuration\\n  //#region ----------------------------------------------------- Core application contracts\\n\\n  function tetuConverter() external view returns (address);\\n  function borrowManager() external view returns (address);\\n  function debtMonitor() external view returns (address);\\n  function tetuLiquidator() external view returns (address);\\n  function swapManager() external view returns (address);\\n  function priceOracle() external view returns (address);\\n  function bookkeeper() external view returns (address);\\n  //#endregion ----------------------------------------------------- Core application contracts\\n\\n  //#region ----------------------------------------------------- External contracts\\n  /// @notice A keeper to control health and efficiency of the borrows\\n  function keeper() external view returns (address);\\n  /// @notice Controller of tetu-contracts-v2, that is allowed to update proxy contracts\\n  function proxyUpdater() external view returns (address);\\n  //#endregion ----------------------------------------------------- External contracts\\n}\\n\",\"keccak256\":\"0xff68dab4badf9543c9a0ae5a1314106f0a5b804e8b6669fbea6e2655eb3c741f\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterControllerProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IConverterControllerProvider {\\n  function controller() external view returns (address);\\n}\\n\",\"keccak256\":\"0x71dce61809acb75f9078290e90033ffe816a51f18b7cb296d161e278c36eec86\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IPriceOracle {\\n  /// @notice Return asset price in USD, decimals 18\\n  function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb11e653eb4d6d7c41f29ee1e3e498253cfa8df1aec3ff31ab527009b79bdb705\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IConverterControllerProvider.sol\\\";\\n\\n/// @notice Main contract of the TetuConverter application\\n/// @dev Borrower (strategy) makes all operations via this contract only.\\ninterface ITetuConverter is IConverterControllerProvider {\\n\\n  /// @notice Find possible borrow strategies and provide \\\"cost of money\\\" as interest for the period for each strategy\\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converters Array of available converters ordered in ascending order of APR.\\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\\n  ///                    This address should be passed to borrow-function during conversion.\\n  ///                    The length of array is always equal to the count of available lending platforms.\\n  ///                    Last items in array can contain zero addresses (it means they are not used)\\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\\n  /// @return amountToBorrowsOut Amounts that should be borrowed\\n  ///                            This amount is not zero if corresponded converter is not zero.\\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\\n  function findBorrowStrategies(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external view returns (\\n    address[] memory converters,\\n    uint[] memory collateralAmountsOut,\\n    uint[] memory amountToBorrowsOut,\\n    int[] memory aprs18\\n  );\\n\\n  /// @notice Find best swap strategy and provide \\\"cost of money\\\" as interest for the period\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findSwapStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_\\n  ) external returns (\\n    address converter,\\n    uint sourceAmountOut,\\n    uint targetAmountOut,\\n    int apr18\\n  );\\n\\n  /// @notice Find best conversion strategy (swap or borrow) and provide \\\"cost of money\\\" as interest for the period.\\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findConversionStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external returns (\\n    address converter,\\n    uint collateralAmountOut,\\n    uint amountToBorrowOut,\\n    int apr18\\n  );\\n\\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\\n  ///         Target amount will be transferred to {receiver_}.\\n  ///         Exist debts can be rebalanced fully or partially if {rebalanceOnBorrowEnabled} is ON\\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\\n  ///      Only whitelisted users are allowed to make borrows\\n  /// @param converter_ A converter received from findBestConversionStrategy.\\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\\n  ///                          This amount must be approved to TetuConverter before the call.\\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\\n  /// @param receiver_ A receiver of borrowed amount\\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\\n  function borrow(\\n    address converter_,\\n    address collateralAsset_,\\n    uint collateralAmount_,\\n    address borrowAsset_,\\n    uint amountToBorrow_,\\n    address receiver_\\n  ) external returns (\\n    uint borrowedAmountOut\\n  );\\n\\n  /// @notice Full or partial repay of the borrow\\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        A user should transfer {amountToRepay_} to TetuConverter before calling repay().\\n  ///        You can know exact total amount of debt using {getStatusCurrent}.\\n  ///        if the amount exceed total amount of the debt:\\n  ///           - the debt will be fully repaid\\n  ///           - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\\n  ///        This amount should be calculated with taking into account possible debt gap,\\n  ///        You should call getDebtAmountCurrent(debtGap = true) to get this amount.\\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\\n  ///         If TetuConverter is not able to make the swap, it reverts\\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\\n  ///                                 This amount is returned back to the collateralReceiver_\\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\\n  function repay(\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_,\\n    address receiver_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint returnedBorrowAmountOut,\\n    uint swappedLeftoverCollateralOut,\\n    uint swappedLeftoverBorrowOut\\n  );\\n\\n  /// @notice Estimate result amount after making full or partial repay\\n  /// @dev It works in exactly same way as repay() but don't make actual repay\\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\\n  /// @param user_ user whose amount-to-repay will be calculated\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        This amount should be calculated without possible debt gap.\\n  ///        In this way it's differ from {repay}\\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\\n  /// @return swappedAmountOut A part of {collateralAmountOut} that were received by direct swap\\n  function quoteRepay(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint swappedAmountOut\\n  );\\n\\n  /// @notice Update status in all opened positions\\n  ///         After this call getDebtAmount will be able to return exact amount to repay\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountCurrent(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountStored(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external view returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\\n  /// @param user_ user whose debts will be returned\\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\\n  ///                                           even if all borrowed amount will be returned.\\n  ///                                           If this amount is not 0, you ask to get too much collateral.\\n  function estimateRepay(\\n    address user_,\\n    address collateralAsset_,\\n    uint collateralAmountRequired_,\\n    address borrowAsset_\\n  ) external view returns (\\n    uint borrowAssetAmount,\\n    uint unobtainableCollateralAssetAmount\\n  );\\n\\n  /// @notice Transfer all reward tokens to {receiver_}\\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\\n  function claimRewards(address receiver_) external returns (\\n    address[] memory rewardTokensOut,\\n    uint[] memory amountsOut\\n  );\\n\\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\\n  ///                      It should be transferred on balance of the TetuConverter before the function call\\n  /// @param receiver_ Result amount will be sent to this address\\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\\n  function safeLiquidate(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    address receiver_,\\n    uint priceImpactToleranceSource_,\\n    uint priceImpactToleranceTarget_\\n  ) external returns (\\n    uint amountOut\\n  );\\n\\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\\n  function isConversionValid(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    uint amountOut_,\\n    uint priceImpactTolerance_\\n  ) external view returns (bool);\\n\\n  /// @notice Close given borrow and return collateral back to the user, governance only\\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\\n  /// @param poolAdapter_ The pool adapter that represents the borrow\\n  /// @param closePosition Close position after repay\\n  ///        Usually it should be true, because the function always tries to repay all debt\\n  ///        false can be used if user doesn't have enough amount to pay full debt\\n  ///              and we are trying to pay \\\"as much as possible\\\"\\n  /// @return collateralAmountOut Amount of collateral returned to the user\\n  /// @return repaidAmountOut Amount of borrow asset paid to the lending platform\\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\\n    uint collateralAmountOut,\\n    uint repaidAmountOut\\n  );\\n\\n  /// @notice Get active borrows of the user with given collateral/borrowToken\\n  /// @dev Simple access to IDebtMonitor.getPositions\\n  /// @return poolAdaptersOut The instances of IPoolAdapter\\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external view returns (\\n    address[] memory poolAdaptersOut\\n  );\\n\\n  /// @notice Save token from TC-balance to {receiver}\\n  /// @dev Normally TetuConverter doesn't have any tokens on balance, they can appear there accidentally only\\n  function salvage(address receiver, address token, uint amount) external;\\n}\\n\",\"keccak256\":\"0x87ac3099e1254509929511509c207ecee9a665a3b43d7ee5b98e2ab0d639416d\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice TetuConverter sends callback notifications to its user via this interface\\ninterface ITetuConverterCallback {\\n  /// @notice Converters calls this function if user should return some amount back.\\n  ///         f.e. when the health factor is unhealthy and the converter needs more tokens to fix it.\\n  ///         or when the full repay is required and converter needs to get full amount-to-repay.\\n  /// @param asset_ Required asset (either collateral or borrow)\\n  /// @param amount_ Required amount of the {asset_}\\n  /// @return amountOut Exact amount that borrower has sent to balance of TetuConverter\\n  function requirePayAmountBack(address asset_, uint amount_) external returns (uint amountOut);\\n\\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external;\\n}\\n\",\"keccak256\":\"0x1ab7657c44e7725e32ef1a25293f1895911943bb25a8d0afb22a218ee4fa9d5b\",\"license\":\"MIT\"},\"contracts/integrations/algebra/AlgebraFeeConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n// coefficients for sigmoids: \\u03b1 / (1 + e^( (\\u03b2-x) / \\u03b3))\\r\\n// alpha1 + alpha2 + baseFee must be <= type(uint16).max\\r\\nstruct AlgebraFeeConfiguration {\\r\\n  uint16 alpha1; // max value of the first sigmoid\\r\\n  uint16 alpha2; // max value of the second sigmoid\\r\\n  uint32 beta1; // shift along the x-axis for the first sigmoid\\r\\n  uint32 beta2; // shift along the x-axis for the second sigmoid\\r\\n  uint16 gamma1; // horizontal stretch factor for the first sigmoid\\r\\n  uint16 gamma2; // horizontal stretch factor for the second sigmoid\\r\\n  uint16 baseFee; // minimum possible fee\\r\\n}\\r\\n\",\"keccak256\":\"0x49cf3f76051c467d50c8640e4be6bf4491469149714d8ab3fda54c7b3dd10c59\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IAlgebraEternalFarming.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IncentiveKey.sol\\\";\\r\\n\\r\\ninterface IAlgebraEternalFarming {\\r\\n    /// @notice reward amounts can be outdated, actual amounts could be obtained via static call of `collectRewards` in FarmingCenter\\r\\n    function getRewardInfo(\\r\\n        IncentiveKey memory key,\\r\\n        uint256 tokenId\\r\\n    ) external view returns (uint256 reward, uint256 bonusReward);\\r\\n}\",\"keccak256\":\"0x48f100e8fed01242ec72231b385b82fd1146929630dc73532b21a5a46f841ada\",\"license\":\"MIT\"},\"contracts/integrations/algebra/IAlgebraPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nimport './pool/IAlgebraPoolImmutables.sol';\\r\\nimport './pool/IAlgebraPoolState.sol';\\r\\nimport './pool/IAlgebraPoolDerivedState.sol';\\r\\nimport './pool/IAlgebraPoolActions.sol';\\r\\nimport './pool/IAlgebraPoolPermissionedActions.sol';\\r\\nimport './pool/IAlgebraPoolEvents.sol';\\r\\n\\r\\n/**\\r\\n * @title The interface for a Algebra Pool\\r\\n * @dev The pool interface is broken up into many smaller pieces.\\r\\n * Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\n */\\r\\ninterface IAlgebraPool is\\r\\nIAlgebraPoolImmutables,\\r\\nIAlgebraPoolState,\\r\\nIAlgebraPoolDerivedState,\\r\\nIAlgebraPoolActions,\\r\\nIAlgebraPoolPermissionedActions,\\r\\nIAlgebraPoolEvents\\r\\n{\\r\\n  // used only for combining interfaces\\r\\n}\\r\\n\",\"keccak256\":\"0xf55d012b8f05dacd31f6a275e5cdb57c231e4ea79dac4010a0a81d38942d04f3\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IDataStorageOperator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport './AlgebraFeeConfiguration.sol';\\r\\n\\r\\n/// @title The interface for the DataStorageOperator\\r\\n/// @dev This contract stores timepoints and calculates adaptive fee and statistical averages\\r\\ninterface IDataStorageOperator {\\r\\n  /// @notice Emitted when the fee configuration is changed\\r\\n  /// @param feeConfig The structure with dynamic fee parameters\\r\\n  /// @dev See the AdaptiveFee library for more details\\r\\n  event FeeConfiguration(AlgebraFeeConfiguration feeConfig);\\r\\n\\r\\n  /// @notice Returns data belonging to a certain timepoint\\r\\n  /// @param index The index of timepoint in the array\\r\\n  /// @dev There is more convenient function to fetch a timepoint: getTimepoints(). Which requires not an index but seconds\\r\\n  /// @return initialized Whether the timepoint has been initialized and the values are safe to use\\r\\n  /// @return blockTimestamp The timestamp of the timepoint\\r\\n  /// @return tickCumulative The tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp\\r\\n  /// @return volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp\\r\\n  /// @return tick The tick at blockTimestamp\\r\\n  /// @return averageTick Time-weighted average tick\\r\\n  /// @return windowStartIndex Index of closest timepoint >= WINDOW seconds ago\\r\\n  function timepoints(\\r\\n    uint256 index\\r\\n  )\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n      bool initialized,\\r\\n      uint32 blockTimestamp,\\r\\n      int56 tickCumulative,\\r\\n      uint88 volatilityCumulative,\\r\\n      int24 tick,\\r\\n      int24 averageTick,\\r\\n      uint16 windowStartIndex\\r\\n    );\\r\\n\\r\\n  /// @notice Initialize the dataStorage array by writing the first slot. Called once for the lifecycle of the timepoints array\\r\\n  /// @param time The time of the dataStorage initialization, via block.timestamp truncated to uint32\\r\\n  /// @param tick Initial tick\\r\\n  function initialize(uint32 time, int24 tick) external;\\r\\n\\r\\n  /// @dev Reverts if a timepoint at or before the desired timepoint timestamp does not exist.\\r\\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\\r\\n  /// If called with a timestamp falling between two timepoints, returns the counterfactual accumulator values\\r\\n  /// at exactly the timestamp between the two timepoints.\\r\\n  /// @param time The current block timestamp\\r\\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return a timepoint\\r\\n  /// @param tick The current tick\\r\\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\\r\\n  /// @return tickCumulative The cumulative tick since the pool was first initialized, as of `secondsAgo`\\r\\n  /// @return volatilityCumulative The cumulative volatility value since the pool was first initialized, as of `secondsAgo`\\r\\n  function getSingleTimepoint(\\r\\n    uint32 time,\\r\\n    uint32 secondsAgo,\\r\\n    int24 tick,\\r\\n    uint16 index\\r\\n  ) external view returns (int56 tickCumulative, uint112 volatilityCumulative);\\r\\n\\r\\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\\r\\n  /// @dev Reverts if `secondsAgos` > oldest timepoint\\r\\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return a timepoint\\r\\n  /// @return tickCumulatives The cumulative tick since the pool was first initialized, as of each `secondsAgo`\\r\\n  /// @return volatilityCumulatives The cumulative volatility values since the pool was first initialized, as of each `secondsAgo`\\r\\n  function getTimepoints(uint32[] memory secondsAgos) external view returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives);\\r\\n\\r\\n  /// @notice Writes a dataStorage timepoint to the array\\r\\n  /// @dev Writable at most once per block. Index represents the most recently written element. index must be tracked externally.\\r\\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\\r\\n  /// @param blockTimestamp The timestamp of the new timepoint\\r\\n  /// @param tick The active tick at the time of the new timepoint\\r\\n  /// @return indexUpdated The new index of the most recently written element in the dataStorage array\\r\\n  /// @return newFee The fee in hundredths of a bip, i.e. 1e-6\\r\\n  function write(uint16 index, uint32 blockTimestamp, int24 tick) external returns (uint16 indexUpdated, uint16 newFee);\\r\\n\\r\\n  /// @notice Changes fee configuration for the pool\\r\\n  function changeFeeConfiguration(AlgebraFeeConfiguration calldata feeConfig) external;\\r\\n\\r\\n  /// @notice Fills uninitialized timepoints with nonzero value\\r\\n  /// @dev Can be used to reduce the gas cost of future swaps\\r\\n  /// @param startIndex The start index, must be not initialized\\r\\n  /// @param amount of slots to fill, startIndex + amount must be <= type(uint16).max\\r\\n  function prepayTimepointsStorageSlots(uint16 startIndex, uint16 amount) external;\\r\\n}\\r\\n\",\"keccak256\":\"0x758fd0079dd315ce0c5ac9ee1b6bee96ea377b471a22367f6bae10c2b0011713\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IFarmingCenter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IAlgebraEternalFarming.sol\\\";\\r\\nimport \\\"./IncentiveKey.sol\\\";\\r\\nimport \\\"./INonfungiblePositionManager.sol\\\";\\r\\n\\r\\ninterface IFarmingCenter {\\r\\n    /// @notice Returns information about a deposited NFT\\r\\n    /// @param tokenId The ID of the deposit (and token) that is being transferred\\r\\n    /// @return L2TokenId The nft layer2 id,\\r\\n    /// numberOfFarms The number of farms,\\r\\n    /// inLimitFarming The parameter showing if the token is in the limit farm,\\r\\n    /// owner The owner of deposit\\r\\n    function deposits(uint256 tokenId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n        uint256 L2TokenId,\\r\\n        uint32 numberOfFarms,\\r\\n        bool inLimitFarming,\\r\\n        address owner\\r\\n    );\\r\\n\\r\\n    /// @notice Enters in incentive (time-limited or eternal farming) with NFT-position token\\r\\n    /// @dev token must be deposited in FarmingCenter\\r\\n    /// @param key The incentive event key\\r\\n    /// @param tokenId The id of position NFT\\r\\n    /// @param tokensLocked Amount of tokens to lock for liquidity multiplier (if tiers are used)\\r\\n    /// @param isLimit Is incentive time-limited or eternal\\r\\n    function enterFarming(\\r\\n        IncentiveKey memory key,\\r\\n        uint256 tokenId,\\r\\n        uint256 tokensLocked,\\r\\n        bool isLimit\\r\\n    ) external;\\r\\n\\r\\n    function eternalFarming() external view returns (IAlgebraEternalFarming);\\r\\n\\r\\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\\r\\n    /// @dev \\\"proxies\\\" to NonfungiblePositionManager\\r\\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\\r\\n    /// recipient The account that should receive the tokens,\\r\\n    /// amount0Max The maximum amount of token0 to collect,\\r\\n    /// amount1Max The maximum amount of token1 to collect\\r\\n    /// @return amount0 The amount of fees collected in token0\\r\\n    /// @return amount1 The amount of fees collected in token1\\r\\n    function collect(INonfungiblePositionManager.CollectParams calldata params)\\r\\n    external\\r\\n    returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n    /// @notice Used to collect reward from eternal farming. Then reward can be claimed.\\r\\n    /// @param key The incentive event key\\r\\n    /// @param tokenId The id of position NFT\\r\\n    /// @return reward The amount of collected reward\\r\\n    /// @return bonusReward The amount of collected  bonus reward\\r\\n    function collectRewards(IncentiveKey memory key, uint256 tokenId)\\r\\n    external\\r\\n    returns (uint256 reward, uint256 bonusReward);\\r\\n\\r\\n    /// @notice Used to claim and send rewards from farming(s)\\r\\n    /// @dev can be used via static call to get current rewards for user\\r\\n    /// @param rewardToken The token that is a reward\\r\\n    /// @param to The address to be rewarded\\r\\n    /// @param amountRequestedIncentive Amount to claim in incentive (limit) farming\\r\\n    /// @param amountRequestedEternal Amount to claim in eternal farming\\r\\n    /// @return reward The summary amount of claimed rewards\\r\\n    function claimReward(\\r\\n        address rewardToken,\\r\\n        address to,\\r\\n        uint256 amountRequestedIncentive,\\r\\n        uint256 amountRequestedEternal\\r\\n    ) external returns (uint256 reward);\\r\\n\\r\\n    /// @notice Exits from incentive (time-limited or eternal farming) with NFT-position token\\r\\n    /// @param key The incentive event key\\r\\n    /// @param tokenId The id of position NFT\\r\\n    /// @param isLimit Is incentive time-limited or eternal\\r\\n    function exitFarming(\\r\\n        IncentiveKey memory key,\\r\\n        uint256 tokenId,\\r\\n        bool isLimit\\r\\n    ) external;\\r\\n\\r\\n    /// @notice Withdraw Algebra NFT-position token\\r\\n    /// @dev can be used via static call to get current rewards for user\\r\\n    /// @param tokenId The id of position NFT\\r\\n    /// @param to New owner of position NFT\\r\\n    /// @param data The additional data for NonfungiblePositionManager\\r\\n    function withdrawToken(\\r\\n        uint256 tokenId,\\r\\n        address to,\\r\\n        bytes memory data\\r\\n    ) external;\\r\\n}\",\"keccak256\":\"0x63723e96d5493b985517506518f62d55619e05a86ce1c03bf2d5e8d4811337ba\",\"license\":\"MIT\"},\"contracts/integrations/algebra/INonfungiblePositionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface INonfungiblePositionManager {\\r\\n    struct MintParams {\\r\\n        address token0;\\r\\n        address token1;\\r\\n        int24 tickLower;\\r\\n        int24 tickUpper;\\r\\n        uint amount0Desired;\\r\\n        uint amount1Desired;\\r\\n        uint amount0Min;\\r\\n        uint amount1Min;\\r\\n        address recipient;\\r\\n        uint deadline;\\r\\n    }\\r\\n\\r\\n    function mint(\\r\\n        MintParams calldata params\\r\\n    ) external payable returns (uint tokenId, uint128 liquidity, uint amount0, uint amount1);\\r\\n\\r\\n    struct IncreaseLiquidityParams {\\r\\n        uint256 tokenId;\\r\\n        uint256 amount0Desired;\\r\\n        uint256 amount1Desired;\\r\\n        uint256 amount0Min;\\r\\n        uint256 amount1Min;\\r\\n        uint256 deadline;\\r\\n    }\\r\\n\\r\\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\\r\\n    external\\r\\n    payable\\r\\n    returns (\\r\\n        uint128 liquidity,\\r\\n        uint256 amount0,\\r\\n        uint256 amount1\\r\\n    );\\r\\n\\r\\n    struct DecreaseLiquidityParams {\\r\\n        uint tokenId;\\r\\n        uint128 liquidity;\\r\\n        uint amount0Min;\\r\\n        uint amount1Min;\\r\\n        uint deadline;\\r\\n    }\\r\\n\\r\\n    function decreaseLiquidity(\\r\\n        DecreaseLiquidityParams calldata params\\r\\n    ) external payable returns (uint amount0, uint amount1);\\r\\n\\r\\n    struct CollectParams {\\r\\n        uint tokenId;\\r\\n        address recipient;\\r\\n        uint128 amount0Max;\\r\\n        uint128 amount1Max;\\r\\n    }\\r\\n\\r\\n    function collect(CollectParams calldata params) external payable returns (uint amount0, uint amount1);\\r\\n\\r\\n    function burn(uint tokenId) external payable;\\r\\n\\r\\n    function safeTransferFrom(\\r\\n        address from,\\r\\n        address to,\\r\\n        uint256 tokenId\\r\\n    ) external;\\r\\n\\r\\n    function positions(uint256 tokenId)\\r\\n    external\\r\\n    view\\r\\n    returns (\\r\\n        uint96 nonce,\\r\\n        address operator,\\r\\n        address token0,\\r\\n        address token1,\\r\\n        int24 tickLower,\\r\\n        int24 tickUpper,\\r\\n        uint128 liquidity,\\r\\n        uint256 feeGrowthInside0LastX128,\\r\\n        uint256 feeGrowthInside1LastX128,\\r\\n        uint128 tokensOwed0,\\r\\n        uint128 tokensOwed1\\r\\n    );\\r\\n}\",\"keccak256\":\"0x605540fd12c6e7645d7015b0f3303a375a848d028f28ab911d74de6c006e9140\",\"license\":\"MIT\"},\"contracts/integrations/algebra/IncentiveKey.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nstruct IncentiveKey {\\r\\n    address rewardToken;\\r\\n    address bonusRewardToken;\\r\\n    address pool;\\r\\n    uint256 startTime;\\r\\n    uint256 endTime;\\r\\n}\",\"keccak256\":\"0x6aa9017a64134f0ffe6b17049b8811c768641c9daf122ded2ecfcf338d13d7d7\",\"license\":\"MIT\"},\"contracts/integrations/algebra/pool/IAlgebraPoolActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title Permissionless pool actions\\r\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\ninterface IAlgebraPoolActions {\\r\\n  /**\\r\\n   * @notice Sets the initial price for the pool\\r\\n   * @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\r\\n   * @param price the initial sqrt price of the pool as a Q64.96\\r\\n   */\\r\\n  function initialize(uint160 price) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Adds liquidity for the given recipient/bottomTick/topTick position\\r\\n   * @dev The caller of this method receives a callback in the form of IAlgebraMintCallback# AlgebraMintCallback\\r\\n   * in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\r\\n   * on bottomTick, topTick, the amount of liquidity, and the current price.\\r\\n   * @param sender The address which will receive potential surplus of paid tokens\\r\\n   * @param recipient The address for which the liquidity will be created\\r\\n   * @param bottomTick The lower tick of the position in which to add liquidity\\r\\n   * @param topTick The upper tick of the position in which to add liquidity\\r\\n   * @param amount The desired amount of liquidity to mint\\r\\n   * @param data Any data that should be passed through to the callback\\r\\n   * @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\r\\n   * @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\r\\n   * @return liquidityActual The actual minted amount of liquidity\\r\\n   */\\r\\n  function mint(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    int24 bottomTick,\\r\\n    int24 topTick,\\r\\n    uint128 amount,\\r\\n    bytes calldata data\\r\\n  )\\r\\n  external\\r\\n  returns (\\r\\n    uint256 amount0,\\r\\n    uint256 amount1,\\r\\n    uint128 liquidityActual\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Collects tokens owed to a position\\r\\n   * @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\r\\n   * Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\r\\n   * amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\r\\n   * actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\r\\n   * @param recipient The address which should receive the fees collected\\r\\n   * @param bottomTick The lower tick of the position for which to collect fees\\r\\n   * @param topTick The upper tick of the position for which to collect fees\\r\\n   * @param amount0Requested How much token0 should be withdrawn from the fees owed\\r\\n   * @param amount1Requested How much token1 should be withdrawn from the fees owed\\r\\n   * @return amount0 The amount of fees collected in token0\\r\\n   * @return amount1 The amount of fees collected in token1\\r\\n   */\\r\\n  function collect(\\r\\n    address recipient,\\r\\n    int24 bottomTick,\\r\\n    int24 topTick,\\r\\n    uint128 amount0Requested,\\r\\n    uint128 amount1Requested\\r\\n  ) external returns (uint128 amount0, uint128 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\r\\n   * @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\r\\n   * @dev Fees must be collected separately via a call to #collect\\r\\n   * @param bottomTick The lower tick of the position for which to burn liquidity\\r\\n   * @param topTick The upper tick of the position for which to burn liquidity\\r\\n   * @param amount How much liquidity to burn\\r\\n   * @return amount0 The amount of token0 sent to the recipient\\r\\n   * @return amount1 The amount of token1 sent to the recipient\\r\\n   */\\r\\n  function burn(\\r\\n    int24 bottomTick,\\r\\n    int24 topTick,\\r\\n    uint128 amount\\r\\n  ) external returns (uint256 amount0, uint256 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Swap token0 for token1, or token1 for token0\\r\\n   * @dev The caller of this method receives a callback in the form of IAlgebraSwapCallback# AlgebraSwapCallback\\r\\n   * @param recipient The address to receive the output of the swap\\r\\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\\r\\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\r\\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\r\\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\\r\\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\\r\\n   * SwapRouter#SwapCallbackData\\r\\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\r\\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\r\\n   */\\r\\n  function swap(\\r\\n    address recipient,\\r\\n    bool zeroToOne,\\r\\n    int256 amountSpecified,\\r\\n    uint160 limitSqrtPrice,\\r\\n    bytes calldata data\\r\\n  ) external returns (int256 amount0, int256 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Swap token0 for token1, or token1 for token0 (tokens that have fee on transfer)\\r\\n   * @dev The caller of this method receives a callback in the form of I AlgebraSwapCallback# AlgebraSwapCallback\\r\\n   * @param sender The address called this function (Comes from the Router)\\r\\n   * @param recipient The address to receive the output of the swap\\r\\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\\r\\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\r\\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\r\\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\\r\\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\\r\\n   * SwapRouter#SwapCallbackData\\r\\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\r\\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\r\\n   */\\r\\n  function swapSupportingFeeOnInputTokens(\\r\\n    address sender,\\r\\n    address recipient,\\r\\n    bool zeroToOne,\\r\\n    int256 amountSpecified,\\r\\n    uint160 limitSqrtPrice,\\r\\n    bytes calldata data\\r\\n  ) external returns (int256 amount0, int256 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\r\\n   * @dev The caller of this method receives a callback in the form of IAlgebraFlashCallback# AlgebraFlashCallback\\r\\n   * @dev All excess tokens paid in the callback are distributed to liquidity providers as an additional fee. So this method can be used\\r\\n   * to donate underlying tokens to currently in-range liquidity providers by calling with 0 amount{0,1} and sending\\r\\n   * the donation amount(s) from the callback\\r\\n   * @param recipient The address which will receive the token0 and token1 amounts\\r\\n   * @param amount0 The amount of token0 to send\\r\\n   * @param amount1 The amount of token1 to send\\r\\n   * @param data Any data to be passed through to the callback\\r\\n   */\\r\\n  function flash(\\r\\n    address recipient,\\r\\n    uint256 amount0,\\r\\n    uint256 amount1,\\r\\n    bytes calldata data\\r\\n  ) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xdab29d9ea949c29ef153b523fcd821e93eed2ec4787ed57aec4bb507ef25a1dd\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolDerivedState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/**\\r\\n * @title Pool state that is not stored\\r\\n * @notice Contains view functions to provide information about the pool that is computed rather than stored on the\\r\\n * blockchain. The functions here may have variable gas costs.\\r\\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\n */\\r\\ninterface IAlgebraPoolDerivedState {\\r\\n  /**\\r\\n   * @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\r\\n   * @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\r\\n   * the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\r\\n   * you must call it with secondsAgos = [3600, 0].\\r\\n   * @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\r\\n   * log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\r\\n   * @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\r\\n   * @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\r\\n   * @return secondsPerLiquidityCumulatives Cumulative seconds per liquidity-in-range value as of each `secondsAgos`\\r\\n   * from the current block timestamp\\r\\n   * @return volatilityCumulatives Cumulative standard deviation as of each `secondsAgos`\\r\\n   * @return volumePerAvgLiquiditys Cumulative swap volume per liquidity as of each `secondsAgos`\\r\\n   */\\r\\n  function getTimepoints(uint32[] calldata secondsAgos)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    int56[] memory tickCumulatives,\\r\\n    uint160[] memory secondsPerLiquidityCumulatives,\\r\\n    uint112[] memory volatilityCumulatives,\\r\\n    uint256[] memory volumePerAvgLiquiditys\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\\r\\n   * @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\\r\\n   * I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\\r\\n   * snapshot is taken and the second snapshot is taken.\\r\\n   * @param bottomTick The lower tick of the range\\r\\n   * @param topTick The upper tick of the range\\r\\n   * @return innerTickCumulative The snapshot of the tick accumulator for the range\\r\\n   * @return innerSecondsSpentPerLiquidity The snapshot of seconds per liquidity for the range\\r\\n   * @return innerSecondsSpent The snapshot of the number of seconds during which the price was in this range\\r\\n   */\\r\\n  function getInnerCumulatives(int24 bottomTick, int24 topTick)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    int56 innerTickCumulative,\\r\\n    uint160 innerSecondsSpentPerLiquidity,\\r\\n    uint32 innerSecondsSpent\\r\\n  );\\r\\n}\\r\\n\",\"keccak256\":\"0x5fee0d693dad3af5000fbc1274faeb53f2903c7de518d570808b8337014d17af\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolEvents.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title Events emitted by a pool\\r\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\ninterface IAlgebraPoolEvents {\\r\\n  /**\\r\\n   * @notice Emitted exactly once by a pool when #initialize is first called on the pool\\r\\n   * @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\r\\n   * @param price The initial sqrt price of the pool, as a Q64.96\\r\\n   * @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\\r\\n   */\\r\\n  event Initialize(uint160 price, int24 tick);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when liquidity is minted for a given position\\r\\n   * @param sender The address that minted the liquidity\\r\\n   * @param owner The owner of the position and recipient of any minted liquidity\\r\\n   * @param bottomTick The lower tick of the position\\r\\n   * @param topTick The upper tick of the position\\r\\n   * @param liquidityAmount The amount of liquidity minted to the position range\\r\\n   * @param amount0 How much token0 was required for the minted liquidity\\r\\n   * @param amount1 How much token1 was required for the minted liquidity\\r\\n   */\\r\\n  event Mint(\\r\\n    address sender,\\r\\n    address indexed owner,\\r\\n    int24 indexed bottomTick,\\r\\n    int24 indexed topTick,\\r\\n    uint128 liquidityAmount,\\r\\n    uint256 amount0,\\r\\n    uint256 amount1\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when fees are collected by the owner of a position\\r\\n   * @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\\r\\n   * @param owner The owner of the position for which fees are collected\\r\\n   * @param recipient The address that received fees\\r\\n   * @param bottomTick The lower tick of the position\\r\\n   * @param topTick The upper tick of the position\\r\\n   * @param amount0 The amount of token0 fees collected\\r\\n   * @param amount1 The amount of token1 fees collected\\r\\n   */\\r\\n  event Collect(address indexed owner, address recipient, int24 indexed bottomTick, int24 indexed topTick, uint128 amount0, uint128 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when a position's liquidity is removed\\r\\n   * @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\\r\\n   * @param owner The owner of the position for which liquidity is removed\\r\\n   * @param bottomTick The lower tick of the position\\r\\n   * @param topTick The upper tick of the position\\r\\n   * @param liquidityAmount The amount of liquidity to remove\\r\\n   * @param amount0 The amount of token0 withdrawn\\r\\n   * @param amount1 The amount of token1 withdrawn\\r\\n   */\\r\\n  event Burn(address indexed owner, int24 indexed bottomTick, int24 indexed topTick, uint128 liquidityAmount, uint256 amount0, uint256 amount1);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted by the pool for any swaps between token0 and token1\\r\\n   * @param sender The address that initiated the swap call, and that received the callback\\r\\n   * @param recipient The address that received the output of the swap\\r\\n   * @param amount0 The delta of the token0 balance of the pool\\r\\n   * @param amount1 The delta of the token1 balance of the pool\\r\\n   * @param price The sqrt(price) of the pool after the swap, as a Q64.96\\r\\n   * @param liquidity The liquidity of the pool after the swap\\r\\n   * @param tick The log base 1.0001 of price of the pool after the swap\\r\\n   */\\r\\n  event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 price, uint128 liquidity, int24 tick);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted by the pool for any flashes of token0/token1\\r\\n   * @param sender The address that initiated the swap call, and that received the callback\\r\\n   * @param recipient The address that received the tokens from flash\\r\\n   * @param amount0 The amount of token0 that was flashed\\r\\n   * @param amount1 The amount of token1 that was flashed\\r\\n   * @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\\r\\n   * @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\\r\\n   */\\r\\n  event Flash(address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when the community fee is changed by the pool\\r\\n   * @param communityFee0New The updated value of the token0 community fee percent\\r\\n   * @param communityFee1New The updated value of the token1 community fee percent\\r\\n   */\\r\\n  event CommunityFee(uint8 communityFee0New, uint8 communityFee1New);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when new activeIncentive is set\\r\\n   * @param virtualPoolAddress The address of a virtual pool associated with the current active incentive\\r\\n   */\\r\\n  event Incentive(address indexed virtualPoolAddress);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when the fee changes\\r\\n   * @param fee The value of the token fee\\r\\n   */\\r\\n  event Fee(uint16 fee);\\r\\n\\r\\n  /**\\r\\n   * @notice Emitted when the LiquidityCooldown changes\\r\\n   * @param liquidityCooldown The value of locktime for added liquidity\\r\\n   */\\r\\n  event LiquidityCooldown(uint32 liquidityCooldown);\\r\\n}\\r\\n\",\"keccak256\":\"0x8bcfbec86863b5b57cdb0db3b9c24fb7ab496d48af8422dc05556105131fff98\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolImmutables.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\nimport '../IDataStorageOperator.sol';\\r\\n\\r\\n/// @title Pool state that never changes\\r\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\ninterface IAlgebraPoolImmutables {\\r\\n  /**\\r\\n   * @notice The contract that stores all the timepoints and can perform actions with them\\r\\n   * @return The operator address\\r\\n   */\\r\\n  function dataStorageOperator() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice The contract that deployed the pool, which must adhere to the IAlgebraFactory interface\\r\\n   * @return The contract address\\r\\n   */\\r\\n  function factory() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice The first of the two tokens of the pool, sorted by address\\r\\n   * @return The token contract address\\r\\n   */\\r\\n  function token0() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice The second of the two tokens of the pool, sorted by address\\r\\n   * @return The token contract address\\r\\n   */\\r\\n  function token1() external view returns (address);\\r\\n\\r\\n  /**\\r\\n   * @notice The pool tick spacing\\r\\n   * @dev Ticks can only be used at multiples of this value\\r\\n   * e.g.: a tickSpacing of 60 means ticks can be initialized every 60th tick, i.e., ..., -120, -60, 0, 60, 120, ...\\r\\n   * This value is an int24 to avoid casting even though it is always positive.\\r\\n   * @return The tick spacing\\r\\n   */\\r\\n  function tickSpacing() external view returns (int24);\\r\\n\\r\\n  /**\\r\\n   * @notice The maximum amount of position liquidity that can use any tick in the range\\r\\n   * @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\r\\n   * also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\r\\n   * @return The max amount of liquidity per tick\\r\\n   */\\r\\n  function maxLiquidityPerTick() external view returns (uint128);\\r\\n}\\r\\n\",\"keccak256\":\"0x9a1ad90c7909c3ae47eef7e893f720e9ac4a73fae3d49cb7b12db95865dbb848\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolPermissionedActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/**\\r\\n * @title Permissioned pool actions\\r\\n * @notice Contains pool methods that may only be called by the factory owner or tokenomics\\r\\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\n */\\r\\ninterface IAlgebraPoolPermissionedActions {\\r\\n  /**\\r\\n   * @notice Set the community's % share of the fees. Cannot exceed 25% (250)\\r\\n   * @param communityFee0 new community fee percent for token0 of the pool in thousandths (1e-3)\\r\\n   * @param communityFee1 new community fee percent for token1 of the pool in thousandths (1e-3)\\r\\n   */\\r\\n  function setCommunityFee(uint8 communityFee0, uint8 communityFee1) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Sets an active incentive\\r\\n   * @param virtualPoolAddress The address of a virtual pool associated with the incentive\\r\\n   */\\r\\n  function setIncentive(address virtualPoolAddress) external;\\r\\n\\r\\n  /**\\r\\n   * @notice Sets new lock time for added liquidity\\r\\n   * @param newLiquidityCooldown The time in seconds\\r\\n   */\\r\\n  function setLiquidityCooldown(uint32 newLiquidityCooldown) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xaf4720ba8ac271e56d80b101b051dc4301b60f6fc8004407d9ec714131e200a1\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.5.0;\\r\\n\\r\\n/// @title Pool state that can change\\r\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\r\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\r\\ninterface IAlgebraPoolState {\\r\\n  /**\\r\\n   * @notice The globalState structure in the pool stores many values but requires only one slot\\r\\n   * and is exposed as a single method to save gas when accessed externally.\\r\\n   * @return price The current price of the pool as a sqrt(token1/token0) Q64.96 value;\\r\\n   * Returns tick The current tick of the pool, i.e. according to the last tick transition that was run;\\r\\n   * Returns This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick\\r\\n   * boundary;\\r\\n   * Returns fee The last pool fee value in hundredths of a bip, i.e. 1e-6;\\r\\n   * Returns timepointIndex The index of the last written timepoint;\\r\\n   * Returns communityFeeToken0 The community fee percentage of the swap fee in thousandths (1e-3) for token0;\\r\\n   * Returns communityFeeToken1 The community fee percentage of the swap fee in thousandths (1e-3) for token1;\\r\\n   * Returns unlocked Whether the pool is currently locked to reentrancy;\\r\\n   */\\r\\n  function globalState()\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    uint160 price,\\r\\n    int24 tick,\\r\\n    uint16 fee,\\r\\n    uint16 timepointIndex,\\r\\n    uint8 communityFeeToken0,\\r\\n    uint8 communityFeeToken1,\\r\\n    bool unlocked\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\r\\n   * @dev This value can overflow the uint256\\r\\n   */\\r\\n  function totalFeeGrowth0Token() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\r\\n   * @dev This value can overflow the uint256\\r\\n   */\\r\\n  function totalFeeGrowth1Token() external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @notice The currently in range liquidity available to the pool\\r\\n   * @dev This value has no relationship to the total liquidity across all ticks.\\r\\n   * Returned value cannot exceed type(uint128).max\\r\\n   */\\r\\n  function liquidity() external view returns (uint128);\\r\\n\\r\\n  /**\\r\\n   * @notice Look up information about a specific tick in the pool\\r\\n   * @dev This is a public structure, so the `return` natspec tags are omitted.\\r\\n   * @param tick The tick to look up\\r\\n   * @return liquidityTotal the total amount of position liquidity that uses the pool either as tick lower or\\r\\n   * tick upper;\\r\\n   * Returns liquidityDelta how much liquidity changes when the pool price crosses the tick;\\r\\n   * Returns outerFeeGrowth0Token the fee growth on the other side of the tick from the current tick in token0;\\r\\n   * Returns outerFeeGrowth1Token the fee growth on the other side of the tick from the current tick in token1;\\r\\n   * Returns outerTickCumulative the cumulative tick value on the other side of the tick from the current tick;\\r\\n   * Returns outerSecondsPerLiquidity the seconds spent per liquidity on the other side of the tick from the current tick;\\r\\n   * Returns outerSecondsSpent the seconds spent on the other side of the tick from the current tick;\\r\\n   * Returns initialized Set to true if the tick is initialized, i.e. liquidityTotal is greater than 0\\r\\n   * otherwise equal to false. Outside values can only be used if the tick is initialized.\\r\\n   * In addition, these values are only relative and must be used only in comparison to previous snapshots for\\r\\n   * a specific position.\\r\\n   */\\r\\n  function ticks(int24 tick)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    uint128 liquidityTotal,\\r\\n    int128 liquidityDelta,\\r\\n    uint256 outerFeeGrowth0Token,\\r\\n    uint256 outerFeeGrowth1Token,\\r\\n    int56 outerTickCumulative,\\r\\n    uint160 outerSecondsPerLiquidity,\\r\\n    uint32 outerSecondsSpent,\\r\\n    bool initialized\\r\\n  );\\r\\n\\r\\n  /** @notice Returns 256 packed tick initialized boolean values. See TickTable for more information */\\r\\n  function tickTable(int16 wordPosition) external view returns (uint256);\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the information about a position by the position's key\\r\\n   * @dev This is a public mapping of structures, so the `return` natspec tags are omitted.\\r\\n   * @param key The position's key is a hash of a preimage composed by the owner, bottomTick and topTick\\r\\n   * @return liquidityAmount The amount of liquidity in the position;\\r\\n   * Returns lastLiquidityAddTimestamp Timestamp of last adding of liquidity;\\r\\n   * Returns innerFeeGrowth0Token Fee growth of token0 inside the tick range as of the last mint/burn/poke;\\r\\n   * Returns innerFeeGrowth1Token Fee growth of token1 inside the tick range as of the last mint/burn/poke;\\r\\n   * Returns fees0 The computed amount of token0 owed to the position as of the last mint/burn/poke;\\r\\n   * Returns fees1 The computed amount of token1 owed to the position as of the last mint/burn/poke\\r\\n   */\\r\\n  function positions(bytes32 key)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    uint128 liquidityAmount,\\r\\n    uint32 lastLiquidityAddTimestamp,\\r\\n    uint256 innerFeeGrowth0Token,\\r\\n    uint256 innerFeeGrowth1Token,\\r\\n    uint128 fees0,\\r\\n    uint128 fees1\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Returns data about a specific timepoint index\\r\\n   * @param index The element of the timepoints array to fetch\\r\\n   * @dev You most likely want to use #getTimepoints() instead of this method to get an timepoint as of some amount of time\\r\\n   * ago, rather than at a specific index in the array.\\r\\n   * This is a public mapping of structures, so the `return` natspec tags are omitted.\\r\\n   * @return initialized whether the timepoint has been initialized and the values are safe to use;\\r\\n   * Returns blockTimestamp The timestamp of the timepoint;\\r\\n   * Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp;\\r\\n   * Returns secondsPerLiquidityCumulative the seconds per in range liquidity for the life of the pool as of the timepoint timestamp;\\r\\n   * Returns volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp;\\r\\n   * Returns averageTick Time-weighted average tick;\\r\\n   * Returns volumePerLiquidityCumulative Cumulative swap volume per liquidity for the life of the pool as of the timepoint timestamp;\\r\\n   */\\r\\n  function timepoints(uint256 index)\\r\\n  external\\r\\n  view\\r\\n  returns (\\r\\n    bool initialized,\\r\\n    uint32 blockTimestamp,\\r\\n    int56 tickCumulative,\\r\\n    uint160 secondsPerLiquidityCumulative,\\r\\n    uint88 volatilityCumulative,\\r\\n    int24 averageTick,\\r\\n    uint144 volumePerLiquidityCumulative\\r\\n  );\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the information about active incentive\\r\\n   * @dev if there is no active incentive at the moment, virtualPool,endTimestamp,startTimestamp would be equal to 0\\r\\n   * @return virtualPool The address of a virtual pool associated with the current active incentive\\r\\n   */\\r\\n  function activeIncentive() external view returns (address virtualPool);\\r\\n\\r\\n  /**\\r\\n   * @notice Returns the lock time for added liquidity\\r\\n   */\\r\\n  function liquidityCooldown() external view returns (uint32 cooldownInSeconds);\\r\\n}\\r\\n\",\"keccak256\":\"0x6570bab323c67435efdf1558466d3e9d3862631554cd199c8c0148afa04afa83\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IConverterStrategyBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\n\\r\\n/// @notice Allow to share declaration of ConverterStrategyBaseState with libraries\\r\\ninterface IConverterStrategyBase {\\r\\n  struct ConverterStrategyBaseState {\\r\\n    /// @dev Amount of underlying assets invested to the pool.\\r\\n    uint investedAssets;\\r\\n\\r\\n    /// @dev Linked Tetu Converter\\r\\n    ITetuConverter converter;\\r\\n\\r\\n    /// @notice Percent of asset amount that can be not invested, it's allowed to just keep it on balance\\r\\n    ///         decimals = {DENOMINATOR}\\r\\n    /// @dev We need this threshold to avoid numerous conversions of small amounts\\r\\n    uint reinvestThresholdPercent;\\r\\n\\r\\n    /// @notice Current debt to the insurance.\\r\\n    ///         It's increased when insurance covers any losses related to swapping and borrow-debts-paying.\\r\\n    ///         It's not changed when insurance covers losses/receives profit that appeared after price changing.\\r\\n    ///         The strategy covers this debt on each hardwork using the profit (rewards, fees)\\r\\n    int debtToInsurance;\\r\\n\\r\\n    /// @notice reserve space for future needs\\r\\n    uint[50-1] __gap;\\r\\n  }\\r\\n}\",\"keccak256\":\"0x0be4f2ba25d955dfa6c9f821ecb466c3ae78f025ad2a85d83d11e22d850047ea\",\"license\":\"MIT\"},\"contracts/interfaces/IPairBasedDefaultStateProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @notice Provides access to getDefaultState() of a pair-based strategy\\r\\ninterface IPairBasedDefaultStateProvider {\\r\\n  /// @notice Returns the current state of the contract\\r\\n  /// @return addr [tokenA, tokenB, pool, profitHolder]\\r\\n  /// @return tickData [tickSpacing, lowerTick, upperTick, rebalanceTickRange]\\r\\n  /// @return nums [totalLiquidity, fuse-status-tokenA, fuse-status-tokenB, withdrawDone, 4 thresholds of token A, 4 thresholds of token B]\\r\\n  /// @return boolValues [isStablePool, depositorSwapTokens]\\r\\n  function getDefaultState() external view returns (\\r\\n    address[] memory addr,\\r\\n    int24[] memory tickData,\\r\\n    uint[] memory nums,\\r\\n    bool[] memory boolValues\\r\\n  );\\r\\n}\",\"keccak256\":\"0x883b0f9e463485a57aa1baea9aafef64180362d336114a53f6cb8b7a94303d70\",\"license\":\"MIT\"},\"contracts/interfaces/IPoolProportionsProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\ninterface IPoolProportionsProvider {\\r\\n  /// @notice Calculate proportions of [underlying, not-underlying] required by the internal pool of the strategy\\r\\n  /// @return Proportion of the not-underlying [0...1e18]\\r\\n  function getPropNotUnderlying18() external view returns (uint);\\r\\n}\\r\\n\",\"keccak256\":\"0x6722552632531ac63c23ddc5a3a104647a3e4a0d4c417ab9051c47ed49bc826c\",\"license\":\"MIT\"},\"contracts/interfaces/IRebalancingV2Strategy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./IPairBasedDefaultStateProvider.sol\\\";\\r\\nimport \\\"./ISetupPairBasedStrategy.sol\\\";\\r\\n\\r\\ninterface IRebalancingV2Strategy is IPairBasedDefaultStateProvider, ISetupPairBasedStrategy {\\r\\n  function needRebalance() external view returns (bool);\\r\\n\\r\\n  /// @notice Rebalance using borrow/repay only, no swaps\\r\\n  /// @param checkNeedRebalance Revert if rebalance is not needed. Pass false to deposit after withdrawByAgg-iterations\\r\\n  function rebalanceNoSwaps(bool checkNeedRebalance) external;\\r\\n\\r\\n  /// @notice Get info about a swap required by next call of {withdrawByAggStep} within the given plan\\r\\n  function quoteWithdrawByAgg(bytes memory planEntryData) external returns (address tokenToSwap, uint amountToSwap);\\r\\n\\r\\n  /// @notice Make withdraw iteration: [exit from the pool], [make 1 swap], [repay a debt], [enter to the pool]\\r\\n  ///         Typical sequence of the actions is: exit from the pool, make 1 swap, repay 1 debt.\\r\\n  ///         You can enter to the pool if you are sure that you won't have borrow + repay on AAVE3 in the same block.\\r\\n  /// @dev All swap-by-agg data should be prepared using {quoteWithdrawByAgg} off-chain\\r\\n  /// @param tokenToSwap_ What token should be swapped to other\\r\\n  /// @param aggregator_ Aggregator that should be used on next swap. 0 - use liquidator\\r\\n  /// @param amountToSwap_ Amount that should be swapped. 0 - no swap\\r\\n  /// @param swapData Swap rote that was prepared off-chain.\\r\\n  /// @param planEntryData PLAN_XXX + additional data, see IterationPlanKinds\\r\\n  /// @param entryToPool Allow to enter to the pool at the end. Use false if you are going to make several iterations.\\r\\n  ///                    It's possible to enter back to the pool by calling {rebalanceNoSwaps} at any moment\\r\\n  ///                    0 - not allowed, 1 - allowed, 2 - allowed only if completed\\r\\n  /// @return completed All debts were closed, leftovers were swapped to the required proportions.\\r\\n  function withdrawByAggStep(\\r\\n    address tokenToSwap_,\\r\\n    address aggregator_,\\r\\n    uint amountToSwap_,\\r\\n    bytes memory swapData,\\r\\n    bytes memory planEntryData,\\r\\n    uint entryToPool\\r\\n  ) external returns (bool completed);\\r\\n\\r\\n  /// @notice Calculate proportions of [underlying, not-underlying] required by the internal pool of the strategy\\r\\n  /// @return Proportion of the not-underlying [0...1e18]\\r\\n  function getPropNotUnderlying18() external view returns (uint);\\r\\n}\\r\\n\",\"keccak256\":\"0x1ae39d0cc7607cdb9b935e2f6bcb8db8206f180d17fc2230f368509c5173d788\",\"license\":\"MIT\"},\"contracts/interfaces/ISetupPairBasedStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @notice Functions to initialize pair-based strategies\\r\\ninterface ISetupPairBasedStrategy {\\r\\n\\r\\n  /// @notice Manually set status of the fuse\\r\\n  /// @param status See PairBasedStrategyLib.FuseStatus enum for possible values\\r\\n  function setFuseStatus(uint status) external;\\r\\n\\r\\n  /// @notice Set thresholds for the fuse: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\\r\\n  ///         Example: [0.9, 0.92, 1.08, 1.1]\\r\\n  ///         Price falls below 0.9 - fuse is ON. Price rises back up to 0.92 - fuse is OFF.\\r\\n  ///         Price raises more and reaches 1.1 - fuse is ON again. Price falls back and reaches 1.08 - fuse OFF again.\\r\\n  /// @param values Price thresholds: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\\r\\n  function setFuseThresholds(uint[4] memory values) external;\\r\\n  function setStrategyProfitHolder(address strategyProfitHolder) external;\\r\\n\\r\\n  /// @notice Set withdrawDone value.\\r\\n  ///         When a fuse was triggered ON, all debts should be closed and asset should be converted to underlying.\\r\\n  ///         After completion of the conversion withdrawDone can be set to 1.\\r\\n  ///         So, {getFuseStatus} will return  withdrawDone=1 and you will know, that withdraw is not required\\r\\n  /// @param done 0 - full withdraw required, 1 - full withdraw was done\\r\\n  function setWithdrawDone(uint done) external;\\r\\n}\\r\\n\",\"keccak256\":\"0xbe3f6fdf20e05b353202bfd42cb087c106ac055310fb3af80b56a4cda2a86a79\",\"license\":\"MIT\"},\"contracts/libs/AppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @notice List of all errors generated by the application\\r\\n///         Each error should have unique code TS-XXX and descriptive comment\\r\\nlibrary AppErrors {\\r\\n  /// @notice Provided address should be not zero\\r\\n  string public constant ZERO_ADDRESS = \\\"TS-1 zero address\\\";\\r\\n\\r\\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\\r\\n  string public constant UNISWAP_PAIR_NOT_FOUND = \\\"TS-2 pair not found\\\";\\r\\n\\r\\n  /// @notice Lengths not matched\\r\\n  string public constant WRONG_LENGTHS = \\\"TS-4 wrong lengths\\\";\\r\\n\\r\\n  /// @notice Unexpected zero balance\\r\\n  string public constant ZERO_BALANCE = \\\"TS-5 zero balance\\\";\\r\\n\\r\\n  string public constant ITEM_NOT_FOUND = \\\"TS-6 not found\\\";\\r\\n\\r\\n  string public constant NOT_ENOUGH_BALANCE = \\\"TS-7 not enough balance\\\";\\r\\n\\r\\n  /// @notice Price oracle returns zero price\\r\\n  string public constant ZERO_PRICE = \\\"TS-8 zero price\\\";\\r\\n\\r\\n  string public constant WRONG_VALUE = \\\"TS-9 wrong value\\\";\\r\\n\\r\\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\\r\\n  string public constant ZERO_AMOUNT_BORROWED = \\\"TS-10 zero borrowed amount\\\";\\r\\n\\r\\n  string public constant WITHDRAW_TOO_MUCH = \\\"TS-11 try to withdraw too much\\\";\\r\\n\\r\\n  string public constant UNKNOWN_ENTRY_KIND = \\\"TS-12 unknown entry kind\\\";\\r\\n\\r\\n  string public constant ONLY_TETU_CONVERTER = \\\"TS-13 only TetuConverter\\\";\\r\\n\\r\\n  string public constant WRONG_ASSET = \\\"TS-14 wrong asset\\\";\\r\\n\\r\\n  string public constant NO_LIQUIDATION_ROUTE = \\\"TS-15 No liquidation route\\\";\\r\\n\\r\\n  string public constant PRICE_IMPACT = \\\"TS-16 price impact\\\";\\r\\n\\r\\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\\r\\n  string public constant REPAY_MAKES_SWAP = \\\"TS-17 can not convert back\\\";\\r\\n\\r\\n  string public constant NO_INVESTMENTS = \\\"TS-18 no investments\\\";\\r\\n\\r\\n  string public constant INCORRECT_LENGTHS = \\\"TS-19 lengths\\\";\\r\\n\\r\\n  /// @notice We expect increasing of the balance, but it was decreased\\r\\n  string public constant BALANCE_DECREASE = \\\"TS-20 balance decrease\\\";\\r\\n\\r\\n  /// @notice Prices changed and invested assets amount was increased on S, value of S is too high\\r\\n  string public constant EARNED_AMOUNT_TOO_HIGH = \\\"TS-21 earned too high\\\";\\r\\n\\r\\n  string public constant GOVERNANCE_ONLY = \\\"TS-22 governance only\\\";\\r\\n\\r\\n  string public constant ZERO_VALUE = \\\"TS-24 zero value\\\";\\r\\n\\r\\n  string public constant INCORRECT_SWAP_BY_AGG_PARAM = \\\"TS-25 swap by agg\\\";\\r\\n\\r\\n  string public constant OVER_COLLATERAL_DETECTED = \\\"TS-27 over-collateral\\\";\\r\\n\\r\\n  string public constant NOT_IMPLEMENTED = \\\"TS-28 not implemented\\\";\\r\\n\\r\\n  /// @notice You are not allowed to make direct debt if a NOT-DUST reverse debt exists and visa verse.\\r\\n  string public constant OPPOSITE_DEBT_EXISTS = \\\"TS-29 opposite debt exists\\\";\\r\\n\\r\\n  string public constant INVALID_VALUE = \\\"TS-30 invalid value\\\";\\r\\n\\r\\n  string public constant TOO_HIGH = \\\"TS-32 too high value\\\";\\r\\n\\r\\n  /// @notice BorrowLib has recursive call, sub-calls are not allowed\\r\\n  ///         This error can happen if allowed proportion is too small, i.e. 0.0004 : (1-0.0004)\\r\\n  ///         Such situation can happen if amount to swap is almost equal to the amount of the token in the current tick,\\r\\n  ///         so swap will move us close to the border between ticks.\\r\\n  ///         It was decided, that it's ok to have revert in that case\\r\\n  ///         We can change this behavior by changing BorrowLib.rebalanceRepayBorrow implementation:\\r\\n  ///             if amount-to-repay passed to _repayDebt is too small to be used,\\r\\n  ///             we should increase it min amount required to make repay successfully (amount must be > threshold)\\r\\n  ///         Previously it was error NOT_ALLOWED = \\\"TS23: not allowed\\\", see issues SCB-777, SCB-818\\r\\n  string public constant TOO_DEEP_RECURSION_BORROW_LIB = \\\"TS-33 too deep recursion\\\";\\r\\n}\\r\\n\",\"keccak256\":\"0x1400c631697434c991de2bfadcac7a0164a87be41a2cb683ed7f4fc75798d3e8\",\"license\":\"BUSL-1.1\"},\"contracts/libs/AppLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\\\";\\r\\n\\r\\n/// @notice Common internal utils\\r\\nlibrary AppLib {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  /// @notice 1% gap to cover possible liquidation inefficiency\\r\\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\\r\\n  uint internal constant GAP_CONVERSION = 1_000;\\r\\n  /// @dev Absolute value for any token\\r\\n  uint internal constant DEFAULT_LIQUIDATION_THRESHOLD = 100_000;\\r\\n  uint internal constant DENOMINATOR = 100_000;\\r\\n\\r\\n  /// @notice Any amount less than the following is dust\\r\\n  uint public constant DUST_AMOUNT_TOKENS = 100;\\r\\n\\r\\n  /// @notice Unchecked increment for for-cycles\\r\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\r\\n    unchecked {\\r\\n      return i + 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\r\\n  /// @dev Should NOT be used for third-party pools\\r\\n  function approveIfNeeded(address token, uint amount, address spender) internal {\\r\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\r\\n      IERC20(token).safeApprove(spender, 0);\\r\\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\\r\\n      IERC20(token).safeApprove(spender, 2 ** 255);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function balance(address token) internal view returns (uint) {\\r\\n    return IERC20(token).balanceOf(address(this));\\r\\n  }\\r\\n\\r\\n  /// @return prices Asset prices in USD, decimals 18\\r\\n  /// @return decs 10**decimals\\r\\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs\\r\\n  ) {\\r\\n    prices = new uint[](len);\\r\\n    decs = new uint[](len);\\r\\n    {\\r\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\\r\\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\\r\\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\\r\\n    uint len = tokens_.length;\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (tokens_[i] == asset_) {\\r\\n        return i;\\r\\n      }\\r\\n    }\\r\\n    return type(uint).max;\\r\\n  }\\r\\n\\r\\n  function _getLiquidator(address controller_) internal view returns (ITetuLiquidator) {\\r\\n    return ITetuLiquidator(IController(controller_).liquidator());\\r\\n  }\\r\\n\\r\\n  function _getPriceOracle(ITetuConverter converter_) internal view returns (IPriceOracle) {\\r\\n    return IPriceOracle(IConverterController(converter_.controller()).priceOracle());\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate liquidation threshold, use default value if the threshold is not set\\r\\n  ///         It's allowed to set any not-zero threshold, it this case default value is not used\\r\\n  /// @dev This function should be applied to the threshold at the moment of the reading its value from the storage.\\r\\n  ///      So, if we pass {mapping(address => uint) storage liquidationThresholds}, the threshold can be zero\\r\\n  ///      bug if we pass {uint liquidationThreshold} to a function, the threshold should be not zero\\r\\n  function _getLiquidationThreshold(uint threshold) internal pure returns (uint) {\\r\\n    return threshold == 0\\r\\n      ? AppLib.DEFAULT_LIQUIDATION_THRESHOLD\\r\\n      : threshold;\\r\\n  }\\r\\n\\r\\n  /// @notice Return a-b OR zero if a < b\\r\\n  function sub0(uint a, uint b) internal pure returns (uint) {\\r\\n    return a > b ? a - b : 0;\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x9ed14dbb815e8db52864ff1002f877e3b496c9dcb2ac1dccc220c510da203022\",\"license\":\"BUSL-1.1\"},\"contracts/libs/AppPlatforms.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nlibrary AppPlatforms {\\r\\n  string public constant UNIV3 = \\\"UniswapV3\\\";\\r\\n  string public constant BALANCER = \\\"Balancer\\\";\\r\\n  string public constant ALGEBRA = \\\"Algebra\\\";\\r\\n  string public constant KYBER = \\\"Kyber\\\";\\r\\n  string public constant PANCAKE = \\\"Pancake\\\"; // https://pancakeswap.finance/\\r\\n}\\r\\n\",\"keccak256\":\"0x28767f209dd412f52bc6274d3d95e4fb1fc03f6e8db183c13efd09ed82741b4b\",\"license\":\"BUSL-1.1\"},\"contracts/libs/BorrowLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"../strategies/ConverterStrategyBaseLib.sol\\\";\\r\\n\\r\\n/// @notice Library to make new borrow, extend/reduce exist borrows and repay to keep proper assets proportions\\r\\n/// @dev Swap through liquidator is still allowed to be able to get required profitToCover, but this amount is small\\r\\nlibrary BorrowLib {\\r\\n  /// @notice prop0 + prop1\\r\\n  uint constant public SUM_PROPORTIONS = 1e18;\\r\\n\\r\\n  /// @notice Function {_rebalanceAssets} cannot be called recursively more than twice.\\r\\n  /// Normally one call is enough.\\r\\n  /// Firstly repay(requiredAmount0) is called below. There are two possible results:\\r\\n  /// 1) requiredCost0 <= cost0\\r\\n  /// 2) v.directDebt == 0\\r\\n  /// There is SCB-818: there are two debts (big and small), on the first cycle we get amount less than expected\\r\\n  /// because of debt gap. So, we need second cycle.\\r\\n  uint constant public MAX_DEEP_RECURSION = 2;\\r\\n\\r\\n  //region -------------------------------------------------- Data types\\r\\n  struct PricesDecs {\\r\\n    /// @notice Asset prices in USD, decimals 18\\r\\n    uint[] prices;\\r\\n    /// @notice decs 10**decimals\\r\\n    uint[] decs;\\r\\n  }\\r\\n\\r\\n  struct ConverterLiquidator {\\r\\n    ITetuConverter converter;\\r\\n    ITetuLiquidator liquidator;\\r\\n  }\\r\\n\\r\\n  struct RebalanceAssetsLocal {\\r\\n    // ------- constant values\\r\\n    address asset0;\\r\\n    address asset1;\\r\\n    /// @notice Proportion of {asset0}, > 0; proportion of {asset1} is SUM_PROPORTIONS - prop0\\r\\n    uint prop0;\\r\\n    /// @notice Min allowed amount of {asset0}-collateral, 0 - use default min value\\r\\n    uint threshold0;\\r\\n    /// @ntoice Min allowed amount of {asset1}-collateral, 0 - use default min value\\r\\n    uint threshold1;\\r\\n\\r\\n    PricesDecs pd;\\r\\n    // ------- refreshable values\\r\\n\\r\\n    // @notice Current balance of {asset0}\\r\\n    uint amount0;\\r\\n    // @notice Current balance of {asset1}\\r\\n    uint amount1;\\r\\n\\r\\n    /// @notice Borrowed amount of not-underlying\\r\\n    uint directDebt;\\r\\n    /// @notice Borrowed amount of underlying\\r\\n    uint reverseDebt;\\r\\n\\r\\n    uint addition0;\\r\\n  }\\r\\n\\r\\n  /// @notice Params required to borrow {assetB} under {assetA}\\r\\n  struct RebalanceAssetsCore {\\r\\n    ConverterLiquidator converterLiquidator;\\r\\n    address assetA;\\r\\n    address assetB;\\r\\n    uint propA;\\r\\n    uint propB;\\r\\n    /// @notice {assetA} to {assetB} ratio; {amountB} * {alpha} => {amountA}, decimals 18\\r\\n    uint alpha18;\\r\\n    /// @notice Min allowed amount of {assetA}-collateral, 0 - use default min value\\r\\n    uint thresholdA;\\r\\n\\r\\n    uint addonA;\\r\\n    uint addonB;\\r\\n\\r\\n    /// @notice Index of {assetA} in {prices} and {decs}\\r\\n    uint indexA;\\r\\n    /// @notice Index of {assetB} in {prices} and {decs}\\r\\n    uint indexB;\\r\\n  }\\r\\n\\r\\n  struct OpenPosition2Local {\\r\\n    uint collateral;\\r\\n    uint toBorrow;\\r\\n    uint cc;\\r\\n    uint cb;\\r\\n    uint c0;\\r\\n    uint cb2;\\r\\n    uint ca0;\\r\\n    uint gamma18;\\r\\n    uint pa2;\\r\\n    uint pb2;\\r\\n    bytes entryData;\\r\\n    uint alpha18;\\r\\n  }\\r\\n\\r\\n  struct MakeBorrowToDepositLocal {\\r\\n    uint[] prices;\\r\\n    uint[] decs;\\r\\n    uint cost0;\\r\\n    uint cost1;\\r\\n    uint prop1;\\r\\n    bytes entryData;\\r\\n  }\\r\\n  //endregion -------------------------------------------------- Data types\\r\\n\\r\\n  //region -------------------------------------------------- External functions\\r\\n  /// @notice Set balances of {asset0} and {asset1} in proportions {prop0}:{prop1} using borrow/repay (no swaps)\\r\\n  /// @param prop0 Proportion of {asset0}, > 0. Proportion of {asset1} is calculates as 1e18 - prop0\\r\\n  /// @param threshold0 Min allowed amount of {asset0}-collateral, 0 - use default min value\\r\\n  /// @param threshold1 Min allowed amount of {asset1}-collateral, 0 - use default min value\\r\\n  /// @param addition0 Additional amount A0 of {asset0}.\\r\\n  ///                  Balance0 = A0 + B0\\r\\n  ///                  We need following balances in results: B0 : Balance1 === {proportion}:{100_000-proportion}\\r\\n  function rebalanceAssets(\\r\\n    ITetuConverter converter_,\\r\\n    ITetuLiquidator liquidator_,\\r\\n    address asset0,\\r\\n    address asset1,\\r\\n    uint prop0,\\r\\n    uint threshold0,\\r\\n    uint threshold1,\\r\\n    uint addition0\\r\\n  ) external {\\r\\n    // pool always have TWO assets, it's not allowed ot have only one asset\\r\\n    // so, we assume that the proportions are in the range (0...1e18)\\r\\n    require(prop0 != 0, AppErrors.ZERO_VALUE);\\r\\n    require(prop0 < SUM_PROPORTIONS, AppErrors.TOO_HIGH);\\r\\n\\r\\n    RebalanceAssetsLocal memory v;\\r\\n    v.asset0 = asset0;\\r\\n    v.asset1 = asset1;\\r\\n    v.prop0 = prop0;\\r\\n    v.threshold0 = threshold0;\\r\\n    v.threshold1 = threshold1;\\r\\n    v.addition0 = addition0;\\r\\n\\r\\n    IPriceOracle priceOracle = AppLib._getPriceOracle(converter_);\\r\\n    address[] memory tokens = new address[](2);\\r\\n    tokens[0] = asset0;\\r\\n    tokens[1] = asset1;\\r\\n    (v.pd.prices, v.pd.decs) = AppLib._getPricesAndDecs(priceOracle, tokens, 2);\\r\\n\\r\\n    _refreshRebalance(v, ConverterLiquidator(converter_, liquidator_), MAX_DEEP_RECURSION);\\r\\n  }\\r\\n\\r\\n  /// @notice Convert {amount_} of underlying to two amounts: A0 (underlying) and A1 (not-underlying)\\r\\n  ///         Result proportions of A0 and A1 should match to {prop0} : 1e18-{prop0}\\r\\n  ///         The function is able to make new borrowing and/or close exist debts.\\r\\n  /// @param amount_ Amount of underlying that is going to be deposited\\r\\n  ///                We assume here, that current balance >= the {amount_}\\r\\n  /// @param tokens_ [Underlying, not underlying]\\r\\n  /// @param thresholds_ Thresholds for the given {tokens_}. Debts with amount-to-repay < threshold are ignored.\\r\\n  /// @param prop0 Required proportion of underlying, > 0. Proportion of not-underlying is calculates as 1e18 - {prop0}\\r\\n  /// @return tokenAmounts Result amounts [A0 (underlying), A1 (not-underlying)]\\r\\n  function prepareToDeposit(\\r\\n    ITetuConverter converter_,\\r\\n    uint amount_,\\r\\n    address[2] memory tokens_,\\r\\n    uint[2] memory thresholds_,\\r\\n    uint prop0\\r\\n  ) external returns (\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    uint[2] memory amountsToDeposit;\\r\\n    uint[2] memory balances = [\\r\\n      AppLib.sub0(AppLib.balance(tokens_[0]), amount_), // We assume here, that current balance >= the {amount_}\\r\\n      AppLib.balance(tokens_[1])\\r\\n    ];\\r\\n\\r\\n    // we assume here, that either direct OR reverse debts (amount > threshold) are possible but not both at the same time\\r\\n    (uint debtReverse, ) = converter_.getDebtAmountCurrent(address(this), tokens_[1], tokens_[0], true);\\r\\n    if (debtReverse > thresholds_[0]) {\\r\\n      // case 1: reverse debt exists\\r\\n      // case 1.1: amount to deposit exceeds exist debt.\\r\\n      //    Close the debt completely and than make either new direct OR reverse debt\\r\\n      // case 1.2: amount to deposit is less than the exist debt.\\r\\n      //    Close the debt partially and make new reverse debt\\r\\n      uint amountToRepay = amount_ > debtReverse ? debtReverse : amount_;\\r\\n      ConverterStrategyBaseLib.closePosition(converter_, tokens_[1], tokens_[0], amountToRepay);\\r\\n      amountsToDeposit = [\\r\\n        AppLib.sub0(AppLib.balance(tokens_[0]), balances[0]),\\r\\n        AppLib.sub0(AppLib.balance(tokens_[1]), balances[1])\\r\\n      ];\\r\\n    } else {\\r\\n      // case 2: no debts OR direct debt exists\\r\\n      amountsToDeposit = [amount_, 0];\\r\\n    }\\r\\n\\r\\n    _makeBorrowToDeposit(converter_, amountsToDeposit, tokens_, thresholds_, prop0);\\r\\n\\r\\n    tokenAmounts = new uint[](2);\\r\\n    tokenAmounts[0] = AppLib.sub0(AppLib.balance(tokens_[0]), balances[0]);\\r\\n    tokenAmounts[1] = AppLib.sub0(AppLib.balance(tokens_[1]), balances[1]);\\r\\n  }\\r\\n  //endregion -------------------------------------------------- External functions\\r\\n\\r\\n  //region -------------------------------------------------- Implementation of prepareToDeposit\\r\\n  /// @notice Make a direct or reverse borrow to make amounts_ fit to the given proportions.\\r\\n  /// If one of available amounts is zero, we just need to make a borrow using second amount as amountIn.\\r\\n  /// Otherwise, we need to calculate amountIn at first.\\r\\n  /// @dev The purpose is to get the amounts in proper proportions: A:B = prop0:prop1.\\r\\n  /// Suppose, amounts_[1] is not enough:\\r\\n  ///   [A1, B1] => [A2 + A3, B1], A2:B1 = prop0:prop1, A3 is amountIn for new borrow.\\r\\n  /// Suppose, amounts_[0] is not enough:\\r\\n  ///   [A1, B1] => [A1, B2 + B3], A1:B2 = prop0:prop1, B3 is amountIn for new borrow.\\r\\n  /// @param amounts_ Available amounts\\r\\n  /// @param tokens_ [Underlying, not underlying]\\r\\n  /// @param thresholds_ Thresholds for the given {tokens_}. Debts with amount-to-repay < threshold are ignored.\\r\\n  /// @param prop0 Required proportion of underlying, > 0. Proportion of not-underlying is calculates as 1e18 - {prop0}\\r\\n  function _makeBorrowToDeposit(\\r\\n    ITetuConverter converter_,\\r\\n    uint[2] memory amounts_,\\r\\n    address[2] memory tokens_,\\r\\n    uint[2] memory thresholds_,\\r\\n    uint prop0\\r\\n  ) internal {\\r\\n    MakeBorrowToDepositLocal memory v;\\r\\n\\r\\n    {\\r\\n      IPriceOracle priceOracle = AppLib._getPriceOracle(converter_);\\r\\n      address[] memory tokens = new address[](2);\\r\\n      tokens[0] = tokens_[0];\\r\\n      tokens[1] = tokens_[1];\\r\\n      (v.prices, v.decs) = AppLib._getPricesAndDecs(priceOracle, tokens, 2);\\r\\n    }\\r\\n\\r\\n    v.cost0 = amounts_[0] * v.prices[0] / v.decs[0];\\r\\n    v.cost1 = amounts_[1] * v.prices[1] / v.decs[1];\\r\\n    // we need: cost0/cost1 = prop0/prop1, and so cost0 * prop1 = cost1 * prop0\\r\\n    v.prop1 = SUM_PROPORTIONS - prop0;\\r\\n\\r\\n    if (v.cost0 * v.prop1 > v.cost1 * prop0) {\\r\\n      // we need to make direct borrow\\r\\n      uint cost0for1 = v.cost1 * prop0 / v.prop1; // a part of cost0 that is matched to cost1\\r\\n      uint amountIn = (v.cost0 - cost0for1) * v.decs[0] / v.prices[0];\\r\\n\\r\\n      AppLib.approveIfNeeded(tokens_[0], amountIn, address(converter_));\\r\\n      v.entryData = abi.encode(1, prop0, v.prop1); // ENTRY_KIND_EXACT_PROPORTION_1\\r\\n      ConverterStrategyBaseLib.openPosition(converter_, v.entryData, tokens_[0], tokens_[1], amountIn, thresholds_[0]);\\r\\n    } else if (v.cost0 * v.prop1 < v.cost1 * prop0) {\\r\\n      // we need to make reverse borrow\\r\\n      uint cost1for0 = v.cost0 * v.prop1 / prop0; // a part of cost1 that is matched to cost0\\r\\n      uint amountIn = (v.cost1 - cost1for0) * v.decs[1] / v.prices[1];\\r\\n\\r\\n      AppLib.approveIfNeeded(tokens_[1], amountIn, address(converter_));\\r\\n      v.entryData = abi.encode(1, v.prop1, prop0); // ENTRY_KIND_EXACT_PROPORTION_1\\r\\n      ConverterStrategyBaseLib.openPosition(converter_, v.entryData, tokens_[1], tokens_[0], amountIn, thresholds_[1]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  //endregion -------------------------------------------------- Implementation of prepareToDeposit\\r\\n\\r\\n  //region -------------------------------------------------- Internal helper functions\\r\\n\\r\\n  /// @notice refresh state in {v} and call _rebalanceAssets()\\r\\n  function _refreshRebalance(\\r\\n    RebalanceAssetsLocal memory v,\\r\\n    ConverterLiquidator memory converterLiquidator,\\r\\n    uint repayAllowed\\r\\n  ) internal {\\r\\n    v.amount0 = IERC20(v.asset0).balanceOf(address(this));\\r\\n    v.amount1 = IERC20(v.asset1).balanceOf(address(this));\\r\\n\\r\\n    (v.directDebt, ) = converterLiquidator.converter.getDebtAmountCurrent(address(this), v.asset0, v.asset1, true);\\r\\n    (v.reverseDebt, ) = converterLiquidator.converter.getDebtAmountCurrent(address(this), v.asset1, v.asset0, true);\\r\\n\\r\\n    _rebalanceAssets(v, converterLiquidator, repayAllowed);\\r\\n  }\\r\\n\\r\\n  /// @param repayAllowed Protection against recursion\\r\\n  ///                     Assets can be rebalanced in two ways:\\r\\n  ///                     1) openPosition\\r\\n  ///                     2) repay + openPosition\\r\\n  ///                     Only one repay is allowed.\\r\\n  function _rebalanceAssets(\\r\\n    RebalanceAssetsLocal memory v,\\r\\n    ConverterLiquidator memory converterLiquidator,\\r\\n    uint repayAllowed\\r\\n  ) internal {\\r\\n    uint cost0 = v.amount0 * v.pd.prices[0] / v.pd.decs[0];\\r\\n    uint cost1 = v.amount1 * v.pd.prices[1] / v.pd.decs[1];\\r\\n    uint costAddition0 = v.addition0 * v.pd.prices[0] / v.pd.decs[0];\\r\\n\\r\\n    if (cost0 + cost1 > costAddition0) {\\r\\n      uint totalCost = cost0 + cost1 - costAddition0;\\r\\n\\r\\n      uint requiredCost0 = totalCost * v.prop0 / SUM_PROPORTIONS + costAddition0;\\r\\n      uint requiredCost1 = totalCost * (SUM_PROPORTIONS - v.prop0) / SUM_PROPORTIONS;\\r\\n\\r\\n      if (requiredCost0 > cost0) {\\r\\n        // we need to increase amount of asset 0 and decrease amount of asset 1, so we need to borrow asset 0 (reverse)\\r\\n        RebalanceAssetsCore memory c10 = RebalanceAssetsCore({\\r\\n          converterLiquidator: converterLiquidator,\\r\\n          assetA: v.asset1,\\r\\n          assetB: v.asset0,\\r\\n          propA: SUM_PROPORTIONS - v.prop0,\\r\\n          propB: v.prop0,\\r\\n          alpha18: 1e18 * v.pd.prices[0] * v.pd.decs[1] / v.pd.prices[1] / v.pd.decs[0],\\r\\n          thresholdA: v.threshold1,\\r\\n          addonA: 0,\\r\\n          addonB: v.addition0,\\r\\n          indexA: 1,\\r\\n          indexB: 0\\r\\n        });\\r\\n\\r\\n        if (v.directDebt >= AppLib.DUST_AMOUNT_TOKENS) {\\r\\n          require(repayAllowed != 0, AppErrors.TOO_DEEP_RECURSION_BORROW_LIB);\\r\\n\\r\\n          // repay of v.asset1 is required\\r\\n          uint requiredAmount0 = (requiredCost0 - cost0) * v.pd.decs[0] / v.pd.prices[0];\\r\\n          rebalanceRepayBorrow(v, c10, requiredAmount0, v.directDebt, repayAllowed);\\r\\n        } else {\\r\\n          // new (or additional) borrow of asset 0 under asset 1 is required\\r\\n          openPosition(c10, v.pd, v.amount1, v.amount0);\\r\\n        }\\r\\n      } else if (requiredCost0 < cost0) {\\r\\n        RebalanceAssetsCore memory c01 = RebalanceAssetsCore({\\r\\n          converterLiquidator: converterLiquidator,\\r\\n          assetA: v.asset0,\\r\\n          assetB: v.asset1,\\r\\n          propA: v.prop0,\\r\\n          propB: SUM_PROPORTIONS - v.prop0,\\r\\n          alpha18: 1e18 * v.pd.prices[1] * v.pd.decs[0] / v.pd.prices[0] / v.pd.decs[1],\\r\\n          thresholdA: v.threshold0,\\r\\n          addonA: v.addition0,\\r\\n          addonB: 0,\\r\\n          indexA: 0,\\r\\n          indexB: 1\\r\\n        });\\r\\n        // we need to decrease amount of asset 0 and increase amount of asset 1, so we need to borrow asset 1 (direct)\\r\\n        if (v.reverseDebt >= AppLib.DUST_AMOUNT_TOKENS) {\\r\\n          require(repayAllowed != 0, AppErrors.TOO_DEEP_RECURSION_BORROW_LIB);\\r\\n\\r\\n          // repay of v.asset0 is required\\r\\n          // requiredCost0 < cost0 => requiredCost1 > cost1\\r\\n          uint requiredAmount1 = (requiredCost1 - cost1) * v.pd.decs[1] / v.pd.prices[1];\\r\\n          rebalanceRepayBorrow(v, c01, requiredAmount1, v.reverseDebt, repayAllowed);\\r\\n        } else {\\r\\n          // new or additional borrow of asset 1 under asset 0 is required\\r\\n          openPosition(c01, v.pd, v.amount0, v.amount1);\\r\\n        }\\r\\n      }\\r\\n    } else {\\r\\n      // if costAddition0 exceeds cost0 + cost1, all amounts should be converted to asset 0\\r\\n      // for simplicity, we don't make any swaps or borrows (amount addition0 is assumed to be small)\\r\\n      // and just leave balances as is\\r\\n      // as result, profit-to-cover will be reduced from costAddition0 to v.amount0\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Repay {amountDebtA} fully or partially to get at least {requiredAmountB} of collateral\\r\\n  ///         then try to rebalance once more\\r\\n  /// @param requiredAmountB Amount of collateral that we need to receive after repay\\r\\n  /// @param amountDebtA Total amount that is required to pay to close the debt\\r\\n  function rebalanceRepayBorrow(\\r\\n    RebalanceAssetsLocal memory v,\\r\\n    RebalanceAssetsCore memory c,\\r\\n    uint requiredAmountB,\\r\\n    uint amountDebtA,\\r\\n    uint repayAllowed\\r\\n  ) internal {\\r\\n    // repayAllowed cannot be zero here because of requires in _rebalanceAssets, but it's safer to check it once more\\r\\n    require(repayAllowed != 0, AppErrors.TOO_DEEP_RECURSION_BORROW_LIB);\\r\\n\\r\\n    // we need to get {requiredAmountB}\\r\\n    // we don't know exact amount to repay\\r\\n    // but we are sure that amount {requiredAmountB ===> requiredAmountA} would be more than required\\r\\n    uint capRequiredAmountA = requiredAmountB * c.alpha18 / 1e18;\\r\\n    uint amountToRepay = Math.min(capRequiredAmountA, amountDebtA);\\r\\n    if (amountToRepay >= AppLib.DUST_AMOUNT_TOKENS) {\\r\\n      ConverterStrategyBaseLib._repayDebt(c.converterLiquidator.converter, c.assetB, c.assetA, amountToRepay);\\r\\n      _refreshRebalance(v, c.converterLiquidator, repayAllowed - 1);\\r\\n    } // else the assets are already in proper proportions\\r\\n  }\\r\\n\\r\\n  //endregion -------------------------------------------------- Internal helper functions\\r\\n\\r\\n  //region -------------------------------------------------- Open position\\r\\n  /// @notice borrow asset B under asset A. Result balances should be A0 + A1, B0 + B1\\r\\n  ///         Where (A1 : B1) == (propA : propB), A0 and B0 are equal to {c.addonA} and {c.addonB}\\r\\n  /// @param balanceA_ Current balance of the collateral\\r\\n  /// @param balanceB_ Current balance of the borrow asset\\r\\n  function openPosition(\\r\\n    RebalanceAssetsCore memory c,\\r\\n    PricesDecs memory pd,\\r\\n    uint balanceA_,\\r\\n    uint balanceB_\\r\\n  ) internal returns (\\r\\n    uint collateralAmountOut,\\r\\n    uint borrowedAmountOut\\r\\n  ) {\\r\\n    // if there are two not-zero addons, the caller should reduce balances before the call\\r\\n    require(c.addonA == 0 || c.addonB == 0, AppErrors.INVALID_VALUE);\\r\\n\\r\\n    // we are going to borrow B under A\\r\\n    if (c.addonB != 0) {\\r\\n      // B is underlying, so we are going to borrow underlying\\r\\n      if (balanceB_ >= c.addonB) {\\r\\n        // simple case - we already have required addon on the balance. Just keep it unused\\r\\n        return _openPosition(c, balanceA_, balanceB_ - c.addonB);\\r\\n      } else {\\r\\n        // we need to get 1) (c.addonB + balanceB_) amount, so we will have required c.addonB\\r\\n        //                2) leftovers of A and B should be allocated in required proportions\\r\\n        // it's too hard to calculate correctly required to borrow amount in this case without changing TetuConverter\\r\\n        // but we can assume here, that amount (c.addonB - balanceB_) is pretty small (it's profitToCover)\\r\\n        // so, we can swap this required amount through liquidator at first\\r\\n        // then use _openPosition to re-allocated rest amounts to proper proportions\\r\\n        (uint decA,) = _makeLittleSwap(c, pd, balanceA_, c.addonB - balanceB_);\\r\\n        return _openPosition(c, balanceA_ - decA, balanceB_);\\r\\n      }\\r\\n    } else if (c.addonA != 0) {\\r\\n      // A is underlying, we need to put aside c.addonA and allocate leftovers in right proportions.\\r\\n      // we are going to borrow B under asset A, so the case (balanceA_ < c.addonA) is not valid here\\r\\n      require(balanceA_ >= c.addonA, AppErrors.NOT_ENOUGH_BALANCE);\\r\\n      return _openPosition(c, balanceA_ - c.addonA, balanceB_);\\r\\n    } else {\\r\\n      // simple logic, no addons\\r\\n      return _openPosition(c, balanceA_, balanceB_);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice borrow asset B under asset A, result balances should have proportions: (propA : propB)\\r\\n  function _openPosition(RebalanceAssetsCore memory c, uint balanceA_, uint balanceB_) internal returns (\\r\\n    uint collateralAmountOut,\\r\\n    uint borrowedAmountOut\\r\\n  ) {\\r\\n    uint untouchedAmountA;\\r\\n    bytes memory entryData = abi.encode(1, c.propA, c.propB);\\r\\n\\r\\n    if (balanceB_ != 0) {\\r\\n      // we are going to use {balanceA_} as collateral\\r\\n      // but there is some amount on {balanceB_}, so we need to keep corresponded part of {balanceA_} untouched\\r\\n      untouchedAmountA = balanceB_ * c.alpha18 * c.propA / c.propB / 1e18;\\r\\n\\r\\n      // we are going to borrow B under A, so balance A must be greater then balance B\\r\\n      // otherwise the function is called incorrectly - probably we need to borrow A under B\\r\\n      require(untouchedAmountA <= balanceA_, AppErrors.WRONG_VALUE);\\r\\n    }\\r\\n\\r\\n    AppLib.approveIfNeeded(c.assetA, balanceA_ - untouchedAmountA, address(c.converterLiquidator.converter));\\r\\n\\r\\n    return ConverterStrategyBaseLib.openPosition(\\r\\n      c.converterLiquidator.converter,\\r\\n      entryData,\\r\\n      c.assetA,\\r\\n      c.assetB,\\r\\n      balanceA_ - untouchedAmountA,\\r\\n      c.thresholdA\\r\\n    );\\r\\n  }\\r\\n\\r\\n  //endregion -------------------------------------------------- Open position\\r\\n\\r\\n  //region -------------------------------------------------- Little swap\\r\\n  /// @notice Swap min amount of A to get {requiredAmountB}\\r\\n  /// @return spentAmountIn how much the balance A has decreased\\r\\n  /// @return receivedAmountOut how much the balance B has increased\\r\\n  function _makeLittleSwap(\\r\\n    RebalanceAssetsCore memory c,\\r\\n    PricesDecs memory pd,\\r\\n    uint balanceA_,\\r\\n    uint requiredAmountB\\r\\n  ) internal returns (\\r\\n    uint spentAmountIn,\\r\\n    uint receivedAmountOut\\r\\n  ) {\\r\\n    uint amountInA = requiredAmountB * pd.prices[c.indexB] * pd.decs[c.indexA] / pd.prices[c.indexA] / pd.decs[c.indexB];\\r\\n    // we can have some loss because of slippage\\r\\n    // so, let's increase input amount a bit\\r\\n    amountInA = amountInA * (100_000 + ConverterStrategyBaseLib._ASSET_LIQUIDATION_SLIPPAGE) / 100_000;\\r\\n\\r\\n    // in practice the addition is required to pay ProfitToCover\\r\\n    // we assume, that total addition amount is small enough, much smaller then the total balance\\r\\n    // otherwise something is wrong: we are going to pay ProfitToCover, but we don't have enough amount on the balances.\\r\\n    require(balanceA_ > amountInA, AppErrors.NOT_ENOUGH_BALANCE);\\r\\n\\r\\n    (spentAmountIn, receivedAmountOut) = ConverterStrategyBaseLib.liquidate(\\r\\n      c.converterLiquidator.converter,\\r\\n      c.converterLiquidator.liquidator,\\r\\n      c.assetA,\\r\\n      c.assetB,\\r\\n      amountInA,\\r\\n      ConverterStrategyBaseLib._ASSET_LIQUIDATION_SLIPPAGE,\\r\\n      c.thresholdA,\\r\\n      false\\r\\n    );\\r\\n  }\\r\\n\\r\\n  //endregion -------------------------------------------------- Little swap\\r\\n\\r\\n}\\r\\n\",\"keccak256\":\"0x5a94be3da8739c31b91b0e4c6ca7860e96d052ef2d1975b63983e33eed33a8a8\",\"license\":\"BUSL-1.1\"},\"contracts/libs/ConverterEntryKinds.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\\r\\nlibrary ConverterEntryKinds {\\r\\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\\r\\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\\r\\n\\r\\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\\r\\n  ///         C2 should be used as collateral to make a borrow B.\\r\\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\\r\\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\\r\\n\\r\\n  /// @notice Borrow given amount using min possible collateral\\r\\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\\r\\n\\r\\n  /// @notice Decode entryData, extract first uint - entry kind\\r\\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\\r\\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\\r\\n    if (entryData_.length == 0) {\\r\\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\\r\\n    }\\r\\n    return abi.decode(entryData_, (uint));\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x4f4332c8be1be5fd85fef7c06795fc19957b35a4f2e3735fdd89c0906ddc923b\",\"license\":\"BUSL-1.1\"},\"contracts/libs/IterationPlanLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"./AppErrors.sol\\\";\\r\\nimport \\\"./AppLib.sol\\\";\\r\\n\\r\\n/// @notice Support of withdraw iteration plans\\r\\nlibrary IterationPlanLib {\\r\\n\\r\\n//region ------------------------------------------------ Constants\\r\\n  /// @notice Swap collateral asset to get required amount-to-repay, then repay and get more collateral back.\\r\\n  ///         It tries to minimizes count of repay-operations.\\r\\n  ///         If there are no debts, swap leftovers to get required proportions of the asset.\\r\\n  ///         This mode is intended i.e. for \\\"withdraw all\\\"\\r\\n  ///         (uint256, uint256) - (entry kind, propNotUnderlying18)\\r\\n  /// propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n  ///                     The assets should be swapped to get following result proportions:\\r\\n  ///                     not-underlying : underlying === propNotUnderlying18 : (1e18 - propNotUnderlying18)\\r\\n  ///                     Pass type(uint).max to read proportions from the pool.\\r\\n  uint constant public PLAN_SWAP_REPAY = 0;\\r\\n\\r\\n  /// @notice Repay available amount-to-repay, swap all or part of collateral to borrowed-asset, make one repay if needed.\\r\\n  ///         Swap + second repay tries to make asset balances to proportions required by the pool.\\r\\n  ///         Proportions are read from pool through IPoolProportionsProvider(this) and re-read after swapping.\\r\\n  ///         This mode is intended i.e. for rebalancing debts using single iteration.\\r\\n  ///         (uint256, uint256, uint256) - (entry kind, propNotUnderlying18, required-amount-to-reduce-the-debt)\\r\\n  /// propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n  ///                     The assets should be swapped to get following result proportions:\\r\\n  ///                     not-underlying : underlying === propNotUnderlying18 : (1e18 - propNotUnderlying18)\\r\\n  ///                     Pass type(uint).max to read proportions from the pool.\\r\\n  uint constant public PLAN_REPAY_SWAP_REPAY = 1;\\r\\n\\r\\n  /// @notice Swap leftovers to required proportions, don't repay any debts\\r\\n  ///         (uint256, uint256) - (entry kind, propNotUnderlying18)\\r\\n  /// propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n  ///                     The assets should be swapped to get following result proportions:\\r\\n  ///                     not-underlying : underlying === propNotUnderlying18 : (1e18 - propNotUnderlying18)\\r\\n  ///                     Pass type(uint).max to read proportions from the pool.\\r\\n  uint constant public PLAN_SWAP_ONLY = 2;\\r\\n//endregion ------------------------------------------------ Constants\\r\\n\\r\\n//region ------------------------------------------------ Data types\\r\\n  /// @notice Set of parameters required to liquidation through aggregators\\r\\n  struct SwapRepayPlanParams {\\r\\n    ITetuConverter converter;\\r\\n    ITetuLiquidator liquidator;\\r\\n\\r\\n    /// @notice Assets used by depositor stored as following way: [underlying, not-underlying]\\r\\n    address[] tokens;\\r\\n\\r\\n    /// @notice Liquidation thresholds for the {tokens}\\r\\n    uint[] liquidationThresholds;\\r\\n\\r\\n    /// @notice Cost of $1 in terms of the assets, decimals 18\\r\\n    uint[] prices;\\r\\n    /// @notice 10**decimal for the assets\\r\\n    uint[] decs;\\r\\n\\r\\n    /// @notice Amounts that will be received on balance before execution of the plan.\\r\\n    uint[] balanceAdditions;\\r\\n\\r\\n    /// @notice Plan kind extracted from entry data, see {IterationPlanKinds}\\r\\n    uint planKind;\\r\\n\\r\\n    /// @notice Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n    ///         The leftovers should be swapped to get following result proportions of the assets:\\r\\n    ///         not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\r\\n    uint propNotUnderlying18;\\r\\n\\r\\n    /// @notice proportions should be taken from the pool and re-read from the pool after each swap\\r\\n    bool usePoolProportions;\\r\\n\\r\\n    /// @notice \\\"required-amount-to-reduce-debt\\\" in the case of REPAY-SWAP-REPAY, zero in other cases\\r\\n    uint entryDataParam;\\r\\n  }\\r\\n\\r\\n  struct GetIterationPlanLocal {\\r\\n    /// @notice Underlying balance\\r\\n    uint assetBalance;\\r\\n    /// @notice Not-underlying balance\\r\\n    uint tokenBalance;\\r\\n\\r\\n    uint totalDebt;\\r\\n    uint totalCollateral;\\r\\n\\r\\n    uint debtReverse;\\r\\n    uint collateralReverse;\\r\\n\\r\\n    address asset;\\r\\n    address token;\\r\\n\\r\\n    bool swapLeftoversNeeded;\\r\\n  }\\r\\n\\r\\n  struct EstimateSwapAmountForRepaySwapRepayLocal {\\r\\n    uint x;\\r\\n    uint y;\\r\\n    uint bA1;\\r\\n    uint bB1;\\r\\n    uint alpha;\\r\\n    uint swapRatio;\\r\\n    uint aB3;\\r\\n    uint cA1;\\r\\n    uint cB1;\\r\\n    uint aA2;\\r\\n    uint aB2;\\r\\n  }\\r\\n//endregion ------------------------------------------------ Data types\\r\\n\\r\\n  /// @notice Decode entryData, extract first uint - entry kind\\r\\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\\r\\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\\r\\n    if (entryData_.length == 0) {\\r\\n      return PLAN_SWAP_REPAY;\\r\\n    }\\r\\n    return abi.decode(entryData_, (uint));\\r\\n  }\\r\\n\\r\\n//region ------------------------------------------------ Build plan\\r\\n  /// @notice Build plan to make single iteration of withdraw according to the selected plan\\r\\n  ///         The goal is to withdraw {requestedAmount} and receive {asset}:{token} in proper proportions on the balance\\r\\n  /// @param converterLiquidator [TetuConverter, TetuLiquidator]\\r\\n  /// @param tokens List of the pool tokens. One of them is underlying and one of then is not-underlying\\r\\n  ///               that we are going to withdraw\\r\\n  /// @param liquidationThresholds Liquidation thresholds for the {tokens}. If amount is less then the threshold,\\r\\n  ///                              we cannot swap it.\\r\\n  /// @param prices Prices of the {tokens}, decimals 18, [$/token]\\r\\n  /// @param decs 10**decimal for each token of the {tokens}\\r\\n  /// @param balanceAdditions Amounts that will be added to the current balances of the {tokens}\\r\\n  ///                         to the moment of the plan execution\\r\\n  /// @param packedData Several values packed to fixed-size array (to reduce number of params)\\r\\n  ///    0: usePoolProportions: 1 - read proportions from the pool through IPoolProportionsProvider(this)\\r\\n  ///    1: planKind: selected plan, one of PLAN_XXX\\r\\n  ///    2: propNotUnderlying18: value of not-underlying proportion [0..1e18] if usePoolProportions == 0\\r\\n  ///    3: requestedBalance: total amount that should be withdrawn, it can be type(uint).max\\r\\n  ///    4: indexAsset: index of the underlying in {tokens} array\\r\\n  ///    5: indexToken: index of the token in {tokens} array. We are going to withdraw the token and convert it to the asset\\r\\n  ///    6: entryDataParam: required-amount-to-reduce-debt in REPAY-SWAP-REPAY case; zero in other cases\\r\\n  function buildIterationPlan(\\r\\n    address[2] memory converterLiquidator,\\r\\n    address[] memory tokens,\\r\\n    uint[] memory liquidationThresholds,\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs,\\r\\n    uint[] memory balanceAdditions,\\r\\n    uint[7] memory packedData\\r\\n  ) external returns (\\r\\n    uint indexToSwapPlus1,\\r\\n    uint amountToSwap,\\r\\n    uint indexToRepayPlus1\\r\\n  ) {\\r\\n    return _buildIterationPlan(\\r\\n      SwapRepayPlanParams({\\r\\n        converter: ITetuConverter(converterLiquidator[0]),\\r\\n        liquidator: ITetuLiquidator(converterLiquidator[1]),\\r\\n        tokens: tokens,\\r\\n        liquidationThresholds: liquidationThresholds,\\r\\n        prices: prices,\\r\\n        decs: decs,\\r\\n        balanceAdditions: balanceAdditions,\\r\\n        planKind: packedData[1],\\r\\n        propNotUnderlying18: packedData[2],\\r\\n        usePoolProportions: packedData[0] != 0,\\r\\n        entryDataParam: packedData[6]\\r\\n      }),\\r\\n      packedData[3],\\r\\n      packedData[4],\\r\\n      packedData[5]\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Generate plan for next withdraw iteration. We can do only one swap per iteration.\\r\\n  ///         In general, we cam make 1) single swap (direct or reverse) and 2) repay\\r\\n  ///         Swap is required to get required repay-amount OR to swap leftovers on final iteration.\\r\\n  /// @param requestedBalance Amount of underlying that we need to have on balance after executing the plan.\\r\\n  /// @param indexAsset Index of the underlying in {p.tokens} array\\r\\n  /// @param indexToken Index of the not-underlying in {p.tokens} array\\r\\n  /// @return indexToSwapPlus1 1-based index of the token to be swapped; 0 means swap is not required.\\r\\n  /// @return amountToSwap Amount to be swapped. 0 - no swap\\r\\n  /// @return indexToRepayPlus1 1-based index of the token that should be used to repay borrow in converter.\\r\\n  ///                            0 - no repay is required - it means that this is a last step with swapping leftovers.\\r\\n  function _buildIterationPlan(\\r\\n    SwapRepayPlanParams memory p,\\r\\n    uint requestedBalance,\\r\\n    uint indexAsset,\\r\\n    uint indexToken\\r\\n  ) internal returns (\\r\\n    uint indexToSwapPlus1,\\r\\n    uint amountToSwap,\\r\\n    uint indexToRepayPlus1\\r\\n  ) {\\r\\n    GetIterationPlanLocal memory v;\\r\\n    v.asset = p.tokens[indexAsset];\\r\\n    v.token = p.tokens[indexToken];\\r\\n\\r\\n    v.assetBalance = IERC20(v.asset).balanceOf(address(this)) + p.balanceAdditions[indexAsset];\\r\\n    v.tokenBalance = IERC20(p.tokens[indexToken]).balanceOf(address(this)) + p.balanceAdditions[indexToken];\\r\\n\\r\\n    if (p.planKind == IterationPlanLib.PLAN_SWAP_ONLY) {\\r\\n      v.swapLeftoversNeeded = true;\\r\\n    } else {\\r\\n      uint requestedAmount = requestedBalance == type(uint).max\\r\\n        ? type(uint).max\\r\\n        : AppLib.sub0(requestedBalance, v.assetBalance);\\r\\n\\r\\n      if (requestedAmount < p.liquidationThresholds[indexAsset]) {\\r\\n        // we don't need to repay any debts anymore, but we should swap leftovers\\r\\n        v.swapLeftoversNeeded = true;\\r\\n      } else {\\r\\n        // we need to increase balance on the following amount: requestedAmount - v.balance;\\r\\n        // we can have two possible borrows:\\r\\n        // 1) direct (p.tokens[INDEX_ASSET] => tokens[i]) and 2) reverse (tokens[i] => p.tokens[INDEX_ASSET])\\r\\n        // normally we can have only one of them, not both..\\r\\n        // but better to take into account possibility to have two debts simultaneously\\r\\n\\r\\n        // reverse debt\\r\\n        (v.debtReverse, v.collateralReverse) = p.converter.getDebtAmountCurrent(address(this), v.token, v.asset, true);\\r\\n        if (v.debtReverse < AppLib.DUST_AMOUNT_TOKENS) { // there is reverse debt or the reverse debt is dust debt\\r\\n          // direct debt\\r\\n          (v.totalDebt, v.totalCollateral) = p.converter.getDebtAmountCurrent(address(this), v.asset, v.token, true);\\r\\n\\r\\n          if (v.totalDebt < AppLib.DUST_AMOUNT_TOKENS) { // there is direct debt or the direct debt is dust debt\\r\\n            // This is final iteration - we need to swap leftovers and get amounts on balance in proper proportions.\\r\\n            // The leftovers should be swapped to get following result proportions of the assets:\\r\\n            //      underlying : not-underlying === 1e18 - propNotUnderlying18 : propNotUnderlying18\\r\\n            v.swapLeftoversNeeded = true;\\r\\n          } else {\\r\\n            // repay direct debt\\r\\n            if (p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY) {\\r\\n              (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanRepaySwapRepay(\\r\\n                p,\\r\\n                [v.assetBalance, v.tokenBalance],\\r\\n                [indexAsset, indexToken],\\r\\n                p.propNotUnderlying18,\\r\\n                [v.totalCollateral, v.totalDebt],\\r\\n                p.entryDataParam\\r\\n              );\\r\\n            } else {\\r\\n              (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanForSellAndRepay(\\r\\n                requestedAmount,\\r\\n                p,\\r\\n                v.totalCollateral,\\r\\n                v.totalDebt,\\r\\n                indexAsset,\\r\\n                indexToken,\\r\\n                v.assetBalance,\\r\\n                v.tokenBalance\\r\\n              );\\r\\n            }\\r\\n          }\\r\\n        } else {\\r\\n          // repay reverse debt\\r\\n          if (p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY) {\\r\\n            (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanRepaySwapRepay(\\r\\n              p,\\r\\n              [v.tokenBalance, v.assetBalance],\\r\\n              [indexToken, indexAsset],\\r\\n              1e18 - p.propNotUnderlying18,\\r\\n              [v.collateralReverse, v.debtReverse],\\r\\n              p.entryDataParam\\r\\n            );\\r\\n          } else {\\r\\n            (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanForSellAndRepay(\\r\\n              requestedAmount == type(uint).max\\r\\n                ? type(uint).max\\r\\n                : requestedAmount * p.prices[indexAsset] * p.decs[indexToken] / p.prices[indexToken] / p.decs[indexAsset],\\r\\n              p,\\r\\n              v.collateralReverse,\\r\\n              v.debtReverse,\\r\\n              indexToken,\\r\\n              indexAsset,\\r\\n              v.tokenBalance,\\r\\n              v.assetBalance\\r\\n            );\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (v.swapLeftoversNeeded) {\\r\\n      (indexToSwapPlus1, amountToSwap) = _buildPlanForLeftovers(p, v.assetBalance, v.tokenBalance, indexAsset, indexToken, p.propNotUnderlying18);\\r\\n    }\\r\\n\\r\\n    return (indexToSwapPlus1, amountToSwap, indexToRepayPlus1);\\r\\n  }\\r\\n\\r\\n  /// @notice Repay B, get collateral A, then swap A => B, [make one more repay B] => get A:B in required proportions\\r\\n  /// @param balancesAB [balanceA, balanceB]\\r\\n  /// @param idxAB [indexA, indexB]\\r\\n  /// @param totalAB [totalCollateralA, totalBorrowB]\\r\\n  /// @param requiredAmountToReduceDebt If not zero: we are going to make repay-swap-repay to reduce total\\r\\n  ///        debt on the given amount. So, if possible it worth to make swap in such a way as to reduce\\r\\n  ///        the amount of debt by the given amount.\\r\\n  function _buildPlanRepaySwapRepay(\\r\\n    SwapRepayPlanParams memory p,\\r\\n    uint[2] memory balancesAB,\\r\\n    uint[2] memory idxAB,\\r\\n    uint propB,\\r\\n    uint[2] memory totalAB,\\r\\n    uint requiredAmountToReduceDebt\\r\\n  ) internal returns (\\r\\n    uint indexToSwapPlus1,\\r\\n    uint amountToSwap,\\r\\n    uint indexToRepayPlus1\\r\\n  ) {\\r\\n    // use all available tokenB to repay debt and receive as much as possible tokenA\\r\\n    uint amountToRepay = Math.min(balancesAB[1], totalAB[1]);\\r\\n\\r\\n    uint collateralAmount;\\r\\n    if (amountToRepay >= AppLib.DUST_AMOUNT_TOKENS) {\\r\\n      uint swappedAmountOut;\\r\\n      //\\r\\n      (collateralAmount, swappedAmountOut) = p.converter.quoteRepay(address(this), p.tokens[idxAB[0]], p.tokens[idxAB[1]], amountToRepay);\\r\\n      if (collateralAmount > swappedAmountOut) { // SCB-789\\r\\n        collateralAmount -= swappedAmountOut;\\r\\n      }\\r\\n    } else {\\r\\n      amountToRepay = 0;\\r\\n    }\\r\\n\\r\\n    // swap A to B: full or partial\\r\\n    // SCB-876: swap B to A are also possible here\\r\\n    bool swapB;\\r\\n    (amountToSwap, swapB) = estimateSwapAmountForRepaySwapRepay(\\r\\n      p,\\r\\n      [balancesAB[0], balancesAB[1]],\\r\\n      [idxAB[0], idxAB[1]],\\r\\n      propB,\\r\\n      totalAB[0],\\r\\n      totalAB[1],\\r\\n      collateralAmount,\\r\\n      amountToRepay\\r\\n    );\\r\\n\\r\\n    if (swapB) {\\r\\n      // edge case: swap B => A; for simplicity, we don't take into account requiredAmountToReduceDebt\\r\\n      return (idxAB[1] + 1, amountToSwap, idxAB[1] + 1);\\r\\n    } else {\\r\\n      // swap A => B\\r\\n      if (requiredAmountToReduceDebt != 0) {\\r\\n        // probably it worth to increase amount to swap?\\r\\n        uint requiredAmountToSwap = requiredAmountToReduceDebt * p.prices[idxAB[1]] * p.decs[idxAB[0]] / p.prices[idxAB[0]] / p.decs[idxAB[1]];\\r\\n        amountToSwap = Math.max(amountToSwap, requiredAmountToSwap);\\r\\n        amountToSwap = Math.min(amountToSwap, balancesAB[0] + collateralAmount);\\r\\n      }\\r\\n\\r\\n      return (idxAB[0] + 1, amountToSwap, idxAB[1] + 1);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Estimate swap amount for iteration \\\"repay-swap-repay\\\"\\r\\n  ///         The iteration should give us amounts of assets in required proportions.\\r\\n  ///         There are two cases here: full swap and partial swap. Second repay is not required if the swap is partial.\\r\\n  /// @param collateralA Estimated value of collateral A received after repay balanceB\\r\\n  /// @return amountToSwap Amount to be swapped\\r\\n  /// @return swapB False: swap A => B; True: swap B => A\\r\\n  function estimateSwapAmountForRepaySwapRepay(\\r\\n    SwapRepayPlanParams memory p,\\r\\n    uint[2] memory balancesAB,\\r\\n    uint[2] memory indicesAB,\\r\\n    uint propB,\\r\\n    uint totalCollateralA,\\r\\n    uint totalBorrowB,\\r\\n    uint collateralA,\\r\\n    uint amountToRepayB\\r\\n  ) internal pure returns(uint amountToSwap, bool swapB) {\\r\\n    // N - number of the state\\r\\n    // bAN, bBN - balances of A and B; aAN, aBN - amounts of A and B; cAN, cBN - collateral/borrow amounts of A/B\\r\\n    // alpha ~ cAN/cBN - estimated ratio of collateral/borrow\\r\\n    // s = swap ratio, aA is swapped to aB, so aA = s * aB\\r\\n    // g = split ratio, bA1 is divided on two parts: bA1 * gamma, bA1 * (1 - gamma). First part is swapped.\\r\\n    // X = proportion of A, Y = proportion of B\\r\\n\\r\\n    // Formulas\\r\\n    // aB3 = (x * bB2 - y * bA2) / (alpha * y + x)\\r\\n    // gamma = (y * bA1 - x * bB1) / (bA1 * (x * s + y))\\r\\n\\r\\n    // There are following stages:\\r\\n    // 0. init (we have at least not zero amount of B and not zero debt of B)\\r\\n    // 1. repay 1 (repay all available amount of B OR all available debt)\\r\\n    // 2. swap (swap A fully or partially to B)\\r\\n    // 3. repay 2 (optional: we need this stage if full swap produces amount of B that is <= available debt)\\r\\n    // 4. final (we have assets in right proportion on the balance)\\r\\n    EstimateSwapAmountForRepaySwapRepayLocal memory v;\\r\\n    v.x = 1e18 - propB;\\r\\n    v.y = propB;\\r\\n// 1. repay 1\\r\\n    // convert amounts A, amounts B to cost A, cost B in USD\\r\\n    v.bA1 = (balancesAB[0] + collateralA) * p.prices[indicesAB[0]] / p.decs[indicesAB[0]];\\r\\n    v.bB1 = (balancesAB[1] - amountToRepayB) * p.prices[indicesAB[1]] / p.decs[indicesAB[1]];\\r\\n    v.cB1 = (totalBorrowB - amountToRepayB) * p.prices[indicesAB[1]] / p.decs[indicesAB[1]];\\r\\n    v.alpha = 1e18 * totalCollateralA * p.prices[indicesAB[0]] * p.decs[indicesAB[1]]\\r\\n      / p.decs[indicesAB[0]] / p.prices[indicesAB[1]] / totalBorrowB; // (!) approx estimation\\r\\n\\r\\n// 2. full swap\\r\\n    v.aA2 = v.bA1;\\r\\n    v.swapRatio = 1e18; // we assume swap ratio 1:1\\r\\n\\r\\n// 3. repay 2\\r\\n    // aB3 = (x * bB2 - Y * bA2) / (alpha * y + x)\\r\\n    v.aB3 = (\\r\\n      v.x * (v.bB1 + v.aA2 * v.swapRatio / 1e18)    // bB2 = v.bB1 + v.aA2 * v.s / 1e18\\r\\n      - v.y * (v.bA1 - v.aA2)                       // bA2 = v.bA1 - v.aA2;\\r\\n    ) / (v.y * v.alpha / 1e18 + v.x);\\r\\n\\r\\n    if (v.aB3 > v.cB1) {\\r\\n      if (v.y * v.bA1 >= v.x * v.bB1) {\\r\\n        // there is not enough debt to make second repay\\r\\n        // we need to make partial swap and receive assets in right proportions in result\\r\\n        // v.gamma = 1e18 * (v.y * v.bA1 - v.x * v.bB1) / (v.bA1 * (v.x * v.s / 1e18 + v.y));\\r\\n        v.aA2 = (v.y * v.bA1 - v.x * v.bB1) / (v.x * v.swapRatio / 1e18 + v.y);\\r\\n      } else {\\r\\n        // scb-867: edge case, we need to make swap B => A\\r\\n        v.aB2 = (v.x * v.bB1 - v.y * v.bA1) / (v.x * v.swapRatio / 1e18 + v.y) /* * 1e18 / v.swapRatio */ ;\\r\\n        swapB = true;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return swapB\\r\\n      ? (v.aB2 * p.decs[indicesAB[1]] / p.prices[indicesAB[1]], true) // edge case: swap B => A\\r\\n      : (v.aA2 * p.decs[indicesAB[0]] / p.prices[indicesAB[0]], false); // normal case: swap A => B\\r\\n  }\\r\\n\\r\\n  /// @notice Prepare a plan to swap leftovers to required proportion\\r\\n  /// @param balanceA Balance of token A, i.e. underlying\\r\\n  /// @param balanceB Balance of token B, i.e. not-underlying\\r\\n  /// @param indexA Index of the token A, i.e. underlying, in {p.prices} and {p.decs}\\r\\n  /// @param indexB Index of the token B, i.e. not-underlying, in {p.prices} and {p.decs}\\r\\n  /// @param propB Required proportion of TokenB [0..1e18]. Proportion of token A is (1e18-propB)\\r\\n  /// @return indexTokenToSwapPlus1 Index of the token to be swapped. 0 - no swap is required\\r\\n  /// @return amountToSwap Amount to be swapped. 0 - no swap is required\\r\\n  function _buildPlanForLeftovers(\\r\\n    SwapRepayPlanParams memory p,\\r\\n    uint balanceA,\\r\\n    uint balanceB,\\r\\n    uint indexA,\\r\\n    uint indexB,\\r\\n    uint propB\\r\\n  ) internal pure returns (\\r\\n    uint indexTokenToSwapPlus1,\\r\\n    uint amountToSwap\\r\\n  ) {\\r\\n    (uint targetA, uint targetB) = _getTargetAmounts(p.prices, p.decs, balanceA, balanceB, propB, indexA, indexB);\\r\\n    if (balanceA < targetA) {\\r\\n      // we need to swap not-underlying to underlying\\r\\n      if (balanceB - targetB > p.liquidationThresholds[indexB]) {\\r\\n        amountToSwap = balanceB - targetB;\\r\\n        indexTokenToSwapPlus1 = indexB + 1;\\r\\n      }\\r\\n    } else {\\r\\n      // we need to swap underlying to not-underlying\\r\\n      if (balanceA - targetA > p.liquidationThresholds[indexA]) {\\r\\n        amountToSwap = balanceA - targetA;\\r\\n        indexTokenToSwapPlus1 = indexA + 1;\\r\\n      }\\r\\n    }\\r\\n    return (indexTokenToSwapPlus1, amountToSwap);\\r\\n  }\\r\\n\\r\\n  /// @notice Prepare a plan to swap some amount of collateral to get required repay-amount and make repaying\\r\\n  ///         1) Sell collateral-asset to get missed amount-to-repay 2) make repay and get more collateral back\\r\\n  /// @param requestedAmount We need to increase balance (of collateral asset) on this amount.\\r\\n  /// @param totalCollateral Total amount of collateral used in the borrow\\r\\n  /// @param totalDebt Total amount of debt that should be repaid to receive {totalCollateral}\\r\\n  /// @param indexCollateral Index of collateral asset in {p.prices}, {p.decs}\\r\\n  /// @param indexBorrow Index of borrow asset in {p.prices}, {p.decs}\\r\\n  /// @param balanceCollateral Current balance of the collateral asset\\r\\n  /// @param balanceBorrow Current balance of the borrowed asset\\r\\n  /// @param indexTokenToSwapPlus1 1-based index of the token to be swapped. Swap of amount of collateral asset can be required\\r\\n  ///                              to receive missed amount-to-repay. 0 - no swap is required\\r\\n  /// @param amountToSwap Amount to be swapped. 0 - no swap is required\\r\\n  /// @param indexRepayTokenPlus1 1-based index of the token to be repaied. 0 - no repaying is required\\r\\n  function _buildPlanForSellAndRepay(\\r\\n    uint requestedAmount,\\r\\n    SwapRepayPlanParams memory p,\\r\\n    uint totalCollateral,\\r\\n    uint totalDebt,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrow,\\r\\n    uint balanceCollateral,\\r\\n    uint balanceBorrow\\r\\n  ) internal pure returns (\\r\\n    uint indexTokenToSwapPlus1,\\r\\n    uint amountToSwap,\\r\\n    uint indexRepayTokenPlus1\\r\\n  ) {\\r\\n    // what amount of collateral we should sell to get required amount-to-pay to pay the debt\\r\\n    uint toSell = _getAmountToSell(\\r\\n      requestedAmount,\\r\\n      totalDebt,\\r\\n      totalCollateral,\\r\\n      p.prices,\\r\\n      p.decs,\\r\\n      indexCollateral,\\r\\n      indexBorrow,\\r\\n      balanceBorrow\\r\\n    );\\r\\n\\r\\n    // convert {toSell} amount of underlying to token\\r\\n    if (toSell != 0 && balanceCollateral != 0) {\\r\\n      toSell = Math.min(toSell, balanceCollateral);\\r\\n      uint threshold = p.liquidationThresholds[indexCollateral];\\r\\n      if (toSell > threshold) {\\r\\n        amountToSwap = toSell;\\r\\n        indexTokenToSwapPlus1 = indexCollateral + 1;\\r\\n      } else {\\r\\n        // we need to sell amount less than the threshold, it's not allowed\\r\\n        // but it's dangerous to just ignore the selling because there is a chance to have error 35\\r\\n        // (There is a debt $3.29, we make repay $3.27 => error 35)\\r\\n        // it would be safer to sell a bit more amount if it's possible\\r\\n        if (balanceCollateral >= threshold + 1) {\\r\\n          amountToSwap = threshold + 1;\\r\\n          indexTokenToSwapPlus1 = indexCollateral + 1;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return (indexTokenToSwapPlus1, amountToSwap, indexBorrow + 1);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate what balances of underlying and not-underlying we need to fit {propNotUnderlying18}\\r\\n  /// @param prices Prices of underlying and not underlying\\r\\n  /// @param decs 10**decimals for underlying and not underlying\\r\\n  /// @param assetBalance Current balance of underlying\\r\\n  /// @param tokenBalance Current balance of not-underlying\\r\\n  /// @param propNotUnderlying18 Required proportion of not-underlying [0..1e18]\\r\\n  ///                            Proportion of underlying would be (1e18 - propNotUnderlying18)\\r\\n  /// @param targetAssets What result balance of underlying is required to fit to required proportions\\r\\n  /// @param targetTokens What result balance of not-underlying is required to fit to required proportions\\r\\n  function _getTargetAmounts(\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs,\\r\\n    uint assetBalance,\\r\\n    uint tokenBalance,\\r\\n    uint propNotUnderlying18,\\r\\n    uint indexAsset,\\r\\n    uint indexToken\\r\\n  ) internal pure returns (\\r\\n    uint targetAssets,\\r\\n    uint targetTokens\\r\\n  ) {\\r\\n    uint costAssets = assetBalance * prices[indexAsset] / decs[indexAsset];\\r\\n    uint costTokens = tokenBalance * prices[indexToken] / decs[indexToken];\\r\\n    targetTokens = propNotUnderlying18 == 0\\r\\n      ? 0\\r\\n      : ((costAssets + costTokens) * propNotUnderlying18 / 1e18);\\r\\n    targetAssets = ((costAssets + costTokens) - targetTokens) * decs[indexAsset] / prices[indexAsset];\\r\\n    targetTokens = targetTokens * decs[indexToken] / prices[indexToken];\\r\\n  }\\r\\n\\r\\n  /// @notice What amount of collateral should be sold to pay the debt and receive {requestedAmount}\\r\\n  /// @dev It doesn't allow to sell more than the amount of total debt in the borrow\\r\\n  /// @param requestedAmount We need to increase balance (of collateral asset) on this amount\\r\\n  /// @param totalDebt Total debt of the borrow in terms of borrow asset\\r\\n  /// @param totalCollateral Total collateral of the borrow in terms of collateral asset\\r\\n  /// @param prices Cost of $1 in terms of the asset, decimals 18\\r\\n  /// @param decs 10**decimals for each asset\\r\\n  /// @param indexCollateral Index of the collateral asset in {prices} and {decs}\\r\\n  /// @param indexBorrowAsset Index of the borrow asset in {prices} and {decs}\\r\\n  /// @param balanceBorrowAsset Available balance of the borrow asset, it will be used to cover the debt\\r\\n  /// @return amountOut Amount of collateral-asset that should be sold\\r\\n  function _getAmountToSell(\\r\\n    uint requestedAmount,\\r\\n    uint totalDebt,\\r\\n    uint totalCollateral,\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrowAsset,\\r\\n    uint balanceBorrowAsset\\r\\n  ) internal pure returns (\\r\\n    uint amountOut\\r\\n  ) {\\r\\n    if (totalDebt != 0) {\\r\\n      if (balanceBorrowAsset != 0) {\\r\\n        // there is some borrow asset on balance\\r\\n        // it will be used to cover the debt\\r\\n        // let's reduce the size of totalDebt/Collateral to exclude balanceBorrowAsset\\r\\n        uint sub = Math.min(balanceBorrowAsset, totalDebt);\\r\\n        totalCollateral -= totalCollateral * sub / totalDebt;\\r\\n        totalDebt -= sub;\\r\\n      }\\r\\n\\r\\n      // for definiteness: usdc - collateral asset, dai - borrow asset\\r\\n      // Pc = price of the USDC, Pb = price of the DAI, alpha = Pc / Pb [DAI / USDC]\\r\\n      // S [USDC] - amount to sell, R [DAI] = alpha * S - amount to repay\\r\\n      // After repaying R we get: alpha * S * C / R\\r\\n      // Balance should be increased on: requestedAmount = alpha * S * C / R - S\\r\\n      // So, we should sell: S = requestedAmount / (alpha * C / R - 1))\\r\\n      // We can lost some amount on liquidation of S => R, so we need to use some gap = {GAP_AMOUNT_TO_SELL}\\r\\n      // Same formula: S * h = S + requestedAmount, where h = health factor => s = requestedAmount / (h - 1)\\r\\n      // h = alpha * C / R\\r\\n      uint alpha18 = prices[indexCollateral] * decs[indexBorrowAsset] * 1e18\\r\\n        / prices[indexBorrowAsset] / decs[indexCollateral];\\r\\n\\r\\n      // if totalCollateral is zero (liquidation happens) we will have zero amount (the debt shouldn't be paid)\\r\\n      amountOut = totalDebt != 0 && alpha18 * totalCollateral / totalDebt > 1e18\\r\\n        ? Math.min(requestedAmount, totalCollateral) * 1e18 / (alpha18 * totalCollateral / totalDebt - 1e18)\\r\\n        : 0;\\r\\n\\r\\n      if (amountOut != 0) {\\r\\n        // we shouldn't try to sell amount greater than amount of totalDebt in terms of collateral asset\\r\\n        // but we always asks +1% because liquidation results can be different a bit from expected\\r\\n        amountOut = (AppLib.GAP_CONVERSION + AppLib.DENOMINATOR) * Math.min(amountOut, totalDebt * 1e18 / alpha18) / AppLib.DENOMINATOR;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return amountOut;\\r\\n  }\\r\\n//endregion ------------------------------------------------ Build plan\\r\\n}\\r\\n\",\"keccak256\":\"0xbe94b0f9bfed116a0dd0fe1c212203b58d40d9a81416116d63fd07669f708596\",\"license\":\"BUSL-1.1\"},\"contracts/libs/TokenAmountsLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./AppErrors.sol\\\";\\r\\n\\r\\n/// @title Library for clearing / joining token addresses & amounts arrays\\r\\n/// @author bogdoslav\\r\\nlibrary TokenAmountsLib {\\r\\n  /// @notice Version of the contract\\r\\n  /// @dev Should be incremented when contract changed\\r\\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \\\"1.0.1\\\";\\r\\n\\r\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\r\\n    unchecked {\\r\\n      return i + 1;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function filterZeroAmounts(\\r\\n    address[] memory tokens,\\r\\n    uint[] memory amounts\\r\\n  ) internal pure returns (\\r\\n    address[] memory t,\\r\\n    uint[] memory a\\r\\n  ) {\\r\\n    require(tokens.length == amounts.length, AppErrors.INCORRECT_LENGTHS);\\r\\n    uint len2 = 0;\\r\\n    uint len = tokens.length;\\r\\n    for (uint i = 0; i < len; i++) {\\r\\n      if (amounts[i] != 0) len2++;\\r\\n    }\\r\\n\\r\\n    t = new address[](len2);\\r\\n    a = new uint[](len2);\\r\\n\\r\\n    uint j = 0;\\r\\n    for (uint i = 0; i < len; i++) {\\r\\n      uint amount = amounts[i];\\r\\n      if (amount != 0) {\\r\\n        t[j] = tokens[i];\\r\\n        a[j] = amount;\\r\\n        j++;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\\r\\n  function combineArrays(\\r\\n    address[] memory tokens0,\\r\\n    uint[] memory amounts0,\\r\\n    address[] memory tokens1,\\r\\n    uint[] memory amounts1,\\r\\n    address[] memory tokens2,\\r\\n    uint[] memory amounts2\\r\\n  ) internal pure returns (\\r\\n    address[] memory allTokens,\\r\\n    uint[] memory allAmounts\\r\\n  ) {\\r\\n    uint[] memory lens = new uint[](3);\\r\\n    lens[0] = tokens0.length;\\r\\n    lens[1] = tokens1.length;\\r\\n    lens[2] = tokens2.length;\\r\\n\\r\\n    require(\\r\\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\\r\\n      AppErrors.INCORRECT_LENGTHS\\r\\n    );\\r\\n\\r\\n    uint maxLength = lens[0] + lens[1] + lens[2];\\r\\n    address[] memory tokensOut = new address[](maxLength);\\r\\n    uint[] memory amountsOut = new uint[](maxLength);\\r\\n    uint unitedLength;\\r\\n\\r\\n    for (uint step; step < 3; ++step) {\\r\\n      uint[] memory amounts = step == 0\\r\\n        ? amounts0\\r\\n        : (step == 1\\r\\n          ? amounts1\\r\\n          : amounts2);\\r\\n      address[] memory tokens = step == 0\\r\\n        ? tokens0\\r\\n        : (step == 1\\r\\n          ? tokens1\\r\\n          : tokens2);\\r\\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\\r\\n        uint amount1 = amounts[i1];\\r\\n        address token1 = tokens[i1];\\r\\n        bool united = false;\\r\\n\\r\\n        for (uint i = 0; i < unitedLength; i++) {\\r\\n          if (token1 == tokensOut[i]) {\\r\\n            amountsOut[i] += amount1;\\r\\n            united = true;\\r\\n            break;\\r\\n          }\\r\\n        }\\r\\n\\r\\n        if (!united) {\\r\\n          tokensOut[unitedLength] = token1;\\r\\n          amountsOut[unitedLength] = amount1;\\r\\n          unitedLength++;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // copy united tokens to result array\\r\\n    allTokens = new address[](unitedLength);\\r\\n    allAmounts = new uint[](unitedLength);\\r\\n    for (uint i; i < unitedLength; i++) {\\r\\n      allTokens[i] = tokensOut[i];\\r\\n      allAmounts[i] = amountsOut[i];\\r\\n    }\\r\\n\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0xb3adb8a53441362b47b3bf5c0c7181f7c1652de7dde3df4fb765e8484447d074\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/ConverterStrategyBase.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV3.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\\\";\\r\\nimport \\\"./ConverterStrategyBaseLib.sol\\\";\\r\\nimport \\\"./ConverterStrategyBaseLib2.sol\\\";\\r\\nimport \\\"./DepositorBase.sol\\\";\\r\\nimport \\\"../interfaces/IConverterStrategyBase.sol\\\";\\r\\n\\r\\n/////////////////////////////////////////////////////////////////////\\r\\n///                        TERMS\\r\\n///  Main asset == underlying: the asset deposited to the vault by users\\r\\n///  Secondary assets: all assets deposited to the internal pool except the main asset\\r\\n/////////////////////////////////////////////////////////////////////\\r\\n// History:\\r\\n// 3.0.1 refactoring of emergency exit\\r\\n// 3.1.0 use bookkeeper, new set of events\\r\\n// 3.1.2 scb-867\\r\\n// 3.1.3 scb-900\\r\\n\\r\\n/// @title Abstract contract for base Converter strategy functionality\\r\\n/// @notice All depositor assets must be correlated (ie USDC/USDT/DAI)\\r\\n/// @author bogdoslav, dvpublic, a17\\r\\nabstract contract ConverterStrategyBase is IConverterStrategyBase, ITetuConverterCallback, DepositorBase, StrategyBaseV3 {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  //region -------------------------------------------------------- DATA TYPES\\r\\n  struct WithdrawUniversalLocal {\\r\\n    ITetuConverter converter;\\r\\n    /// @notice Target asset that should be received on balance.\\r\\n    ///         It's underlying in _withdrawUniversal(), but it can be any other asset in requirePayAmountBack()\\r\\n    address theAsset;\\r\\n    /// @notice List of tokens received by _depositorPoolAssets()\\r\\n    address[] tokens;\\r\\n    /// @notice Index of the {asset} in {tokens}\\r\\n    uint indexTheAsset;\\r\\n    /// @notice Initial balance of the [asset}\\r\\n    uint balanceBefore;\\r\\n    uint indexUnderlying;\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- DATA TYPES\\r\\n\\r\\n  //region -------------------------------------------------------- CONSTANTS\\r\\n\\r\\n  /// @dev Version of this contract. Adjust manually on each code modification.\\r\\n  string public constant CONVERTER_STRATEGY_BASE_VERSION = \\\"3.1.3\\\";\\r\\n\\r\\n  /// @notice 1% gap to cover possible liquidation inefficiency\\r\\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\\r\\n  uint internal constant GAP_CONVERSION = 1_000;\\r\\n  uint internal constant DENOMINATOR = 100_000;\\r\\n  /// @notice If we need to withdraw A, we always tries to receive on balance A + delta\\r\\n  ///         and have at least delta on balance after withdraw to prevent situation when we have debts\\r\\n  ///         but don't have any liquidity to pay the debts and receive locked collaterals back\\r\\n  ///\\r\\n  ///         Delta will be in the range [GAP_WITHDRAW...2 * GAP_WITHDRAW]\\r\\n  uint internal constant GAP_WITHDRAW = 1_000;\\r\\n  //endregion -------------------------------------------------------- CONSTANTS\\r\\n\\r\\n  //region -------------------------------------------------------- VARIABLES\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n  //                Keep names and ordering!\\r\\n  // Add only in the bottom and don't forget to decrease gap variable\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n\\r\\n  /// @notice Minimum token amounts that can be liquidated\\r\\n  /// @dev These thresholds are used to workaround dust problems in many other cases, not during liquidation only\\r\\n  mapping(address => uint) public liquidationThresholds;\\r\\n\\r\\n  /// @notice Internal variables of ConverterStrategyBase\\r\\n  ConverterStrategyBaseState internal _csbs;\\r\\n  //endregion -------------------------------------------------------- VARIABLES\\r\\n\\r\\n  //region -------------------------------------------------------- Getters\\r\\n  function converter() external view returns (ITetuConverter) {\\r\\n    return _csbs.converter;\\r\\n  }\\r\\n\\r\\n  function reinvestThresholdPercent() external view returns (uint) {\\r\\n    return _csbs.reinvestThresholdPercent;\\r\\n  }\\r\\n\\r\\n  function debtToInsurance() external view returns (int) {\\r\\n    return _csbs.debtToInsurance;\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- Getters\\r\\n\\r\\n  //region -------------------------------------------------------- Events\\r\\n  event OnDepositorEnter(uint[] amounts, uint[] consumedAmounts);\\r\\n  event OnDepositorExit(uint liquidityAmount, uint[] withdrawnAmounts);\\r\\n  event OnDepositorEmergencyExit(uint[] withdrawnAmounts);\\r\\n  event OnHardWorkEarnedLost(\\r\\n    uint investedAssetsNewPrices,\\r\\n    uint earnedByPrices,\\r\\n    uint earnedHandleRewards,\\r\\n    uint lostHandleRewards,\\r\\n    uint earnedDeposit,\\r\\n    uint lostDeposit,\\r\\n    uint paidDebtToInsurance,\\r\\n    uint amountPerf\\r\\n  );\\r\\n  //endregion -------------------------------------------------------- Events\\r\\n\\r\\n  //region -------------------------------------------------------- Initialization and configuration\\r\\n\\r\\n  /// @notice Initialize contract after setup it as proxy implementation\\r\\n  function __ConverterStrategyBase_init(\\r\\n    address controller_,\\r\\n    address splitter_,\\r\\n    address converter_\\r\\n  ) internal onlyInitializing {\\r\\n    __StrategyBase_init(controller_, splitter_);\\r\\n    _csbs.converter = ITetuConverter(converter_);\\r\\n\\r\\n    // 1% by default\\r\\n    _csbs.reinvestThresholdPercent = DENOMINATOR / 100;\\r\\n    emit ConverterStrategyBaseLib2.ReinvestThresholdPercentChanged(DENOMINATOR / 100);\\r\\n  }\\r\\n\\r\\n  /// @dev Liquidation thresholds are used to detect dust in many cases, not only in liquidation case\\r\\n  /// @param amount Min amount of token allowed to liquidate, token's decimals are used.\\r\\n  function setLiquidationThreshold(address token, uint amount) external {\\r\\n    ConverterStrategyBaseLib2.checkLiquidationThresholdChanged(controller(), token, amount);\\r\\n    liquidationThresholds[token] = amount;\\r\\n  }\\r\\n\\r\\n  /// @param percent_ New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\\r\\n  function setReinvestThresholdPercent(uint percent_) external {\\r\\n    ConverterStrategyBaseLib2.checkReinvestThresholdPercentChanged(controller(), percent_);\\r\\n    _csbs.reinvestThresholdPercent = percent_;\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- Initialization and configuration\\r\\n\\r\\n  //region -------------------------------------------------------- Deposit to the pool\\r\\n\\r\\n  /// @notice Amount of underlying assets converted to pool assets and invested to the pool.\\r\\n  function investedAssets() override public view virtual returns (uint) {\\r\\n    return _csbs.investedAssets;\\r\\n  }\\r\\n\\r\\n  /// @notice Deposit given amount to the pool.\\r\\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\\r\\n    uint strategyLoss\\r\\n  ){\\r\\n    (uint updatedInvestedAssets, uint earnedByPrices) = _fixPriceChanges(updateTotalAssetsBeforeInvest_);\\r\\n    (strategyLoss,) = _depositToPoolUniversal(amount_, earnedByPrices, updatedInvestedAssets, false);\\r\\n  }\\r\\n\\r\\n  /// @notice Deposit {amount_} to the pool, send {earnedByPrices_} to insurance.\\r\\n  ///         totalAsset will decrease on earnedByPrices_ and sharePrice won't change after all recalculations.\\r\\n  /// @dev We need to deposit {amount_} and withdraw {earnedByPrices_} here\\r\\n  /// @param amount_ Amount of underlying to be deposited\\r\\n  /// @param earnedByPrices_ Profit received because of price changing\\r\\n  /// @param investedAssets_ Invested assets value calculated with updated prices\\r\\n  /// @param updateInvestedAssetsInAnyCase_ _csbs.investedAssets must be updated even if a deposit is not needed\\r\\n  /// @return strategyLoss Loss happened on the depositing. It doesn't include any price-changing losses\\r\\n  /// @return amountSentToInsurance Price-changing-profit that was sent to the insurance\\r\\n  function _depositToPoolUniversal(\\r\\n    uint amount_,\\r\\n    uint earnedByPrices_,\\r\\n    uint investedAssets_,\\r\\n    bool updateInvestedAssetsInAnyCase_\\r\\n  ) internal virtual returns (\\r\\n    uint strategyLoss,\\r\\n    uint amountSentToInsurance\\r\\n  ){\\r\\n    address _asset = baseState.asset;\\r\\n\\r\\n    uint amountToDeposit = amount_ > earnedByPrices_\\r\\n      ? amount_ - earnedByPrices_\\r\\n      : 0;\\r\\n\\r\\n    // skip deposit for small amounts\\r\\n    bool needToDeposit = amountToDeposit > _csbs.reinvestThresholdPercent * investedAssets_ / DENOMINATOR;\\r\\n    uint balanceBefore = AppLib.balance(_asset);\\r\\n\\r\\n    // send earned-by-prices to the insurance, ignore dust values\\r\\n    if (earnedByPrices_ > AppLib._getLiquidationThreshold(liquidationThresholds[_asset])) {\\r\\n      if (needToDeposit || balanceBefore >= earnedByPrices_) {\\r\\n        (amountSentToInsurance,) = ConverterStrategyBaseLib2.sendToInsurance(\\r\\n          _asset,\\r\\n          earnedByPrices_,\\r\\n          baseState.splitter,\\r\\n          investedAssets_ + balanceBefore,\\r\\n          balanceBefore\\r\\n        );\\r\\n      } else {\\r\\n        // needToDeposit is false and we don't have enough amount to cover earned-by-prices, we need to withdraw\\r\\n        (/* expectedWithdrewUSD */,, strategyLoss, amountSentToInsurance) = _withdrawUniversal(0, earnedByPrices_, investedAssets_);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // make deposit\\r\\n    if (needToDeposit) {\\r\\n      (address[] memory tokens, uint indexAsset) = _getTokens(_asset);\\r\\n\\r\\n      // prepare array of amounts ready to deposit, borrow missed amounts\\r\\n      uint[] memory amounts = _beforeDeposit(_csbs.converter, amountToDeposit, tokens, indexAsset);\\r\\n\\r\\n      // make deposit, actually consumed amounts can be different from the desired amounts\\r\\n      if (!ConverterStrategyBaseLib2.findZeroAmount(amounts)) {\\r\\n        // we cannot enter to pool if at least one of amounts is zero\\r\\n        // we check != 0 and don't use thresholds because some strategies allow to enter to the pool with amount < liquidation threshold\\r\\n        (uint[] memory consumedAmounts,) = _depositorEnter(amounts);\\r\\n        emit OnDepositorEnter(amounts, consumedAmounts);\\r\\n      }\\r\\n\\r\\n      // update _investedAssets with new deposited amount\\r\\n      uint investedAssetsAfter = _updateInvestedAssets();\\r\\n\\r\\n      // we need to compensate difference if during deposit we lost some assets\\r\\n      (,strategyLoss) = ConverterStrategyBaseLib2._registerIncome(\\r\\n        investedAssets_ + balanceBefore,\\r\\n        investedAssetsAfter + AppLib.balance(_asset) + amountSentToInsurance\\r\\n      );\\r\\n    } else {\\r\\n      if (updateInvestedAssetsInAnyCase_) {\\r\\n        _csbs.investedAssets = investedAssets_;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return (strategyLoss, amountSentToInsurance);\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- Deposit to the pool\\r\\n\\r\\n  //region -------------------------------------------------------- Convert amounts before deposit\\r\\n\\r\\n  /// @notice Prepare {tokenAmounts} to be passed to depositorEnter\\r\\n  /// @dev Override this function to customize entry kind\\r\\n  /// @param amount_ The amount of main asset that should be invested\\r\\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\\r\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\r\\n  /// @return tokenAmounts Amounts of depositor's assets ready to invest (this array can be passed to depositorEnter)\\r\\n  function _beforeDeposit(\\r\\n    ITetuConverter converter_,\\r\\n    uint amount_,\\r\\n    address[] memory tokens_,\\r\\n    uint indexAsset_\\r\\n  ) internal virtual returns (\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    // calculate required collaterals for each token and temporary save them to tokenAmounts\\r\\n    (uint[] memory weights, uint totalWeight) = _depositorPoolWeights();\\r\\n    return ConverterStrategyBaseLib.beforeDeposit(\\r\\n      converter_,\\r\\n      amount_,\\r\\n      tokens_,\\r\\n      indexAsset_,\\r\\n      weights,\\r\\n      totalWeight,\\r\\n      liquidationThresholds\\r\\n    );\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- Convert amounts before deposit\\r\\n\\r\\n  //region -------------------------------------------------------- Get requested amount\\r\\n\\r\\n  /// @notice Initialize members of {v}\\r\\n  /// @param underlying true if asset_ is underlying\\r\\n  function _initWithdrawUniversalLocal(address asset_, WithdrawUniversalLocal memory v, bool underlying) internal view {\\r\\n    v.tokens = _depositorPoolAssets();\\r\\n    v.theAsset = asset_;\\r\\n    v.converter = _csbs.converter;\\r\\n    v.indexTheAsset = AppLib.getAssetIndex(v.tokens, asset_);\\r\\n    v.balanceBefore = AppLib.balance(asset_);\\r\\n    v.indexUnderlying = underlying ? v.indexTheAsset : AppLib.getAssetIndex(v.tokens, baseState.asset);\\r\\n  }\\r\\n\\r\\n  /// @notice Get the specified {amount} of the given {v.asset} on the balance\\r\\n  /// @dev Ensures that either all debts are closed, or a non-zero amount remains on the balance or in the pool to pay off the debts\\r\\n  /// @param amount_ Required amount of {v.asset}. Use type(uint).max to withdraw all\\r\\n  /// @return expectedTotalAssetAmount Expected amount of {v.asset} that should be received on the balance\\r\\n  ///                                  Expected total amount of given asset after all withdraws, conversions, swaps and repays\\r\\n  function _makeRequestedAmount(uint amount_, WithdrawUniversalLocal memory v) internal virtual returns ( // it's virtual to simplify unit testing\\r\\n    uint expectedTotalAssetAmount\\r\\n  ) {\\r\\n    uint depositorLiquidity = _depositorLiquidity();\\r\\n\\r\\n    // calculate how much liquidity we need to withdraw for getting at least requested amount of the {v.asset}\\r\\n    uint[] memory quoteAmounts = _depositorQuoteExit(depositorLiquidity);\\r\\n    uint liquidityAmountToWithdraw = ConverterStrategyBaseLib2.getLiquidityAmount(\\r\\n      amount_,\\r\\n      v.tokens,\\r\\n      v.indexTheAsset,\\r\\n      v.converter,\\r\\n      quoteAmounts,\\r\\n      depositorLiquidity,\\r\\n      v.indexUnderlying\\r\\n    );\\r\\n\\r\\n    if (liquidityAmountToWithdraw != 0) {\\r\\n      uint[] memory withdrawnAmounts = _depositorExit(liquidityAmountToWithdraw, false);\\r\\n      // the depositor is able to use less liquidity than it was asked, i.e. Balancer-depositor leaves some BPT unused\\r\\n      // use what exactly was withdrew instead of the expectation\\r\\n      // assume that liquidity cannot increase in _depositorExit\\r\\n      liquidityAmountToWithdraw = depositorLiquidity - _depositorLiquidity();\\r\\n      emit OnDepositorExit(liquidityAmountToWithdraw, withdrawnAmounts);\\r\\n    }\\r\\n\\r\\n    // try to receive at least requested amount of the {v.asset} on the balance\\r\\n    uint expectedBalance = ConverterStrategyBaseLib.makeRequestedAmount(\\r\\n      v.tokens,\\r\\n      v.indexTheAsset,\\r\\n      v.converter,\\r\\n      AppLib._getLiquidator(controller()),\\r\\n      (amount_ == type(uint).max ? amount_ : v.balanceBefore + amount_), // current balance + the amount required to be withdrawn on balance\\r\\n      liquidationThresholds\\r\\n    );\\r\\n\\r\\n    require(expectedBalance >= v.balanceBefore, AppErrors.BALANCE_DECREASE);\\r\\n    return expectedBalance - v.balanceBefore;\\r\\n  }\\r\\n\\r\\n  //endregion -------------------------------------------------------- Get requested amount\\r\\n\\r\\n  //region -------------------------------------------------------- Withdraw from the pool\\r\\n\\r\\n  function _beforeWithdraw(uint /*amount*/) internal virtual {\\r\\n    // do nothing\\r\\n  }\\r\\n\\r\\n  /// @notice Withdraw given amount from the pool.\\r\\n  /// @param amount Amount to be withdrawn in terms of the asset in addition to the exist balance.\\r\\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing (in USD, decimals of the {asset})\\r\\n  /// @return assetPrice Price of the {asset} from the price oracle\\r\\n  /// @return strategyLoss Loss should be covered from Insurance\\r\\n  function _withdrawFromPool(uint amount) override internal virtual returns (\\r\\n    uint expectedWithdrewUSD,\\r\\n    uint assetPrice,\\r\\n    uint strategyLoss\\r\\n  ) {\\r\\n    // calculate profit/loss because of price changes, try to compensate the loss from the insurance\\r\\n    (uint investedAssetsNewPrices, uint earnedByPrices) = _fixPriceChanges(true);\\r\\n    (expectedWithdrewUSD, assetPrice, strategyLoss,) = _withdrawUniversal(amount, earnedByPrices, investedAssetsNewPrices);\\r\\n  }\\r\\n\\r\\n  /// @notice Withdraw all from the pool.\\r\\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing\\r\\n  /// @return assetPrice Price of the {asset} taken from the price oracle\\r\\n  /// @return strategyLoss Loss should be covered from Insurance\\r\\n  function _withdrawAllFromPool() override internal virtual returns (\\r\\n    uint expectedWithdrewUSD,\\r\\n    uint assetPrice,\\r\\n    uint strategyLoss\\r\\n  ) {\\r\\n    return _withdrawFromPool(type(uint).max);\\r\\n  }\\r\\n\\r\\n  /// @dev The function is virtual to simplify unit testing\\r\\n  /// @param amount_ Amount to be trying to withdrawn. Max uint means attempt to withdraw all possible invested assets.\\r\\n  /// @param earnedByPrices_ Additional amount that should be withdrawn and send to the insurance\\r\\n  /// @param investedAssets_ Value of invested assets recalculated using current prices\\r\\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing in terms of USD value of each asset in the pool\\r\\n  /// @return assetPrice Price of the {asset} taken from the price oracle\\r\\n  /// @return strategyLoss Loss before withdrawing: [new-investedAssets - old-investedAssets]\\r\\n  /// @return amountSentToInsurance Actual amount of underlying sent to the insurance\\r\\n  function _withdrawUniversal(uint amount_, uint earnedByPrices_, uint investedAssets_) virtual internal returns (\\r\\n    uint expectedWithdrewUSD,\\r\\n    uint assetPrice,\\r\\n    uint strategyLoss,\\r\\n    uint amountSentToInsurance\\r\\n  ) {\\r\\n    // amount to withdraw; we add a little gap to avoid situation \\\"opened debts, no liquidity to pay\\\"\\r\\n    uint amount = amount_ == type(uint).max\\r\\n      ? amount_\\r\\n      : (amount_ + earnedByPrices_) * (DENOMINATOR + GAP_WITHDRAW) / DENOMINATOR;\\r\\n    _beforeWithdraw(amount);\\r\\n\\r\\n    if (amount != 0 && investedAssets_ != 0) {\\r\\n      WithdrawUniversalLocal memory v;\\r\\n      _initWithdrawUniversalLocal(baseState.asset, v, true);\\r\\n\\r\\n      // get at least requested amount of the underlying on the balance\\r\\n      assetPrice = ConverterStrategyBaseLib2.getAssetPriceFromConverter(v.converter, v.theAsset);\\r\\n      expectedWithdrewUSD = AppLib.sub0(_makeRequestedAmount(amount, v), earnedByPrices_) * assetPrice / 1e18;\\r\\n\\r\\n      (amountSentToInsurance, strategyLoss) = ConverterStrategyBaseLib2.calculateIncomeAfterWithdraw(\\r\\n        baseState.splitter,\\r\\n        v.theAsset,\\r\\n        investedAssets_,\\r\\n        v.balanceBefore,\\r\\n        earnedByPrices_,\\r\\n        _updateInvestedAssets()\\r\\n      );\\r\\n    }\\r\\n\\r\\n    return (\\r\\n      expectedWithdrewUSD,\\r\\n      assetPrice,\\r\\n      strategyLoss,\\r\\n      amountSentToInsurance\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Withdraw all amounts from the pool using minimum actions (it skips claiming rewards, fees and so on)\\r\\n  function _emergencyExitFromPool() override internal virtual {\\r\\n    uint[] memory withdrawnAmounts = _depositorEmergencyExit();\\r\\n    emit OnDepositorEmergencyExit(withdrawnAmounts);\\r\\n    // we don't convert amounts to main asset to avoid any excess actions\\r\\n    // update of invested assets is necessary in any case\\r\\n    _updateInvestedAssets();\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- Withdraw from the pool\\r\\n\\r\\n  //region -------------------------------------------------------- Claim rewards\\r\\n\\r\\n  /// @notice Claim all possible rewards.\\r\\n  function _claim() override internal virtual returns (address[] memory rewardTokensOut, uint[] memory amountsOut) {\\r\\n    // get rewards from the Depositor\\r\\n    (address[] memory rewardTokens, uint[] memory rewardAmounts, uint[] memory balancesBefore) = _depositorClaimRewards();\\r\\n\\r\\n    (rewardTokensOut, amountsOut) = ConverterStrategyBaseLib2.claimConverterRewards(\\r\\n      _csbs.converter,\\r\\n      _depositorPoolAssets(),\\r\\n      rewardTokens,\\r\\n      rewardAmounts,\\r\\n      balancesBefore\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @dev Call recycle process and send tokens to forwarder.\\r\\n  ///      Need to be separated from the claim process - the claim can be called by operator for other purposes.\\r\\n  /// @return paidDebtToInsurance Earned amount spent on debt-to-insurance payment\\r\\n  /// @return amountPerf Total performance fee in terms of underlying\\r\\n  function _rewardsLiquidation(address[] memory rewardTokens_, uint[] memory rewardAmounts_) internal returns (\\r\\n    uint paidDebtToInsurance,\\r\\n    uint amountPerf\\r\\n  ) {\\r\\n    if (rewardTokens_.length != 0) {\\r\\n      (paidDebtToInsurance, amountPerf) = ConverterStrategyBaseLib.recycle(\\r\\n        baseState,\\r\\n        _csbs,\\r\\n        _depositorPoolAssets(),\\r\\n        controller(),\\r\\n        liquidationThresholds,\\r\\n        rewardTokens_,\\r\\n        rewardAmounts_\\r\\n      );\\r\\n    }\\r\\n    return (paidDebtToInsurance, amountPerf);\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- Claim rewards\\r\\n\\r\\n  //region -------------------------------------------------------- Hardwork\\r\\n\\r\\n  /// @notice A virtual handler to make any action before hardwork\\r\\n  /// @return True if the hardwork should be skipped\\r\\n  function _preHardWork(bool reInvest) internal virtual returns (bool) {\\r\\n    reInvest; // hide warning\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  /// @notice A virtual handler to make any action after hardwork\\r\\n  function _postHardWork() internal virtual {}\\r\\n\\r\\n  /// @notice Is strategy ready to hard work\\r\\n  function isReadyToHardWork() override external virtual view returns (bool) {\\r\\n    // check claimable amounts and compare with thresholds\\r\\n    return true;\\r\\n  }\\r\\n\\r\\n  /// @notice Do hard work with reinvesting\\r\\n  /// @return earned Earned amount in terms of {asset}\\r\\n  /// @return lost Lost amount in terms of {asset}\\r\\n  function doHardWork() override public returns (uint earned, uint lost) {\\r\\n    require(msg.sender == baseState.splitter, StrategyLib2.DENIED);\\r\\n    return _doHardWork(true);\\r\\n  }\\r\\n\\r\\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\\r\\n  /// @return earned The amount of earned rewards.\\r\\n  /// @return lost The amount of lost rewards.\\r\\n  /// @return assetBalanceAfterClaim The asset balance after claiming rewards.\\r\\n  /// @return paidDebtToInsurance A part of {earned} spent on debt-to-insurance payment\\r\\n  /// @return amountPerf Performance fee in terms of underlying\\r\\n  function _handleRewards() internal virtual returns (\\r\\n    uint earned,\\r\\n    uint lost,\\r\\n    uint assetBalanceAfterClaim,\\r\\n    uint paidDebtToInsurance,\\r\\n    uint amountPerf\\r\\n  );\\r\\n\\r\\n  /// @param reInvest Deposit to pool all available amount if it's greater than the threshold\\r\\n  /// @return earned Earned amount in terms of {asset}\\r\\n  /// @return lost Lost amount in terms of {asset}\\r\\n  function _doHardWork(bool reInvest) internal returns (uint earned, uint lost) {\\r\\n    // ATTENTION! splitter will not cover the loss if it is lower than profit\\r\\n    (uint investedAssetsNewPrices, uint earnedByPrices) = _fixPriceChanges(true);\\r\\n    if (!_preHardWork(reInvest)) {\\r\\n      // claim rewards and get current asset balance\\r\\n      (uint earned1, uint lost1, uint assetBalance, uint paidDebtToInsurance, uint amountPerf) = _handleRewards();\\r\\n\\r\\n      // re-invest income\\r\\n      (uint investedAssetsAfterHandleRewards,,) = _calcInvestedAssets();\\r\\n\\r\\n      (, uint amountSentToInsurance) = _depositToPoolUniversal(\\r\\n        reInvest\\r\\n        && investedAssetsAfterHandleRewards != 0\\r\\n        && assetBalance > _csbs.reinvestThresholdPercent * investedAssetsAfterHandleRewards / DENOMINATOR\\r\\n          ? assetBalance\\r\\n          : 0,\\r\\n        earnedByPrices,\\r\\n        investedAssetsAfterHandleRewards,\\r\\n        true\\r\\n      );\\r\\n\\r\\n      (earned, lost) = ConverterStrategyBaseLib2._registerIncome(\\r\\n        investedAssetsAfterHandleRewards + assetBalance, // assets in use before deposit\\r\\n        _csbs.investedAssets + AppLib.balance(baseState.asset) + amountSentToInsurance // assets in use after deposit\\r\\n      );\\r\\n\\r\\n      _postHardWork();\\r\\n      emit OnHardWorkEarnedLost(investedAssetsNewPrices, earnedByPrices, earned1, lost1, earned, lost, paidDebtToInsurance, amountPerf);\\r\\n\\r\\n      // Excluded from earned two values: performance fee and amount paid to cover debt before the insurance\\r\\n      // Amount sent to the forwarder is still included to the result earned amount.\\r\\n      earned = AppLib.sub0(earned + earned1, paidDebtToInsurance + amountPerf);\\r\\n      lost += lost1;\\r\\n    }\\r\\n\\r\\n    // register amount paid for the debts and amount received for the provided collaterals\\r\\n    ConverterStrategyBaseLib2.registerBorrowResults(_csbs.converter, baseState.asset);\\r\\n\\r\\n    return (earned, lost);\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- Hardwork\\r\\n\\r\\n  //region -------------------------------------------------------- InvestedAssets Calculations\\r\\n\\r\\n  /// @notice Updates cached _investedAssets to actual value\\r\\n  /// @dev Should be called after deposit / withdraw / claim; virtual - for ut\\r\\n  function _updateInvestedAssets() internal returns (uint investedAssetsOut) {\\r\\n    (investedAssetsOut,,) = _calcInvestedAssets();\\r\\n    _csbs.investedAssets = investedAssetsOut;\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\r\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\r\\n  /// @return amountOut Invested asset amount under control (in terms of {asset})\\r\\n  /// @return prices Asset prices in USD, decimals 18\\r\\n  /// @return decs 10**decimals\\r\\n  function _calcInvestedAssets() internal returns (uint amountOut, uint[] memory prices, uint[] memory decs) {\\r\\n    (address[] memory tokens, uint indexAsset) = _getTokens(baseState.asset);\\r\\n    return ConverterStrategyBaseLib2.calcInvestedAssets(\\r\\n      tokens,\\r\\n      _getDepositorQuoteExitAmountsOut(tokens),\\r\\n      indexAsset,\\r\\n      _csbs.converter,\\r\\n      true\\r\\n    );\\r\\n  }\\r\\n\\r\\n  function calcInvestedAssets() external returns (uint investedAssetsOut) {\\r\\n    StrategyLib2.onlyOperators(controller());\\r\\n    (investedAssetsOut,,) = _calcInvestedAssets();\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate amount of deposited tokens that can be received from the pool after withdrawing all liquidity.\\r\\n  function _getDepositorQuoteExitAmountsOut(address[] memory tokens) internal returns (\\r\\n    uint[] memory depositorQuoteExitAmountsOut\\r\\n  ) {\\r\\n    uint liquidity = _depositorLiquidity();\\r\\n    return liquidity == 0\\r\\n      ? new uint[](tokens.length)\\r\\n      : _depositorQuoteExit(liquidity);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate profit/loss happened because of price changing. Try to cover the loss, send the profit to the insurance\\r\\n  /// @param updateInvestedAssetsAmount_ If false - just return current value of invested assets\\r\\n  /// @return investedAssetsOut Updated value of {_investedAssets}\\r\\n  /// @return earnedOut Profit that was received because of price changes. It should be sent back to insurance.\\r\\n  /// It's too dangerous to try to get this amount here because of the problem \\\"borrow-repay is not allowed in a single block\\\"\\r\\n  /// So, we need to handle it in the caller code.\\r\\n  function _fixPriceChanges(bool updateInvestedAssetsAmount_) internal returns (uint investedAssetsOut, uint earnedOut) {\\r\\n    if (updateInvestedAssetsAmount_) {\\r\\n      (address[] memory tokens, uint indexAsset) = _getTokens(baseState.asset);\\r\\n      (investedAssetsOut, earnedOut) = ConverterStrategyBaseLib2.fixPriceChanges(\\r\\n        _csbs,\\r\\n        baseState,\\r\\n        _getDepositorQuoteExitAmountsOut(tokens),\\r\\n        tokens,\\r\\n        indexAsset\\r\\n      );\\r\\n    } else {\\r\\n      (investedAssetsOut, earnedOut) = (_csbs.investedAssets, 0);\\r\\n    }\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- InvestedAssets Calculations\\r\\n\\r\\n  //region -------------------------------------------------------- ITetuConverterCallback\\r\\n\\r\\n  /// @notice Converters asks to send some amount back.\\r\\n  ///         The results depend on whether the required amount is on the balance:\\r\\n  ///         1. The {amount_} exists on the balance: send the amount to TetuConverter, return {amount_}\\r\\n  ///         2. The {amount_} doesn't exist on the balance. Try to receive the {amount_}.\\r\\n  ///         2.1. if the required amount is received: return {amount_}\\r\\n  ///         2.2. if less amount X (X < {amount_}) is received return X - gap\\r\\n  ///         In the case 2 no amount is send to TetuConverter.\\r\\n  ///         Converter should make second call of requirePayAmountBack({amountOut}) to receive the assets.\\r\\n  /// @param theAsset_ Required asset (either collateral or borrow), it can be NOT underlying\\r\\n  /// @param amount_ Required amount of {theAsset_}\\r\\n  /// @return amountOut Amount that was send OR can be claimed on the next call.\\r\\n  ///                   The caller should control own balance to know if the amount was actually send\\r\\n  ///                   (because we need compatibility with exist not-NSR strategies)\\r\\n  function requirePayAmountBack(address theAsset_, uint amount_) external override returns (uint amountOut) {\\r\\n    WithdrawUniversalLocal memory v;\\r\\n    _initWithdrawUniversalLocal(theAsset_, v, false);\\r\\n    require(msg.sender == address(v.converter), StrategyLib.DENIED);\\r\\n    require(amount_ != 0, AppErrors.ZERO_VALUE);\\r\\n    require(v.indexTheAsset != type(uint).max, AppErrors.WRONG_ASSET);\\r\\n\\r\\n    (uint _investedAssets, uint earnedByPrices) = _fixPriceChanges(true);\\r\\n    v.balanceBefore = ConverterStrategyBaseLib2.sendProfitGetAssetBalance(theAsset_, v.balanceBefore, _investedAssets, earnedByPrices, baseState);\\r\\n\\r\\n    // amount to withdraw; we add a little gap to avoid situation \\\"opened debts, no liquidity to pay\\\"\\r\\n    // At first we add only 1 gap.\\r\\n    // This is min allowed amount that we should have on balance to be able to send {amount_} to the converter\\r\\n    uint amountPlusGap = amount_ * (DENOMINATOR + GAP_WITHDRAW) / DENOMINATOR;\\r\\n\\r\\n    if (v.balanceBefore >= amountPlusGap) {\\r\\n      // the requested amount is available, send it to the converter\\r\\n      IERC20(theAsset_).safeTransfer(address(v.converter), amount_);\\r\\n      amountOut = amount_;\\r\\n    } else {\\r\\n      // the requested amount is not available\\r\\n      // so, we cannot send anything to converter in this call\\r\\n      // try to receive requested amount to balance\\r\\n      // we should receive amount with extra gap, where gap is in the range (GAP_WITHDRAW, 2 * GAP_WITHDRAW]\\r\\n      // The caller will be able to claim requested amount (w/o extra gap) in the next call\\r\\n      if (_investedAssets == 0) {\\r\\n        // there are no invested amounts, we can use amount on balance only\\r\\n        // but we cannot send all amount, we should keep not zero amount on balance\\r\\n        // to avoid situation \\\"opened debts, no liquidity to pay\\\"\\r\\n        // as soon as the converter asks for payment, we still have an opened debt..\\r\\n        amountOut = v.balanceBefore * DENOMINATOR / (DENOMINATOR + GAP_WITHDRAW);\\r\\n      } else {\\r\\n        uint amountTwoGaps = amount_ * (DENOMINATOR + 2 * GAP_WITHDRAW) / DENOMINATOR;\\r\\n        // get at least requested amount of {theAsset_} on the balance\\r\\n        _makeRequestedAmount(amountTwoGaps - v.balanceBefore, v);\\r\\n\\r\\n        uint balanceAfter = AppLib.balance(theAsset_);\\r\\n        amountOut = balanceAfter > amountPlusGap\\r\\n          ? amount_\\r\\n          : balanceAfter * DENOMINATOR / (DENOMINATOR + GAP_WITHDRAW);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // update invested assets anyway, even if we suppose it will be called in other places\\r\\n    _updateInvestedAssets();\\r\\n\\r\\n    return amountOut;\\r\\n  }\\r\\n\\r\\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\\r\\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\\r\\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\\r\\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external override {\\r\\n    require(msg.sender == address(_csbs.converter), StrategyLib2.DENIED);\\r\\n    require(assets_.length == amounts_.length, AppErrors.INCORRECT_LENGTHS);\\r\\n\\r\\n    // TetuConverter is able two call this function in two cases:\\r\\n    // 1) rebalancing (the health factor of some borrow is too low)\\r\\n    // 2) forcible closing of the borrow\\r\\n    // In both cases we update invested assets value here\\r\\n    // and avoid fixing any related losses in hardwork\\r\\n    _updateInvestedAssets();\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- ITetuConverterCallback\\r\\n\\r\\n  //region -------------------------------------------------------- Others\\r\\n\\r\\n  /// @notice Unlimited capacity by default\\r\\n  function capacity() external virtual view returns (uint) {\\r\\n    return 2 ** 255;\\r\\n    // almost same as type(uint).max but more gas efficient\\r\\n  }\\r\\n\\r\\n  /// @return tokens Result of {_depositorPoolAssets}\\r\\n  /// @return indexAsset Index of the underlying in {tokens}\\r\\n  function _getTokens(address asset_) internal view returns (address[] memory tokens, uint indexAsset) {\\r\\n    tokens = _depositorPoolAssets();\\r\\n    indexAsset = AppLib.getAssetIndex(tokens, asset_);\\r\\n    require(indexAsset != type(uint).max, StrategyLib2.WRONG_VALUE);\\r\\n  }\\r\\n  //endregion -------------------------------------------------------- Others\\r\\n\\r\\n\\r\\n  /// @dev This empty reserved space is put in place to allow future versions to add new\\r\\n  /// variables without shifting down storage in the inheritance chain.\\r\\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\r\\n  uint[50 - 4] private __gap; // 50 - count of variables\\r\\n\\r\\n}\\r\\n\",\"keccak256\":\"0x30dfda42728b6124e87adabd83791bbbf9873b71b1480a612fa7a68ff75a6079\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/ConverterStrategyBaseLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib2.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"../libs/AppErrors.sol\\\";\\r\\nimport \\\"../libs/AppLib.sol\\\";\\r\\nimport \\\"../libs/TokenAmountsLib.sol\\\";\\r\\nimport \\\"../libs/ConverterEntryKinds.sol\\\";\\r\\nimport \\\"../libs/IterationPlanLib.sol\\\";\\r\\nimport \\\"../interfaces/IConverterStrategyBase.sol\\\";\\r\\n\\r\\nlibrary ConverterStrategyBaseLib {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n//region--------------------------------------------------- Data types\\r\\n\\r\\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\\r\\n  struct RecycleLocalParams {\\r\\n    /// @notice Compound amount + Performance amount\\r\\n    uint amountCP;\\r\\n    /// @notice Amount to compound\\r\\n    uint amountC;\\r\\n    /// @notice Amount to send to performance and insurance\\r\\n    uint amountP;\\r\\n    /// @notice Amount to forwarder + amount to compound\\r\\n    uint amountFC;\\r\\n    address rewardToken;\\r\\n    uint len;\\r\\n    uint receivedAmountOut;\\r\\n  }\\r\\n\\r\\n  struct OpenPositionLocal {\\r\\n    uint entryKind;\\r\\n    address[] converters;\\r\\n    uint[] collateralsRequired;\\r\\n    uint[] amountsToBorrow;\\r\\n    uint collateral;\\r\\n    uint amountToBorrow;\\r\\n  }\\r\\n\\r\\n  struct OpenPositionEntryKind1Local {\\r\\n    address[] converters;\\r\\n    uint[] collateralsRequired;\\r\\n    uint[] amountsToBorrow;\\r\\n    uint collateral;\\r\\n    uint amountToBorrow;\\r\\n    uint c1;\\r\\n    uint c3;\\r\\n    uint alpha;\\r\\n  }\\r\\n\\r\\n  struct SwapToGetAmountLocal {\\r\\n    uint len;\\r\\n    uint[] prices;\\r\\n    uint[] decs;\\r\\n  }\\r\\n\\r\\n  struct ConvertAfterWithdrawLocal {\\r\\n    address asset;\\r\\n    uint spent;\\r\\n    uint received;\\r\\n    uint balance;\\r\\n    uint balanceBefore;\\r\\n    uint len;\\r\\n  }\\r\\n\\r\\n  struct SwapToGivenAmountInputParams {\\r\\n    ITetuConverter converter;\\r\\n    ITetuLiquidator liquidator;\\r\\n    uint targetAmount;\\r\\n    address[] tokens;\\r\\n    uint[] amounts;\\r\\n    /// @notice liquidationThresholds for the {tokens}\\r\\n    uint[] liquidationThresholds;\\r\\n    uint indexTargetAsset;\\r\\n    address underlying;\\r\\n    /// @notice Allow to swap more then required (i.e. 1_000 => +1%)\\r\\n    ///         to avoid additional swap if the swap return amount a bit less than we expected\\r\\n    uint overswap;\\r\\n  }\\r\\n\\r\\n  struct SwapToGivenAmountLocal {\\r\\n    uint len;\\r\\n    uint[] availableAmounts;\\r\\n    uint i;\\r\\n  }\\r\\n\\r\\n  struct CloseDebtsForRequiredAmountLocal {\\r\\n    address asset;\\r\\n    uint balanceAsset;\\r\\n    uint balanceToken;\\r\\n\\r\\n    uint newBalanceAsset;\\r\\n    uint newBalanceToken;\\r\\n\\r\\n    uint idxToSwap1;\\r\\n    uint amountToSwap;\\r\\n    uint idxToRepay1;\\r\\n\\r\\n    /// @notice Cost of $1 in terms of the assets, decimals 18\\r\\n    uint[] prices;\\r\\n    /// @notice 10**decimal for the assets\\r\\n    uint[] decs;\\r\\n\\r\\n    /// @notice Amounts that will be received on balance before execution of the plan.\\r\\n    uint[] balanceAdditions;\\r\\n\\r\\n    /// @notice Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n    ///         The leftovers should be swapped to get following result proportions of the assets:\\r\\n    ///         not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\r\\n    uint propNotUnderlying18;\\r\\n\\r\\n    /// @notice proportions should be taken from the pool and re-read from the pool after each swap\\r\\n    bool usePoolProportions;\\r\\n\\r\\n    bool exitLoop;\\r\\n  }\\r\\n\\r\\n  struct DataSetLocal {\\r\\n    ITetuConverter converter;\\r\\n    ITetuLiquidator liquidator;\\r\\n    /// @notice Tokens received from {_depositorPoolAssets}\\r\\n    address[] tokens;\\r\\n    /// @notice Index of the main asset in {tokens}\\r\\n    uint indexAsset;\\r\\n    /// @notice Length of {tokens}\\r\\n    uint len;\\r\\n  }\\r\\n\\r\\n  struct RecycleLocal {\\r\\n    address asset;\\r\\n    uint compoundRatio;\\r\\n    uint performanceFee;\\r\\n    uint toPerf;\\r\\n    uint toInsurance;\\r\\n    uint[] amountsToForward;\\r\\n    uint[] thresholds;\\r\\n    int debtToInsuranceCurrent;\\r\\n    int debtToInsuranceUpdated;\\r\\n    address splitter;\\r\\n  }\\r\\n\\r\\n  /// @notice Input params for _recycle\\r\\n  struct RecycleParams {\\r\\n    ITetuConverter converter;\\r\\n    ITetuLiquidator liquidator;\\r\\n    address splitter;\\r\\n\\r\\n    /// @notice Underlying asset\\r\\n    address asset;\\r\\n    /// @notice Compound ration in the range [0...COMPOUND_DENOMINATOR]\\r\\n    uint compoundRatio;\\r\\n    /// @notice tokens received from {_depositorPoolAssets}\\r\\n    address[] tokens;\\r\\n    /// @notice Liquidation thresholds for rewards tokens\\r\\n    uint[] thresholds;\\r\\n    /// @notice Full list of reward tokens received from tetuConverter and depositor\\r\\n    address[] rewardTokens;\\r\\n    /// @notice Amounts of {rewardTokens_}; we assume, there are no zero amounts here\\r\\n    uint[] rewardAmounts;\\r\\n    /// @notice Performance fee in the range [0...FEE_DENOMINATOR]\\r\\n    uint performanceFee;\\r\\n    /// @notice Current debt to the insurance [in underlying]\\r\\n    int debtToInsurance;\\r\\n    /// @notice Liquidation threshold for the {asset}\\r\\n    uint assetThreshold;\\r\\n  }\\r\\n//endregion--------------------------------------------------- Data types\\r\\n\\r\\n//region--------------------------------------------------- Constants\\r\\n\\r\\n  /// @notice approx one month for average block time 2 sec\\r\\n  uint internal constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\\r\\n  uint internal constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\\r\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\r\\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\\r\\n  uint internal constant PRICE_IMPACT_TOLERANCE = 300;\\r\\n  /// @notice borrow/collateral amount cannot be less than given number of tokens\\r\\n  uint internal constant DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD = 10;\\r\\n  /// @notice Allow to swap more then required (i.e. 1_000 => +1%) inside {swapToGivenAmount}\\r\\n  ///         to avoid additional swap if the swap will return amount a bit less than we expected\\r\\n  uint internal constant OVERSWAP = PRICE_IMPACT_TOLERANCE + _ASSET_LIQUIDATION_SLIPPAGE;\\r\\n  /// @notice During SWAP-REPAY cycle we can receive requested amount after SWAP, so, following REPAY will be skipped.\\r\\n  ///         But we should prevent situation \\\"zero balance, not zero debts\\\".\\r\\n  ///         So, it worth to request amount higher (on the given gap) than it's really requested.\\r\\n  uint internal constant REQUESTED_BALANCE_GAP = 5_000; // 5%\\r\\n//endregion--------------------------------------------------- Constants\\r\\n\\r\\n//region--------------------------------------------------- Events\\r\\n  /// @notice A borrow was made\\r\\n  event OpenPosition(\\r\\n    address converter,\\r\\n    address collateralAsset,\\r\\n    uint collateralAmount,\\r\\n    address borrowAsset,\\r\\n    uint borrowedAmount,\\r\\n    address recepient\\r\\n  );\\r\\n\\r\\n  /// @notice Some borrow(s) was/were repaid\\r\\n  event ClosePosition(\\r\\n    address collateralAsset,\\r\\n    address borrowAsset,\\r\\n    uint amountRepay,\\r\\n    address recepient,\\r\\n    uint returnedAssetAmountOut,\\r\\n    uint returnedBorrowAmountOut\\r\\n  );\\r\\n\\r\\n  /// @notice A liquidation was made\\r\\n  event Liquidation(\\r\\n    address tokenIn,\\r\\n    address tokenOut,\\r\\n    uint amountIn,\\r\\n    uint spentAmountIn,\\r\\n    uint receivedAmountOut\\r\\n  );\\r\\n\\r\\n  event ReturnAssetToConverter(address asset, uint amount);\\r\\n\\r\\n  /// @notice Recycle was made\\r\\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\\r\\n  /// @param amountsToForward Amounts to be sent to forwarder\\r\\n  event Recycle(\\r\\n    address[] rewardTokens,\\r\\n    uint[] amountsToForward,\\r\\n    uint toPerf,\\r\\n    uint toInsurance\\r\\n  );\\r\\n\\r\\n  /// @notice Debt to insurance was paid by rewards\\r\\n  /// @param debtToInsuranceBefore Initial amount of debts to the insurance, in underlying\\r\\n  /// @param debtToInsuranceBefore Final amount of debts to the insurance, in underlying\\r\\n  event OnPayDebtToInsurance(\\r\\n    int debtToInsuranceBefore,\\r\\n    int debtToInsuraneAfter\\r\\n  );\\r\\n\\r\\n  /// @notice Debt to insurance was paid by a reward token\\r\\n  /// @param debtToCover Initial amount of debt that should be covered, in underlying\\r\\n  /// @param debtLeftovers Final amount of debt that should be covered, in underlying\\r\\n  /// It can be negative if we paid more than required\\r\\n  event OnCoverDebtToInsurance(\\r\\n    address rewardToken,\\r\\n    uint rewardAmount,\\r\\n    uint debtToCover,\\r\\n    int debtLeftovers\\r\\n  );\\r\\n//endregion---------------------------------------------------  Events\\r\\n\\r\\n//region--------------------------------------------------- Borrow and close positions\\r\\n\\r\\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\\r\\n  ///         Max possible collateral should be approved before calling of this function.\\r\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\r\\n  ///                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\r\\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\\r\\n  /// @param amountIn_ Meaning depends on {entryData_}.\\r\\n  function openPosition(\\r\\n    ITetuConverter tetuConverter_,\\r\\n    bytes memory entryData_,\\r\\n    address collateralAsset_,\\r\\n    address borrowAsset_,\\r\\n    uint amountIn_,\\r\\n    uint thresholdAmountIn_\\r\\n  ) external returns (\\r\\n    uint collateralAmountOut,\\r\\n    uint borrowedAmountOut\\r\\n  ) {\\r\\n    return _openPosition(tetuConverter_, entryData_, collateralAsset_, borrowAsset_, amountIn_, thresholdAmountIn_);\\r\\n  }\\r\\n\\r\\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\\r\\n  ///         Max possible collateral should be approved before calling of this function.\\r\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\r\\n  ///                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\r\\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\\r\\n  /// @param amountIn_ Meaning depends on {entryData_}.\\r\\n  /// @param thresholdAmountIn_ Min value of amountIn allowed for the second and subsequent conversions.\\r\\n  ///        0 - use default min value\\r\\n  ///        If amountIn becomes too low, no additional borrows are possible, so\\r\\n  ///        the rest amountIn is just added to collateral/borrow amount of previous conversion.\\r\\n  function _openPosition(\\r\\n    ITetuConverter tetuConverter_,\\r\\n    bytes memory entryData_,\\r\\n    address collateralAsset_,\\r\\n    address borrowAsset_,\\r\\n    uint amountIn_,\\r\\n    uint thresholdAmountIn_\\r\\n  ) internal returns (\\r\\n    uint collateralAmountOut,\\r\\n    uint borrowedAmountOut\\r\\n  ) {\\r\\n    if (thresholdAmountIn_ == 0) {\\r\\n      // zero threshold is not allowed because round-issues are possible, see openPosition.dust test\\r\\n      // we assume here, that it's useless to borrow amount using collateral/borrow amount\\r\\n      // less than given number of tokens (event for BTC)\\r\\n      thresholdAmountIn_ = DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD;\\r\\n    }\\r\\n    if (amountIn_ <= thresholdAmountIn_) {\\r\\n      return (0, 0);\\r\\n    }\\r\\n\\r\\n    OpenPositionLocal memory vars;\\r\\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\\r\\n    vars.entryKind = ConverterEntryKinds.getEntryKind(entryData_);\\r\\n    if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\\r\\n      return openPositionEntryKind1(\\r\\n        tetuConverter_,\\r\\n        entryData_,\\r\\n        collateralAsset_,\\r\\n        borrowAsset_,\\r\\n        amountIn_,\\r\\n        thresholdAmountIn_\\r\\n      );\\r\\n    } else {\\r\\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\\r\\n        entryData_,\\r\\n        collateralAsset_,\\r\\n        amountIn_,\\r\\n        borrowAsset_,\\r\\n        _LOAN_PERIOD_IN_BLOCKS\\r\\n      );\\r\\n\\r\\n      uint len = vars.converters.length;\\r\\n      if (len > 0) {\\r\\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\\r\\n          vars.collateral;\\r\\n          vars.amountToBorrow;\\r\\n          if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\\r\\n            // we have exact amount of total collateral amount\\r\\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\\r\\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\\r\\n              ? amountIn_\\r\\n              : vars.collateralsRequired[i];\\r\\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\\r\\n              ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\\r\\n              : vars.amountsToBorrow[i];\\r\\n            amountIn_ -= vars.collateral;\\r\\n          } else {\\r\\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\\r\\n            // we have exact amount of total amount-to-borrow\\r\\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\\r\\n              ? amountIn_\\r\\n              : vars.amountsToBorrow[i];\\r\\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\\r\\n              ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\\r\\n              : vars.collateralsRequired[i];\\r\\n            amountIn_ -= vars.amountToBorrow;\\r\\n          }\\r\\n\\r\\n          if (amountIn_ < thresholdAmountIn_ && amountIn_ != 0) {\\r\\n            // dust amount is left, just leave it unused\\r\\n            // we cannot add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\\r\\n            amountIn_ = 0;\\r\\n          }\\r\\n\\r\\n          if (vars.amountToBorrow != 0) {\\r\\n            borrowedAmountOut += tetuConverter_.borrow(\\r\\n              vars.converters[i],\\r\\n              collateralAsset_,\\r\\n              vars.collateral,\\r\\n              borrowAsset_,\\r\\n              vars.amountToBorrow,\\r\\n              address(this)\\r\\n            );\\r\\n            collateralAmountOut += vars.collateral;\\r\\n            emit OpenPosition(\\r\\n              vars.converters[i],\\r\\n              collateralAsset_,\\r\\n              vars.collateral,\\r\\n              borrowAsset_,\\r\\n              vars.amountToBorrow,\\r\\n              address(this)\\r\\n            );\\r\\n          }\\r\\n\\r\\n          if (amountIn_ == 0) break;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      return (collateralAmountOut, borrowedAmountOut);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Open position using entry kind 1 - split provided amount on two parts according provided proportions\\r\\n  /// @param amountIn_ Amount of collateral to be divided on parts. We assume {amountIn_} > 0\\r\\n  /// @param collateralThreshold_ Min allowed collateral amount to be used for new borrow, > 0\\r\\n  /// @return collateralAmountOut Total collateral used to borrow {borrowedAmountOut}\\r\\n  /// @return borrowedAmountOut Total borrowed amount\\r\\n  function openPositionEntryKind1(\\r\\n    ITetuConverter tetuConverter_,\\r\\n    bytes memory entryData_,\\r\\n    address collateralAsset_,\\r\\n    address borrowAsset_,\\r\\n    uint amountIn_,\\r\\n    uint collateralThreshold_\\r\\n  ) internal returns (\\r\\n    uint collateralAmountOut,\\r\\n    uint borrowedAmountOut\\r\\n  ) {\\r\\n    OpenPositionEntryKind1Local memory vars;\\r\\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\\r\\n      entryData_,\\r\\n      collateralAsset_,\\r\\n      amountIn_,\\r\\n      borrowAsset_,\\r\\n      _LOAN_PERIOD_IN_BLOCKS\\r\\n    );\\r\\n\\r\\n    uint len = vars.converters.length;\\r\\n    if (len > 0) {\\r\\n      // we should split amountIn on two amounts with proportions x:y\\r\\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\\r\\n      // calculate prices conversion ratio using price oracle, decimals 18\\r\\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\\r\\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\\r\\n\\r\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\\r\\n        // and give us required proportions in result\\r\\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\\r\\n        // C1 is collateral amount left untouched (x)\\r\\n        // C2 is collateral amount converted to B2 (y)\\r\\n        // but if lending platform doesn't have enough liquidity\\r\\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\\r\\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\\r\\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\\r\\n        vars.c1 = x * vars.c3 / y;\\r\\n\\r\\n        // we doesn't calculate an intermediate ratio cR/(cR+c1) to avoid lost of precision\\r\\n        if ((vars.collateralsRequired[i] + vars.c1) > amountIn_) {\\r\\n          vars.collateral = vars.collateralsRequired[i] * amountIn_ / (vars.collateralsRequired[i] + vars.c1);\\r\\n          vars.amountToBorrow = vars.amountsToBorrow[i] * amountIn_ / (vars.collateralsRequired[i] + vars.c1);\\r\\n        } else {\\r\\n          vars.collateral = vars.collateralsRequired[i];\\r\\n          vars.amountToBorrow = vars.amountsToBorrow[i];\\r\\n        }\\r\\n\\r\\n        // skip any attempts to borrow zero amount or use too little collateral\\r\\n        if (vars.collateral < collateralThreshold_ || vars.amountToBorrow == 0) {\\r\\n          if (vars.collateralsRequired[i] + vars.c1 + collateralThreshold_ > amountIn_) {\\r\\n            // The lending platform has enough resources to make the borrow but amount of the borrow is too low\\r\\n            // Skip the borrow, leave leftover of collateral untouched\\r\\n            break;\\r\\n          } else {\\r\\n            // The lending platform doesn't have enough resources to make the borrow.\\r\\n            // We should try to make borrow on the next platform (if any)\\r\\n            continue;\\r\\n          }\\r\\n        }\\r\\n\\r\\n        require(\\r\\n          tetuConverter_.borrow(\\r\\n            vars.converters[i],\\r\\n            collateralAsset_,\\r\\n            vars.collateral,\\r\\n            borrowAsset_,\\r\\n            vars.amountToBorrow,\\r\\n            address(this)\\r\\n          ) == vars.amountToBorrow,\\r\\n          StrategyLib2.WRONG_VALUE\\r\\n        );\\r\\n        emit OpenPosition(\\r\\n          vars.converters[i],\\r\\n          collateralAsset_,\\r\\n          vars.collateral,\\r\\n          borrowAsset_,\\r\\n          vars.amountToBorrow,\\r\\n          address(this)\\r\\n        );\\r\\n\\r\\n        borrowedAmountOut += vars.amountToBorrow;\\r\\n        collateralAmountOut += vars.collateral;\\r\\n\\r\\n        // calculate amount to be borrowed in the next converter\\r\\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\\r\\n        vars.c1 = x * vars.c3 / y;\\r\\n        amountIn_ = (amountIn_ > vars.c1 + vars.collateral)\\r\\n          ? amountIn_ - (vars.c1 + vars.collateral)\\r\\n          : 0;\\r\\n\\r\\n        // protection against dust amounts, see \\\"openPosition.dust\\\", just leave dust amount unused\\r\\n        // we CAN NOT add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\\r\\n        // we assume here, that collateralThreshold_ != 0, so check amountIn_ != 0 is not required\\r\\n        if (amountIn_ < collateralThreshold_) break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return (collateralAmountOut, borrowedAmountOut);\\r\\n  }\\r\\n\\r\\n  /// @notice Get ratio18 = collateral / borrow\\r\\n  function _getCollateralToBorrowRatio(\\r\\n    ITetuConverter converter_,\\r\\n    address collateralAsset_,\\r\\n    address borrowAsset_\\r\\n  ) internal view returns (uint){\\r\\n    IPriceOracle priceOracle = AppLib._getPriceOracle(converter_);\\r\\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\\r\\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\\r\\n    return 1e18 * priceBorrow * 10 ** IERC20Metadata(collateralAsset_).decimals()\\r\\n    / priceCollateral / 10 ** IERC20Metadata(borrowAsset_).decimals();\\r\\n  }\\r\\n\\r\\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\\r\\n  ///         It doesn't repay more than the actual amount of the debt, so it can use less amount than {amountToRepay}\\r\\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\\r\\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\\r\\n  /// @return repaidAmountOut Amount that was actually repaid\\r\\n  function _closePosition(\\r\\n    ITetuConverter converter_,\\r\\n    address collateralAsset,\\r\\n    address borrowAsset,\\r\\n    uint amountToRepay\\r\\n  ) internal returns (\\r\\n    uint returnedAssetAmountOut,\\r\\n    uint repaidAmountOut\\r\\n  ) {\\r\\n\\r\\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\\r\\n\\r\\n    // We shouldn't try to pay more than we actually need to repay\\r\\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\\r\\n    // Let's limit amountToRepay by needToRepay-amount\\r\\n    (uint needToRepay,) = converter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\\r\\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\\r\\n\\r\\n    return _closePositionExact(converter_, collateralAsset, borrowAsset, amountRepay, balanceBefore);\\r\\n  }\\r\\n\\r\\n  /// @notice Close the given position, pay {amountRepay} exactly and ensure that all amount was accepted,\\r\\n  /// @param amountRepay Amount to repay in terms of {borrowAsset}\\r\\n  /// @param balanceBorrowAsset Current balance of the borrow asset\\r\\n  /// @return collateralOut Amount of collateral received back after repaying\\r\\n  /// @return repaidAmountOut Amount that was actually repaid\\r\\n  function _closePositionExact(\\r\\n    ITetuConverter converter_,\\r\\n    address collateralAsset,\\r\\n    address borrowAsset,\\r\\n    uint amountRepay,\\r\\n    uint balanceBorrowAsset\\r\\n  ) internal returns (\\r\\n    uint collateralOut,\\r\\n    uint repaidAmountOut\\r\\n  ) {\\r\\n    if (amountRepay >= AppLib.DUST_AMOUNT_TOKENS) {\\r\\n      // Make full/partial repayment\\r\\n      IERC20(borrowAsset).safeTransfer(address(converter_), amountRepay);\\r\\n\\r\\n      uint notUsedAmount;\\r\\n      (collateralOut, notUsedAmount,,) = converter_.repay(collateralAsset, borrowAsset, amountRepay, address(this));\\r\\n\\r\\n      emit ClosePosition(collateralAsset, borrowAsset, amountRepay, address(this), collateralOut, notUsedAmount);\\r\\n      uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\\r\\n\\r\\n      // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (debt-gap)\\r\\n      repaidAmountOut = balanceBorrowAsset > balanceAfter\\r\\n        ? balanceBorrowAsset - balanceAfter\\r\\n        : 0;\\r\\n      require(notUsedAmount == 0, StrategyLib2.WRONG_VALUE);\\r\\n    }\\r\\n\\r\\n    return (collateralOut, repaidAmountOut);\\r\\n  }\\r\\n\\r\\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\\r\\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\\r\\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\\r\\n  /// @return repaidAmountOut Amount that was actually repaid\\r\\n  function closePosition(\\r\\n    ITetuConverter tetuConverter_,\\r\\n    address collateralAsset,\\r\\n    address borrowAsset,\\r\\n    uint amountToRepay\\r\\n  ) external returns (\\r\\n    uint returnedAssetAmountOut,\\r\\n    uint repaidAmountOut\\r\\n  ) {\\r\\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\\r\\n  }\\r\\n//endregion--------------------------------------------------- Borrow and close positions\\r\\n\\r\\n//region--------------------------------------------------- Liquidation\\r\\n\\r\\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\\r\\n  /// @param liquidationThresholdForTokenIn_ Liquidation threshold for {amountIn_}\\r\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\r\\n  /// @return spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\\r\\n  /// @return receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\\r\\n  function liquidate(\\r\\n    ITetuConverter converter,\\r\\n    ITetuLiquidator liquidator_,\\r\\n    address tokenIn_,\\r\\n    address tokenOut_,\\r\\n    uint amountIn_,\\r\\n    uint slippage_,\\r\\n    uint liquidationThresholdForTokenIn_,\\r\\n    bool skipValidation\\r\\n  ) external returns (\\r\\n    uint spentAmountIn,\\r\\n    uint receivedAmountOut\\r\\n  ) {\\r\\n    return _liquidate(converter, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdForTokenIn_, skipValidation);\\r\\n  }\\r\\n\\r\\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\\r\\n  /// @param liquidationThresholdForTokenIn_ Liquidation threshold for {amountIn_}\\r\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\r\\n  /// @return spentAmountIn Amount of {tokenIn} has been consumed by the liquidator (== 0 | amountIn_)\\r\\n  /// @return receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\\r\\n  function _liquidate(\\r\\n    ITetuConverter converter_,\\r\\n    ITetuLiquidator liquidator_,\\r\\n    address tokenIn_,\\r\\n    address tokenOut_,\\r\\n    uint amountIn_,\\r\\n    uint slippage_,\\r\\n    uint liquidationThresholdForTokenIn_,\\r\\n    bool skipValidation\\r\\n  ) internal returns (\\r\\n    uint spentAmountIn,\\r\\n    uint receivedAmountOut\\r\\n  ) {\\r\\n    // we check amountIn by threshold, not amountOut\\r\\n    // because {_closePositionsToGetAmount} is implemented in {get plan, make action}-way\\r\\n    // {_closePositionsToGetAmount} can be used with swap by aggregators, where amountOut cannot be calculate\\r\\n    // at the moment of plan building. So, for uniformity, only amountIn is checked everywhere\\r\\n\\r\\n    if (amountIn_ <= liquidationThresholdForTokenIn_) {\\r\\n      return (0, 0);\\r\\n    }\\r\\n\\r\\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\\r\\n\\r\\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\\r\\n\\r\\n    // if the expected value is higher than threshold distribute to destinations\\r\\n    return (amountIn_, _liquidateWithRoute(converter_, route, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, skipValidation));\\r\\n  }\\r\\n\\r\\n  /// @notice Make liquidation using given route and check correctness using TetuConverter's price oracle\\r\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\r\\n  function _liquidateWithRoute(\\r\\n    ITetuConverter converter_,\\r\\n    ITetuLiquidator.PoolData[] memory route,\\r\\n    ITetuLiquidator liquidator_,\\r\\n    address tokenIn_,\\r\\n    address tokenOut_,\\r\\n    uint amountIn_,\\r\\n    uint slippage_,\\r\\n    bool skipValidation\\r\\n  ) internal returns (\\r\\n    uint receivedAmountOut\\r\\n  ) {\\r\\n    // we need to approve each time, liquidator address can be changed in controller\\r\\n    AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\\r\\n\\r\\n    uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\\r\\n    liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\\r\\n    uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\\r\\n\\r\\n    require(balanceAfter > balanceBefore, AppErrors.BALANCE_DECREASE);\\r\\n    receivedAmountOut = balanceAfter - balanceBefore;\\r\\n\\r\\n    // Oracle in TetuConverter \\\"knows\\\" only limited number of the assets\\r\\n    // It may not know prices for reward assets, so for rewards this validation should be skipped to avoid TC-4 error\\r\\n    require(skipValidation || converter_.isConversionValid(tokenIn_, amountIn_, tokenOut_, receivedAmountOut, slippage_), AppErrors.PRICE_IMPACT);\\r\\n    emit Liquidation(tokenIn_, tokenOut_, amountIn_, amountIn_, receivedAmountOut);\\r\\n  }\\r\\n//endregion--------------------------------------------------- Liquidation\\r\\n\\r\\n//region--------------------------------------------------- Recycle rewards\\r\\n\\r\\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\\r\\n  /// We have two kinds of rewards:\\r\\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\\r\\n  /// 2) any other rewards\\r\\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\\r\\n  ///   Compound-part of Rewards-2 can be liquidated\\r\\n  ///   Compound part of Rewards-1 should be just left on the balance\\r\\n  ///   Performance amounts should be liquidate, result underlying should be sent to performance receiver and insurance.\\r\\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\\r\\n  /// @dev {_recycle} is implemented as separate (inline) function to simplify unit testing\\r\\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\\r\\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\\r\\n  /// @return paidDebtToInsurance Earned amount spent on debt-to-insurance payment\\r\\n  /// @return amountPerf Performance fee in terms of underlying\\r\\n  function recycle(\\r\\n    IStrategyV3.BaseState storage baseState,\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    address[] memory tokens,\\r\\n    address controller,\\r\\n    mapping(address => uint) storage liquidationThresholds,\\r\\n    address[] memory rewardTokens_,\\r\\n    uint[] memory rewardAmounts_\\r\\n  ) external returns (uint paidDebtToInsurance, uint amountPerf) {\\r\\n    RecycleLocal memory v;\\r\\n    v.asset = baseState.asset;\\r\\n    v.compoundRatio = baseState.compoundRatio;\\r\\n    v.performanceFee = baseState.performanceFee;\\r\\n    v.thresholds = _getLiquidationThresholds(liquidationThresholds, rewardTokens_, rewardTokens_.length);\\r\\n    v.debtToInsuranceCurrent = csbs.debtToInsurance;\\r\\n    v.splitter = baseState.splitter;\\r\\n\\r\\n    (v.amountsToForward, amountPerf, v.debtToInsuranceUpdated) = _recycle(RecycleParams({\\r\\n      converter: csbs.converter,\\r\\n      liquidator: AppLib._getLiquidator(controller),\\r\\n      asset: v.asset,\\r\\n      compoundRatio: v.compoundRatio,\\r\\n      tokens: tokens,\\r\\n      thresholds: v.thresholds,\\r\\n      rewardTokens: rewardTokens_,\\r\\n      rewardAmounts: rewardAmounts_,\\r\\n      performanceFee: v.performanceFee,\\r\\n      debtToInsurance: v.debtToInsuranceCurrent,\\r\\n      splitter: v.splitter,\\r\\n      assetThreshold: AppLib._getLiquidationThreshold(liquidationThresholds[v.asset])\\r\\n    }));\\r\\n\\r\\n    if (v.debtToInsuranceCurrent != v.debtToInsuranceUpdated) {\\r\\n      csbs.debtToInsurance = v.debtToInsuranceUpdated;\\r\\n      emit OnPayDebtToInsurance(v.debtToInsuranceCurrent, v.debtToInsuranceUpdated);\\r\\n      paidDebtToInsurance = v.debtToInsuranceCurrent - v.debtToInsuranceUpdated > 0\\r\\n        ? uint(v.debtToInsuranceCurrent - v.debtToInsuranceUpdated)\\r\\n        : 0;\\r\\n    }\\r\\n\\r\\n    // send performance-part of the underlying to the performance receiver and insurance\\r\\n    (v.toPerf, v.toInsurance) = _sendPerformanceFee(\\r\\n      v.asset,\\r\\n      amountPerf,\\r\\n      v.splitter,\\r\\n      baseState.performanceReceiver,\\r\\n      baseState.performanceFeeRatio\\r\\n    );\\r\\n\\r\\n    // override rewardTokens_, v.amountsToForward by the values actually sent to the forwarder\\r\\n    (rewardTokens_, v.amountsToForward) = _sendTokensToForwarder(controller, v.splitter, rewardTokens_, v.amountsToForward, v.thresholds);\\r\\n\\r\\n    emit Recycle(rewardTokens_, v.amountsToForward, v.toPerf, v.toInsurance);\\r\\n    return (paidDebtToInsurance, amountPerf);\\r\\n  }\\r\\n\\r\\n  /// @notice Send {amount_} of {asset_} to {receiver_} and insurance\\r\\n  /// @param asset_ Underlying asset\\r\\n  /// @param amount_ Amount of underlying asset to be sent to performance+insurance\\r\\n  /// @param receiver_ Performance receiver\\r\\n  /// @param ratio [0..100_000], 100_000 - send full amount to perf, 0 - send full amount to the insurance.\\r\\n  function _sendPerformanceFee(address asset_, uint amount_, address splitter, address receiver_, uint ratio) internal returns (\\r\\n    uint toPerf,\\r\\n    uint toInsurance\\r\\n  ) {\\r\\n    // read inside lib for reduce contract space in the main contract\\r\\n    address insurance = address(ITetuVaultV2(ISplitter(splitter).vault()).insurance());\\r\\n\\r\\n    toPerf = amount_ * ratio / AppLib.DENOMINATOR;\\r\\n    toInsurance = amount_ - toPerf;\\r\\n\\r\\n    if (toPerf != 0) {\\r\\n      IERC20(asset_).safeTransfer(receiver_, toPerf);\\r\\n    }\\r\\n    if (toInsurance != 0) {\\r\\n      IERC20(asset_).safeTransfer(insurance, toInsurance);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Send {amounts_} to forwarder, skip amounts < thresholds (see SCB-812)\\r\\n  /// @return tokensOut Tokens sent to the forwarder\\r\\n  /// @return amountsOut Amounts sent to the forwarder\\r\\n  function _sendTokensToForwarder(\\r\\n    address controller_,\\r\\n    address splitter_,\\r\\n    address[] memory tokens_,\\r\\n    uint[] memory amounts_,\\r\\n    uint[] memory thresholds_\\r\\n  ) internal returns (\\r\\n    address[] memory tokensOut,\\r\\n    uint[] memory amountsOut\\r\\n  ) {\\r\\n    uint len = tokens_.length;\\r\\n    IForwarder forwarder = IForwarder(IController(controller_).forwarder());\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (thresholds_[i] > amounts_[i]) {\\r\\n        amounts_[i] = 0; // it will be excluded in filterZeroAmounts() below\\r\\n      } else {\\r\\n        AppLib.approveIfNeeded(tokens_[i], amounts_[i], address(forwarder));\\r\\n      }\\r\\n    }\\r\\n\\r\\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokens_, amounts_);\\r\\n    if (tokensOut.length != 0) {\\r\\n      forwarder.registerIncome(tokensOut, amountsOut, ISplitter(splitter_).vault(), true);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Recycle the amounts: split each amount on tree parts: performance+insurance (P), forwarder (F), compound (C)\\r\\n  ///         Liquidate P+C, send F to the forwarder.\\r\\n  /// We have two kinds of rewards:\\r\\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\\r\\n  /// 2) any other rewards\\r\\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\\r\\n  ///   Compound-part of Rewards-2 can be liquidated\\r\\n  ///   Compound part of Rewards-1 should be just left on the balance\\r\\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\\r\\n  ///   Performance amounts are liquidated, result amount of underlying is returned in {amountToPerformanceAndInsurance}\\r\\n  /// @return amountsToForward Amounts of {rewardTokens} to be sent to forwarder, zero amounts are allowed here\\r\\n  /// @return amountToPerformanceAndInsurance Amount of underlying to be sent to performance receiver and insurance\\r\\n  /// @return debtToInsuranceOut Remain debt to the insurance [in underlying]\\r\\n  function _recycle(RecycleParams memory p) internal returns (\\r\\n    uint[] memory amountsToForward,\\r\\n    uint amountToPerformanceAndInsurance,\\r\\n    int debtToInsuranceOut\\r\\n  ) {\\r\\n    RecycleLocalParams memory v;\\r\\n\\r\\n    v.len = p.rewardTokens.length;\\r\\n    require(v.len == p.rewardAmounts.length, AppErrors.WRONG_LENGTHS);\\r\\n\\r\\n    amountsToForward = new uint[](v.len);\\r\\n\\r\\n    // rewardAmounts => P + F + C, where P - performance + insurance, F - forwarder, C - compound\\r\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\r\\n      // if we have a debt-to-insurance we should firstly cover the debt using all available rewards\\r\\n      // and only then we can use leftovers of the rewards for other needs\\r\\n      if (p.debtToInsurance > int(p.assetThreshold)) {\\r\\n        (p.rewardAmounts[i], p.debtToInsurance) = _coverDebtToInsuranceFromRewards(p, i, uint(p.debtToInsurance));\\r\\n        if (p.rewardAmounts[i] < p.thresholds[i]) continue;\\r\\n      }\\r\\n\\r\\n      v.amountFC = p.rewardAmounts[i] * (COMPOUND_DENOMINATOR - p.performanceFee) / COMPOUND_DENOMINATOR;\\r\\n      v.amountC = v.amountFC * p.compoundRatio / COMPOUND_DENOMINATOR;\\r\\n      v.amountP = p.rewardAmounts[i] - v.amountFC;\\r\\n      v.rewardToken = p.rewardTokens[i];\\r\\n      v.amountCP = v.amountC + v.amountP;\\r\\n\\r\\n      if (v.amountCP > 0) {\\r\\n        if (AppLib.getAssetIndex(p.tokens, v.rewardToken) != type(uint).max) {\\r\\n          if (v.rewardToken == p.asset) {\\r\\n            // This is underlying, liquidation of compound part is not allowed; just keep on the balance, should be handled later\\r\\n            amountToPerformanceAndInsurance += v.amountP;\\r\\n          } else {\\r\\n            // This is secondary asset, Liquidation of compound part is not allowed, we should liquidate performance part only\\r\\n            // If the performance amount is too small, liquidation will not happen and we will just keep that dust tokens on balance forever\\r\\n            (, v.receivedAmountOut) = _liquidate(\\r\\n              p.converter,\\r\\n              p.liquidator,\\r\\n              v.rewardToken,\\r\\n              p.asset,\\r\\n              v.amountP,\\r\\n              _REWARD_LIQUIDATION_SLIPPAGE,\\r\\n              p.thresholds[i],\\r\\n              false // use conversion validation for these rewards\\r\\n            );\\r\\n            amountToPerformanceAndInsurance += v.receivedAmountOut;\\r\\n          }\\r\\n        } else {\\r\\n          // If amount is too small, the liquidation won't be allowed and we will just keep that dust tokens on balance forever\\r\\n          // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\\r\\n          // We assume here, that {token} cannot be equal to {_asset}\\r\\n          // because the {_asset} is always included to the list of depositor's assets\\r\\n          (, v.receivedAmountOut) = _liquidate(\\r\\n            p.converter,\\r\\n            p.liquidator,\\r\\n            v.rewardToken,\\r\\n            p.asset,\\r\\n            v.amountCP,\\r\\n            _REWARD_LIQUIDATION_SLIPPAGE,\\r\\n            p.thresholds[i],\\r\\n            true // skip conversion validation for rewards because we can have arbitrary assets here\\r\\n          );\\r\\n          amountToPerformanceAndInsurance += v.receivedAmountOut * (p.rewardAmounts[i] - v.amountFC) / v.amountCP;\\r\\n        }\\r\\n      }\\r\\n      amountsToForward[i] = v.amountFC - v.amountC;\\r\\n    }\\r\\n\\r\\n    return (amountsToForward, amountToPerformanceAndInsurance, p.debtToInsurance);\\r\\n  }\\r\\n\\r\\n  /// @notice Try to cover {p.debtToInsurance} using available rewards of {p.rewardTokens[index]}\\r\\n  /// @param index Index of the reward token in {p.rewardTokens}\\r\\n  /// @param debtAmount Debt to insurance that should be covered by the reward tokens\\r\\n  /// @return rewardsLeftovers Amount of unused reward tokens (it can be used for other needs)\\r\\n  /// @return debtToInsuranceOut New value of the debt to the insurance\\r\\n  function _coverDebtToInsuranceFromRewards(RecycleParams memory p, uint index, uint debtAmount) internal returns (\\r\\n    uint rewardsLeftovers,\\r\\n    int debtToInsuranceOut\\r\\n  ) {\\r\\n    uint spentAmount;\\r\\n    uint amountToSend;\\r\\n\\r\\n    if (p.asset == p.rewardTokens[index]) {\\r\\n      // assume p.debtToInsurance > 0 here\\r\\n      spentAmount = Math.min(debtAmount, p.rewardAmounts[index]);\\r\\n      amountToSend = spentAmount;\\r\\n    } else {\\r\\n      // estimate amount of underlying that we can receive for the available amount of the reward tokens\\r\\n      uint amountAsset = p.rewardAmounts[index] > p.assetThreshold\\r\\n        ? p.liquidator.getPrice(p.rewardTokens[index], p.asset, p.rewardAmounts[index])\\r\\n        : 0;\\r\\n      uint amountIn;\\r\\n\\r\\n      if (amountAsset > debtAmount + p.assetThreshold) {\\r\\n        // pay a part of the rewards to cover the debt completely\\r\\n        amountIn = p.rewardAmounts[index] * debtAmount / amountAsset;\\r\\n      } else {\\r\\n        // pay all available rewards to cover a part of the debt\\r\\n        amountIn = p.rewardAmounts[index];\\r\\n      }\\r\\n\\r\\n      (spentAmount, amountToSend) = _liquidate(\\r\\n        p.converter,\\r\\n        p.liquidator,\\r\\n        p.rewardTokens[index],\\r\\n        p.asset,\\r\\n        amountIn,\\r\\n        _REWARD_LIQUIDATION_SLIPPAGE,\\r\\n        p.thresholds[index],\\r\\n        true // skip conversion validation for rewards because we can have arbitrary assets here\\r\\n      );\\r\\n    }\\r\\n\\r\\n    IERC20(p.asset).safeTransfer(address(ITetuVaultV2(ISplitter(p.splitter).vault()).insurance()), amountToSend);\\r\\n\\r\\n    rewardsLeftovers = AppLib.sub0(p.rewardAmounts[index], spentAmount);\\r\\n    debtToInsuranceOut = int(debtAmount) - int(amountToSend);\\r\\n\\r\\n    emit OnCoverDebtToInsurance(p.rewardTokens[index], spentAmount, debtAmount, debtToInsuranceOut);\\r\\n  }\\r\\n//endregion----------------------------------------------- Recycle rewards\\r\\n\\r\\n//region--------------------------------------------------- Before deposit\\r\\n  /// @notice Default implementation of ConverterStrategyBase.beforeDeposit\\r\\n  /// @param amount_ Amount of underlying to be deposited\\r\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\r\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\r\\n  /// @param weights_ Depositor pool weights\\r\\n  /// @param totalWeight_ Sum of {weights_}\\r\\n  function beforeDeposit(\\r\\n    ITetuConverter converter_,\\r\\n    uint amount_,\\r\\n    address[] memory tokens_,\\r\\n    uint indexAsset_,\\r\\n    uint[] memory weights_,\\r\\n    uint totalWeight_,\\r\\n    mapping(address => uint) storage liquidationThresholds\\r\\n  ) external returns (\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    // temporary save collateral to tokensAmounts\\r\\n    tokenAmounts = _getCollaterals(amount_, tokens_, weights_, totalWeight_, indexAsset_, AppLib._getPriceOracle(converter_));\\r\\n\\r\\n    // make borrow and save amounts of tokens available for deposit to tokenAmounts, zero result amounts are possible\\r\\n    tokenAmounts = _getTokenAmounts(\\r\\n      converter_,\\r\\n      tokens_,\\r\\n      indexAsset_,\\r\\n      tokenAmounts,\\r\\n      AppLib._getLiquidationThreshold(liquidationThresholds[tokens_[indexAsset_]])\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice For each {token_} calculate a part of {amount_} to be used as collateral according to the weights.\\r\\n  ///         I.e. we have 300 USDC, we need to split it on 100 USDC, 100 USDT, 100 DAI\\r\\n  ///         USDC is main asset, USDT and DAI should be borrowed. We check amounts of USDT and DAI on the balance\\r\\n  ///         and return collaterals reduced on that amounts. For main asset, we return full amount always (100 USDC).\\r\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\r\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\r\\n  /// @return tokenAmountsOut Length of the array is equal to the length of {tokens_}\\r\\n  function _getCollaterals(\\r\\n    uint amount_,\\r\\n    address[] memory tokens_,\\r\\n    uint[] memory weights_,\\r\\n    uint totalWeight_,\\r\\n    uint indexAsset_,\\r\\n    IPriceOracle priceOracle\\r\\n  ) internal view returns (\\r\\n    uint[] memory tokenAmountsOut\\r\\n  ) {\\r\\n    uint len = tokens_.length;\\r\\n    tokenAmountsOut = new uint[](len);\\r\\n\\r\\n    // get token prices and decimals\\r\\n    (uint[] memory prices, uint[] memory decs) = AppLib._getPricesAndDecs(priceOracle, tokens_, len);\\r\\n\\r\\n    // split the amount on tokens proportionally to the weights\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      uint amountAssetForToken = amount_ * weights_[i] / totalWeight_;\\r\\n\\r\\n      if (i == indexAsset_) {\\r\\n        tokenAmountsOut[i] = amountAssetForToken;\\r\\n      } else {\\r\\n        // if we have some tokens on balance then we need to use only a part of the collateral\\r\\n        uint tokenAmountToBeBorrowed = amountAssetForToken\\r\\n          * prices[indexAsset_]\\r\\n          * decs[i]\\r\\n          / prices[i]\\r\\n          / decs[indexAsset_];\\r\\n\\r\\n        uint tokenBalance = IERC20(tokens_[i]).balanceOf(address(this));\\r\\n        if (tokenBalance < tokenAmountToBeBorrowed) {\\r\\n          tokenAmountsOut[i] = amountAssetForToken * (tokenAmountToBeBorrowed - tokenBalance) / tokenAmountToBeBorrowed;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Make borrow and return amounts of {tokens} available to deposit\\r\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\r\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\r\\n  /// @param collaterals_ Amounts of main asset that can be used as collateral to borrow {tokens_}\\r\\n  /// @param thresholdAsset_ Value of liquidation threshold for the main (collateral) asset\\r\\n  /// @return tokenAmountsOut Amounts of {tokens}  available to deposit\\r\\n  function _getTokenAmounts(\\r\\n    ITetuConverter converter_,\\r\\n    address[] memory tokens_,\\r\\n    uint indexAsset_,\\r\\n    uint[] memory collaterals_,\\r\\n    uint thresholdAsset_\\r\\n  ) internal returns (\\r\\n    uint[] memory tokenAmountsOut\\r\\n  ) {\\r\\n    // content of tokenAmounts will be modified in place\\r\\n    uint len = tokens_.length;\\r\\n    tokenAmountsOut = new uint[](len);\\r\\n    address asset = tokens_[indexAsset_];\\r\\n\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (i != indexAsset_) {\\r\\n        address token = tokens_[i];\\r\\n        if (collaterals_[i] != 0) {\\r\\n          AppLib.approveIfNeeded(asset, collaterals_[i], address(converter_));\\r\\n          _openPosition(\\r\\n            converter_,\\r\\n            \\\"\\\", // entry kind = 0: fixed collateral amount, max possible borrow amount\\r\\n            asset,\\r\\n            token,\\r\\n            collaterals_[i],\\r\\n            thresholdAsset_\\r\\n          );\\r\\n\\r\\n          // zero borrowed amount is possible here (conversion is not available)\\r\\n          // if it's not suitable for depositor, the depositor should check zero amount in other places\\r\\n        }\\r\\n        tokenAmountsOut[i] = IERC20(token).balanceOf(address(this));\\r\\n      }\\r\\n    }\\r\\n\\r\\n    tokenAmountsOut[indexAsset_] = Math.min(\\r\\n      collaterals_[indexAsset_],\\r\\n      IERC20(asset).balanceOf(address(this))\\r\\n    );\\r\\n  }\\r\\n//endregion--------------------------------------------------- Before deposit\\r\\n\\r\\n//region--------------------------------------------------- Make requested amount\\r\\n\\r\\n  /// @notice Convert {amountsToConvert_} to the given {asset}\\r\\n  ///         Swap leftovers (if any) to the given asset.\\r\\n  ///         If result amount is less than expected, try to close any other available debts (1 repay per block only)\\r\\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\\r\\n  /// @param indexAsset_ Index of the given {asset} in {tokens}\\r\\n  /// @param requestedBalance Total amount of the given asset that we need to have on balance at the end.\\r\\n  ///                         Max uint means attempt to withdraw all possible amount.\\r\\n  /// @return expectedBalance Expected asset balance after all swaps and repays\\r\\n  function makeRequestedAmount(\\r\\n    address[] memory tokens_,\\r\\n    uint indexAsset_,\\r\\n    ITetuConverter converter_,\\r\\n    ITetuLiquidator liquidator_,\\r\\n    uint requestedBalance,\\r\\n    mapping(address => uint) storage liquidationThresholds_\\r\\n  ) external returns (uint expectedBalance) {\\r\\n    DataSetLocal memory v = DataSetLocal({\\r\\n      len: tokens_.length,\\r\\n      converter: converter_,\\r\\n      tokens: tokens_,\\r\\n      indexAsset: indexAsset_,\\r\\n      liquidator: liquidator_\\r\\n    });\\r\\n    uint[] memory _liquidationThresholds = _getLiquidationThresholds(liquidationThresholds_, v.tokens, v.len);\\r\\n    expectedBalance = _closePositionsToGetAmount(v, _liquidationThresholds, requestedBalance);\\r\\n  }\\r\\n  //endregion-------------------------------------------- Make requested amount\\r\\n\\r\\n//region ------------------------------------------------ Close position\\r\\n  /// @notice Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\\r\\n  /// @dev We assume here that this function is called before closing any positions in the current block\\r\\n  /// @param liquidationThresholds Min allowed amounts-out for liquidations\\r\\n  /// @param requestedBalance Total amount of the given asset that we need to have on balance at the end.\\r\\n  ///                         Max uint means attempt to withdraw all possible amount.\\r\\n  /// @return expectedBalance Expected asset balance after all swaps and repays\\r\\n  function closePositionsToGetAmount(\\r\\n    ITetuConverter converter_,\\r\\n    ITetuLiquidator liquidator,\\r\\n    uint indexAsset,\\r\\n    mapping(address => uint) storage liquidationThresholds,\\r\\n    uint requestedBalance,\\r\\n    address[] memory tokens\\r\\n  ) external returns (\\r\\n    uint expectedBalance\\r\\n  ) {\\r\\n    uint len = tokens.length;\\r\\n    return _closePositionsToGetAmount(\\r\\n      DataSetLocal({\\r\\n        len: len,\\r\\n        converter: converter_,\\r\\n        tokens: tokens,\\r\\n        indexAsset: indexAsset,\\r\\n        liquidator: liquidator\\r\\n      }),\\r\\n      _getLiquidationThresholds(liquidationThresholds, tokens, len),\\r\\n      requestedBalance\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\\r\\n  /// @dev Implements {IterationPlanLib.PLAN_SWAP_REPAY} only\\r\\n  ///      Note: AAVE3 allows to make two repays in a single block, see Aave3SingleBlockTest in TetuConverter\\r\\n  ///      but it doesn't allow to make borrow and repay in a single block.\\r\\n  /// @param liquidationThresholds_ Min allowed amounts-out for liquidations\\r\\n  /// @param requestedBalance Total amount of the given asset that we need to have on balance at the end.\\r\\n  ///                         Max uint means attempt to withdraw all possible amount.\\r\\n  /// @return expectedBalance Expected asset balance after all swaps and repays\\r\\n  function _closePositionsToGetAmount(\\r\\n    DataSetLocal memory d_,\\r\\n    uint[] memory liquidationThresholds_,\\r\\n    uint requestedBalance\\r\\n  ) internal returns (\\r\\n    uint expectedBalance\\r\\n  ) {\\r\\n    if (requestedBalance != 0) {\\r\\n      //let's get a bit more amount on balance to prevent situation \\\"zero balance, not-zero debts\\\"\\r\\n      requestedBalance = applyRequestedBalanceGap(requestedBalance);\\r\\n      CloseDebtsForRequiredAmountLocal memory v;\\r\\n      v.asset = d_.tokens[d_.indexAsset];\\r\\n\\r\\n      // v.planKind = IterationPlanLib.PLAN_SWAP_REPAY; // PLAN_SWAP_REPAY == 0, so we don't need this line\\r\\n      v.balanceAdditions = new uint[](d_.len);\\r\\n      expectedBalance = IERC20(v.asset).balanceOf(address(this));\\r\\n\\r\\n      (v.prices, v.decs) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(d_.converter), d_.tokens, d_.len);\\r\\n\\r\\n      for (uint i; i < d_.len; i = AppLib.uncheckedInc(i)) {\\r\\n        if (i == d_.indexAsset) continue;\\r\\n\\r\\n        v.balanceAsset = IERC20(v.asset).balanceOf(address(this));\\r\\n        v.balanceToken = IERC20(d_.tokens[i]).balanceOf(address(this));\\r\\n\\r\\n        // Make one or several iterations. Do single swap and single repaying (both are optional) on each iteration.\\r\\n        // Calculate expectedAmount of received underlying. Swap leftovers at the end even if requestedAmount is 0 at that moment.\\r\\n        do {\\r\\n          // generate iteration plan: [swap], [repay]\\r\\n          (v.idxToSwap1, v.amountToSwap, v.idxToRepay1) = IterationPlanLib.buildIterationPlan(\\r\\n            [address(d_.converter), address(d_.liquidator)],\\r\\n            d_.tokens,\\r\\n            liquidationThresholds_,\\r\\n            v.prices,\\r\\n            v.decs,\\r\\n            v.balanceAdditions,\\r\\n            [0, IterationPlanLib.PLAN_SWAP_REPAY, 0, requestedBalance, d_.indexAsset, i, 0]\\r\\n          );\\r\\n          if (v.idxToSwap1 == 0 && v.idxToRepay1 == 0) break;\\r\\n\\r\\n          // make swap if necessary\\r\\n          uint spentAmountIn;\\r\\n          if (v.idxToSwap1 != 0) {\\r\\n            uint indexIn = v.idxToSwap1 - 1;\\r\\n            uint indexOut = indexIn == d_.indexAsset ? i : d_.indexAsset;\\r\\n            (spentAmountIn,) = _liquidate(\\r\\n              d_.converter,\\r\\n              d_.liquidator,\\r\\n              d_.tokens[indexIn],\\r\\n              d_.tokens[indexOut],\\r\\n              v.amountToSwap,\\r\\n              _ASSET_LIQUIDATION_SLIPPAGE,\\r\\n              liquidationThresholds_[indexIn],\\r\\n              false\\r\\n            );\\r\\n\\r\\n            if (indexIn == d_.indexAsset) {\\r\\n              expectedBalance = AppLib.sub0(expectedBalance, spentAmountIn);\\r\\n            } else if (indexOut == d_.indexAsset) {\\r\\n              expectedBalance += spentAmountIn * v.prices[i] * v.decs[d_.indexAsset] / v.prices[d_.indexAsset] / v.decs[i];\\r\\n\\r\\n              // if we already received enough amount on balance, we can avoid additional actions\\r\\n              // to avoid high gas consumption in the cases like SCB-787\\r\\n              uint balanceAsset = IERC20(v.asset).balanceOf(address(this));\\r\\n              if (balanceAsset + liquidationThresholds_[d_.indexAsset] > requestedBalance) {\\r\\n                v.balanceAsset = balanceAsset;\\r\\n                break;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n\\r\\n          // repay a debt if necessary\\r\\n          if (v.idxToRepay1 != 0) {\\r\\n            uint indexBorrow = v.idxToRepay1 - 1;\\r\\n            uint indexCollateral = indexBorrow == d_.indexAsset ? i : d_.indexAsset;\\r\\n            uint amountToRepay = IERC20(d_.tokens[indexBorrow]).balanceOf(address(this));\\r\\n\\r\\n            (uint expectedAmountOut, uint repaidAmountOut, uint amountSendToRepay) = _repayDebt(\\r\\n              d_.converter,\\r\\n              d_.tokens[indexCollateral],\\r\\n              d_.tokens[indexBorrow],\\r\\n              amountToRepay\\r\\n            );\\r\\n\\r\\n            if (indexBorrow == d_.indexAsset) {\\r\\n              expectedBalance = expectedBalance > amountSendToRepay\\r\\n                ? expectedBalance - amountSendToRepay\\r\\n                : 0;\\r\\n            } else if (indexCollateral == d_.indexAsset) {\\r\\n              require(expectedAmountOut >= spentAmountIn, AppErrors.BALANCE_DECREASE);\\r\\n              if (repaidAmountOut < amountSendToRepay) {\\r\\n                // SCB-779: expectedAmountOut was estimated for amountToRepay, but we have paid repaidAmountOut only\\r\\n                expectedBalance += expectedAmountOut * repaidAmountOut / amountSendToRepay;\\r\\n              } else {\\r\\n                expectedBalance += expectedAmountOut;\\r\\n              }\\r\\n            }\\r\\n          }\\r\\n\\r\\n          // update balances\\r\\n          v.newBalanceAsset = IERC20(v.asset).balanceOf(address(this));\\r\\n          v.newBalanceToken = IERC20(d_.tokens[i]).balanceOf(address(this));\\r\\n\\r\\n          v.exitLoop = (v.balanceAsset == v.newBalanceAsset && v.balanceToken == v.newBalanceToken);\\r\\n          v.balanceAsset = v.newBalanceAsset;\\r\\n          v.balanceToken = v.newBalanceToken;\\r\\n        } while (!v.exitLoop);\\r\\n\\r\\n        if (v.balanceAsset + liquidationThresholds_[d_.indexAsset] > requestedBalance) break;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return expectedBalance;\\r\\n  }\\r\\n//endregion ------------------------------------------------ Close position\\r\\n\\r\\n//region ------------------------------------------------ Repay debts\\r\\n  /// @notice Repay {amountIn} and get collateral in return, calculate expected amount\\r\\n  ///         Take into account possible debt-gap and the fact that the amount of debt may be less than {amountIn}\\r\\n  /// @param amountToRepay Max available amount of borrow asset that we can repay\\r\\n  /// @return expectedAmountOut Estimated amount of main asset that should be added to balance = collateral - {toSell}\\r\\n  /// @return repaidAmountOut Actually paid amount\\r\\n  /// @return amountSendToRepay Amount send to repay\\r\\n  function _repayDebt(\\r\\n    ITetuConverter converter,\\r\\n    address collateralAsset,\\r\\n    address borrowAsset,\\r\\n    uint amountToRepay\\r\\n  ) internal returns (\\r\\n    uint expectedAmountOut,\\r\\n    uint repaidAmountOut,\\r\\n    uint amountSendToRepay\\r\\n  ) {\\r\\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\\r\\n\\r\\n    // get amount of debt with debt-gap\\r\\n    (uint needToRepay,) = converter.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\\r\\n    amountSendToRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\\r\\n\\r\\n    // get expected amount without debt-gap\\r\\n    uint swappedAmountOut;\\r\\n    (expectedAmountOut, swappedAmountOut) = converter.quoteRepay(address(this), collateralAsset, borrowAsset, amountSendToRepay);\\r\\n\\r\\n    if (expectedAmountOut > swappedAmountOut) {\\r\\n      // SCB-789 Following situation is possible\\r\\n      //    needToRepay = 100, needToRepayExact = 90 (debt gap is 10)\\r\\n      //    1) amountRepay = 80\\r\\n      //       expectedAmountOut is calculated for 80, no problems\\r\\n      //    2) amountRepay = 99,\\r\\n      //       expectedAmountOut is calculated for 90 + 9 (90 - repay, 9 - direct swap)\\r\\n      //       expectedAmountOut must be reduced on 9 here (!)\\r\\n      expectedAmountOut -= swappedAmountOut;\\r\\n    }\\r\\n\\r\\n    // close the debt\\r\\n    (, repaidAmountOut) = _closePositionExact(converter, collateralAsset, borrowAsset, amountSendToRepay, balanceBefore);\\r\\n\\r\\n    return (expectedAmountOut, repaidAmountOut, amountSendToRepay);\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Repay debts\\r\\n\\r\\n//region------------------------------------------------ Other helpers\\r\\n\\r\\n  /// @return liquidationThresholdsOut Liquidation thresholds of the {tokens_}, result values > 0\\r\\n  function _getLiquidationThresholds(\\r\\n    mapping(address => uint) storage liquidationThresholds,\\r\\n    address[] memory tokens_,\\r\\n    uint len\\r\\n  ) internal view returns (\\r\\n    uint[] memory liquidationThresholdsOut\\r\\n  ) {\\r\\n    liquidationThresholdsOut = new uint[](len);\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      liquidationThresholdsOut[i] = AppLib._getLiquidationThreshold(liquidationThresholds[tokens_[i]]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function applyRequestedBalanceGap(uint amount_) internal pure returns (uint) {\\r\\n    return amount_ == type(uint).max\\r\\n      ? amount_\\r\\n      : amount_ * (COMPOUND_DENOMINATOR + REQUESTED_BALANCE_GAP) / COMPOUND_DENOMINATOR;\\r\\n  }\\r\\n//endregion--------------------------------------------- Other helpers\\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0x8dd1596a48aeabdaef121d613050c7731576aece3782a3c3042b33be3be7a13e\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/ConverterStrategyBaseLib2.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV3.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IBookkeeper.sol\\\";\\r\\nimport \\\"../libs/AppErrors.sol\\\";\\r\\nimport \\\"../libs/AppLib.sol\\\";\\r\\nimport \\\"../libs/TokenAmountsLib.sol\\\";\\r\\nimport \\\"../libs/ConverterEntryKinds.sol\\\";\\r\\nimport \\\"../interfaces/IConverterStrategyBase.sol\\\";\\r\\n\\r\\n/// @notice Continuation of ConverterStrategyBaseLib (workaround for size limits)\\r\\nlibrary ConverterStrategyBaseLib2 {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n//region --------------------------------------- Data types\\r\\n  struct CalcInvestedAssetsLocal {\\r\\n    uint len;\\r\\n    uint[] debts;\\r\\n    address asset;\\r\\n    address token;\\r\\n  }\\r\\n//endregion --------------------------------------- Data types\\r\\n\\r\\n//region --------------------------------------- CONSTANTS\\r\\n  uint internal constant DENOMINATOR = 100_000;\\r\\n\\r\\n  /// @dev 0.5% of max loss for strategy TVL\\r\\n  /// @notice Same value as StrategySplitterV2.HARDWORK_LOSS_TOLERANCE\\r\\n  uint public constant HARDWORK_LOSS_TOLERANCE = 500;\\r\\n\\r\\n  /// @dev 0.5% of max profit for strategy TVL\\r\\n  /// @notice Limit max amount of profit that can be send to insurance after price changing\\r\\n  uint public constant PRICE_CHANGE_PROFIT_TOLERANCE = HARDWORK_LOSS_TOLERANCE;\\r\\n\\r\\n//endregion --------------------------------------- CONSTANTS\\r\\n\\r\\n//region----------------------------------------- EVENTS\\r\\n  event LiquidationThresholdChanged(address token, uint amount);\\r\\n  event ReinvestThresholdPercentChanged(uint amount);\\r\\n  event SendToInsurance(uint sentAmount, uint unsentAmount);\\r\\n\\r\\n  /// @notice Increase to debts between new and previous checkpoints.\\r\\n  /// @param tokens List of possible collateral/borrow assets. One of the is underlying.\\r\\n  /// @param deltaGains Amounts by which the debt has reduced (supply profit) [sync with {tokens}]\\r\\n  /// @param deltaLosses Amounts by which the debt has increased (increase of amount-to-pay) [sync with {tokens}]\\r\\n  /// @param prices Prices of the {tokens}\\r\\n  /// @param increaseToDebt Total amount of increasing of the debt to the insurance in underlying\\r\\n  event OnIncreaseDebtToInsurance(\\r\\n    address[] tokens,\\r\\n    uint[] deltaGains,\\r\\n    uint[] deltaLosses,\\r\\n    uint[] prices,\\r\\n    int increaseToDebt\\r\\n  );\\r\\n\\r\\n  /// @param debtToInsuranceBefore Value of the debt to insurance before fix price change\\r\\n  /// @param debtToInsuranceAfter New value of the debt to insurance\\r\\n  /// @param increaseToDebt Amount on which debt to insurance was increased.\\r\\n  /// Actual value {debtToInsuranceAfter}-{debtToInsuranceBefore} can be less than increaseToDebt\\r\\n  /// because some amount can be left uncovered.\\r\\n  event FixPriceChanges(\\r\\n    uint investedAssetsBefore,\\r\\n    uint investedAssetsOut,\\r\\n    int debtToInsuranceBefore,\\r\\n    int debtToInsuranceAfter,\\r\\n    int increaseToDebt\\r\\n  );\\r\\n\\r\\n  /// @param lossToCover Amount of loss that should be covered (it fits to allowed limits, no revert)\\r\\n  /// @param debtToInsuranceInc The amount by which the debt to insurance increases\\r\\n  /// @param amountCovered Actually covered amount of loss. If amountCovered < lossToCover => the insurance is not enough\\r\\n  /// @param lossUncovered Amount of uncovered losses (not enough insurance)\\r\\n  event OnCoverLoss(\\r\\n    uint lossToCover,\\r\\n    int debtToInsuranceInc,\\r\\n    uint amountCovered,\\r\\n    uint lossUncovered\\r\\n  );\\r\\n\\r\\n  /// @notice Value of {debtToInsurance} was increased on {increaseToDebt} inside fix-price-change\\r\\n  /// in the case when invested-asset amounts were increased.\\r\\n  /// @dev See comments in {_coverLossAfterPriceChanging}: actual profit-to-cover amount can be less than {increaseToDebt}\\r\\n  /// @param debtToInsuranceBefore Value of debtToInsurance before fix-price-change\\r\\n  /// @param increaseToDebt Value on which {debtToInsuranceBefore} was incremented\\r\\n  event ChangeDebtToInsuranceOnProfit(\\r\\n    int debtToInsuranceBefore,\\r\\n    int increaseToDebt\\r\\n  );\\r\\n\\r\\n  /// @notice Amount {lossCovered}+{lossUncovered} should be covered, but it's too high and will produce revert\\r\\n  /// on the splitter side. So, only {lossCovered} can be covered, {lossUncovered} are not covered\\r\\n  event UncoveredLoss(uint lossCovered, uint lossUncovered, uint investedAssetsBefore, uint investedAssetsAfter);\\r\\n\\r\\n  /// @notice Register amounts received for supplying collaterals and amount paid for the debts\\r\\n  /// @param gains Amount received by all pool adapters for the provided collateral, in underlying\\r\\n  /// @param losses Amount paid by all pool adapters for the debts, in underlying\\r\\n  event BorrowResults(uint gains, uint losses);\\r\\n\\r\\n  /// @notice An amount (earned - earnedByPrice) is earned on withdraw and sent to the insurance\\r\\n  /// @dev We assume that earned > earnedByPrice, but it's better to save raw values\\r\\n  event OnEarningOnWithdraw(uint earned, uint earnedByPrice);\\r\\n\\r\\n//endregion----------------------------------------- EVENTS\\r\\n\\r\\n//region----------------------------------------- MAIN LOGIC\\r\\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\\r\\n  function getAvailableBalances(\\r\\n    address[] memory tokens_,\\r\\n    uint indexAsset\\r\\n  ) external view returns (uint[] memory) {\\r\\n    uint len = tokens_.length;\\r\\n    uint[] memory amountsToConvert = new uint[](len);\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (i == indexAsset) continue;\\r\\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this));\\r\\n    }\\r\\n    return amountsToConvert;\\r\\n  }\\r\\n\\r\\n\\r\\n  /// @notice Calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\\r\\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\\r\\n  ///         User needs to withdraw {targetAmount_} in some asset.\\r\\n  ///         There are three kinds of available liquidity:\\r\\n  ///         1) liquidity in the pool - {depositorLiquidity_}\\r\\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\\r\\n  ///         3) Liquidity locked in the debts.\\r\\n  /// @param targetAmount Required amount of main asset to be withdrawn from the strategy; type(uint).max - withdraw all\\r\\n  /// @param quoteAmounts Results of _depositorQuoteExit(depositorLiquidity)\\r\\n  /// @return resultAmount Amount of liquidity that should be withdrawn from the pool, cannot exceed depositorLiquidity\\r\\n  function getLiquidityAmount(\\r\\n    uint targetAmount,\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset,\\r\\n    ITetuConverter converter,\\r\\n    uint[] memory quoteAmounts,\\r\\n    uint depositorLiquidity,\\r\\n    uint indexUnderlying\\r\\n  ) external view returns (\\r\\n    uint resultAmount\\r\\n  ) {\\r\\n    // total amount of assetsInPool recalculated to the underlying\\r\\n    // we need to calculate this value in the case of partial withdraw only\\r\\n    // so we assume below that it is equal to 0 if full withdraw is required\\r\\n    uint totalUnderlying;\\r\\n\\r\\n    if (targetAmount != type(uint).max) {\\r\\n      // reduce targetAmount_ on the amounts of not-underlying assets available on the balance\\r\\n      uint len = tokens.length;\\r\\n      (uint[] memory prices, uint[] memory decs) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(converter), tokens, len);\\r\\n\\r\\n      // calculate total amount of assets invested to the pool\\r\\n      for (uint i; i < tokens.length; i = AppLib.uncheckedInc(i)) {\\r\\n        totalUnderlying += (indexAsset == i)\\r\\n          ? quoteAmounts[i]\\r\\n          : quoteAmounts[i] * prices[i] * decs[indexUnderlying] / prices[indexUnderlying] / decs[i];\\r\\n      }\\r\\n\\r\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n        // assume here that the targetAmount_ is already reduced on available balance of the target asset\\r\\n        if (indexAsset == i) continue;\\r\\n\\r\\n        uint tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\\r\\n        if (tokenBalance != 0) {\\r\\n          uint tokenBalanceInAsset = tokenBalance * prices[i] * decs[indexAsset] / prices[indexAsset] / decs[i];\\r\\n\\r\\n          targetAmount = targetAmount > tokenBalanceInAsset\\r\\n            ? targetAmount - tokenBalanceInAsset\\r\\n            : 0;\\r\\n\\r\\n          uint tokenBalanceInUnderlying = indexUnderlying == indexAsset\\r\\n            ? tokenBalanceInAsset\\r\\n            : tokenBalance * prices[i] * decs[indexUnderlying] / prices[indexUnderlying] / decs[i];\\r\\n\\r\\n          totalUnderlying = totalUnderlying > tokenBalanceInUnderlying\\r\\n            ? totalUnderlying - tokenBalanceInUnderlying\\r\\n            : 0;\\r\\n        }\\r\\n      }\\r\\n\\r\\n      if (indexAsset != indexUnderlying) {\\r\\n        // convert targetAmount_ to underlying\\r\\n        targetAmount =  targetAmount * prices[indexAsset] * decs[indexUnderlying] / prices[indexUnderlying] / decs[indexAsset];\\r\\n      }\\r\\n    }\\r\\n\\r\\n    uint liquidityRatioOut = totalUnderlying == 0\\r\\n      ? 1e18\\r\\n      : ((targetAmount == 0)\\r\\n        ? 0\\r\\n        : 1e18 * 101 * targetAmount / totalUnderlying / 100 // a part of amount that we are going to withdraw + 1% on top\\r\\n      );\\r\\n\\r\\n    resultAmount = liquidityRatioOut == 0\\r\\n      ? 0\\r\\n      : Math.min(liquidityRatioOut * depositorLiquidity / 1e18, depositorLiquidity);\\r\\n  }\\r\\n\\r\\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\\r\\n  /// @dev The post-processing is rewards conversion to the main asset\\r\\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\\r\\n  /// @param rewardTokens_ List of rewards claimed from the internal pool\\r\\n  /// @param rewardTokens_ Amounts of rewards claimed from the internal pool\\r\\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\\r\\n  /// @param amountsOut Amounts of available rewards\\r\\n  function claimConverterRewards(\\r\\n    ITetuConverter converter_,\\r\\n    address[] memory tokens_,\\r\\n    address[] memory rewardTokens_,\\r\\n    uint[] memory rewardAmounts_,\\r\\n    uint[] memory balancesBefore\\r\\n  ) external returns (\\r\\n    address[] memory tokensOut,\\r\\n    uint[] memory amountsOut\\r\\n  ) {\\r\\n    // Rewards from TetuConverter\\r\\n    (address[] memory tokensTC, uint[] memory amountsTC) = converter_.claimRewards(address(this));\\r\\n\\r\\n    // Join arrays and recycle tokens\\r\\n    (tokensOut, amountsOut) = TokenAmountsLib.combineArrays(\\r\\n      rewardTokens_, rewardAmounts_,\\r\\n      tokensTC, amountsTC,\\r\\n      // by default, depositor assets have zero amounts here\\r\\n      tokens_, new uint[](tokens_.length)\\r\\n    );\\r\\n\\r\\n    // set fresh balances for depositor tokens\\r\\n    uint len = tokensOut.length;\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      for (uint j; j < tokens_.length; j = AppLib.uncheckedInc(j)) {\\r\\n        if (tokensOut[i] == tokens_[j]) {\\r\\n          amountsOut[i] = IERC20(tokens_[j]).balanceOf(address(this)) - balancesBefore[j];\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // filter zero amounts out\\r\\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\\r\\n  }\\r\\n\\r\\n  /// @notice Get price of {tokenB} in term of {tokenA} with 18 decimals\\r\\n  function getOracleAssetsPrice(ITetuConverter converter, address tokenA, address tokenB) external view returns (\\r\\n    uint price\\r\\n  ) {\\r\\n    IPriceOracle oracle = AppLib._getPriceOracle(converter);\\r\\n    uint priceA = oracle.getAssetPrice(tokenA);\\r\\n    uint priceB = oracle.getAssetPrice(tokenB);\\r\\n    price = priceA > 0 ? 1e18 * priceB / priceA : type(uint).max;\\r\\n  }\\r\\n\\r\\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\\r\\n    return AppLib._getPriceOracle(converter).getAssetPrice(token);\\r\\n  }\\r\\n\\r\\n  /// @notice Try to find zero amount\\r\\n  /// @return True if {amounts_} array contains zero amount\\r\\n  function findZeroAmount(uint[] memory amounts_) internal pure returns (bool) {\\r\\n    uint len = amounts_.length;\\r\\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (amounts_[i] == 0) return true;\\r\\n    }\\r\\n    return false;\\r\\n  }\\r\\n//endregion ----------------------------------------- MAIN LOGIC\\r\\n\\r\\n//region -------------------------------------------- Cover loss, send profit to insurance\\r\\n  /// @notice Send given {amount} of {asset} (== underlying) to the insurance\\r\\n  /// @param totalAssets_ Total strategy balance = balance of underlying + current invested assets amount\\r\\n  /// @param balance Current balance of the underlying\\r\\n  /// @return sentAmount Amount of underlying sent to the insurance\\r\\n  /// @return unsentAmount Missed part of the {amount} that were not sent to the insurance\\r\\n  function sendToInsurance(address asset, uint amount, address splitter, uint totalAssets_, uint balance) external returns (\\r\\n    uint sentAmount,\\r\\n    uint unsentAmount\\r\\n  ) {\\r\\n    return _sendToInsurance(asset, amount, splitter, totalAssets_, balance);\\r\\n  }\\r\\n\\r\\n  function _sendToInsurance(address asset, uint amount, address splitter, uint totalAssets_, uint balance) internal returns (\\r\\n    uint sentAmount,\\r\\n    uint unsentAmount\\r\\n  ) {\\r\\n    uint amountToSend = Math.min(amount, balance);\\r\\n    if (amountToSend != 0) {\\r\\n      // max amount that can be send to insurance is limited by PRICE_CHANGE_PROFIT_TOLERANCE\\r\\n\\r\\n      // Amount limitation should be implemented in the same way as in StrategySplitterV2._coverLoss\\r\\n      // Revert or cut amount in both cases\\r\\n\\r\\n      require(totalAssets_ != 0, AppErrors.ZERO_BALANCE);\\r\\n      amountToSend = Math.min(amountToSend, PRICE_CHANGE_PROFIT_TOLERANCE * totalAssets_ / 100_000);\\r\\n      //require(amountToSend <= PRICE_CHANGE_PROFIT_TOLERANCE * strategyBalance / 100_000, AppErrors.EARNED_AMOUNT_TOO_HIGH);\\r\\n\\r\\n      IERC20(asset).safeTransfer(address(ITetuVaultV2(ISplitter(splitter).vault()).insurance()), amountToSend);\\r\\n    }\\r\\n\\r\\n    sentAmount = amountToSend;\\r\\n    unsentAmount = amount > amountToSend\\r\\n      ? amount - amountToSend\\r\\n      : 0;\\r\\n\\r\\n    emit SendToInsurance(sentAmount, unsentAmount);\\r\\n  }\\r\\n\\r\\n  function _registerIncome(uint assetBefore, uint assetAfter) internal pure returns (uint earned, uint lost) {\\r\\n    if (assetAfter > assetBefore) {\\r\\n      earned = assetAfter - assetBefore;\\r\\n    } else {\\r\\n      lost = assetBefore - assetAfter;\\r\\n    }\\r\\n    return (earned, lost);\\r\\n  }\\r\\n\\r\\n  /// @notice Send ProfitToCover to insurance - code fragment of the requirePayAmountBack()\\r\\n  ///         moved here to reduce size of requirePayAmountBack()\\r\\n  /// @param theAsset_ The asset passed from Converter\\r\\n  /// @param balanceTheAsset_ Current balance of {theAsset_}\\r\\n  /// @param investedAssets_ Value of investedAssets after call fixPriceChange()\\r\\n  /// @param earnedByPrices_ ProfitToCover received from fixPriceChange()\\r\\n  /// @return balanceTheAssetOut Final balance of {theAsset_} (after sending profit-to-cover to the insurance)\\r\\n  function sendProfitGetAssetBalance(\\r\\n    address theAsset_,\\r\\n    uint balanceTheAsset_,\\r\\n    uint investedAssets_,\\r\\n    uint earnedByPrices_,\\r\\n    IStrategyV3.BaseState storage baseState_\\r\\n  ) external returns (\\r\\n    uint balanceTheAssetOut\\r\\n  ) {\\r\\n    balanceTheAssetOut = balanceTheAsset_;\\r\\n    if (earnedByPrices_ != 0) {\\r\\n      address underlying = baseState_.asset;\\r\\n      uint balanceUnderlying = theAsset_ == underlying\\r\\n        ? balanceTheAsset_\\r\\n        : AppLib.balance(underlying);\\r\\n\\r\\n      _sendToInsurance(underlying, earnedByPrices_, baseState_.splitter, investedAssets_ + balanceUnderlying, balanceUnderlying);\\r\\n\\r\\n      if (theAsset_ == underlying) {\\r\\n        balanceTheAssetOut = AppLib.balance(theAsset_);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n//endregion -------------------------------------------- Cover loss, send profit to insurance\\r\\n\\r\\n//region ---------------------------------------- Setters\\r\\n  function checkReinvestThresholdPercentChanged(address controller, uint percent_) external {\\r\\n    StrategyLib.onlyOperators(controller);\\r\\n    require(percent_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\\r\\n    emit ReinvestThresholdPercentChanged(percent_);\\r\\n  }\\r\\n\\r\\n  function checkLiquidationThresholdChanged(address controller, address token, uint amount) external {\\r\\n    StrategyLib.onlyOperators(controller);\\r\\n    emit LiquidationThresholdChanged(token, amount);\\r\\n  }\\r\\n//endregion ---------------------------------------- Setters\\r\\n\\r\\n//region ---------------------------------------- Withdraw helpers\\r\\n  /// @notice Get amount of assets that we expect to receive after withdrawing\\r\\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\\r\\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\\r\\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\\r\\n  ///                  one of assets must be {asset_}\\r\\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\\r\\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\\r\\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\\r\\n  function getExpectedWithdrawnAmounts(\\r\\n    uint[] memory reserves_,\\r\\n    uint liquidityAmount_,\\r\\n    uint totalSupply_\\r\\n  ) internal pure returns (\\r\\n    uint[] memory withdrawnAmountsOut\\r\\n  ) {\\r\\n    uint ratio = totalSupply_ == 0\\r\\n      ? 0\\r\\n      : (liquidityAmount_ >= totalSupply_\\r\\n        ? 1e18\\r\\n        : 1e18 * liquidityAmount_ / totalSupply_\\r\\n      );\\r\\n\\r\\n    uint len = reserves_.length;\\r\\n    withdrawnAmountsOut = new uint[](len);\\r\\n\\r\\n    if (ratio != 0) {\\r\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate expected amount of the main asset after withdrawing\\r\\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\\r\\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\\r\\n  /// @return amountsOut Expected amounts of the main asset received after conversion withdrawnAmounts+amountsToConvert\\r\\n  function getExpectedAmountMainAsset(\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset,\\r\\n    ITetuConverter converter,\\r\\n    uint[] memory withdrawnAmounts_,\\r\\n    uint[] memory amountsToConvert_\\r\\n  ) internal returns (\\r\\n    uint[] memory amountsOut\\r\\n  ) {\\r\\n    uint len = tokens.length;\\r\\n    amountsOut = new uint[](len);\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (i == indexAsset) {\\r\\n        amountsOut[i] = withdrawnAmounts_[i];\\r\\n      } else {\\r\\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\\r\\n        if (amount != 0) {\\r\\n          (amountsOut[i],) = converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return amountsOut;\\r\\n  }\\r\\n\\r\\n  /// @notice Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\\r\\n  /// @param amountsToConvert Amounts of {tokens} to be converted, they are located on the balance before withdraw\\r\\n  /// @param withdrawnAmounts Amounts of {tokens} that were withdrew from the pool\\r\\n  function postWithdrawActions(\\r\\n    ITetuConverter converter,\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset,\\r\\n\\r\\n    uint[] memory reservesBeforeWithdraw,\\r\\n    uint liquidityAmountWithdrew,\\r\\n    uint totalSupplyBeforeWithdraw,\\r\\n\\r\\n    uint[] memory amountsToConvert,\\r\\n    uint[] memory withdrawnAmounts\\r\\n  ) external returns (\\r\\n    uint[] memory expectedMainAssetAmounts,\\r\\n    uint[] memory _amountsToConvert\\r\\n  ) {\\r\\n    // estimate expected amount of assets to be withdrawn\\r\\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\\r\\n      reservesBeforeWithdraw,\\r\\n      liquidityAmountWithdrew,\\r\\n      totalSupplyBeforeWithdraw\\r\\n    );\\r\\n\\r\\n    // from received amounts after withdraw calculate how much we receive from converter for them in terms of the underlying asset\\r\\n    expectedMainAssetAmounts = getExpectedAmountMainAsset(\\r\\n      tokens,\\r\\n      indexAsset,\\r\\n      converter,\\r\\n      expectedWithdrawAmounts,\\r\\n      amountsToConvert\\r\\n    );\\r\\n\\r\\n    uint len = tokens.length;\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      amountsToConvert[i] += withdrawnAmounts[i];\\r\\n    }\\r\\n\\r\\n    return (expectedMainAssetAmounts, amountsToConvert);\\r\\n  }\\r\\n\\r\\n  /// @notice return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\\r\\n  function postWithdrawActionsEmpty(\\r\\n    ITetuConverter converter,\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset,\\r\\n    uint[] memory amountsToConvert_\\r\\n  ) external returns (\\r\\n    uint[] memory expectedAmountsMainAsset\\r\\n  ) {\\r\\n    expectedAmountsMainAsset = getExpectedAmountMainAsset(\\r\\n      tokens,\\r\\n      indexAsset,\\r\\n      converter,\\r\\n      // there are no withdrawn amounts\\r\\n      new uint[](tokens.length), // array with all zero values\\r\\n      amountsToConvert_\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate amount earned after withdraw. Withdraw cannot produce income, so we send all\\r\\n  ///         earned amount to insurance. Also we send to the insurance earned-by-prices-amount here.\\r\\n  /// @dev Amount for the insurance is sent from the balance, so the sending doesn't change invested assets.\\r\\n  /// @param asset Underlying\\r\\n  /// @param investedAssets_ Invested assets amount at the moment of withdrawing start\\r\\n  /// @param balanceBefore Balance of the underlying at the moment of withdrawing start\\r\\n  /// @param earnedByPrices_ Amount of underlying earned because of price changes, it should be send to the insurance.\\r\\n  /// @param updatedInvestedAssets_ Invested assets amount after withdrawing\\r\\n  /// @return amountSentToInsurance Total amount sent to the insurance in result.\\r\\n  function calculateIncomeAfterWithdraw(\\r\\n    address splitter,\\r\\n    address asset,\\r\\n    uint investedAssets_,\\r\\n    uint balanceBefore,\\r\\n    uint earnedByPrices_,\\r\\n    uint updatedInvestedAssets_\\r\\n  ) external returns (uint amountSentToInsurance, uint strategyLoss) {\\r\\n    uint balanceAfterWithdraw = AppLib.balance(asset);\\r\\n\\r\\n    // we need to compensate difference if during withdraw we lost some assets\\r\\n    // also we should send earned amounts to the insurance\\r\\n    // it's too dangerous to earn money on withdraw, we can move share price\\r\\n    // in the case of \\\"withdraw almost all\\\" share price can be changed significantly\\r\\n    // so, it's safer to transfer earned amount to the insurance\\r\\n    // earned can exceeds earnedByPrices_\\r\\n    // but if earned < earnedByPrices_ it means that we compensate a part of losses from earned-by-prices.\\r\\n    uint earned;\\r\\n    (earned, strategyLoss) = _registerIncome(\\r\\n      AppLib.sub0(investedAssets_ + balanceBefore, earnedByPrices_),\\r\\n      updatedInvestedAssets_ + balanceAfterWithdraw\\r\\n    );\\r\\n\\r\\n    if (earned != earnedByPrices_) {\\r\\n      emit OnEarningOnWithdraw(earned, earnedByPrices_);\\r\\n    }\\r\\n\\r\\n    if (earned != 0) {\\r\\n      (amountSentToInsurance,) = _sendToInsurance(\\r\\n        asset,\\r\\n        earned,\\r\\n        splitter,\\r\\n        investedAssets_ + balanceBefore,\\r\\n        balanceAfterWithdraw\\r\\n      );\\r\\n    }\\r\\n\\r\\n    return (amountSentToInsurance, strategyLoss);\\r\\n  }\\r\\n//endregion ------------------------------------- Withdraw helpers\\r\\n\\r\\n//region---------------------------------------- calcInvestedAssets\\r\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\r\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\r\\n  /// @param indexAsset Index of the underlying (main asset) in {tokens}\\r\\n  /// @param makeCheckpoint_ True - call IBookkeeper.checkpoint in the converter\\r\\n  /// @return amountOut Invested asset amount under control (in terms of underlying)\\r\\n  /// @return prices Asset prices in USD, decimals 18\\r\\n  /// @return decs 10**decimals\\r\\n  function calcInvestedAssets(\\r\\n    address[] memory tokens,\\r\\n    uint[] memory depositorQuoteExitAmountsOut,\\r\\n    uint indexAsset,\\r\\n    ITetuConverter converter_,\\r\\n    bool makeCheckpoint_\\r\\n  ) external returns (\\r\\n    uint amountOut,\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs\\r\\n  ) {\\r\\n    return _calcInvestedAssets(tokens, depositorQuoteExitAmountsOut, indexAsset, converter_, makeCheckpoint_);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\r\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\r\\n  /// @param indexAsset Index of the underlying (main asset) in {tokens}\\r\\n  /// @param makeCheckpoint_ True - call IBookkeeper.checkpoint in the converter\\r\\n  /// @return amountOut Invested asset amount under control (in terms of underlying)\\r\\n  /// @return prices Asset prices in USD, decimals 18\\r\\n  /// @return decs 10**decimals\\r\\n  function _calcInvestedAssets(\\r\\n    address[] memory tokens,\\r\\n    uint[] memory depositorQuoteExitAmountsOut,\\r\\n    uint indexAsset,\\r\\n    ITetuConverter converter_,\\r\\n    bool makeCheckpoint_\\r\\n  ) internal returns (\\r\\n    uint amountOut,\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs\\r\\n  ) {\\r\\n    CalcInvestedAssetsLocal memory v;\\r\\n    v.len = tokens.length;\\r\\n    v.asset = tokens[indexAsset];\\r\\n\\r\\n    // calculate prices, decimals\\r\\n    (prices, decs) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(converter_), tokens, v.len);\\r\\n\\r\\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\\r\\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\\r\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (i == indexAsset) {\\r\\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\\r\\n        amountOut += depositorQuoteExitAmountsOut[i];\\r\\n      } else {\\r\\n        v.token = tokens[i];\\r\\n        // possible reverse debt: collateralAsset = tokens[i], borrowAsset = underlying\\r\\n        // investedAssets is calculated using exact debts, debt-gaps are not taken into account\\r\\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(address(this), v.token, v.asset, false);\\r\\n        if (amountOut < toPay) {\\r\\n          setDebt(v, indexAsset, toPay);\\r\\n        } else {\\r\\n          amountOut -= toPay;\\r\\n        }\\r\\n\\r\\n        // available amount to repay\\r\\n        uint toRepay = collateral + IERC20(v.token).balanceOf(address(this)) + depositorQuoteExitAmountsOut[i];\\r\\n\\r\\n        // direct debt: collateralAsset = underlying, borrowAsset = tokens[i]\\r\\n        // investedAssets is calculated using exact debts, debt-gaps are not taken into account\\r\\n        (toPay, collateral) = converter_.getDebtAmountCurrent(address(this), v.asset, v.token, false);\\r\\n        amountOut += collateral;\\r\\n\\r\\n        if (toRepay >= toPay) {\\r\\n          amountOut += (toRepay - toPay) * prices[i] * decs[indexAsset] / prices[indexAsset] / decs[i];\\r\\n        } else {\\r\\n          // there is not enough amount to pay the debt\\r\\n          // let's register a debt and try to resolve it later below\\r\\n          setDebt(v, i, toPay - toRepay);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n    if (v.debts.length == v.len) {\\r\\n      // we assume here, that it would be always profitable to save collateral\\r\\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\\r\\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\\r\\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\r\\n        if (v.debts[i] == 0) continue;\\r\\n\\r\\n        // estimatedAssets should be reduced on the debt-value\\r\\n        // this estimation is approx and do not count price impact on the liquidation\\r\\n        // we will able to count the real output only after withdraw process\\r\\n        uint debtInAsset = v.debts[i] * prices[i] * decs[indexAsset] / prices[indexAsset] / decs[i];\\r\\n        if (debtInAsset > amountOut) {\\r\\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\\r\\n          amountOut = 0;\\r\\n        } else {\\r\\n          amountOut -= debtInAsset;\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    if (makeCheckpoint_) {\\r\\n      _callCheckpoint(tokens, converter_);\\r\\n    }\\r\\n\\r\\n    return (amountOut, prices, decs);\\r\\n  }\\r\\n\\r\\n  /// @notice Make new checkpoint in converter's bookkeeper\\r\\n  /// As results, a next call of checkpoint will return amount of increases to debts (\\\"deltas\\\")\\r\\n  /// since current moment up to the moment of the next call (we need such deltas in _fixPriceChanges only)\\r\\n  function _callCheckpoint(address[] memory tokens, ITetuConverter converter_) internal returns (\\r\\n    uint[] memory deltaGains,\\r\\n    uint[] memory deltaLosses\\r\\n  ) {\\r\\n    IBookkeeper a = IBookkeeper(IConverterController(converter_.controller()).bookkeeper());\\r\\n    return a.checkpoint(tokens);\\r\\n  }\\r\\n\\r\\n  /// @notice Lazy initialization of v.debts, add {value} to {v.debts[index]}\\r\\n  function setDebt(CalcInvestedAssetsLocal memory v, uint index, uint value) pure internal {\\r\\n    if (v.debts.length == 0) {\\r\\n      // lazy initialization\\r\\n      v.debts = new uint[](v.len);\\r\\n    }\\r\\n\\r\\n    // to pay the following amount we need to swap some other asset at first\\r\\n    v.debts[index] += value;\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate the token amounts for deposit and amount of loss (as old-total-asset - new-total-asset)\\r\\n  /// @param liquidationThresholdsAB [liquidityThreshold of token A, liquidityThreshold of tokenB]\\r\\n  /// @return loss New total assets - old total assets\\r\\n  /// @return tokenAmounts Balances of the token A and token B.\\r\\n  ///                     If any balance is zero it's not possible to enter to the pool, so return empty array (len 0)\\r\\n  function getTokenAmountsPair(\\r\\n    ITetuConverter converter,\\r\\n    uint totalAssets,\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint[2] calldata liquidationThresholdsAB\\r\\n  ) external returns (\\r\\n    uint loss,\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    tokenAmounts = new uint[](2);\\r\\n    tokenAmounts[0] = AppLib.balance(tokenA);\\r\\n    tokenAmounts[1] = AppLib.balance(tokenB);\\r\\n\\r\\n    address[] memory tokens = new address[](2);\\r\\n    tokens[0] = tokenA;\\r\\n    tokens[1] = tokenB;\\r\\n\\r\\n    uint[] memory amounts = new uint[](2);\\r\\n    amounts[0] = tokenAmounts[0];\\r\\n\\r\\n    (uint newTotalAssets,,) = _calcInvestedAssets(tokens, amounts, 0, converter, true);\\r\\n    return (\\r\\n      newTotalAssets < totalAssets\\r\\n        ? totalAssets - newTotalAssets\\r\\n        : 0,\\r\\n      (tokenAmounts[0] < liquidationThresholdsAB[0] || tokenAmounts[1] < liquidationThresholdsAB[1])\\r\\n        ? new uint[](0)\\r\\n        : tokenAmounts\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Swap can give us more amount out than expected, so we will receive increasing of share price.\\r\\n  ///         To prevent it, we need to send exceeded amount to insurance,\\r\\n  ///         but it's too expensive to make such transfer at the end of withdrawAggByStep.\\r\\n  ///         So, we postpone sending the profit until the next call of fixPriceChange\\r\\n  ///         by manually setting investedAssets equal to the oldTotalAssets\\r\\n  /// @dev If profitToCover was sent only partly, we will postpone sending of remain amount up to the next call\\r\\n  ///      of fixPriceChange in same manner\\r\\n  /// @param oldTotalAssets Total asset at the moment after last call of fixPriceChange,\\r\\n  ///                       decreased on the value of profitToCover.\\r\\n  function fixTooHighInvestedAssets(\\r\\n    address asset_,\\r\\n    uint oldTotalAssets,\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs_\\r\\n  ) external {\\r\\n    uint balance = IERC20(asset_).balanceOf(address(this));\\r\\n    uint newTotalAssets = csbs_.investedAssets + balance;\\r\\n\\r\\n    if (oldTotalAssets < newTotalAssets) {\\r\\n      // total asset was increased (i.e. because of too profitable swaps)\\r\\n      // this increment will increase share price\\r\\n      // we should send added amount to insurance to avoid share price change\\r\\n      // anyway, it's too expensive to do it here\\r\\n      // so, we postpone sending the profit until the next call of fixPriceChange\\r\\n      if (oldTotalAssets > balance) {\\r\\n        csbs_.investedAssets = oldTotalAssets - balance;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n//endregion------------------------------------- calcInvestedAssets\\r\\n\\r\\n//region ------------------------------------------------------- Bookkeeper logic\\r\\n  /// @notice Make checkpoint (it's writable function) and calculate total cost of the deltas in terms of the {asset}\\r\\n  /// @param tokens Full list of tokens that can be used as collateral/borrow asset by the current strategy\\r\\n  /// @param indexAsset Index of the underlying in {tokens}\\r\\n  /// @return increaseToDebt Total increase-to-debt since previous checkpoint [in underlying]\\r\\n  function _getIncreaseToDebt(\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset,\\r\\n    uint[] memory prices,\\r\\n    uint[] memory decs,\\r\\n    ITetuConverter converter\\r\\n  ) internal returns (\\r\\n    int increaseToDebt\\r\\n  ) {\\r\\n    IBookkeeper a = IBookkeeper(IConverterController(converter.controller()).bookkeeper());\\r\\n    (uint[] memory deltaGains, uint[] memory deltaLosses) = a.checkpoint(tokens);\\r\\n\\r\\n    uint len = tokens.length;\\r\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\r\\n      if (i == indexAsset) {\\r\\n        increaseToDebt -= int(deltaGains[i]);\\r\\n        increaseToDebt += int(deltaLosses[i]);\\r\\n      } else {\\r\\n        increaseToDebt += (int(deltaLosses[i]) - int(deltaGains[i]))\\r\\n          * int(prices[i]) * int(decs[indexAsset]) / int(prices[indexAsset]) / int(decs[i]);\\r\\n      }\\r\\n    }\\r\\n    emit OnIncreaseDebtToInsurance(tokens, deltaGains, deltaLosses, prices, increaseToDebt);\\r\\n\\r\\n    return increaseToDebt;\\r\\n  }\\r\\n\\r\\n  /// @notice Register income and cover possible loss after price changing, emit FixPriceChanges\\r\\n  /// @param investedAssetsBefore Currently stored value of _csbs.investedAssets\\r\\n  /// @param investedAssetsAfter Actual value of invested assets calculated at the current moment\\r\\n  /// @param increaseToDebt The amount by which the total loan debts increased for the selected period\\r\\n  /// @return earned Amount earned because of price changing\\r\\n  function _coverLossAfterPriceChanging(\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    uint investedAssetsBefore,\\r\\n    uint investedAssetsAfter,\\r\\n    int increaseToDebt,\\r\\n    IStrategyV3.BaseState storage baseState\\r\\n  ) internal returns (uint earned) {\\r\\n    int debtToInsurance0 = csbs.debtToInsurance;\\r\\n    if (investedAssetsAfter > investedAssetsBefore) {\\r\\n      earned = investedAssetsAfter - investedAssetsBefore;\\r\\n      if (increaseToDebt != 0) {\\r\\n        // Earned amount will be send to the insurance later.\\r\\n        // Probably it can be reduced by same limitations as {lost} amount below\\r\\n        // and so, it will be necessary to decrease increaseToDebt proportionally.\\r\\n        // For simplicity, we increase debtToInsurance on full increaseToDebt always\\r\\n        // in assumption, that such profits are always low.\\r\\n        csbs.debtToInsurance += increaseToDebt;\\r\\n        emit ChangeDebtToInsuranceOnProfit(debtToInsurance0, increaseToDebt);\\r\\n      }\\r\\n    } else {\\r\\n      uint lost = investedAssetsBefore - investedAssetsAfter;\\r\\n      if (lost != 0) {\\r\\n        uint totalAsset = investedAssetsAfter + IERC20(baseState.asset).balanceOf(address(this));\\r\\n        (uint lossToCover, uint lossUncovered) = _getSafeLossToCover(lost, totalAsset);\\r\\n\\r\\n        if (lossUncovered != 0) {\\r\\n          // we need to cover lost-amount, but this amount is too high and will produce revert in the splitter\\r\\n          // so, we will cover only part of {lost} and leave other part uncovered.\\r\\n          emit UncoveredLoss(lossToCover, lossUncovered, investedAssetsBefore, investedAssetsAfter);\\r\\n        }\\r\\n\\r\\n        // if we compensate lost only partially, we reduce both amounts \\\"from prices\\\" and \\\"from debts\\\" proportionally\\r\\n        _coverLossAndCheckResults(csbs, baseState.splitter, lossToCover, increaseToDebt * int(lossToCover) / int(lost));\\r\\n\\r\\n      }\\r\\n    }\\r\\n\\r\\n    emit FixPriceChanges(\\r\\n      investedAssetsBefore,\\r\\n      investedAssetsAfter,\\r\\n      debtToInsurance0,\\r\\n      csbs.debtToInsurance,\\r\\n      increaseToDebt\\r\\n    );\\r\\n    return earned;\\r\\n  }\\r\\n\\r\\n  /// @notice Call coverPossibleStrategyLoss, covered loss will be sent to vault.\\r\\n  ///         If the loss were covered only partially, emit {NotEnoughInsurance}\\r\\n  function coverLossAndCheckResults(\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    address splitter,\\r\\n    uint lossToCover\\r\\n  ) external {\\r\\n    _coverLossAndCheckResults(csbs, splitter, lossToCover, int(lossToCover));\\r\\n  }\\r\\n\\r\\n  /// @notice Call coverPossibleStrategyLoss, covered loss will be sent to vault.\\r\\n  function _coverLossAndCheckResults(\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    address splitter,\\r\\n    uint lossToCover,\\r\\n    int debtToInsuranceInc\\r\\n  ) internal {\\r\\n    address asset = ISplitter(splitter).asset();\\r\\n    address vault = ISplitter(splitter).vault();\\r\\n\\r\\n    uint balanceBefore = IERC20(asset).balanceOf(vault);\\r\\n    ISplitter(splitter).coverPossibleStrategyLoss(0, lossToCover);\\r\\n    uint balanceAfter = IERC20(asset).balanceOf(vault);\\r\\n\\r\\n    uint delta = AppLib.sub0(balanceAfter, balanceBefore);\\r\\n    uint uncovered = AppLib.sub0(lossToCover, delta);\\r\\n    debtToInsuranceInc = lossToCover == 0\\r\\n      ? int(0)\\r\\n      : debtToInsuranceInc * int(lossToCover - uncovered) / int(lossToCover);\\r\\n\\r\\n    if (debtToInsuranceInc != 0) {\\r\\n      csbs.debtToInsurance += debtToInsuranceInc;\\r\\n    }\\r\\n\\r\\n    // we don't add uncovered amount to the debts to the insurance\\r\\n    emit OnCoverLoss(lossToCover, debtToInsuranceInc, delta, uncovered);\\r\\n  }\\r\\n\\r\\n  /// @notice Cut loss-value to safe value that doesn't produce revert inside splitter\\r\\n  function _getSafeLossToCover(uint loss, uint totalAssets_) internal pure returns (\\r\\n    uint lossToCover,\\r\\n    uint lossUncovered\\r\\n  ) {\\r\\n    // see StrategySplitterV2._declareStrategyIncomeAndCoverLoss, _coverLoss implementations\\r\\n    lossToCover = Math.min(loss, ConverterStrategyBaseLib2.HARDWORK_LOSS_TOLERANCE * totalAssets_ / 100_000);\\r\\n    lossUncovered = AppLib.sub0(loss, lossToCover);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate profit/loss happened because of price changing.\\r\\n  /// Try to cover the loss, send the profit to the insurance.\\r\\n  /// Increment debt to insurance on amount of increase of the debts.\\r\\n  /// @param amountsInPool Amount of tokens that can be received from the pool after withdrawing all liquidity.\\r\\n  /// The order of tokens is same as in the {tokens}\\r\\n  /// @param tokens Result of {_depositorPoolAssets}\\r\\n  /// @param indexAsset Index of the underlying in {tokens}\\r\\n  /// @return investedAssetsOut Updated value of {csbs.investedAssets}\\r\\n  /// @return earnedOut Profit that was received because of price changes. It should be sent back to insurance.\\r\\n  function fixPriceChanges(\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    IStrategyV3.BaseState storage baseState,\\r\\n    uint[] memory amountsInPool,\\r\\n    address[] memory tokens,\\r\\n    uint indexAsset\\r\\n  ) external returns (\\r\\n    uint investedAssetsOut,\\r\\n    uint earnedOut\\r\\n  ) {\\r\\n    ITetuConverter converter = csbs.converter;\\r\\n    uint investedAssetsBefore = csbs.investedAssets;\\r\\n\\r\\n    uint[] memory prices;\\r\\n    uint[] memory decs;\\r\\n\\r\\n    (investedAssetsOut, prices, decs) = _calcInvestedAssets(tokens, amountsInPool, indexAsset, converter, false);\\r\\n    csbs.investedAssets = investedAssetsOut;\\r\\n\\r\\n    int increaseToDebt = _getIncreaseToDebt(tokens, indexAsset, prices, decs, converter);\\r\\n    earnedOut = _coverLossAfterPriceChanging(csbs, investedAssetsBefore, investedAssetsOut, increaseToDebt, baseState);\\r\\n  }\\r\\n\\r\\n  /// @notice Register amounts received for supplying collaterals and amount paid for the debts\\r\\n  ///         for the current period (a new period is started after each hardwork operation)\\r\\n  function registerBorrowResults(ITetuConverter converter, address asset) external {\\r\\n    IBookkeeper a = IBookkeeper(IConverterController(converter.controller()).bookkeeper());\\r\\n    (uint gains, uint losses) = a.startPeriod(asset);\\r\\n    if (gains != 0 && losses != 0) {\\r\\n      emit BorrowResults(gains, losses);\\r\\n    }\\r\\n  }\\r\\n//endregion ------------------------------------------------------- Bookkeeper logic\\r\\n\\r\\n\\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0xbf108a509285156685b75ae591c421fc9b514e6011fd95f30ec4bfa13dd9f1d5\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/DepositorBase.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\n/// @title Abstract base Depositor contract.\\r\\n/// @notice Converter strategies should inherit xDepositor.\\r\\n/// @notice All communication with external pools should be done at inherited contract\\r\\n/// @author bogdoslav\\r\\nabstract contract DepositorBase {\\r\\n\\r\\n  /// @notice Returns pool assets\\r\\n  function _depositorPoolAssets() internal virtual view returns (address[] memory assets);\\r\\n\\r\\n  /// @notice Returns pool token proportions\\r\\n  function _depositorPoolWeights() internal virtual view returns (uint[] memory weights, uint total);\\r\\n\\r\\n  /// @notice Returns pool token reserves\\r\\n  function _depositorPoolReserves() internal virtual view returns (uint[] memory reserves);\\r\\n\\r\\n  /// @notice Returns depositor's pool shares / lp token amount\\r\\n  function _depositorLiquidity() internal virtual view returns (uint);\\r\\n\\r\\n  //// @notice Total amount of LP tokens in the depositor\\r\\n  function _depositorTotalSupply() internal view virtual returns (uint);\\r\\n\\r\\n  /// @notice Deposit given amount to the pool.\\r\\n  /// @dev Depositor must care about tokens approval by itself.\\r\\n  function _depositorEnter(uint[] memory amountsDesired_) internal virtual returns (\\r\\n    uint[] memory amountsConsumed,\\r\\n    uint liquidityOut\\r\\n  );\\r\\n\\r\\n  /// @notice Withdraw given lp amount from the pool.\\r\\n  /// @param liquidityAmount Amount of liquidity to be converted\\r\\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\\r\\n  /// @param emergency Emergency exit (only withdraw, don't claim any rewards or make any other additional actions)\\r\\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\\r\\n  function _depositorExit(uint liquidityAmount, bool emergency) internal virtual returns (uint[] memory amountsOut);\\r\\n\\r\\n  /// @notice Quotes output for given lp amount from the pool.\\r\\n  /// @dev Write function with read-only behavior. BalanceR's depositor requires not-view.\\r\\n  /// @param liquidityAmount Amount of liquidity to be converted\\r\\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\\r\\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\\r\\n  function _depositorQuoteExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\\r\\n\\r\\n  /// @dev If pool supports emergency withdraw need to call it for emergencyExit()\\r\\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\\r\\n  function _depositorEmergencyExit() internal virtual returns (uint[] memory amountsOut) {\\r\\n    uint liquidity = _depositorLiquidity();\\r\\n    return liquidity == 0\\r\\n      ? new uint[](_depositorPoolAssets().length)\\r\\n      : _depositorExit(liquidity, true);\\r\\n  }\\r\\n\\r\\n  /// @notice Claim all possible rewards.\\r\\n  /// @return rewardTokens Claimed token addresses\\r\\n  /// @return rewardAmounts Claimed token amounts\\r\\n  /// @return depositorBalancesBefore Must have the same length as _depositorPoolAssets and represent balances before claim in the same order\\r\\n  function _depositorClaimRewards() internal virtual returns (\\r\\n    address[] memory rewardTokens,\\r\\n    uint[] memory rewardAmounts,\\r\\n    uint[] memory depositorBalancesBefore\\r\\n  );\\r\\n}\\r\\n\",\"keccak256\":\"0xf268ae50022f5028f4717d1e0256447ce5f0c3f671080d400a436f19d182e57e\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/algebra/AlgebraConverterStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"../ConverterStrategyBase.sol\\\";\\r\\nimport \\\"./AlgebraDepositor.sol\\\";\\r\\nimport \\\"./AlgebraConverterStrategyLogicLib.sol\\\";\\r\\nimport \\\"../../libs/AppPlatforms.sol\\\";\\r\\nimport \\\"../../interfaces/IRebalancingV2Strategy.sol\\\";\\r\\nimport \\\"../pair/PairBasedStrategyLib.sol\\\";\\r\\nimport \\\"./AlgebraStrategyErrors.sol\\\";\\r\\nimport \\\"../pair/PairBasedStrategyLogicLib.sol\\\";\\r\\n\\r\\ncontract AlgebraConverterStrategy is AlgebraDepositor, ConverterStrategyBase, IRebalancingV2Strategy {\\r\\n\\r\\n  //region ------------------------------------------------- Constants\\r\\n\\r\\n  string public constant override NAME = \\\"Algebra Converter Strategy\\\";\\r\\n  string public constant override PLATFORM = AppPlatforms.ALGEBRA;\\r\\n  string public constant override STRATEGY_VERSION = \\\"3.1.4\\\";\\r\\n\\r\\n  //endregion ------------------------------------------------- Constants\\r\\n\\r\\n  //region ------------------------------------------------- INIT\\r\\n\\r\\n  /// @notice Initialize the strategy with the given parameters.\\r\\n  /// @param controller_ The address of the controller.\\r\\n  /// @param splitter_ The address of the splitter.\\r\\n  /// @param converter_ The address of the converter.\\r\\n  /// @param pool_ The address of the pool.\\r\\n  /// @param tickRange_ The tick range for the liquidity position.\\r\\n  /// @param rebalanceTickRange_ The tick range for rebalancing.\\r\\n  function init(\\r\\n    address controller_,\\r\\n    address splitter_,\\r\\n    address converter_,\\r\\n    address pool_,\\r\\n    int24 tickRange_,\\r\\n    int24 rebalanceTickRange_,\\r\\n    bool isStablePool,\\r\\n    IncentiveKey memory key,\\r\\n    uint[4] calldata fuseThresholds\\r\\n  ) external initializer {\\r\\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\\r\\n    AlgebraConverterStrategyLogicLib.initStrategyState(\\r\\n      state,\\r\\n      [controller_, pool_],\\r\\n      tickRange_,\\r\\n      rebalanceTickRange_,\\r\\n      ISplitter(splitter_).asset(),\\r\\n      isStablePool,\\r\\n      fuseThresholds\\r\\n    );\\r\\n\\r\\n    AlgebraConverterStrategyLogicLib.initFarmingState(state, key);\\r\\n\\r\\n    // setup specific name for UI\\r\\n    StrategyLib2._changeStrategySpecificName(baseState, AlgebraConverterStrategyLogicLib.createSpecificName(state.pair));\\r\\n  }\\r\\n  //endregion ------------------------------------------------- INIT\\r\\n\\r\\n  //region --------------------------------------------- OPERATOR ACTIONS\\r\\n\\r\\n  /// @notice Manually set status of the fuse\\r\\n  /// @param status See PairBasedStrategyLib.FuseStatus enum for possible values\\r\\n  function setFuseStatus(uint status) external {\\r\\n    StrategyLib2.onlyOperators(controller());\\r\\n    PairBasedStrategyLib.setFuseStatus(state.pair.fuseAB, PairBasedStrategyLib.FuseStatus(status));\\r\\n  }\\r\\n\\r\\n  /// @notice Set thresholds for the fuse: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\\r\\n  ///         Decimals 18. The thresholds are compared with prices from TetuConverter's price oracle.\\r\\n  ///         Example: [0.9, 0.92, 1.08, 1.1]\\r\\n  ///         Price falls below 0.9 - fuse is ON. Price rises back up to 0.92 - fuse is OFF.\\r\\n  ///         Price raises more and reaches 1.1 - fuse is ON again. Price falls back and reaches 1.08 - fuse OFF again.\\r\\n  /// @param values Price thresholds: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\\r\\n  function setFuseThresholds(uint[4] memory values) external {\\r\\n    StrategyLib2.onlyOperators(controller());\\r\\n    PairBasedStrategyLib.setFuseThresholds(state.pair.fuseAB, values);\\r\\n  }\\r\\n\\r\\n  function setStrategyProfitHolder(address strategyProfitHolder) external {\\r\\n    StrategyLib2.onlyOperators(controller());\\r\\n    state.pair.strategyProfitHolder = strategyProfitHolder;\\r\\n  }\\r\\n\\r\\n  /// @notice Set withdrawDone value.\\r\\n  ///         When a fuse was triggered ON, all debts should be closed and asset should be converted to underlying.\\r\\n  ///         After completion of the conversion withdrawDone can be set to 1.\\r\\n  ///         So, {getFuseStatus} will return  withdrawDone=1 and you will know, that withdraw is not required\\r\\n  /// @param done 0 - full withdraw required, 1 - full withdraw was done\\r\\n  function setWithdrawDone(uint done) external {\\r\\n    StrategyLib2.onlyOperators(controller());\\r\\n    state.pair.withdrawDone = done;\\r\\n  }\\r\\n  //endregion --------------------------------------------- OPERATOR ACTIONS\\r\\n\\r\\n  //region --------------------------------------------- METRIC VIEWS\\r\\n\\r\\n  /// @notice Check if the strategy is ready for hard work.\\r\\n  /// @return A boolean indicating if the strategy is ready for hard work.\\r\\n  function isReadyToHardWork() override external virtual view returns (bool) {\\r\\n    return !needRebalance()\\r\\n    && !_isFuseTriggeredOn()\\r\\n    && AlgebraConverterStrategyLogicLib.isReadyToHardWork(state, _csbs.converter, controller());\\r\\n  }\\r\\n\\r\\n  /// @notice Check if the strategy needs rebalancing.\\r\\n  /// @return A boolean indicating if the strategy needs rebalancing.\\r\\n  function needRebalance() public view returns (bool) {\\r\\n    return AlgebraConverterStrategyLogicLib.needStrategyRebalance(state.pair, _csbs.converter);\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the current state of the contract\\r\\n  /// @return addr [tokenA, tokenB, pool, profitHolder]\\r\\n  /// @return tickData [tickSpacing, lowerTick, upperTick, rebalanceTickRange]\\r\\n  /// @return nums [totalLiquidity, fuse-status-tokenA, fuse-status-tokenB, withdrawDone, 4 thresholds of token A, 4 thresholds of token B]\\r\\n  /// @return boolValues [isStablePool, depositorSwapTokens]\\r\\n  function getDefaultState() external override view returns (\\r\\n    address[] memory addr,\\r\\n    int24[] memory tickData,\\r\\n    uint[] memory nums,\\r\\n    bool[] memory boolValues\\r\\n  ) {\\r\\n    return PairBasedStrategyLogicLib.getDefaultState(state.pair);\\r\\n  }\\r\\n\\r\\n  //endregion ---------------------------------------------- METRIC VIEWS\\r\\n\\r\\n  //region --------------------------------------------- CALLBACKS\\r\\n\\r\\n  function onERC721Received(\\r\\n    address,\\r\\n    address,\\r\\n    uint256,\\r\\n    bytes memory\\r\\n  ) external pure returns (bytes4) {\\r\\n    return this.onERC721Received.selector;\\r\\n  }\\r\\n\\r\\n  //endregion --------------------------------------------- CALLBACKS\\r\\n\\r\\n  //region--------------------------------------------- REBALANCE\\r\\n\\r\\n  /// @notice Rebalance using borrow/repay only, no swaps\\r\\n  /// @param checkNeedRebalance Revert if rebalance is not needed. Pass false to deposit after withdrawByAgg-iterations\\r\\n  function rebalanceNoSwaps(bool checkNeedRebalance) external {\\r\\n    address _controller = controller();\\r\\n    StrategyLib2.onlyOperators(_controller);\\r\\n\\r\\n    (uint profitToCover, uint oldTotalAssets) = _rebalanceBefore();\\r\\n    uint[] memory tokenAmounts = AlgebraConverterStrategyLogicLib.rebalanceNoSwaps(\\r\\n      _csbs,\\r\\n      state.pair,\\r\\n      [address(_csbs.converter), address(AppLib._getLiquidator(_controller))],\\r\\n      oldTotalAssets,\\r\\n      profitToCover,\\r\\n      baseState.splitter,\\r\\n      checkNeedRebalance,\\r\\n      liquidationThresholds\\r\\n    );\\r\\n    _rebalanceAfter(tokenAmounts);\\r\\n    state.pair.lastRebalanceNoSwap = block.timestamp;\\r\\n  }\\r\\n  //endregion--------------------------------------------- REBALANCE\\r\\n\\r\\n  //region --------------------------------------------- Withdraw by iterations\\r\\n\\r\\n  /// @notice Get info about a swap required by next call of {withdrawByAggStep} within the given plan\\r\\n  function quoteWithdrawByAgg(bytes memory planEntryData) external returns (address tokenToSwap, uint amountToSwap) {\\r\\n    // restriction \\\"operator only\\\" is checked inside {initWithdrawLocal} in {quoteWithdrawStep}\\r\\n\\r\\n    // estimate amounts to be withdrawn from the pool\\r\\n    uint totalLiquidity = state.pair.totalLiquidity;\\r\\n    uint[] memory amountsOut = (totalLiquidity == 0)\\r\\n      ? new uint[](2)\\r\\n      : _depositorQuoteExit(totalLiquidity);\\r\\n\\r\\n    return PairBasedStrategyLogicLib.quoteWithdrawByAgg(\\r\\n      state.pair,\\r\\n      planEntryData,\\r\\n      amountsOut,\\r\\n      controller(),\\r\\n      _csbs.converter,\\r\\n      liquidationThresholds\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Make withdraw iteration: [exit from the pool], [make 1 swap], [repay a debt], [enter to the pool]\\r\\n  ///         Typical sequence of the actions is: exit from the pool, make 1 swap, repay 1 debt.\\r\\n  ///         You can enter to the pool if you are sure that you won't have borrow + repay on AAVE3 in the same block.\\r\\n  /// @dev All swap-by-agg data should be prepared using {quoteWithdrawByAgg} off-chain\\r\\n  /// @param tokenToSwap_ What token should be swapped to other\\r\\n  /// @param aggregator_ Aggregator that should be used on next swap. 0 - use liquidator\\r\\n  /// @param amountToSwap_ Amount that should be swapped. 0 - no swap\\r\\n  /// @param swapData Swap rote that was prepared off-chain.\\r\\n  /// @param planEntryData PLAN_XXX + additional data, see IterationPlanKinds\\r\\n  /// @param entryToPool Allow to enter to the pool at the end. Use false if you are going to make several iterations.\\r\\n  ///                    It's possible to enter back to the pool by calling {rebalanceNoSwaps} at any moment\\r\\n  ///                    0 - not allowed, 1 - allowed, 2 - allowed only if completed\\r\\n  /// @return completed All debts were closed, leftovers were swapped to the required proportions.\\r\\n  function withdrawByAggStep(\\r\\n    address tokenToSwap_,\\r\\n    address aggregator_,\\r\\n    uint amountToSwap_,\\r\\n    bytes memory swapData,\\r\\n    bytes memory planEntryData,\\r\\n    uint entryToPool\\r\\n  ) external returns (bool completed) {\\r\\n    // restriction \\\"operator only\\\" is checked inside UniswapV3ConverterStrategyLogicLib.withdrawByAggStep\\r\\n\\r\\n    // fix price changes, exit from the pool\\r\\n    (uint profitToCover, uint oldTotalAssets) = _rebalanceBefore();\\r\\n\\r\\n    // check \\\"operator only\\\", make withdraw step, cover-loss, send profit to cover, prepare to enter to the pool\\r\\n    uint[] memory tokenAmounts;\\r\\n    (completed, tokenAmounts) = AlgebraConverterStrategyLogicLib.withdrawByAggStep(\\r\\n      _csbs,\\r\\n      [tokenToSwap_, aggregator_, controller(), address(_csbs.converter), baseState.splitter],\\r\\n      [amountToSwap_, profitToCover, oldTotalAssets, entryToPool],\\r\\n      swapData,\\r\\n      planEntryData,\\r\\n      state.pair,\\r\\n      liquidationThresholds\\r\\n    );\\r\\n\\r\\n    // enter to the pool\\r\\n    _rebalanceAfter(tokenAmounts);\\r\\n    state.pair.lastRebalanceNoSwap = 0;\\r\\n\\r\\n    if (completed && _isFuseTriggeredOn()) {\\r\\n      // full withdraw was completed, we can exclude next calls of withdrawByAggStep\\r\\n      state.pair.withdrawDone = 1;\\r\\n    }\\r\\n\\r\\n    ConverterStrategyBaseLib2.fixTooHighInvestedAssets(baseState.asset, oldTotalAssets, _csbs);\\r\\n  }\\r\\n\\r\\n  function getPropNotUnderlying18() external view returns (uint) {\\r\\n    return AlgebraConverterStrategyLogicLib.getPropNotUnderlying18(state.pair);\\r\\n  }\\r\\n\\r\\n  //endregion ------------------------------------ Withdraw by iterations\\r\\n\\r\\n  //region--------------------------------------------- INTERNAL LOGIC\\r\\n  function _beforeDeposit(\\r\\n    ITetuConverter converter_,\\r\\n    uint amount_,\\r\\n    address[] memory tokens_,\\r\\n    uint /*indexAsset_*/\\r\\n  ) override internal virtual returns (\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    require(!needRebalance(), AlgebraStrategyErrors.NEED_REBALANCE);\\r\\n    (uint prop0, uint prop1) = AlgebraConverterStrategyLogicLib.getEntryDataProportions(\\r\\n      IAlgebraPool(state.pair.pool),\\r\\n      state.pair.lowerTick,\\r\\n      state.pair.upperTick,\\r\\n      state.pair.depositorSwapTokens\\r\\n    );\\r\\n\\r\\n    // get token amounts for token A, token B\\r\\n    address tokenA = state.pair.tokenA;\\r\\n    tokenAmounts = PairBasedStrategyLogicLib._beforeDeposit(\\r\\n      converter_,\\r\\n      amount_,\\r\\n      tokenA,\\r\\n      state.pair.tokenB,\\r\\n      prop0 * 1e18 / (prop0 + prop1),\\r\\n      liquidationThresholds\\r\\n    );\\r\\n\\r\\n    // take into account a possibility that tokens_ can contain [B, A]\\r\\n    if (tokens_[0] != tokenA) {\\r\\n      (tokenAmounts[0], tokenAmounts[1]) = (tokenAmounts[1], tokenAmounts[0]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\\r\\n  /// @return earned The amount of earned rewards.\\r\\n  /// @return lost The amount of lost rewards.\\r\\n  /// @return assetBalanceAfterClaim The asset balance after claiming rewards.\\r\\n  /// @return paidDebtToInsurance Earned amount spent on debt-to-insurance payment\\r\\n  /// @return amountPerf Total performance fee in terms of underlying\\r\\n  function _handleRewards() override internal virtual returns (\\r\\n    uint earned,\\r\\n    uint lost,\\r\\n    uint assetBalanceAfterClaim,\\r\\n    uint paidDebtToInsurance,\\r\\n    uint amountPerf\\r\\n  ) {\\r\\n    (address[] memory rewardTokens, uint[] memory amounts) = _claim();\\r\\n    earned = AlgebraConverterStrategyLogicLib.calcEarned(state.pair.tokenA, controller(), rewardTokens, amounts);\\r\\n    (paidDebtToInsurance, amountPerf) = _rewardsLiquidation(rewardTokens, amounts);\\r\\n    return (earned, lost, AppLib.balance(baseState.asset), paidDebtToInsurance, amountPerf);\\r\\n  }\\r\\n\\r\\n  /// @notice Deposit given amount to the pool.\\r\\n  /// @param amount_ The amount to be deposited.\\r\\n  /// @param updateTotalAssetsBeforeInvest_ A boolean indicating if the total assets should be updated before investing.\\r\\n  /// @return strategyLoss Loss should be covered from Insurance\\r\\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\\r\\n    uint strategyLoss\\r\\n  ) {\\r\\n    if (PairBasedStrategyLib.isFuseTriggeredOn(state.pair.fuseAB.status)) {\\r\\n      uint[] memory tokenAmounts = new uint[](2);\\r\\n      tokenAmounts[0] = amount_;\\r\\n      emit OnDepositorEnter(tokenAmounts, tokenAmounts);\\r\\n      return 0;\\r\\n    } else {\\r\\n      return super._depositToPool(amount_, updateTotalAssetsBeforeInvest_);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _beforeWithdraw(uint /*amount*/) internal view override {\\r\\n    require(!needRebalance(), AlgebraStrategyErrors.NEED_REBALANCE);\\r\\n  }\\r\\n\\r\\n  /// @notice Check need-rebalance and fuse-ON\\r\\n  /// @return True if the hardwork should be skipped\\r\\n  function _preHardWork(bool reInvest) internal view override returns (bool) {\\r\\n    reInvest; // hide warning\\r\\n    require(!needRebalance(), AlgebraStrategyErrors.NEED_REBALANCE);\\r\\n    require(!_isFuseTriggeredOn(), AlgebraStrategyErrors.FUSE_IS_ACTIVE);\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  /// @notice Prepare to rebalance: check operator-only, fix price changes, call depositor exit\\r\\n  function _rebalanceBefore() internal returns (uint profitToCover, uint oldTotalAssets) {\\r\\n    (, profitToCover) = _fixPriceChanges(true);\\r\\n    oldTotalAssets = totalAssets() - profitToCover;\\r\\n\\r\\n    // withdraw all liquidity from pool\\r\\n    // after disableFuse() liquidity is zero\\r\\n    uint liquidity = state.pair.totalLiquidity;\\r\\n    if (liquidity != 0) {\\r\\n      _depositorExit(liquidity, false);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Make actions after rebalance: depositor enter, update invested assets\\r\\n  function _rebalanceAfter(uint[] memory tokenAmounts) internal {\\r\\n    if (tokenAmounts.length == 2 && !_isFuseTriggeredOn()) {\\r\\n      _depositorEnter(tokenAmounts);\\r\\n    }\\r\\n    _updateInvestedAssets();\\r\\n  }\\r\\n\\r\\n  function _isFuseTriggeredOn() internal view returns (bool) {\\r\\n    return PairBasedStrategyLib.isFuseTriggeredOn(state.pair.fuseAB.status);\\r\\n  }\\r\\n  //endregion--------------------------------------- INTERNAL LOGIC\\r\\n}\\r\\n\",\"keccak256\":\"0x9b42df091a354cf8965d77849e4653c9792fd5f7445e9358aafdeafb2df27292\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/algebra/AlgebraConverterStrategyLogicLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"./AlgebraLib.sol\\\";\\r\\nimport \\\"./AlgebraDebtLib.sol\\\";\\r\\nimport \\\"./AlgebraStrategyErrors.sol\\\";\\r\\nimport \\\"../../libs/AppLib.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\r\\nimport \\\"../pair/PairBasedStrategyLogicLib.sol\\\";\\r\\n\\r\\nlibrary AlgebraConverterStrategyLogicLib {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  //region ------------------------------------------------ Constants\\r\\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_STABLE = 300;\\r\\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE = 500;\\r\\n  uint internal constant HARD_WORK_USD_FEE_THRESHOLD = 100;\\r\\n\\r\\n  INonfungiblePositionManager internal constant ALGEBRA_NFT = INonfungiblePositionManager(0x8eF88E4c7CfbbaC1C163f7eddd4B578792201de6);\\r\\n  IFarmingCenter internal constant FARMING_CENTER = IFarmingCenter(0x7F281A8cdF66eF5e9db8434Ec6D97acc1bc01E78);\\r\\n  //endregion ------------------------------------------------ Constants\\r\\n\\r\\n  //region ------------------------------------------------ Events\\r\\n  event Rebalanced(uint loss, uint profitToCover, uint coveredByRewards);\\r\\n  event RebalancedDebt(uint loss, uint profitToCover, uint coveredByRewards);\\r\\n  event AlgebraFeesClaimed(uint fee0, uint fee1);\\r\\n  event AlgebraRewardsClaimed(uint reward, uint bonusReward);\\r\\n  //endregion ------------------------------------------------ Events\\r\\n\\r\\n  //region ------------------------------------------------ Data types\\r\\n\\r\\n  struct State {\\r\\n    PairBasedStrategyLogicLib.PairState pair;\\r\\n    // additional (specific) state\\r\\n\\r\\n    uint tokenId;\\r\\n    // farming\\r\\n    address rewardToken;\\r\\n    address bonusRewardToken;\\r\\n    uint256 startTime;\\r\\n    uint256 endTime;\\r\\n\\r\\n    /// @notice reserve space for future needs\\r\\n    uint[10] __gap;\\r\\n  }\\r\\n\\r\\n  struct RebalanceLocal {\\r\\n    /// @notice Fuse for token A and token B\\r\\n    PairBasedStrategyLib.FuseStateParams fuseAB;\\r\\n    ITetuConverter converter;\\r\\n    IAlgebraPool pool;\\r\\n    address tokenA;\\r\\n    address tokenB;\\r\\n    bool isStablePool;\\r\\n    uint[2] liquidationThresholdsAB;\\r\\n\\r\\n    bool fuseStatusChangedAB;\\r\\n    PairBasedStrategyLib.FuseStatus fuseStatusAB;\\r\\n\\r\\n    uint poolPrice;\\r\\n    uint poolPriceAdjustment;\\r\\n  }\\r\\n\\r\\n  struct EnterLocalVariables {\\r\\n    bool depositorSwapTokens;\\r\\n    uint128 liquidity;\\r\\n    uint tokenId;\\r\\n    int24 lowerTick;\\r\\n    int24 upperTick;\\r\\n  }\\r\\n\\r\\n  struct IsReadyToHardWorkLocal {\\r\\n    address tokenA;\\r\\n    address tokenB;\\r\\n    uint rewardInTermOfTokenA;\\r\\n    uint bonusRewardInTermOfTokenA;\\r\\n    uint fee0;\\r\\n    uint fee1;\\r\\n  }\\r\\n\\r\\n  struct ExitLocal {\\r\\n    address strategyProfitHolder;\\r\\n    uint128 liquidity;\\r\\n    uint reward;\\r\\n    uint bonusReward;\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Data types\\r\\n\\r\\n  //region ------------------------------------------------ Helpers\\r\\n\\r\\n  /// @param controllerPool [controller, pool]\\r\\n  /// @param fuseThresholds Fuse thresholds for tokens (stable pool only)\\r\\n  function initStrategyState(\\r\\n    State storage state,\\r\\n    address[2] calldata controllerPool,\\r\\n    int24 tickRange,\\r\\n    int24 rebalanceTickRange,\\r\\n    address asset_,\\r\\n    bool isStablePool,\\r\\n    uint[4] calldata fuseThresholds\\r\\n  ) external {\\r\\n    require(controllerPool[1] != address(0), AppErrors.ZERO_ADDRESS);\\r\\n    address token0 = IAlgebraPool(controllerPool[1]).token0();\\r\\n    address token1 = IAlgebraPool(controllerPool[1]).token1();\\r\\n\\r\\n    int24[4] memory tickData;\\r\\n    {\\r\\n      int24 tickSpacing = AlgebraLib.tickSpacing();\\r\\n      if (tickRange != 0) {\\r\\n        require(tickRange == tickRange / tickSpacing * tickSpacing, AlgebraStrategyErrors.INCORRECT_TICK_RANGE);\\r\\n        require(rebalanceTickRange == rebalanceTickRange / tickSpacing * tickSpacing, AlgebraStrategyErrors.INCORRECT_REBALANCE_TICK_RANGE);\\r\\n      }\\r\\n      tickData[0] = tickSpacing;\\r\\n      (tickData[1], tickData[2]) = AlgebraDebtLib.calcTickRange(IAlgebraPool(controllerPool[1]), tickRange, tickSpacing);\\r\\n      tickData[3] = rebalanceTickRange;\\r\\n    }\\r\\n\\r\\n    PairBasedStrategyLogicLib.setInitialDepositorValues(\\r\\n      state.pair,\\r\\n      [controllerPool[1], asset_, token0, token1],\\r\\n      tickData,\\r\\n      isStablePool,\\r\\n      fuseThresholds\\r\\n    );\\r\\n\\r\\n    address liquidator = IController(controllerPool[0]).liquidator();\\r\\n    IERC20(token0).approve(liquidator, type(uint).max);\\r\\n    IERC20(token1).approve(liquidator, type(uint).max);\\r\\n    IERC20(token0).approve(address(ALGEBRA_NFT), type(uint).max);\\r\\n    IERC20(token1).approve(address(ALGEBRA_NFT), type(uint).max);\\r\\n  }\\r\\n\\r\\n  function initFarmingState(\\r\\n    State storage state,\\r\\n    IncentiveKey calldata key\\r\\n  ) external {\\r\\n    state.rewardToken = key.rewardToken;\\r\\n    state.bonusRewardToken = key.bonusRewardToken;\\r\\n    state.startTime = key.startTime;\\r\\n    state.endTime = key.endTime;\\r\\n  }\\r\\n\\r\\n  function createSpecificName(PairBasedStrategyLogicLib.PairState storage pairState) external view returns (string memory) {\\r\\n    return string(abi.encodePacked(\\\"Algebra \\\", IERC20Metadata(pairState.tokenA).symbol(), \\\"/\\\", IERC20Metadata(pairState.tokenB).symbol()));\\r\\n  }\\r\\n\\r\\n  function getIncentiveKey(State storage state) internal view returns (IncentiveKey memory) {\\r\\n    return IncentiveKey(state.rewardToken, state.bonusRewardToken, state.pair.pool, state.startTime, state.endTime);\\r\\n  }\\r\\n\\r\\n  function getFees(State storage state) public view returns (uint fee0, uint fee1) {\\r\\n    (fee0, fee1) = AlgebraLib.getFees(IAlgebraPool(state.pair.pool), ALGEBRA_NFT, state.tokenId);\\r\\n  }\\r\\n\\r\\n  function getPoolReserves(PairBasedStrategyLogicLib.PairState storage pairState) external view returns (\\r\\n    uint[] memory reserves\\r\\n  ) {\\r\\n    reserves = new uint[](2);\\r\\n    (uint160 sqrtRatioX96, , , , , ,) = IAlgebraPool(pairState.pool).globalState();\\r\\n\\r\\n    (reserves[0], reserves[1]) = AlgebraLib.getAmountsForLiquidity(\\r\\n      sqrtRatioX96,\\r\\n      pairState.lowerTick,\\r\\n      pairState.upperTick,\\r\\n      pairState.totalLiquidity\\r\\n    );\\r\\n\\r\\n    if (pairState.depositorSwapTokens) {\\r\\n      (reserves[0], reserves[1]) = (reserves[1], reserves[0]);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev Gets the liquidator swap slippage based on the pool type (stable or volatile).\\r\\n  /// @return The liquidator swap slippage percentage.\\r\\n  function _getLiquidatorSwapSlippage(bool isStablePool) internal pure returns (uint) {\\r\\n    return isStablePool ? LIQUIDATOR_SWAP_SLIPPAGE_STABLE : LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE;\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate proportions of the tokens for entry kind 1\\r\\n  /// @param pool Pool instance.\\r\\n  /// @param lowerTick The lower tick of the pool's main range.\\r\\n  /// @param upperTick The upper tick of the pool's main range.\\r\\n  /// @param depositorSwapTokens A boolean indicating if need to use token B instead of token A.\\r\\n  /// @return prop0 Proportion onf token A. Any decimals are allowed, prop[0 or 1]/(prop0 + prop1) are important only\\r\\n  /// @return prop1 Proportion onf token B. Any decimals are allowed, prop[0 or 1]/(prop0 + prop1) are important only\\r\\n  function getEntryDataProportions(IAlgebraPool pool, int24 lowerTick, int24 upperTick, bool depositorSwapTokens) external view returns (uint, uint) {\\r\\n    return AlgebraDebtLib.getEntryDataProportions(pool, lowerTick, upperTick, depositorSwapTokens);\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Helpers\\r\\n\\r\\n  //region ------------------------------------------------ Join the pool\\r\\n\\r\\n  function enter(\\r\\n    State storage state,\\r\\n    uint[] memory amountsDesired_\\r\\n  ) external returns (uint[] memory amountsConsumed, uint liquidityOut) {\\r\\n    EnterLocalVariables memory vars = EnterLocalVariables({\\r\\n      depositorSwapTokens : state.pair.depositorSwapTokens,\\r\\n      liquidity : 0,\\r\\n      tokenId : state.tokenId,\\r\\n      lowerTick : state.pair.lowerTick,\\r\\n      upperTick : state.pair.upperTick\\r\\n    });\\r\\n\\r\\n    (address token0, address token1) = vars.depositorSwapTokens\\r\\n      ? (state.pair.tokenB, state.pair.tokenA)\\r\\n      : (state.pair.tokenA, state.pair.tokenB);\\r\\n    if (vars.depositorSwapTokens) {\\r\\n      (amountsDesired_[0], amountsDesired_[1]) = (amountsDesired_[1], amountsDesired_[0]);\\r\\n    }\\r\\n\\r\\n    amountsConsumed = new uint[](2);\\r\\n\\r\\n    if (vars.tokenId > 0) {\\r\\n      (,,,,int24 nftLowerTick, int24 nftUpperTick,,,,,) = ALGEBRA_NFT.positions(vars.tokenId);\\r\\n      if (nftLowerTick != vars.lowerTick || nftUpperTick != vars.upperTick) {\\r\\n        ALGEBRA_NFT.burn(vars.tokenId);\\r\\n        vars.tokenId = 0;\\r\\n      }\\r\\n    }\\r\\n\\r\\n    IncentiveKey memory key = getIncentiveKey(state);\\r\\n\\r\\n    if (vars.tokenId == 0) {\\r\\n      (vars.tokenId, vars.liquidity, amountsConsumed[0], amountsConsumed[1]) = ALGEBRA_NFT.mint(INonfungiblePositionManager.MintParams(\\r\\n        token0,\\r\\n        token1,\\r\\n        vars.lowerTick,\\r\\n        vars.upperTick,\\r\\n        amountsDesired_[0],\\r\\n        amountsDesired_[1],\\r\\n        0,\\r\\n        0,\\r\\n        address(this),\\r\\n        block.timestamp\\r\\n      ));\\r\\n\\r\\n      state.tokenId = vars.tokenId;\\r\\n\\r\\n      ALGEBRA_NFT.safeTransferFrom(address(this), address(FARMING_CENTER), vars.tokenId);\\r\\n    } else {\\r\\n      (vars.liquidity, amountsConsumed[0], amountsConsumed[1]) = ALGEBRA_NFT.increaseLiquidity(INonfungiblePositionManager.IncreaseLiquidityParams(\\r\\n        vars.tokenId,\\r\\n        amountsDesired_[0],\\r\\n        amountsDesired_[1],\\r\\n        0,\\r\\n        0,\\r\\n        block.timestamp\\r\\n      ));\\r\\n\\r\\n      if (state.pair.totalLiquidity > 0) {\\r\\n        // get reward amounts\\r\\n        (uint reward, uint bonusReward) = _collectRewards(key, vars.tokenId);\\r\\n\\r\\n        // exit farming (undeposit)\\r\\n        FARMING_CENTER.exitFarming(key, vars.tokenId, false);\\r\\n\\r\\n        // claim rewards and send to profit holder\\r\\n        address strategyProfitHolder = state.pair.strategyProfitHolder;\\r\\n        _claimRewards(state.rewardToken, strategyProfitHolder, reward);\\r\\n        _claimRewards(state.bonusRewardToken, strategyProfitHolder, bonusReward);\\r\\n      } else {\\r\\n        ALGEBRA_NFT.safeTransferFrom(address(this), address(FARMING_CENTER), vars.tokenId);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    FARMING_CENTER.enterFarming(key, vars.tokenId, 0, false);\\r\\n\\r\\n    // todo probably we need to swap amountsConsumed depending on depositorSwapTokens in same way as in univ3\\r\\n    state.pair.totalLiquidity += vars.liquidity;\\r\\n    liquidityOut = uint(vars.liquidity);\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Join the pool\\r\\n\\r\\n  //region ------------------------------------------------ Exit the pool\\r\\n\\r\\n  /// @param emergency Emergency exit (only withdraw, don't claim any rewards or make any other additional actions)\\r\\n  function exit(\\r\\n    State storage state,\\r\\n    uint128 liquidityAmountToExit,\\r\\n    bool emergency\\r\\n  ) external returns (uint[] memory amountsOut) {\\r\\n    ExitLocal memory v;\\r\\n\\r\\n    amountsOut = new uint[](2);\\r\\n    v.strategyProfitHolder = state.pair.strategyProfitHolder;\\r\\n    IncentiveKey memory key = getIncentiveKey(state);\\r\\n\\r\\n    v.liquidity = state.pair.totalLiquidity;\\r\\n\\r\\n    require(v.liquidity >= liquidityAmountToExit, AlgebraStrategyErrors.WRONG_LIQUIDITY);\\r\\n\\r\\n    // we assume here, that liquidity is not zero (otherwise it doesn't worth to call exit)\\r\\n    uint tokenId = state.tokenId;\\r\\n\\r\\n    // get reward amounts\\r\\n    if (! emergency) {\\r\\n      (v.reward, v.bonusReward) = _collectRewards(key, tokenId);\\r\\n    }\\r\\n\\r\\n    // exit farming (undeposit)\\r\\n    FARMING_CENTER.exitFarming(getIncentiveKey(state), state.tokenId, false);\\r\\n\\r\\n    // claim rewards and send to profit holder\\r\\n    if (! emergency) {\\r\\n      _claimRewards(state.rewardToken, v.strategyProfitHolder, v.reward);\\r\\n      _claimRewards(state.bonusRewardToken, v.strategyProfitHolder, v.bonusReward);\\r\\n    }\\r\\n\\r\\n    // withdraw nft\\r\\n    FARMING_CENTER.withdrawToken(tokenId, address(this), '');\\r\\n\\r\\n    // burn liquidity\\r\\n    (amountsOut[0], amountsOut[1]) = ALGEBRA_NFT.decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams(tokenId, liquidityAmountToExit, 0, 0, block.timestamp));\\r\\n\\r\\n    {\\r\\n      // collect tokens and fee\\r\\n      (uint collected0, uint collected1) = ALGEBRA_NFT.collect(INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max));\\r\\n\\r\\n      uint fee0 = collected0 > amountsOut[0] ? (collected0 - amountsOut[0]) : 0;\\r\\n      uint fee1 = collected1 > amountsOut[1] ? (collected1 - amountsOut[1]) : 0;\\r\\n\\r\\n      emit AlgebraFeesClaimed(fee0, fee1);\\r\\n\\r\\n      if (state.pair.depositorSwapTokens) {\\r\\n        (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\\r\\n        (fee0, fee1) = (fee1, fee0);\\r\\n      }\\r\\n\\r\\n      // send fees to profit holder\\r\\n      if (fee0 > 0) {\\r\\n        IERC20(state.pair.tokenA).safeTransfer(v.strategyProfitHolder, fee0);\\r\\n      }\\r\\n      if (fee1 > 0) {\\r\\n        IERC20(state.pair.tokenB).safeTransfer(v.strategyProfitHolder, fee1);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    v.liquidity -= liquidityAmountToExit;\\r\\n    state.pair.totalLiquidity = v.liquidity;\\r\\n\\r\\n    if (v.liquidity != 0) {\\r\\n      ALGEBRA_NFT.safeTransferFrom(address(this), address(FARMING_CENTER), tokenId);\\r\\n      FARMING_CENTER.enterFarming(key, tokenId, 0, false);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function quoteExit(\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    uint128 liquidityAmountToExit\\r\\n  ) public view returns (uint[] memory amountsOut) {\\r\\n    (uint160 sqrtRatioX96, , , , , ,) = IAlgebraPool(pairState.pool).globalState();\\r\\n    amountsOut = new uint[](2);\\r\\n    (amountsOut[0], amountsOut[1]) = AlgebraLib.getAmountsForLiquidity(\\r\\n      sqrtRatioX96,\\r\\n      pairState.lowerTick,\\r\\n      pairState.upperTick,\\r\\n      liquidityAmountToExit\\r\\n    );\\r\\n    if (pairState.depositorSwapTokens) {\\r\\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\\r\\n    }\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Exit the pool\\r\\n\\r\\n  //region ------------------------------------------------ Rewards\\r\\n\\r\\n  function isReadyToHardWork(State storage state, ITetuConverter converter, address controller) external view returns (bool isReady) {\\r\\n    IsReadyToHardWorkLocal memory v;\\r\\n    v.tokenA = state.pair.tokenA;\\r\\n    v.tokenB = state.pair.tokenB;\\r\\n    address h = state.pair.strategyProfitHolder;\\r\\n\\r\\n    if (state.pair.totalLiquidity != 0) {\\r\\n      address rewardToken = state.rewardToken;\\r\\n      address bonusRewardToken = state.bonusRewardToken;\\r\\n      IncentiveKey memory key = getIncentiveKey(state);\\r\\n      (uint reward, uint bonusReward) = FARMING_CENTER.eternalFarming().getRewardInfo(key, state.tokenId);\\r\\n      reward += IERC20(rewardToken).balanceOf(h);\\r\\n      bonusReward += IERC20(bonusRewardToken).balanceOf(h);\\r\\n      ITetuLiquidator liquidator = ITetuLiquidator(IController(controller).liquidator());\\r\\n      if (reward > 0) {\\r\\n        v.rewardInTermOfTokenA = liquidator.getPrice(rewardToken, v.tokenA, reward);\\r\\n      }\\r\\n      if (v.bonusRewardInTermOfTokenA > 0) {\\r\\n        v.bonusRewardInTermOfTokenA = liquidator.getPrice(bonusRewardToken, v.tokenA, bonusReward);\\r\\n      }\\r\\n      (v.fee0, v.fee1) = getFees(state);\\r\\n    }\\r\\n\\r\\n    // check claimable amounts and compare with thresholds\\r\\n    if (state.pair.depositorSwapTokens) {\\r\\n      (v.fee0, v.fee1) = (v.fee1, v.fee0);\\r\\n    }\\r\\n\\r\\n    v.fee0 += IERC20(v.tokenA).balanceOf(h);\\r\\n    v.fee1 += IERC20(v.tokenB).balanceOf(h);\\r\\n\\r\\n    IPriceOracle oracle = AppLib._getPriceOracle(converter);\\r\\n    uint priceA = oracle.getAssetPrice(v.tokenA);\\r\\n    uint priceB = oracle.getAssetPrice(v.tokenB);\\r\\n\\r\\n    uint fee0USD = v.fee0 * priceA / 1e18;\\r\\n    uint fee1USD = v.fee1 * priceB / 1e18;\\r\\n\\r\\n    return\\r\\n      fee0USD > HARD_WORK_USD_FEE_THRESHOLD\\r\\n      || fee1USD > HARD_WORK_USD_FEE_THRESHOLD\\r\\n      || v.rewardInTermOfTokenA * priceA / 1e18 > HARD_WORK_USD_FEE_THRESHOLD\\r\\n      || v.bonusRewardInTermOfTokenA * priceA / 1e18 > HARD_WORK_USD_FEE_THRESHOLD\\r\\n    ;\\r\\n  }\\r\\n\\r\\n  function claimRewards(State storage state) external returns (\\r\\n    address[] memory tokensOut,\\r\\n    uint[] memory amountsOut,\\r\\n    uint[] memory balancesBefore\\r\\n  ) {\\r\\n    address strategyProfitHolder = state.pair.strategyProfitHolder;\\r\\n    uint tokenId = state.tokenId;\\r\\n    tokensOut = new address[](4);\\r\\n    tokensOut[0] = state.pair.tokenA;\\r\\n    tokensOut[1] = state.pair.tokenB;\\r\\n    tokensOut[2] = state.rewardToken;\\r\\n    tokensOut[3] = state.bonusRewardToken;\\r\\n\\r\\n    balancesBefore = new uint[](4);\\r\\n    for (uint i; i < tokensOut.length; i++) {\\r\\n      balancesBefore[i] = IERC20(tokensOut[i]).balanceOf(address(this));\\r\\n    }\\r\\n\\r\\n    amountsOut = new uint[](4);\\r\\n    if (tokenId > 0 && state.pair.totalLiquidity > 0) {\\r\\n      (amountsOut[0], amountsOut[1]) = FARMING_CENTER.collect(INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max));\\r\\n\\r\\n      emit AlgebraFeesClaimed(amountsOut[0], amountsOut[1]);\\r\\n\\r\\n      if (state.pair.depositorSwapTokens) {\\r\\n        (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\\r\\n      }\\r\\n\\r\\n      (amountsOut[2], amountsOut[3]) = _collectRewards(getIncentiveKey(state), tokenId);\\r\\n      amountsOut[2] = _claimRewards(tokensOut[2], address(0), amountsOut[2]);\\r\\n      amountsOut[3] = _claimRewards(tokensOut[3], address(0), amountsOut[3]);\\r\\n\\r\\n      emit AlgebraRewardsClaimed(amountsOut[2], amountsOut[3]);\\r\\n    }\\r\\n\\r\\n    for (uint i; i < tokensOut.length; ++i) {\\r\\n      uint b = IERC20(tokensOut[i]).balanceOf(strategyProfitHolder);\\r\\n      if (b > 0) {\\r\\n        IERC20(tokensOut[i]).transferFrom(strategyProfitHolder, address(this), b);\\r\\n        amountsOut[i] += b;\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function calcEarned(address asset, address controller, address[] memory rewardTokens, uint[] memory amounts) external view returns (uint) {\\r\\n    ITetuLiquidator liquidator = ITetuLiquidator(IController(controller).liquidator());\\r\\n    uint len = rewardTokens.length;\\r\\n    uint earned;\\r\\n    for (uint i; i < len; ++i) {\\r\\n      address token = rewardTokens[i];\\r\\n      if (token == asset) {\\r\\n        earned += amounts[i];\\r\\n      } else {\\r\\n        earned += liquidator.getPrice(rewardTokens[i], asset, amounts[i]);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return earned;\\r\\n  }\\r\\n\\r\\n  /// @notice Claim rewards if any, send them to {strategyProfitHolder} if !skipTransfer, hide exceptions\\r\\n  /// @param to Transfer rewards to {to}, skip transfer if 0\\r\\n  function _claimRewards(address token, address to, uint rewardAmount) internal returns (uint rewardOut) {\\r\\n    if (rewardAmount != 0) {\\r\\n      try FARMING_CENTER.claimReward(\\r\\n        token, address(this), 0, rewardAmount\\r\\n      ) returns (uint /*reward*/) {\\r\\n        // if previous calls of claimReward were failed and current call is successful,\\r\\n        // we can receive reward > rewardAmount here but we will receive only rewardAmount on the balance.\\r\\n        // Most probably it's enough to transfer min(rewardAmount, reward) but it's more reliable to check balance\\r\\n        if (to != address(0)) {\\r\\n          rewardOut = Math.min(rewardAmount, IERC20(token).balanceOf(address(this)));\\r\\n          if (rewardOut != 0) {\\r\\n            IERC20(token).safeTransfer(to, rewardOut);\\r\\n          }\\r\\n        }\\r\\n      } catch {\\r\\n        // an exception in reward-claiming shouldn't stop hardwork / withdraw\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return rewardOut;\\r\\n  }\\r\\n\\r\\n  /// @notice Collect rewards, hide exceptions\\r\\n  function _collectRewards(IncentiveKey memory key, uint tokenId) internal returns (uint reward, uint bonusReward) {\\r\\n    try FARMING_CENTER.collectRewards(\\r\\n      key, tokenId\\r\\n    ) returns (uint rewardAmount, uint bonusRewardAmount) {\\r\\n      (reward, bonusReward) = (rewardAmount, bonusRewardAmount);\\r\\n    } catch {\\r\\n      // an exception in reward-claiming shouldn't stop hardwork / withdraw\\r\\n    }\\r\\n\\r\\n    return (reward, bonusReward);\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Rewards\\r\\n\\r\\n  //region ------------------------------------------------ Rebalance\\r\\n\\r\\n  /// @notice Determine if the strategy needs to be rebalanced.\\r\\n  /// @return needRebalance A boolean indicating if {rebalanceNoSwaps} should be called\\r\\n  function needStrategyRebalance(PairBasedStrategyLogicLib.PairState storage pairState, ITetuConverter converter_) external view returns (\\r\\n    bool needRebalance\\r\\n  ) {\\r\\n    address pool = pairState.pool;\\r\\n    // poolPrice should have same decimals as a price from oracle == 18\\r\\n    uint poolPriceAdjustment = PairBasedStrategyLib.getPoolPriceAdjustment(IERC20Metadata(pairState.tokenA).decimals());\\r\\n    uint poolPrice = AlgebraLib.getPrice(pool, pairState.tokenB) * poolPriceAdjustment;\\r\\n    (needRebalance, , ) = PairBasedStrategyLogicLib.needStrategyRebalance(\\r\\n      pairState,\\r\\n      converter_,\\r\\n      AlgebraDebtLib.getCurrentTick(IAlgebraPool(pool)),\\r\\n      poolPrice\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Make rebalance without swaps (using borrowing only).\\r\\n  /// @param converterLiquidator [TetuConverter, TetuLiquidator]\\r\\n  /// @param checkNeedRebalance_ True if the function should ensure that the rebalance is required\\r\\n  /// @param totalAssets_ Current value of totalAssets()\\r\\n  /// @return tokenAmounts Token amounts for deposit. If length == 0 - rebalance wasn't made and no deposit is required.\\r\\n  function rebalanceNoSwaps(\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    address[2] calldata converterLiquidator,\\r\\n    uint totalAssets_,\\r\\n    uint profitToCover,\\r\\n    address splitter,\\r\\n    bool checkNeedRebalance_,\\r\\n    mapping(address => uint) storage liquidityThresholds_\\r\\n  ) external returns (\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    RebalanceLocal memory v;\\r\\n    _initLocalVars(v, ITetuConverter(converterLiquidator[0]), pairState, liquidityThresholds_);\\r\\n    v.poolPrice = AlgebraLib.getPrice(address(v.pool), pairState.tokenB) * v.poolPriceAdjustment;\\r\\n    bool needRebalance;\\r\\n    int24 tick = AlgebraDebtLib.getCurrentTick(v.pool);\\r\\n    (needRebalance, v.fuseStatusChangedAB, v.fuseStatusAB) = PairBasedStrategyLogicLib.needStrategyRebalance(\\r\\n      pairState,\\r\\n      v.converter,\\r\\n      tick,\\r\\n      v.poolPrice\\r\\n    );\\r\\n\\r\\n    // update fuse status if necessary\\r\\n    if (needRebalance) {\\r\\n      // we assume here, that needRebalance is true if any fuse has changed state, see needStrategyRebalance impl\\r\\n      PairBasedStrategyLogicLib.updateFuseStatus(pairState, v.fuseStatusChangedAB, v.fuseStatusAB);\\r\\n    }\\r\\n\\r\\n    require(!checkNeedRebalance_ || needRebalance, AlgebraStrategyErrors.NO_REBALANCE_NEEDED);\\r\\n\\r\\n    // rebalancing debt, setting new tick range\\r\\n    if (needRebalance) {\\r\\n      AlgebraDebtLib.rebalanceNoSwaps(converterLiquidator, pairState, profitToCover, totalAssets_, splitter, v.liquidationThresholdsAB, tick);\\r\\n\\r\\n      uint loss;\\r\\n      (loss, tokenAmounts) = ConverterStrategyBaseLib2.getTokenAmountsPair(v.converter, totalAssets_, v.tokenA, v.tokenB, v.liquidationThresholdsAB);\\r\\n\\r\\n      if (loss != 0) {\\r\\n        ConverterStrategyBaseLib2.coverLossAndCheckResults(csbs, splitter, loss);\\r\\n      }\\r\\n      emit Rebalanced(loss, profitToCover, 0);\\r\\n    }\\r\\n\\r\\n    return tokenAmounts;\\r\\n  }\\r\\n\\r\\n  /// @notice Initialize {v} by state values\\r\\n  function _initLocalVars(\\r\\n    RebalanceLocal memory v,\\r\\n    ITetuConverter converter_,\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    mapping(address => uint) storage liquidityThresholds_\\r\\n  ) internal view {\\r\\n    v.pool = IAlgebraPool(pairState.pool);\\r\\n    v.fuseAB = pairState.fuseAB;\\r\\n    v.converter = converter_;\\r\\n    v.tokenA = pairState.tokenA;\\r\\n    v.tokenB = pairState.tokenB;\\r\\n    v.isStablePool = pairState.isStablePool;\\r\\n    v.liquidationThresholdsAB[0] = AppLib._getLiquidationThreshold(liquidityThresholds_[v.tokenA]);\\r\\n    v.liquidationThresholdsAB[1] = AppLib._getLiquidationThreshold(liquidityThresholds_[v.tokenB]);\\r\\n    uint poolPriceDecimals = IERC20Metadata(v.tokenA).decimals();\\r\\n    v.poolPriceAdjustment = poolPriceDecimals < 18 ? 10**(18 - poolPriceDecimals) : 1;\\r\\n  }\\r\\n\\r\\n  /// @notice Get proportion of not-underlying in the pool, [0...1e18]\\r\\n  ///         prop.underlying : prop.not.underlying = 1e18 - PropNotUnderlying18 : propNotUnderlying18\\r\\n  function getPropNotUnderlying18(PairBasedStrategyLogicLib.PairState storage pairState) view external returns (uint) {\\r\\n    // get pool proportions\\r\\n    IAlgebraPool pool = IAlgebraPool(pairState.pool);\\r\\n    bool depositorSwapTokens = pairState.depositorSwapTokens;\\r\\n    (int24 newLowerTick, int24 newUpperTick) = AlgebraDebtLib._calcNewTickRange(pool, pairState.lowerTick, pairState.upperTick, pairState.tickSpacing);\\r\\n    (uint consumed0, uint consumed1) = AlgebraDebtLib.getEntryDataProportions(pool, newLowerTick, newUpperTick, depositorSwapTokens);\\r\\n\\r\\n    require(consumed0 + consumed1 > 0, AppErrors.ZERO_VALUE);\\r\\n    return consumed1 * 1e18 / (consumed0 + consumed1);\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Rebalance\\r\\n\\r\\n  //region ------------------------------------------------ WithdrawByAgg\\r\\n  /// @param addr_ [tokenToSwap, aggregator, controller, converter, splitter]\\r\\n  /// @param values_ [amountToSwap_, profitToCover, oldTotalAssets, entryToPool]\\r\\n  /// @return completed All debts were closed, leftovers were swapped to proper proportions\\r\\n  /// @return tokenAmountsOut Amounts to be deposited to pool. This array is empty if no deposit allowed/required.\\r\\n  function withdrawByAggStep(\\r\\n    IConverterStrategyBase.ConverterStrategyBaseState storage csbs,\\r\\n    address[5] calldata addr_,\\r\\n    uint[4] calldata values_,\\r\\n    bytes memory swapData,\\r\\n    bytes memory planEntryData,\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    mapping(address => uint) storage liquidationThresholds\\r\\n  ) external returns (\\r\\n    bool completed,\\r\\n    uint[] memory tokenAmountsOut\\r\\n  ) {\\r\\n    address[2] memory tokens = [pairState.tokenA, pairState.tokenB];\\r\\n\\r\\n    // Calculate amounts to be deposited to pool, calculate loss, fix profitToCover\\r\\n    uint[] memory tokenAmounts;\\r\\n    uint loss;\\r\\n    (completed, tokenAmounts, loss) = PairBasedStrategyLogicLib.withdrawByAggStep(addr_, values_, swapData, planEntryData, tokens, liquidationThresholds);\\r\\n\\r\\n    // cover loss\\r\\n    if (loss != 0) {\\r\\n      ConverterStrategyBaseLib2.coverLossAndCheckResults(\\r\\n        csbs,\\r\\n        addr_[4], // splitter\\r\\n        loss\\r\\n      );\\r\\n    }\\r\\n    emit RebalancedDebt(loss, values_[1], 0);\\r\\n\\r\\n    // uint entryToPool = values_[3];\\r\\n    if (values_[3] == PairBasedStrategyLib.ENTRY_TO_POOL_IS_ALLOWED\\r\\n      || (values_[3] == PairBasedStrategyLib.ENTRY_TO_POOL_IS_ALLOWED_IF_COMPLETED && completed)\\r\\n    ) {\\r\\n      // We are going to enter to the pool: update lowerTick and upperTick, initialize tokenAmountsOut\\r\\n      (pairState.lowerTick, pairState.upperTick) = AlgebraDebtLib._calcNewTickRange(\\r\\n        IAlgebraPool(pairState.pool),\\r\\n        pairState.lowerTick,\\r\\n        pairState.upperTick,\\r\\n        pairState.tickSpacing\\r\\n      );\\r\\n      tokenAmountsOut = tokenAmounts;\\r\\n    }\\r\\n\\r\\n    return (completed, tokenAmountsOut); // hide warning\\r\\n  }\\r\\n  //endregion ------------------------------------------------ WithdrawByAgg\\r\\n\\r\\n}\\r\\n\\r\\n\",\"keccak256\":\"0xd6666e9ac8b88d98d2b9e7b2cc161818f731ee92dc1475df6811bf5227f19126\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/algebra/AlgebraDebtLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"../ConverterStrategyBaseLib.sol\\\";\\r\\nimport \\\"../ConverterStrategyBaseLib2.sol\\\";\\r\\nimport \\\"./AlgebraLib.sol\\\";\\r\\nimport \\\"./AlgebraStrategyErrors.sol\\\";\\r\\nimport \\\"../../libs/BorrowLib.sol\\\";\\r\\nimport \\\"../pair/PairBasedStrategyLogicLib.sol\\\";\\r\\n\\r\\nlibrary AlgebraDebtLib {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n//region  -------------------------------------------- Constants\\r\\n  uint public constant SELL_GAP = 100;\\r\\n  address internal constant ONEINCH = 0x1111111254EEB25477B68fb85Ed929f73A960582; // 1inch router V5\\r\\n  address internal constant OPENOCEAN = 0x6352a56caadC4F1E25CD6c75970Fa768A3304e64; // OpenOceanExchangeProxy\\r\\n//endregion  -------------------------------------------- Constants\\r\\n\\r\\n//region  -------------------------------------------- Entry data\\r\\n  /// @notice Calculate proportions of the tokens for entry kind 1\\r\\n  /// @param pool Pool instance.\\r\\n  /// @param lowerTick The lower tick of the pool's main range.\\r\\n  /// @param upperTick The upper tick of the pool's main range.\\r\\n  /// @param depositorSwapTokens A boolean indicating if need to use token B instead of token A.\\r\\n  /// @return prop0 Proportion onf token A. Any decimals are allowed, prop[0 or 1]/(prop0 + prop1) are important only\\r\\n  /// @return prop1 Proportion onf token B. Any decimals are allowed, prop[0 or 1]/(prop0 + prop1) are important only\\r\\n  function getEntryDataProportions(\\r\\n    IAlgebraPool pool,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    bool depositorSwapTokens\\r\\n  ) internal view returns (uint, uint) {\\r\\n    address token1 = pool.token1();\\r\\n    uint token1Price = AlgebraLib.getPrice(address(pool), token1);\\r\\n\\r\\n    uint token1Decimals = IERC20Metadata(token1).decimals();\\r\\n\\r\\n    uint token0Desired = token1Price;\\r\\n    uint token1Desired = 10 ** token1Decimals;\\r\\n    require(token1Desired != 0, AppErrors.ZERO_VALUE);\\r\\n\\r\\n    // calculate proportions\\r\\n    (uint consumed0, uint consumed1,) = AlgebraLib.addLiquidityPreview(address(pool), lowerTick, upperTick, token0Desired, token1Desired);\\r\\n    return depositorSwapTokens\\r\\n      ? (1e18*consumed1 * token1Price / token1Desired, 1e18*consumed0)\\r\\n      : (1e18*consumed0, 1e18*consumed1 * token1Price / token1Desired);\\r\\n  }\\r\\n\\r\\n//endregion  -------------------------------------------- Entry data\\r\\n\\r\\n//region  -------------------------------------------- Calc tick range\\r\\n  function calcTickRange(IAlgebraPool pool, int24 tickRange, int24 tickSpacing) public view returns (int24 lowerTick, int24 upperTick) {\\r\\n    return PairBasedStrategyLogicLib.calcTickRange(getCurrentTick(pool), tickRange, tickSpacing);\\r\\n  }\\r\\n\\r\\n  function getCurrentTick(IAlgebraPool pool) public view returns(int24 tick) {\\r\\n    (, tick, , , , ,) = pool.globalState();\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate the new tick range for a Algebra pool, the tick is read from the pool.\\r\\n  /// @param pool The Algebra pool to calculate the new tick range for.\\r\\n  /// @param lowerTick The current lower tick value for the pool.\\r\\n  /// @param upperTick The current upper tick value for the pool.\\r\\n  /// @param tickSpacing The tick spacing for the pool.\\r\\n  /// @return lowerTickNew The new lower tick value for the pool.\\r\\n  /// @return upperTickNew The new upper tick value for the pool.\\r\\n  function _calcNewTickRange(\\r\\n    IAlgebraPool pool,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    int24 tickSpacing\\r\\n  ) internal view returns (int24 lowerTickNew, int24 upperTickNew) {\\r\\n    int24 currentTick = getCurrentTick(pool);\\r\\n    return _calcNewTickRangeForTick(currentTick, lowerTick, upperTick, tickSpacing);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate the new tick range for a Algebra pool, the tick is known.\\r\\n  function _calcNewTickRangeForTick(\\r\\n    int24 currentTick,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    int24 tickSpacing\\r\\n  ) internal pure returns (int24 lowerTickNew, int24 upperTickNew) {\\r\\n    int24 fullTickRange = upperTick - lowerTick;\\r\\n    int24 tickRange = fullTickRange == tickSpacing\\r\\n      ? int24(0)\\r\\n      : fullTickRange / 2;\\r\\n    return PairBasedStrategyLogicLib.calcTickRange(currentTick, tickRange, tickSpacing);\\r\\n  }\\r\\n//endregion  -------------------------------------------- Calc tick range\\r\\n\\r\\n//region  -------------------------------------------- Rebalance\\r\\n  /// @param liquidationThresholdsAB [liquidityThreshold of token A, liquidityThreshold of tokenB]\\r\\n  function rebalanceNoSwaps(\\r\\n    address[2] calldata converterLiquidator,\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    uint profitToCover,\\r\\n    uint totalAssets,\\r\\n    address splitter,\\r\\n    uint[2] calldata liquidationThresholdsAB,\\r\\n    int24 tick\\r\\n  ) external {\\r\\n    (int24 newLowerTick, int24 newUpperTick) = _calcNewTickRangeForTick(tick, pairState.lowerTick, pairState.upperTick, pairState.tickSpacing);\\r\\n    (uint prop0, uint prop1) = getEntryDataProportions(IAlgebraPool(pairState.pool), newLowerTick, newUpperTick, pairState.depositorSwapTokens);\\r\\n    PairBasedStrategyLogicLib._rebalanceNoSwaps(\\r\\n      converterLiquidator,\\r\\n      pairState,\\r\\n      profitToCover,\\r\\n      totalAssets,\\r\\n      splitter,\\r\\n  liquidationThresholdsAB,\\r\\n      prop0 * BorrowLib.SUM_PROPORTIONS / (prop0 + prop1)\\r\\n    );\\r\\n    (pairState.lowerTick, pairState.upperTick) = (newLowerTick, newUpperTick);\\r\\n  }\\r\\n//endregion  -------------------------------------------- Rebalance\\r\\n\\r\\n}\\r\\n\",\"keccak256\":\"0x50d9e3181249775760329e51f6614d3eb9d8e4dc89cddbbcdb04b3880a22e79d\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/algebra/AlgebraDepositor.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\\\";\\r\\nimport \\\"../DepositorBase.sol\\\";\\r\\nimport \\\"./AlgebraStrategyErrors.sol\\\";\\r\\nimport \\\"./AlgebraConverterStrategyLogicLib.sol\\\";\\r\\n\\r\\n\\r\\nabstract contract AlgebraDepositor is DepositorBase, Initializable {\\r\\n  using SafeERC20 for IERC20;\\r\\n\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n  ///                CONSTANTS\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n\\r\\n  /// @dev Version of this contract. Adjust manually on each code modification.\\r\\n  string public constant ALGEBRA_DEPOSITOR_VERSION = \\\"1.0.0\\\";\\r\\n\\r\\n  uint internal constant IDX_SS_NUMS_PROFIT_HOLDER_BALANCE_A = 0;\\r\\n  uint internal constant IDX_SS_NUMS_PROFIT_HOLDER_BALANCE_B = 1;\\r\\n  uint internal constant IDX_SS_NUMS_PROFIT_HOLDER_BALANCE_RT = 2;\\r\\n  uint internal constant IDX_SS_NUMS_PROFIT_HOLDER_BALANCE_BRT = 3;\\r\\n\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n  ///                VARIABLES\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n\\r\\n  /// @dev State variable to store the current state of the whole strategy\\r\\n  AlgebraConverterStrategyLogicLib.State internal state;\\r\\n\\r\\n  /// @dev reserve space for future needs\\r\\n  uint[100 - 65] private __gap;\\r\\n\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n  ///                       View\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n\\r\\n  /// @return nums Balances of [tokenA, tokenB, rewardToken, bonusRewardToken] for profit holder\\r\\n  function getSpecificState() external view returns (\\r\\n    uint[] memory nums\\r\\n  ) {\\r\\n    address profitHolder = state.pair.strategyProfitHolder;\\r\\n    nums = new uint[](4);\\r\\n    nums[IDX_SS_NUMS_PROFIT_HOLDER_BALANCE_A] = IERC20(state.pair.tokenA).balanceOf(profitHolder);\\r\\n    nums[IDX_SS_NUMS_PROFIT_HOLDER_BALANCE_B] = IERC20(state.pair.tokenB).balanceOf(profitHolder);\\r\\n    nums[IDX_SS_NUMS_PROFIT_HOLDER_BALANCE_RT] = IERC20(state.rewardToken).balanceOf(profitHolder);\\r\\n    nums[IDX_SS_NUMS_PROFIT_HOLDER_BALANCE_BRT] = IERC20(state.bonusRewardToken).balanceOf(profitHolder);\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the fees for the current state.\\r\\n  /// @return fee0 and fee1.\\r\\n  function getFees() public view returns (uint fee0, uint fee1) {\\r\\n    return AlgebraConverterStrategyLogicLib.getFees(state);\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the pool assets.\\r\\n  /// @return poolAssets An array containing the addresses of the pool assets.\\r\\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\\r\\n    poolAssets = new address[](2);\\r\\n    poolAssets[0] = state.pair.tokenA;\\r\\n    poolAssets[1] = state.pair.tokenB;\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the pool weights and the total weight.\\r\\n  /// @return weights An array containing the weights of the pool assets, and totalWeight the sum of the weights.\\r\\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\\r\\n    weights = new uint[](2);\\r\\n    weights[0] = 1;\\r\\n    weights[1] = 1;\\r\\n    totalWeight = 2;\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the pool reserves.\\r\\n  /// @return reserves An array containing the reserves of the pool assets.\\r\\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reserves) {\\r\\n    return AlgebraConverterStrategyLogicLib.getPoolReserves(state.pair);\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the current liquidity of the depositor.\\r\\n  /// @return The current liquidity of the depositor.\\r\\n  function _depositorLiquidity() override internal virtual view returns (uint) {\\r\\n    return uint(state.pair.totalLiquidity);\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the total supply of the depositor.\\r\\n  /// @return In UniV3 we can not calculate the total supply of the whole pool. Return only ourself value.\\r\\n  function _depositorTotalSupply() override internal view virtual returns (uint) {\\r\\n    return uint(state.pair.totalLiquidity);\\r\\n  }\\r\\n\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n  ///             Enter, exit\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n\\r\\n  /// @notice Handles the deposit operation.\\r\\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (uint[] memory amountsConsumed, uint liquidityOut) {\\r\\n    (amountsConsumed, liquidityOut) = AlgebraConverterStrategyLogicLib.enter(state, amountsDesired_);\\r\\n  }\\r\\n\\r\\n  /// @notice Handles the withdrawal operation.\\r\\n  /// @param liquidityAmount The amount of liquidity to be withdrawn.\\r\\n  /// @param emergency Emergency exit (only withdraw, don't claim any rewards or make any other additional actions)\\r\\n  /// @return amountsOut The amounts of the tokens withdrawn.\\r\\n  function _depositorExit(uint liquidityAmount, bool emergency) override internal virtual returns (uint[] memory amountsOut) {\\r\\n    amountsOut = AlgebraConverterStrategyLogicLib.exit(state, uint128(liquidityAmount), emergency);\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the amount of tokens that would be withdrawn based on the provided liquidity amount.\\r\\n  /// @param liquidityAmount The amount of liquidity to quote the withdrawal for.\\r\\n  /// @return amountsOut The amounts of the tokens that would be withdrawn.\\r\\n  function _depositorQuoteExit(uint liquidityAmount) override internal virtual returns (uint[] memory amountsOut) {\\r\\n    amountsOut = AlgebraConverterStrategyLogicLib.quoteExit(state.pair, uint128(liquidityAmount));\\r\\n  }\\r\\n\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n  ///             Claim rewards\\r\\n  /////////////////////////////////////////////////////////////////////\\r\\n\\r\\n  /// @notice Claims all possible rewards.\\r\\n  /// @return tokensOut An array containing the addresses of the reward tokens,\\r\\n  /// @return amountsOut An array containing the amounts of the reward tokens.\\r\\n  function _depositorClaimRewards() override internal virtual returns (\\r\\n    address[] memory tokensOut,\\r\\n    uint[] memory amountsOut,\\r\\n    uint[] memory balancesBefore\\r\\n  ) {\\r\\n    return AlgebraConverterStrategyLogicLib.claimRewards(state);\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x009e10b3d50e8b594bff96135380f91674d801a9049c4e69b755cdb39b2072aa\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/algebra/AlgebraLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"../../integrations/algebra/IAlgebraPool.sol\\\";\\r\\nimport \\\"../../integrations/algebra/INonfungiblePositionManager.sol\\\";\\r\\nimport \\\"../../integrations/algebra/IFarmingCenter.sol\\\";\\r\\nimport \\\"../../integrations/algebra/IncentiveKey.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\r\\n\\r\\nlibrary AlgebraLib {\\r\\n  int24 internal constant TICKSPACING = 60;\\r\\n  uint8 internal constant RESOLUTION = 96;\\r\\n  uint internal constant Q96 = 0x1000000000000000000000000;\\r\\n  uint private constant TWO_96 = 2 ** 96;\\r\\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\r\\n  uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\\r\\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\r\\n  uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\\r\\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\r\\n  int24 internal constant MIN_TICK = - 887272;\\r\\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\r\\n  int24 internal constant MAX_TICK = - MIN_TICK;\\r\\n\\r\\n  function tickSpacing() external pure returns (int24) {\\r\\n    return TICKSPACING;\\r\\n  }\\r\\n\\r\\n  function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\\r\\n    IAlgebraPool pool = IAlgebraPool(pool_);\\r\\n    (uint160 sqrtRatioX96, , , , , ,) = pool.globalState();\\r\\n    liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\\r\\n    (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\r\\n  /// pool prices and the prices at the tick boundaries\\r\\n  function getLiquidityForAmounts(\\r\\n    uint160 sqrtRatioX96,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    uint amount0,\\r\\n    uint amount1\\r\\n  ) public pure returns (uint128 liquidity) {\\r\\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\\r\\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n\\r\\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\\r\\n      liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\\r\\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\\r\\n      uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\\r\\n      uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\\r\\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\r\\n    } else {\\r\\n      liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\r\\n  /// pool prices and the prices at the tick boundaries\\r\\n  function getAmountsForLiquidity(\\r\\n    uint160 sqrtRatioX96,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    uint128 liquidity\\r\\n  ) public pure returns (uint amount0, uint amount1) {\\r\\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\\r\\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\\r\\n\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n\\r\\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\\r\\n      amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\r\\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\\r\\n      amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\\r\\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\\r\\n    } else {\\r\\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\\r\\n  /// @param a The multiplicand\\r\\n  /// @param b The multiplier\\r\\n  /// @param denominator The divisor\\r\\n  /// @return result The 256-bit result\\r\\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\r\\n  function mulDiv(\\r\\n    uint a,\\r\\n    uint b,\\r\\n    uint denominator\\r\\n  ) public pure returns (uint result) {\\r\\n    unchecked {\\r\\n      // 512-bit multiply [prod1 prod0] = a * b\\r\\n      // Compute the product mod 2**256 and mod 2**256 - 1\\r\\n      // then use the Chinese Remainder Theorem to reconstruct\\r\\n      // the 512 bit result. The result is stored in two 256\\r\\n      // variables such that product = prod1 * 2**256 + prod0\\r\\n      uint prod0;\\r\\n      // Least significant 256 bits of the product\\r\\n      uint prod1;\\r\\n      // Most significant 256 bits of the product\\r\\n      assembly {\\r\\n        let mm := mulmod(a, b, not(0))\\r\\n        prod0 := mul(a, b)\\r\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n      }\\r\\n\\r\\n      // Handle non-overflow cases, 256 by 256 division\\r\\n      if (prod1 == 0) {\\r\\n        require(denominator > 0);\\r\\n        assembly {\\r\\n          result := div(prod0, denominator)\\r\\n        }\\r\\n        return result;\\r\\n      }\\r\\n\\r\\n      // Make sure the result is less than 2**256.\\r\\n      // Also prevents denominator == 0\\r\\n      require(denominator > prod1);\\r\\n\\r\\n      ///////////////////////////////////////////////\\r\\n      // 512 by 256 division.\\r\\n      ///////////////////////////////////////////////\\r\\n\\r\\n      // Make division exact by subtracting the remainder from [prod1 prod0]\\r\\n      // Compute remainder using mulmod\\r\\n      uint remainder;\\r\\n      assembly {\\r\\n        remainder := mulmod(a, b, denominator)\\r\\n      }\\r\\n      // Subtract 256 bit number from 512 bit number\\r\\n      assembly {\\r\\n        prod1 := sub(prod1, gt(remainder, prod0))\\r\\n        prod0 := sub(prod0, remainder)\\r\\n      }\\r\\n\\r\\n      // Factor powers of two out of denominator\\r\\n      // Compute largest power of two divisor of denominator.\\r\\n      // Always >= 1.\\r\\n      // EDIT for 0.8 compatibility:\\r\\n      // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\\r\\n      uint twos = denominator & (~denominator + 1);\\r\\n\\r\\n      // Divide denominator by power of two\\r\\n      assembly {\\r\\n        denominator := div(denominator, twos)\\r\\n      }\\r\\n\\r\\n      // Divide [prod1 prod0] by the factors of two\\r\\n      assembly {\\r\\n        prod0 := div(prod0, twos)\\r\\n      }\\r\\n      // Shift in bits from prod1 into prod0. For this we need\\r\\n      // to flip `twos` such that it is 2**256 / twos.\\r\\n      // If twos is zero, then it becomes one\\r\\n      assembly {\\r\\n        twos := add(div(sub(0, twos), twos), 1)\\r\\n      }\\r\\n      prod0 |= prod1 * twos;\\r\\n\\r\\n      // Invert denominator mod 2**256\\r\\n      // Now that denominator is an odd number, it has an inverse\\r\\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\r\\n      // Compute the inverse by starting with a seed that is correct\\r\\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\\r\\n      uint inv = (3 * denominator) ^ 2;\\r\\n      // Now use Newton-Raphson iteration to improve the precision.\\r\\n      // Thanks to Hensel's lifting lemma, this also works in modular\\r\\n      // arithmetic, doubling the correct bits in each step.\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**8\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**16\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**32\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**64\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**128\\r\\n      inv *= 2 - denominator * inv;\\r\\n      // inverse mod 2**256\\r\\n\\r\\n      // Because the division is now exact we can divide by multiplying\\r\\n      // with the modular inverse of denominator. This will give us the\\r\\n      // correct result modulo 2**256. Since the precoditions guarantee\\r\\n      // that the outcome is less than 2**256, this is the final result.\\r\\n      // We don't need to compute the high bits of the result and prod1\\r\\n      // is no longer required.\\r\\n      result = prod0 * inv;\\r\\n      return result;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\\r\\n  /// @param a The multiplicand\\r\\n  /// @param b The multiplier\\r\\n  /// @param denominator The divisor\\r\\n  /// @return result The 256-bit result\\r\\n  function mulDivRoundingUp(\\r\\n    uint a,\\r\\n    uint b,\\r\\n    uint denominator\\r\\n  ) internal pure returns (uint result) {\\r\\n    result = mulDiv(a, b, denominator);\\r\\n    if (mulmod(a, b, denominator) > 0) {\\r\\n      require(result < type(uint).max);\\r\\n      result++;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates price in pool\\r\\n  /// @return price with decimals of paired token\\r\\n  function getPrice(address pool_, address tokenIn) public view returns (uint) {\\r\\n    IAlgebraPool pool = IAlgebraPool(pool_);\\r\\n    address token0 = pool.token0();\\r\\n    address token1 = pool.token1();\\r\\n\\r\\n    uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\\r\\n    uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\\r\\n    (uint160 sqrtPriceX96,,,,,,) = pool.globalState();\\r\\n\\r\\n    uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\\r\\n\\r\\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\\r\\n    uint purePrice;\\r\\n    uint precision;\\r\\n    if (tokenIn == token0) {\\r\\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\\r\\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\\r\\n      purePrice = part * part;\\r\\n    } else {\\r\\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\\r\\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\\r\\n      purePrice = part * part;\\r\\n    }\\r\\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\\r\\n  }\\r\\n\\r\\n  function getFees(IAlgebraPool pool, INonfungiblePositionManager nft, uint tokenId) public view returns (uint fee0, uint fee1) {\\r\\n    (, int24 tick, , , , ,) = pool.globalState();\\r\\n    (,,,,int24 lowerTick,int24 upperTick,uint128 liquidity,uint feeGrowthInside0Last, uint feeGrowthInside1Last, uint128 tokensOwed0, uint128 tokensOwed1) = nft.positions(tokenId);\\r\\n    fee0 = _computeFeesEarned(pool, lowerTick, upperTick, liquidity, true, feeGrowthInside0Last, tick) + uint(tokensOwed0);\\r\\n    fee1 = _computeFeesEarned(pool, lowerTick, upperTick, liquidity, false, feeGrowthInside1Last, tick) + uint(tokensOwed1);\\r\\n  }\\r\\n\\r\\n  function _computeFeesEarned(\\r\\n    IAlgebraPool pool,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    uint128 liquidity,\\r\\n    bool isZero,\\r\\n    uint feeGrowthInsideLast,\\r\\n    int24 tick\\r\\n  ) internal view returns (uint fee) {\\r\\n    uint feeGrowthOutsideLower;\\r\\n    uint feeGrowthOutsideUpper;\\r\\n    uint feeGrowthGlobal;\\r\\n    if (isZero) {\\r\\n      feeGrowthGlobal = pool.totalFeeGrowth0Token();\\r\\n      (,, feeGrowthOutsideLower,,,,,) = pool.ticks(lowerTick);\\r\\n      (,, feeGrowthOutsideUpper,,,,,) = pool.ticks(upperTick);\\r\\n    } else {\\r\\n      feeGrowthGlobal = pool.totalFeeGrowth1Token();\\r\\n      (,,, feeGrowthOutsideLower,,,,) = pool.ticks(lowerTick);\\r\\n      (,,, feeGrowthOutsideUpper,,,,) = pool.ticks(upperTick);\\r\\n    }\\r\\n\\r\\n    unchecked {\\r\\n      // calculate fee growth below\\r\\n      uint feeGrowthBelow;\\r\\n      if (tick >= lowerTick) {\\r\\n        feeGrowthBelow = feeGrowthOutsideLower;\\r\\n      } else {\\r\\n        feeGrowthBelow = feeGrowthGlobal - feeGrowthOutsideLower;\\r\\n      }\\r\\n      // calculate fee growth above\\r\\n      uint feeGrowthAbove;\\r\\n      if (tick < upperTick) {\\r\\n        feeGrowthAbove = feeGrowthOutsideUpper;\\r\\n      } else {\\r\\n        feeGrowthAbove = feeGrowthGlobal - feeGrowthOutsideUpper;\\r\\n      }\\r\\n\\r\\n      uint feeGrowthInside = feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove;\\r\\n      fee = mulDiv(\\r\\n        liquidity,\\r\\n        feeGrowthInside - feeGrowthInsideLast,\\r\\n        0x100000000000000000000000000000000\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\r\\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param amount0 The amount0 being sent in\\r\\n  /// @return liquidity The amount of returned liquidity\\r\\n  function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\\r\\n    return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\r\\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param amount1 The amount1 being sent in\\r\\n  /// @return liquidity The amount of returned liquidity\\r\\n  function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param liquidity The liquidity being valued\\r\\n  /// @return amount0 The amount0\\r\\n  function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\\r\\n  }\\r\\n\\r\\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\r\\n  /// @param sqrtRatioAX96 A sqrt price\\r\\n  /// @param sqrtRatioBX96 Another sqrt price\\r\\n  /// @param liquidity The liquidity being valued\\r\\n  /// @return amount1 The amount1\\r\\n  function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\\r\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\r\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\r\\n    }\\r\\n    return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\\r\\n  }\\r\\n\\r\\n  function _countDigits(uint n) internal pure returns (uint) {\\r\\n    if (n == 0) {\\r\\n      return 0;\\r\\n    }\\r\\n    uint count = 0;\\r\\n    while (n != 0) {\\r\\n      n = n / 10;\\r\\n      ++count;\\r\\n    }\\r\\n    return count;\\r\\n  }\\r\\n\\r\\n  function _min(uint a, uint b) internal pure returns (uint) {\\r\\n    return a < b ? a : b;\\r\\n  }\\r\\n\\r\\n  function _max(uint a, uint b) internal pure returns (uint) {\\r\\n    return a > b ? a : b;\\r\\n  }\\r\\n\\r\\n  function _toUint128(uint x) private pure returns (uint128 y) {\\r\\n    require((y = uint128(x)) == x);\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\\r\\n  /// @dev Throws if |tick| > max tick\\r\\n  /// @param tick The input tick for the above formula\\r\\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\r\\n  /// at the given tick\\r\\n  function _getSqrtRatioAtTick(int24 tick)\\r\\n  internal\\r\\n  pure\\r\\n  returns (uint160 sqrtPriceX96)\\r\\n  {\\r\\n    uint256 absTick =\\r\\n      tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\\r\\n\\r\\n    // EDIT: 0.8 compatibility\\r\\n    require(absTick <= uint256(int256(MAX_TICK)), \\\"T\\\");\\r\\n\\r\\n    uint256 ratio =\\r\\n      absTick & 0x1 != 0\\r\\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\\r\\n        : 0x100000000000000000000000000000000;\\r\\n    if (absTick & 0x2 != 0)\\r\\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\r\\n    if (absTick & 0x4 != 0)\\r\\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\r\\n    if (absTick & 0x8 != 0)\\r\\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\r\\n    if (absTick & 0x10 != 0)\\r\\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\r\\n    if (absTick & 0x20 != 0)\\r\\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\r\\n    if (absTick & 0x40 != 0)\\r\\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\r\\n    if (absTick & 0x80 != 0)\\r\\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\r\\n    if (absTick & 0x100 != 0)\\r\\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\r\\n    if (absTick & 0x200 != 0)\\r\\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\r\\n    if (absTick & 0x400 != 0)\\r\\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\r\\n    if (absTick & 0x800 != 0)\\r\\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\r\\n    if (absTick & 0x1000 != 0)\\r\\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\r\\n    if (absTick & 0x2000 != 0)\\r\\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\r\\n    if (absTick & 0x4000 != 0)\\r\\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\r\\n    if (absTick & 0x8000 != 0)\\r\\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\r\\n    if (absTick & 0x10000 != 0)\\r\\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\r\\n    if (absTick & 0x20000 != 0)\\r\\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\r\\n    if (absTick & 0x40000 != 0)\\r\\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\r\\n    if (absTick & 0x80000 != 0)\\r\\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\r\\n\\r\\n    if (tick > 0) ratio = type(uint256).max / ratio;\\r\\n\\r\\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\r\\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\r\\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\r\\n    sqrtPriceX96 = uint160(\\r\\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\r\\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\r\\n  /// ever return.\\r\\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\r\\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\r\\n  function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\r\\n    // second inequality must be < because the price can never reach the price at the max tick\\r\\n    require(\\r\\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\\r\\n      \\\"R\\\"\\r\\n    );\\r\\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\\r\\n\\r\\n    uint256 r = ratio;\\r\\n    uint256 msb = 0;\\r\\n\\r\\n    assembly {\\r\\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(5, gt(r, 0xFFFFFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(4, gt(r, 0xFFFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(3, gt(r, 0xFF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(2, gt(r, 0xF))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := shl(1, gt(r, 0x3))\\r\\n      msb := or(msb, f)\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      let f := gt(r, 0x1)\\r\\n      msb := or(msb, f)\\r\\n    }\\r\\n\\r\\n    if (msb >= 128) r = ratio >> (msb - 127);\\r\\n    else r = ratio << (127 - msb);\\r\\n\\r\\n    int256 log_2 = (int256(msb) - 128) << 64;\\r\\n\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(63, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(62, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(61, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(60, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(59, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(58, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(57, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(56, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(55, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(54, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(53, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(52, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(51, f))\\r\\n      r := shr(f, r)\\r\\n    }\\r\\n    assembly {\\r\\n      r := shr(127, mul(r, r))\\r\\n      let f := shr(128, r)\\r\\n      log_2 := or(log_2, shl(50, f))\\r\\n    }\\r\\n\\r\\n    tick = _getFinalTick(log_2, sqrtPriceX96);\\r\\n  }\\r\\n\\r\\n  function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\r\\n    // 128.128 number\\r\\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\\r\\n\\r\\n    int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\r\\n    int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\r\\n\\r\\n    tick = (tickLow == tickHi)\\r\\n      ? tickLow\\r\\n      : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow);\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x177e22910ca9ac7f1cec711cf1acc69590ec263756b1f9659734fbc0a0a1f744\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/algebra/AlgebraStrategyErrors.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nlibrary AlgebraStrategyErrors {\\r\\n\\r\\n  string public constant NEED_REBALANCE = \\\"AS-1 Need rebalance\\\";\\r\\n  string public constant WRONG_BALANCE = \\\"AS-2 Wrong balance\\\";\\r\\n  string public constant INCORRECT_TICK_RANGE = \\\"AS-3 Incorrect tickRange\\\";\\r\\n  string public constant INCORRECT_REBALANCE_TICK_RANGE = \\\"AS-4 Incorrect rebalanceTickRange\\\";\\r\\n  string public constant INCORRECT_ASSET = \\\"AS-5 Incorrect asset\\\";\\r\\n  string public constant WRONG_FEE = \\\"AS-6 Wrong fee\\\";\\r\\n  string public constant WRONG_LIQUIDITY = \\\"AS-7 Wrong liquidity\\\";\\r\\n  string public constant NO_REBALANCE_NEEDED = \\\"AS-9 No rebalance needed\\\";\\r\\n  string public constant BALANCE_LOWER_THAN_FEE = \\\"AS-10 Balance lower than fee\\\";\\r\\n  string public constant NOT_CALLBACK_CALLER = \\\"AS-11 Not callback caller\\\";\\r\\n  string public constant ZERO_PROFIT_HOLDER = \\\"AS-13 Zero strategy profit holder\\\";\\r\\n  string public constant FUSE_IS_ACTIVE = \\\"AS-14 Fuse is active\\\";\\r\\n}\\r\\n\",\"keccak256\":\"0x203fb059702ec39aa716497f14e292a6082b3ac810af7415e449c3c1da5ca258\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/pair/PairBasedStrategyLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\r\\nimport \\\"../ConverterStrategyBaseLib.sol\\\";\\r\\nimport \\\"../../interfaces/IPoolProportionsProvider.sol\\\";\\r\\nimport \\\"../../libs/BorrowLib.sol\\\";\\r\\n\\r\\n/// @notice Library for the UniV3-like strategies with two tokens in the pool\\r\\n/// @dev The library contains quoteWithdrawStep/withdrawStep-related logic\\r\\nlibrary PairBasedStrategyLib {\\r\\n  //region ------------------------------------------------ Constants\\r\\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\\r\\n  /// @notice In all functions below array {token} contains underlying at the first position\\r\\n  uint internal constant IDX_ASSET = 0;\\r\\n  /// @notice In all functions below array {token} contains not-underlying at the second position\\r\\n  uint internal constant IDX_TOKEN = 1;\\r\\n\\r\\n  uint internal constant IDX_SWAP_1 = 0;\\r\\n  uint internal constant IDX_REPAY_1 = 1;\\r\\n  uint internal constant IDX_SWAP_2 = 2;\\r\\n  uint internal constant IDX_REPAY_2 = 3;\\r\\n\\r\\n  /// @notice A gap to reduce AmountToSwap calculated inside quoteWithdrawByAgg, [0...100_000]\\r\\n  uint public constant GAP_AMOUNT_TO_SWAP = 100;\\r\\n\\r\\n  /// @notice Enter to the pool at the end of withdrawByAggStep\\r\\n  uint public constant ENTRY_TO_POOL_IS_ALLOWED = 1;\\r\\n  /// @notice Enter to the pool at the end of withdrawByAggStep only if full withdrawing has been completed\\r\\n  uint public constant ENTRY_TO_POOL_IS_ALLOWED_IF_COMPLETED = 2;\\r\\n\\r\\n  /// @notice Fuse thresholds are set as array: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\\r\\n  ///         If the price falls below LOWER_LIMIT_ON the fuse is turned ON\\r\\n  ///         When the prices raises back and reaches LOWER_LIMIT_OFF, the fuse is turned OFF\\r\\n  ///         In the same way, if the price raises above UPPER_LIMIT_ON the fuse is turned ON\\r\\n  ///         When the prices falls back and reaches UPPER_LIMIT_OFF, the fuse is turned OFF\\r\\n  ///\\r\\n  ///         Example: [0.9, 0.92, 1.08, 1.1]\\r\\n  ///         Price falls below 0.9 - fuse is ON. Price rises back up to 0.92 - fuse is OFF.\\r\\n  ///         Price raises more and reaches 1.1 - fuse is ON again. Price falls back and reaches 1.08 - fuse OFF again.\\r\\n  uint public constant FUSE_IDX_LOWER_LIMIT_ON = 0;\\r\\n  uint public constant FUSE_IDX_LOWER_LIMIT_OFF = 1;\\r\\n  uint public constant FUSE_IDX_UPPER_LIMIT_ON = 2;\\r\\n  uint public constant FUSE_IDX_UPPER_LIMIT_OFF = 3;\\r\\n\\r\\n  uint public constant IDX_ADDR_DEFAULT_STATE_TOKEN_A = 0;\\r\\n  uint public constant IDX_ADDR_DEFAULT_STATE_TOKEN_B = 1;\\r\\n  uint public constant IDX_ADDR_DEFAULT_STATE_POOL = 2;\\r\\n  uint public constant IDX_ADDR_DEFAULT_STATE_PROFIT_HOLDER = 3;\\r\\n\\r\\n  uint public constant IDX_TICK_DEFAULT_STATE_TICK_SPACING = 0;\\r\\n  uint public constant IDX_TICK_DEFAULT_STATE_LOWER_TICK = 1;\\r\\n  uint public constant IDX_TICK_DEFAULT_STATE_UPPER_TICK = 2;\\r\\n  uint public constant IDX_TICK_DEFAULT_STATE_REBALANCE_TICK_RANGE = 3;\\r\\n\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_TOTAL_LIQUIDITY = 0;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_FUSE_STATUS = 1;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_RESERVED_0 = 2;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_WITHDRAW_DONE = 3;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_0 = 4;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_1 = 5;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_2 = 6;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_3 = 7;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_RESERVED_1 = 8;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_RESERVED_2 = 9;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_RESERVED_3 = 10;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_RESERVED_4 = 11;\\r\\n  uint public constant IDX_NUMS_DEFAULT_STATE_LAST_REBALANCE_NO_SWAP = 12;\\r\\n\\r\\n  uint public constant IDX_BOOL_VALUES_DEFAULT_STATE_IS_STABLE_POOL = 0;\\r\\n  uint public constant IDX_BOOL_VALUES_DEFAULT_STATE_DEPOSITOR_SWAP_TOKENS = 1;\\r\\n\\r\\n  /// @notice 1inch router V5 (Polygon, Base)\\r\\n  address internal constant ONEINCH = 0x1111111254EEB25477B68fb85Ed929f73A960582;\\r\\n  /// @notice OpenOceanExchangeProxy (Polygon and many other chains)\\r\\n  /// @dev See https://docs.openocean.finance/dev/contracts-of-chains\\r\\n  address internal constant OPENOCEAN = 0x6352a56caadC4F1E25CD6c75970Fa768A3304e64;\\r\\n  /// @notice OpenOceanExchangeProxy (zkEVM)\\r\\n  /// @dev See https://docs.openocean.finance/dev/contracts-of-chains\\r\\n  address internal constant OPENOCEAN_ZKEVM = 0x6dd434082EAB5Cd134B33719ec1FF05fE985B97b;\\r\\n\\r\\n  string public constant UNKNOWN_SWAP_ROUTER = \\\"PBS-1 Unknown router\\\";\\r\\n  string public constant INCORRECT_TICK_RANGE = \\\"PBS-3 Incorrect tickRange\\\";\\r\\n  string public constant INCORRECT_REBALANCE_TICK_RANGE = \\\"PBS-4 Incorrect rebalanceTickRange\\\";\\r\\n  string public constant INCORRECT_ASSET = \\\"PBS-5 Incorrect asset\\\";\\r\\n\\r\\n  //endregion ------------------------------------------------ Constants\\r\\n\\r\\n  //region ------------------------------------------------ Data types\\r\\n  /// @notice The fuse is triggered when the price rises above or falls below the limit 1.\\r\\n  ///         If the fuse was triggered, all assets are withdrawn from the pool on the strategy balance.\\r\\n  ///         Then all debts should be closed and all assets should be converted to underlying.\\r\\n  ///         The fuse is turned off automatically when the price falls below or rises above the limit 2\\r\\n  ///         and all assets are deposited back to the pool.\\r\\n  enum FuseStatus {\\r\\n    /// @notice Fuse is not used at all\\r\\n    FUSE_DISABLED_0,\\r\\n    /// @notice Fuse is not triggered, assets are deposited to the pool\\r\\n    FUSE_OFF_1,\\r\\n    /// @notice Fuse was triggered by lower limit, assets was withdrawn from the pool, but active debts can exist\\r\\n    FUSE_ON_LOWER_LIMIT_2,\\r\\n    /// @notice Fuse was triggered by upper limit, assets was withdrawn from the pool, but active debts can exist\\r\\n    FUSE_ON_UPPER_LIMIT_3\\r\\n  }\\r\\n\\r\\n  struct SwapByAggParams {\\r\\n    bool useLiquidator;\\r\\n    address tokenToSwap;\\r\\n    /// @notice Aggregator to make swap\\r\\n    ///         It is 0 if useLiquidator is true\\r\\n    ///         It can be equal to address of liquidator if we use liquidator as aggregator (in tests)\\r\\n    address aggregator;\\r\\n    uint amountToSwap;\\r\\n    /// @notice Swap-data prepared off-chain (route, amounts, etc). 0 - use liquidator to make swap\\r\\n    bytes swapData;\\r\\n  }\\r\\n\\r\\n  struct GetAmountToRepay2Local {\\r\\n    uint x;\\r\\n    uint y;\\r\\n    uint c0;\\r\\n    uint b0;\\r\\n    uint alpha;\\r\\n    int b;\\r\\n  }\\r\\n\\r\\n  struct FuseStateParams {\\r\\n    FuseStatus status;\\r\\n    /// @notice Price thresholds [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\\r\\n    /// @dev see PairBasedStrategyLib.FUSE_IDX_XXX\\r\\n    uint[4] thresholds;\\r\\n\\r\\n    /// @notice reserve space for future needs\\r\\n    uint[4] __gap;\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Data types\\r\\n\\r\\n  //region ------------------------------------------------ Events\\r\\n  event FuseStatusChanged(uint fuseStatus);\\r\\n  event NewFuseThresholds(uint[4] newFuseThresholds);\\r\\n  event SwapByAgg(\\r\\n    uint amountToSwap,\\r\\n    uint amountIn,\\r\\n    uint amountOut,\\r\\n    uint expectedAmountOut,\\r\\n    address aggregator,\\r\\n    address assetIn,\\r\\n    address assetOut\\r\\n  );\\r\\n  //endregion ------------------------------------------------ Events\\r\\n\\r\\n  //region ------------------------------------------------ External withdraw functions\\r\\n\\r\\n  /// @notice Get info for the swap that will be made on the next call of {withdrawStep}\\r\\n  /// @param converterLiquidator_ [TetuConverter, TetuLiquidator]\\r\\n  /// @param tokens Tokens used by depositor (length == 2: underlying and not-underlying)\\r\\n  /// @param liquidationThresholds Liquidation thresholds for the {tokens}\\r\\n  /// @param entryDataValues [propNotUnderlying18, entryDataParam]\\r\\n  ///     propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n  ///                           The leftovers should be swapped to get following result proportions of the assets:\\r\\n  ///                           not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\r\\n  ///                            Value type(uint).max means that the proportions should be read from the pool.\\r\\n  ///     entryDataParam It contains \\\"required-amount-to-reduce-debt\\\" in REPAY-SWAP-REPAY case\\r\\n  /// @param amountsFromPool Amounts of {tokens} that will be received from the pool before calling withdraw\\r\\n  /// @return tokenToSwap Address of the token that will be swapped on the next swap. 0 - no swap\\r\\n  /// @return amountToSwap Amount that will be swapped on the next swap. 0 - no swap\\r\\n  ///                      This amount is NOT reduced on {GAP_AMOUNT_TO_SWAP}, it should be reduced after the call if necessary.\\r\\n  function quoteWithdrawStep(\\r\\n    address[2] memory converterLiquidator_,\\r\\n    address[] memory tokens,\\r\\n    uint[] memory liquidationThresholds,\\r\\n    uint[] memory amountsFromPool,\\r\\n    uint planKind,\\r\\n    uint[2] memory entryDataValues\\r\\n  ) external returns (\\r\\n    address tokenToSwap,\\r\\n    uint amountToSwap\\r\\n  ){\\r\\n    (uint[] memory prices,\\r\\n      uint[] memory decs\\r\\n    ) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(ITetuConverter(converterLiquidator_[0])), tokens, 2);\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p = IterationPlanLib.SwapRepayPlanParams({\\r\\n      converter: ITetuConverter(converterLiquidator_[0]),\\r\\n      liquidator: ITetuLiquidator(converterLiquidator_[1]),\\r\\n      tokens: tokens,\\r\\n      liquidationThresholds: liquidationThresholds,\\r\\n      propNotUnderlying18: entryDataValues[0] == type(uint).max\\r\\n        ? IPoolProportionsProvider(address(this)).getPropNotUnderlying18()\\r\\n        : entryDataValues[0],\\r\\n      prices: prices,\\r\\n      decs: decs,\\r\\n      balanceAdditions: amountsFromPool,\\r\\n      planKind: planKind,\\r\\n      usePoolProportions: entryDataValues[0] == type(uint).max,\\r\\n      entryDataParam: entryDataValues[1]\\r\\n    });\\r\\n    return _quoteWithdrawStep(p);\\r\\n  }\\r\\n\\r\\n  /// @notice Make withdraw step with 0 or 1 swap only. The step can make one of the following actions:\\r\\n  ///         1) repay direct debt 2) repay reverse debt 3) final swap leftovers of not-underlying asset\\r\\n  /// @param converterLiquidator_ [TetuConverter, TetuLiquidator]\\r\\n  /// @param tokens Tokens used by depositor (length == 2: underlying and not-underlying)\\r\\n  /// @param liquidationThresholds Liquidation thresholds for the {tokens}\\r\\n  /// @param tokenToSwap_ Address of the token that will be swapped on the next swap. 0 - no swap\\r\\n  /// @param amountToSwap_ Amount that will be swapped on the next swap. 0 - no swap\\r\\n  /// @param aggregator_ Aggregator that should be used for the next swap. 0 - no swap\\r\\n  /// @param swapData_ Swap data to be passed to the aggregator on the next swap.\\r\\n  ///                  Swap data contains swap-route, amount and all other required info for the swap.\\r\\n  ///                  Swap data should be prepared on-chain on the base of data received by {quoteWithdrawStep}\\r\\n  /// @param useLiquidator_ Use liquidator instead of aggregator.\\r\\n  ///                       Aggregator swaps amount reduced on {GAP_AMOUNT_TO_SWAP}.\\r\\n  ///                       Liquidator doesn't use {GAP_AMOUNT_TO_SWAP}.\\r\\n  ///                       It's allowed to pass liquidator address in {aggregator_} and set {useLiquidator_} to false -\\r\\n  ///                       the liquidator will be used in same way as aggregator in this case.\\r\\n  /// @param planKind One of IterationPlanLib.PLAN_XXX\\r\\n  /// @param entryDataValues [propNotUnderlying18, entryDataParam]\\r\\n  ///     propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\r\\n  ///                           The leftovers should be swapped to get following result proportions of the assets:\\r\\n  ///                           not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\r\\n  ///     entryDataParam It contains \\\"required-amount-to-reduce-debt\\\" in REPAY-SWAP-REPAY case\\r\\n  /// @return completed All debts were closed, leftovers were swapped to the required proportions\\r\\n  function withdrawStep(\\r\\n    address[2] memory converterLiquidator_,\\r\\n    address[] memory tokens,\\r\\n    uint[] memory liquidationThresholds,\\r\\n    address tokenToSwap_,\\r\\n    uint amountToSwap_,\\r\\n    address aggregator_,\\r\\n    bytes memory swapData_,\\r\\n    bool useLiquidator_,\\r\\n    uint planKind,\\r\\n    uint[2] memory entryDataValues\\r\\n  ) external returns (\\r\\n    bool completed\\r\\n  ){\\r\\n    (uint[] memory prices,\\r\\n      uint[] memory decs\\r\\n    ) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(ITetuConverter(converterLiquidator_[0])), tokens, 2);\\r\\n\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p = IterationPlanLib.SwapRepayPlanParams({\\r\\n      converter: ITetuConverter(converterLiquidator_[0]),\\r\\n      liquidator: ITetuLiquidator(converterLiquidator_[1]),\\r\\n      tokens: tokens,\\r\\n      liquidationThresholds: liquidationThresholds,\\r\\n      propNotUnderlying18: entryDataValues[0] == type(uint).max\\r\\n        ? IPoolProportionsProvider(address(this)).getPropNotUnderlying18()\\r\\n        : entryDataValues[0],\\r\\n      prices: prices,\\r\\n      decs: decs,\\r\\n      balanceAdditions: new uint[](2), // 2 = tokens.length\\r\\n      planKind: planKind,\\r\\n      usePoolProportions: entryDataValues[0] == type(uint).max,\\r\\n      entryDataParam: entryDataValues[1]\\r\\n    });\\r\\n    SwapByAggParams memory aggParams = SwapByAggParams({\\r\\n      tokenToSwap: tokenToSwap_,\\r\\n      amountToSwap: amountToSwap_,\\r\\n      useLiquidator: useLiquidator_,\\r\\n      aggregator: aggregator_,\\r\\n      swapData: swapData_\\r\\n    });\\r\\n    return _withdrawStep(p, aggParams);\\r\\n  }\\r\\n  //endregion ------------------------------------------------ External withdraw functions\\r\\n\\r\\n  //region ------------------------------------------------ Fuse functions\\r\\n  function setFuseStatus(FuseStateParams storage fuse, FuseStatus status) external {\\r\\n    fuse.status = status;\\r\\n    emit FuseStatusChanged(uint(status));\\r\\n  }\\r\\n\\r\\n  function setFuseThresholds(FuseStateParams storage state, uint[4] memory values) external {\\r\\n    require(\\r\\n      (values[FUSE_IDX_LOWER_LIMIT_ON] == 0 && values[FUSE_IDX_LOWER_LIMIT_OFF] == 0)\\r\\n      || (values[FUSE_IDX_LOWER_LIMIT_ON] <= values[FUSE_IDX_LOWER_LIMIT_OFF]),\\r\\n      AppErrors.INVALID_VALUE\\r\\n    );\\r\\n    require(\\r\\n      (values[FUSE_IDX_UPPER_LIMIT_ON] == 0 && values[FUSE_IDX_UPPER_LIMIT_OFF] == 0)\\r\\n      || (values[FUSE_IDX_UPPER_LIMIT_ON] >= values[FUSE_IDX_UPPER_LIMIT_OFF]),\\r\\n      AppErrors.INVALID_VALUE\\r\\n    );\\r\\n    if (values[FUSE_IDX_LOWER_LIMIT_ON] != 0 && values[FUSE_IDX_UPPER_LIMIT_ON] != 0) {\\r\\n      require(\\r\\n        values[FUSE_IDX_UPPER_LIMIT_ON] > values[FUSE_IDX_LOWER_LIMIT_ON],\\r\\n        AppErrors.INVALID_VALUE\\r\\n      );\\r\\n    }\\r\\n    state.thresholds = values;\\r\\n    emit NewFuseThresholds(values);\\r\\n  }\\r\\n\\r\\n  function isFuseTriggeredOn(PairBasedStrategyLib.FuseStatus fuseStatus) internal pure returns (bool) {\\r\\n    return uint(fuseStatus) > uint(PairBasedStrategyLib.FuseStatus.FUSE_OFF_1);\\r\\n  }\\r\\n\\r\\n  /// @notice Check if the fuse should be turned ON/OFF\\r\\n  /// @param price Current price in the oracle\\r\\n  /// @param poolPrice Current price in the pool\\r\\n  /// @return needToChange A boolean indicating if the fuse status should be changed\\r\\n  /// @return status Exist fuse status or new fuse status (if needToChange is true)\\r\\n  function needChangeFuseStatus(FuseStateParams memory fuse, uint price, uint poolPrice) internal pure returns (\\r\\n    bool needToChange,\\r\\n    FuseStatus status\\r\\n  ) {\\r\\n    if (fuse.status != FuseStatus.FUSE_DISABLED_0) {\\r\\n      if (fuse.status == FuseStatus.FUSE_OFF_1) {\\r\\n        // currently fuse is OFF\\r\\n        if (price <= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_ON] || poolPrice <= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_ON]) {\\r\\n          needToChange = true;\\r\\n          status = FuseStatus.FUSE_ON_LOWER_LIMIT_2;\\r\\n        } else if (price >= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_ON] || poolPrice >= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_ON]) {\\r\\n          needToChange = true;\\r\\n          status = FuseStatus.FUSE_ON_UPPER_LIMIT_3;\\r\\n        }\\r\\n      } else {\\r\\n        if (fuse.status == FuseStatus.FUSE_ON_LOWER_LIMIT_2) {\\r\\n          // currently fuse is triggered ON by lower limit\\r\\n          if (price >= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_OFF] && poolPrice >= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_OFF]) {\\r\\n            needToChange = true;\\r\\n            if (price >= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_ON] || poolPrice >= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_ON]) {\\r\\n              status = FuseStatus.FUSE_ON_UPPER_LIMIT_3;\\r\\n            } else {\\r\\n              status = FuseStatus.FUSE_OFF_1;\\r\\n            }\\r\\n          }\\r\\n        } else {\\r\\n          // currently fuse is triggered ON by upper limit\\r\\n          if (price <= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_OFF] && poolPrice <= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_OFF]) {\\r\\n            needToChange = true;\\r\\n            if (price <= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_OFF] || poolPrice <= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_OFF]) {\\r\\n              status = FuseStatus.FUSE_ON_LOWER_LIMIT_2;\\r\\n            } else {\\r\\n              status = FuseStatus.FUSE_OFF_1;\\r\\n            }\\r\\n          }\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return (needToChange, needToChange ? status : fuse.status);\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Fuse functions\\r\\n\\r\\n  //region ------------------------------------------------ Internal helper functions\\r\\n  /// @notice Quote amount of the next swap if any.\\r\\n  ///         Swaps are required if direct-borrow exists OR reverse-borrow exists or not underlying leftovers exist\\r\\n  ///         Function returns info for first swap only.\\r\\n  /// @return tokenToSwap What token should be swapped. Zero address if no swap is required\\r\\n  /// @return amountToSwap Amount to swap. Zero if no swap is required.\\r\\n  function _quoteWithdrawStep(IterationPlanLib.SwapRepayPlanParams memory p) internal returns (\\r\\n    address tokenToSwap,\\r\\n    uint amountToSwap\\r\\n  ) {\\r\\n    uint indexTokenToSwapPlus1;\\r\\n    (indexTokenToSwapPlus1, amountToSwap,) = IterationPlanLib.buildIterationPlan(\\r\\n      [address(p.converter), address(p.liquidator)],\\r\\n      p.tokens,\\r\\n      p.liquidationThresholds,\\r\\n      p.prices,\\r\\n      p.decs,\\r\\n      p.balanceAdditions,\\r\\n      [\\r\\n        p.usePoolProportions ? 1 : 0,\\r\\n        p.planKind,\\r\\n        p.propNotUnderlying18,\\r\\n        type(uint).max,\\r\\n        IDX_ASSET,\\r\\n        IDX_TOKEN,\\r\\n        p.entryDataParam\\r\\n      ]\\r\\n    );\\r\\n    if (indexTokenToSwapPlus1 != 0) {\\r\\n      tokenToSwap = p.tokens[indexTokenToSwapPlus1 - 1];\\r\\n    }\\r\\n    return (tokenToSwap, amountToSwap);\\r\\n  }\\r\\n\\r\\n  /// @notice Make one iteration of withdraw. Each iteration can make 0 or 1 swap only\\r\\n  ///         We can make only 1 of the following 3 operations per single call:\\r\\n  ///         1) repay direct debt 2) repay reverse debt 3) swap leftovers to underlying\\r\\n  function _withdrawStep(IterationPlanLib.SwapRepayPlanParams memory p, SwapByAggParams memory aggParams) internal returns (\\r\\n    bool completed\\r\\n  ) {\\r\\n    (uint idxToSwap1, uint amountToSwap, uint idxToRepay1) = IterationPlanLib.buildIterationPlan(\\r\\n      [address(p.converter), address(p.liquidator)],\\r\\n      p.tokens,\\r\\n      p.liquidationThresholds,\\r\\n      p.prices,\\r\\n      p.decs,\\r\\n      p.balanceAdditions,\\r\\n      [\\r\\n        p.usePoolProportions ? 1 : 0,\\r\\n        p.planKind,\\r\\n        p.propNotUnderlying18,\\r\\n        type(uint).max,\\r\\n        IDX_ASSET,\\r\\n        IDX_TOKEN,\\r\\n        p.entryDataParam\\r\\n      ]\\r\\n    );\\r\\n\\r\\n    bool[4] memory actions = [\\r\\n      p.planKind == IterationPlanLib.PLAN_SWAP_ONLY || p.planKind == IterationPlanLib.PLAN_SWAP_REPAY, // swap 1\\r\\n      p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY || p.planKind == IterationPlanLib.PLAN_SWAP_REPAY, // repay 1\\r\\n      p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY, // swap 2\\r\\n      p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY // repay 2\\r\\n      ];\\r\\n\\r\\n    if (idxToSwap1 != 0 && actions[IDX_SWAP_1]) {\\r\\n      (, p.propNotUnderlying18) = _swap(p, aggParams, idxToSwap1 - 1, idxToSwap1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, amountToSwap);\\r\\n    }\\r\\n\\r\\n    if (idxToRepay1 != 0 && actions[IDX_REPAY_1]) {\\r\\n      ConverterStrategyBaseLib._repayDebt(\\r\\n        p.converter,\\r\\n        p.tokens[idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET],\\r\\n        p.tokens[idxToRepay1 - 1],\\r\\n        IERC20(p.tokens[idxToRepay1 - 1]).balanceOf(address(this))\\r\\n      );\\r\\n    }\\r\\n\\r\\n    if (idxToSwap1 != 0) {\\r\\n      if (actions[IDX_SWAP_2]) {\\r\\n        (, p.propNotUnderlying18) = _swap(p, aggParams, idxToSwap1 - 1, idxToSwap1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, amountToSwap);\\r\\n\\r\\n        if (actions[IDX_REPAY_2] && idxToRepay1 != 0) {\\r\\n          // see calculations inside estimateSwapAmountForRepaySwapRepay\\r\\n          // There are two possibilities here:\\r\\n          // 1) All collateral asset available on balance was swapped. We need additional repay to get assets in right proportions\\r\\n          // 2) Only part of collateral asset was swapped, so assets are already in right proportions. Repay 2 is not needed\\r\\n          (uint amountToRepay2, bool borrowInsteadRepay) = _getAmountToRepay2(\\r\\n            p,\\r\\n            idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET,\\r\\n            idxToRepay1 - 1\\r\\n          );\\r\\n\\r\\n          if (borrowInsteadRepay) {\\r\\n            _borrowToProportions(p, idxToRepay1 - 1, idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, true);\\r\\n\\r\\n          } else if (amountToRepay2 > p.liquidationThresholds[idxToRepay1 - 1]) {\\r\\n            _secondRepay(p, idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, idxToRepay1 - 1, amountToRepay2, type(uint).max);\\r\\n          }\\r\\n        }\\r\\n      } else {\\r\\n        // leftovers were swapped, there are no debts anymore\\r\\n        // the swap can change pool proportions, so probably it's necessary to make additional borrow here\\r\\n        if (\\r\\n          idxToRepay1 == 0 // there are no debts anymore\\r\\n          && p.usePoolProportions  // we use proportions from the pool\\r\\n          && p.propNotUnderlying18 != 0 && p.propNotUnderlying18 != 1e18 // BorrowLib doesn't allow prop=0\\r\\n        ) {\\r\\n          _fixLeftoversProportions(p);\\r\\n        }\\r\\n      }\\r\\n    }\\r\\n\\r\\n    // Withdraw is completed on last iteration (no debts, swapping leftovers)\\r\\n    return idxToRepay1 == 0;\\r\\n  }\\r\\n\\r\\n  /// @notice Make final repay in the scheme REPAY-SWAP-REPAY\\r\\n  ///         Depending on condition the final repay can be made several times or additional borrow can be made\\r\\n  /// @param amountToRepay Amount of {indexBorrow} asset that should be repaid\\r\\n  /// @param needToRepayPrev Amount-to-repay on previous call of the {_secondRepay}\\r\\n  ///                        This amount should decrease on each step of recursion.\\r\\n  ///                        if it doesn't decrease repay is not successfull and it's useless to continue to call repays\\r\\n  ///                        It can happen if liquidationThreshold has incorrect value (i.t. it's too low or zero)\\r\\n  function _secondRepay(\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrow,\\r\\n    uint amountToRepay,\\r\\n    uint needToRepayPrev\\r\\n  ) internal {\\r\\n    // we need to know repaidAmount\\r\\n    // we cannot relay on the value returned by _repayDebt because of SCB-710, we need to check balances\\r\\n    uint balanceBefore = IERC20(p.tokens[indexBorrow]).balanceOf(address(this));\\r\\n    ConverterStrategyBaseLib._repayDebt(p.converter, p.tokens[indexCollateral], p.tokens[indexBorrow], amountToRepay);\\r\\n    uint balanceAfter = IERC20(p.tokens[indexBorrow]).balanceOf(address(this));\\r\\n\\r\\n    uint repaidAmount = balanceBefore > balanceAfter\\r\\n      ? balanceBefore - balanceAfter\\r\\n      : 0;\\r\\n\\r\\n    if (repaidAmount < amountToRepay && amountToRepay - repaidAmount > p.liquidationThresholds[indexBorrow]) {\\r\\n      // repaidAmount is less than expected\\r\\n      // we need to make additional borrow OR probably make one more repay\\r\\n      // repaidAmount can be less amountToRepay2 even if there is still opened debt, see SCB-777\\r\\n      (uint needToRepay,) = p.converter.getDebtAmountStored(address(this), p.tokens[indexCollateral], p.tokens[indexBorrow], true);\\r\\n      if (\\r\\n        needToRepay > p.liquidationThresholds[indexBorrow]\\r\\n        && needToRepay < needToRepayPrev // amount of debt was reduced on prev iteration of recursion\\r\\n      ) {\\r\\n        // more repays are required\\r\\n        _secondRepay(p, indexCollateral, indexBorrow, amountToRepay - repaidAmount, needToRepay);\\r\\n      } else {\\r\\n        _borrowToProportions(p, indexBorrow, indexCollateral, false);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Set balances to right proportions using borrow\\r\\n  ///         (it can be necessary if propNotUnderlying18 was changed after swap)\\r\\n  function _fixLeftoversProportions(IterationPlanLib.SwapRepayPlanParams memory p) internal {\\r\\n    uint balanceAsset = IERC20(p.tokens[IDX_ASSET]).balanceOf(address(this));\\r\\n    uint balanceToken = IERC20(p.tokens[IDX_TOKEN]).balanceOf(address(this));\\r\\n    (uint targetAssets,\\r\\n      uint targetTokens\\r\\n    ) = IterationPlanLib._getTargetAmounts(p.prices, p.decs, balanceAsset, balanceToken, p.propNotUnderlying18, IDX_ASSET, IDX_TOKEN);\\r\\n\\r\\n    if (balanceAsset > targetAssets) {\\r\\n      if (balanceAsset - targetAssets > p.liquidationThresholds[IDX_ASSET]) {\\r\\n        _borrowToProportions(p, IDX_ASSET, IDX_TOKEN, balanceAsset, balanceToken, true);\\r\\n      }\\r\\n    } else if (balanceToken > targetTokens) {\\r\\n      if (balanceToken - targetTokens > p.liquidationThresholds[IDX_ASSET]) {\\r\\n        _borrowToProportions(p, IDX_TOKEN, IDX_ASSET, balanceToken, balanceAsset, true);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice borrow borrow-asset under collateral-asset, result balances should match to propNotUnderlying18\\r\\n  function _borrowToProportions(\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrow,\\r\\n    bool checkOppositDebtDoesntExist\\r\\n  ) internal {\\r\\n    _borrowToProportions(\\r\\n      p,\\r\\n      indexCollateral,\\r\\n      indexBorrow,\\r\\n      IERC20(p.tokens[indexCollateral]).balanceOf(address(this)),\\r\\n      IERC20(p.tokens[indexBorrow]).balanceOf(address(this)),\\r\\n      checkOppositDebtDoesntExist\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice borrow borrow-asset under collateral-asset, result balances should match to propNotUnderlying18\\r\\n  function _borrowToProportions(\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrow,\\r\\n    uint balanceCollateral,\\r\\n    uint balanceBorrow,\\r\\n    bool checkOppositDebtDoesntExist\\r\\n  ) internal {\\r\\n    // we are going to change direction of the borrow\\r\\n    // let's ensure that there is no debt in opposite direction\\r\\n    if (checkOppositDebtDoesntExist) {\\r\\n      (uint needToRepay,) = p.converter.getDebtAmountStored(address(this), p.tokens[indexBorrow], p.tokens[indexCollateral], false);\\r\\n      require(needToRepay < AppLib.DUST_AMOUNT_TOKENS, AppErrors.OPPOSITE_DEBT_EXISTS);\\r\\n    }\\r\\n\\r\\n    BorrowLib.RebalanceAssetsCore memory cac = BorrowLib.RebalanceAssetsCore({\\r\\n      converterLiquidator: BorrowLib.ConverterLiquidator(p.converter, p.liquidator),\\r\\n      assetA: p.tokens[indexCollateral],\\r\\n      assetB: p.tokens[indexBorrow],\\r\\n      propA: indexCollateral == IDX_ASSET ? 1e18 - p.propNotUnderlying18 : p.propNotUnderlying18,\\r\\n      propB: indexCollateral == IDX_ASSET ? p.propNotUnderlying18 : 1e18 - p.propNotUnderlying18,\\r\\n    // {assetA} to {assetB} ratio; {amountB} * {alpha} => {amountA}, decimals 18\\r\\n      alpha18: 1e18 * p.prices[indexBorrow] * p.decs[indexCollateral] / p.prices[indexCollateral] / p.decs[indexBorrow],\\r\\n      thresholdA: p.liquidationThresholds[indexCollateral],\\r\\n      addonA: 0,\\r\\n      addonB: 0,\\r\\n      indexA: indexCollateral,\\r\\n      indexB: indexBorrow\\r\\n    });\\r\\n\\r\\n    BorrowLib.openPosition(\\r\\n      cac,\\r\\n      BorrowLib.PricesDecs({\\r\\n        prices: p.prices,\\r\\n        decs: p.decs\\r\\n      }),\\r\\n      balanceCollateral,\\r\\n      balanceBorrow\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate amount that should be repaid to get right proportions of assets on balance\\r\\n  ///         Analyse only single borrow-direction: indexCollateral => indexBorrow\\r\\n  /// @return amountToRepay Amount that should be repaid\\r\\n  /// @return borrowInsteadRepay true if repay is not necessary at all and borrow is required instead\\r\\n  ///                            if we need both repay and borrow then false is returned\\r\\n  function _getAmountToRepay2(\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\r\\n    uint indexCollateral,\\r\\n    uint indexBorrow\\r\\n  ) internal view returns (\\r\\n    uint amountToRepay,\\r\\n    bool borrowInsteadRepay\\r\\n  ) {\\r\\n    GetAmountToRepay2Local memory v;\\r\\n    v.c0 = IERC20(p.tokens[indexCollateral]).balanceOf(address(this)) * p.prices[indexCollateral] / p.decs[indexCollateral];\\r\\n    v.b0 = IERC20(p.tokens[indexBorrow]).balanceOf(address(this)) * p.prices[indexBorrow] / p.decs[indexBorrow];\\r\\n\\r\\n    v.x = indexCollateral == IDX_ASSET ? 1e18 - p.propNotUnderlying18 : p.propNotUnderlying18;\\r\\n    v.y = indexCollateral == IDX_ASSET ? p.propNotUnderlying18 : 1e18 - p.propNotUnderlying18;\\r\\n    v.alpha = p.prices[indexCollateral] * p.decs[indexBorrow] * 1e18 / p.prices[indexBorrow] / p.decs[indexCollateral];\\r\\n\\r\\n    (uint needToRepay, uint collateralAmountOut) = p.converter.getDebtAmountStored(\\r\\n      address(this),\\r\\n      p.tokens[indexCollateral],\\r\\n      p.tokens[indexBorrow],\\r\\n      true\\r\\n    );\\r\\n\\r\\n    if (needToRepay == 0) {\\r\\n      // check if we need to make reverse borrow to fit to proportions: borrow collateral-asset under borrow-asset\\r\\n      uint targetCollateral = (v.c0 + v.b0) * v.x / (v.x + v.y);\\r\\n      borrowInsteadRepay = targetCollateral > v.c0\\r\\n        && targetCollateral - v.c0\\r\\n        > (p.liquidationThresholds[indexCollateral] * p.prices[indexCollateral] / p.decs[indexCollateral]);\\r\\n    } else {\\r\\n      // initial balances: c0, b0\\r\\n      // we are going to repay amount b and receive (betta * b, b), where betta ~ alpha * totalCollateral / totalBorrow\\r\\n      // we should have x/y = (c0 + betta * b) / (b0 - b)\\r\\n      // so b = (x * b0 - y * c0) / (betta * y + x)\\r\\n      v.b = (int(v.x * v.b0) - int(v.y * v.c0)) / (int(v.y * v.alpha * collateralAmountOut / needToRepay / 1e18) + int(v.x));\\r\\n      if (v.b > 0) {\\r\\n        amountToRepay = uint(v.b);\\r\\n      }\\r\\n    }\\r\\n\\r\\n    return (amountToRepay * p.decs[indexBorrow] / p.prices[indexBorrow], borrowInsteadRepay);\\r\\n  }\\r\\n\\r\\n  /// @notice Swap {aggParams.amountToSwap} using either liquidator or aggregator\\r\\n  /// @dev You can use liquidator as aggregator, so aggregator's logic will be used for the liquidator\\r\\n  /// @param amountIn Calculated amount to be swapped. It can be different from {aggParams.amountToSwap} a bit,\\r\\n  ///                 but aggregators require exact value {aggParams.amountToSwap}, so amountIn is not used with agg.\\r\\n  function _swap(\\r\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\r\\n    SwapByAggParams memory aggParams,\\r\\n    uint indexIn,\\r\\n    uint indexOut,\\r\\n    uint amountIn\\r\\n  ) internal returns (\\r\\n    uint spentAmountIn,\\r\\n    uint updatedPropNotUnderlying18\\r\\n  ) {\\r\\n    // liquidator and aggregator have different logic here:\\r\\n    // - liquidator uses amountIn to swap\\r\\n    // - Aggregator uses amountToSwap for which a route was built off-chain before the call of the swap()\\r\\n    // It's allowed to use aggregator == liquidator, so in this way liquidator will use aggregator's logic (for tests)\\r\\n\\r\\n    if (!aggParams.useLiquidator) {\\r\\n      // aggregator requires exact input amount - aggParams.amountToSwap\\r\\n      // actual amount can be a bit different because the quote function was called in different block\\r\\n      amountIn = aggParams.amountToSwap;\\r\\n    }\\r\\n    address aggregator = aggParams.useLiquidator\\r\\n      ? address(p.liquidator)\\r\\n      : aggParams.aggregator;\\r\\n\\r\\n    require(amountIn <= IERC20(p.tokens[indexIn]).balanceOf(address(this)), AppErrors.NOT_ENOUGH_BALANCE);\\r\\n    // let's ensure that \\\"next swap\\\" is made using correct token\\r\\n    require(aggParams.tokenToSwap == p.tokens[indexIn], AppErrors.INCORRECT_SWAP_BY_AGG_PARAM);\\r\\n\\r\\n    if (amountIn > p.liquidationThresholds[indexIn]) {\\r\\n      AppLib.approveIfNeeded(p.tokens[indexIn], amountIn, aggregator);\\r\\n\\r\\n      uint balanceTokenOutBefore = AppLib.balance(p.tokens[indexOut]);\\r\\n\\r\\n      if (aggParams.useLiquidator) {\\r\\n\\r\\n        (spentAmountIn,) = ConverterStrategyBaseLib._liquidate(\\r\\n          p.converter,\\r\\n          ITetuLiquidator(aggregator),\\r\\n          p.tokens[indexIn],\\r\\n          p.tokens[indexOut],\\r\\n          amountIn,\\r\\n          _ASSET_LIQUIDATION_SLIPPAGE,\\r\\n          p.liquidationThresholds[indexIn],\\r\\n          true\\r\\n        );\\r\\n      } else {\\r\\n        if (aggregator != address(p.liquidator)) {\\r\\n          _checkSwapRouter(aggregator);\\r\\n        }\\r\\n\\r\\n        (bool success, bytes memory result) = aggregator.call(aggParams.swapData);\\r\\n        require(success, string(result));\\r\\n\\r\\n        spentAmountIn = amountIn;\\r\\n      }\\r\\n\\r\\n      require(\\r\\n        p.converter.isConversionValid(\\r\\n          p.tokens[indexIn],\\r\\n          amountIn,\\r\\n          p.tokens[indexOut],\\r\\n          AppLib.balance(p.tokens[indexOut]) - balanceTokenOutBefore,\\r\\n          _ASSET_LIQUIDATION_SLIPPAGE\\r\\n        ), AppErrors.PRICE_IMPACT);\\r\\n\\r\\n      emit SwapByAgg(\\r\\n        aggParams.amountToSwap,\\r\\n        amountIn,\\r\\n        AppLib.balance(p.tokens[indexOut]) - balanceTokenOutBefore,\\r\\n        amountIn * p.prices[indexIn] * p.decs[indexOut] / p.prices[indexOut] / p.decs[indexIn],\\r\\n        aggregator,\\r\\n        p.tokens[indexIn],\\r\\n        p.tokens[indexOut]\\r\\n      );\\r\\n    }\\r\\n\\r\\n    return (\\r\\n      spentAmountIn,\\r\\n    // p.propNotUnderlying18 contains original proportions that were valid before the swap\\r\\n    // after swap() we need to re-read new values from the pool\\r\\n      p.usePoolProportions\\r\\n        ? IPoolProportionsProvider(address(this)).getPropNotUnderlying18()\\r\\n        : p.propNotUnderlying18\\r\\n    );\\r\\n  }\\r\\n  //endregion ------------------------------------------------ Internal helper functions\\r\\n\\r\\n  //region ----------------------------------------- Utils\\r\\n  function getPoolPriceAdjustment(uint poolPriceDecimals) external pure returns (uint adjustment) {\\r\\n    // we assume that decimals never higher than 18\\r\\n    adjustment = poolPriceDecimals < 18 ? 10 ** (18 - poolPriceDecimals) : 1;\\r\\n  }\\r\\n\\r\\n  function _checkSwapRouter(address router) internal pure {\\r\\n    require(router == ONEINCH || router == OPENOCEAN || router == OPENOCEAN_ZKEVM, UNKNOWN_SWAP_ROUTER);\\r\\n  }\\r\\n\\r\\n  /// @notice Extract propNotUnderlying18 from {planEntryData} of the given {planKind}\\r\\n  function _extractProp(uint planKind, bytes memory planEntryData) internal pure returns (\\r\\n    uint propNotUnderlying18,\\r\\n    uint entryDataParamValue\\r\\n  ) {\\r\\n    if (planKind == IterationPlanLib.PLAN_SWAP_REPAY || planKind == IterationPlanLib.PLAN_SWAP_ONLY) {\\r\\n      (, propNotUnderlying18) = abi.decode(planEntryData, (uint, uint));\\r\\n      require(propNotUnderlying18 <= 1e18 || propNotUnderlying18 == type(uint).max, AppErrors.INVALID_VALUE); // 0 is allowed\\r\\n    } else {\\r\\n      require(planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY, AppErrors.WRONG_VALUE);\\r\\n      // save \\\"required-amount-to-reduce-debt\\\" to entryDataParamValue\\r\\n      (, propNotUnderlying18, entryDataParamValue) = abi.decode(planEntryData, (uint, uint, uint));\\r\\n      require(propNotUnderlying18 <= 1e18 || propNotUnderlying18 == type(uint).max, AppErrors.INVALID_VALUE); // 0 is allowed\\r\\n    }\\r\\n    return (propNotUnderlying18, entryDataParamValue);\\r\\n  }\\r\\n  //endregion ------------------------------------------ Utils\\r\\n}\\r\\n\",\"keccak256\":\"0x5bdbb11c9584ac19547eed43ef3ffa0e8f33f728fd4019f5948b5853c51d570a\",\"license\":\"BUSL-1.1\"},\"contracts/strategies/pair/PairBasedStrategyLogicLib.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\r\\nimport \\\"../ConverterStrategyBaseLib.sol\\\";\\r\\nimport \\\"./PairBasedStrategyLib.sol\\\";\\r\\nimport \\\"../ConverterStrategyBaseLib2.sol\\\";\\r\\n\\r\\n/// @notice Library for the UniV3-like strategies with two tokens in the pool\\r\\nlibrary PairBasedStrategyLogicLib {\\r\\n  //region ------------------------------------------------------- Data types\\r\\n  /// @notice Local variables required inside withdrawByAggStep and quoteWithdrawByAgg\\r\\n  struct WithdrawLocal {\\r\\n    /// @notice [underlying, not-underlying]\\r\\n    address[] tokens;\\r\\n    address controller;\\r\\n    /// @notice liquidationThresholds for the {tokens}, greater or equal to {DEFAULT_LIQUIDATION_THRESHOLD}\\r\\n    uint[] liquidationThresholds;\\r\\n    uint planKind;\\r\\n    uint propNotUnderlying18;\\r\\n    uint entryDataParam;\\r\\n  }\\r\\n\\r\\n  /// @notice Common part of all XXXXConverterStrategyLogicLib.State\\r\\n  struct PairState {\\r\\n    address pool;\\r\\n    address strategyProfitHolder;\\r\\n    /// @notice This is underlying\\r\\n    address tokenA;\\r\\n    /// @notice This is not underlying\\r\\n    address tokenB;\\r\\n\\r\\n    bool isStablePool;\\r\\n    /// @notice Tokens are swapped in the pool (pool.tokenB is underlying, pool.tokenA is not-underlying)\\r\\n    bool depositorSwapTokens;\\r\\n\\r\\n    int24 tickSpacing;\\r\\n    int24 lowerTick;\\r\\n    int24 upperTick;\\r\\n    int24 rebalanceTickRange;\\r\\n    uint128 totalLiquidity;\\r\\n\\r\\n    /// @notice Fuse for tokens\\r\\n    PairBasedStrategyLib.FuseStateParams fuseAB;\\r\\n\\r\\n    /// @notice 1 means that the fuse was triggered ON and then all debts were closed\\r\\n    ///         and assets were converter to underlying using withdrawStepByAgg.\\r\\n    ///         This flag is automatically cleared to 0 if fuse is triggered OFF.\\r\\n    uint withdrawDone;\\r\\n\\r\\n    /// @notice Timestamp of last call of rebalanceNoSwaps() or zero if withdrawByAggStep() was called last\\r\\n    uint lastRebalanceNoSwap;\\r\\n\\r\\n    /// @notice reserve space for future needs\\r\\n    uint[50 - 17] __gap;\\r\\n  }\\r\\n\\r\\n  struct RebalanceNoSwapsLocal {\\r\\n    address tokenA;\\r\\n    address tokenB;\\r\\n    bool depositorSwapTokens;\\r\\n    int24 newLowerTick;\\r\\n    int24 newUpperTick;\\r\\n    uint prop0;\\r\\n    uint prop1;\\r\\n  }\\r\\n\\r\\n  struct WithdrawByAggStepLocal {\\r\\n    PairBasedStrategyLogicLib.WithdrawLocal w;\\r\\n    address tokenToSwap;\\r\\n    address aggregator;\\r\\n    address controller;\\r\\n    address converter;\\r\\n    address splitter;\\r\\n    uint amountToSwap;\\r\\n    uint profitToCover;\\r\\n    uint oldTotalAssets;\\r\\n    uint entryToPool;\\r\\n  }\\r\\n  //endregion ------------------------------------------------------- Data types\\r\\n\\r\\n  //region ------------------------------------------------------- Events\\r\\n  //endregion ------------------------------------------------------- Events\\r\\n\\r\\n  //region ------------------------------------------------------- Helpers\\r\\n  /// @notice Prepare array of amounts ready to deposit, borrow missed amounts\\r\\n  /// @param amount_ Amount of tokenA\\r\\n  /// @param tokenA Underlying\\r\\n  /// @param tokenB Not-underlying\\r\\n  /// @param prop0 Required proportion of underlying, > 0. Proportion of not-underlying is calculates as 1e18 - {prop0}\\r\\n  /// @param liquidationThresholds Dust-thresholds for the tokens A and B\\r\\n  /// @return tokenAmounts Amounts of token A and B to be deposited, [A, B]\\r\\n  function _beforeDeposit(\\r\\n    ITetuConverter tetuConverter_,\\r\\n    uint amount_,\\r\\n    address tokenA,\\r\\n    address tokenB,\\r\\n    uint prop0,\\r\\n    mapping(address => uint) storage liquidationThresholds\\r\\n  ) external returns (\\r\\n    uint[] memory tokenAmounts\\r\\n  ) {\\r\\n    return BorrowLib.prepareToDeposit(\\r\\n      tetuConverter_,\\r\\n      amount_,\\r\\n      [tokenA, tokenB],\\r\\n      [\\r\\n        AppLib._getLiquidationThreshold(liquidationThresholds[tokenA]),\\r\\n        AppLib._getLiquidationThreshold(liquidationThresholds[tokenB])\\r\\n      ],\\r\\n      prop0\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Initialize {dest} in place. Underlying is always first in {dest.tokens}.\\r\\n  /// @param tokens_ [underlying, not-underlying]\\r\\n  function initWithdrawLocal(\\r\\n    WithdrawLocal memory dest,\\r\\n    address[2] memory tokens_,\\r\\n    mapping(address => uint) storage liquidationThresholds,\\r\\n    bytes memory planEntryData,\\r\\n    address controller\\r\\n  ) internal view { // it's internal because it initializes {dest}\\r\\n    dest.controller = controller;\\r\\n    StrategyLib2.onlyOperators(dest.controller);\\r\\n\\r\\n    dest.planKind = IterationPlanLib.getEntryKind(planEntryData);\\r\\n    (dest.propNotUnderlying18, dest.entryDataParam)  = PairBasedStrategyLib._extractProp(dest.planKind, planEntryData);\\r\\n\\r\\n    dest.tokens = new address[](2);\\r\\n    (dest.tokens[0], dest.tokens[1]) = (tokens_[0], tokens_[1]);\\r\\n\\r\\n    dest.liquidationThresholds = new uint[](2);\\r\\n    dest.liquidationThresholds[0] = AppLib._getLiquidationThreshold(liquidationThresholds[dest.tokens[0]]);\\r\\n    dest.liquidationThresholds[1] = AppLib._getLiquidationThreshold(liquidationThresholds[dest.tokens[1]]);\\r\\n  }\\r\\n\\r\\n  function calcTickRange(int24 tick, int24 tickRange, int24 tickSpacing) public pure returns (\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick\\r\\n  ) {\\r\\n    if (tick < 0 && tick / tickSpacing * tickSpacing != tick) {\\r\\n      lowerTick = ((tick - tickRange) / tickSpacing - 1) * tickSpacing;\\r\\n    } else {\\r\\n      lowerTick = (tick - tickRange) / tickSpacing * tickSpacing;\\r\\n    }\\r\\n    upperTick = tickRange == 0 ? lowerTick + tickSpacing : lowerTick + tickRange * 2;\\r\\n  }\\r\\n  //endregion ------------------------------------------------------- Helpers\\r\\n\\r\\n  //region ------------------------------------------------------- PairState-helpers\\r\\n  /// @notice Set the initial values to PairState instance\\r\\n  /// @param pairState Depositor storage state struct to be initialized\\r\\n  /// @param addr [pool, asset, pool.token0(), pool.token1()]\\r\\n  ///        asset: Underlying asset of the depositor.\\r\\n  /// @param tickData [tickSpacing, lowerTick, upperTick, rebalanceTickRange]\\r\\n  /// @param fuseThresholds Fuse thresholds for tokens (stable pool only)\\r\\n  function setInitialDepositorValues(\\r\\n    PairState storage pairState,\\r\\n    address[4] calldata addr,\\r\\n    int24[4] calldata tickData,\\r\\n    bool isStablePool_,\\r\\n    uint[4] calldata fuseThresholds\\r\\n  ) external {\\r\\n    pairState.pool = addr[0];\\r\\n    address asset = addr[1];\\r\\n    address token0 = addr[2];\\r\\n    address token1 = addr[3];\\r\\n\\r\\n    pairState.tickSpacing = tickData[0];\\r\\n    pairState.lowerTick = tickData[1];\\r\\n    pairState.upperTick = tickData[2];\\r\\n    pairState.rebalanceTickRange = tickData[3];\\r\\n\\r\\n    require(asset == token0 || asset == token1, PairBasedStrategyLib.INCORRECT_ASSET);\\r\\n    if (asset == token0) {\\r\\n      pairState.tokenA = token0;\\r\\n      pairState.tokenB = token1;\\r\\n      pairState.depositorSwapTokens = false;\\r\\n    } else {\\r\\n      pairState.tokenA = token1;\\r\\n      pairState.tokenB = token0;\\r\\n      pairState.depositorSwapTokens = true;\\r\\n    }\\r\\n\\r\\n    if (isStablePool_) {\\r\\n      /// for stable pools fuse can be enabled\\r\\n      pairState.isStablePool = true;\\r\\n      PairBasedStrategyLib.setFuseStatus(pairState.fuseAB, PairBasedStrategyLib.FuseStatus.FUSE_OFF_1);\\r\\n      PairBasedStrategyLib.setFuseThresholds(pairState.fuseAB, fuseThresholds);\\r\\n    }\\r\\n\\r\\n    // totalLiquidity is 0, no need to initialize\\r\\n    // withdrawDone is 0, no need to initialize\\r\\n  }\\r\\n\\r\\n  function updateFuseStatus(\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    bool fuseStatusChangedAB,\\r\\n    PairBasedStrategyLib.FuseStatus fuseStatusAB\\r\\n  ) external {\\r\\n    bool updated;\\r\\n    if (fuseStatusChangedAB) {\\r\\n      PairBasedStrategyLib.setFuseStatus(pairState.fuseAB, fuseStatusAB);\\r\\n      updated = true;\\r\\n    }\\r\\n\\r\\n    if (updated) {\\r\\n      // if fuse is triggered ON, full-withdraw is required\\r\\n      // if fuse is triggered OFF, the assets will be deposited back to pool\\r\\n      // in both cases withdrawDone should be reset\\r\\n      pairState.withdrawDone = 0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Returns the current state of the contract\\r\\n  /// @return addr [tokenA, tokenB, pool, profitHolder]\\r\\n  /// @return tickData [tickSpacing, lowerTick, upperTick, rebalanceTickRange]\\r\\n  /// @return nums [totalLiquidity, fuse-status-tokenA, withdrawDone, 4 thresholds of token A, lastRebalanceNoSwap, 5 reserved values]\\r\\n  /// @return boolValues [isStablePool, depositorSwapTokens]\\r\\n  function getDefaultState(PairBasedStrategyLogicLib.PairState storage pairState) external view returns (\\r\\n    address[] memory addr,\\r\\n    int24[] memory tickData,\\r\\n    uint[] memory nums,\\r\\n    bool[] memory boolValues\\r\\n  ) {\\r\\n    addr = new address[](4);\\r\\n    tickData = new int24[](4);\\r\\n    nums = new uint[](13);\\r\\n    boolValues = new bool[](2);\\r\\n\\r\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_TOKEN_A] = pairState.tokenA;\\r\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_TOKEN_B] = pairState.tokenB;\\r\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_POOL] = pairState.pool;\\r\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_PROFIT_HOLDER] = pairState.strategyProfitHolder;\\r\\n\\r\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_TICK_SPACING] = pairState.tickSpacing;\\r\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_LOWER_TICK] = pairState.lowerTick;\\r\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_UPPER_TICK] = pairState.upperTick;\\r\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_REBALANCE_TICK_RANGE] = pairState.rebalanceTickRange;\\r\\n\\r\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_TOTAL_LIQUIDITY] = uint(pairState.totalLiquidity);\\r\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_FUSE_STATUS] = uint(pairState.fuseAB.status);\\r\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_WITHDRAW_DONE] = pairState.withdrawDone;\\r\\n    for (uint i = 0; i < 4; ++i) {\\r\\n      nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_THRESHOLD_0 + i] = pairState.fuseAB.thresholds[i];\\r\\n    }\\r\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_LAST_REBALANCE_NO_SWAP] = pairState.lastRebalanceNoSwap;\\r\\n\\r\\n    boolValues[PairBasedStrategyLib.IDX_BOOL_VALUES_DEFAULT_STATE_IS_STABLE_POOL] = pairState.isStablePool;\\r\\n    boolValues[PairBasedStrategyLib.IDX_BOOL_VALUES_DEFAULT_STATE_DEPOSITOR_SWAP_TOKENS] = pairState.depositorSwapTokens;\\r\\n  }\\r\\n\\r\\n  /// @notice Get info about a swap required by next call of {withdrawByAggStep} within the given plan\\r\\n  /// @param amounts_ Amounts of [underlying, not-underlying] that will be received from the pool before withdrawing\\r\\n  function quoteWithdrawByAgg(\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    bytes memory planEntryData,\\r\\n    uint[] memory amounts_,\\r\\n    address controller_,\\r\\n    ITetuConverter converter_,\\r\\n    mapping(address => uint) storage liquidationThresholds\\r\\n  ) external returns (\\r\\n    address tokenToSwap,\\r\\n    uint amountToSwap\\r\\n  ) {\\r\\n    // check operator-only, initialize w\\r\\n    WithdrawLocal memory w;\\r\\n    initWithdrawLocal(\\r\\n      w,\\r\\n      [pairState.tokenA, pairState.tokenB],\\r\\n      liquidationThresholds,\\r\\n      planEntryData,\\r\\n      controller_\\r\\n    );\\r\\n\\r\\n    (tokenToSwap, amountToSwap) = PairBasedStrategyLib.quoteWithdrawStep(\\r\\n      [address(converter_), address(AppLib._getLiquidator(w.controller))],\\r\\n      w.tokens,\\r\\n      w.liquidationThresholds,\\r\\n      amounts_,\\r\\n      w.planKind,\\r\\n      [w.propNotUnderlying18, w.entryDataParam]\\r\\n    );\\r\\n\\r\\n    if (amountToSwap != 0) {\\r\\n      // withdrawByAggStep will execute REPAY1 - SWAP - REPAY2\\r\\n      // but quoteWithdrawByAgg and withdrawByAggStep are executed in different blocks\\r\\n      // so, REPAY1 can return less collateral than quoteWithdrawByAgg expected\\r\\n      // As result, we can have less amount on balance than required amountToSwap\\r\\n      // So, we need to reduce amountToSwap on small gap amount\\r\\n      amountToSwap -= amountToSwap * PairBasedStrategyLib.GAP_AMOUNT_TO_SWAP / 100_000;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @notice Calculate amounts to be deposited to pool, calculate loss, fix profitToCover\\r\\n  /// @param addr_ [tokenToSwap, aggregator, controller, converter, splitter]\\r\\n  /// @param values_ [amountToSwap_, profitToCover, oldTotalAssets, not used here]\\r\\n  /// @param tokens [underlying, not-underlying] (values been read from pairBase)\\r\\n  /// @return completed All debts were closed, leftovers were swapped to proper proportions\\r\\n  /// @return tokenAmounts Amounts to be deposited to pool. If {tokenAmounts} contains zero amount return empty array.\\r\\n  function withdrawByAggStep(\\r\\n    address[5] calldata addr_,\\r\\n    uint[4] calldata values_,\\r\\n    bytes memory swapData,\\r\\n    bytes memory planEntryData,\\r\\n    address[2] memory tokens,\\r\\n    mapping(address => uint) storage liquidationThresholds\\r\\n  ) external returns (\\r\\n    bool completed,\\r\\n    uint[] memory tokenAmounts,\\r\\n    uint loss\\r\\n  ) {\\r\\n    WithdrawByAggStepLocal memory v;\\r\\n\\r\\n    v.tokenToSwap = addr_[0];\\r\\n    v.aggregator = addr_[1];\\r\\n    v.controller = addr_[2];\\r\\n    v.converter = addr_[3];\\r\\n    v.splitter = addr_[4];\\r\\n\\r\\n    v.amountToSwap = values_[0];\\r\\n    v.profitToCover = values_[1];\\r\\n    v.oldTotalAssets = values_[2];\\r\\n\\r\\n    // initialize v\\r\\n    PairBasedStrategyLogicLib.initWithdrawLocal(v.w, tokens, liquidationThresholds, planEntryData, v.controller);\\r\\n\\r\\n    // make withdraw iteration according to the selected plan\\r\\n    completed = PairBasedStrategyLib.withdrawStep(\\r\\n      [v.converter, address(AppLib._getLiquidator(v.w.controller))],\\r\\n      v.w.tokens,\\r\\n      v.w.liquidationThresholds,\\r\\n      v.tokenToSwap,\\r\\n      v.amountToSwap,\\r\\n      v.aggregator,\\r\\n      swapData,\\r\\n      v.aggregator == address(0),\\r\\n      v.w.planKind,\\r\\n      [v.w.propNotUnderlying18, v.w.entryDataParam]\\r\\n    );\\r\\n\\r\\n    // fix loss / profitToCover\\r\\n    if (v.profitToCover != 0) {\\r\\n      ConverterStrategyBaseLib2.sendToInsurance(\\r\\n        v.w.tokens[0],\\r\\n        v.profitToCover,\\r\\n        v.splitter,\\r\\n        v.oldTotalAssets,\\r\\n        IERC20(v.w.tokens[0]).balanceOf(address(this))\\r\\n      );\\r\\n    }\\r\\n\\r\\n    (loss, tokenAmounts) = ConverterStrategyBaseLib2.getTokenAmountsPair(\\r\\n      ITetuConverter(v.converter),\\r\\n      v.oldTotalAssets,\\r\\n      v.w.tokens[0],\\r\\n      v.w.tokens[1],\\r\\n      [v.w.liquidationThresholds[0], v.w.liquidationThresholds[1]]\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @notice Rebalance asset to proportions {propTokenA}:{1e18-propTokenA}, fix profitToCover\\r\\n  /// @param propTokenA Proportion of {tokenA}, > 0. Proportion of {tokenB} is calculates as 1e18 - prop0\\r\\n  /// @param liquidationThresholdsAB [liquidityThreshold of token A, liquidityThreshold of tokenB]\\r\\n  function _rebalanceNoSwaps(\\r\\n    address[2] calldata converterLiquidator,\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    uint profitToCover,\\r\\n    uint totalAssets,\\r\\n    address splitter,\\r\\n    uint[2] calldata liquidationThresholdsAB,\\r\\n    uint propTokenA\\r\\n  ) internal {\\r\\n    address tokenA = pairState.tokenA;\\r\\n    address tokenB = pairState.tokenB;\\r\\n\\r\\n    BorrowLib.rebalanceAssets(\\r\\n      ITetuConverter(converterLiquidator[0]),\\r\\n      ITetuLiquidator(converterLiquidator[1]),\\r\\n      tokenA,\\r\\n      tokenB,\\r\\n      propTokenA,\\r\\n      liquidationThresholdsAB[0], // liquidityThreshold of token A\\r\\n      liquidationThresholdsAB[1], // liquidityThreshold of token B\\r\\n      profitToCover\\r\\n    );\\r\\n\\r\\n    // we assume here, that rebalanceAssets provides profitToCover on balance and set leftovers to right proportions\\r\\n    if (profitToCover != 0) {\\r\\n      ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToCover, splitter, totalAssets, IERC20(tokenA).balanceOf(address(this)));\\r\\n    }\\r\\n  }\\r\\n  //endregion ------------------------------------------------------- PairState-helpers\\r\\n\\r\\n  //region ------------------------------------------------------- needStrategyRebalance\\r\\n  /// @notice Determine if the strategy needs to be rebalanced.\\r\\n  /// @return needRebalance A boolean indicating if {rebalanceNoSwaps} should be called\\r\\n  function needStrategyRebalance(\\r\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\r\\n    ITetuConverter converter_,\\r\\n    int24 tick,\\r\\n    uint poolPrice\\r\\n  ) external view returns (\\r\\n    bool needRebalance,\\r\\n    bool fuseStatusChangedAB,\\r\\n    PairBasedStrategyLib.FuseStatus fuseStatusAB\\r\\n  ) {\\r\\n    if (pairState.isStablePool) {\\r\\n      uint price = ConverterStrategyBaseLib2.getOracleAssetsPrice(\\r\\n        converter_,\\r\\n        pairState.tokenA,\\r\\n        pairState.tokenB\\r\\n      );\\r\\n      (fuseStatusChangedAB, fuseStatusAB) = PairBasedStrategyLib.needChangeFuseStatus(pairState.fuseAB, price, poolPrice);\\r\\n      needRebalance = fuseStatusChangedAB\\r\\n        || (\\r\\n          !PairBasedStrategyLib.isFuseTriggeredOn(fuseStatusAB)\\r\\n          && _needPoolRebalance(pairState, tick)\\r\\n        );\\r\\n    } else {\\r\\n      needRebalance = _needPoolRebalance(pairState, tick);\\r\\n    }\\r\\n\\r\\n    return (needRebalance, fuseStatusChangedAB, fuseStatusAB); // hide warning\\r\\n  }\\r\\n\\r\\n  /// @notice Determine if the pool needs to be rebalanced.\\r\\n  /// @return A boolean indicating if the pool needs to be rebalanced.\\r\\n  function _needPoolRebalance(\\r\\n    int24 tick,\\r\\n    int24 lowerTick,\\r\\n    int24 upperTick,\\r\\n    int24 tickSpacing,\\r\\n    int24 rebalanceTickRange\\r\\n  ) internal pure returns (bool) {\\r\\n    if (upperTick - lowerTick == tickSpacing) {\\r\\n      return tick < lowerTick || tick >= upperTick;\\r\\n    } else {\\r\\n      int24 halfRange = (upperTick - lowerTick) / 2;\\r\\n      int24 oldMedianTick = lowerTick + halfRange;\\r\\n      return (tick > oldMedianTick)\\r\\n        ? tick - oldMedianTick >= rebalanceTickRange\\r\\n        : oldMedianTick - tick > rebalanceTickRange;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function _needPoolRebalance(PairBasedStrategyLogicLib.PairState storage pairState, int24 tick) internal view returns (bool) {\\r\\n    return _needPoolRebalance(\\r\\n      tick,\\r\\n      pairState.lowerTick,\\r\\n      pairState.upperTick,\\r\\n      pairState.tickSpacing,\\r\\n      pairState.rebalanceTickRange\\r\\n    );\\r\\n  }\\r\\n  //endregion ------------------------------------------------------- needStrategyRebalance\\r\\n}\\r\\n\",\"keccak256\":\"0xa1de412c47d5ef698afdb1fe0afe130a9b66dae28ef90aaec4349ca482f24863\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506200001c62000022565b620000e3565b600054610100900460ff16156200008f5760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff90811614620000e1576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b615d1880620000f36000396000f3fe608060405234801561001057600080fd5b50600436106103645760003560e01c80636b5fba5a116101c9578063ab9e3eee116100ff578063ceee861d116100ad578063dee1f0e41161007c578063dee1f0e4146107ac578063dfeb1032146107bf578063f77c4791146107d2578063ffb86c6a146107da57600080fd5b8063ceee861d14610765578063d295ea7014610789578063db8d55f114610791578063de3d047c1461079957600080fd5b8063ab9e3eee146106db578063b2457556146106e3578063b429afeb146106f6578063b77c975b14610709578063bd38837b1461073b578063cd4c81561461074c578063ce2f18421461075d57600080fd5b80637eba7ba611610177578063936725ec11610146578063936725ec146105e557806396b7b14e146106845780639d0bcca014610697578063a3f4df7e1461069f57600080fd5b80637eba7ba6146106315780637efc77fa14610643578063877887821461066957806387c7f7701461067157600080fd5b80636b5fba5a146105a45780636ffb4c8e146105b75780637063a237146105ca57806371ee0175146105dd57806373a50ef5146105e557806378327438146106095780637cc963801461062957600080fd5b80634593144c1161029e57806351e03fbe1161024c5780635641ec031161021b5780635641ec031461055b5780635cfc1a51146105635780636207a0cf1461056d57806363e277341461059157600080fd5b806351e03fbe1461051357806352bbbb74146105265780635412335d1461053b578063546799631461055357600080fd5b80634593144c146104b05780634ad0b684146104b85780634ba31b01146104c05780634e71d92d146104c85780634fa5d854146104d05780634fac6ccd146104ed578063507142d91461050057600080fd5b80631d2dca9e1161031657806333c5b58e116102e557806333c5b58e1461046a57806338d52e0f146104725780633cd8045e1461048c57806342fdb4711461049d57600080fd5b80631d2dca9e146104345780632221eb3c14610447578063261efa121461045a578063325a19f11461046257600080fd5b806301e1d1141461036957806301ffc9a714610384578063066a6fc3146103a7578063074424d6146103ba5780630acd12c7146103eb5780630e30428d146103f3578063150b7a0214610408575b600080fd5b6103716107e2565b6040519081526020015b60405180910390f35b6103976103923660046148ce565b61086d565b604051901515815260200161037b565b6103976103b53660046149fb565b6108b3565b6103de604051806040016040528060058152602001640312e302e360dc1b81525081565b60405161037b9190614ae5565b610371610a92565b610406610401366004614af8565b610bb4565b005b61041b610416366004614b24565b610c58565b6040516001600160e01b0319909116815260200161037b565b610406610442366004614b9d565b610c69565b610406610455366004614bba565b610dd2565b606854610371565b610371610e48565b610371610e78565b6064546001600160a01b03165b60405161037b9190614bd3565b6065546001600160a01b031661047f565b6104066104ab366004614bba565b610ef8565b610371610fe7565b609754610371565b610371611017565b61040661108e565b6104d8611108565b6040805192835260208301919091520161037b565b6104066104fb366004614be7565b611176565b61040661050e366004614c24565b6112a8565b610371610521366004614bba565b611658565b61052e611820565b60405161037b9190614d74565b610543611a8e565b60405161037b9493929190614db9565b6103de611b1d565b610406611bb2565b600160ff1b610371565b6103de604051806040016040528060058152602001640ccb8c4b8d60da1b81525081565b61040661059f366004614e5d565b611c4b565b6104066105b2366004614be7565b611d29565b6104066105c5366004614bba565b611dba565b6104066105d8366004614ece565b611e42565b609954610371565b6103de60405180604001604052806005815260200164332e302e3160d81b81525081565b610371610617366004614be7565b60966020526000908152604090205481565b610371611ee0565b61037161063f366004614bba565b5490565b6103de60405180604001604052806007815260200166416c676562726160c81b81525081565b606754610371565b61037161067f366004614af8565b611f10565b610406610692366004614f8f565b6121f6565b61047f61229b565b6103de6040518060400160405280601a81526020017f416c676562726120436f6e76657274657220537472617465677900000000000081525081565b6103976122cb565b6103716106f1366004615050565b612398565b610397610704366004614be7565b612447565b61071c610717366004615080565b61246c565b604080516001600160a01b03909316835260208301919091520161037b565b6098546001600160a01b031661047f565b6066546001600160a01b031661047f565b609a54610371565b6103de60405180604001604052806005815260200164332e312e3360d81b81525081565b606954610371565b6104d861255e565b6104066107a7366004614bba565b6125d6565b6103976107ba366004614be7565b612633565b6104066107cd3660046150b4565b6126b8565b61047f612760565b610397612790565b60006107ed60975490565b6064546040516370a0823160e01b81526001600160a01b03909116906370a082319061081d903090600401614bd3565b602060405180830381865afa15801561083a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061085e9190615131565b6108689190615160565b905090565b60006001600160e01b03198216631e94dddf60e01b148061089e57506001600160e01b0319821663f73147b360e01b145b806108ad57506108ad826127de565b92915050565b60008060006108c0612803565b91509150606073eD92d01D784c2458b19441eDf4135c66915F93ee63911ec05360976040518060a001604052808e6001600160a01b03166001600160a01b031681526020018d6001600160a01b03166001600160a01b03168152602001610925612760565b6001600160a01b039081168252609854811660208084019190915260655490911660409283015281516080810183528e8152908101899052808201889052606081018b905290516001600160e01b031960e086901b168152610996939291908d908d90600190609690600401615196565b600060405180830381865af41580156109b3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526109db919081019061527a565b90945090506109e981612855565b60006010558380156109fe57506109fe612884565b15610a09576001600f555b606480546040516368f9467b60e01b81526001600160a01b039091166004820152602481018490526097604482015273c1Ed5dD095C703421F623F416b88bbf57a1E1012916368f9467b910160006040518083038186803b158015610a6d57600080fd5b505af4158015610a81573d6000803e3d6000fd5b505050505050509695505050505050565b606554606454604051633e53813360e11b81526000926001600160a01b0390811692169083907306c875daA1Dc2E27dd7381EB3b6be4F99553a60990637ca7026690610ae490869086906004016152c0565b602060405180830381865af4158015610b01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b259190615131565b90506000806000610b34612896565b9250925092507306c875daA1Dc2E27dd7381EB3b6be4F99553a609639ad00ec2868686868b6040518663ffffffff1660e01b8152600401610b799594939291906152da565b60006040518083038186803b158015610b9157600080fd5b505af4158015610ba5573d6000803e3d6000fd5b50929998505050505050505050565b73c1Ed5dD095C703421F623F416b88bbf57a1E101263142395ef610bd6612760565b6040516001600160e01b031960e084901b1681526001600160a01b03918216600482015290851660248201526044810184905260640160006040518083038186803b158015610c2457600080fd5b505af4158015610c38573d6000803e3d6000fd5b5050506001600160a01b0390921660009081526096602052604090205550565b630a85bd0160e11b5b949350505050565b6000610c73612760565b60405163124fdbb760e21b81529091507306c875daA1Dc2E27dd7381EB3b6be4F99553a6099063493f6edc90610cad908490600401614bd3565b60006040518083038186803b158015610cc557600080fd5b505af4158015610cd9573d6000803e3d6000fd5b50505050600080610ce8612803565b604080518082019091526098546001600160a01b03168152919350915060009073eD92d01D784c2458b19441eDf4135c66915F93ee9063b6fda8139060979060019060208101610d378a6128b1565b6001600160a01b039081169091526065546040516001600160e01b031960e088901b168152610d77959493928a928c929116908e90609690600401615336565b600060405180830381865af4158015610d94573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610dbc9190810190615388565b9050610dc781612855565b505042601055505050565b7306c875daA1Dc2E27dd7381EB3b6be4F99553a60963493f6edc610df4612760565b6040518263ffffffff1660e01b8152600401610e109190614bd3565b60006040518083038186803b158015610e2857600080fd5b505af4158015610e3c573d6000803e3d6000fd5b505050600f9190915550565b600061086861063f60017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b6153bc565b60007306c875daA1Dc2E27dd7381EB3b6be4F99553a60963493f6edc610e9c612760565b6040518263ffffffff1660e01b8152600401610eb89190614bd3565b60006040518083038186803b158015610ed057600080fd5b505af4158015610ee4573d6000803e3d6000fd5b50505050610ef0612915565b509092915050565b7306c875daA1Dc2E27dd7381EB3b6be4F99553a60963493f6edc610f1a612760565b6040518263ffffffff1660e01b8152600401610f369190614bd3565b60006040518083038186803b158015610f4e57600080fd5b505af4158015610f62573d6000803e3d6000fd5b5073626aB57b826869B8AE32D32487E0AB6405625bb39250636bffb346915060069050836003811115610f9757610f976153cf565b6040518363ffffffff1660e01b8152600401610fb49291906153e5565b60006040518083038186803b158015610fcc57600080fd5b505af4158015610fe0573d6000803e3d6000fd5b5050505050565b600061086861063f60017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f16153bc565b604051630a3c2bb160e21b81526001600482015260009073eD92d01D784c2458b19441eDf4135c66915F93ee906328f0aec490602401602060405180830381865af415801561106a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108689190615131565b7306c875daA1Dc2E27dd7381EB3b6be4F99553a60963d19cc38a6110b0612760565b6040518263ffffffff1660e01b81526004016110cc9190614bd3565b60006040518083038186803b1580156110e457600080fd5b505af41580156110f8573d6000803e3d6000fd5b505050506111046129e6565b5050565b60655460408051808201909152600a81526914d08e8811195b9a595960b21b60208201526000918291906001600160a01b031633146111635760405162461bcd60e51b815260040161115a9190614ae5565b60405180910390fd5b5061116e6001612aa2565b915091509091565b3330146111c55760405162461bcd60e51b815260206004820152601b60248201527f496e637265617365207265766973696f6e20666f7262696464656e0000000000604482015260640161115a565b60006111f561063f60017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd6153bc565b611200906001615160565b90506112348161123160017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd6153bc565b55565b6112638261123160017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e46153bc565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c8910160405180910390a15050565b600054610100900460ff16158080156112c85750600054600160ff909116105b806112e25750303b1580156112e2575060005460ff166001145b6113455760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161115a565b6000805460ff191660011790558015611368576000805461ff0019166101001790555b6113738a8a8a612c9b565b73eD92d01D784c2458b19441eDf4135c66915F93ee632df3c9a9600160405180604001604052808e6001600160a01b03166001600160a01b031681526020018b6001600160a01b03166001600160a01b031681525089898e6001600160a01b03166338d52e0f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611408573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061142c9190615417565b8a896040518863ffffffff1660e01b81526004016114509796959493929190615434565b60006040518083038186803b15801561146857600080fd5b505af415801561147c573d6000803e3d6000fd5b50506040805163c3724a8960e01b81526001600482015286516001600160a01b03908116602483015260208801518116604483015291870151909116606482015260608601516084820152608086015160a482015273eD92d01D784c2458b19441eDf4135c66915F93ee925063c3724a89915060c40160006040518083038186803b15801561150a57600080fd5b505af415801561151e573d6000803e3d6000fd5b505060405163bd85be2960e01b8152600160048201527306c875daA1Dc2E27dd7381EB3b6be4F99553a6099250637fc1c15b915060649073eD92d01D784c2458b19441eDf4135c66915F93ee9063bd85be2990602401600060405180830381865af4158015611591573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526115b99190810190615485565b6040518363ffffffff1660e01b81526004016115d69291906154fb565b60006040518083038186803b1580156115ee57600080fd5b505af4158015611602573d6000803e3d6000fd5b50505050801561164c576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050505050565b606554606454604051633e53813360e11b81526000926001600160a01b0390811692169083907306c875daA1Dc2E27dd7381EB3b6be4F99553a60990637ca70266906116aa90869086906004016152c0565b602060405180830381865af41580156116c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116eb9190615131565b9050808511156117975760008061170a61170584896153bc565b612d3d565b604051631594b05b60e01b815290985091935091507306c875daA1Dc2E27dd7381EB3b6be4F99553a60990631594b05b906117519087908790879087908c906004016152da565b602060405180830381865af415801561176e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117929190615131565b925050505b6040516333bbb20360e11b815260048101869052602481018290526001600160a01b038084166044830152841660648201527306c875daA1Dc2E27dd7381EB3b6be4F99553a6099063677764069060840160006040518083038186803b15801561180057600080fd5b505af4158015611814573d6000803e3d6000fd5b50505050505050919050565b60025460408051600480825260a082019092526060926001600160a01b0316916020820160808036833750506003546040516370a0823160e01b81529294506001600160a01b0316916370a08231915061187e908490600401614bd3565b602060405180830381865afa15801561189b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118bf9190615131565b826000815181106118d2576118d2615514565b6020908102919091010152600480546040516370a0823160e01b81526001600160a01b03909116916370a082319161190c91859101614bd3565b602060405180830381865afa158015611929573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194d9190615131565b8260018151811061196057611960615514565b60209081029190910101526033546040516370a0823160e01b81526001600160a01b03909116906370a082319061199b908490600401614bd3565b602060405180830381865afa1580156119b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119dc9190615131565b826002815181106119ef576119ef615514565b60209081029190910101526034546040516370a0823160e01b81526001600160a01b03909116906370a0823190611a2a908490600401614bd3565b602060405180830381865afa158015611a47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a6b9190615131565b82600381518110611a7e57611a7e615514565b6020026020010181815250505090565b604051636e81b62960e01b81526001600482015260609081908190819073E8dfB7074F4E14b7eDD1E08C03Fa6079c9E091b590636e81b62990602401600060405180830381865af4158015611ae7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611b0f91908101906155f2565b935093509350935090919293565b606060646006018054611b2f906156f0565b80601f0160208091040260200160405190810160405280929190818152602001828054611b5b906156f0565b8015611ba85780601f10611b7d57610100808354040283529160200191611ba8565b820191906000526020600020905b815481529060010190602001808311611b8b57829003601f168201915b5050505050905090565b611bba612d6e565b7306c875daA1Dc2E27dd7381EB3b6be4F99553a60963bd020682611bdc612760565b6064805460655460405160e086901b6001600160e01b03191681526001600160a01b03948516600482015291841660248301529290921660448301520160006040518083038186803b158015611c3157600080fd5b505af4158015611c45573d6000803e3d6000fd5b50505050565b7306c875daA1Dc2E27dd7381EB3b6be4F99553a60963493f6edc611c6d612760565b6040518263ffffffff1660e01b8152600401611c899190614bd3565b60006040518083038186803b158015611ca157600080fd5b505af4158015611cb5573d6000803e3d6000fd5b5050604051637fc1c15b60e01b81527306c875daA1Dc2E27dd7381EB3b6be4F99553a6099250637fc1c15b9150611cf5906064908690869060040161572a565b60006040518083038186803b158015611d0d57600080fd5b505af4158015611d21573d6000803e3d6000fd5b505050505050565b7306c875daA1Dc2E27dd7381EB3b6be4F99553a60963493f6edc611d4b612760565b6040518263ffffffff1660e01b8152600401611d679190614bd3565b60006040518083038186803b158015611d7f57600080fd5b505af4158015611d93573d6000803e3d6000fd5b5050600280546001600160a01b0319166001600160a01b0394909416939093179092555050565b73c1Ed5dD095C703421F623F416b88bbf57a1E101263d2c3cf25611ddc612760565b6040516001600160e01b031960e084901b1681526001600160a01b0390911660048201526024810184905260440160006040518083038186803b158015611e2257600080fd5b505af4158015611e36573d6000803e3d6000fd5b50505060999190915550565b7306c875daA1Dc2E27dd7381EB3b6be4F99553a60963ed6b63c16064858585611e69612760565b6040516001600160e01b031960e088901b168152600481019590955260248501939093526001600160a01b039182166044850152606484015216608482015260a40160006040518083038186803b158015611ec357600080fd5b505af4158015611ed7573d6000803e3d6000fd5b50505050505050565b600061086861063f60017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd6153bc565b6000611f1a614886565b611f2684826000612db9565b805160408051808201909152600a81526914d08e8811195b9a595960b21b6020820152906001600160a01b03163314611f725760405162461bcd60e51b815260040161115a9190614ae5565b5060408051808201909152601081526f54532d3234207a65726f2076616c756560801b602082015283611fb85760405162461bcd60e51b815260040161115a9190614ae5565b5060001981606001511415604051806040016040528060118152602001701514cb4c4d081ddc9bdb99c8185cdcd95d607a1b8152509061200b5760405162461bcd60e51b815260040161115a9190614ae5565b506000806120196001612e33565b608085015160405163513cfdb360e11b81526001600160a01b038a16600482015260248101919091526044810183905260648181018390526084820152919350915073c1Ed5dD095C703421F623F416b88bbf57a1E10129063a279fb669060a401602060405180830381865af4158015612097573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120bb9190615131565b60808401526000620186a06120d26103e882615160565b6120dc9088615760565b6120e69190615777565b90508084608001511061211257835161210a906001600160a01b0389169088612efd565b8594506121e3565b8260000361214d576121296103e8620186a0615160565b620186a0856080015161213c9190615760565b6121469190615777565b94506121e3565b6000620186a06121606103e86002615760565b61216d90620186a0615160565b6121779089615760565b6121819190615777565b905061219c85608001518261219691906153bc565b86612f4f565b5060006121a8896131b4565b90508281116121dc576121c06103e8620186a0615160565b6121cd620186a083615760565b6121d79190615777565b6121de565b875b965050505b6121eb613224565b505050505092915050565b60985460408051808201909152600a81526914d08e8811195b9a595960b21b6020820152906001600160a01b031633146122435760405162461bcd60e51b815260040161115a9190614ae5565b5080518251146040518060400160405280600d81526020016c54532d3139206c656e6774687360981b8152509061228d5760405162461bcd60e51b815260040161115a9190614ae5565b50612296613224565b505050565b600061086861063f60017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e46153bc565b60006122d5612790565b1580156122e757506122e5612884565b155b8015610868575060985473eD92d01D784c2458b19441eDf4135c66915F93ee9063d1585fc4906001906001600160a01b0316612321612760565b6040516001600160e01b031960e086901b16815260048101939093526001600160a01b0391821660248401521660448201526064015b602060405180830381865af4158015612374573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108689190615799565b6065546064546040516001625acc3160e01b0319815260009283927306c875daA1Dc2E27dd7381EB3b6be4F99553a6099263ffa533cf926123ea926001600160a01b03918216929116906004016152c0565b602060405180830381865af4158015612407573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061242b9190615131565b905080156124405761243d818461323a565b91505b5092915050565b6000612451612760565b6001600160a01b0316826001600160a01b0316149050919050565b6005546000908190630100000090046001600160801b031681811561249957612494826132e6565b6124b7565b60408051600280825260608201835290916020830190803683375050505b905073E8dfB7074F4E14b7eDD1E08C03Fa6079c9E091b56350d2e0ba600187846124df612760565b6098546040516001600160e01b031960e088901b16815261251395949392916001600160a01b0316906096906004016157b6565b6040805180830381865af415801561252f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125539190615807565b935093505050915091565b604051632cc58ef960e01b815260016004820152600090819073eD92d01D784c2458b19441eDf4135c66915F93ee90632cc58ef9906024016040805180830381865af41580156125b2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061116e9190615835565b7306c875daA1Dc2E27dd7381EB3b6be4F99553a609636d51f04360646125fa612760565b6040516001600160e01b031960e085901b16815260048101929092526001600160a01b0316602482015260448101849052606401610fb4565b6000816001600160a01b0316612647612760565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015612684573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126a89190615417565b6001600160a01b03161492915050565b7306c875daA1Dc2E27dd7381EB3b6be4F99553a60963493f6edc6126da612760565b6040518263ffffffff1660e01b81526004016126f69190614bd3565b60006040518083038186803b15801561270e57600080fd5b505af4158015612722573d6000803e3d6000fd5b5050604051630593c4c960e01b815273626aB57b826869B8AE32D32487E0AB6405625bb39250630593c4c99150610fb4906006908590600401615859565b600061086861063f60017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c36186153bc565b609854604051633934e59d60e11b8152600160048201526001600160a01b03909116602482015260009073eD92d01D784c2458b19441eDf4135c66915F93ee90637269cb3a90604401612357565b60006001600160e01b0319821663c19fa56160e01b14806108ad57506108ad82613370565b6000806128106001612e33565b925082905061281d6107e2565b61282791906153bc565b600554909150630100000090046001600160801b031680156128505761284e8160006133a5565b505b509091565b8051600214801561286b5750612869612884565b155b1561287c576128798161343e565b50505b611104613224565b6006546000906108689060ff166134cb565b60008060006128a6600019612d3d565b925092509250909192565b6000816001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156128f1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ad9190615417565b606454600090606090819083908190612936906001600160a01b03166134e8565b9150915073c1Ed5dD095C703421F623F416b88bbf57a1E1012637325f33f8361295e85613554565b6098546040516001600160e01b031960e086901b16815261299493929187916001600160a01b03909116906001906004016158a6565b600060405180830381865af41580156129b1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526129d991908101906158f4565b9450945094505050909192565b60608060008060006129f66135d2565b609854929550909350915073c1Ed5dD095C703421F623F416b88bbf57a1E10129063e99de4da906001600160a01b0316612a2e613651565b8686866040518663ffffffff1660e01b8152600401612a51959493929190615960565b600060405180830381865af4158015612a6e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612a9691908101906159ca565b90969095509350505050565b600080600080612ab26001612e33565b91509150612abf856136e5565b612c19576000806000806000612ad3613798565b945094509450945094506000612ae7612915565b505090506000612b398c8015612afc57508215155b8015612b235750609954620186a090612b16908590615760565b612b209190615777565b86115b612b2e576000612b30565b855b8984600161387b565b9150612b7d9050612b4a8684615160565b6064548390612b61906001600160a01b03166131b4565b609754612b6e9190615160565b612b789190615160565b613ac8565b909b509950604080518a8152602081018a905290810188905260608101879052608081018c905260a081018b905260c0810185905260e081018490527ff87a9dead982c86370b885093f79ded2c9a614d95d83c0c20f68e13e3b9b7d3f906101000160405180910390a1612c03612bf4888d615160565b612bfe8587615160565b613af8565b9a50612c0f868b615160565b9950505050505050505b6098546064546040516323c1ae5960e11b815273c1Ed5dD095C703421F623F416b88bbf57a1E1012926347835cb292612c64926001600160a01b0392831692909116906004016152c0565b60006040518083038186803b158015612c7c57600080fd5b505af4158015612c90573d6000803e3d6000fd5b505050505050915091565b600054610100900460ff16612cc25760405162461bcd60e51b815260040161115a90615a23565b612ccc8383613b12565b609880546001600160a01b0319166001600160a01b038316179055612cf56064620186a0615777565b6099557fe4166dfcf23bbd3e3f764a99dc8fa740554c03c82d6019b81cf265f396f6f2fe612d276064620186a0615777565b60405190815260200160405180910390a1505050565b6000806000806000612d4f6001612e33565b91509150612d5e868284613bbb565b5091989097509095509350505050565b6000612d78613dc8565b90507f768a28cb3459382a3d2173feb2dad0235f8de680b109872da581a3aa269fe5f481604051612da99190614d74565b60405180910390a1611104613224565b612dc1613651565b604083018190526001600160a01b038085166020850152609854168352612de89084613e4f565b6060830152612df6836131b4565b608083015280612e20576040820151606454612e1b91906001600160a01b0316613e4f565b612e26565b81606001515b60a0909201919091525050565b6000808215612ef0576064546000908190612e56906001600160a01b03166134e8565b9150915073c1Ed5dD095C703421F623F416b88bbf57a1E1012633643611860976064612e8186613554565b86866040518663ffffffff1660e01b8152600401612ea3959493929190615a6e565b6040805180830381865af4158015612ebf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ee39190615835565b9094509250612ef8915050565b505060975460005b915091565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b179052612296908490613ead565b600080612f6c6005546001600160801b0363010000009091041690565b90506000612f79826132e6565b9050600073c1Ed5dD095C703421F623F416b88bbf57a1E1012630252e2c78787604001518860600151896000015187898c60a001516040518863ffffffff1660e01b8152600401612fd09796959493929190615ab2565b602060405180830381865af4158015612fed573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130119190615131565b905080156130835760006130268260006133a5565b600554909150630100000090046001600160801b031661304690856153bc565b91507faebc771af58936b05e89b0be7d3f9761480181abcd4a649fbdd01753fda169708282604051613079929190615b0a565b60405180910390a1505b600073cD14081DDD966ADbCEc1930Bbe541765EBA2D68663c432aee18760400151886060015189600001516130be6130b9612760565b6128b1565b6000198d146130dc578c8c608001516130d79190615160565b6130de565b8c5b60966040518763ffffffff1660e01b815260040161310196959493929190615b23565b602060405180830381865af415801561311e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131429190615131565b905085608001518110156040518060400160405280601681526020017554532d32302062616c616e636520646563726561736560501b815250906131995760405162461bcd60e51b815260040161115a9190614ae5565b5060808601516131a990826153bc565b979650505050505050565b6040516370a0823160e01b81526000906001600160a01b038316906370a08231906131e3903090600401614bd3565b602060405180830381865afa158015613200573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ad9190615131565b600061322e612915565b50506097819055919050565b60065460009061324c9060ff166134cb565b156132d557604080516002808252606082018352600092602083019080368337019050509050838160008151811061328657613286615514565b6020026020010181815250507f59400c8c523464b521238ea8f50e923f2bc64663557e6afec92a97f7efe92d0581826040516132c3929190615b66565b60405180910390a160009150506108ad565b6132df8383613f7f565b90506108ad565b60405163a7aced0960e01b8152600160048201526001600160801b038216602482015260609073eD92d01D784c2458b19441eDf4135c66915F93ee9063a7aced0990604401600060405180830381865af4158015613348573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526108ad9190810190615388565b60006001600160e01b0319821663b7b79fa960e01b14806108ad57506301ffc9a760e01b6001600160e01b03198316146108ad565b604051635b1e6c8160e11b8152600160048201526001600160801b0383166024820152811515604482015260609073eD92d01D784c2458b19441eDf4135c66915F93ee9063b63cd90290606401600060405180830381865af415801561340f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526134379190810190615388565b9392505050565b6060600073eD92d01D784c2458b19441eDf4135c66915F93ee63b67626216001856040518363ffffffff1660e01b815260040161347c929190615b0a565b600060405180830381865af4158015613499573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526134c19190810190615b8b565b9094909350915050565b600060018260038111156134e1576134e16153cf565b1192915050565b606060006134f4613651565b91506135008284613e4f565b90506000198114156040518060400160405280600f81526020016e53423a2057726f6e672076616c756560881b8152509061354e5760405162461bcd60e51b815260040161115a9190614ae5565b50915091565b606060006135726005546001600160801b0363010000009091041690565b9050801561358857613583816132e6565b613437565b82516001600160401b038111156135a1576135a1614910565b6040519080825280602002602001820160405280156135ca578160200160208202803683370190505b509392505050565b60405163f6e2611760e01b8152600160048201526060908190819073eD92d01D784c2458b19441eDf4135c66915F93ee9063f6e2611790602401600060405180830381865af4158015613629573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526128a69190810190615bd1565b6040805160028082526060808301845292602083019080368337505060035482519293506001600160a01b03169183915060009061369157613691615514565b6001600160a01b0392831660209182029290920101526004548251911690829060019081106136c2576136c2615514565b60200260200101906001600160a01b031690816001600160a01b03168152505090565b60006136ef612790565b156040518060400160405280601381526020017241532d31204e65656420726562616c616e636560681b8152509061373a5760405162461bcd60e51b815260040161115a9190614ae5565b50613743612884565b156040518060400160405280601481526020017341532d313420467573652069732061637469766560601b8152509061378f5760405162461bcd60e51b815260040161115a9190614ae5565b50600092915050565b60008060008060008060006137ab6129e6565b600354919350915073eD92d01D784c2458b19441eDf4135c66915F93ee906334d2ec3d906001600160a01b03166137e0612760565b85856040518563ffffffff1660e01b81526004016138019493929190615c1f565b602060405180830381865af415801561381e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138429190615131565b965061384e8282613fa8565b60645491955093508790879061386c906001600160a01b03166131b4565b96509650965050509091929394565b60645460009081906001600160a01b03168186881161389b5760006138a5565b6138a587896153bc565b90506000620186a0876097600201546138be9190615760565b6138c89190615777565b8211905060006138d7846131b4565b6001600160a01b0385166000908152609660205260409020549091506138fc90614053565b8911156139eb57818061390f5750888110155b156139d75760655473c1Ed5dD095C703421F623F416b88bbf57a1E10129063890ffb849086908c906001600160a01b031661394a868e615160565b6040516001600160e01b031960e087901b1681526001600160a01b03948516600482015260248101939093529216604482015260648101919091526084810184905260a4016040805180830381865af41580156139ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139cf9190615835565b5094506139eb565b6139e360008a8a613bbb565b909850965050505b8115613aaf576000806139fd866134e8565b6098549193509150600090613a1d906001600160a01b031687858561406b565b9050613a2881614320565b613a75576000613a378261343e565b5090507f59400c8c523464b521238ea8f50e923f2bc64663557e6afec92a97f7efe92d058282604051613a6b929190615b66565b60405180910390a1505b6000613a7f613224565b9050613aa2613a8e868e615160565b8a613a988b6131b4565b612b6e9085615160565b9a50613abb945050505050565b8615613abb5760978890555b5050505094509492505050565b60008083831115613ae457613add84846153bc565b9150613af1565b613aee83856153bc565b90505b9250929050565b6000818311613b08576000613437565b61343782846153bc565b600054610100900460ff16613b395760405162461bcd60e51b815260040161115a90615a23565b613b63817fd2de0374d4479f33e63ae5ed6ca772a10463dd883a90c612050b51fab619640061436c565b613b6c826143c2565b604051631797527d60e01b81526064600482018190526001600160a01b038085166024840152831660448301527306c875daA1Dc2E27dd7381EB3b6be4F99553a60991631797527d9101611cf5565b60008060008060006000198814613bff57620186a0613bdc6103e882615160565b613be6898b615160565b613bf09190615760565b613bfa9190615777565b613c01565b875b9050613c0c816145e7565b8015801590613c1a57508515155b15613dbe57613c27614886565b606454613c3f906001600160a01b0316826001612db9565b80516020820151604051637a55caf360e01b815273c1Ed5dD095C703421F623F416b88bbf57a1E101292637a55caf392613c7b926004016152c0565b602060405180830381865af4158015613c98573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613cbc9190615131565b9450670de0b6b3a764000085613cdb613cd58585612f4f565b8b613af8565b613ce59190615760565b613cef9190615777565b6065546020830151608084015192985073c1Ed5dD095C703421F623F416b88bbf57a1E101292632ce30333926001600160a01b031691908b908d613d31613224565b6040516001600160e01b031960e089901b1681526001600160a01b03968716600482015295909416602486015260448501929092526064840152608483015260a482015260c4016040805180830381865af4158015613d94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613db89190615835565b94509250505b5093509350935093565b60606000613de66005546001600160801b0363010000009091041690565b90508015613dfe57613df98160016133a5565b613e49565b613e06613651565b516001600160401b03811115613e1e57613e1e614910565b604051908082528060200260200182016040528015613e47578160200160208202803683370190505b505b91505090565b8151600090815b81811015613ea157836001600160a01b0316858281518110613e7a57613e7a615514565b60200260200101516001600160a01b031603613e995791506108ad9050565b600101613e56565b50600019949350505050565b6000613f02826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b031661463a9092919063ffffffff16565b8051909150156122965780806020019051810190613f209190615799565b6122965760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b606482015260840161115a565b6000806000613f8d84612e33565b91509150613f9e858284600061387b565b5095945050505050565b6000808351600014613af15773cD14081DDD966ADbCEc1930Bbe541765EBA2D686635dcb613060646097613fda613651565b613fe2612760565b60968a8a6040518863ffffffff1660e01b81526004016140089796959493929190615c5d565b6040805180830381865af4158015614024573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906140489190615835565b909590945092505050565b6000811561406157816108ad565b620186a092915050565b6060614075612790565b156040518060400160405280601381526020017241532d31204e65656420726562616c616e636560681b815250906140c05760405162461bcd60e51b815260040161115a9190614ae5565b50600154600480546040516221c5bf60e11b81526001600160a01b0390931691830191909152600160c81b8104600290810b6024840152600160e01b8204900b6044830152600160a81b900460ff1615156064820152600090819073eD92d01D784c2458b19441eDf4135c66915F93ee9062438b7e906084016040805180830381865af4158015614155573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141799190615835565b6003546004549294509092506001600160a01b039081169173E8dfB7074F4E14b7eDD1E08C03Fa6079c9E091b591631c2040d5918b918b918691166141be888a615160565b6141d08a670de0b6b3a7640000615760565b6141da9190615777565b60405160e087901b6001600160e01b03191681526001600160a01b0395861660048201526024810194909452918416604484015290921660648201526084810191909152609660a482015260c401600060405180830381865af4158015614245573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261426d9190810190615388565b9350806001600160a01b03168660008151811061428c5761428c615514565b60200260200101516001600160a01b03161461431557836001815181106142b5576142b5615514565b6020026020010151846000815181106142d0576142d0615514565b6020026020010151856000815181106142eb576142eb615514565b602002602001018660018151811061430557614305615514565b6020908102919091010191909152525b505050949350505050565b8051600090815b818110156143625783818151811061434157614341615514565b602002602001015160000361435a575060019392505050565b600101614327565b5060009392505050565b6143768282614649565b6111045760405162461bcd60e51b815260206004820152601a60248201527f496e74657266616365206973206e6f7420737570706f72746564000000000000604482015260640161115a565b600054610100900460ff166143e95760405162461bcd60e51b815260040161115a90615a23565b6001600160a01b0381166144315760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b604482015260640161115a565b61445b817f4c2403fdcb3cff9b705d96bf0705858e3390412670a62c8bcba611ca7e20ab8661436c565b60006001600160a01b0316816001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa1580156144a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906144c89190615417565b6001600160a01b0316036145105760405162461bcd60e51b815260206004820152600f60248201526e5a65726f20676f7665726e616e636560881b604482015260640161115a565b61453f8161123160017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c36186153bc565b61456e4261123160017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b6153bc565b61459d4361123160017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f16153bc565b604080516001600160a01b0383168152426020820152438183015290517f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe2367134269181900360600190a150565b6145ef612790565b156040518060400160405280601381526020017241532d31204e65656420726562616c616e636560681b815250906111045760405162461bcd60e51b815260040161115a9190614ae5565b6060610c61848460008561471d565b60006001600160a01b0383166146905760405162461bcd60e51b815260206004820152600c60248201526b5a65726f206164647265737360a01b604482015260640161115a565b823b60008190036146a55760009150506108ad565b6040516301ffc9a760e01b81526001600160e01b0319841660048201526001600160a01b038516906301ffc9a790602401602060405180830381865afa92505050801561470f575060408051601f3d908101601f1916820190925261470c91810190615799565b60015b156143625791506108ad9050565b60608247101561477e5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b606482015260840161115a565b600080866001600160a01b0316858760405161479a9190615cc6565b60006040518083038185875af1925050503d80600081146147d7576040519150601f19603f3d011682016040523d82523d6000602084013e6147dc565b606091505b50915091506131a98783838760608315614857578251600003614850576001600160a01b0385163b6148505760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161115a565b5081610c61565b610c61838381511561486c5781518083602001fd5b8060405162461bcd60e51b815260040161115a9190614ae5565b6040518060c0016040528060006001600160a01b0316815260200160006001600160a01b03168152602001606081526020016000815260200160008152602001600081525090565b6000602082840312156148e057600080fd5b81356001600160e01b03198116811461343757600080fd5b6001600160a01b038116811461490d57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60405160a081016001600160401b038111828210171561494857614948614910565b60405290565b604051601f8201601f191681016001600160401b038111828210171561497657614976614910565b604052919050565b60006001600160401b0382111561499757614997614910565b50601f01601f191660200190565b600082601f8301126149b657600080fd5b81356149c96149c48261497e565b61494e565b8181528460208386010111156149de57600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060008060c08789031215614a1457600080fd5b8635614a1f816148f8565b95506020870135614a2f816148f8565b94506040870135935060608701356001600160401b0380821115614a5257600080fd5b614a5e8a838b016149a5565b94506080890135915080821115614a7457600080fd5b50614a8189828a016149a5565b92505060a087013590509295509295509295565b60005b83811015614ab0578181015183820152602001614a98565b50506000910152565b60008151808452614ad1816020860160208601614a95565b601f01601f19169290920160200192915050565b6020815260006134376020830184614ab9565b60008060408385031215614b0b57600080fd5b8235614b16816148f8565b946020939093013593505050565b60008060008060808587031215614b3a57600080fd5b8435614b45816148f8565b93506020850135614b55816148f8565b92506040850135915060608501356001600160401b03811115614b7757600080fd5b614b83878288016149a5565b91505092959194509250565b801515811461490d57600080fd5b600060208284031215614baf57600080fd5b813561343781614b8f565b600060208284031215614bcc57600080fd5b5035919050565b6001600160a01b0391909116815260200190565b600060208284031215614bf957600080fd5b8135613437816148f8565b8060020b811461490d57600080fd5b80608081018310156108ad57600080fd5b6000806000806000806000806000898b03610200811215614c4457600080fd5b8a35614c4f816148f8565b995060208b0135614c5f816148f8565b985060408b0135614c6f816148f8565b975060608b0135614c7f816148f8565b965060808b0135614c8f81614c04565b955060a08b0135614c9f81614c04565b945060c08b0135614caf81614b8f565b935060a060df1982011215614cc357600080fd5b50614ccc614926565b60e08b0135614cda816148f8565b81526101008b0135614ceb816148f8565b60208201526101208b0135614cff816148f8565b60408201526101408b013560608201526101608b013560808201529150614d2a8b6101808c01614c13565b90509295985092959850929598565b600081518084526020808501945080840160005b83811015614d6957815187529582019590820190600101614d4d565b509495945050505050565b6020815260006134376020830184614d39565b600081518084526020808501945080840160005b83811015614d69578151151587529582019590820190600101614d9b565b6080808252855190820181905260009060209060a0840190828901845b82811015614dfb5781516001600160a01b031684529284019290840190600101614dd6565b5050508381038285015286518082528783019183019060005b81811015614e3357835160020b83529284019291840191600101614e14565b50508481036040860152614e478188614d39565b9250505082810360608401526131a98185614d87565b60008060208385031215614e7057600080fd5b82356001600160401b0380821115614e8757600080fd5b818501915085601f830112614e9b57600080fd5b813581811115614eaa57600080fd5b866020828501011115614ebc57600080fd5b60209290920196919550909350505050565b600080600060608486031215614ee357600080fd5b833592506020840135614ef5816148f8565b929592945050506040919091013590565b60006001600160401b03821115614f1f57614f1f614910565b5060051b60200190565b600082601f830112614f3a57600080fd5b81356020614f4a6149c483614f06565b82815260059290921b84018101918181019086841115614f6957600080fd5b8286015b84811015614f845780358352918301918301614f6d565b509695505050505050565b60008060408385031215614fa257600080fd5b82356001600160401b0380821115614fb957600080fd5b818501915085601f830112614fcd57600080fd5b81356020614fdd6149c483614f06565b82815260059290921b84018101918181019089841115614ffc57600080fd5b948201945b83861015615023578535615014816148f8565b82529482019490820190615001565b9650508601359250508082111561503957600080fd5b5061504685828601614f29565b9150509250929050565b6000806040838503121561506357600080fd5b82359150602083013561507581614b8f565b809150509250929050565b60006020828403121561509257600080fd5b81356001600160401b038111156150a857600080fd5b61243d848285016149a5565b6000608082840312156150c657600080fd5b82601f8301126150d557600080fd5b604051608081018181106001600160401b03821117156150f7576150f7614910565b60405280608084018581111561510c57600080fd5b845b8181101561512657803583526020928301920161510e565b509195945050505050565b60006020828403121561514357600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b808201808211156108ad576108ad61514a565b8060005b6004811015611c45578151845260209384019390910190600101615177565b60006101c089835260208084018a60005b60058110156151cd5781516001600160a01b0316835291830191908301906001016151a7565b505050506151de60c0840189615173565b806101408401526151f181840188614ab9565b90508281036101608401526152068187614ab9565b61018084019590955250506101a0015295945050505050565b600082601f83011261523057600080fd5b815160206152406149c483614f06565b82815260059290921b8401810191818101908684111561525f57600080fd5b8286015b84811015614f845780518352918301918301615263565b6000806040838503121561528d57600080fd5b825161529881614b8f565b60208401519092506001600160401b038111156152b457600080fd5b6150468582860161521f565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039586168152602081019490945260408401929092526060830152909116608082015260a00190565b8060005b6002811015611c455781516001600160a01b031684526020938401939091019060010161530e565b888152602081018890526101208101615352604083018961530a565b608082019690965260a08101949094526001600160a01b039290921660c0840152151560e0830152610100909101529392505050565b60006020828403121561539a57600080fd5b81516001600160401b038111156153b057600080fd5b61243d8482850161521f565b818103818111156108ad576108ad61514a565b634e487b7160e01b600052602160045260246000fd5b828152604081016004831061540a57634e487b7160e01b600052602160045260246000fd5b8260208301529392505050565b60006020828403121561542957600080fd5b8151613437816148f8565b8781526101608101615449602083018961530a565b8660020b60608301528560020b608083015260018060a01b03851660a083015283151560c083015260808360e084013798975050505050505050565b60006020828403121561549757600080fd5b81516001600160401b038111156154ad57600080fd5b8201601f810184136154be57600080fd5b80516154cc6149c48261497e565b8181528560208385010111156154e157600080fd5b6154f2826020830160208601614a95565b95945050505050565b828152604060208201526000610c616040830184614ab9565b634e487b7160e01b600052603260045260246000fd5b600082601f83011261553b57600080fd5b8151602061554b6149c483614f06565b82815260059290921b8401810191818101908684111561556a57600080fd5b8286015b84811015614f84578051615581816148f8565b835291830191830161556e565b600082601f83011261559f57600080fd5b815160206155af6149c483614f06565b82815260059290921b840181019181810190868411156155ce57600080fd5b8286015b84811015614f845780516155e581614b8f565b83529183019183016155d2565b6000806000806080858703121561560857600080fd5b84516001600160401b038082111561561f57600080fd5b61562b8883890161552a565b955060209150818701518181111561564257600080fd5b8701601f8101891361565357600080fd5b80516156616149c482614f06565b81815260059190911b8201840190848101908b83111561568057600080fd5b928501925b828410156156a757835161569881614c04565b82529285019290850190615685565b60408b01519098509450505050808211156156c157600080fd5b6156cd8883890161521f565b935060608701519150808211156156e357600080fd5b50614b838782880161558e565b600181811c9082168061570457607f821691505b60208210810361572457634e487b7160e01b600052602260045260246000fd5b50919050565b83815260406020820152816040820152818360608301376000818301606090810191909152601f909201601f1916010192915050565b80820281158282048414176108ad576108ad61514a565b60008261579457634e487b7160e01b600052601260045260246000fd5b500490565b6000602082840312156157ab57600080fd5b815161343781614b8f565b86815260c0602082015260006157cf60c0830188614ab9565b82810360408401526157e18188614d39565b6001600160a01b0396871660608501529490951660808301525060a00152949350505050565b6000806040838503121561581a57600080fd5b8251615825816148f8565b6020939093015192949293505050565b6000806040838503121561584857600080fd5b505080516020909101519092909150565b82815260a081016134376020830184615173565b600081518084526020808501945080840160005b83811015614d695781516001600160a01b031687529582019590820190600101615881565b60a0815260006158b960a083018861586d565b82810360208401526158cb8188614d39565b604084019690965250506001600160a01b03929092166060830152151560809091015292915050565b60008060006060848603121561590957600080fd5b8351925060208401516001600160401b038082111561592757600080fd5b6159338783880161521f565b9350604086015191508082111561594957600080fd5b506159568682870161521f565b9150509250925092565b6001600160a01b038616815260a0602082018190526000906159849083018761586d565b8281036040840152615996818761586d565b905082810360608401526159aa8186614d39565b905082810360808401526159be8185614d39565b98975050505050505050565b600080604083850312156159dd57600080fd5b82516001600160401b03808211156159f457600080fd5b615a008683870161552a565b93506020850151915080821115615a1657600080fd5b506150468582860161521f565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b85815284602082015260a060408201526000615a8d60a0830186614d39565b8281036060840152615a9f818661586d565b9150508260808301529695505050505050565b87815260e060208201526000615acb60e083018961586d565b604083018890526001600160a01b03871660608401528281036080840152615af38187614d39565b60a0840195909552505060c0015295945050505050565b828152604060208201526000610c616040830184614d39565b60c081526000615b3660c083018961586d565b6020830197909752506001600160a01b039485166040820152929093166060830152608082015260a00152919050565b604081526000615b796040830185614d39565b82810360208401526154f28185614d39565b60008060408385031215615b9e57600080fd5b82516001600160401b03811115615bb457600080fd5b615bc08582860161521f565b925050602083015190509250929050565b600080600060608486031215615be657600080fd5b83516001600160401b0380821115615bfd57600080fd5b615c098783880161552a565b9450602086015191508082111561592757600080fd5b6001600160a01b03858116825284166020820152608060408201819052600090615c4b9083018561586d565b82810360608401526131a98185614d39565b87815286602082015260e060408201526000615c7c60e083018861586d565b6001600160a01b03871660608401526080830186905282810360a0840152615ca4818661586d565b905082810360c0840152615cb88185614d39565b9a9950505050505050505050565b60008251615cd8818460208701614a95565b919091019291505056fea26469706673582212206c1b23f828f1b255caddccc473838130664e9c3ea2789cb785f31d8e4e1b367864736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106103645760003560e01c80636b5fba5a116101c9578063ab9e3eee116100ff578063ceee861d116100ad578063dee1f0e41161007c578063dee1f0e4146107ac578063dfeb1032146107bf578063f77c4791146107d2578063ffb86c6a146107da57600080fd5b8063ceee861d14610765578063d295ea7014610789578063db8d55f114610791578063de3d047c1461079957600080fd5b8063ab9e3eee146106db578063b2457556146106e3578063b429afeb146106f6578063b77c975b14610709578063bd38837b1461073b578063cd4c81561461074c578063ce2f18421461075d57600080fd5b80637eba7ba611610177578063936725ec11610146578063936725ec146105e557806396b7b14e146106845780639d0bcca014610697578063a3f4df7e1461069f57600080fd5b80637eba7ba6146106315780637efc77fa14610643578063877887821461066957806387c7f7701461067157600080fd5b80636b5fba5a146105a45780636ffb4c8e146105b75780637063a237146105ca57806371ee0175146105dd57806373a50ef5146105e557806378327438146106095780637cc963801461062957600080fd5b80634593144c1161029e57806351e03fbe1161024c5780635641ec031161021b5780635641ec031461055b5780635cfc1a51146105635780636207a0cf1461056d57806363e277341461059157600080fd5b806351e03fbe1461051357806352bbbb74146105265780635412335d1461053b578063546799631461055357600080fd5b80634593144c146104b05780634ad0b684146104b85780634ba31b01146104c05780634e71d92d146104c85780634fa5d854146104d05780634fac6ccd146104ed578063507142d91461050057600080fd5b80631d2dca9e1161031657806333c5b58e116102e557806333c5b58e1461046a57806338d52e0f146104725780633cd8045e1461048c57806342fdb4711461049d57600080fd5b80631d2dca9e146104345780632221eb3c14610447578063261efa121461045a578063325a19f11461046257600080fd5b806301e1d1141461036957806301ffc9a714610384578063066a6fc3146103a7578063074424d6146103ba5780630acd12c7146103eb5780630e30428d146103f3578063150b7a0214610408575b600080fd5b6103716107e2565b6040519081526020015b60405180910390f35b6103976103923660046148ce565b61086d565b604051901515815260200161037b565b6103976103b53660046149fb565b6108b3565b6103de604051806040016040528060058152602001640312e302e360dc1b81525081565b60405161037b9190614ae5565b610371610a92565b610406610401366004614af8565b610bb4565b005b61041b610416366004614b24565b610c58565b6040516001600160e01b0319909116815260200161037b565b610406610442366004614b9d565b610c69565b610406610455366004614bba565b610dd2565b606854610371565b610371610e48565b610371610e78565b6064546001600160a01b03165b60405161037b9190614bd3565b6065546001600160a01b031661047f565b6104066104ab366004614bba565b610ef8565b610371610fe7565b609754610371565b610371611017565b61040661108e565b6104d8611108565b6040805192835260208301919091520161037b565b6104066104fb366004614be7565b611176565b61040661050e366004614c24565b6112a8565b610371610521366004614bba565b611658565b61052e611820565b60405161037b9190614d74565b610543611a8e565b60405161037b9493929190614db9565b6103de611b1d565b610406611bb2565b600160ff1b610371565b6103de604051806040016040528060058152602001640ccb8c4b8d60da1b81525081565b61040661059f366004614e5d565b611c4b565b6104066105b2366004614be7565b611d29565b6104066105c5366004614bba565b611dba565b6104066105d8366004614ece565b611e42565b609954610371565b6103de60405180604001604052806005815260200164332e302e3160d81b81525081565b610371610617366004614be7565b60966020526000908152604090205481565b610371611ee0565b61037161063f366004614bba565b5490565b6103de60405180604001604052806007815260200166416c676562726160c81b81525081565b606754610371565b61037161067f366004614af8565b611f10565b610406610692366004614f8f565b6121f6565b61047f61229b565b6103de6040518060400160405280601a81526020017f416c676562726120436f6e76657274657220537472617465677900000000000081525081565b6103976122cb565b6103716106f1366004615050565b612398565b610397610704366004614be7565b612447565b61071c610717366004615080565b61246c565b604080516001600160a01b03909316835260208301919091520161037b565b6098546001600160a01b031661047f565b6066546001600160a01b031661047f565b609a54610371565b6103de60405180604001604052806005815260200164332e312e3360d81b81525081565b606954610371565b6104d861255e565b6104066107a7366004614bba565b6125d6565b6103976107ba366004614be7565b612633565b6104066107cd3660046150b4565b6126b8565b61047f612760565b610397612790565b60006107ed60975490565b6064546040516370a0823160e01b81526001600160a01b03909116906370a082319061081d903090600401614bd3565b602060405180830381865afa15801561083a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061085e9190615131565b6108689190615160565b905090565b60006001600160e01b03198216631e94dddf60e01b148061089e57506001600160e01b0319821663f73147b360e01b145b806108ad57506108ad826127de565b92915050565b60008060006108c0612803565b91509150606073__$e73f546b22cebb10cea6b8c699528ebeb1$__63911ec05360976040518060a001604052808e6001600160a01b03166001600160a01b031681526020018d6001600160a01b03166001600160a01b03168152602001610925612760565b6001600160a01b039081168252609854811660208084019190915260655490911660409283015281516080810183528e8152908101899052808201889052606081018b905290516001600160e01b031960e086901b168152610996939291908d908d90600190609690600401615196565b600060405180830381865af41580156109b3573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526109db919081019061527a565b90945090506109e981612855565b60006010558380156109fe57506109fe612884565b15610a09576001600f555b606480546040516368f9467b60e01b81526001600160a01b039091166004820152602481018490526097604482015273__$8f1afe7577f9ab973017c74eca19b86f3c$__916368f9467b910160006040518083038186803b158015610a6d57600080fd5b505af4158015610a81573d6000803e3d6000fd5b505050505050509695505050505050565b606554606454604051633e53813360e11b81526000926001600160a01b03908116921690839073__$7dde4232fad0cb3c495beb9e735b7d0c63$__90637ca7026690610ae490869086906004016152c0565b602060405180830381865af4158015610b01573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b259190615131565b90506000806000610b34612896565b92509250925073__$7dde4232fad0cb3c495beb9e735b7d0c63$__639ad00ec2868686868b6040518663ffffffff1660e01b8152600401610b799594939291906152da565b60006040518083038186803b158015610b9157600080fd5b505af4158015610ba5573d6000803e3d6000fd5b50929998505050505050505050565b73__$8f1afe7577f9ab973017c74eca19b86f3c$__63142395ef610bd6612760565b6040516001600160e01b031960e084901b1681526001600160a01b03918216600482015290851660248201526044810184905260640160006040518083038186803b158015610c2457600080fd5b505af4158015610c38573d6000803e3d6000fd5b5050506001600160a01b0390921660009081526096602052604090205550565b630a85bd0160e11b5b949350505050565b6000610c73612760565b60405163124fdbb760e21b815290915073__$7dde4232fad0cb3c495beb9e735b7d0c63$__9063493f6edc90610cad908490600401614bd3565b60006040518083038186803b158015610cc557600080fd5b505af4158015610cd9573d6000803e3d6000fd5b50505050600080610ce8612803565b604080518082019091526098546001600160a01b03168152919350915060009073__$e73f546b22cebb10cea6b8c699528ebeb1$__9063b6fda8139060979060019060208101610d378a6128b1565b6001600160a01b039081169091526065546040516001600160e01b031960e088901b168152610d77959493928a928c929116908e90609690600401615336565b600060405180830381865af4158015610d94573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610dbc9190810190615388565b9050610dc781612855565b505042601055505050565b73__$7dde4232fad0cb3c495beb9e735b7d0c63$__63493f6edc610df4612760565b6040518263ffffffff1660e01b8152600401610e109190614bd3565b60006040518083038186803b158015610e2857600080fd5b505af4158015610e3c573d6000803e3d6000fd5b505050600f9190915550565b600061086861063f60017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b6153bc565b600073__$7dde4232fad0cb3c495beb9e735b7d0c63$__63493f6edc610e9c612760565b6040518263ffffffff1660e01b8152600401610eb89190614bd3565b60006040518083038186803b158015610ed057600080fd5b505af4158015610ee4573d6000803e3d6000fd5b50505050610ef0612915565b509092915050565b73__$7dde4232fad0cb3c495beb9e735b7d0c63$__63493f6edc610f1a612760565b6040518263ffffffff1660e01b8152600401610f369190614bd3565b60006040518083038186803b158015610f4e57600080fd5b505af4158015610f62573d6000803e3d6000fd5b5073__$79fe6ec7a3db45dafbed12dca1c6dad764$__9250636bffb346915060069050836003811115610f9757610f976153cf565b6040518363ffffffff1660e01b8152600401610fb49291906153e5565b60006040518083038186803b158015610fcc57600080fd5b505af4158015610fe0573d6000803e3d6000fd5b5050505050565b600061086861063f60017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f16153bc565b604051630a3c2bb160e21b81526001600482015260009073__$e73f546b22cebb10cea6b8c699528ebeb1$__906328f0aec490602401602060405180830381865af415801561106a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108689190615131565b73__$7dde4232fad0cb3c495beb9e735b7d0c63$__63d19cc38a6110b0612760565b6040518263ffffffff1660e01b81526004016110cc9190614bd3565b60006040518083038186803b1580156110e457600080fd5b505af41580156110f8573d6000803e3d6000fd5b505050506111046129e6565b5050565b60655460408051808201909152600a81526914d08e8811195b9a595960b21b60208201526000918291906001600160a01b031633146111635760405162461bcd60e51b815260040161115a9190614ae5565b60405180910390fd5b5061116e6001612aa2565b915091509091565b3330146111c55760405162461bcd60e51b815260206004820152601b60248201527f496e637265617365207265766973696f6e20666f7262696464656e0000000000604482015260640161115a565b60006111f561063f60017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd6153bc565b611200906001615160565b90506112348161123160017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd6153bc565b55565b6112638261123160017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e46153bc565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c8910160405180910390a15050565b600054610100900460ff16158080156112c85750600054600160ff909116105b806112e25750303b1580156112e2575060005460ff166001145b6113455760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b606482015260840161115a565b6000805460ff191660011790558015611368576000805461ff0019166101001790555b6113738a8a8a612c9b565b73__$e73f546b22cebb10cea6b8c699528ebeb1$__632df3c9a9600160405180604001604052808e6001600160a01b03166001600160a01b031681526020018b6001600160a01b03166001600160a01b031681525089898e6001600160a01b03166338d52e0f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611408573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061142c9190615417565b8a896040518863ffffffff1660e01b81526004016114509796959493929190615434565b60006040518083038186803b15801561146857600080fd5b505af415801561147c573d6000803e3d6000fd5b50506040805163c3724a8960e01b81526001600482015286516001600160a01b03908116602483015260208801518116604483015291870151909116606482015260608601516084820152608086015160a482015273__$e73f546b22cebb10cea6b8c699528ebeb1$__925063c3724a89915060c40160006040518083038186803b15801561150a57600080fd5b505af415801561151e573d6000803e3d6000fd5b505060405163bd85be2960e01b81526001600482015273__$7dde4232fad0cb3c495beb9e735b7d0c63$__9250637fc1c15b915060649073__$e73f546b22cebb10cea6b8c699528ebeb1$__9063bd85be2990602401600060405180830381865af4158015611591573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526115b99190810190615485565b6040518363ffffffff1660e01b81526004016115d69291906154fb565b60006040518083038186803b1580156115ee57600080fd5b505af4158015611602573d6000803e3d6000fd5b50505050801561164c576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b50505050505050505050565b606554606454604051633e53813360e11b81526000926001600160a01b03908116921690839073__$7dde4232fad0cb3c495beb9e735b7d0c63$__90637ca70266906116aa90869086906004016152c0565b602060405180830381865af41580156116c7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116eb9190615131565b9050808511156117975760008061170a61170584896153bc565b612d3d565b604051631594b05b60e01b8152909850919350915073__$7dde4232fad0cb3c495beb9e735b7d0c63$__90631594b05b906117519087908790879087908c906004016152da565b602060405180830381865af415801561176e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117929190615131565b925050505b6040516333bbb20360e11b815260048101869052602481018290526001600160a01b0380841660448301528416606482015273__$7dde4232fad0cb3c495beb9e735b7d0c63$__9063677764069060840160006040518083038186803b15801561180057600080fd5b505af4158015611814573d6000803e3d6000fd5b50505050505050919050565b60025460408051600480825260a082019092526060926001600160a01b0316916020820160808036833750506003546040516370a0823160e01b81529294506001600160a01b0316916370a08231915061187e908490600401614bd3565b602060405180830381865afa15801561189b573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118bf9190615131565b826000815181106118d2576118d2615514565b6020908102919091010152600480546040516370a0823160e01b81526001600160a01b03909116916370a082319161190c91859101614bd3565b602060405180830381865afa158015611929573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194d9190615131565b8260018151811061196057611960615514565b60209081029190910101526033546040516370a0823160e01b81526001600160a01b03909116906370a082319061199b908490600401614bd3565b602060405180830381865afa1580156119b8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119dc9190615131565b826002815181106119ef576119ef615514565b60209081029190910101526034546040516370a0823160e01b81526001600160a01b03909116906370a0823190611a2a908490600401614bd3565b602060405180830381865afa158015611a47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a6b9190615131565b82600381518110611a7e57611a7e615514565b6020026020010181815250505090565b604051636e81b62960e01b81526001600482015260609081908190819073__$b1ba452cecccdd06eb05ace2d0a762c7e1$__90636e81b62990602401600060405180830381865af4158015611ae7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611b0f91908101906155f2565b935093509350935090919293565b606060646006018054611b2f906156f0565b80601f0160208091040260200160405190810160405280929190818152602001828054611b5b906156f0565b8015611ba85780601f10611b7d57610100808354040283529160200191611ba8565b820191906000526020600020905b815481529060010190602001808311611b8b57829003601f168201915b5050505050905090565b611bba612d6e565b73__$7dde4232fad0cb3c495beb9e735b7d0c63$__63bd020682611bdc612760565b6064805460655460405160e086901b6001600160e01b03191681526001600160a01b03948516600482015291841660248301529290921660448301520160006040518083038186803b158015611c3157600080fd5b505af4158015611c45573d6000803e3d6000fd5b50505050565b73__$7dde4232fad0cb3c495beb9e735b7d0c63$__63493f6edc611c6d612760565b6040518263ffffffff1660e01b8152600401611c899190614bd3565b60006040518083038186803b158015611ca157600080fd5b505af4158015611cb5573d6000803e3d6000fd5b5050604051637fc1c15b60e01b815273__$7dde4232fad0cb3c495beb9e735b7d0c63$__9250637fc1c15b9150611cf5906064908690869060040161572a565b60006040518083038186803b158015611d0d57600080fd5b505af4158015611d21573d6000803e3d6000fd5b505050505050565b73__$7dde4232fad0cb3c495beb9e735b7d0c63$__63493f6edc611d4b612760565b6040518263ffffffff1660e01b8152600401611d679190614bd3565b60006040518083038186803b158015611d7f57600080fd5b505af4158015611d93573d6000803e3d6000fd5b5050600280546001600160a01b0319166001600160a01b0394909416939093179092555050565b73__$8f1afe7577f9ab973017c74eca19b86f3c$__63d2c3cf25611ddc612760565b6040516001600160e01b031960e084901b1681526001600160a01b0390911660048201526024810184905260440160006040518083038186803b158015611e2257600080fd5b505af4158015611e36573d6000803e3d6000fd5b50505060999190915550565b73__$7dde4232fad0cb3c495beb9e735b7d0c63$__63ed6b63c16064858585611e69612760565b6040516001600160e01b031960e088901b168152600481019590955260248501939093526001600160a01b039182166044850152606484015216608482015260a40160006040518083038186803b158015611ec357600080fd5b505af4158015611ed7573d6000803e3d6000fd5b50505050505050565b600061086861063f60017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd6153bc565b6000611f1a614886565b611f2684826000612db9565b805160408051808201909152600a81526914d08e8811195b9a595960b21b6020820152906001600160a01b03163314611f725760405162461bcd60e51b815260040161115a9190614ae5565b5060408051808201909152601081526f54532d3234207a65726f2076616c756560801b602082015283611fb85760405162461bcd60e51b815260040161115a9190614ae5565b5060001981606001511415604051806040016040528060118152602001701514cb4c4d081ddc9bdb99c8185cdcd95d607a1b8152509061200b5760405162461bcd60e51b815260040161115a9190614ae5565b506000806120196001612e33565b608085015160405163513cfdb360e11b81526001600160a01b038a16600482015260248101919091526044810183905260648181018390526084820152919350915073__$8f1afe7577f9ab973017c74eca19b86f3c$__9063a279fb669060a401602060405180830381865af4158015612097573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120bb9190615131565b60808401526000620186a06120d26103e882615160565b6120dc9088615760565b6120e69190615777565b90508084608001511061211257835161210a906001600160a01b0389169088612efd565b8594506121e3565b8260000361214d576121296103e8620186a0615160565b620186a0856080015161213c9190615760565b6121469190615777565b94506121e3565b6000620186a06121606103e86002615760565b61216d90620186a0615160565b6121779089615760565b6121819190615777565b905061219c85608001518261219691906153bc565b86612f4f565b5060006121a8896131b4565b90508281116121dc576121c06103e8620186a0615160565b6121cd620186a083615760565b6121d79190615777565b6121de565b875b965050505b6121eb613224565b505050505092915050565b60985460408051808201909152600a81526914d08e8811195b9a595960b21b6020820152906001600160a01b031633146122435760405162461bcd60e51b815260040161115a9190614ae5565b5080518251146040518060400160405280600d81526020016c54532d3139206c656e6774687360981b8152509061228d5760405162461bcd60e51b815260040161115a9190614ae5565b50612296613224565b505050565b600061086861063f60017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e46153bc565b60006122d5612790565b1580156122e757506122e5612884565b155b8015610868575060985473__$e73f546b22cebb10cea6b8c699528ebeb1$__9063d1585fc4906001906001600160a01b0316612321612760565b6040516001600160e01b031960e086901b16815260048101939093526001600160a01b0391821660248401521660448201526064015b602060405180830381865af4158015612374573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108689190615799565b6065546064546040516001625acc3160e01b03198152600092839273__$7dde4232fad0cb3c495beb9e735b7d0c63$__9263ffa533cf926123ea926001600160a01b03918216929116906004016152c0565b602060405180830381865af4158015612407573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061242b9190615131565b905080156124405761243d818461323a565b91505b5092915050565b6000612451612760565b6001600160a01b0316826001600160a01b0316149050919050565b6005546000908190630100000090046001600160801b031681811561249957612494826132e6565b6124b7565b60408051600280825260608201835290916020830190803683375050505b905073__$b1ba452cecccdd06eb05ace2d0a762c7e1$__6350d2e0ba600187846124df612760565b6098546040516001600160e01b031960e088901b16815261251395949392916001600160a01b0316906096906004016157b6565b6040805180830381865af415801561252f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125539190615807565b935093505050915091565b604051632cc58ef960e01b815260016004820152600090819073__$e73f546b22cebb10cea6b8c699528ebeb1$__90632cc58ef9906024016040805180830381865af41580156125b2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061116e9190615835565b73__$7dde4232fad0cb3c495beb9e735b7d0c63$__636d51f04360646125fa612760565b6040516001600160e01b031960e085901b16815260048101929092526001600160a01b0316602482015260448101849052606401610fb4565b6000816001600160a01b0316612647612760565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015612684573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126a89190615417565b6001600160a01b03161492915050565b73__$7dde4232fad0cb3c495beb9e735b7d0c63$__63493f6edc6126da612760565b6040518263ffffffff1660e01b81526004016126f69190614bd3565b60006040518083038186803b15801561270e57600080fd5b505af4158015612722573d6000803e3d6000fd5b5050604051630593c4c960e01b815273__$79fe6ec7a3db45dafbed12dca1c6dad764$__9250630593c4c99150610fb4906006908590600401615859565b600061086861063f60017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c36186153bc565b609854604051633934e59d60e11b8152600160048201526001600160a01b03909116602482015260009073__$e73f546b22cebb10cea6b8c699528ebeb1$__90637269cb3a90604401612357565b60006001600160e01b0319821663c19fa56160e01b14806108ad57506108ad82613370565b6000806128106001612e33565b925082905061281d6107e2565b61282791906153bc565b600554909150630100000090046001600160801b031680156128505761284e8160006133a5565b505b509091565b8051600214801561286b5750612869612884565b155b1561287c576128798161343e565b50505b611104613224565b6006546000906108689060ff166134cb565b60008060006128a6600019612d3d565b925092509250909192565b6000816001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156128f1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ad9190615417565b606454600090606090819083908190612936906001600160a01b03166134e8565b9150915073__$8f1afe7577f9ab973017c74eca19b86f3c$__637325f33f8361295e85613554565b6098546040516001600160e01b031960e086901b16815261299493929187916001600160a01b03909116906001906004016158a6565b600060405180830381865af41580156129b1573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526129d991908101906158f4565b9450945094505050909192565b60608060008060006129f66135d2565b609854929550909350915073__$8f1afe7577f9ab973017c74eca19b86f3c$__9063e99de4da906001600160a01b0316612a2e613651565b8686866040518663ffffffff1660e01b8152600401612a51959493929190615960565b600060405180830381865af4158015612a6e573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612a9691908101906159ca565b90969095509350505050565b600080600080612ab26001612e33565b91509150612abf856136e5565b612c19576000806000806000612ad3613798565b945094509450945094506000612ae7612915565b505090506000612b398c8015612afc57508215155b8015612b235750609954620186a090612b16908590615760565b612b209190615777565b86115b612b2e576000612b30565b855b8984600161387b565b9150612b7d9050612b4a8684615160565b6064548390612b61906001600160a01b03166131b4565b609754612b6e9190615160565b612b789190615160565b613ac8565b909b509950604080518a8152602081018a905290810188905260608101879052608081018c905260a081018b905260c0810185905260e081018490527ff87a9dead982c86370b885093f79ded2c9a614d95d83c0c20f68e13e3b9b7d3f906101000160405180910390a1612c03612bf4888d615160565b612bfe8587615160565b613af8565b9a50612c0f868b615160565b9950505050505050505b6098546064546040516323c1ae5960e11b815273__$8f1afe7577f9ab973017c74eca19b86f3c$__926347835cb292612c64926001600160a01b0392831692909116906004016152c0565b60006040518083038186803b158015612c7c57600080fd5b505af4158015612c90573d6000803e3d6000fd5b505050505050915091565b600054610100900460ff16612cc25760405162461bcd60e51b815260040161115a90615a23565b612ccc8383613b12565b609880546001600160a01b0319166001600160a01b038316179055612cf56064620186a0615777565b6099557fe4166dfcf23bbd3e3f764a99dc8fa740554c03c82d6019b81cf265f396f6f2fe612d276064620186a0615777565b60405190815260200160405180910390a1505050565b6000806000806000612d4f6001612e33565b91509150612d5e868284613bbb565b5091989097509095509350505050565b6000612d78613dc8565b90507f768a28cb3459382a3d2173feb2dad0235f8de680b109872da581a3aa269fe5f481604051612da99190614d74565b60405180910390a1611104613224565b612dc1613651565b604083018190526001600160a01b038085166020850152609854168352612de89084613e4f565b6060830152612df6836131b4565b608083015280612e20576040820151606454612e1b91906001600160a01b0316613e4f565b612e26565b81606001515b60a0909201919091525050565b6000808215612ef0576064546000908190612e56906001600160a01b03166134e8565b9150915073__$8f1afe7577f9ab973017c74eca19b86f3c$__633643611860976064612e8186613554565b86866040518663ffffffff1660e01b8152600401612ea3959493929190615a6e565b6040805180830381865af4158015612ebf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ee39190615835565b9094509250612ef8915050565b505060975460005b915091565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663a9059cbb60e01b179052612296908490613ead565b600080612f6c6005546001600160801b0363010000009091041690565b90506000612f79826132e6565b9050600073__$8f1afe7577f9ab973017c74eca19b86f3c$__630252e2c78787604001518860600151896000015187898c60a001516040518863ffffffff1660e01b8152600401612fd09796959493929190615ab2565b602060405180830381865af4158015612fed573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130119190615131565b905080156130835760006130268260006133a5565b600554909150630100000090046001600160801b031661304690856153bc565b91507faebc771af58936b05e89b0be7d3f9761480181abcd4a649fbdd01753fda169708282604051613079929190615b0a565b60405180910390a1505b600073__$e930d50fb5f4f1298547dbcb2bb0591990$__63c432aee18760400151886060015189600001516130be6130b9612760565b6128b1565b6000198d146130dc578c8c608001516130d79190615160565b6130de565b8c5b60966040518763ffffffff1660e01b815260040161310196959493929190615b23565b602060405180830381865af415801561311e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131429190615131565b905085608001518110156040518060400160405280601681526020017554532d32302062616c616e636520646563726561736560501b815250906131995760405162461bcd60e51b815260040161115a9190614ae5565b5060808601516131a990826153bc565b979650505050505050565b6040516370a0823160e01b81526000906001600160a01b038316906370a08231906131e3903090600401614bd3565b602060405180830381865afa158015613200573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ad9190615131565b600061322e612915565b50506097819055919050565b60065460009061324c9060ff166134cb565b156132d557604080516002808252606082018352600092602083019080368337019050509050838160008151811061328657613286615514565b6020026020010181815250507f59400c8c523464b521238ea8f50e923f2bc64663557e6afec92a97f7efe92d0581826040516132c3929190615b66565b60405180910390a160009150506108ad565b6132df8383613f7f565b90506108ad565b60405163a7aced0960e01b8152600160048201526001600160801b038216602482015260609073__$e73f546b22cebb10cea6b8c699528ebeb1$__9063a7aced0990604401600060405180830381865af4158015613348573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526108ad9190810190615388565b60006001600160e01b0319821663b7b79fa960e01b14806108ad57506301ffc9a760e01b6001600160e01b03198316146108ad565b604051635b1e6c8160e11b8152600160048201526001600160801b0383166024820152811515604482015260609073__$e73f546b22cebb10cea6b8c699528ebeb1$__9063b63cd90290606401600060405180830381865af415801561340f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526134379190810190615388565b9392505050565b6060600073__$e73f546b22cebb10cea6b8c699528ebeb1$__63b67626216001856040518363ffffffff1660e01b815260040161347c929190615b0a565b600060405180830381865af4158015613499573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526134c19190810190615b8b565b9094909350915050565b600060018260038111156134e1576134e16153cf565b1192915050565b606060006134f4613651565b91506135008284613e4f565b90506000198114156040518060400160405280600f81526020016e53423a2057726f6e672076616c756560881b8152509061354e5760405162461bcd60e51b815260040161115a9190614ae5565b50915091565b606060006135726005546001600160801b0363010000009091041690565b9050801561358857613583816132e6565b613437565b82516001600160401b038111156135a1576135a1614910565b6040519080825280602002602001820160405280156135ca578160200160208202803683370190505b509392505050565b60405163f6e2611760e01b8152600160048201526060908190819073__$e73f546b22cebb10cea6b8c699528ebeb1$__9063f6e2611790602401600060405180830381865af4158015613629573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526128a69190810190615bd1565b6040805160028082526060808301845292602083019080368337505060035482519293506001600160a01b03169183915060009061369157613691615514565b6001600160a01b0392831660209182029290920101526004548251911690829060019081106136c2576136c2615514565b60200260200101906001600160a01b031690816001600160a01b03168152505090565b60006136ef612790565b156040518060400160405280601381526020017241532d31204e65656420726562616c616e636560681b8152509061373a5760405162461bcd60e51b815260040161115a9190614ae5565b50613743612884565b156040518060400160405280601481526020017341532d313420467573652069732061637469766560601b8152509061378f5760405162461bcd60e51b815260040161115a9190614ae5565b50600092915050565b60008060008060008060006137ab6129e6565b600354919350915073__$e73f546b22cebb10cea6b8c699528ebeb1$__906334d2ec3d906001600160a01b03166137e0612760565b85856040518563ffffffff1660e01b81526004016138019493929190615c1f565b602060405180830381865af415801561381e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138429190615131565b965061384e8282613fa8565b60645491955093508790879061386c906001600160a01b03166131b4565b96509650965050509091929394565b60645460009081906001600160a01b03168186881161389b5760006138a5565b6138a587896153bc565b90506000620186a0876097600201546138be9190615760565b6138c89190615777565b8211905060006138d7846131b4565b6001600160a01b0385166000908152609660205260409020549091506138fc90614053565b8911156139eb57818061390f5750888110155b156139d75760655473__$8f1afe7577f9ab973017c74eca19b86f3c$__9063890ffb849086908c906001600160a01b031661394a868e615160565b6040516001600160e01b031960e087901b1681526001600160a01b03948516600482015260248101939093529216604482015260648101919091526084810184905260a4016040805180830381865af41580156139ab573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139cf9190615835565b5094506139eb565b6139e360008a8a613bbb565b909850965050505b8115613aaf576000806139fd866134e8565b6098549193509150600090613a1d906001600160a01b031687858561406b565b9050613a2881614320565b613a75576000613a378261343e565b5090507f59400c8c523464b521238ea8f50e923f2bc64663557e6afec92a97f7efe92d058282604051613a6b929190615b66565b60405180910390a1505b6000613a7f613224565b9050613aa2613a8e868e615160565b8a613a988b6131b4565b612b6e9085615160565b9a50613abb945050505050565b8615613abb5760978890555b5050505094509492505050565b60008083831115613ae457613add84846153bc565b9150613af1565b613aee83856153bc565b90505b9250929050565b6000818311613b08576000613437565b61343782846153bc565b600054610100900460ff16613b395760405162461bcd60e51b815260040161115a90615a23565b613b63817fd2de0374d4479f33e63ae5ed6ca772a10463dd883a90c612050b51fab619640061436c565b613b6c826143c2565b604051631797527d60e01b81526064600482018190526001600160a01b0380851660248401528316604483015273__$7dde4232fad0cb3c495beb9e735b7d0c63$__91631797527d9101611cf5565b60008060008060006000198814613bff57620186a0613bdc6103e882615160565b613be6898b615160565b613bf09190615760565b613bfa9190615777565b613c01565b875b9050613c0c816145e7565b8015801590613c1a57508515155b15613dbe57613c27614886565b606454613c3f906001600160a01b0316826001612db9565b80516020820151604051637a55caf360e01b815273__$8f1afe7577f9ab973017c74eca19b86f3c$__92637a55caf392613c7b926004016152c0565b602060405180830381865af4158015613c98573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613cbc9190615131565b9450670de0b6b3a764000085613cdb613cd58585612f4f565b8b613af8565b613ce59190615760565b613cef9190615777565b6065546020830151608084015192985073__$8f1afe7577f9ab973017c74eca19b86f3c$__92632ce30333926001600160a01b031691908b908d613d31613224565b6040516001600160e01b031960e089901b1681526001600160a01b03968716600482015295909416602486015260448501929092526064840152608483015260a482015260c4016040805180830381865af4158015613d94573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613db89190615835565b94509250505b5093509350935093565b60606000613de66005546001600160801b0363010000009091041690565b90508015613dfe57613df98160016133a5565b613e49565b613e06613651565b516001600160401b03811115613e1e57613e1e614910565b604051908082528060200260200182016040528015613e47578160200160208202803683370190505b505b91505090565b8151600090815b81811015613ea157836001600160a01b0316858281518110613e7a57613e7a615514565b60200260200101516001600160a01b031603613e995791506108ad9050565b600101613e56565b50600019949350505050565b6000613f02826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b031661463a9092919063ffffffff16565b8051909150156122965780806020019051810190613f209190615799565b6122965760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b606482015260840161115a565b6000806000613f8d84612e33565b91509150613f9e858284600061387b565b5095945050505050565b6000808351600014613af15773__$e930d50fb5f4f1298547dbcb2bb0591990$__635dcb613060646097613fda613651565b613fe2612760565b60968a8a6040518863ffffffff1660e01b81526004016140089796959493929190615c5d565b6040805180830381865af4158015614024573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906140489190615835565b909590945092505050565b6000811561406157816108ad565b620186a092915050565b6060614075612790565b156040518060400160405280601381526020017241532d31204e65656420726562616c616e636560681b815250906140c05760405162461bcd60e51b815260040161115a9190614ae5565b50600154600480546040516221c5bf60e11b81526001600160a01b0390931691830191909152600160c81b8104600290810b6024840152600160e01b8204900b6044830152600160a81b900460ff1615156064820152600090819073__$e73f546b22cebb10cea6b8c699528ebeb1$__9062438b7e906084016040805180830381865af4158015614155573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141799190615835565b6003546004549294509092506001600160a01b039081169173__$b1ba452cecccdd06eb05ace2d0a762c7e1$__91631c2040d5918b918b918691166141be888a615160565b6141d08a670de0b6b3a7640000615760565b6141da9190615777565b60405160e087901b6001600160e01b03191681526001600160a01b0395861660048201526024810194909452918416604484015290921660648201526084810191909152609660a482015260c401600060405180830381865af4158015614245573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261426d9190810190615388565b9350806001600160a01b03168660008151811061428c5761428c615514565b60200260200101516001600160a01b03161461431557836001815181106142b5576142b5615514565b6020026020010151846000815181106142d0576142d0615514565b6020026020010151856000815181106142eb576142eb615514565b602002602001018660018151811061430557614305615514565b6020908102919091010191909152525b505050949350505050565b8051600090815b818110156143625783818151811061434157614341615514565b602002602001015160000361435a575060019392505050565b600101614327565b5060009392505050565b6143768282614649565b6111045760405162461bcd60e51b815260206004820152601a60248201527f496e74657266616365206973206e6f7420737570706f72746564000000000000604482015260640161115a565b600054610100900460ff166143e95760405162461bcd60e51b815260040161115a90615a23565b6001600160a01b0381166144315760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b604482015260640161115a565b61445b817f4c2403fdcb3cff9b705d96bf0705858e3390412670a62c8bcba611ca7e20ab8661436c565b60006001600160a01b0316816001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa1580156144a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906144c89190615417565b6001600160a01b0316036145105760405162461bcd60e51b815260206004820152600f60248201526e5a65726f20676f7665726e616e636560881b604482015260640161115a565b61453f8161123160017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c36186153bc565b61456e4261123160017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b6153bc565b61459d4361123160017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f16153bc565b604080516001600160a01b0383168152426020820152438183015290517f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe2367134269181900360600190a150565b6145ef612790565b156040518060400160405280601381526020017241532d31204e65656420726562616c616e636560681b815250906111045760405162461bcd60e51b815260040161115a9190614ae5565b6060610c61848460008561471d565b60006001600160a01b0383166146905760405162461bcd60e51b815260206004820152600c60248201526b5a65726f206164647265737360a01b604482015260640161115a565b823b60008190036146a55760009150506108ad565b6040516301ffc9a760e01b81526001600160e01b0319841660048201526001600160a01b038516906301ffc9a790602401602060405180830381865afa92505050801561470f575060408051601f3d908101601f1916820190925261470c91810190615799565b60015b156143625791506108ad9050565b60608247101561477e5760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b606482015260840161115a565b600080866001600160a01b0316858760405161479a9190615cc6565b60006040518083038185875af1925050503d80600081146147d7576040519150601f19603f3d011682016040523d82523d6000602084013e6147dc565b606091505b50915091506131a98783838760608315614857578251600003614850576001600160a01b0385163b6148505760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161115a565b5081610c61565b610c61838381511561486c5781518083602001fd5b8060405162461bcd60e51b815260040161115a9190614ae5565b6040518060c0016040528060006001600160a01b0316815260200160006001600160a01b03168152602001606081526020016000815260200160008152602001600081525090565b6000602082840312156148e057600080fd5b81356001600160e01b03198116811461343757600080fd5b6001600160a01b038116811461490d57600080fd5b50565b634e487b7160e01b600052604160045260246000fd5b60405160a081016001600160401b038111828210171561494857614948614910565b60405290565b604051601f8201601f191681016001600160401b038111828210171561497657614976614910565b604052919050565b60006001600160401b0382111561499757614997614910565b50601f01601f191660200190565b600082601f8301126149b657600080fd5b81356149c96149c48261497e565b61494e565b8181528460208386010111156149de57600080fd5b816020850160208301376000918101602001919091529392505050565b60008060008060008060c08789031215614a1457600080fd5b8635614a1f816148f8565b95506020870135614a2f816148f8565b94506040870135935060608701356001600160401b0380821115614a5257600080fd5b614a5e8a838b016149a5565b94506080890135915080821115614a7457600080fd5b50614a8189828a016149a5565b92505060a087013590509295509295509295565b60005b83811015614ab0578181015183820152602001614a98565b50506000910152565b60008151808452614ad1816020860160208601614a95565b601f01601f19169290920160200192915050565b6020815260006134376020830184614ab9565b60008060408385031215614b0b57600080fd5b8235614b16816148f8565b946020939093013593505050565b60008060008060808587031215614b3a57600080fd5b8435614b45816148f8565b93506020850135614b55816148f8565b92506040850135915060608501356001600160401b03811115614b7757600080fd5b614b83878288016149a5565b91505092959194509250565b801515811461490d57600080fd5b600060208284031215614baf57600080fd5b813561343781614b8f565b600060208284031215614bcc57600080fd5b5035919050565b6001600160a01b0391909116815260200190565b600060208284031215614bf957600080fd5b8135613437816148f8565b8060020b811461490d57600080fd5b80608081018310156108ad57600080fd5b6000806000806000806000806000898b03610200811215614c4457600080fd5b8a35614c4f816148f8565b995060208b0135614c5f816148f8565b985060408b0135614c6f816148f8565b975060608b0135614c7f816148f8565b965060808b0135614c8f81614c04565b955060a08b0135614c9f81614c04565b945060c08b0135614caf81614b8f565b935060a060df1982011215614cc357600080fd5b50614ccc614926565b60e08b0135614cda816148f8565b81526101008b0135614ceb816148f8565b60208201526101208b0135614cff816148f8565b60408201526101408b013560608201526101608b013560808201529150614d2a8b6101808c01614c13565b90509295985092959850929598565b600081518084526020808501945080840160005b83811015614d6957815187529582019590820190600101614d4d565b509495945050505050565b6020815260006134376020830184614d39565b600081518084526020808501945080840160005b83811015614d69578151151587529582019590820190600101614d9b565b6080808252855190820181905260009060209060a0840190828901845b82811015614dfb5781516001600160a01b031684529284019290840190600101614dd6565b5050508381038285015286518082528783019183019060005b81811015614e3357835160020b83529284019291840191600101614e14565b50508481036040860152614e478188614d39565b9250505082810360608401526131a98185614d87565b60008060208385031215614e7057600080fd5b82356001600160401b0380821115614e8757600080fd5b818501915085601f830112614e9b57600080fd5b813581811115614eaa57600080fd5b866020828501011115614ebc57600080fd5b60209290920196919550909350505050565b600080600060608486031215614ee357600080fd5b833592506020840135614ef5816148f8565b929592945050506040919091013590565b60006001600160401b03821115614f1f57614f1f614910565b5060051b60200190565b600082601f830112614f3a57600080fd5b81356020614f4a6149c483614f06565b82815260059290921b84018101918181019086841115614f6957600080fd5b8286015b84811015614f845780358352918301918301614f6d565b509695505050505050565b60008060408385031215614fa257600080fd5b82356001600160401b0380821115614fb957600080fd5b818501915085601f830112614fcd57600080fd5b81356020614fdd6149c483614f06565b82815260059290921b84018101918181019089841115614ffc57600080fd5b948201945b83861015615023578535615014816148f8565b82529482019490820190615001565b9650508601359250508082111561503957600080fd5b5061504685828601614f29565b9150509250929050565b6000806040838503121561506357600080fd5b82359150602083013561507581614b8f565b809150509250929050565b60006020828403121561509257600080fd5b81356001600160401b038111156150a857600080fd5b61243d848285016149a5565b6000608082840312156150c657600080fd5b82601f8301126150d557600080fd5b604051608081018181106001600160401b03821117156150f7576150f7614910565b60405280608084018581111561510c57600080fd5b845b8181101561512657803583526020928301920161510e565b509195945050505050565b60006020828403121561514357600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b808201808211156108ad576108ad61514a565b8060005b6004811015611c45578151845260209384019390910190600101615177565b60006101c089835260208084018a60005b60058110156151cd5781516001600160a01b0316835291830191908301906001016151a7565b505050506151de60c0840189615173565b806101408401526151f181840188614ab9565b90508281036101608401526152068187614ab9565b61018084019590955250506101a0015295945050505050565b600082601f83011261523057600080fd5b815160206152406149c483614f06565b82815260059290921b8401810191818101908684111561525f57600080fd5b8286015b84811015614f845780518352918301918301615263565b6000806040838503121561528d57600080fd5b825161529881614b8f565b60208401519092506001600160401b038111156152b457600080fd5b6150468582860161521f565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039586168152602081019490945260408401929092526060830152909116608082015260a00190565b8060005b6002811015611c455781516001600160a01b031684526020938401939091019060010161530e565b888152602081018890526101208101615352604083018961530a565b608082019690965260a08101949094526001600160a01b039290921660c0840152151560e0830152610100909101529392505050565b60006020828403121561539a57600080fd5b81516001600160401b038111156153b057600080fd5b61243d8482850161521f565b818103818111156108ad576108ad61514a565b634e487b7160e01b600052602160045260246000fd5b828152604081016004831061540a57634e487b7160e01b600052602160045260246000fd5b8260208301529392505050565b60006020828403121561542957600080fd5b8151613437816148f8565b8781526101608101615449602083018961530a565b8660020b60608301528560020b608083015260018060a01b03851660a083015283151560c083015260808360e084013798975050505050505050565b60006020828403121561549757600080fd5b81516001600160401b038111156154ad57600080fd5b8201601f810184136154be57600080fd5b80516154cc6149c48261497e565b8181528560208385010111156154e157600080fd5b6154f2826020830160208601614a95565b95945050505050565b828152604060208201526000610c616040830184614ab9565b634e487b7160e01b600052603260045260246000fd5b600082601f83011261553b57600080fd5b8151602061554b6149c483614f06565b82815260059290921b8401810191818101908684111561556a57600080fd5b8286015b84811015614f84578051615581816148f8565b835291830191830161556e565b600082601f83011261559f57600080fd5b815160206155af6149c483614f06565b82815260059290921b840181019181810190868411156155ce57600080fd5b8286015b84811015614f845780516155e581614b8f565b83529183019183016155d2565b6000806000806080858703121561560857600080fd5b84516001600160401b038082111561561f57600080fd5b61562b8883890161552a565b955060209150818701518181111561564257600080fd5b8701601f8101891361565357600080fd5b80516156616149c482614f06565b81815260059190911b8201840190848101908b83111561568057600080fd5b928501925b828410156156a757835161569881614c04565b82529285019290850190615685565b60408b01519098509450505050808211156156c157600080fd5b6156cd8883890161521f565b935060608701519150808211156156e357600080fd5b50614b838782880161558e565b600181811c9082168061570457607f821691505b60208210810361572457634e487b7160e01b600052602260045260246000fd5b50919050565b83815260406020820152816040820152818360608301376000818301606090810191909152601f909201601f1916010192915050565b80820281158282048414176108ad576108ad61514a565b60008261579457634e487b7160e01b600052601260045260246000fd5b500490565b6000602082840312156157ab57600080fd5b815161343781614b8f565b86815260c0602082015260006157cf60c0830188614ab9565b82810360408401526157e18188614d39565b6001600160a01b0396871660608501529490951660808301525060a00152949350505050565b6000806040838503121561581a57600080fd5b8251615825816148f8565b6020939093015192949293505050565b6000806040838503121561584857600080fd5b505080516020909101519092909150565b82815260a081016134376020830184615173565b600081518084526020808501945080840160005b83811015614d695781516001600160a01b031687529582019590820190600101615881565b60a0815260006158b960a083018861586d565b82810360208401526158cb8188614d39565b604084019690965250506001600160a01b03929092166060830152151560809091015292915050565b60008060006060848603121561590957600080fd5b8351925060208401516001600160401b038082111561592757600080fd5b6159338783880161521f565b9350604086015191508082111561594957600080fd5b506159568682870161521f565b9150509250925092565b6001600160a01b038616815260a0602082018190526000906159849083018761586d565b8281036040840152615996818761586d565b905082810360608401526159aa8186614d39565b905082810360808401526159be8185614d39565b98975050505050505050565b600080604083850312156159dd57600080fd5b82516001600160401b03808211156159f457600080fd5b615a008683870161552a565b93506020850151915080821115615a1657600080fd5b506150468582860161521f565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b85815284602082015260a060408201526000615a8d60a0830186614d39565b8281036060840152615a9f818661586d565b9150508260808301529695505050505050565b87815260e060208201526000615acb60e083018961586d565b604083018890526001600160a01b03871660608401528281036080840152615af38187614d39565b60a0840195909552505060c0015295945050505050565b828152604060208201526000610c616040830184614d39565b60c081526000615b3660c083018961586d565b6020830197909752506001600160a01b039485166040820152929093166060830152608082015260a00152919050565b604081526000615b796040830185614d39565b82810360208401526154f28185614d39565b60008060408385031215615b9e57600080fd5b82516001600160401b03811115615bb457600080fd5b615bc08582860161521f565b925050602083015190509250929050565b600080600060608486031215615be657600080fd5b83516001600160401b0380821115615bfd57600080fd5b615c098783880161552a565b9450602086015191508082111561592757600080fd5b6001600160a01b03858116825284166020820152608060408201819052600090615c4b9083018561586d565b82810360608401526131a98185614d39565b87815286602082015260e060408201526000615c7c60e083018861586d565b6001600160a01b03871660608401526080830186905282810360a0840152615ca4818661586d565b905082810360c0840152615cb88185614d39565b9a9950505050505050505050565b60008251615cd8818460208701614a95565b919091019291505056fea26469706673582212206c1b23f828f1b255caddccc473838130664e9c3ea2789cb785f31d8e4e1b367864736f6c63430008110033",
  "libraries": {
    "ConverterStrategyBaseLib": "0xcD14081DDD966ADbCEc1930Bbe541765EBA2D686",
    "ConverterStrategyBaseLib2": "0xc1Ed5dD095C703421F623F416b88bbf57a1E1012",
    "StrategyLib2": "0x06c875daA1Dc2E27dd7381EB3b6be4F99553a609",
    "AlgebraConverterStrategyLogicLib": "0xeD92d01D784c2458b19441eDf4135c66915F93ee",
    "PairBasedStrategyLib": "0x626aB57b826869B8AE32D32487E0AB6405625bb3",
    "PairBasedStrategyLogicLib": "0xE8dfB7074F4E14b7eDD1E08C03Fa6079c9E091b5"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "claim()": {
        "details": "Manual claim rewards."
      },
      "created()": {
        "returns": {
          "_0": "Creation timestamp"
        }
      },
      "createdBlock()": {
        "returns": {
          "_0": "Creation block number"
        }
      },
      "doHardWork()": {
        "returns": {
          "earned": "Earned amount in terms of {asset}",
          "lost": "Lost amount in terms of {asset}"
        }
      },
      "emergencyExit()": {
        "details": "In case of any issue operator can withdraw all from pool."
      },
      "getDefaultState()": {
        "returns": {
          "addr": "[tokenA, tokenB, pool, profitHolder]",
          "boolValues": "[isStablePool, depositorSwapTokens]",
          "nums": "[totalLiquidity, fuse-status-tokenA, fuse-status-tokenB, withdrawDone, 4 thresholds of token A, 4 thresholds of token B]",
          "tickData": "[tickSpacing, lowerTick, upperTick, rebalanceTickRange]"
        }
      },
      "getFees()": {
        "returns": {
          "fee0": "and fee1."
        }
      },
      "getPropNotUnderlying18()": {
        "returns": {
          "_0": "Proportion of the not-underlying [0...1e18]"
        }
      },
      "getSlot(uint256)": {
        "details": "Gets a slot as bytes32"
      },
      "getSpecificState()": {
        "returns": {
          "nums": "Balances of [tokenA, tokenB, rewardToken, bonusRewardToken] for profit holder"
        }
      },
      "increaseRevision(address)": {
        "details": "Revision should be increased on each contract upgrade"
      },
      "init(address,address,address,address,int24,int24,bool,(address,address,address,uint256,uint256),uint256[4])": {
        "params": {
          "controller_": "The address of the controller.",
          "converter_": "The address of the converter.",
          "pool_": "The address of the pool.",
          "rebalanceTickRange_": "The tick range for rebalancing.",
          "splitter_": "The address of the splitter.",
          "tickRange_": "The tick range for the liquidity position."
        }
      },
      "investAll(uint256,bool)": {
        "params": {
          "updateTotalAssetsBeforeInvest_": "Recalculate total assets amount before depositing.                                       It can be false if we know exactly, that the amount is already actual."
        },
        "returns": {
          "strategyLoss": "Loss should be covered from Insurance"
        }
      },
      "isController(address)": {
        "details": "Return true if given address is controller"
      },
      "isReadyToHardWork()": {
        "returns": {
          "_0": "A boolean indicating if the strategy is ready for hard work."
        }
      },
      "needRebalance()": {
        "returns": {
          "_0": "A boolean indicating if the strategy needs rebalancing."
        }
      },
      "onTransferAmounts(address[],uint256[])": {
        "params": {
          "amounts_": "Amount of {asset_} that has been sent to the user's balance",
          "assets_": "Any asset sent to the balance, i.e. inside repayTheBorrow"
        }
      },
      "performanceFee()": {
        "details": "use FEE_DENOMINATOR"
      },
      "previousImplementation()": {
        "details": "Previous logic implementation"
      },
      "rebalanceNoSwaps(bool)": {
        "params": {
          "checkNeedRebalance": "Revert if rebalance is not needed. Pass false to deposit after withdrawByAgg-iterations"
        }
      },
      "requirePayAmountBack(address,uint256)": {
        "params": {
          "amount_": "Required amount of {theAsset_}",
          "theAsset_": "Required asset (either collateral or borrow), it can be NOT underlying"
        },
        "returns": {
          "amountOut": "Amount that was send OR can be claimed on the next call.                   The caller should control own balance to know if the amount was actually send                   (because we need compatibility with exist not-NSR strategies)"
        }
      },
      "revision()": {
        "details": "Contract upgrade counter"
      },
      "setCompoundRatio(uint256)": {
        "details": "PlatformVoter can change compound ratio for some strategies.      A strategy can implement another logic for some uniq cases."
      },
      "setFuseStatus(uint256)": {
        "params": {
          "status": "See PairBasedStrategyLib.FuseStatus enum for possible values"
        }
      },
      "setFuseThresholds(uint256[4])": {
        "params": {
          "values": "Price thresholds: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]"
        }
      },
      "setLiquidationThreshold(address,uint256)": {
        "details": "Liquidation thresholds are used to detect dust in many cases, not only in liquidation case",
        "params": {
          "amount": "Min amount of token allowed to liquidate, token's decimals are used."
        }
      },
      "setReinvestThresholdPercent(uint256)": {
        "params": {
          "percent_": "New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}"
        }
      },
      "setStrategySpecificName(string)": {
        "details": "The name will be used for UI."
      },
      "setWithdrawDone(uint256)": {
        "params": {
          "done": "0 - full withdraw required, 1 - full withdraw was done"
        }
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "totalAssets()": {
        "details": "Total amount of underlying assets under control of this strategy."
      },
      "withdrawAllToSplitter()": {
        "details": "Withdraws all underlying assets to the vault",
        "returns": {
          "strategyLoss": "Loss should be covered from Insurance"
        }
      },
      "withdrawByAggStep(address,address,uint256,bytes,bytes,uint256)": {
        "details": "All swap-by-agg data should be prepared using {quoteWithdrawByAgg} off-chain",
        "params": {
          "aggregator_": "Aggregator that should be used on next swap. 0 - use liquidator",
          "amountToSwap_": "Amount that should be swapped. 0 - no swap",
          "entryToPool": "Allow to enter to the pool at the end. Use false if you are going to make several iterations.                    It's possible to enter back to the pool by calling {rebalanceNoSwaps} at any moment                    0 - not allowed, 1 - allowed, 2 - allowed only if completed",
          "planEntryData": "PLAN_XXX + additional data, see IterationPlanKinds",
          "swapData": "Swap rote that was prepared off-chain.",
          "tokenToSwap_": "What token should be swapped to other"
        },
        "returns": {
          "completed": "All debts were closed, leftovers were swapped to the required proportions."
        }
      },
      "withdrawToSplitter(uint256)": {
        "details": "Withdraws some assets to the splitter",
        "returns": {
          "strategyLoss": "Loss should be covered from Insurance"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "CONTROLLABLE_VERSION()": {
        "notice": "Version of the contract"
      },
      "capacity()": {
        "notice": "Unlimited capacity by default"
      },
      "controller()": {
        "notice": "Return controller address saved in the contract slot"
      },
      "created()": {
        "notice": "Return creation timestamp"
      },
      "createdBlock()": {
        "notice": "Return creation block number"
      },
      "doHardWork()": {
        "notice": "Do hard work with reinvesting"
      },
      "getDefaultState()": {
        "notice": "Returns the current state of the contract"
      },
      "getFees()": {
        "notice": "Returns the fees for the current state."
      },
      "getPropNotUnderlying18()": {
        "notice": "Calculate proportions of [underlying, not-underlying] required by the internal pool of the strategy"
      },
      "init(address,address,address,address,int24,int24,bool,(address,address,address,uint256,uint256),uint256[4])": {
        "notice": "Initialize the strategy with the given parameters."
      },
      "investAll(uint256,bool)": {
        "notice": "Stakes everything the strategy holds into the reward pool. amount_ Amount transferred to the strategy balance just before calling this function"
      },
      "investedAssets()": {
        "notice": "Amount of underlying assets converted to pool assets and invested to the pool."
      },
      "isGovernance(address)": {
        "notice": "Return true if given address is setup as governance in Controller"
      },
      "isReadyToHardWork()": {
        "notice": "Check if the strategy is ready for hard work."
      },
      "liquidationThresholds(address)": {
        "notice": "Minimum token amounts that can be liquidated"
      },
      "needRebalance()": {
        "notice": "Check if the strategy needs rebalancing."
      },
      "onTransferAmounts(address[],uint256[])": {
        "notice": "TetuConverter calls this function when it sends any amount to user's balance"
      },
      "performanceFee()": {
        "notice": "A percent of total profit that is sent to the {performanceReceiver} before compounding"
      },
      "performanceReceiver()": {
        "notice": "{performanceFee}% of total profit is sent to the {performanceReceiver} before compounding"
      },
      "quoteWithdrawByAgg(bytes)": {
        "notice": "Get info about a swap required by next call of {withdrawByAggStep} within the given plan"
      },
      "rebalanceNoSwaps(bool)": {
        "notice": "Rebalance using borrow/repay only, no swaps"
      },
      "requirePayAmountBack(address,uint256)": {
        "notice": "Converters asks to send some amount back.         The results depend on whether the required amount is on the balance:         1. The {amount_} exists on the balance: send the amount to TetuConverter, return {amount_}         2. The {amount_} doesn't exist on the balance. Try to receive the {amount_}.         2.1. if the required amount is received: return {amount_}         2.2. if less amount X (X < {amount_}) is received return X - gap         In the case 2 no amount is send to TetuConverter.         Converter should make second call of requirePayAmountBack({amountOut}) to receive the assets."
      },
      "setFuseStatus(uint256)": {
        "notice": "Manually set status of the fuse"
      },
      "setFuseThresholds(uint256[4])": {
        "notice": "Set thresholds for the fuse: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]         Decimals 18. The thresholds are compared with prices from TetuConverter's price oracle.         Example: [0.9, 0.92, 1.08, 1.1]         Price falls below 0.9 - fuse is ON. Price rises back up to 0.92 - fuse is OFF.         Price raises more and reaches 1.1 - fuse is ON again. Price falls back and reaches 1.08 - fuse OFF again."
      },
      "setWithdrawDone(uint256)": {
        "notice": "Set withdrawDone value.         When a fuse was triggered ON, all debts should be closed and asset should be converted to underlying.         After completion of the conversion withdrawDone can be set to 1.         So, {getFuseStatus} will return  withdrawDone=1 and you will know, that withdraw is not required"
      },
      "setupPerformanceFee(uint256,address,uint256)": {
        "notice": "Set performance fee, receiver and ratio"
      },
      "withdrawByAggStep(address,address,uint256,bytes,bytes,uint256)": {
        "notice": "Make withdraw iteration: [exit from the pool], [make 1 swap], [repay a debt], [enter to the pool]         Typical sequence of the actions is: exit from the pool, make 1 swap, repay 1 debt.         You can enter to the pool if you are sure that you won't have borrow + repay on AAVE3 in the same block."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11608,
        "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 11611,
        "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 108974,
        "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
        "label": "state",
        "offset": 0,
        "slot": "1",
        "type": "t_struct(State)106126_storage"
      },
      {
        "astId": 108981,
        "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
        "label": "__gap",
        "offset": 0,
        "slot": "65",
        "type": "t_array(t_uint256)35_storage"
      },
      {
        "astId": 16958,
        "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
        "label": "baseState",
        "offset": 0,
        "slot": "100",
        "type": "t_struct(BaseState)5555_storage"
      },
      {
        "astId": 17405,
        "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
        "label": "__gap",
        "offset": 0,
        "slot": "107",
        "type": "t_array(t_uint256)43_storage"
      },
      {
        "astId": 97474,
        "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
        "label": "liquidationThresholds",
        "offset": 0,
        "slot": "150",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 97478,
        "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
        "label": "_csbs",
        "offset": 0,
        "slot": "151",
        "type": "t_struct(ConverterStrategyBaseState)93300_storage"
      },
      {
        "astId": 98978,
        "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
        "label": "__gap",
        "offset": 0,
        "slot": "204",
        "type": "t_array(t_uint256)46_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)10_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[10]",
        "numberOfBytes": "320"
      },
      "t_array(t_uint256)33_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[33]",
        "numberOfBytes": "1056"
      },
      "t_array(t_uint256)35_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[35]",
        "numberOfBytes": "1120"
      },
      "t_array(t_uint256)43_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[43]",
        "numberOfBytes": "1376"
      },
      "t_array(t_uint256)46_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[46]",
        "numberOfBytes": "1472"
      },
      "t_array(t_uint256)49_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[49]",
        "numberOfBytes": "1568"
      },
      "t_array(t_uint256)4_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[4]",
        "numberOfBytes": "128"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_contract(ITetuConverter)51535": {
        "encoding": "inplace",
        "label": "contract ITetuConverter",
        "numberOfBytes": "20"
      },
      "t_enum(FuseStatus)120839": {
        "encoding": "inplace",
        "label": "enum PairBasedStrategyLib.FuseStatus",
        "numberOfBytes": "1"
      },
      "t_int24": {
        "encoding": "inplace",
        "label": "int24",
        "numberOfBytes": "3"
      },
      "t_int256": {
        "encoding": "inplace",
        "label": "int256",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_struct(BaseState)5555_storage": {
        "encoding": "inplace",
        "label": "struct IStrategyV3.BaseState",
        "members": [
          {
            "astId": 5536,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "asset",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 5539,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "splitter",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 5542,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "performanceReceiver",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 5545,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "performanceFee",
            "offset": 0,
            "slot": "3",
            "type": "t_uint256"
          },
          {
            "astId": 5548,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "performanceFeeRatio",
            "offset": 0,
            "slot": "4",
            "type": "t_uint256"
          },
          {
            "astId": 5551,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "compoundRatio",
            "offset": 0,
            "slot": "5",
            "type": "t_uint256"
          },
          {
            "astId": 5554,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "strategySpecificName",
            "offset": 0,
            "slot": "6",
            "type": "t_string_storage"
          }
        ],
        "numberOfBytes": "224"
      },
      "t_struct(ConverterStrategyBaseState)93300_storage": {
        "encoding": "inplace",
        "label": "struct IConverterStrategyBase.ConverterStrategyBaseState",
        "members": [
          {
            "astId": 93282,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "investedAssets",
            "offset": 0,
            "slot": "0",
            "type": "t_uint256"
          },
          {
            "astId": 93286,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "converter",
            "offset": 0,
            "slot": "1",
            "type": "t_contract(ITetuConverter)51535"
          },
          {
            "astId": 93289,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "reinvestThresholdPercent",
            "offset": 0,
            "slot": "2",
            "type": "t_uint256"
          },
          {
            "astId": 93292,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "debtToInsurance",
            "offset": 0,
            "slot": "3",
            "type": "t_int256"
          },
          {
            "astId": 93299,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "__gap",
            "offset": 0,
            "slot": "4",
            "type": "t_array(t_uint256)49_storage"
          }
        ],
        "numberOfBytes": "1696"
      },
      "t_struct(FuseStateParams)120879_storage": {
        "encoding": "inplace",
        "label": "struct PairBasedStrategyLib.FuseStateParams",
        "members": [
          {
            "astId": 120868,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "status",
            "offset": 0,
            "slot": "0",
            "type": "t_enum(FuseStatus)120839"
          },
          {
            "astId": 120873,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "thresholds",
            "offset": 0,
            "slot": "1",
            "type": "t_array(t_uint256)4_storage"
          },
          {
            "astId": 120878,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "__gap",
            "offset": 0,
            "slot": "5",
            "type": "t_array(t_uint256)4_storage"
          }
        ],
        "numberOfBytes": "288"
      },
      "t_struct(PairState)123049_storage": {
        "encoding": "inplace",
        "label": "struct PairBasedStrategyLogicLib.PairState",
        "members": [
          {
            "astId": 123008,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "pool",
            "offset": 0,
            "slot": "0",
            "type": "t_address"
          },
          {
            "astId": 123010,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "strategyProfitHolder",
            "offset": 0,
            "slot": "1",
            "type": "t_address"
          },
          {
            "astId": 123013,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "tokenA",
            "offset": 0,
            "slot": "2",
            "type": "t_address"
          },
          {
            "astId": 123016,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "tokenB",
            "offset": 0,
            "slot": "3",
            "type": "t_address"
          },
          {
            "astId": 123018,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "isStablePool",
            "offset": 20,
            "slot": "3",
            "type": "t_bool"
          },
          {
            "astId": 123021,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "depositorSwapTokens",
            "offset": 21,
            "slot": "3",
            "type": "t_bool"
          },
          {
            "astId": 123023,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "tickSpacing",
            "offset": 22,
            "slot": "3",
            "type": "t_int24"
          },
          {
            "astId": 123025,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "lowerTick",
            "offset": 25,
            "slot": "3",
            "type": "t_int24"
          },
          {
            "astId": 123027,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "upperTick",
            "offset": 28,
            "slot": "3",
            "type": "t_int24"
          },
          {
            "astId": 123029,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "rebalanceTickRange",
            "offset": 0,
            "slot": "4",
            "type": "t_int24"
          },
          {
            "astId": 123031,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "totalLiquidity",
            "offset": 3,
            "slot": "4",
            "type": "t_uint128"
          },
          {
            "astId": 123035,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "fuseAB",
            "offset": 0,
            "slot": "5",
            "type": "t_struct(FuseStateParams)120879_storage"
          },
          {
            "astId": 123038,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "withdrawDone",
            "offset": 0,
            "slot": "14",
            "type": "t_uint256"
          },
          {
            "astId": 123041,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "lastRebalanceNoSwap",
            "offset": 0,
            "slot": "15",
            "type": "t_uint256"
          },
          {
            "astId": 123048,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "__gap",
            "offset": 0,
            "slot": "16",
            "type": "t_array(t_uint256)33_storage"
          }
        ],
        "numberOfBytes": "1568"
      },
      "t_struct(State)106126_storage": {
        "encoding": "inplace",
        "label": "struct AlgebraConverterStrategyLogicLib.State",
        "members": [
          {
            "astId": 106110,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "pair",
            "offset": 0,
            "slot": "0",
            "type": "t_struct(PairState)123049_storage"
          },
          {
            "astId": 106112,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "tokenId",
            "offset": 0,
            "slot": "49",
            "type": "t_uint256"
          },
          {
            "astId": 106114,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "rewardToken",
            "offset": 0,
            "slot": "50",
            "type": "t_address"
          },
          {
            "astId": 106116,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "bonusRewardToken",
            "offset": 0,
            "slot": "51",
            "type": "t_address"
          },
          {
            "astId": 106118,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "startTime",
            "offset": 0,
            "slot": "52",
            "type": "t_uint256"
          },
          {
            "astId": 106120,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "endTime",
            "offset": 0,
            "slot": "53",
            "type": "t_uint256"
          },
          {
            "astId": 106125,
            "contract": "contracts/strategies/algebra/AlgebraConverterStrategy.sol:AlgebraConverterStrategy",
            "label": "__gap",
            "offset": 0,
            "slot": "54",
            "type": "t_array(t_uint256)10_storage"
          }
        ],
        "numberOfBytes": "2048"
      },
      "t_uint128": {
        "encoding": "inplace",
        "label": "uint128",
        "numberOfBytes": "16"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}