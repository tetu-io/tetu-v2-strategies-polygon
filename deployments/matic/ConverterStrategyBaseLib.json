{
  "address": "0x9971fDd707a2878Dc201294DcAbef5A0F8901589",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "collateralAsset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrowAsset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountRepay",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recepient",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "returnedAssetAmountOut",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "returnedBorrowAmountOut",
          "type": "uint256"
        }
      ],
      "name": "ClosePosition",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "investedAssetsBefore",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "investedAssetsOut",
          "type": "uint256"
        }
      ],
      "name": "FixPriceChanges",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "tokenIn",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "tokenOut",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "spentAmountIn",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "receivedAmountOut",
          "type": "uint256"
        }
      ],
      "name": "Liquidation",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "converter",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "collateralAsset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "collateralAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "borrowAsset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "borrowedAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "recepient",
          "type": "address"
        }
      ],
      "name": "OpenPosition",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "asset",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "ReturnAssetToConverter",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "contract ITetuConverter",
          "name": "converter",
          "type": "ITetuConverter"
        },
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        }
      ],
      "name": "getAssetPriceFromConverter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract ITetuConverter",
          "name": "converter",
          "type": "ITetuConverter"
        },
        {
          "internalType": "address",
          "name": "tokenA",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "tokenB",
          "type": "address"
        }
      ],
      "name": "getOracleAssetsPrice",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0xc76645add27095a721faa663941a7192f41b8e64d2b6c295a5e8910cad2f6a61",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0x9971fDd707a2878Dc201294DcAbef5A0F8901589",
    "transactionIndex": 45,
    "gasUsed": "5090197",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000008000000000000000000000000000000000400000000000000000000000800000000000800000000100000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000040000000000000000200000000000004000000000000000000000000000000000000000000000004000000000000000000001000000000000008000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0xc101f4fb0cb31f7d8554a6a018f448c240e8dc55b215c7f898509dce15535710",
    "transactionHash": "0xc76645add27095a721faa663941a7192f41b8e64d2b6c295a5e8910cad2f6a61",
    "logs": [
      {
        "transactionIndex": 45,
        "blockNumber": 44395021,
        "transactionHash": "0xc76645add27095a721faa663941a7192f41b8e64d2b6c295a5e8910cad2f6a61",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bbbbb8c4364ec2ce52c59d2ed3e56f307e529a94",
          "0x000000000000000000000000a8b52f02108aa5f4b675bdcc973760022d7c6020"
        ],
        "data": "0x00000000000000000000000000000000000000000000000002309ab928acae00000000000000000000000000000000000000000000000001a94405340dc0b62b0000000000000000000000000000000000000000000000ede07ab5ce57178eb4000000000000000000000000000000000000000000000001a7136a7ae514082b0000000000000000000000000000000000000000000000ede2ab50877fc43cb4",
        "logIndex": 177,
        "blockHash": "0xc101f4fb0cb31f7d8554a6a018f448c240e8dc55b215c7f898509dce15535710"
      }
    ],
    "blockNumber": 44395021,
    "cumulativeGasUsed": "13165207",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 13,
  "solcInputHash": "ab046f60baf4f728a1eee5f7d3f43ff0",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountRepay\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recepient\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnedAssetAmountOut\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"returnedBorrowAmountOut\",\"type\":\"uint256\"}],\"name\":\"ClosePosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investedAssetsBefore\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investedAssetsOut\",\"type\":\"uint256\"}],\"name\":\"FixPriceChanges\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"spentAmountIn\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"receivedAmountOut\",\"type\":\"uint256\"}],\"name\":\"Liquidation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"converter\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"collateralAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"collateralAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"borrowAsset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"borrowedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"recepient\",\"type\":\"address\"}],\"name\":\"OpenPosition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReturnAssetToConverter\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"contract ITetuConverter\",\"name\":\"converter\",\"type\":\"ITetuConverter\"},{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getAssetPriceFromConverter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract ITetuConverter\",\"name\":\"converter\",\"type\":\"ITetuConverter\"},{\"internalType\":\"address\",\"name\":\"tokenA\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenB\",\"type\":\"address\"}],\"name\":\"getOracleAssetsPrice\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"calcInvestedAssets(address[],uint256[],uint256,ITetuConverter)\":{\"details\":\"This is writable function because we need to update current balances in the internal protocols.\",\"returns\":{\"amountOut\":\"Invested asset amount under control (in terms of {asset})\"}},\"closePosition(ITetuConverter,address,address,uint256)\":{\"params\":{\"amountToRepay\":\"Amount to repay in terms of {borrowAsset}\"},\"returns\":{\"repaidAmountOut\":\"Amount that was actually repaid\",\"returnedAssetAmountOut\":\"Amount of collateral received back after repaying\"}},\"closePositionsToGetAmount(ITetuConverter,ITetuLiquidator,uint256,mapping(address => uint256) storage,uint256,address[])\":{\"details\":\"We assume here that this function is called before closing any positions in the current block\",\"params\":{\"liquidationThresholds\":\"Min allowed amounts-out for liquidations\",\"requestedAmount\":\"Requested amount of main asset that should be added to the current balance\"},\"returns\":{\"expectedAmount\":\"Main asset amount expected to be received on balance after all conversions and swaps\"}},\"getOracleAssetsPrice(ITetuConverter,address,address)\":{\"params\":{\"converter\":\"The Tetu converter.\",\"tokenA\":\"The first token address.\",\"tokenB\":\"The second token address.\"},\"returns\":{\"_0\":\"The price ratio of the two tokens.\"}},\"getTokenAmounts(ITetuConverter,address[],uint256,uint256[],uint256)\":{\"params\":{\"collaterals_\":\"Amounts of main asset that can be used as collateral to borrow {tokens_}\",\"thresholdMainAsset_\":\"Value of liquidation threshold for the main (collateral) asset\",\"tokens_\":\"Tokens received from {_depositorPoolAssets}\"},\"returns\":{\"tokenAmountsOut\":\"Amounts available for deposit\"}},\"liquidate(ITetuConverter,ITetuLiquidator,address,address,uint256,uint256,uint256,bool)\":{\"params\":{\"receivedAmountOut\":\"Amount of {tokenOut_} has been returned by the liquidator\",\"skipValidation\":\"Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\",\"spentAmountIn\":\"Amount of {tokenIn} has been consumed by the liquidator\"}},\"makeRequestedAmount(address[],uint256,uint256[],ITetuConverter,ITetuLiquidator,uint256,uint256[],mapping(address => uint256) storage)\":{\"params\":{\"amountsToConvert_\":\"Amounts available for conversion after withdrawing from the pool\",\"expectedMainAssetAmounts\":\"Amounts of main asset that we expect to receive after conversion amountsToConvert_\",\"indexAsset_\":\"Index of main {asset} in {tokens}\",\"requestedAmount\":\"Amount to be withdrawn in terms of the asset in addition to the exist balance.        Max uint means attempt to withdraw all possible invested assets.\",\"tokens_\":\"Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\"},\"returns\":{\"expectedAmount\":\"Expected total amount of main asset after all conversions, swaps and repays\"}},\"openPosition(ITetuConverter,bytes,address,address,uint256,uint256)\":{\"params\":{\"amountIn_\":\"Meaning depends on {entryData_}.\",\"entryData_\":\"Encoded entry kind and additional params if necessary (set of params depends on the kind)                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\"}},\"postWithdrawActions(ITetuConverter,address[],uint256,uint256[],uint256,uint256,uint256[],uint256[])\":{\"params\":{\"amountsToConvert\":\"Amounts of {tokens} to be converted, they are located on the balance before withdraw\",\"withdrawnAmounts\":\"Amounts of {tokens} that were withdrew from the pool\"}},\"recycle(ITetuConverter,address,uint256,address[],ITetuLiquidator,mapping(address => uint256) storage,address[],uint256[],uint256)\":{\"params\":{\"asset\":\"Underlying asset\",\"compoundRatio\":\"Compound ration in the range [0...COMPOUND_DENOMINATOR]\",\"liquidationThresholds\":\"Liquidation thresholds for rewards tokens\",\"performanceFee\":\"Performance fee in the range [0...FEE_DENOMINATOR]\",\"rewardAmounts\":\"Amounts of {rewardTokens_}; we assume, there are no zero amounts here\",\"rewardTokens\":\"Full list of reward tokens received from tetuConverter and depositor\",\"tokens\":\"tokens received from {_depositorPoolAssets}\"},\"returns\":{\"amountToPerformanceAndInsurance\":\"Amount of underlying to be sent to performance receiver and insurance\",\"amountsToForward\":\"Amounts of {rewardTokens} to be sent to forwarder, zero amounts are allowed here\"}},\"swapToGivenAmountAndSendToConverter(uint256,uint256,address[],address,address,address,mapping(address => uint256) storage)\":{\"params\":{\"amount_\":\"Amount of the main asset requested by converter\",\"asset\":\"Main asset or underlying (it can be different from tokens[indexTheAsset])\",\"indexTheAsset\":\"Index of the asset required by converter in the {tokens}\"},\"returns\":{\"amountOut\":\"Amount of the main asset sent to converter\"}}},\"stateVariables\":{\"DEFAULT_LIQUIDATION_THRESHOLD\":{\"details\":\"Absolute value for any token\"},\"GAP_CONVERSION\":{\"details\":\"We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\"}},\"version\":1},\"userdoc\":{\"events\":{\"ClosePosition(address,address,uint256,address,uint256,uint256)\":{\"notice\":\"Some borrow(s) was/were repaid\"},\"Liquidation(address,address,uint256,uint256,uint256)\":{\"notice\":\"A liquidation was made\"},\"OpenPosition(address,address,uint256,address,uint256,address)\":{\"notice\":\"A borrow was made\"}},\"kind\":\"user\",\"methods\":{\"calcInvestedAssets(address[],uint256[],uint256,ITetuConverter)\":{\"notice\":\"Calculate amount we will receive when we withdraw all from pool\"},\"closePosition(ITetuConverter,address,address,uint256)\":{\"notice\":\"Close the given position, pay {amountToRepay}, return collateral amount in result\"},\"closePositionsToGetAmount(ITetuConverter,ITetuLiquidator,uint256,mapping(address => uint256) storage,uint256,address[])\":{\"notice\":\"Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\"},\"coverPossibleStrategyLoss(uint256,uint256,address)\":{\"notice\":\"Register income and cover possible loss\"},\"getOracleAssetsPrice(ITetuConverter,address,address)\":{\"notice\":\"Get the price ratio of the two given tokens from the oracle.\"},\"getTokenAmounts(ITetuConverter,address[],uint256,uint256[],uint256)\":{\"notice\":\"Make borrow and save amounts of tokens available for deposit to tokenAmounts\"},\"liquidate(ITetuConverter,ITetuLiquidator,address,address,uint256,uint256,uint256,bool)\":{\"notice\":\"Make liquidation if estimated amountOut exceeds the given threshold\"},\"makeRequestedAmount(address[],uint256,uint256[],ITetuConverter,ITetuLiquidator,uint256,uint256[],mapping(address => uint256) storage)\":{\"notice\":\"Convert {amountsToConvert_} to the main {asset}         Swap leftovers (if any) to the main asset.         If result amount is less than expected, try to close any other available debts (1 repay per block only)\"},\"openPosition(ITetuConverter,bytes,address,address,uint256,uint256)\":{\"notice\":\"Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}         Max possible collateral should be approved before calling of this function.\"},\"postWithdrawActions(ITetuConverter,address[],uint256,uint256[],uint256,uint256,uint256[],uint256[])\":{\"notice\":\"Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\"},\"postWithdrawActionsEmpty(ITetuConverter,address[],uint256,uint256[])\":{\"notice\":\"return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\"},\"recycle(ITetuConverter,address,uint256,address[],ITetuLiquidator,mapping(address => uint256) storage,address[],uint256[],uint256)\":{\"notice\":\"Recycle the amounts: split each amount on tree parts: performance+insurance (P), forwarder (F), compound (C)         Liquidate P+C, send F to the forwarder. We have two kinds of rewards: 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets) 2) any other rewards All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound   Compound-part of Rewards-2 can be liquidated   Compound part of Rewards-1 should be just left on the balance   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.   Performance amounts are liquidated, result amount of underlying is returned in {amountToPerformanceAndInsurance}\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/ConverterStrategyBaseLib.sol\":\"ConverterStrategyBaseLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IController {\\n\\n  // --- DEPENDENCY ADDRESSES\\n  function governance() external view returns (address);\\n\\n  function voter() external view returns (address);\\n\\n  function liquidator() external view returns (address);\\n\\n  function forwarder() external view returns (address);\\n\\n  function investFund() external view returns (address);\\n\\n  function veDistributor() external view returns (address);\\n\\n  function platformVoter() external view returns (address);\\n\\n  // --- VAULTS\\n\\n  function vaults(uint id) external view returns (address);\\n\\n  function vaultsList() external view returns (address[] memory);\\n\\n  function vaultsListLength() external view returns (uint);\\n\\n  function isValidVault(address _vault) external view returns (bool);\\n\\n  // --- restrictions\\n\\n  function isOperator(address _adr) external view returns (bool);\\n\\n\\n}\\n\",\"keccak256\":\"0x86716b8a4775605c31b8bb9f90f8f4a18b709ff4435182f3a148803368060a8c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x5f43ed533d0fc4dc2f8f081d2c4b77960f3e908d5f7359096b385e5673f1ba0c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n     */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n     */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n     */\\n  function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x953f20efa64081a325109a0e03602b889d2819c2b51c1e1fb21a062feeda74f3\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x9f69f84d864c2a84de9321871aa52f6f70d14afe46badbcd37c0d4f22af75e7b\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IForwarder {\\n\\n  function tetu() external view returns (address);\\n  function tetuThreshold() external view returns (uint);\\n\\n  function tokenPerDestinationLength(address destination) external view returns (uint);\\n\\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\\n\\n  function amountPerDestination(address token, address destination) external view returns (uint amount);\\n\\n  function registerIncome(\\n    address[] memory tokens,\\n    uint[] memory amounts,\\n    address vault,\\n    bool isDistribute\\n  ) external;\\n\\n  function distributeAll(address destination) external;\\n\\n  function distribute(address token) external;\\n\\n  function setInvestFundRatio(uint value) external;\\n\\n  function setGaugesRatio(uint value) external;\\n\\n}\\n\",\"keccak256\":\"0x687c497fc034e8d64bca403bac1bf4cd7bd1f107df414c2657325c1b3ab92822\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ISplitter {\\n\\n  function init(address controller_, address _asset, address _vault) external;\\n\\n  // *************** ACTIONS **************\\n\\n  function withdrawAllToVault() external;\\n\\n  function withdrawToVault(uint256 amount) external;\\n\\n  function coverPossibleStrategyLoss(uint earned, uint lost) external;\\n\\n  function doHardWork() external;\\n\\n  function investAll() external;\\n\\n  // **************** VIEWS ***************\\n\\n  function asset() external view returns (address);\\n\\n  function vault() external view returns (address);\\n\\n  function totalAssets() external view returns (uint256);\\n\\n  function isHardWorking() external view returns (bool);\\n\\n  function strategies(uint i) external view returns (address);\\n\\n  function strategiesLength() external view returns (uint);\\n\\n  function HARDWORK_DELAY() external view returns (uint);\\n\\n  function lastHardWorks(address strategy) external view returns (uint);\\n\\n  function pausedStrategies(address strategy) external view returns (bool);\\n\\n  function pauseInvesting(address strategy) external;\\n\\n  function continueInvesting(address strategy, uint apr) external;\\n\\n}\\n\",\"keccak256\":\"0x68f37a5089c98097159e7f18ef04c42d15e10e6c11602e47bc6092708c11e5fc\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface ITetuLiquidator {\\n\\n  struct PoolData {\\n    address pool;\\n    address swapper;\\n    address tokenIn;\\n    address tokenOut;\\n  }\\n\\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\\n\\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\\n\\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\\n\\n  function buildRoute(\\n    address tokenIn,\\n    address tokenOut\\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\\n\\n  function liquidate(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n  function liquidateWithRoute(\\n    PoolData[] memory route,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n\\n}\\n\",\"keccak256\":\"0xd5fe6f3ab750cc2d23f573597db5607c701e74c39e13c20c07a921a26c6d5012\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IVaultInsurance.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISplitter.sol\\\";\\n\\ninterface ITetuVaultV2 {\\n\\n  function splitter() external view returns (ISplitter);\\n\\n  function insurance() external view returns (IVaultInsurance);\\n\\n  function depositFee() external view returns (uint);\\n\\n  function withdrawFee() external view returns (uint);\\n\\n  function init(\\n    address controller_,\\n    IERC20 _asset,\\n    string memory _name,\\n    string memory _symbol,\\n    address _gauge,\\n    uint _buffer\\n  ) external;\\n\\n  function setSplitter(address _splitter) external;\\n\\n  function coverLoss(uint amount) external;\\n\\n  function initInsurance(IVaultInsurance _insurance) external;\\n\\n}\\n\",\"keccak256\":\"0x9e77a10b32a52f826d28d17c420f776fd289e5e4f925ec87f7177a1ce224a412\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IVaultInsurance {\\n\\n  function init(address _vault, address _asset) external;\\n\\n  function vault() external view returns (address);\\n\\n  function asset() external view returns (address);\\n\\n  function transferToVault(uint amount) external;\\n\\n}\\n\",\"keccak256\":\"0x6461572763b1f6decec1dee9d2ffe8ca152369bdc68255ec083cb3da3ce507a1\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        // only check isContract if the call was successful and the return data is empty\\n        // otherwise we already know that it was a contract\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n    // Look for revert reason and bubble it up if present\\n    if (returndata.length > 0) {\\n      // The easiest way to bubble the revert reason is using memory via assembly\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xcc7eeaafd4384e04ff39e0c01f0a6794736c34cad529751b8abd7b088ecc2e83\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n  enum Rounding {\\n    Down, // Toward negative infinity\\n    Up, // Toward infinity\\n    Zero // Toward zero\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b - 1) / b can overflow on addition, so we distribute.\\n    return a == 0 ? 0 : (a - 1) / b + 1;\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n  unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly {\\n      let mm := mulmod(x, y, not(0))\\n      prod0 := mul(x, y)\\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n      return prod0 / denominator;\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly {\\n    // Compute remainder using mulmod.\\n      remainder := mulmod(x, y, denominator)\\n\\n    // Subtract 256 bit number from 512 bit number.\\n      prod1 := sub(prod1, gt(remainder, prod0))\\n      prod0 := sub(prod0, remainder)\\n    }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n    // See https://cs.stackexchange.com/q/138556/92363.\\n\\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\\n    uint256 twos = denominator & (~denominator + 1);\\n    assembly {\\n    // Divide denominator by twos.\\n      denominator := div(denominator, twos)\\n\\n    // Divide [prod1 prod0] by twos.\\n      prod0 := div(prod0, twos)\\n\\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n      twos := add(div(sub(0, twos), twos), 1)\\n    }\\n\\n    // Shift in bits from prod1 into prod0.\\n    prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n    uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n    // in modular arithmetic, doubling the correct bits in each step.\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n    result = prod0 * inverse;\\n    return result;\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator,\\n    Rounding rounding\\n  ) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n  unchecked {\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    return min(result, a / result);\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = sqrt(a);\\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 128;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 64;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 32;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 16;\\n    }\\n    if (value >> 8 > 0) {\\n      value >>= 8;\\n      result += 8;\\n    }\\n    if (value >> 4 > 0) {\\n      value >>= 4;\\n      result += 4;\\n    }\\n    if (value >> 2 > 0) {\\n      value >>= 2;\\n      result += 2;\\n    }\\n    if (value >> 1 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log2(value);\\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >= 10**64) {\\n      value /= 10**64;\\n      result += 64;\\n    }\\n    if (value >= 10**32) {\\n      value /= 10**32;\\n      result += 32;\\n    }\\n    if (value >= 10**16) {\\n      value /= 10**16;\\n      result += 16;\\n    }\\n    if (value >= 10**8) {\\n      value /= 10**8;\\n      result += 8;\\n    }\\n    if (value >= 10**4) {\\n      value /= 10**4;\\n      result += 4;\\n    }\\n    if (value >= 10**2) {\\n      value /= 10**2;\\n      result += 2;\\n    }\\n    if (value >= 10**1) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log10(value);\\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 16;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 8;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 4;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 2;\\n    }\\n    if (value >> 8 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log256(value);\\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n  }\\n  }\\n}\\n\",\"keccak256\":\"0x2c5be0f4a60126b08e20f40586958ec1b76a27b69406c4b0db19e9dc6f771cfc\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n  unchecked {\\n    uint256 oldAllowance = token.allowance(address(this), spender);\\n    require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n    uint256 newAllowance = oldAllowance - value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n  }\\n\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x2378ee07b24e40c75781b27b2aa0812769c0000964e2d2501e3d234d3285dd18\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/SafeERC20.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\n\\nlibrary StrategyLib {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Denominator for fee calculation.\\n  uint internal constant FEE_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        EVENTS\\n  // *************************************************************\\n\\n  event CompoundRatioChanged(uint oldValue, uint newValue);\\n  event StrategySpecificNameChanged(string name);\\n  event EmergencyExit(address sender, uint amount);\\n  event ManualClaim(address sender);\\n  event InvestAll(uint balance);\\n  event WithdrawAllToSplitter(uint amount);\\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\\n\\n  // *************************************************************\\n  //                        ERRORS\\n  // *************************************************************\\n\\n  string internal constant DENIED = \\\"SB: Denied\\\";\\n  string internal constant TOO_HIGH = \\\"SB: Too high\\\";\\n  string internal constant WRONG_VALUE = \\\"SB: Wrong value\\\";\\n  /// @dev Denominator for compound ratio\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        CHECKS AND EMITS\\n  // *************************************************************\\n\\n  function _checkCompoundRatioChanged(address controller, uint oldValue, uint newValue) external {\\n    onlyPlatformVoter(controller);\\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\\n    emit CompoundRatioChanged(oldValue, newValue);\\n  }\\n\\n  function _checkStrategySpecificNameChanged(address controller, string calldata newName) external {\\n    onlyOperators(controller);\\n    emit StrategySpecificNameChanged(newName);\\n  }\\n\\n  function _checkManualClaim(address controller) external {\\n    onlyOperators(controller);\\n    emit ManualClaim(msg.sender);\\n  }\\n\\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\\n    onlySplitter(splitter);\\n    assetBalance = IERC20(asset).balanceOf(address(this));\\n    emit InvestAll(assetBalance);\\n  }\\n\\n  // *************************************************************\\n  //                     RESTRICTIONS\\n  // *************************************************************\\n\\n  /// @dev Restrict access only for operators\\n  function onlyOperators(address controller) public view {\\n    require(IController(controller).isOperator(msg.sender), DENIED);\\n  }\\n\\n  /// @dev Restrict access only for governance\\n  function onlyGovernance(address controller) public view {\\n    require(IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for platform voter\\n  function onlyPlatformVoter(address controller) public view {\\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for splitter\\n  function onlySplitter(address splitter) public view {\\n    require(splitter == msg.sender, DENIED);\\n  }\\n\\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_) external view {\\n    onlyGovernance(controller);\\n    require(fee_ <= 100_000, TOO_HIGH);\\n    require(receiver_ != address(0), WRONG_VALUE);\\n  }\\n\\n  // *************************************************************\\n  //                       HELPERS\\n  // *************************************************************\\n\\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\\n  ///         Revert if the amount is different from expected too much (high price impact)\\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\\n  /// @param assetPrice Price of the asset, decimals 18\\n  /// @return balance Current asset balance of the strategy\\n  function checkWithdrawImpact(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) public view returns (uint balance) {\\n    balance = IERC20(_asset).balanceOf(address(this));\\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\\n\\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\\n    }\\n  }\\n\\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\\n    onlyOperators(controller);\\n\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    IERC20(asset).safeTransfer(splitter, balance);\\n    emit EmergencyExit(msg.sender, balance);\\n  }\\n\\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\\n    onlySplitter(splitter);\\n    return IERC20(asset).balanceOf(address(this));\\n  }\\n\\n  function _withdrawAllToSplitterPostActions(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) external {\\n    uint balance = checkWithdrawImpact(\\n      _asset,\\n      balanceBefore,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n\\n    if (balance != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, balance);\\n    }\\n    emit WithdrawAllToSplitter(balance);\\n  }\\n\\n  function _withdrawToSplitterPostActions(\\n    uint amount,\\n    uint balance,\\n    address _asset,\\n    address _splitter\\n  ) external {\\n    uint amountAdjusted = Math.min(amount, balance);\\n    if (amountAdjusted != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\\n    }\\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\\n  }\\n}\\n\",\"keccak256\":\"0x81940f83bfee07d985fc82504e764db61673f99ae82e1d323f64f51843b7ef9f\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/// @notice Keep and provide addresses of all application contracts\\ninterface IConverterController {\\n  function governance() external view returns (address);\\n\\n  // ********************* Health factor explanation  ****************\\n  // For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\\n  // For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\\n  // We set min-health-factor = 1.1, target-health-factor = 1.3\\n  // For collateral 100 we will borrow 100/1.3 = 76.92\\n  //\\n  // Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\\n  // Collateral * LT    85         65.45\\n  // Borrow value       65.38      65.38         but borrow value is the same as before\\n  // Health factor      1.3        1.001         liquidation almost happens here (!)\\n  //\\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\\n  // and the borrow value won't change at the same time, the liquidation happens at that point.\\n  // Min health factor marks the point at which a rebalancing must be made asap.\\n  // *****************************************************************\\n\\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\\n  function minHealthFactor2() external view returns (uint16);\\n  function setMinHealthFactor2(uint16 value_) external;\\n\\n  /// @notice target health factor with decimals 2\\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\\n  ///      or additional borrow and restore the health factor to the given target value\\n  function targetHealthFactor2() external view returns (uint16);\\n  function setTargetHealthFactor2(uint16 value_) external;\\n\\n  /// @notice max allowed health factor with decimals 2\\n  /// @dev For future versions, currently max health factor is not used\\n  function maxHealthFactor2() external view returns (uint16);\\n  /// @dev For future versions, currently max health factor is not used\\n  function setMaxHealthFactor2(uint16 value_) external;\\n\\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\\n  function blocksPerDay() external view returns (uint);\\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\\n  /// @notice Check if it's time to call updateBlocksPerDay()\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\\n  /// @notice Recalculate blocksPerDay value\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function updateBlocksPerDay(uint periodInSeconds_) external;\\n\\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\\n  function paused() external view returns (bool);\\n\\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\\n  function isWhitelisted(address user_) external view returns (bool);\\n\\n  /// @notice The size of the gap by which the debt should be increased upon repayment\\n  ///         Such gaps are required by AAVE pool adapters to workaround dust tokens problem\\n  ///         and be able to make full repayment.\\n  /// @dev Debt gap is applied as following: toPay = debt * (DEBT_GAP_DENOMINATOR + debtGap) / DEBT_GAP_DENOMINATOR\\n  function debtGap() external view returns (uint);\\n\\n  //-----------------------------------------------------\\n  //        Core application contracts\\n  //-----------------------------------------------------\\n\\n  function tetuConverter() external view returns (address);\\n  function borrowManager() external view returns (address);\\n  function debtMonitor() external view returns (address);\\n  function tetuLiquidator() external view returns (address);\\n  function swapManager() external view returns (address);\\n  function priceOracle() external view returns (address);\\n\\n  //-----------------------------------------------------\\n  //        External contracts\\n  //-----------------------------------------------------\\n  /// @notice A keeper to control health and efficiency of the borrows\\n  function keeper() external view returns (address);\\n  /// @notice Controller of tetu-contracts-v2, that is allowed to update proxy contracts\\n  function proxyUpdater() external view returns (address);\\n}\\n\",\"keccak256\":\"0xefb20480cab050b2e178982481efc65babd931bdb6aeb4f0e10c58684cee43f1\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterControllerProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IConverterControllerProvider {\\n  function controller() external view returns (address);\\n}\\n\",\"keccak256\":\"0x71dce61809acb75f9078290e90033ffe816a51f18b7cb296d161e278c36eec86\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IPriceOracle {\\n  /// @notice Return asset price in USD, decimals 18\\n  function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb11e653eb4d6d7c41f29ee1e3e498253cfa8df1aec3ff31ab527009b79bdb705\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IConverterControllerProvider.sol\\\";\\n\\n/// @notice Main contract of the TetuConverter application\\n/// @dev Borrower (strategy) makes all operations via this contract only.\\ninterface ITetuConverter is IConverterControllerProvider {\\n\\n  /// @notice Find possible borrow strategies and provide \\\"cost of money\\\" as interest for the period for each strategy\\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converters Array of available converters ordered in ascending order of APR.\\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\\n  ///                    This address should be passed to borrow-function during conversion.\\n  ///                    The length of array is always equal to the count of available lending platforms.\\n  ///                    Last items in array can contain zero addresses (it means they are not used)\\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\\n  /// @return amountToBorrowsOut Amounts that should be borrowed\\n  ///                            This amount is not zero if corresponded converter is not zero.\\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\\n  function findBorrowStrategies(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external view returns (\\n    address[] memory converters,\\n    uint[] memory collateralAmountsOut,\\n    uint[] memory amountToBorrowsOut,\\n    int[] memory aprs18\\n  );\\n\\n  /// @notice Find best swap strategy and provide \\\"cost of money\\\" as interest for the period\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findSwapStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_\\n  ) external returns (\\n    address converter,\\n    uint sourceAmountOut,\\n    uint targetAmountOut,\\n    int apr18\\n  );\\n\\n  /// @notice Find best conversion strategy (swap or borrow) and provide \\\"cost of money\\\" as interest for the period.\\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findConversionStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external returns (\\n    address converter,\\n    uint collateralAmountOut,\\n    uint amountToBorrowOut,\\n    int apr18\\n  );\\n\\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\\n  ///      Only whitelisted users are allowed to make borrows\\n  /// @param converter_ A converter received from findBestConversionStrategy.\\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\\n  ///                          This amount must be approved to TetuConverter before the call.\\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\\n  /// @param receiver_ A receiver of borrowed amount\\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\\n  function borrow(\\n    address converter_,\\n    address collateralAsset_,\\n    uint collateralAmount_,\\n    address borrowAsset_,\\n    uint amountToBorrow_,\\n    address receiver_\\n  ) external returns (\\n    uint borrowedAmountOut\\n  );\\n\\n  /// @notice Full or partial repay of the borrow\\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        You can know exact total amount of debt using {getStatusCurrent}.\\n  ///        if the amount exceed total amount of the debt:\\n  ///           - the debt will be fully repaid\\n  ///           - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\\n  ///        This amount should be calculated with taking into account possible debt gap,\\n  ///        You should call getDebtAmountCurrent(debtGap = true) to get this amount.\\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\\n  ///         If TetuConverter is not able to make the swap, it reverts\\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\\n  ///                                 This amount is returned back to the collateralReceiver_\\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\\n  function repay(\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_,\\n    address receiver_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint returnedBorrowAmountOut,\\n    uint swappedLeftoverCollateralOut,\\n    uint swappedLeftoverBorrowOut\\n  );\\n\\n  /// @notice Estimate result amount after making full or partial repay\\n  /// @dev It works in exactly same way as repay() but don't make actual repay\\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\\n  /// @param user_ user whose amount-to-repay will be calculated\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        This amount should be calculated without possible debt gap.\\n  ///        In this way it's differ from {repay}\\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\\n  /// @return swappedAmountOut A part of {collateralAmountOut} that were received by direct swap\\n  function quoteRepay(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint swappedAmountOut\\n  );\\n\\n  /// @notice Update status in all opened positions\\n  ///         After this call getDebtAmount will be able to return exact amount to repay\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountCurrent(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountStored(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external view returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\\n  /// @param user_ user whose debts will be returned\\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\\n  ///                                           even if all borrowed amount will be returned.\\n  ///                                           If this amount is not 0, you ask to get too much collateral.\\n  function estimateRepay(\\n    address user_,\\n    address collateralAsset_,\\n    uint collateralAmountRequired_,\\n    address borrowAsset_\\n  ) external view returns (\\n    uint borrowAssetAmount,\\n    uint unobtainableCollateralAssetAmount\\n  );\\n\\n  /// @notice Transfer all reward tokens to {receiver_}\\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\\n  function claimRewards(address receiver_) external returns (\\n    address[] memory rewardTokensOut,\\n    uint[] memory amountsOut\\n  );\\n\\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\\n  ///                      It should be transferred on balance of the TetuConverter before the function call\\n  /// @param receiver_ Result amount will be sent to this address\\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\\n  function safeLiquidate(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    address receiver_,\\n    uint priceImpactToleranceSource_,\\n    uint priceImpactToleranceTarget_\\n  ) external returns (\\n    uint amountOut\\n  );\\n\\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\\n  function isConversionValid(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    uint amountOut_,\\n    uint priceImpactTolerance_\\n  ) external view returns (bool);\\n\\n  /// @notice Close given borrow and return collateral back to the user, governance only\\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\\n  /// @param poolAdapter_ The pool adapter that represents the borrow\\n  /// @param closePosition Close position after repay\\n  ///        Usually it should be true, because the function always tries to repay all debt\\n  ///        false can be used if user doesn't have enough amount to pay full debt\\n  ///              and we are trying to pay \\\"as much as possible\\\"\\n  /// @return collateralAmountOut Amount of collateral returned to the user\\n  /// @return repaidAmountOut Amount of borrow asset paid to the lending platform\\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\\n    uint collateralAmountOut,\\n    uint repaidAmountOut\\n  );\\n\\n  /// @notice Get active borrows of the user with given collateral/borrowToken\\n  /// @dev Simple access to IDebtMonitor.getPositions\\n  /// @return poolAdaptersOut The instances of IPoolAdapter\\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external view returns (\\n    address[] memory poolAdaptersOut\\n  );\\n\\n  /// @notice Save token from TC-balance to {receiver}\\n  /// @dev Normally TetuConverter doesn't have any tokens on balance, they can appear there accidentally only\\n  function salvage(address receiver, address token, uint amount) external;\\n}\\n\",\"keccak256\":\"0xd30f740004b39189b18ab99299e9d673ff48b754e053415130a6eda95558fa7d\",\"license\":\"MIT\"},\"contracts/libs/AppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice List of all errors generated by the application\\n///         Each error should have unique code TS-XXX and descriptive comment\\nlibrary AppErrors {\\n  /// @notice Provided address should be not zero\\n  string public constant ZERO_ADDRESS = \\\"TS-1 zero address\\\";\\n\\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\\n  string public constant UNISWAP_PAIR_NOT_FOUND = \\\"TS-2 pair not found\\\";\\n\\n  /// @notice Lengths not matched\\n  string public constant WRONG_LENGTHS = \\\"TS-4 wrong lengths\\\";\\n\\n  /// @notice Unexpected zero balance\\n  string public constant ZERO_BALANCE = \\\"TS-5 zero balance\\\";\\n\\n  string public constant ITEM_NOT_FOUND = \\\"TS-6 not found\\\";\\n\\n  string public constant NOT_ENOUGH_BALANCE = \\\"TS-7 not enough balance\\\";\\n\\n  /// @notice Price oracle returns zero price\\n  string public constant ZERO_PRICE = \\\"TS-8 zero price\\\";\\n\\n  string public constant WRONG_VALUE = \\\"TS-9 wrong value\\\";\\n\\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\\n  string public constant ZERO_AMOUNT_BORROWED = \\\"TS-10 zero borrowed amount\\\";\\n\\n  string public constant WITHDRAW_TOO_MUCH = \\\"TS-11 try to withdraw too much\\\";\\n\\n  string public constant UNKNOWN_ENTRY_KIND = \\\"TS-12 unknown entry kind\\\";\\n\\n  string public constant ONLY_TETU_CONVERTER = \\\"TS-13 only TetuConverter\\\";\\n\\n  string public constant WRONG_ASSET = \\\"TS-14 wrong asset\\\";\\n\\n  string public constant NO_LIQUIDATION_ROUTE = \\\"TS-15 No liquidation route\\\";\\n\\n  string public constant PRICE_IMPACT = \\\"TS-16 price impact\\\";\\n\\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\\n  string public constant REPAY_MAKES_SWAP = \\\"TS-17 can not convert back\\\";\\n\\n  string public constant NO_INVESTMENTS = \\\"TS-18 no investments\\\";\\n\\n  string public constant INCORRECT_LENGTHS = \\\"TS-19 lengths\\\";\\n\\n  /// @notice We expect increasing of the balance, but it was decreased\\n  string public constant BALANCE_DECREASE = \\\"TS-20 balance decrease\\\";\\n\\n  /// @notice Prices changed and invested assets amount was increased on S, value of S is too high\\n  string public constant EARNED_AMOUNT_TOO_HIGH = \\\"TS-21 earned too high\\\";\\n\\n  string public constant GOVERNANCE_ONLY = \\\"TS-22 governance only\\\";\\n}\\n\",\"keccak256\":\"0xc723cb16fc5a3e054ebd5f1597da4b092efec3041a87a6d3a816246721437042\",\"license\":\"MIT\"},\"contracts/libs/AppLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\\\";\\n\\n/// @notice Common internal utils\\nlibrary AppLib {\\n  using SafeERC20 for IERC20;\\n\\n  /// @notice Unchecked increment for for-cycles\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\n    unchecked {\\n      return i + 1;\\n    }\\n  }\\n\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\n  /// @dev Should NOT be used for third-party pools\\n  function approveIfNeeded(address token, uint amount, address spender) internal {\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\n      IERC20(token).safeApprove(spender, 0);\\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\\n      IERC20(token).safeApprove(spender, 2 ** 255);\\n    }\\n  }\\n\\n  function balance(address token) internal view returns (uint) {\\n    return IERC20(token).balanceOf(address(this));\\n  }\\n}\\n\",\"keccak256\":\"0xfab865a9b68066722b1ffea0123683a3a0515bc4cfa03c067c93d191a625e63d\",\"license\":\"MIT\"},\"contracts/libs/ConverterEntryKinds.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\\nlibrary ConverterEntryKinds {\\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\\n\\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\\n  ///         C2 should be used as collateral to make a borrow B.\\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\\n\\n  /// @notice Borrow given amount using min possible collateral\\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\\n\\n  /// @notice Decode entryData, extract first uint - entry kind\\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\\n    if (entryData_.length == 0) {\\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\\n    }\\n    return abi.decode(entryData_, (uint));\\n  }\\n}\\n\",\"keccak256\":\"0x42e53e67f20fe11a5f5209e21f2d9b2ebeacdb197ae506ac796920907ea679a2\",\"license\":\"MIT\"},\"contracts/libs/TokenAmountsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./AppErrors.sol\\\";\\n\\n/// @title Library for clearing / joining token addresses & amounts arrays\\n/// @author bogdoslav\\nlibrary TokenAmountsLib {\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \\\"1.0.1\\\";\\n\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\n    unchecked {\\n      return i + 1;\\n    }\\n  }\\n\\n  function filterZeroAmounts(\\n    address[] memory tokens,\\n    uint[] memory amounts\\n  ) internal pure returns (\\n    address[] memory t,\\n    uint[] memory a\\n  ) {\\n    require(tokens.length == amounts.length, AppErrors.INCORRECT_LENGTHS);\\n    uint len2 = 0;\\n    uint len = tokens.length;\\n    for (uint i = 0; i < len; i++) {\\n      if (amounts[i] != 0) len2++;\\n    }\\n\\n    t = new address[](len2);\\n    a = new uint[](len2);\\n\\n    uint j = 0;\\n    for (uint i = 0; i < len; i++) {\\n      uint amount = amounts[i];\\n      if (amount != 0) {\\n        t[j] = tokens[i];\\n        a[j] = amount;\\n        j++;\\n      }\\n    }\\n  }\\n\\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\\n  function combineArrays(\\n    address[] memory tokens0,\\n    uint[] memory amounts0,\\n    address[] memory tokens1,\\n    uint[] memory amounts1,\\n    address[] memory tokens2,\\n    uint[] memory amounts2\\n  ) internal pure returns (\\n    address[] memory allTokens,\\n    uint[] memory allAmounts\\n  ) {\\n    uint[] memory lens = new uint[](3);\\n    lens[0] = tokens0.length;\\n    lens[1] = tokens1.length;\\n    lens[2] = tokens2.length;\\n\\n    require(\\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\\n      AppErrors.INCORRECT_LENGTHS\\n    );\\n\\n    uint maxLength = lens[0] + lens[1] + lens[2];\\n    address[] memory tokensOut = new address[](maxLength);\\n    uint[] memory amountsOut = new uint[](maxLength);\\n    uint unitedLength;\\n\\n    for (uint step; step < 3; ++step) {\\n      uint[] memory amounts = step == 0\\n        ? amounts0\\n        : (step == 1\\n          ? amounts1\\n          : amounts2);\\n      address[] memory tokens = step == 0\\n        ? tokens0\\n        : (step == 1\\n          ? tokens1\\n          : tokens2);\\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\\n        uint amount1 = amounts[i1];\\n        address token1 = tokens[i1];\\n        bool united = false;\\n\\n        for (uint i = 0; i < unitedLength; i++) {\\n          if (token1 == tokensOut[i]) {\\n            amountsOut[i] += amount1;\\n            united = true;\\n            break;\\n          }\\n        }\\n\\n        if (!united) {\\n          tokensOut[unitedLength] = token1;\\n          amountsOut[unitedLength] = amount1;\\n          unitedLength++;\\n        }\\n      }\\n    }\\n\\n    // copy united tokens to result array\\n    allTokens = new address[](unitedLength);\\n    allAmounts = new uint[](unitedLength);\\n    for (uint i; i < unitedLength; i++) {\\n      allTokens[i] = tokensOut[i];\\n      allAmounts[i] = amountsOut[i];\\n    }\\n\\n  }\\n}\\n\",\"keccak256\":\"0x6be459b8106584d7f9d3ad9f7a9fe6afa86bc41c5915c2d708715dba75c6174a\",\"license\":\"MIT\"},\"contracts/strategies/ConverterStrategyBaseLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"../libs/AppErrors.sol\\\";\\nimport \\\"../libs/AppLib.sol\\\";\\nimport \\\"../libs/TokenAmountsLib.sol\\\";\\nimport \\\"../libs/ConverterEntryKinds.sol\\\";\\n\\nlibrary ConverterStrategyBaseLib {\\n  using SafeERC20 for IERC20;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Data types\\n  /////////////////////////////////////////////////////////////////////\\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\\n  struct RecycleLocalParams {\\n    /// @notice Compound amount + Performance amount\\n    uint amountCP;\\n    /// @notice Amount to compound\\n    uint amountC;\\n    /// @notice Amount to send to performance and insurance\\n    uint amountP;\\n    /// @notice Amount to forwarder + amount to compound\\n    uint amountFC;\\n    address rewardToken;\\n    uint liquidationThresholdAsset;\\n    uint len;\\n    uint receivedAmountOut;\\n  }\\n\\n  struct OpenPositionLocal {\\n    uint entryKind;\\n    address[] converters;\\n    uint[] collateralsRequired;\\n    uint[] amountsToBorrow;\\n    uint collateral;\\n    uint amountToBorrow;\\n  }\\n\\n  struct OpenPositionEntryKind1Local {\\n    address[] converters;\\n    uint[] collateralsRequired;\\n    uint[] amountsToBorrow;\\n    uint collateral;\\n    uint amountToBorrow;\\n    uint c1;\\n    uint c3;\\n    uint ratio;\\n    uint alpha;\\n  }\\n\\n  struct CalcInvestedAssetsLocal {\\n    uint len;\\n    uint[] prices;\\n    uint[] decs;\\n    uint[] debts;\\n  }\\n\\n  struct ConvertAfterWithdrawLocal {\\n    address asset;\\n    uint collateral;\\n    uint spent;\\n    uint received;\\n    uint balance;\\n    uint balanceBefore;\\n    uint len;\\n  }\\n\\n  struct SwapToGivenAmountInputParams {\\n    uint targetAmount;\\n    address[] tokens;\\n    uint indexTargetAsset;\\n    address underlying;\\n    uint[] amounts;\\n    ITetuConverter converter;\\n    ITetuLiquidator liquidator;\\n    uint liquidationThresholdForTargetAsset;\\n    /// @notice Allow to swap more then required (i.e. 1_000 => +1%)\\n    ///         to avoid additional swap if the swap return amount a bit less than we expected\\n    uint overswap;\\n  }\\n\\n  struct SwapToGivenAmountLocal {\\n    uint len;\\n    uint[] availableAmounts;\\n    uint i;\\n  }\\n\\n  struct CloseDebtsForRequiredAmountLocal {\\n    uint len;\\n    address asset;\\n    uint collateral;\\n    uint spentAmountIn;\\n    uint receivedAmount;\\n    uint balance;\\n    uint[] tokensBalancesBefore;\\n\\n    uint totalDebt;\\n    uint totalCollateral;\\n\\n    /// @notice Cost of $1 in terms of the assets, decimals 18\\n    uint[] prices;\\n    /// @notice 10**decimal for the assets\\n    uint[] decs;\\n\\n    uint newBalance;\\n  }\\n  //endregion Data types\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Constants\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice approx one month for average block time 2 sec\\n  uint internal constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\\n  uint internal constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n  uint internal constant DENOMINATOR = 100_000;\\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\\n  uint internal constant PRICE_IMPACT_TOLERANCE = 300;\\n  /// @notice borrow/collateral amount cannot be less than given number of tokens\\n  uint internal constant DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD = 10;\\n  /// @notice Allow to swap more then required (i.e. 1_000 => +1%) inside {swapToGivenAmount}\\n  ///         to avoid additional swap if the swap will return amount a bit less than we expected\\n  uint internal constant OVERSWAP = PRICE_IMPACT_TOLERANCE + _ASSET_LIQUIDATION_SLIPPAGE;\\n  /// @dev Absolute value for any token\\n  uint internal constant DEFAULT_LIQUIDATION_THRESHOLD = 100_000;\\n  /// @notice 1% gap to cover possible liquidation inefficiency\\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\\n  uint internal constant GAP_CONVERSION = 1_000;\\n  //endregion Constants\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Events\\n  /////////////////////////////////////////////////////////////////////\\n  /// @notice A borrow was made\\n  event OpenPosition(\\n    address converter,\\n    address collateralAsset,\\n    uint collateralAmount,\\n    address borrowAsset,\\n    uint borrowedAmount,\\n    address recepient\\n  );\\n\\n  /// @notice Some borrow(s) was/were repaid\\n  event ClosePosition(\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountRepay,\\n    address recepient,\\n    uint returnedAssetAmountOut,\\n    uint returnedBorrowAmountOut\\n  );\\n\\n  /// @notice A liquidation was made\\n  event Liquidation(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amountIn,\\n    uint spentAmountIn,\\n    uint receivedAmountOut\\n  );\\n\\n  event ReturnAssetToConverter(address asset, uint amount);\\n\\n  event FixPriceChanges(uint investedAssetsBefore, uint investedAssetsOut);\\n  //endregion Events\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region View functions\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Get amount of assets that we expect to receive after withdrawing\\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\\n  ///                  one of assets must be {asset_}\\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\\n  function getExpectedWithdrawnAmounts(\\n    uint[] memory reserves_,\\n    uint liquidityAmount_,\\n    uint totalSupply_\\n  ) internal pure returns (\\n    uint[] memory withdrawnAmountsOut\\n  ) {\\n    uint ratio = totalSupply_ == 0\\n      ? 0\\n      : (liquidityAmount_ >= totalSupply_\\n        ? 1e18\\n        : 1e18 * liquidityAmount_ / totalSupply_\\n      );\\n\\n    uint len = reserves_.length;\\n    withdrawnAmountsOut = new uint[](len);\\n\\n    if (ratio != 0) {\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\\n      }\\n    }\\n  }\\n\\n  /// @return prices Asset prices in USD, decimals 18\\n  /// @return decs 10**decimals\\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\\n    uint[] memory prices,\\n    uint[] memory decs\\n  ) {\\n    prices = new uint[](len);\\n    decs = new uint[](len);\\n    {\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\\n    uint len = tokens_.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (tokens_[i] == asset_) {\\n        return i;\\n      }\\n    }\\n    return type(uint).max;\\n  }\\n\\n  /// @notice Get the price ratio of the two given tokens from the oracle.\\n  /// @param converter The Tetu converter.\\n  /// @param tokenA The first token address.\\n  /// @param tokenB The second token address.\\n  /// @return The price ratio of the two tokens.\\n  function getOracleAssetsPrice(ITetuConverter converter, address tokenA, address tokenB) external view returns (uint) {\\n    IPriceOracle oracle = IPriceOracle(IConverterController(converter.controller()).priceOracle());\\n    uint priceA = oracle.getAssetPrice(tokenA);\\n    uint priceB = oracle.getAssetPrice(tokenB);\\n    return priceB * 1e18 / priceA;\\n  }\\n  //endregion View functions\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Borrow and close positions\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\\n  ///         Max possible collateral should be approved before calling of this function.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\\n  /// @param amountIn_ Meaning depends on {entryData_}.\\n  function openPosition(\\n    ITetuConverter tetuConverter_,\\n    bytes memory entryData_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountIn_,\\n    uint thresholdAmountIn_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    return _openPosition(tetuConverter_, entryData_, collateralAsset_, borrowAsset_, amountIn_, thresholdAmountIn_);\\n  }\\n\\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\\n  ///         Max possible collateral should be approved before calling of this function.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\\n  /// @param amountIn_ Meaning depends on {entryData_}.\\n  /// @param thresholdAmountIn_ Min value of amountIn allowed for the second and subsequent conversions.\\n  ///        0 - use default min value\\n  ///        If amountIn becomes too low, no additional borrows are possible, so\\n  ///        the rest amountIn is just added to collateral/borrow amount of previous conversion.\\n  function _openPosition(\\n    ITetuConverter tetuConverter_,\\n    bytes memory entryData_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountIn_,\\n    uint thresholdAmountIn_\\n  ) internal returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    if (thresholdAmountIn_ == 0) {\\n      // zero threshold is not allowed because round-issues are possible, see openPosition.dust test\\n      // we assume here, that it's useless to borrow amount using collateral/borrow amount\\n      // less than given number of tokens (event for BTC)\\n      thresholdAmountIn_ = DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD;\\n    }\\n    if (amountIn_ <= thresholdAmountIn_) {\\n      return (0, 0);\\n    }\\n\\n    OpenPositionLocal memory vars;\\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\\n    vars.entryKind = ConverterEntryKinds.getEntryKind(entryData_);\\n    if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\\n      return openPositionEntryKind1(\\n        tetuConverter_,\\n        entryData_,\\n        collateralAsset_,\\n        borrowAsset_,\\n        amountIn_,\\n        thresholdAmountIn_\\n      );\\n    } else {\\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\\n        entryData_,\\n        collateralAsset_,\\n        amountIn_,\\n        borrowAsset_,\\n        _LOAN_PERIOD_IN_BLOCKS\\n      );\\n\\n      uint len = vars.converters.length;\\n      if (len > 0) {\\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\\n          vars.collateral;\\n          vars.amountToBorrow;\\n          if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\\n            // we have exact amount of total collateral amount\\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\\n              ? amountIn_\\n              : vars.collateralsRequired[i];\\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\\n              ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\\n              : vars.amountsToBorrow[i];\\n            amountIn_ -= vars.collateral;\\n          } else {\\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\\n            // we have exact amount of total amount-to-borrow\\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\\n              ? amountIn_\\n              : vars.amountsToBorrow[i];\\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\\n              ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\\n              : vars.collateralsRequired[i];\\n            amountIn_ -= vars.amountToBorrow;\\n          }\\n\\n          if (amountIn_ < thresholdAmountIn_ && amountIn_ != 0) {\\n            // dust amount is left, just leave it unused\\n            // we cannot add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\\n            amountIn_ = 0;\\n          }\\n\\n          if (vars.amountToBorrow != 0) {\\n            borrowedAmountOut += tetuConverter_.borrow(\\n              vars.converters[i],\\n              collateralAsset_,\\n              vars.collateral,\\n              borrowAsset_,\\n              vars.amountToBorrow,\\n              address(this)\\n            );\\n            collateralAmountOut += vars.collateral;\\n            emit OpenPosition(\\n              vars.converters[i],\\n              collateralAsset_,\\n              vars.collateral,\\n              borrowAsset_,\\n              vars.amountToBorrow,\\n              address(this)\\n            );\\n          }\\n\\n          if (amountIn_ == 0) break;\\n        }\\n      }\\n\\n      return (collateralAmountOut, borrowedAmountOut);\\n    }\\n  }\\n\\n  /// @notice Open position using entry kind 1 - split provided amount on two parts according provided proportions\\n  /// @param amountIn_ Amount of collateral to be divided on parts. We assume {amountIn_} > 0\\n  /// @param collateralThreshold_ Min allowed collateral amount to be used for new borrow, > 0\\n  /// @return collateralAmountOut Total collateral used to borrow {borrowedAmountOut}\\n  /// @return borrowedAmountOut Total borrowed amount\\n  function openPositionEntryKind1(\\n    ITetuConverter tetuConverter_,\\n    bytes memory entryData_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountIn_,\\n    uint collateralThreshold_\\n  ) internal returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    OpenPositionEntryKind1Local memory vars;\\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\\n      entryData_,\\n      collateralAsset_,\\n      amountIn_,\\n      borrowAsset_,\\n      _LOAN_PERIOD_IN_BLOCKS\\n    );\\n\\n    uint len = vars.converters.length;\\n    if (len > 0) {\\n      // we should split amountIn on two amounts with proportions x:y\\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\\n      // calculate prices conversion ratio using price oracle, decimals 18\\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\\n\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\\n        // and give us required proportions in result\\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\\n        // C1 is collateral amount left untouched (x)\\n        // C2 is collateral amount converted to B2 (y)\\n        // but if lending platform doesn't have enough liquidity\\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\\n        vars.c1 = x * vars.c3 / y;\\n        vars.ratio = (vars.collateralsRequired[i] + vars.c1) > amountIn_\\n          ? 1e18 * amountIn_ / (vars.collateralsRequired[i] + vars.c1)\\n          : 1e18;\\n\\n        vars.collateral = vars.collateralsRequired[i] * vars.ratio / 1e18;\\n        vars.amountToBorrow = vars.amountsToBorrow[i] * vars.ratio / 1e18;\\n\\n        // skip any attempts to borrow zero amount or use too little collateral\\n        if (vars.collateral < collateralThreshold_ || vars.amountToBorrow == 0) {\\n          if (vars.collateralsRequired[i] + vars.c1 + collateralThreshold_ > amountIn_) {\\n            // The lending platform has enough resources to make the borrow but amount of the borrow is too low\\n            // Skip the borrow, leave leftover of collateral untouched\\n            break;\\n          } else {\\n            // The lending platform doesn't have enough resources to make the borrow.\\n            // We should try to make borrow on the next platform (if any)\\n            continue;\\n          }\\n        }\\n\\n        require(\\n          tetuConverter_.borrow(\\n            vars.converters[i],\\n            collateralAsset_,\\n            vars.collateral,\\n            borrowAsset_,\\n            vars.amountToBorrow,\\n            address(this)\\n          ) == vars.amountToBorrow,\\n          StrategyLib.WRONG_VALUE\\n        );\\n        emit OpenPosition(\\n          vars.converters[i],\\n          collateralAsset_,\\n          vars.collateral,\\n          borrowAsset_,\\n          vars.amountToBorrow,\\n          address(this)\\n        );\\n\\n        borrowedAmountOut += vars.amountToBorrow;\\n        collateralAmountOut += vars.collateral;\\n\\n        // calculate amount to be borrowed in the next converter\\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\\n        vars.c1 = x * vars.c3 / y;\\n        amountIn_ = (amountIn_ > vars.c1 + vars.collateral)\\n          ? amountIn_ - (vars.c1 + vars.collateral)\\n          : 0;\\n\\n        // protection against dust amounts, see \\\"openPosition.dust\\\", just leave dust amount unused\\n        // we CAN NOT add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\\n        // we assume here, that collateralThreshold_ != 0, so check amountIn_ != 0 is not required\\n        if (amountIn_ < collateralThreshold_) break;\\n      }\\n    }\\n\\n    return (collateralAmountOut, borrowedAmountOut);\\n  }\\n\\n  /// @notice Get ratio18 = collateral / borrow\\n  function _getCollateralToBorrowRatio(\\n    ITetuConverter tetuConverter_,\\n    address collateralAsset_,\\n    address borrowAsset_\\n  ) internal view returns (uint){\\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle());\\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\\n    return 1e18 * priceBorrow * 10 ** IERC20Metadata(collateralAsset_).decimals()\\n    / priceCollateral / 10 ** IERC20Metadata(borrowAsset_).decimals();\\n  }\\n\\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\\n  ///         It doesn't repay more than the actual amount of the debt, so it can use less amount than {amountToRepay}\\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\\n  /// @return repaidAmountOut Amount that was actually repaid\\n  function _closePosition(\\n    ITetuConverter converter_,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountToRepay\\n  ) internal returns (\\n    uint returnedAssetAmountOut,\\n    uint repaidAmountOut\\n  ) {\\n\\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\\n\\n    // We shouldn't try to pay more than we actually need to repay\\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\\n    // Let's limit amountToRepay by needToRepay-amount\\n    (uint needToRepay,) = converter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\\n\\n    return _closePositionExact(converter_, collateralAsset, borrowAsset, amountRepay, balanceBefore);\\n  }\\n\\n  /// @notice Close the given position, pay {amountRepay} exactly and ensure that all amount was accepted,\\n  /// @param amountRepay Amount to repay in terms of {borrowAsset}\\n  /// @param balanceBorrowAsset Current balance of the borrow asset\\n  /// @return collateralOut Amount of collateral received back after repaying\\n  /// @return repaidAmountOut Amount that was actually repaid\\n  function _closePositionExact(\\n    ITetuConverter converter_,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountRepay,\\n    uint balanceBorrowAsset\\n  ) internal returns (\\n    uint collateralOut,\\n    uint repaidAmountOut\\n  ) {\\n    // Make full/partial repayment\\n    IERC20(borrowAsset).safeTransfer(address(converter_), amountRepay);\\n\\n    uint notUsedAmount;\\n    (collateralOut, notUsedAmount,,) = converter_.repay(collateralAsset, borrowAsset, amountRepay, address(this));\\n\\n    emit ClosePosition(collateralAsset, borrowAsset, amountRepay, address(this), collateralOut, notUsedAmount);\\n    uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\\n\\n    // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (debt-gap)\\n    repaidAmountOut = balanceBorrowAsset > balanceAfter\\n      ? balanceBorrowAsset - balanceAfter\\n      : 0;\\n\\n    require(notUsedAmount == 0, StrategyLib.WRONG_VALUE);\\n  }\\n\\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\\n  /// @return repaidAmountOut Amount that was actually repaid\\n  function closePosition(\\n    ITetuConverter tetuConverter_,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountToRepay\\n  ) external returns (\\n    uint returnedAssetAmountOut,\\n    uint repaidAmountOut\\n  ) {\\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\\n  }\\n  //endregion Borrow and close positions\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Liquidation\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\n  function liquidate(\\n    ITetuConverter converter,\\n    ITetuLiquidator liquidator_,\\n    address tokenIn_,\\n    address tokenOut_,\\n    uint amountIn_,\\n    uint slippage_,\\n    uint liquidationThresholdTokenOut_,\\n    bool skipValidation\\n  ) external returns (\\n    uint spentAmountIn,\\n    uint receivedAmountOut\\n  ) {\\n    return _liquidate(converter, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdTokenOut_, skipValidation);\\n  }\\n\\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator (== 0 | amountIn_)\\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\n  function _liquidate(\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator_,\\n    address tokenIn_,\\n    address tokenOut_,\\n    uint amountIn_,\\n    uint slippage_,\\n    uint liquidationThresholdForTokenOut_,\\n    bool skipValidation\\n  ) internal returns (\\n    uint spentAmountIn,\\n    uint receivedAmountOut\\n  ) {\\n    if (amountIn_ == 0) {\\n      return (0, 0);\\n    }\\n\\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\\n\\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\\n\\n    // calculate balance in out value for check threshold\\n    uint amountOut = liquidator_.getPriceForRoute(route, amountIn_);\\n\\n    // if the expected value is higher than threshold distribute to destinations\\n    return amountOut > liquidationThresholdForTokenOut_\\n      ? (amountIn_, _liquidateWithRoute(converter_, route, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, skipValidation))\\n      : (0, 0);\\n  }\\n\\n  /// @notice Make liquidation using given route and check correctness using TetuConverter's price oracle\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\n  function _liquidateWithRoute(\\n    ITetuConverter converter_,\\n    ITetuLiquidator.PoolData[] memory route,\\n    ITetuLiquidator liquidator_,\\n    address tokenIn_,\\n    address tokenOut_,\\n    uint amountIn_,\\n    uint slippage_,\\n    bool skipValidation\\n  ) internal returns (\\n    uint receivedAmountOut\\n  ) {\\n    // we need to approve each time, liquidator address can be changed in controller\\n    AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\\n\\n    uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\\n    liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\\n    uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\\n\\n    require(balanceAfter > balanceBefore, AppErrors.BALANCE_DECREASE);\\n    receivedAmountOut = balanceAfter - balanceBefore;\\n\\n    // Oracle in TetuConverter \\\"knows\\\" only limited number of the assets\\n    // It may not know prices for reward assets, so for rewards this validation should be skipped to avoid TC-4 error\\n    require(skipValidation || converter_.isConversionValid(tokenIn_, amountIn_, tokenOut_, receivedAmountOut, slippage_), AppErrors.PRICE_IMPACT);\\n    emit Liquidation(tokenIn_, tokenOut_, amountIn_, amountIn_, receivedAmountOut);\\n  }\\n  //endregion Liquidation\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region requirePayAmountBack\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @param amount_ Amount of the main asset requested by converter\\n  /// @param indexTheAsset Index of the asset required by converter in the {tokens}\\n  /// @param asset Main asset or underlying (it can be different from tokens[indexTheAsset])\\n  /// @return amountOut Amount of the main asset sent to converter\\n  function swapToGivenAmountAndSendToConverter(\\n    uint amount_,\\n    uint indexTheAsset,\\n    address[] memory tokens,\\n    address converter,\\n    address controller,\\n    address asset,\\n    mapping(address => uint) storage liquidationThresholds\\n  ) external returns (\\n    uint amountOut\\n  ) {\\n    // msg.sender == converter; we assume here that it was checked before the call of this function\\n    address theAsset = tokens[indexTheAsset];\\n\\n    amountOut = IERC20(theAsset).balanceOf(address(this));\\n\\n    // convert withdrawn assets to the target asset if not enough\\n    if (amountOut < amount_) {\\n      ConverterStrategyBaseLib.swapToGivenAmount(\\n        amount_ - amountOut,\\n        tokens,\\n        indexTheAsset,\\n        asset, // underlying === main asset\\n        ITetuConverter(converter),\\n        ITetuLiquidator(IController(controller).liquidator()),\\n        liquidationThresholds[theAsset],\\n        OVERSWAP\\n      );\\n      amountOut = IERC20(theAsset).balanceOf(address(this));\\n    }\\n\\n    // we should send the asset as is even if it is lower than requested\\n    // but shouldn't sent more amount than requested\\n    amountOut = Math.min(amount_, amountOut);\\n    if (amountOut != 0) {\\n      IERC20(theAsset).safeTransfer(converter, amountOut);\\n    }\\n\\n    // There are two cases of calling requirePayAmountBack by converter:\\n    // 1) close a borrow: we will receive collateral back and amount of investedAssets almost won't change\\n    // 2) rebalancing: we have real loss, it will be taken into account at next hard work\\n    emit ReturnAssetToConverter(theAsset, amountOut);\\n\\n    // let's leave any leftovers un-invested, they will be reinvested at next hardwork\\n  }\\n\\n  /// @notice Swap available amounts of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\\n  /// @param targetAmount_ Required amount of tokens[indexTheAsset_] that should be received by swap(s)\\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\\n  /// @param indexTargetAsset_ Index of target asset in tokens_ array\\n  /// @param underlying_ Index of underlying\\n  /// @param liquidationThresholdForTargetAsset_ Liquidation thresholds for the target asset\\n  /// @param overswap_ Allow to swap more then required (i.e. 1_000 => +1%)\\n  ///                  to avoid additional swap if the swap return amount a bit less than we expected\\n  /// @return spentAmounts Any amounts spent during the swaps\\n  function swapToGivenAmount(\\n    uint targetAmount_,\\n    address[] memory tokens_,\\n    uint indexTargetAsset_,\\n    address underlying_,\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator_,\\n    uint liquidationThresholdForTargetAsset_,\\n    uint overswap_\\n  ) internal returns (\\n    uint[] memory spentAmounts,\\n    uint[] memory receivedAmounts\\n  ) {\\n    SwapToGivenAmountLocal memory v;\\n    v.len = tokens_.length;\\n\\n    v.availableAmounts = new uint[](v.len);\\n    for (; v.i < v.len; v.i = AppLib.uncheckedInc(v.i)) {\\n      v.availableAmounts[v.i] = IERC20(tokens_[v.i]).balanceOf(address(this));\\n    }\\n\\n    (spentAmounts, receivedAmounts) = _swapToGivenAmount(\\n      SwapToGivenAmountInputParams({\\n        targetAmount: targetAmount_,\\n        tokens: tokens_,\\n        indexTargetAsset: indexTargetAsset_,\\n        underlying: underlying_,\\n        amounts: v.availableAmounts,\\n        converter: converter_,\\n        liquidator: liquidator_,\\n        liquidationThresholdForTargetAsset: Math.max(liquidationThresholdForTargetAsset_, DEFAULT_LIQUIDATION_THRESHOLD),\\n        overswap: overswap_\\n      })\\n    );\\n  }\\n\\n  /// @notice Swap available {amounts_} of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\\n  /// @return spentAmounts Any amounts spent during the swaps\\n  /// @return receivedAmounts Any amounts received during the swaps\\n  function _swapToGivenAmount(SwapToGivenAmountInputParams memory p) internal returns (\\n    uint[] memory spentAmounts,\\n    uint[] memory receivedAmounts\\n  ) {\\n    CalcInvestedAssetsLocal memory v;\\n    v.len = p.tokens.length;\\n    receivedAmounts = new uint[](v.len);\\n    spentAmounts = new uint[](v.len);\\n\\n    // calculate prices, decimals\\n    (v.prices, v.decs) = _getPricesAndDecs(\\n      IPriceOracle(IConverterController(p.converter.controller()).priceOracle()),\\n      p.tokens,\\n      v.len\\n    );\\n\\n    // we need to swap other assets to the asset\\n    // at first we should swap NOT underlying.\\n    // if it would be not enough, we can swap underlying too.\\n\\n    // swap NOT underlying, initialize {indexUnderlying}\\n    uint indexUnderlying;\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (p.underlying == p.tokens[i]) {\\n        indexUnderlying = i;\\n        continue;\\n      }\\n      if (p.indexTargetAsset == i) continue;\\n\\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, i);\\n      spentAmounts[i] += spent;\\n      receivedAmounts[p.indexTargetAsset] += received;\\n\\n      if (receivedAmounts[p.indexTargetAsset] >= p.targetAmount) break;\\n    }\\n\\n    // swap underlying\\n    if (receivedAmounts[p.indexTargetAsset] < p.targetAmount && p.indexTargetAsset != indexUnderlying) {\\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, indexUnderlying);\\n      spentAmounts[indexUnderlying] += spent;\\n      receivedAmounts[p.indexTargetAsset] += received;\\n    }\\n  }\\n\\n  /// @notice Swap a part of amount of asset {tokens[indexTokenIn]} to {targetAsset} to get {targetAmount} in result\\n  /// @param receivedTargetAmount Already received amount of {targetAsset} in previous swaps\\n  /// @param indexTokenIn Index of the tokenIn in p.tokens\\n  function _swapToGetAmount(\\n    uint receivedTargetAmount,\\n    SwapToGivenAmountInputParams memory p,\\n    CalcInvestedAssetsLocal memory v,\\n    uint indexTokenIn\\n  ) internal returns (\\n    uint amountSpent,\\n    uint amountReceived\\n  ) {\\n    if (p.amounts[indexTokenIn] != 0) {\\n      // we assume here, that p.targetAmount > receivedTargetAmount, see _swapToGivenAmount implementation\\n\\n      // calculate amount that should be swapped\\n      // {overswap} allows to swap a bit more\\n      // to avoid additional swaps if the swap will give us a bit less amount than expected\\n      uint amountIn = (\\n        (p.targetAmount - receivedTargetAmount)\\n        * v.prices[p.indexTargetAsset] * v.decs[indexTokenIn]\\n        / v.prices[indexTokenIn] / v.decs[p.indexTargetAsset]\\n      ) * (p.overswap + DENOMINATOR) / DENOMINATOR;\\n\\n      (amountSpent, amountReceived) = _liquidate(\\n        p.converter,\\n        p.liquidator,\\n        p.tokens[indexTokenIn],\\n        p.tokens[p.indexTargetAsset],\\n        Math.min(amountIn, p.amounts[indexTokenIn]),\\n        _ASSET_LIQUIDATION_SLIPPAGE,\\n        p.liquidationThresholdForTargetAsset,\\n        false\\n      );\\n    }\\n\\n    return (amountSpent, amountReceived);\\n  }\\n  //endregion requirePayAmountBack\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Recycle rewards\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Recycle the amounts: split each amount on tree parts: performance+insurance (P), forwarder (F), compound (C)\\n  ///         Liquidate P+C, send F to the forwarder.\\n  /// We have two kinds of rewards:\\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\\n  /// 2) any other rewards\\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\\n  ///   Compound-part of Rewards-2 can be liquidated\\n  ///   Compound part of Rewards-1 should be just left on the balance\\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\\n  ///   Performance amounts are liquidated, result amount of underlying is returned in {amountToPerformanceAndInsurance}\\n  /// @param asset Underlying asset\\n  /// @param compoundRatio Compound ration in the range [0...COMPOUND_DENOMINATOR]\\n  /// @param tokens tokens received from {_depositorPoolAssets}\\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\\n  /// @param rewardAmounts Amounts of {rewardTokens_}; we assume, there are no zero amounts here\\n  /// @param liquidationThresholds Liquidation thresholds for rewards tokens\\n  /// @param performanceFee Performance fee in the range [0...FEE_DENOMINATOR]\\n  /// @return amountsToForward Amounts of {rewardTokens} to be sent to forwarder, zero amounts are allowed here\\n  /// @return amountToPerformanceAndInsurance Amount of underlying to be sent to performance receiver and insurance\\n  function recycle(\\n    ITetuConverter converter_,\\n    address asset,\\n    uint compoundRatio,\\n    address[] memory tokens,\\n    ITetuLiquidator liquidator,\\n    mapping(address => uint) storage liquidationThresholds,\\n    address[] memory rewardTokens,\\n    uint[] memory rewardAmounts,\\n    uint performanceFee\\n  ) external returns (\\n    uint[] memory amountsToForward,\\n    uint amountToPerformanceAndInsurance\\n  ) {\\n    RecycleLocalParams memory p;\\n\\n    p.len = rewardTokens.length;\\n    require(p.len == rewardAmounts.length, AppErrors.WRONG_LENGTHS);\\n\\n    p.liquidationThresholdAsset = Math.max(liquidationThresholds[asset], DEFAULT_LIQUIDATION_THRESHOLD);\\n\\n    amountsToForward = new uint[](p.len);\\n\\n    // rewardAmounts => P + F + C, where P - performance + insurance, F - forwarder, C - compound\\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\\n      p.amountFC = rewardAmounts[i] * (COMPOUND_DENOMINATOR - performanceFee) / COMPOUND_DENOMINATOR;\\n      p.amountC = p.amountFC * compoundRatio / COMPOUND_DENOMINATOR;\\n      p.amountP = rewardAmounts[i] - p.amountFC;\\n      p.rewardToken = rewardTokens[i];\\n      p.amountCP = p.amountC + p.amountP;\\n\\n      if (p.amountCP > 0) {\\n        if (ConverterStrategyBaseLib.getAssetIndex(tokens, p.rewardToken) != type(uint).max) {\\n          if (p.rewardToken == asset) {\\n            // This is underlying, liquidation of compound part is not allowed; just keep on the balance, should be handled later\\n            amountToPerformanceAndInsurance += p.amountP;\\n          } else {\\n            // This is secondary asset, Liquidation of compound part is not allowed, we should liquidate performance part only\\n            if (p.amountP < Math.max(liquidationThresholds[p.rewardToken], DEFAULT_LIQUIDATION_THRESHOLD)) {\\n              // performance amount is too small, liquidation is not allowed, we just keep that dust tokens on balance forever\\n            } else {\\n              (, p.receivedAmountOut) = _liquidate(\\n                converter_,\\n                liquidator,\\n                p.rewardToken,\\n                asset,\\n                p.amountP,\\n                _REWARD_LIQUIDATION_SLIPPAGE,\\n                p.liquidationThresholdAsset,\\n                false // use conversion validation for these rewards\\n              );\\n              amountToPerformanceAndInsurance += p.receivedAmountOut;\\n            }\\n          }\\n        } else {\\n          if (p.amountCP < Math.max(liquidationThresholds[p.rewardToken], DEFAULT_LIQUIDATION_THRESHOLD)) {\\n            // amount is too small, liquidation is not allowed, we just keep that dust tokens on balance forever\\n          } else {\\n            // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\\n            // We assume here, that {token} cannot be equal to {_asset}\\n            // because the {_asset} is always included to the list of depositor's assets\\n            (, p.receivedAmountOut) = _liquidate(\\n              converter_,\\n              liquidator,\\n              p.rewardToken,\\n              asset,\\n              p.amountCP,\\n              _REWARD_LIQUIDATION_SLIPPAGE,\\n              p.liquidationThresholdAsset,\\n              true // skip conversion validation for rewards becase we can have arbitrary assets here\\n            );\\n\\n            amountToPerformanceAndInsurance += p.receivedAmountOut * (rewardAmounts[i] - p.amountFC) / p.amountCP;\\n          }\\n        }\\n      }\\n      amountsToForward[i] = p.amountFC - p.amountC;\\n    }\\n    return (amountsToForward, amountToPerformanceAndInsurance);\\n  }\\n  //endregion Recycle rewards\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region calcInvestedAssets\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\n  /// @return amountOut Invested asset amount under control (in terms of {asset})\\n  function calcInvestedAssets(\\n    address[] memory tokens,\\n    uint[] memory depositorQuoteExitAmountsOut,\\n    uint indexAsset,\\n    ITetuConverter converter_\\n  ) external returns (\\n    uint amountOut\\n  ) {\\n    CalcInvestedAssetsLocal memory v;\\n    v.len = tokens.length;\\n\\n    // calculate prices, decimals\\n    (v.prices, v.decs) = _getPricesAndDecs(\\n      IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\\n      tokens,\\n      v.len\\n    );\\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) {\\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\\n        amountOut += depositorQuoteExitAmountsOut[i];\\n      } else {\\n        // available amount to repay\\n        uint toRepay = IERC20(tokens[i]).balanceOf(address(this)) + depositorQuoteExitAmountsOut[i];\\n\\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(\\n          address(this),\\n          tokens[indexAsset],\\n          tokens[i],\\n          // investedAssets is calculated using exact debts, debt-gaps are not taken into account\\n          false\\n        );\\n        amountOut += collateral;\\n\\n        if (toRepay >= toPay) {\\n          amountOut += (toRepay - toPay) * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\\n        } else {\\n          // there is not enough amount to pay the debt\\n          // let's register a debt and try to resolve it later below\\n          if (v.debts.length == 0) {\\n            // lazy initialization\\n            v.debts = new uint[](v.len);\\n          }\\n\\n          // to pay the following amount we need to swap some other asset at first\\n          v.debts[i] = toPay - toRepay;\\n        }\\n      }\\n    }\\n    if (v.debts.length == v.len) {\\n      // we assume here, that it would be always profitable to save collateral\\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n        if (v.debts[i] == 0) continue;\\n\\n        // estimatedAssets should be reduced on the debt-value\\n        // this estimation is approx and do not count price impact on the liquidation\\n        // we will able to count the real output only after withdraw process\\n        uint debtInAsset = v.debts[i] * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\\n        if (debtInAsset > amountOut) {\\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\\n          amountOut = 0;\\n        } else {\\n          amountOut -= debtInAsset;\\n        }\\n      }\\n    }\\n\\n    return amountOut;\\n  }\\n  //endregion calcInvestedAssets\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region getExpectedAmountMainAsset\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Calculate expected amount of the main asset after withdrawing\\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\\n  /// @return amountsOut Expected amounts of the main asset received after conversion withdrawnAmounts+amountsToConvert\\n  function getExpectedAmountMainAsset(\\n    address[] memory tokens,\\n    uint indexAsset,\\n    ITetuConverter converter,\\n    uint[] memory withdrawnAmounts_,\\n    uint[] memory amountsToConvert_\\n  ) internal returns (\\n    uint[] memory amountsOut\\n  ) {\\n    uint len = tokens.length;\\n    amountsOut = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) {\\n        amountsOut[i] = withdrawnAmounts_[i];\\n      } else {\\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\\n        if (amount != 0) {\\n          (amountsOut[i],) = converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\\n        }\\n      }\\n    }\\n\\n    return amountsOut;\\n  }\\n  //endregion getExpectedAmountMainAsset\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Reduce size of ConverterStrategyBase\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Make borrow and save amounts of tokens available for deposit to tokenAmounts\\n  /// @param thresholdMainAsset_ Min allowed value of collateral in terms of main asset, 0 - use default min value\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\n  /// @param collaterals_ Amounts of main asset that can be used as collateral to borrow {tokens_}\\n  /// @param thresholdMainAsset_ Value of liquidation threshold for the main (collateral) asset\\n  /// @return tokenAmountsOut Amounts available for deposit\\n  function getTokenAmounts(\\n    ITetuConverter tetuConverter_,\\n    address[] memory tokens_,\\n    uint indexAsset_,\\n    uint[] memory collaterals_,\\n    uint thresholdMainAsset_\\n  ) external returns (\\n    uint[] memory tokenAmountsOut\\n  ) {\\n    // content of tokenAmounts will be modified in place\\n    uint len = tokens_.length;\\n    tokenAmountsOut = new uint[](len);\\n\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i != indexAsset_) {\\n        if (collaterals_[i] != 0) {\\n          AppLib.approveIfNeeded(tokens_[indexAsset_], collaterals_[i], address(tetuConverter_));\\n          _openPosition(\\n            tetuConverter_,\\n            \\\"\\\", // entry kind = 0: fixed collateral amount, max possible borrow amount\\n            tokens_[indexAsset_],\\n            tokens_[i],\\n            collaterals_[i],\\n            Math.max(thresholdMainAsset_, DEFAULT_LIQUIDATION_THRESHOLD)\\n          );\\n\\n          // zero borrowed amount is possible here (conversion is not available)\\n          // if it's not suitable for depositor, the depositor should check zero amount in other places\\n        }\\n        tokenAmountsOut[i] = IERC20(tokens_[i]).balanceOf(address(this));\\n      }\\n    }\\n\\n    tokenAmountsOut[indexAsset_] = Math.min(\\n      collaterals_[indexAsset_],\\n      IERC20(tokens_[indexAsset_]).balanceOf(address(this))\\n    );\\n  }\\n\\n  /// @notice Convert {amountsToConvert_} to the main {asset}\\n  ///         Swap leftovers (if any) to the main asset.\\n  ///         If result amount is less than expected, try to close any other available debts (1 repay per block only)\\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\n  /// @param requestedAmount Amount to be withdrawn in terms of the asset in addition to the exist balance.\\n  ///        Max uint means attempt to withdraw all possible invested assets.\\n  /// @param amountsToConvert_ Amounts available for conversion after withdrawing from the pool\\n  /// @param expectedMainAssetAmounts Amounts of main asset that we expect to receive after conversion amountsToConvert_\\n  /// @return expectedAmount Expected total amount of main asset after all conversions, swaps and repays\\n  function makeRequestedAmount(\\n    address[] memory tokens_,\\n    uint indexAsset_,\\n    uint[] memory amountsToConvert_,\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator_,\\n    uint requestedAmount,\\n    uint[] memory expectedMainAssetAmounts,\\n    mapping(address => uint) storage liquidationThresholds\\n  ) external returns (uint expectedAmount) {\\n    // get the total expected amount\\n    for (uint i; i < tokens_.length; i = AppLib.uncheckedInc(i)) {\\n      expectedAmount += expectedMainAssetAmounts[i];\\n    }\\n\\n    // we cannot repay a debt twice\\n    // suppose, we have usdt = 1 and we need to convert it to usdc, then get additional usdt=10 and make second repay\\n    // But: we cannot make repay(1) and than repay(10). We MUST make single repay(11)\\n\\n    if (requestedAmount != type(uint).max\\n      && expectedAmount > requestedAmount * (GAP_CONVERSION + DENOMINATOR) / DENOMINATOR\\n    ) {\\n      // amountsToConvert_ are enough to get requestedAmount\\n      _convertAfterWithdraw(\\n        converter_,\\n        liquidator_,\\n        indexAsset_,\\n        liquidationThresholds[tokens_[indexAsset_]],\\n        tokens_,\\n        amountsToConvert_\\n      );\\n    } else {\\n      // amountsToConvert_ are NOT enough to get requestedAmount\\n      // We are allowed to make only one repay per block, so, we shouldn't try to convert amountsToConvert_\\n      // We should try to close the exist debts instead:\\n      //    convert a part of main assets to get amount of secondary assets required to repay the debts\\n      // and only then make conversion.\\n      expectedAmount = _closePositionsToGetAmount(\\n        converter_,\\n        liquidator_,\\n        indexAsset_,\\n        liquidationThresholds,\\n        requestedAmount,\\n        tokens_\\n      ) + expectedMainAssetAmounts[indexAsset_];\\n    }\\n\\n    return expectedAmount;\\n  }\\n  //endregion Reduce size of ConverterStrategyBase\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Withdraw helpers\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\\n  /// @param amountsToConvert Amounts of {tokens} to be converted, they are located on the balance before withdraw\\n  /// @param withdrawnAmounts Amounts of {tokens} that were withdrew from the pool\\n  function postWithdrawActions(\\n    ITetuConverter converter,\\n    address[] memory tokens,\\n    uint indexAsset,\\n\\n    uint[] memory reservesBeforeWithdraw,\\n    uint liquidityAmountWithdrew,\\n    uint totalSupplyBeforeWithdraw,\\n\\n    uint[] memory amountsToConvert,\\n    uint[] memory withdrawnAmounts\\n  ) external returns (\\n    uint[] memory expectedMainAssetAmounts,\\n    uint[] memory _amountsToConvert\\n  ) {\\n    // estimate expected amount of assets to be withdrawn\\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\\n      reservesBeforeWithdraw,\\n      liquidityAmountWithdrew,\\n      totalSupplyBeforeWithdraw\\n    );\\n\\n    // from received amounts after withdraw calculate how much we receive from converter for them in terms of the underlying asset\\n    expectedMainAssetAmounts = getExpectedAmountMainAsset(\\n      tokens,\\n      indexAsset,\\n      converter,\\n      expectedWithdrawAmounts,\\n      amountsToConvert\\n    );\\n\\n    uint len = tokens.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      amountsToConvert[i] += withdrawnAmounts[i];\\n    }\\n\\n    return (expectedMainAssetAmounts, amountsToConvert);\\n  }\\n\\n  /// @notice return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\\n  function postWithdrawActionsEmpty(\\n    ITetuConverter converter,\\n    address[] memory tokens,\\n    uint indexAsset,\\n    uint[] memory amountsToConvert_\\n  ) external returns (\\n    uint[] memory expectedAmountsMainAsset\\n  ) {\\n    expectedAmountsMainAsset = getExpectedAmountMainAsset(\\n      tokens,\\n      indexAsset,\\n      converter,\\n      // there are no withdrawn amounts\\n      new uint[](tokens.length), // array with all zero values\\n      amountsToConvert_\\n    );\\n  }\\n\\n  //endregion Withdraw helpers\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region convertAfterWithdraw\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Convert {amountsToConvert_} (available on balance) to the main asset\\n  ///         Swap leftovers if any.\\n  ///         Result amount can be less than requested one, we don't try to close any other debts here\\n  /// @param indexAsset Index of the main asset in {tokens}\\n  /// @param liquidationThreshold Min allowed amount of main asset to be liquidated in {liquidator}\\n  /// @param tokens Tokens received from {_depositorPoolAssets}\\n  /// @param amountsToConvert Amounts to convert, the order of asset is same as in {tokens}\\n  /// @return collateralOut Total amount of main asset returned after closing positions\\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\\n  function _convertAfterWithdraw(\\n    ITetuConverter tetuConverter,\\n    ITetuLiquidator liquidator,\\n    uint indexAsset,\\n    uint liquidationThreshold,\\n    address[] memory tokens,\\n    uint[] memory amountsToConvert\\n  ) internal returns (\\n    uint collateralOut,\\n    uint[] memory repaidAmountsOut\\n  ) {\\n    ConvertAfterWithdrawLocal memory v;\\n    v.asset = tokens[indexAsset];\\n    v.balanceBefore = IERC20(v.asset).balanceOf(address(this));\\n    v.len = tokens.length;\\n\\n    // Close positions to convert all required amountsToConvert\\n    repaidAmountsOut = new uint[](tokens.length);\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset || amountsToConvert[i] == 0) continue;\\n      (, repaidAmountsOut[i]) = _closePosition(tetuConverter, v.asset, tokens[i], amountsToConvert[i]);\\n    }\\n\\n    // Manually swap remain leftovers\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset || amountsToConvert[i] == 0) continue;\\n      if (amountsToConvert[i] > repaidAmountsOut[i]) {\\n        (v.spent, v.received) = _liquidate(\\n          tetuConverter,\\n          liquidator,\\n          tokens[i],\\n          v.asset,\\n          amountsToConvert[i] - repaidAmountsOut[i],\\n          _ASSET_LIQUIDATION_SLIPPAGE,\\n          liquidationThreshold,\\n          false\\n        );\\n        collateralOut += v.received;\\n        repaidAmountsOut[i] += v.spent;\\n      }\\n    }\\n\\n    // Calculate amount of received collateral\\n    v.balance = IERC20(v.asset).balanceOf(address(this));\\n    collateralOut = v.balance > v.balanceBefore\\n      ? v.balance - v.balanceBefore\\n      : 0;\\n\\n    return (collateralOut, repaidAmountsOut);\\n  }\\n\\n  /// @notice Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\\n  /// @dev We assume here that this function is called before closing any positions in the current block\\n  /// @param liquidationThresholds Min allowed amounts-out for liquidations\\n  /// @param requestedAmount Requested amount of main asset that should be added to the current balance\\n  /// @return expectedAmount Main asset amount expected to be received on balance after all conversions and swaps\\n  function closePositionsToGetAmount(\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator,\\n    uint indexAsset,\\n    mapping(address => uint) storage liquidationThresholds,\\n    uint requestedAmount,\\n    address[] memory tokens\\n  ) external returns (\\n    uint expectedAmount\\n  ) {\\n    return _closePositionsToGetAmount(\\n      converter_,\\n      liquidator,\\n      indexAsset,\\n      liquidationThresholds,\\n      requestedAmount,\\n      tokens\\n    );\\n  }\\n\\n  function _closePositionsToGetAmount(\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator,\\n    uint indexAsset,\\n    mapping(address => uint) storage liquidationThresholds,\\n    uint requestedAmount,\\n    address[] memory tokens\\n  ) internal returns (\\n    uint expectedAmount\\n  ) {\\n    if (requestedAmount != 0) {\\n      CloseDebtsForRequiredAmountLocal memory v;\\n      v.asset = tokens[indexAsset];\\n      v.len = tokens.length;\\n      v.balance = IERC20(v.asset).balanceOf(address(this));\\n\\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n        if (i == indexAsset) continue;\\n\\n        // we need to increase balance on the following amount: requestedAmount - v.balance;\\n        // we have following borrow: amount-to-pay and corresponded collateral\\n        (v.totalDebt, v.totalCollateral) = converter_.getDebtAmountCurrent(address(this), v.asset, tokens[i], true);\\n\\n        uint tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\\n\\n        if (v.totalDebt != 0 || tokenBalance != 0) {\\n          //lazy initialization of the prices and decs\\n          if (v.prices.length == 0) {\\n            (v.prices, v.decs) = _getPricesAndDecs(\\n              IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\\n              tokens,\\n              v.len\\n            );\\n          }\\n\\n          // repay the debt if any\\n          if (v.totalDebt != 0) {\\n            // what amount of main asset we should sell to pay the debt\\n            uint toSell = _getAmountToSell(\\n              requestedAmount,\\n              v.totalDebt,\\n              v.totalCollateral,\\n              v.prices,\\n              v.decs,\\n              indexAsset,\\n              i,\\n              tokenBalance\\n            );\\n\\n            // convert {toSell} amount of main asset to tokens[i]\\n            if (toSell != 0 && v.balance != 0) {\\n              toSell = Math.min(toSell, v.balance);\\n              (toSell,) = _liquidate(\\n                converter_,\\n                liquidator,\\n                v.asset,\\n                tokens[i],\\n                toSell,\\n                _ASSET_LIQUIDATION_SLIPPAGE,\\n                liquidationThresholds[tokens[i]],\\n                false\\n              );\\n              tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\\n            }\\n\\n            // sell {toSell}, repay the debt, return collateral back; we should receive amount > toSell\\n            expectedAmount += _repayDebt(converter_, v.asset, tokens[i], tokenBalance) - toSell;\\n\\n            // we can have some leftovers after closing the debt\\n            tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\\n          }\\n\\n          // directly swap leftovers\\n          if (tokenBalance != 0) {\\n            (uint spentAmountIn,) = _liquidate(\\n              converter_,\\n              liquidator,\\n              tokens[i],\\n              v.asset,\\n              tokenBalance,\\n              _ASSET_LIQUIDATION_SLIPPAGE,\\n              liquidationThresholds[v.asset],\\n              false\\n            );\\n            if (spentAmountIn != 0) {\\n              // spentAmountIn can be zero if token balance is less than liquidationThreshold\\n              expectedAmount += spentAmountIn * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\\n            }\\n          }\\n\\n          // reduce of requestedAmount on the balance increment\\n          v.newBalance = IERC20(v.asset).balanceOf(address(this));\\n          require(v.newBalance >= v.balance, AppErrors.BALANCE_DECREASE);\\n\\n          if (requestedAmount > v.newBalance - v.balance) {\\n            requestedAmount -= (v.newBalance - v.balance);\\n            v.balance = v.newBalance;\\n          } else {\\n            // we get requestedAmount on the balance and don't need to make any other conversions\\n            break;\\n          }\\n        }\\n      }\\n    }\\n\\n    return expectedAmount;\\n  }\\n\\n  /// @notice What amount of collateral should be sold to pay the debt and receive {requestedAmount}\\n  /// @dev It doesn't allow to sell more than the amount of total debt in the borrow\\n  /// @param requestedAmount We need to increase balance (of collateral asset) on this amount\\n  /// @param totalDebt Total debt of the borrow in terms of borrow asset\\n  /// @param totalCollateral Total collateral of the borrow in terms of collateral asset\\n  /// @param prices Cost of $1 in terms of the asset, decimals 18\\n  /// @param decs 10**decimals for each asset\\n  /// @param indexCollateral Index of the collateral asset in {prices} and {decs}\\n  /// @param indexBorrowAsset Index of the borrow asset in {prices} and {decs}\\n  /// @param balanceBorrowAsset Available balance of the borrow asset, it will be used to cover the debt\\n  function _getAmountToSell(\\n    uint requestedAmount,\\n    uint totalDebt,\\n    uint totalCollateral,\\n    uint[] memory prices,\\n    uint[] memory decs,\\n    uint indexCollateral,\\n    uint indexBorrowAsset,\\n    uint balanceBorrowAsset\\n  ) internal pure returns (\\n    uint amountOut\\n  ) {\\n    if (totalDebt != 0) {\\n      if (balanceBorrowAsset != 0) {\\n        // there is some borrow asset on balance\\n        // it will be used to cover the debt\\n        // let's reduce the size of totalDebt/Collateral to exclude balanceBorrowAsset\\n        uint sub = Math.min(balanceBorrowAsset, totalDebt);\\n        totalCollateral -= totalCollateral * sub / totalDebt;\\n        totalDebt -= sub;\\n      }\\n\\n      // for definiteness: usdc - collateral asset, dai - borrow asset\\n      // Pc = price of the USDC, Pb = price of the DAI, alpha = Pc / Pb [DAI / USDC]\\n      // S [USDC] - amount to sell, R [DAI] = alpha * S - amount to repay\\n      // After repaying R we get: alpha * S * C / R\\n      // Balance should be increased on: requestedAmount = alpha * S * C / R - S\\n      // So, we should sell: S = requestedAmount / (alpha * C / R - 1))\\n      // We can lost some amount on liquidation of S => R, so we need to use some gap = {GAP_AMOUNT_TO_SELL}\\n      // Same formula: S * h = S + requestedAmount, where h = health factor => s = requestedAmount / (h - 1)\\n      // h = alpha * C / R\\n      uint alpha18 = prices[indexCollateral] * decs[indexBorrowAsset] * 1e18\\n        / prices[indexBorrowAsset] / decs[indexCollateral];\\n\\n      // if totalCollateral is zero (liquidation happens) we will have zero amount (the debt shouldn't be paid)\\n      amountOut = totalDebt != 0 && alpha18 * totalCollateral / totalDebt > 1e18\\n        ? Math.min(requestedAmount, totalCollateral) * 1e18 / (alpha18 * totalCollateral / totalDebt - 1e18)\\n        : 0;\\n\\n      if (amountOut != 0) {\\n        // we shouldn't try to sell amount greater than amount of totalDebt in terms of collateral asset\\n        // but we always asks +1% because liquidation results can be different a bit from expected\\n        amountOut = (GAP_CONVERSION + DENOMINATOR) * Math.min(amountOut, totalDebt * 1e18 / alpha18) / DENOMINATOR;\\n      }\\n    }\\n\\n    return amountOut;\\n  }\\n\\n  /// @notice Repay {amountIn} and get collateral in return, calculate expected amount\\n  ///         Take into account possible debt-gap and the fact that the amount of debt may be less than {amountIn}\\n  /// @param amountToRepay Max available amount of borrow asset that we can repay\\n  /// @return expectedAmountOut Estimated amount of main asset that should be added to balance = collateral - {toSell}\\n  function _repayDebt(\\n    ITetuConverter converter,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountToRepay\\n  ) internal returns (\\n    uint expectedAmountOut\\n  ) {\\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\\n\\n    // get amount of debt with debt-gap\\n    (uint needToRepay,) = converter.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\\n\\n    // get expected amount without debt-gap\\n    uint swappedAmountOut;\\n    (expectedAmountOut, swappedAmountOut) = converter.quoteRepay(address(this), collateralAsset, borrowAsset, amountRepay);\\n\\n    if (expectedAmountOut > swappedAmountOut) {\\n      // Following situation is possible\\n      //    needToRepay = 100, needToRepayExact = 90 (debt gap is 10)\\n      //    1) amountRepay = 80\\n      //       expectedAmountOut is calculated for 80, no problems\\n      //    2) amountRepay = 99,\\n      //       expectedAmountOut is calculated for 90 + 9 (90 - repay, 9 - direct swap)\\n      //       expectedAmountOut must be reduced on 9 here (!)\\n      expectedAmountOut -= swappedAmountOut;\\n    }\\n\\n    // close the debt\\n    _closePositionExact(converter, collateralAsset, borrowAsset, amountRepay, balanceBefore);\\n\\n    return expectedAmountOut;\\n  }\\n  //endregion convertAfterWithdraw\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Other helpers\\n  /////////////////////////////////////////////////////////////////////\\n\\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\\n    return IPriceOracle(IConverterController(converter.controller()).priceOracle()).getAssetPrice(token);\\n  }\\n\\n  function registerIncome(uint assetBefore, uint assetAfter) internal pure returns (uint earned, uint lost) {\\n    if (assetAfter > assetBefore) {\\n      earned = assetAfter - assetBefore;\\n    } else {\\n      lost = assetBefore - assetAfter;\\n    }\\n    return (earned, lost);\\n  }\\n\\n  /// @notice Register income and cover possible loss\\n  function coverPossibleStrategyLoss(uint assetBefore, uint assetAfter, address splitter) external returns (uint earned) {\\n    uint lost;\\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(assetBefore, assetAfter);\\n    if (lost != 0) {\\n      ISplitter(splitter).coverPossibleStrategyLoss(earned, lost);\\n    }\\n    emit FixPriceChanges(assetBefore, assetAfter);\\n  }\\n\\n  //endregion Other helpers\\n}\\n\\n\",\"keccak256\":\"0xcc5a1509229cfc3e1b6303053820384a18f6f24869e78266acb19b6db167ab15\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x615b1a6200003b600b82828239805160001a60731461002e57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100d45760003560e01c8063954d7e7311610086578063954d7e73146101e657806399c1fde414610206578063c9bce69014610226578063ca27d10d14610246578063dcb7398e14610266578063ef50284f14610286578063f1f2b573146102b457600080fd5b80631a2221c7146100d957806358b54f161461010f5780636138ea851461013d5780637a55caf31461015d5780637a9a23e5146101705780637de8f5691461019e5780637fd6c0a1146101d3575b600080fd5b8180156100e557600080fd5b506100f96100f4366004614bb2565b6102d4565b6040516101069190614c74565b60405180910390f35b81801561011b57600080fd5b5061012f61012a366004614c87565b610582565b604051908152602001610106565b81801561014957600080fd5b506100f9610158366004614d04565b61059f565b61012f61016b366004614d83565b6105f9565b81801561017c57600080fd5b5061019061018b366004614dbc565b610733565b604051610106929190614e96565b8180156101aa57600080fd5b506101be6101b9366004614ec9565b6107c1565b60408051928352602083019190915201610106565b61012f6101e1366004614f57565b6107e5565b8180156101f257600080fd5b506101be610201366004614fa2565b6109b7565b81801561021257600080fd5b5061012f610221366004614ff3565b6109d4565b81801561023257600080fd5b5061012f610241366004615086565b610bed565b81801561025257600080fd5b506101be61026136600461512c565b61112f565b81801561027257600080fd5b5061012f6102813660046151ec565b611150565b81801561029257600080fd5b506102a66102a136600461521a565b61120b565b6040516101069291906152f1565b8180156102c057600080fd5b5061012f6102cf366004615313565b6115bf565b8351606090806001600160401b038111156102f1576102f1614a52565b60405190808252806020026020018201604052801561031a578160200160208202803683370190505b50915060005b818110156104b1578581146104a957848181518110610341576103416153d9565b60200260200101516000146104045761038d878781518110610365576103656153d9565b602002602001015186838151811061037f5761037f6153d9565b60200260200101518a6116c8565b61040188604051806020016040528060008152508989815181106103b3576103b36153d9565b60200260200101518a85815181106103cd576103cd6153d9565b60200260200101518986815181106103e7576103e76153d9565b60200260200101516103fc8a620186a0611773565b611789565b50505b868181518110610416576104166153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161044991906153ef565b602060405180830381865afa158015610466573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061048a9190615403565b83828151811061049c5761049c6153d9565b6020026020010181815250505b600101610320565b5061055a8486815181106104c7576104c76153d9565b60200260200101518787815181106104e1576104e16153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161051491906153ef565b602060405180830381865afa158015610531573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105559190615403565b611c12565b82868151811061056c5761056c6153d9565b6020026020010181815250505095945050505050565b6000610592878787878787611c21565b90505b9695505050505050565b60606105f084848787516001600160401b038111156105c0576105c0614a52565b6040519080825280602002602001820160405280156105e9578160200160208202803683370190505b50866123dc565b95945050505050565b6000826001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015610639573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061065d919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561069a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106be919061541c565b6001600160a01b031663b3596f07836040518263ffffffff1660e01b81526004016106e991906153ef565b602060405180830381865afa158015610706573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072a9190615403565b90505b92915050565b60608060006107438888886125b9565b90506107528a8a8d84896123dc565b8a5190935060005b818110156107ad57858181518110610774576107746153d9565b602002602001015187828151811061078e5761078e6153d9565b602002602001018181516107a29190615456565b90525060010161075a565b5085925050505b9850989650505050505050565b6000806107d48a8a8a8a8a8a8a8a6126c0565b915091509850989650505050505050565b600080846001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015610826573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061084a919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610887573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ab919061541c565b90506000816001600160a01b031663b3596f07866040518263ffffffff1660e01b81526004016108db91906153ef565b602060405180830381865afa1580156108f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061091c9190615403565b90506000826001600160a01b031663b3596f07866040518263ffffffff1660e01b815260040161094c91906153ef565b602060405180830381865afa158015610969573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061098d9190615403565b9050816109a282670de0b6b3a7640000615469565b6109ac9190615480565b979650505050505050565b6000806109c68686868661284f565b915091505b94509492505050565b6000808688815181106109e9576109e96153d9565b60200260200101519050806001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610a1f91906153ef565b602060405180830381865afa158015610a3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a609190615403565b915088821015610b7957610b07610a77838b6154a2565b888a878a8a6001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ab9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610add919061541c565b6001600160a01b038816600090815260208b90526040902054610b0261012c80615456565b612976565b50506040516370a0823160e01b81526001600160a01b038216906370a0823190610b359030906004016153ef565b602060405180830381865afa158015610b52573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b769190615403565b91505b610b838983611c12565b91508115610b9f57610b9f6001600160a01b0382168784612b39565b604080516001600160a01b0383168152602081018490527f178d2d6770c9dbd24f8d3e4dc08998cad5a42857f107435518f65c761e253bcc910160405180910390a150979650505050505050565b6000610c1a6040518060800160405280600081526020016060815260200160608152602001606081525090565b8551816000018181525050610cf4836001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c8a919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cc7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ceb919061541c565b82518890612b9c565b6040830152602082015260005b8151811015610ff957848103610d3d57858181518110610d2357610d236153d9565b602002602001015183610d369190615456565b9250610ff1565b6000868281518110610d5157610d516153d9565b6020026020010151888381518110610d6b57610d6b6153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610d9e91906153ef565b602060405180830381865afa158015610dbb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ddf9190615403565b610de99190615456565b9050600080866001600160a01b031663dd27ede7308c8b81518110610e1057610e106153d9565b60200260200101518d8881518110610e2a57610e2a6153d9565b602002602001015160006040518563ffffffff1660e01b8152600401610e5394939291906154b5565b60408051808303816000875af1158015610e71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e9591906154df565b9092509050610ea48187615456565b9550818310610f6a5784604001518481518110610ec357610ec36153d9565b602002602001015185602001518981518110610ee157610ee16153d9565b602002602001015186604001518a81518110610eff57610eff6153d9565b602002602001015187602001518781518110610f1d57610f1d6153d9565b60200260200101518587610f3191906154a2565b610f3b9190615469565b610f459190615469565b610f4f9190615480565b610f599190615480565b610f639087615456565b9550610fed565b846060015151600003610fc05784516001600160401b03811115610f9057610f90614a52565b604051908082528060200260200182016040528015610fb9578160200160208202803683370190505b5060608601525b610fca83836154a2565b85606001518581518110610fe057610fe06153d9565b6020026020010181815250505b5050505b600101610d01565b508051606082015151036111255760005b81518110156111235781606001518181518110611029576110296153d9565b60200260200101516000031561111b57600082604001518281518110611051576110516153d9565b60200260200101518360200151878151811061106f5761106f6153d9565b60200260200101518460400151888151811061108d5761108d6153d9565b6020026020010151856020015185815181106110ab576110ab6153d9565b6020026020010151866060015186815181106110c9576110c96153d9565b60200260200101516110db9190615469565b6110e59190615469565b6110ef9190615480565b6110f99190615480565b90508381111561110c5760009350611119565b61111681856154a2565b93505b505b60010161100a565b505b505b949350505050565b600080611140888888888888611789565b915091505b965096945050505050565b60008061115d8585612d8a565b909250905080156111ca57604051630855081f60e01b815260048101839052602481018290526001600160a01b03841690630855081f90604401600060405180830381600087803b1580156111b157600080fd5b505af11580156111c5573d6000803e3d6000fd5b505050505b60408051868152602081018690527f3e60abe0a0e1f40e1cea1431e7b150cef698f6d8aa08b3d4e445d7a26bd93e2a910160405180910390a1509392505050565b606060006112606040518061010001604052806000815260200160008152602001600081526020016000815260200160006001600160a01b031681526020016000815260200160008152602001600081525090565b855160c08201819052855160408051808201909152601281527154532d342077726f6e67206c656e6774687360701b602082015291146112bc5760405162461bcd60e51b81526004016112b39190615553565b60405180910390fd5b506001600160a01b038b166000908152602088905260409020546112e390620186a0611773565b60a082015260c08101516001600160401b0381111561130457611304614a52565b60405190808252806020026020018201604052801561132d578160200160208202803683370190505b50925060005b8160c001518110156115af57620186a061134d86826154a2565b87838151811061135f5761135f6153d9565b60200260200101516113719190615469565b61137b9190615480565b60608301819052620186a090611392908d90615469565b61139c9190615480565b6020830152606082015186518790839081106113ba576113ba6153d9565b60200260200101516113cc91906154a2565b604083015286518790829081106113e5576113e56153d9565b6020908102919091018101516001600160a01b031660808401526040830151908301516114129190615456565b808352156115765760001961142b8b8460800151612dba565b146114cd578b6001600160a01b031682608001516001600160a01b03160361146357604082015161145c9084615456565b9250611576565b60808201516001600160a01b031660009081526020899052604090205461148d90620186a0611773565b8260400151106114c8576114b68d8a84608001518f86604001516113888860a0015160006126c0565b60e0840181905261145c915084615456565b611576565b60808201516001600160a01b03166000908152602089905260409020546114f790620186a0611773565b8251106115765761151d8d8a84608001518f86600001516113888860a0015160016126c0565b60e08401525081516060830151875188908490811061153e5761153e6153d9565b602002602001015161155091906154a2565b8360e0015161155f9190615469565b6115699190615480565b6115739084615456565b92505b8160200151826060015161158a91906154a2565b84828151811061159c5761159c6153d9565b6020908102919091010152600101611333565b5050995099975050505050505050565b6000805b89518110156115fb578381815181106115de576115de6153d9565b6020026020010151826115f19190615456565b91506001016115c3565b5060001984141580156116305750620186a0611619816103e8615456565b6116239086615469565b61162d9190615480565b81115b156116875761168086868a8560008e8e81518110611650576116506153d9565b60200260200101516001600160a01b03166001600160a01b03168152602001908152602001600020548d8c612e18565b50506116bc565b828881518110611699576116996153d9565b60200260200101516116af87878b86898f611c21565b6116b99190615456565b90505b98975050505050505050565b604051636eb1769f60e11b81523060048201526001600160a01b03828116602483015283919085169063dd62ed3e90604401602060405180830381865afa158015611717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061173b9190615403565b101561176e576117566001600160a01b0384168260006131c5565b61176e6001600160a01b03841682600160ff1b6131c5565b505050565b6000818311611782578161072a565b5090919050565b6000808260000361179957600a92505b8284116117ab57506000905080611145565b6117e46040518060c001604052806000815260200160608152602001606081526020016060815260200160008152602001600081525090565b6117ed886132da565b8082526000190161181057611806898989898989613301565b9250925050611145565b60405163430ffb1760e01b81526001600160a01b038a169063430ffb1790611847908b908b908a908c906213c68090600401615566565b600060405180830381865afa158015611864573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261188c9190810190615602565b506060840152604083015260208201819052518015611c0b5760005b81811015611c095782516119b857826040015181815181106118cc576118cc6153d9565b602002602001015187106118fd57826040015181815181106118f0576118f06153d9565b60200260200101516118ff565b865b6080840152604083015180518290811061191b5761191b6153d9565b6020026020010151871061194c578260600151818151811061193f5761193f6153d9565b602002602001015161199d565b82604001518181518110611962576119626153d9565b60200260200101518784606001518381518110611981576119816153d9565b60200260200101516119939190615469565b61199d9190615480565b60a084015260808301516119b190886154a2565b9650611ab6565b826060015181815181106119ce576119ce6153d9565b602002602001015187106119ff57826060015181815181106119f2576119f26153d9565b6020026020010151611a01565b865b60a08401526060830151805182908110611a1d57611a1d6153d9565b60200260200101518710611a4e5782604001518181518110611a4157611a416153d9565b6020026020010151611a9f565b82606001518181518110611a6457611a646153d9565b60200260200101518784604001518381518110611a8357611a836153d9565b6020026020010151611a959190615469565b611a9f9190615480565b608084015260a0830151611ab390886154a2565b96505b8587108015611ac457508615155b15611ace57600096505b60a083015115611bfb578a6001600160a01b0316630adb2d8584602001518381518110611afd57611afd6153d9565b60200260200101518b86608001518c8860a00151306040518763ffffffff1660e01b8152600401611b3396959493929190615703565b6020604051808303816000875af1158015611b52573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b769190615403565b611b809085615456565b9350826080015185611b929190615456565b94507ff63c9c64ebdd1eb99706ca3f7489f7fbdd9c8756363cef40b2fc6e293fa150ec83602001518281518110611bcb57611bcb6153d9565b60200260200101518a85608001518b8760a0015130604051611bf296959493929190615703565b60405180910390a15b8615611c09576001016118a8565b505b5050611145565b6000818310611782578161072a565b6000821561059557611c966040518061018001604052806000815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016060815260200160008152602001600081526020016060815260200160608152602001600081525090565b828681518110611ca857611ca86153d9565b6020908102919091018101516001600160a01b0316908201819052835182526040516370a0823160e01b81526370a0823190611ce89030906004016153ef565b602060405180830381865afa158015611d05573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d299190615403565b60a082015260005b81518110156123d0578087146123c857886001600160a01b031663dd27ede7308460200151878581518110611d6857611d686153d9565b602002602001015160016040518563ffffffff1660e01b8152600401611d9194939291906154b5565b60408051808303816000875af1158015611daf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611dd391906154df565b61010084015260e08301528351600090859083908110611df557611df56153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401611e2891906153ef565b602060405180830381865afa158015611e45573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e699190615403565b90508260e001516000141580611e7e57508015155b156123c65782610120015151600003611f6d57611f608a6001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015611ed2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ef6919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611f33573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f57919061541c565b84518790612b9c565b6101408501526101208401525b60e08301511561218a576000611f9c878560e001518661010001518761012001518861014001518e8989613816565b90508015801590611fb0575060a084015115155b156120c057611fc3818560a00151611c12565b90506120328b8b8660200151898781518110611fe157611fe16153d9565b60200260200101518561012c8e60008e8c81518110612002576120026153d9565b60200260200101516001600160a01b03166001600160a01b031681526020019081526020016000205460006126c0565b5080915050858381518110612049576120496153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161207c91906153ef565b602060405180830381865afa158015612099573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120bd9190615403565b91505b806120ea8c86602001518987815181106120dc576120dc6153d9565b6020026020010151866139e0565b6120f491906154a2565b6120fe9086615456565b9450858381518110612112576121126153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161214591906153ef565b602060405180830381865afa158015612162573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121869190615403565b9150505b80156122a75760006121ea8b8b8886815181106121a9576121a96153d9565b602002602001015187602001518661012c8e60008c602001516001600160a01b03166001600160a01b031681526020019081526020016000205460006126c0565b50905080156122a557836101400151838151811061220a5761220a6153d9565b60200260200101518461012001518a81518110612229576122296153d9565b60200260200101518561014001518b81518110612248576122486153d9565b60200260200101518661012001518681518110612267576122676153d9565b60200260200101518461227a9190615469565b6122849190615469565b61228e9190615480565b6122989190615480565b6122a29086615456565b94505b505b82602001516001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016122d791906153ef565b602060405180830381865afa1580156122f4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123189190615403565b610160840181905260a084015160408051808201909152601681527554532d32302062616c616e636520646563726561736560501b60208201529110156123725760405162461bcd60e51b81526004016112b39190615553565b508260a0015183610160015161238891906154a2565b8611156123c0578260a001518361016001516123a491906154a2565b6123ae90876154a2565b61016084015160a085015295506123c6565b506123d0565b505b600101611d31565b50509695505050505050565b8451606090806001600160401b038111156123f9576123f9614a52565b604051908082528060200260200182016040528015612422578160200160208202803683370190505b50915060005b818110156125ae5786810361247457848181518110612449576124496153d9565b6020026020010151838281518110612463576124636153d9565b6020026020010181815250506125a6565b6000848281518110612488576124886153d9565b60200260200101518683815181106124a2576124a26153d9565b60200260200101516124b49190615456565b905080156125a457866001600160a01b031663667df249308b8b815181106124de576124de6153d9565b60200260200101518c86815181106124f8576124f86153d9565b60209081029190910101516040516001600160e01b031960e086901b1681526001600160a01b03938416600482015291831660248301529190911660448201526064810184905260840160408051808303816000875af1158015612560573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061258491906154df565b50848381518110612597576125976153d9565b6020026020010181815250505b505b600101612428565b505095945050505050565b6060600082156125fb57828410156125ed57826125de85670de0b6b3a7640000615469565b6125e89190615480565b6125fe565b670de0b6b3a76400006125fe565b60005b8551909150806001600160401b0381111561261b5761261b614a52565b604051908082528060200260200182016040528015612644578160200160208202803683370190505b50925081156126b75760005b818110156126b557670de0b6b3a764000083888381518110612674576126746153d9565b60200260200101516126869190615469565b6126909190615480565b8482815181106126a2576126a26153d9565b6020908102919091010152600101612650565b505b50509392505050565b600080856000036126d6575060009050806107b4565b604051633744088160e11b81526001600160a01b0389811660048301528881166024830152600091908b1690636e88110290604401600060405180830381865afa158015612728573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526127509190810190615780565b50805160408051808201909152601a81527f54532d3135204e6f206c69717569646174696f6e20726f75746500000000000060208201529192506127a75760405162461bcd60e51b81526004016112b39190615553565b50604051637cbf210b60e11b81526000906001600160a01b038c169063f97e4216906127d99085908c906004016158f9565b602060405180830381865afa1580156127f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061281a9190615403565b905085811161282b5760008061283c565b8761283c8d848e8e8e8e8e8d613ba0565b9350935050509850989650505050505050565b6000806000846001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161288091906153ef565b602060405180830381865afa15801561289d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128c19190615403565b90506000876001600160a01b031663dd27ede730898960016040518563ffffffff1660e01b81526004016128f894939291906154b5565b60408051808303816000875af1158015612916573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061293a91906154df565b509050600061295782871061294f5782612951565b865b84611c12565b90506129668989898487613e90565b9450945050505094509492505050565b60608061299d60405180606001604052806000815260200160608152602001600081525090565b89518082526001600160401b038111156129b9576129b9614a52565b6040519080825280602002602001820160405280156129e2578160200160208202803683370190505b5060208201525b805160408201511015612ab55789816040015181518110612a0c57612a0c6153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401612a3f91906153ef565b602060405180830381865afa158015612a5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a809190615403565b8160200151826040015181518110612a9a57612a9a6153d9565b602090810291909101015260408101805160010190526129e9565b612b276040518061012001604052808d81526020018c81526020018b81526020018a6001600160a01b0316815260200183602001518152602001896001600160a01b03168152602001886001600160a01b03168152602001612b1a88620186a0611773565b8152602001869052614071565b909c909b509950505050505050505050565b6040516001600160a01b03831660248201526044810182905261176e90849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526143fc565b606080826001600160401b03811115612bb757612bb7614a52565b604051908082528060200260200182016040528015612be0578160200160208202803683370190505b509150826001600160401b03811115612bfb57612bfb614a52565b604051908082528060200260200182016040528015612c24578160200160208202803683370190505b50905060005b83811015612d8157848181518110612c4457612c446153d9565b60200260200101516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015612c89573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cad919061590c565b612cb890600a615a13565b828281518110612cca57612cca6153d9565b602002602001018181525050856001600160a01b031663b3596f07868381518110612cf757612cf76153d9565b60200260200101516040518263ffffffff1660e01b8152600401612d1b91906153ef565b602060405180830381865afa158015612d38573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d5c9190615403565b838281518110612d6e57612d6e6153d9565b6020908102919091010152600101612c2a565b50935093915050565b60008083831115612da657612d9f84846154a2565b9150612db3565b612db083856154a2565b90505b9250929050565b8151600090815b81811015612e0c57836001600160a01b0316858281518110612de557612de56153d9565b60200260200101516001600160a01b031603612e0457915061072d9050565b600101612dc1565b50600019949350505050565b60006060612e656040518060e0016040528060006001600160a01b031681526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b848781518110612e7757612e776153d9565b60209081029190910101516001600160a01b03168082526040516370a0823160e01b81526370a0823190612eaf9030906004016153ef565b602060405180830381865afa158015612ecc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ef09190615403565b60a0820152845160c082015284516001600160401b03811115612f1557612f15614a52565b604051908082528060200260200182016040528015612f3e578160200160208202803683370190505b50915060005b8160c00151811015612fe65787811480612f775750848181518110612f6b57612f6b6153d9565b60200260200101516000145b612fde57612fbd8a8360000151888481518110612f9657612f966153d9565b6020026020010151888581518110612fb057612fb06153d9565b602002602001015161284f565b9050838281518110612fd157612fd16153d9565b6020026020010181815250505b600101612f44565b5060005b8160c0015181101561311a578781148061301d5750848181518110613011576130116153d9565b60200260200101516000145b61311257828181518110613033576130336153d9565b602002602001015185828151811061304d5761304d6153d9565b60200260200101511115613112576130c88a8a888481518110613072576130726153d9565b60200260200101518560000151878681518110613091576130916153d9565b60200260200101518a87815181106130ab576130ab6153d9565b60200260200101516130bd91906154a2565b61012c8d60006126c0565b6060840181905260408401919091526130e19085615456565b935081604001518382815181106130fa576130fa6153d9565b6020026020010181815161310e9190615456565b9052505b600101612fea565b5080516040516370a0823160e01b81526001600160a01b03909116906370a082319061314a9030906004016153ef565b602060405180830381865afa158015613167573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061318b9190615403565b6080820181905260a0820151106131a35760006131b7565b8060a0015181608001516131b791906154a2565b925050965096945050505050565b80158061323f5750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015613219573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061323d9190615403565b155b6132aa5760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084016112b3565b6040516001600160a01b03831660248201526044810182905261176e90849063095ea7b360e01b90606401612b65565b600081516000036132ed57506000919050565b8180602001905181019061072d9190615403565b6000806133536040518061012001604052806060815260200160608152602001606081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b60405163430ffb1760e01b81526001600160a01b038a169063430ffb179061338a908b908b908a908c906213c68090600401615566565b600060405180830381865afa1580156133a7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526133cf9190810190615602565b5060408401526020830152808252518015613809576000808a8060200190518101906133fb9190615a22565b925092505061340b8c8b8b6144ce565b61010085015260005b8381101561380557670de0b6b3a76400008560400151828151811061343b5761343b6153d9565b60200260200101518661010001516134539190615469565b61345d9190615480565b60c0860181905282906134709085615469565b61347a9190615480565b60a08601819052602086015180518b9291908490811061349c5761349c6153d9565b60200260200101516134ae9190615456565b116134c157670de0b6b3a764000061350a565b8460a00151856020015182815181106134dc576134dc6153d9565b60200260200101516134ee9190615456565b6135008a670de0b6b3a7640000615469565b61350a9190615480565b60e0860181905260208601518051670de0b6b3a764000092919084908110613534576135346153d9565b60200260200101516135469190615469565b6135509190615480565b856060018181525050670de0b6b3a76400008560e001518660400151838151811061357d5761357d6153d9565b602002602001015161358f9190615469565b6135999190615480565b608086015260608501518811806135b257506080850151155b156135fa5788888660a00151876020015184815181106135d4576135d46153d9565b60200260200101516135e69190615456565b6135f09190615456565b11613805576137fd565b84608001518d6001600160a01b0316630adb2d8587600001518481518110613624576136246153d9565b60200260200101518e89606001518f8b60800151306040518763ffffffff1660e01b815260040161365a96959493929190615703565b6020604051808303816000875af1158015613679573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061369d9190615403565b146040518060400160405280600f81526020016e53423a2057726f6e672076616c756560881b815250906136e45760405162461bcd60e51b81526004016112b39190615553565b507ff63c9c64ebdd1eb99706ca3f7489f7fbdd9c8756363cef40b2fc6e293fa150ec8560000151828151811061371c5761371c6153d9565b60200260200101518c87606001518d89608001513060405161374396959493929190615703565b60405180910390a1608085015161375a9087615456565b955084606001518761376c9190615456565b9650670de0b6b3a7640000856080015186610100015161378c9190615469565b6137969190615480565b60c0860181905282906137a99085615469565b6137b39190615480565b60a0860181905260608601516137c891615456565b89116137d55760006137f3565b84606001518560a001516137e99190615456565b6137f3908a6154a2565b9850878910613805575b600101613414565b5050505b5050965096945050505050565b600087156116bc578115613861576000613830838a611c12565b90508861383d828a615469565b6138479190615480565b61385190896154a2565b975061385d818a6154a2565b9850505b6000858581518110613875576138756153d9565b602002602001015187858151811061388f5761388f6153d9565b60200260200101518786815181106138a9576138a96153d9565b60200260200101518988815181106138c3576138c36153d9565b60200260200101516138d59190615469565b6138e790670de0b6b3a7640000615469565b6138f19190615480565b6138fb9190615480565b905088158015906139275750670de0b6b3a76400008961391b8a84615469565b6139259190615480565b115b613932576000613980565b670de0b6b3a7640000896139468a84615469565b6139509190615480565b61395a91906154a2565b6139648b8a611c12565b61397690670de0b6b3a7640000615469565b6139809190615480565b915081156139d357620186a06139ad83836139a38d670de0b6b3a7640000615469565b6105559190615480565b6139bc620186a06103e8615456565b6139c69190615469565b6139d09190615480565b91505b5098975050505050505050565b600080836001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401613a0f91906153ef565b602060405180830381865afa158015613a2c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a509190615403565b90506000866001600160a01b031663dd27ede730888860016040518563ffffffff1660e01b8152600401613a8794939291906154b5565b60408051808303816000875af1158015613aa5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613ac991906154df565b5090506000613ae5828610613ade5782612951565b8584611c12565b60405163667df24960e01b81523060048201526001600160a01b0389811660248301528881166044830152606482018390529192506000918a169063667df2499060840160408051808303816000875af1158015613b47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b6b91906154df565b909550905080851115613b8557613b8281866154a2565b94505b613b928989898588613e90565b505050505050949350505050565b6000613bad8685896116c8565b6040516370a0823160e01b81526000906001600160a01b038716906370a0823190613bdc9030906004016153ef565b602060405180830381865afa158015613bf9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613c1d9190615403565b6040516310fe133960e31b81529091506001600160a01b038916906387f099c890613c50908c9089908990600401615a50565b600060405180830381600087803b158015613c6a57600080fd5b505af1158015613c7e573d6000803e3d6000fd5b50506040516370a0823160e01b8152600092506001600160a01b03891691506370a0823190613cb19030906004016153ef565b602060405180830381865afa158015613cce573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613cf29190615403565b90508181116040518060400160405280601681526020017554532d32302062616c616e636520646563726561736560501b81525090613d445760405162461bcd60e51b81526004016112b39190615553565b50613d4f82826154a2565b92508380613ddf5750604051630a47e27160e21b81526001600160a01b03898116600483015260248201889052888116604483015260648201859052608482018790528c169063291f89c49060a401602060405180830381865afa158015613dbb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613ddf9190615a75565b604051806040016040528060128152602001711514cb4c4d881c1c9a58d9481a5b5c1858dd60721b81525090613e285760405162461bcd60e51b81526004016112b39190615553565b50604080516001600160a01b03808b1682528916602082015290810187905260608101879052608081018490527f5a821a618ddb1a1fd304234a69c9d7f20c129d122fcf35593d13a071926643079060a00160405180910390a1505098975050505050505050565b600080613ea76001600160a01b0386168886612b39565b6040516314b685e960e21b81526001600160a01b038781166004830152868116602483015260448201869052306064830152600091908916906352da17a4906084016080604051808303816000875af1158015613f08573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613f2c9190615a92565b5050604080516001600160a01b03808c1682528a1660208201529081018890523060608201526080810183905260a0810182905291945091507f1d1ba11e7ca20f5dc77d8cfd75b68d11520677808f89f6ba0f0e50dc52c450129060c00160405180910390a16040516370a0823160e01b81526000906001600160a01b038816906370a0823190613fc19030906004016153ef565b602060405180830381865afa158015613fde573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906140029190615403565b905080851161401257600061401c565b61401c81866154a2565b60408051808201909152600f81526e53423a2057726f6e672076616c756560881b602082015290935082156140645760405162461bcd60e51b81526004016112b39190615553565b5050509550959350505050565b60608061409f6040518060800160405280600081526020016060815260200160608152602001606081525090565b6020840151518082526001600160401b038111156140bf576140bf614a52565b6040519080825280602002602001820160405280156140e8578160200160208202803683370190505b5081519092506001600160401b0381111561410557614105614a52565b60405190808252806020026020018201604052801561412e578160200160208202803683370190505b5092506142078460a001516001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015614176573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061419a919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156141d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141fb919061541c565b60208601518351612b9c565b604083015260208201526000805b825181101561432e5785602001518181518110614234576142346153d9565b60200260200101516001600160a01b031686606001516001600160a01b03160361426057809150614326565b604086015181146143265760008061429786896040015181518110614287576142876153d9565b6020026020010151898786614779565b91509150818784815181106142ae576142ae6153d9565b602002602001018181516142c29190615456565b905250604088015186518291889181106142de576142de6153d9565b602002602001018181516142f29190615456565b905250875160408901518751889190811061430f5761430f6153d9565b60200260200101511061432357505061432e565b50505b600101614215565b5084600001518386604001518151811061434a5761434a6153d9565b6020026020010151108015614363575080856040015114155b156143f55760008061439485886040015181518110614384576143846153d9565b6020026020010151888686614779565b91509150818684815181106143ab576143ab6153d9565b602002602001018181516143bf9190615456565b905250604087015185518291879181106143db576143db6153d9565b602002602001018181516143ef9190615456565b90525050505b5050915091565b6000614451826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166149179092919063ffffffff16565b80519091501561176e578080602001905181019061446f9190615a75565b61176e5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016112b3565b600080846001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa15801561450f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614533919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614570573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614594919061541c565b90506000816001600160a01b031663b3596f07866040518263ffffffff1660e01b81526004016145c491906153ef565b602060405180830381865afa1580156145e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146059190615403565b90506000826001600160a01b031663b3596f07866040518263ffffffff1660e01b815260040161463591906153ef565b602060405180830381865afa158015614652573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146769190615403565b9050846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156146b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146da919061590c565b6146e590600a615a13565b82876001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015614724573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614748919061590c565b61475390600a615a13565b61476584670de0b6b3a7640000615469565b61476f9190615469565b6109a29190615480565b60008084608001518381518110614792576147926153d9565b60200260200101516000146109cb576000620186a0808761010001516147b89190615456565b86604001518860400151815181106147d2576147d26153d9565b6020026020010151876020015187815181106147f0576147f06153d9565b60200260200101518860400151888151811061480e5761480e6153d9565b602002602001015189602001518b6040015181518110614830576148306153d9565b60200260200101518c8c6000015161484891906154a2565b6148529190615469565b61485c9190615469565b6148669190615480565b6148709190615480565b61487a9190615469565b6148849190615480565b90506149098660a001518760c00151886020015187815181106148a9576148a96153d9565b602002602001015189602001518a60400151815181106148cb576148cb6153d9565b60200260200101516148fa868c608001518b815181106148ed576148ed6153d9565b6020026020010151611c12565b61012c8c60e0015160006126c0565b909890975095505050505050565b6060611127848460008585600080866001600160a01b0316858760405161493e9190615ac8565b60006040518083038185875af1925050503d806000811461497b576040519150601f19603f3d011682016040523d82523d6000602084013e614980565b606091505b50915091506109ac87838387606083156149fb5782516000036149f4576001600160a01b0385163b6149f45760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016112b3565b5081611127565b6111278383815115614a105781518083602001fd5b8060405162461bcd60e51b81526004016112b39190615553565b6001600160a01b0381168114614a3f57600080fd5b50565b8035614a4d81614a2a565b919050565b634e487b7160e01b600052604160045260246000fd5b604051608081016001600160401b0381118282101715614a8a57614a8a614a52565b60405290565b604051601f8201601f191681016001600160401b0381118282101715614ab857614ab8614a52565b604052919050565b60006001600160401b03821115614ad957614ad9614a52565b5060051b60200190565b600082601f830112614af457600080fd5b81356020614b09614b0483614ac0565b614a90565b82815260059290921b84018101918181019086841115614b2857600080fd5b8286015b84811015614b4c578035614b3f81614a2a565b8352918301918301614b2c565b509695505050505050565b600082601f830112614b6857600080fd5b81356020614b78614b0483614ac0565b82815260059290921b84018101918181019086841115614b9757600080fd5b8286015b84811015614b4c5780358352918301918301614b9b565b600080600080600060a08688031215614bca57600080fd5b8535614bd581614a2a565b945060208601356001600160401b0380821115614bf157600080fd5b614bfd89838a01614ae3565b9550604088013594506060880135915080821115614c1a57600080fd5b50614c2788828901614b57565b95989497509295608001359392505050565b600081518084526020808501945080840160005b83811015614c6957815187529582019590820190600101614c4d565b509495945050505050565b60208152600061072a6020830184614c39565b60008060008060008060c08789031215614ca057600080fd5b8635614cab81614a2a565b95506020870135614cbb81614a2a565b945060408701359350606087013592506080870135915060a08701356001600160401b03811115614ceb57600080fd5b614cf789828a01614ae3565b9150509295509295509295565b60008060008060808587031215614d1a57600080fd5b8435614d2581614a2a565b935060208501356001600160401b0380821115614d4157600080fd5b614d4d88838901614ae3565b9450604087013593506060870135915080821115614d6a57600080fd5b50614d7787828801614b57565b91505092959194509250565b60008060408385031215614d9657600080fd5b8235614da181614a2a565b91506020830135614db181614a2a565b809150509250929050565b600080600080600080600080610100898b031215614dd957600080fd5b614de289614a42565b975060208901356001600160401b0380821115614dfe57600080fd5b614e0a8c838d01614ae3565b985060408b0135975060608b0135915080821115614e2757600080fd5b614e338c838d01614b57565b965060808b0135955060a08b0135945060c08b0135915080821115614e5757600080fd5b614e638c838d01614b57565b935060e08b0135915080821115614e7957600080fd5b50614e868b828c01614b57565b9150509295985092959890939650565b604081526000614ea96040830185614c39565b82810360208401526105f08185614c39565b8015158114614a3f57600080fd5b600080600080600080600080610100898b031215614ee657600080fd5b8835614ef181614a2a565b97506020890135614f0181614a2a565b96506040890135614f1181614a2a565b95506060890135614f2181614a2a565b94506080890135935060a0890135925060c0890135915060e0890135614f4681614ebb565b809150509295985092959890939650565b600080600060608486031215614f6c57600080fd5b8335614f7781614a2a565b92506020840135614f8781614a2a565b91506040840135614f9781614a2a565b809150509250925092565b60008060008060808587031215614fb857600080fd5b8435614fc381614a2a565b93506020850135614fd381614a2a565b92506040850135614fe381614a2a565b9396929550929360600135925050565b600080600080600080600060e0888a03121561500e57600080fd5b873596506020880135955060408801356001600160401b0381111561503257600080fd5b61503e8a828b01614ae3565b955050606088013561504f81614a2a565b9350608088013561505f81614a2a565b925060a088013561506f81614a2a565b8092505060c0880135905092959891949750929550565b6000806000806080858703121561509c57600080fd5b84356001600160401b03808211156150b357600080fd5b6150bf88838901614ae3565b955060208701359150808211156150d557600080fd5b506150e287828801614b57565b9350506040850135915060608501356150fa81614a2a565b939692955090935050565b60006001600160401b0382111561511e5761511e614a52565b50601f01601f191660200190565b60008060008060008060c0878903121561514557600080fd5b863561515081614a2a565b955060208701356001600160401b0381111561516b57600080fd5b8701601f8101891361517c57600080fd5b803561518a614b0482615105565b8181528a602083850101111561519f57600080fd5b816020840160208301376000602083830101528097505050506151c460408801614a42565b93506151d260608801614a42565b92506080870135915060a087013590509295509295509295565b60008060006060848603121561520157600080fd5b83359250602084013591506040840135614f9781614a2a565b60008060008060008060008060006101208a8c03121561523957600080fd5b6152428a614a42565b985061525060208b01614a42565b975060408a0135965060608a01356001600160401b038082111561527357600080fd5b61527f8d838e01614ae3565b975061528d60808d01614a42565b965060a08c0135955060c08c01359150808211156152aa57600080fd5b6152b68d838e01614ae3565b945060e08c01359150808211156152cc57600080fd5b506152d98c828d01614b57565b9250506101008a013590509295985092959850929598565b6040815260006153046040830185614c39565b90508260208301529392505050565b600080600080600080600080610100898b03121561533057600080fd5b88356001600160401b038082111561534757600080fd5b6153538c838d01614ae3565b995060208b0135985060408b013591508082111561537057600080fd5b61537c8c838d01614b57565b975061538a60608c01614a42565b965061539860808c01614a42565b955060a08b0135945060c08b01359150808211156153b557600080fd5b506153c28b828c01614b57565b92505060e089013590509295985092959890939650565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b0391909116815260200190565b60006020828403121561541557600080fd5b5051919050565b60006020828403121561542e57600080fd5b815161543981614a2a565b9392505050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561072d5761072d615440565b808202811582820484141761072d5761072d615440565b60008261549d57634e487b7160e01b600052601260045260246000fd5b500490565b8181038181111561072d5761072d615440565b6001600160a01b039485168152928416602084015292166040820152901515606082015260800190565b600080604083850312156154f257600080fd5b505080516020909101519092909150565b60005b8381101561551e578181015183820152602001615506565b50506000910152565b6000815180845261553f816020860160208601615503565b601f01601f19169290920160200192915050565b60208152600061072a6020830184615527565b60a08152600061557960a0830188615527565b6001600160a01b03968716602084015260408301959095525091909316606082015260800191909152919050565b600082601f8301126155b857600080fd5b815160206155c8614b0483614ac0565b82815260059290921b840181019181810190868411156155e757600080fd5b8286015b84811015614b4c57805183529183019183016155eb565b6000806000806080858703121561561857600080fd5b84516001600160401b038082111561562f57600080fd5b818701915087601f83011261564357600080fd5b81516020615653614b0483614ac0565b82815260059290921b8401810191818101908b84111561567257600080fd5b948201945b8386101561569957855161568a81614a2a565b82529482019490820190615677565b918a01519198509093505050808211156156b257600080fd5b6156be888389016155a7565b945060408701519150808211156156d457600080fd5b6156e0888389016155a7565b935060608701519150808211156156f657600080fd5b50614d77878288016155a7565b6001600160a01b039687168152948616602086015260408501939093529084166060840152608083015290911660a082015260c00190565b600082601f83011261574c57600080fd5b815161575a614b0482615105565b81815284602083860101111561576f57600080fd5b611127826020830160208701615503565b600080604080848603121561579457600080fd5b83516001600160401b03808211156157ab57600080fd5b818601915086601f8301126157bf57600080fd5b815160206157cf614b0483614ac0565b82815260079290921b8401810191818101908a8411156157ee57600080fd5b948201945b83861015615868576080868c03121561580c5760008081fd5b615814614a68565b865161581f81614a2a565b81528684015161582e81614a2a565b818501528688015161583f81614a2a565b8189015260608781015161585281614a2a565b90820152825260809590950194908201906157f3565b9189015191975090945050508083111561588157600080fd5b505061588f8582860161573b565b9150509250929050565b600081518084526020808501945080840160005b83811015614c6957815180516001600160a01b039081168952848201518116858a01526040808301518216908a01526060918201511690880152608090960195908201906001016158ad565b6040815260006153046040830185615899565b60006020828403121561591e57600080fd5b815160ff8116811461543957600080fd5b600181815b8085111561596a57816000190482111561595057615950615440565b8085161561595d57918102915b93841c9390800290615934565b509250929050565b6000826159815750600161072d565b8161598e5750600061072d565b81600181146159a457600281146159ae576159ca565b600191505061072d565b60ff8411156159bf576159bf615440565b50506001821b61072d565b5060208310610133831016604e8410600b84101617156159ed575081810a61072d565b6159f7838361592f565b8060001904821115615a0b57615a0b615440565b029392505050565b600061072a60ff841683615972565b600080600060608486031215615a3757600080fd5b8351925060208401519150604084015190509250925092565b606081526000615a636060830186615899565b60208301949094525060400152919050565b600060208284031215615a8757600080fd5b815161543981614ebb565b60008060008060808587031215615aa857600080fd5b505082516020840151604085015160609095015191969095509092509050565b60008251615ada818460208701615503565b919091019291505056fea2646970667358221220d68b96dfcb6df9a6deef8f050b4c7cdbb87017d351287a036ffdca1abebf02cd64736f6c63430008110033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100d45760003560e01c8063954d7e7311610086578063954d7e73146101e657806399c1fde414610206578063c9bce69014610226578063ca27d10d14610246578063dcb7398e14610266578063ef50284f14610286578063f1f2b573146102b457600080fd5b80631a2221c7146100d957806358b54f161461010f5780636138ea851461013d5780637a55caf31461015d5780637a9a23e5146101705780637de8f5691461019e5780637fd6c0a1146101d3575b600080fd5b8180156100e557600080fd5b506100f96100f4366004614bb2565b6102d4565b6040516101069190614c74565b60405180910390f35b81801561011b57600080fd5b5061012f61012a366004614c87565b610582565b604051908152602001610106565b81801561014957600080fd5b506100f9610158366004614d04565b61059f565b61012f61016b366004614d83565b6105f9565b81801561017c57600080fd5b5061019061018b366004614dbc565b610733565b604051610106929190614e96565b8180156101aa57600080fd5b506101be6101b9366004614ec9565b6107c1565b60408051928352602083019190915201610106565b61012f6101e1366004614f57565b6107e5565b8180156101f257600080fd5b506101be610201366004614fa2565b6109b7565b81801561021257600080fd5b5061012f610221366004614ff3565b6109d4565b81801561023257600080fd5b5061012f610241366004615086565b610bed565b81801561025257600080fd5b506101be61026136600461512c565b61112f565b81801561027257600080fd5b5061012f6102813660046151ec565b611150565b81801561029257600080fd5b506102a66102a136600461521a565b61120b565b6040516101069291906152f1565b8180156102c057600080fd5b5061012f6102cf366004615313565b6115bf565b8351606090806001600160401b038111156102f1576102f1614a52565b60405190808252806020026020018201604052801561031a578160200160208202803683370190505b50915060005b818110156104b1578581146104a957848181518110610341576103416153d9565b60200260200101516000146104045761038d878781518110610365576103656153d9565b602002602001015186838151811061037f5761037f6153d9565b60200260200101518a6116c8565b61040188604051806020016040528060008152508989815181106103b3576103b36153d9565b60200260200101518a85815181106103cd576103cd6153d9565b60200260200101518986815181106103e7576103e76153d9565b60200260200101516103fc8a620186a0611773565b611789565b50505b868181518110610416576104166153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161044991906153ef565b602060405180830381865afa158015610466573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061048a9190615403565b83828151811061049c5761049c6153d9565b6020026020010181815250505b600101610320565b5061055a8486815181106104c7576104c76153d9565b60200260200101518787815181106104e1576104e16153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161051491906153ef565b602060405180830381865afa158015610531573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105559190615403565b611c12565b82868151811061056c5761056c6153d9565b6020026020010181815250505095945050505050565b6000610592878787878787611c21565b90505b9695505050505050565b60606105f084848787516001600160401b038111156105c0576105c0614a52565b6040519080825280602002602001820160405280156105e9578160200160208202803683370190505b50866123dc565b95945050505050565b6000826001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015610639573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061065d919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561069a573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106be919061541c565b6001600160a01b031663b3596f07836040518263ffffffff1660e01b81526004016106e991906153ef565b602060405180830381865afa158015610706573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072a9190615403565b90505b92915050565b60608060006107438888886125b9565b90506107528a8a8d84896123dc565b8a5190935060005b818110156107ad57858181518110610774576107746153d9565b602002602001015187828151811061078e5761078e6153d9565b602002602001018181516107a29190615456565b90525060010161075a565b5085925050505b9850989650505050505050565b6000806107d48a8a8a8a8a8a8a8a6126c0565b915091509850989650505050505050565b600080846001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015610826573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061084a919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610887573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108ab919061541c565b90506000816001600160a01b031663b3596f07866040518263ffffffff1660e01b81526004016108db91906153ef565b602060405180830381865afa1580156108f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061091c9190615403565b90506000826001600160a01b031663b3596f07866040518263ffffffff1660e01b815260040161094c91906153ef565b602060405180830381865afa158015610969573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061098d9190615403565b9050816109a282670de0b6b3a7640000615469565b6109ac9190615480565b979650505050505050565b6000806109c68686868661284f565b915091505b94509492505050565b6000808688815181106109e9576109e96153d9565b60200260200101519050806001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610a1f91906153ef565b602060405180830381865afa158015610a3c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a609190615403565b915088821015610b7957610b07610a77838b6154a2565b888a878a8a6001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610ab9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610add919061541c565b6001600160a01b038816600090815260208b90526040902054610b0261012c80615456565b612976565b50506040516370a0823160e01b81526001600160a01b038216906370a0823190610b359030906004016153ef565b602060405180830381865afa158015610b52573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610b769190615403565b91505b610b838983611c12565b91508115610b9f57610b9f6001600160a01b0382168784612b39565b604080516001600160a01b0383168152602081018490527f178d2d6770c9dbd24f8d3e4dc08998cad5a42857f107435518f65c761e253bcc910160405180910390a150979650505050505050565b6000610c1a6040518060800160405280600081526020016060815260200160608152602001606081525090565b8551816000018181525050610cf4836001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015610c66573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610c8a919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610cc7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ceb919061541c565b82518890612b9c565b6040830152602082015260005b8151811015610ff957848103610d3d57858181518110610d2357610d236153d9565b602002602001015183610d369190615456565b9250610ff1565b6000868281518110610d5157610d516153d9565b6020026020010151888381518110610d6b57610d6b6153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401610d9e91906153ef565b602060405180830381865afa158015610dbb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610ddf9190615403565b610de99190615456565b9050600080866001600160a01b031663dd27ede7308c8b81518110610e1057610e106153d9565b60200260200101518d8881518110610e2a57610e2a6153d9565b602002602001015160006040518563ffffffff1660e01b8152600401610e5394939291906154b5565b60408051808303816000875af1158015610e71573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e9591906154df565b9092509050610ea48187615456565b9550818310610f6a5784604001518481518110610ec357610ec36153d9565b602002602001015185602001518981518110610ee157610ee16153d9565b602002602001015186604001518a81518110610eff57610eff6153d9565b602002602001015187602001518781518110610f1d57610f1d6153d9565b60200260200101518587610f3191906154a2565b610f3b9190615469565b610f459190615469565b610f4f9190615480565b610f599190615480565b610f639087615456565b9550610fed565b846060015151600003610fc05784516001600160401b03811115610f9057610f90614a52565b604051908082528060200260200182016040528015610fb9578160200160208202803683370190505b5060608601525b610fca83836154a2565b85606001518581518110610fe057610fe06153d9565b6020026020010181815250505b5050505b600101610d01565b508051606082015151036111255760005b81518110156111235781606001518181518110611029576110296153d9565b60200260200101516000031561111b57600082604001518281518110611051576110516153d9565b60200260200101518360200151878151811061106f5761106f6153d9565b60200260200101518460400151888151811061108d5761108d6153d9565b6020026020010151856020015185815181106110ab576110ab6153d9565b6020026020010151866060015186815181106110c9576110c96153d9565b60200260200101516110db9190615469565b6110e59190615469565b6110ef9190615480565b6110f99190615480565b90508381111561110c5760009350611119565b61111681856154a2565b93505b505b60010161100a565b505b505b949350505050565b600080611140888888888888611789565b915091505b965096945050505050565b60008061115d8585612d8a565b909250905080156111ca57604051630855081f60e01b815260048101839052602481018290526001600160a01b03841690630855081f90604401600060405180830381600087803b1580156111b157600080fd5b505af11580156111c5573d6000803e3d6000fd5b505050505b60408051868152602081018690527f3e60abe0a0e1f40e1cea1431e7b150cef698f6d8aa08b3d4e445d7a26bd93e2a910160405180910390a1509392505050565b606060006112606040518061010001604052806000815260200160008152602001600081526020016000815260200160006001600160a01b031681526020016000815260200160008152602001600081525090565b855160c08201819052855160408051808201909152601281527154532d342077726f6e67206c656e6774687360701b602082015291146112bc5760405162461bcd60e51b81526004016112b39190615553565b60405180910390fd5b506001600160a01b038b166000908152602088905260409020546112e390620186a0611773565b60a082015260c08101516001600160401b0381111561130457611304614a52565b60405190808252806020026020018201604052801561132d578160200160208202803683370190505b50925060005b8160c001518110156115af57620186a061134d86826154a2565b87838151811061135f5761135f6153d9565b60200260200101516113719190615469565b61137b9190615480565b60608301819052620186a090611392908d90615469565b61139c9190615480565b6020830152606082015186518790839081106113ba576113ba6153d9565b60200260200101516113cc91906154a2565b604083015286518790829081106113e5576113e56153d9565b6020908102919091018101516001600160a01b031660808401526040830151908301516114129190615456565b808352156115765760001961142b8b8460800151612dba565b146114cd578b6001600160a01b031682608001516001600160a01b03160361146357604082015161145c9084615456565b9250611576565b60808201516001600160a01b031660009081526020899052604090205461148d90620186a0611773565b8260400151106114c8576114b68d8a84608001518f86604001516113888860a0015160006126c0565b60e0840181905261145c915084615456565b611576565b60808201516001600160a01b03166000908152602089905260409020546114f790620186a0611773565b8251106115765761151d8d8a84608001518f86600001516113888860a0015160016126c0565b60e08401525081516060830151875188908490811061153e5761153e6153d9565b602002602001015161155091906154a2565b8360e0015161155f9190615469565b6115699190615480565b6115739084615456565b92505b8160200151826060015161158a91906154a2565b84828151811061159c5761159c6153d9565b6020908102919091010152600101611333565b5050995099975050505050505050565b6000805b89518110156115fb578381815181106115de576115de6153d9565b6020026020010151826115f19190615456565b91506001016115c3565b5060001984141580156116305750620186a0611619816103e8615456565b6116239086615469565b61162d9190615480565b81115b156116875761168086868a8560008e8e81518110611650576116506153d9565b60200260200101516001600160a01b03166001600160a01b03168152602001908152602001600020548d8c612e18565b50506116bc565b828881518110611699576116996153d9565b60200260200101516116af87878b86898f611c21565b6116b99190615456565b90505b98975050505050505050565b604051636eb1769f60e11b81523060048201526001600160a01b03828116602483015283919085169063dd62ed3e90604401602060405180830381865afa158015611717573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061173b9190615403565b101561176e576117566001600160a01b0384168260006131c5565b61176e6001600160a01b03841682600160ff1b6131c5565b505050565b6000818311611782578161072a565b5090919050565b6000808260000361179957600a92505b8284116117ab57506000905080611145565b6117e46040518060c001604052806000815260200160608152602001606081526020016060815260200160008152602001600081525090565b6117ed886132da565b8082526000190161181057611806898989898989613301565b9250925050611145565b60405163430ffb1760e01b81526001600160a01b038a169063430ffb1790611847908b908b908a908c906213c68090600401615566565b600060405180830381865afa158015611864573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261188c9190810190615602565b506060840152604083015260208201819052518015611c0b5760005b81811015611c095782516119b857826040015181815181106118cc576118cc6153d9565b602002602001015187106118fd57826040015181815181106118f0576118f06153d9565b60200260200101516118ff565b865b6080840152604083015180518290811061191b5761191b6153d9565b6020026020010151871061194c578260600151818151811061193f5761193f6153d9565b602002602001015161199d565b82604001518181518110611962576119626153d9565b60200260200101518784606001518381518110611981576119816153d9565b60200260200101516119939190615469565b61199d9190615480565b60a084015260808301516119b190886154a2565b9650611ab6565b826060015181815181106119ce576119ce6153d9565b602002602001015187106119ff57826060015181815181106119f2576119f26153d9565b6020026020010151611a01565b865b60a08401526060830151805182908110611a1d57611a1d6153d9565b60200260200101518710611a4e5782604001518181518110611a4157611a416153d9565b6020026020010151611a9f565b82606001518181518110611a6457611a646153d9565b60200260200101518784604001518381518110611a8357611a836153d9565b6020026020010151611a959190615469565b611a9f9190615480565b608084015260a0830151611ab390886154a2565b96505b8587108015611ac457508615155b15611ace57600096505b60a083015115611bfb578a6001600160a01b0316630adb2d8584602001518381518110611afd57611afd6153d9565b60200260200101518b86608001518c8860a00151306040518763ffffffff1660e01b8152600401611b3396959493929190615703565b6020604051808303816000875af1158015611b52573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611b769190615403565b611b809085615456565b9350826080015185611b929190615456565b94507ff63c9c64ebdd1eb99706ca3f7489f7fbdd9c8756363cef40b2fc6e293fa150ec83602001518281518110611bcb57611bcb6153d9565b60200260200101518a85608001518b8760a0015130604051611bf296959493929190615703565b60405180910390a15b8615611c09576001016118a8565b505b5050611145565b6000818310611782578161072a565b6000821561059557611c966040518061018001604052806000815260200160006001600160a01b03168152602001600081526020016000815260200160008152602001600081526020016060815260200160008152602001600081526020016060815260200160608152602001600081525090565b828681518110611ca857611ca86153d9565b6020908102919091018101516001600160a01b0316908201819052835182526040516370a0823160e01b81526370a0823190611ce89030906004016153ef565b602060405180830381865afa158015611d05573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d299190615403565b60a082015260005b81518110156123d0578087146123c857886001600160a01b031663dd27ede7308460200151878581518110611d6857611d686153d9565b602002602001015160016040518563ffffffff1660e01b8152600401611d9194939291906154b5565b60408051808303816000875af1158015611daf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611dd391906154df565b61010084015260e08301528351600090859083908110611df557611df56153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401611e2891906153ef565b602060405180830381865afa158015611e45573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611e699190615403565b90508260e001516000141580611e7e57508015155b156123c65782610120015151600003611f6d57611f608a6001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015611ed2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ef6919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611f33573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f57919061541c565b84518790612b9c565b6101408501526101208401525b60e08301511561218a576000611f9c878560e001518661010001518761012001518861014001518e8989613816565b90508015801590611fb0575060a084015115155b156120c057611fc3818560a00151611c12565b90506120328b8b8660200151898781518110611fe157611fe16153d9565b60200260200101518561012c8e60008e8c81518110612002576120026153d9565b60200260200101516001600160a01b03166001600160a01b031681526020019081526020016000205460006126c0565b5080915050858381518110612049576120496153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161207c91906153ef565b602060405180830381865afa158015612099573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906120bd9190615403565b91505b806120ea8c86602001518987815181106120dc576120dc6153d9565b6020026020010151866139e0565b6120f491906154a2565b6120fe9086615456565b9450858381518110612112576121126153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161214591906153ef565b602060405180830381865afa158015612162573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121869190615403565b9150505b80156122a75760006121ea8b8b8886815181106121a9576121a96153d9565b602002602001015187602001518661012c8e60008c602001516001600160a01b03166001600160a01b031681526020019081526020016000205460006126c0565b50905080156122a557836101400151838151811061220a5761220a6153d9565b60200260200101518461012001518a81518110612229576122296153d9565b60200260200101518561014001518b81518110612248576122486153d9565b60200260200101518661012001518681518110612267576122676153d9565b60200260200101518461227a9190615469565b6122849190615469565b61228e9190615480565b6122989190615480565b6122a29086615456565b94505b505b82602001516001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016122d791906153ef565b602060405180830381865afa1580156122f4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123189190615403565b610160840181905260a084015160408051808201909152601681527554532d32302062616c616e636520646563726561736560501b60208201529110156123725760405162461bcd60e51b81526004016112b39190615553565b508260a0015183610160015161238891906154a2565b8611156123c0578260a001518361016001516123a491906154a2565b6123ae90876154a2565b61016084015160a085015295506123c6565b506123d0565b505b600101611d31565b50509695505050505050565b8451606090806001600160401b038111156123f9576123f9614a52565b604051908082528060200260200182016040528015612422578160200160208202803683370190505b50915060005b818110156125ae5786810361247457848181518110612449576124496153d9565b6020026020010151838281518110612463576124636153d9565b6020026020010181815250506125a6565b6000848281518110612488576124886153d9565b60200260200101518683815181106124a2576124a26153d9565b60200260200101516124b49190615456565b905080156125a457866001600160a01b031663667df249308b8b815181106124de576124de6153d9565b60200260200101518c86815181106124f8576124f86153d9565b60209081029190910101516040516001600160e01b031960e086901b1681526001600160a01b03938416600482015291831660248301529190911660448201526064810184905260840160408051808303816000875af1158015612560573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061258491906154df565b50848381518110612597576125976153d9565b6020026020010181815250505b505b600101612428565b505095945050505050565b6060600082156125fb57828410156125ed57826125de85670de0b6b3a7640000615469565b6125e89190615480565b6125fe565b670de0b6b3a76400006125fe565b60005b8551909150806001600160401b0381111561261b5761261b614a52565b604051908082528060200260200182016040528015612644578160200160208202803683370190505b50925081156126b75760005b818110156126b557670de0b6b3a764000083888381518110612674576126746153d9565b60200260200101516126869190615469565b6126909190615480565b8482815181106126a2576126a26153d9565b6020908102919091010152600101612650565b505b50509392505050565b600080856000036126d6575060009050806107b4565b604051633744088160e11b81526001600160a01b0389811660048301528881166024830152600091908b1690636e88110290604401600060405180830381865afa158015612728573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526127509190810190615780565b50805160408051808201909152601a81527f54532d3135204e6f206c69717569646174696f6e20726f75746500000000000060208201529192506127a75760405162461bcd60e51b81526004016112b39190615553565b50604051637cbf210b60e11b81526000906001600160a01b038c169063f97e4216906127d99085908c906004016158f9565b602060405180830381865afa1580156127f6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061281a9190615403565b905085811161282b5760008061283c565b8761283c8d848e8e8e8e8e8d613ba0565b9350935050509850989650505050505050565b6000806000846001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161288091906153ef565b602060405180830381865afa15801561289d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128c19190615403565b90506000876001600160a01b031663dd27ede730898960016040518563ffffffff1660e01b81526004016128f894939291906154b5565b60408051808303816000875af1158015612916573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061293a91906154df565b509050600061295782871061294f5782612951565b865b84611c12565b90506129668989898487613e90565b9450945050505094509492505050565b60608061299d60405180606001604052806000815260200160608152602001600081525090565b89518082526001600160401b038111156129b9576129b9614a52565b6040519080825280602002602001820160405280156129e2578160200160208202803683370190505b5060208201525b805160408201511015612ab55789816040015181518110612a0c57612a0c6153d9565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401612a3f91906153ef565b602060405180830381865afa158015612a5c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612a809190615403565b8160200151826040015181518110612a9a57612a9a6153d9565b602090810291909101015260408101805160010190526129e9565b612b276040518061012001604052808d81526020018c81526020018b81526020018a6001600160a01b0316815260200183602001518152602001896001600160a01b03168152602001886001600160a01b03168152602001612b1a88620186a0611773565b8152602001869052614071565b909c909b509950505050505050505050565b6040516001600160a01b03831660248201526044810182905261176e90849063a9059cbb60e01b906064015b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b0319909316929092179091526143fc565b606080826001600160401b03811115612bb757612bb7614a52565b604051908082528060200260200182016040528015612be0578160200160208202803683370190505b509150826001600160401b03811115612bfb57612bfb614a52565b604051908082528060200260200182016040528015612c24578160200160208202803683370190505b50905060005b83811015612d8157848181518110612c4457612c446153d9565b60200260200101516001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015612c89573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612cad919061590c565b612cb890600a615a13565b828281518110612cca57612cca6153d9565b602002602001018181525050856001600160a01b031663b3596f07868381518110612cf757612cf76153d9565b60200260200101516040518263ffffffff1660e01b8152600401612d1b91906153ef565b602060405180830381865afa158015612d38573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d5c9190615403565b838281518110612d6e57612d6e6153d9565b6020908102919091010152600101612c2a565b50935093915050565b60008083831115612da657612d9f84846154a2565b9150612db3565b612db083856154a2565b90505b9250929050565b8151600090815b81811015612e0c57836001600160a01b0316858281518110612de557612de56153d9565b60200260200101516001600160a01b031603612e0457915061072d9050565b600101612dc1565b50600019949350505050565b60006060612e656040518060e0016040528060006001600160a01b031681526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b848781518110612e7757612e776153d9565b60209081029190910101516001600160a01b03168082526040516370a0823160e01b81526370a0823190612eaf9030906004016153ef565b602060405180830381865afa158015612ecc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ef09190615403565b60a0820152845160c082015284516001600160401b03811115612f1557612f15614a52565b604051908082528060200260200182016040528015612f3e578160200160208202803683370190505b50915060005b8160c00151811015612fe65787811480612f775750848181518110612f6b57612f6b6153d9565b60200260200101516000145b612fde57612fbd8a8360000151888481518110612f9657612f966153d9565b6020026020010151888581518110612fb057612fb06153d9565b602002602001015161284f565b9050838281518110612fd157612fd16153d9565b6020026020010181815250505b600101612f44565b5060005b8160c0015181101561311a578781148061301d5750848181518110613011576130116153d9565b60200260200101516000145b61311257828181518110613033576130336153d9565b602002602001015185828151811061304d5761304d6153d9565b60200260200101511115613112576130c88a8a888481518110613072576130726153d9565b60200260200101518560000151878681518110613091576130916153d9565b60200260200101518a87815181106130ab576130ab6153d9565b60200260200101516130bd91906154a2565b61012c8d60006126c0565b6060840181905260408401919091526130e19085615456565b935081604001518382815181106130fa576130fa6153d9565b6020026020010181815161310e9190615456565b9052505b600101612fea565b5080516040516370a0823160e01b81526001600160a01b03909116906370a082319061314a9030906004016153ef565b602060405180830381865afa158015613167573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061318b9190615403565b6080820181905260a0820151106131a35760006131b7565b8060a0015181608001516131b791906154a2565b925050965096945050505050565b80158061323f5750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa158015613219573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061323d9190615403565b155b6132aa5760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084016112b3565b6040516001600160a01b03831660248201526044810182905261176e90849063095ea7b360e01b90606401612b65565b600081516000036132ed57506000919050565b8180602001905181019061072d9190615403565b6000806133536040518061012001604052806060815260200160608152602001606081526020016000815260200160008152602001600081526020016000815260200160008152602001600081525090565b60405163430ffb1760e01b81526001600160a01b038a169063430ffb179061338a908b908b908a908c906213c68090600401615566565b600060405180830381865afa1580156133a7573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526133cf9190810190615602565b5060408401526020830152808252518015613809576000808a8060200190518101906133fb9190615a22565b925092505061340b8c8b8b6144ce565b61010085015260005b8381101561380557670de0b6b3a76400008560400151828151811061343b5761343b6153d9565b60200260200101518661010001516134539190615469565b61345d9190615480565b60c0860181905282906134709085615469565b61347a9190615480565b60a08601819052602086015180518b9291908490811061349c5761349c6153d9565b60200260200101516134ae9190615456565b116134c157670de0b6b3a764000061350a565b8460a00151856020015182815181106134dc576134dc6153d9565b60200260200101516134ee9190615456565b6135008a670de0b6b3a7640000615469565b61350a9190615480565b60e0860181905260208601518051670de0b6b3a764000092919084908110613534576135346153d9565b60200260200101516135469190615469565b6135509190615480565b856060018181525050670de0b6b3a76400008560e001518660400151838151811061357d5761357d6153d9565b602002602001015161358f9190615469565b6135999190615480565b608086015260608501518811806135b257506080850151155b156135fa5788888660a00151876020015184815181106135d4576135d46153d9565b60200260200101516135e69190615456565b6135f09190615456565b11613805576137fd565b84608001518d6001600160a01b0316630adb2d8587600001518481518110613624576136246153d9565b60200260200101518e89606001518f8b60800151306040518763ffffffff1660e01b815260040161365a96959493929190615703565b6020604051808303816000875af1158015613679573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061369d9190615403565b146040518060400160405280600f81526020016e53423a2057726f6e672076616c756560881b815250906136e45760405162461bcd60e51b81526004016112b39190615553565b507ff63c9c64ebdd1eb99706ca3f7489f7fbdd9c8756363cef40b2fc6e293fa150ec8560000151828151811061371c5761371c6153d9565b60200260200101518c87606001518d89608001513060405161374396959493929190615703565b60405180910390a1608085015161375a9087615456565b955084606001518761376c9190615456565b9650670de0b6b3a7640000856080015186610100015161378c9190615469565b6137969190615480565b60c0860181905282906137a99085615469565b6137b39190615480565b60a0860181905260608601516137c891615456565b89116137d55760006137f3565b84606001518560a001516137e99190615456565b6137f3908a6154a2565b9850878910613805575b600101613414565b5050505b5050965096945050505050565b600087156116bc578115613861576000613830838a611c12565b90508861383d828a615469565b6138479190615480565b61385190896154a2565b975061385d818a6154a2565b9850505b6000858581518110613875576138756153d9565b602002602001015187858151811061388f5761388f6153d9565b60200260200101518786815181106138a9576138a96153d9565b60200260200101518988815181106138c3576138c36153d9565b60200260200101516138d59190615469565b6138e790670de0b6b3a7640000615469565b6138f19190615480565b6138fb9190615480565b905088158015906139275750670de0b6b3a76400008961391b8a84615469565b6139259190615480565b115b613932576000613980565b670de0b6b3a7640000896139468a84615469565b6139509190615480565b61395a91906154a2565b6139648b8a611c12565b61397690670de0b6b3a7640000615469565b6139809190615480565b915081156139d357620186a06139ad83836139a38d670de0b6b3a7640000615469565b6105559190615480565b6139bc620186a06103e8615456565b6139c69190615469565b6139d09190615480565b91505b5098975050505050505050565b600080836001600160a01b03166370a08231306040518263ffffffff1660e01b8152600401613a0f91906153ef565b602060405180830381865afa158015613a2c573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a509190615403565b90506000866001600160a01b031663dd27ede730888860016040518563ffffffff1660e01b8152600401613a8794939291906154b5565b60408051808303816000875af1158015613aa5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613ac991906154df565b5090506000613ae5828610613ade5782612951565b8584611c12565b60405163667df24960e01b81523060048201526001600160a01b0389811660248301528881166044830152606482018390529192506000918a169063667df2499060840160408051808303816000875af1158015613b47573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b6b91906154df565b909550905080851115613b8557613b8281866154a2565b94505b613b928989898588613e90565b505050505050949350505050565b6000613bad8685896116c8565b6040516370a0823160e01b81526000906001600160a01b038716906370a0823190613bdc9030906004016153ef565b602060405180830381865afa158015613bf9573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613c1d9190615403565b6040516310fe133960e31b81529091506001600160a01b038916906387f099c890613c50908c9089908990600401615a50565b600060405180830381600087803b158015613c6a57600080fd5b505af1158015613c7e573d6000803e3d6000fd5b50506040516370a0823160e01b8152600092506001600160a01b03891691506370a0823190613cb19030906004016153ef565b602060405180830381865afa158015613cce573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613cf29190615403565b90508181116040518060400160405280601681526020017554532d32302062616c616e636520646563726561736560501b81525090613d445760405162461bcd60e51b81526004016112b39190615553565b50613d4f82826154a2565b92508380613ddf5750604051630a47e27160e21b81526001600160a01b03898116600483015260248201889052888116604483015260648201859052608482018790528c169063291f89c49060a401602060405180830381865afa158015613dbb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613ddf9190615a75565b604051806040016040528060128152602001711514cb4c4d881c1c9a58d9481a5b5c1858dd60721b81525090613e285760405162461bcd60e51b81526004016112b39190615553565b50604080516001600160a01b03808b1682528916602082015290810187905260608101879052608081018490527f5a821a618ddb1a1fd304234a69c9d7f20c129d122fcf35593d13a071926643079060a00160405180910390a1505098975050505050505050565b600080613ea76001600160a01b0386168886612b39565b6040516314b685e960e21b81526001600160a01b038781166004830152868116602483015260448201869052306064830152600091908916906352da17a4906084016080604051808303816000875af1158015613f08573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613f2c9190615a92565b5050604080516001600160a01b03808c1682528a1660208201529081018890523060608201526080810183905260a0810182905291945091507f1d1ba11e7ca20f5dc77d8cfd75b68d11520677808f89f6ba0f0e50dc52c450129060c00160405180910390a16040516370a0823160e01b81526000906001600160a01b038816906370a0823190613fc19030906004016153ef565b602060405180830381865afa158015613fde573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906140029190615403565b905080851161401257600061401c565b61401c81866154a2565b60408051808201909152600f81526e53423a2057726f6e672076616c756560881b602082015290935082156140645760405162461bcd60e51b81526004016112b39190615553565b5050509550959350505050565b60608061409f6040518060800160405280600081526020016060815260200160608152602001606081525090565b6020840151518082526001600160401b038111156140bf576140bf614a52565b6040519080825280602002602001820160405280156140e8578160200160208202803683370190505b5081519092506001600160401b0381111561410557614105614a52565b60405190808252806020026020018201604052801561412e578160200160208202803683370190505b5092506142078460a001516001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015614176573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061419a919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156141d7573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141fb919061541c565b60208601518351612b9c565b604083015260208201526000805b825181101561432e5785602001518181518110614234576142346153d9565b60200260200101516001600160a01b031686606001516001600160a01b03160361426057809150614326565b604086015181146143265760008061429786896040015181518110614287576142876153d9565b6020026020010151898786614779565b91509150818784815181106142ae576142ae6153d9565b602002602001018181516142c29190615456565b905250604088015186518291889181106142de576142de6153d9565b602002602001018181516142f29190615456565b905250875160408901518751889190811061430f5761430f6153d9565b60200260200101511061432357505061432e565b50505b600101614215565b5084600001518386604001518151811061434a5761434a6153d9565b6020026020010151108015614363575080856040015114155b156143f55760008061439485886040015181518110614384576143846153d9565b6020026020010151888686614779565b91509150818684815181106143ab576143ab6153d9565b602002602001018181516143bf9190615456565b905250604087015185518291879181106143db576143db6153d9565b602002602001018181516143ef9190615456565b90525050505b5050915091565b6000614451826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166149179092919063ffffffff16565b80519091501561176e578080602001905181019061446f9190615a75565b61176e5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016112b3565b600080846001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa15801561450f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614533919061541c565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614570573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614594919061541c565b90506000816001600160a01b031663b3596f07866040518263ffffffff1660e01b81526004016145c491906153ef565b602060405180830381865afa1580156145e1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146059190615403565b90506000826001600160a01b031663b3596f07866040518263ffffffff1660e01b815260040161463591906153ef565b602060405180830381865afa158015614652573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146769190615403565b9050846001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156146b6573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146da919061590c565b6146e590600a615a13565b82876001600160a01b031663313ce5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015614724573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614748919061590c565b61475390600a615a13565b61476584670de0b6b3a7640000615469565b61476f9190615469565b6109a29190615480565b60008084608001518381518110614792576147926153d9565b60200260200101516000146109cb576000620186a0808761010001516147b89190615456565b86604001518860400151815181106147d2576147d26153d9565b6020026020010151876020015187815181106147f0576147f06153d9565b60200260200101518860400151888151811061480e5761480e6153d9565b602002602001015189602001518b6040015181518110614830576148306153d9565b60200260200101518c8c6000015161484891906154a2565b6148529190615469565b61485c9190615469565b6148669190615480565b6148709190615480565b61487a9190615469565b6148849190615480565b90506149098660a001518760c00151886020015187815181106148a9576148a96153d9565b602002602001015189602001518a60400151815181106148cb576148cb6153d9565b60200260200101516148fa868c608001518b815181106148ed576148ed6153d9565b6020026020010151611c12565b61012c8c60e0015160006126c0565b909890975095505050505050565b6060611127848460008585600080866001600160a01b0316858760405161493e9190615ac8565b60006040518083038185875af1925050503d806000811461497b576040519150601f19603f3d011682016040523d82523d6000602084013e614980565b606091505b50915091506109ac87838387606083156149fb5782516000036149f4576001600160a01b0385163b6149f45760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016112b3565b5081611127565b6111278383815115614a105781518083602001fd5b8060405162461bcd60e51b81526004016112b39190615553565b6001600160a01b0381168114614a3f57600080fd5b50565b8035614a4d81614a2a565b919050565b634e487b7160e01b600052604160045260246000fd5b604051608081016001600160401b0381118282101715614a8a57614a8a614a52565b60405290565b604051601f8201601f191681016001600160401b0381118282101715614ab857614ab8614a52565b604052919050565b60006001600160401b03821115614ad957614ad9614a52565b5060051b60200190565b600082601f830112614af457600080fd5b81356020614b09614b0483614ac0565b614a90565b82815260059290921b84018101918181019086841115614b2857600080fd5b8286015b84811015614b4c578035614b3f81614a2a565b8352918301918301614b2c565b509695505050505050565b600082601f830112614b6857600080fd5b81356020614b78614b0483614ac0565b82815260059290921b84018101918181019086841115614b9757600080fd5b8286015b84811015614b4c5780358352918301918301614b9b565b600080600080600060a08688031215614bca57600080fd5b8535614bd581614a2a565b945060208601356001600160401b0380821115614bf157600080fd5b614bfd89838a01614ae3565b9550604088013594506060880135915080821115614c1a57600080fd5b50614c2788828901614b57565b95989497509295608001359392505050565b600081518084526020808501945080840160005b83811015614c6957815187529582019590820190600101614c4d565b509495945050505050565b60208152600061072a6020830184614c39565b60008060008060008060c08789031215614ca057600080fd5b8635614cab81614a2a565b95506020870135614cbb81614a2a565b945060408701359350606087013592506080870135915060a08701356001600160401b03811115614ceb57600080fd5b614cf789828a01614ae3565b9150509295509295509295565b60008060008060808587031215614d1a57600080fd5b8435614d2581614a2a565b935060208501356001600160401b0380821115614d4157600080fd5b614d4d88838901614ae3565b9450604087013593506060870135915080821115614d6a57600080fd5b50614d7787828801614b57565b91505092959194509250565b60008060408385031215614d9657600080fd5b8235614da181614a2a565b91506020830135614db181614a2a565b809150509250929050565b600080600080600080600080610100898b031215614dd957600080fd5b614de289614a42565b975060208901356001600160401b0380821115614dfe57600080fd5b614e0a8c838d01614ae3565b985060408b0135975060608b0135915080821115614e2757600080fd5b614e338c838d01614b57565b965060808b0135955060a08b0135945060c08b0135915080821115614e5757600080fd5b614e638c838d01614b57565b935060e08b0135915080821115614e7957600080fd5b50614e868b828c01614b57565b9150509295985092959890939650565b604081526000614ea96040830185614c39565b82810360208401526105f08185614c39565b8015158114614a3f57600080fd5b600080600080600080600080610100898b031215614ee657600080fd5b8835614ef181614a2a565b97506020890135614f0181614a2a565b96506040890135614f1181614a2a565b95506060890135614f2181614a2a565b94506080890135935060a0890135925060c0890135915060e0890135614f4681614ebb565b809150509295985092959890939650565b600080600060608486031215614f6c57600080fd5b8335614f7781614a2a565b92506020840135614f8781614a2a565b91506040840135614f9781614a2a565b809150509250925092565b60008060008060808587031215614fb857600080fd5b8435614fc381614a2a565b93506020850135614fd381614a2a565b92506040850135614fe381614a2a565b9396929550929360600135925050565b600080600080600080600060e0888a03121561500e57600080fd5b873596506020880135955060408801356001600160401b0381111561503257600080fd5b61503e8a828b01614ae3565b955050606088013561504f81614a2a565b9350608088013561505f81614a2a565b925060a088013561506f81614a2a565b8092505060c0880135905092959891949750929550565b6000806000806080858703121561509c57600080fd5b84356001600160401b03808211156150b357600080fd5b6150bf88838901614ae3565b955060208701359150808211156150d557600080fd5b506150e287828801614b57565b9350506040850135915060608501356150fa81614a2a565b939692955090935050565b60006001600160401b0382111561511e5761511e614a52565b50601f01601f191660200190565b60008060008060008060c0878903121561514557600080fd5b863561515081614a2a565b955060208701356001600160401b0381111561516b57600080fd5b8701601f8101891361517c57600080fd5b803561518a614b0482615105565b8181528a602083850101111561519f57600080fd5b816020840160208301376000602083830101528097505050506151c460408801614a42565b93506151d260608801614a42565b92506080870135915060a087013590509295509295509295565b60008060006060848603121561520157600080fd5b83359250602084013591506040840135614f9781614a2a565b60008060008060008060008060006101208a8c03121561523957600080fd5b6152428a614a42565b985061525060208b01614a42565b975060408a0135965060608a01356001600160401b038082111561527357600080fd5b61527f8d838e01614ae3565b975061528d60808d01614a42565b965060a08c0135955060c08c01359150808211156152aa57600080fd5b6152b68d838e01614ae3565b945060e08c01359150808211156152cc57600080fd5b506152d98c828d01614b57565b9250506101008a013590509295985092959850929598565b6040815260006153046040830185614c39565b90508260208301529392505050565b600080600080600080600080610100898b03121561533057600080fd5b88356001600160401b038082111561534757600080fd5b6153538c838d01614ae3565b995060208b0135985060408b013591508082111561537057600080fd5b61537c8c838d01614b57565b975061538a60608c01614a42565b965061539860808c01614a42565b955060a08b0135945060c08b01359150808211156153b557600080fd5b506153c28b828c01614b57565b92505060e089013590509295985092959890939650565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b0391909116815260200190565b60006020828403121561541557600080fd5b5051919050565b60006020828403121561542e57600080fd5b815161543981614a2a565b9392505050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561072d5761072d615440565b808202811582820484141761072d5761072d615440565b60008261549d57634e487b7160e01b600052601260045260246000fd5b500490565b8181038181111561072d5761072d615440565b6001600160a01b039485168152928416602084015292166040820152901515606082015260800190565b600080604083850312156154f257600080fd5b505080516020909101519092909150565b60005b8381101561551e578181015183820152602001615506565b50506000910152565b6000815180845261553f816020860160208601615503565b601f01601f19169290920160200192915050565b60208152600061072a6020830184615527565b60a08152600061557960a0830188615527565b6001600160a01b03968716602084015260408301959095525091909316606082015260800191909152919050565b600082601f8301126155b857600080fd5b815160206155c8614b0483614ac0565b82815260059290921b840181019181810190868411156155e757600080fd5b8286015b84811015614b4c57805183529183019183016155eb565b6000806000806080858703121561561857600080fd5b84516001600160401b038082111561562f57600080fd5b818701915087601f83011261564357600080fd5b81516020615653614b0483614ac0565b82815260059290921b8401810191818101908b84111561567257600080fd5b948201945b8386101561569957855161568a81614a2a565b82529482019490820190615677565b918a01519198509093505050808211156156b257600080fd5b6156be888389016155a7565b945060408701519150808211156156d457600080fd5b6156e0888389016155a7565b935060608701519150808211156156f657600080fd5b50614d77878288016155a7565b6001600160a01b039687168152948616602086015260408501939093529084166060840152608083015290911660a082015260c00190565b600082601f83011261574c57600080fd5b815161575a614b0482615105565b81815284602083860101111561576f57600080fd5b611127826020830160208701615503565b600080604080848603121561579457600080fd5b83516001600160401b03808211156157ab57600080fd5b818601915086601f8301126157bf57600080fd5b815160206157cf614b0483614ac0565b82815260079290921b8401810191818101908a8411156157ee57600080fd5b948201945b83861015615868576080868c03121561580c5760008081fd5b615814614a68565b865161581f81614a2a565b81528684015161582e81614a2a565b818501528688015161583f81614a2a565b8189015260608781015161585281614a2a565b90820152825260809590950194908201906157f3565b9189015191975090945050508083111561588157600080fd5b505061588f8582860161573b565b9150509250929050565b600081518084526020808501945080840160005b83811015614c6957815180516001600160a01b039081168952848201518116858a01526040808301518216908a01526060918201511690880152608090960195908201906001016158ad565b6040815260006153046040830185615899565b60006020828403121561591e57600080fd5b815160ff8116811461543957600080fd5b600181815b8085111561596a57816000190482111561595057615950615440565b8085161561595d57918102915b93841c9390800290615934565b509250929050565b6000826159815750600161072d565b8161598e5750600061072d565b81600181146159a457600281146159ae576159ca565b600191505061072d565b60ff8411156159bf576159bf615440565b50506001821b61072d565b5060208310610133831016604e8410600b84101617156159ed575081810a61072d565b6159f7838361592f565b8060001904821115615a0b57615a0b615440565b029392505050565b600061072a60ff841683615972565b600080600060608486031215615a3757600080fd5b8351925060208401519150604084015190509250925092565b606081526000615a636060830186615899565b60208301949094525060400152919050565b600060208284031215615a8757600080fd5b815161543981614ebb565b60008060008060808587031215615aa857600080fd5b505082516020840151604085015160609095015191969095509092509050565b60008251615ada818460208701615503565b919091019291505056fea2646970667358221220d68b96dfcb6df9a6deef8f050b4c7cdbb87017d351287a036ffdca1abebf02cd64736f6c63430008110033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "calcInvestedAssets(address[],uint256[],uint256,ITetuConverter)": {
        "details": "This is writable function because we need to update current balances in the internal protocols.",
        "returns": {
          "amountOut": "Invested asset amount under control (in terms of {asset})"
        }
      },
      "closePosition(ITetuConverter,address,address,uint256)": {
        "params": {
          "amountToRepay": "Amount to repay in terms of {borrowAsset}"
        },
        "returns": {
          "repaidAmountOut": "Amount that was actually repaid",
          "returnedAssetAmountOut": "Amount of collateral received back after repaying"
        }
      },
      "closePositionsToGetAmount(ITetuConverter,ITetuLiquidator,uint256,mapping(address => uint256) storage,uint256,address[])": {
        "details": "We assume here that this function is called before closing any positions in the current block",
        "params": {
          "liquidationThresholds": "Min allowed amounts-out for liquidations",
          "requestedAmount": "Requested amount of main asset that should be added to the current balance"
        },
        "returns": {
          "expectedAmount": "Main asset amount expected to be received on balance after all conversions and swaps"
        }
      },
      "getOracleAssetsPrice(ITetuConverter,address,address)": {
        "params": {
          "converter": "The Tetu converter.",
          "tokenA": "The first token address.",
          "tokenB": "The second token address."
        },
        "returns": {
          "_0": "The price ratio of the two tokens."
        }
      },
      "getTokenAmounts(ITetuConverter,address[],uint256,uint256[],uint256)": {
        "params": {
          "collaterals_": "Amounts of main asset that can be used as collateral to borrow {tokens_}",
          "thresholdMainAsset_": "Value of liquidation threshold for the main (collateral) asset",
          "tokens_": "Tokens received from {_depositorPoolAssets}"
        },
        "returns": {
          "tokenAmountsOut": "Amounts available for deposit"
        }
      },
      "liquidate(ITetuConverter,ITetuLiquidator,address,address,uint256,uint256,uint256,bool)": {
        "params": {
          "receivedAmountOut": "Amount of {tokenOut_} has been returned by the liquidator",
          "skipValidation": "Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)",
          "spentAmountIn": "Amount of {tokenIn} has been consumed by the liquidator"
        }
      },
      "makeRequestedAmount(address[],uint256,uint256[],ITetuConverter,ITetuLiquidator,uint256,uint256[],mapping(address => uint256) storage)": {
        "params": {
          "amountsToConvert_": "Amounts available for conversion after withdrawing from the pool",
          "expectedMainAssetAmounts": "Amounts of main asset that we expect to receive after conversion amountsToConvert_",
          "indexAsset_": "Index of main {asset} in {tokens}",
          "requestedAmount": "Amount to be withdrawn in terms of the asset in addition to the exist balance.        Max uint means attempt to withdraw all possible invested assets.",
          "tokens_": "Results of _depositorPoolAssets() call (list of depositor's asset in proper order)"
        },
        "returns": {
          "expectedAmount": "Expected total amount of main asset after all conversions, swaps and repays"
        }
      },
      "openPosition(ITetuConverter,bytes,address,address,uint256,uint256)": {
        "params": {
          "amountIn_": "Meaning depends on {entryData_}.",
          "entryData_": "Encoded entry kind and additional params if necessary (set of params depends on the kind)                   See TetuConverter\\EntryKinds.sol\\ENTRY_KIND_XXX constants for possible entry kinds                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible."
        }
      },
      "postWithdrawActions(ITetuConverter,address[],uint256,uint256[],uint256,uint256,uint256[],uint256[])": {
        "params": {
          "amountsToConvert": "Amounts of {tokens} to be converted, they are located on the balance before withdraw",
          "withdrawnAmounts": "Amounts of {tokens} that were withdrew from the pool"
        }
      },
      "recycle(ITetuConverter,address,uint256,address[],ITetuLiquidator,mapping(address => uint256) storage,address[],uint256[],uint256)": {
        "params": {
          "asset": "Underlying asset",
          "compoundRatio": "Compound ration in the range [0...COMPOUND_DENOMINATOR]",
          "liquidationThresholds": "Liquidation thresholds for rewards tokens",
          "performanceFee": "Performance fee in the range [0...FEE_DENOMINATOR]",
          "rewardAmounts": "Amounts of {rewardTokens_}; we assume, there are no zero amounts here",
          "rewardTokens": "Full list of reward tokens received from tetuConverter and depositor",
          "tokens": "tokens received from {_depositorPoolAssets}"
        },
        "returns": {
          "amountToPerformanceAndInsurance": "Amount of underlying to be sent to performance receiver and insurance",
          "amountsToForward": "Amounts of {rewardTokens} to be sent to forwarder, zero amounts are allowed here"
        }
      },
      "swapToGivenAmountAndSendToConverter(uint256,uint256,address[],address,address,address,mapping(address => uint256) storage)": {
        "params": {
          "amount_": "Amount of the main asset requested by converter",
          "asset": "Main asset or underlying (it can be different from tokens[indexTheAsset])",
          "indexTheAsset": "Index of the asset required by converter in the {tokens}"
        },
        "returns": {
          "amountOut": "Amount of the main asset sent to converter"
        }
      }
    },
    "stateVariables": {
      "DEFAULT_LIQUIDATION_THRESHOLD": {
        "details": "Absolute value for any token"
      },
      "GAP_CONVERSION": {
        "details": "We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap"
      }
    },
    "version": 1
  },
  "userdoc": {
    "events": {
      "ClosePosition(address,address,uint256,address,uint256,uint256)": {
        "notice": "Some borrow(s) was/were repaid"
      },
      "Liquidation(address,address,uint256,uint256,uint256)": {
        "notice": "A liquidation was made"
      },
      "OpenPosition(address,address,uint256,address,uint256,address)": {
        "notice": "A borrow was made"
      }
    },
    "kind": "user",
    "methods": {
      "calcInvestedAssets(address[],uint256[],uint256,ITetuConverter)": {
        "notice": "Calculate amount we will receive when we withdraw all from pool"
      },
      "closePosition(ITetuConverter,address,address,uint256)": {
        "notice": "Close the given position, pay {amountToRepay}, return collateral amount in result"
      },
      "closePositionsToGetAmount(ITetuConverter,ITetuLiquidator,uint256,mapping(address => uint256) storage,uint256,address[])": {
        "notice": "Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance"
      },
      "coverPossibleStrategyLoss(uint256,uint256,address)": {
        "notice": "Register income and cover possible loss"
      },
      "getOracleAssetsPrice(ITetuConverter,address,address)": {
        "notice": "Get the price ratio of the two given tokens from the oracle."
      },
      "getTokenAmounts(ITetuConverter,address[],uint256,uint256[],uint256)": {
        "notice": "Make borrow and save amounts of tokens available for deposit to tokenAmounts"
      },
      "liquidate(ITetuConverter,ITetuLiquidator,address,address,uint256,uint256,uint256,bool)": {
        "notice": "Make liquidation if estimated amountOut exceeds the given threshold"
      },
      "makeRequestedAmount(address[],uint256,uint256[],ITetuConverter,ITetuLiquidator,uint256,uint256[],mapping(address => uint256) storage)": {
        "notice": "Convert {amountsToConvert_} to the main {asset}         Swap leftovers (if any) to the main asset.         If result amount is less than expected, try to close any other available debts (1 repay per block only)"
      },
      "openPosition(ITetuConverter,bytes,address,address,uint256,uint256)": {
        "notice": "Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}         Max possible collateral should be approved before calling of this function."
      },
      "postWithdrawActions(ITetuConverter,address[],uint256,uint256[],uint256,uint256,uint256[],uint256[])": {
        "notice": "Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}"
      },
      "postWithdrawActionsEmpty(ITetuConverter,address[],uint256,uint256[])": {
        "notice": "return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}"
      },
      "recycle(ITetuConverter,address,uint256,address[],ITetuLiquidator,mapping(address => uint256) storage,address[],uint256[],uint256)": {
        "notice": "Recycle the amounts: split each amount on tree parts: performance+insurance (P), forwarder (F), compound (C)         Liquidate P+C, send F to the forwarder. We have two kinds of rewards: 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets) 2) any other rewards All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound   Compound-part of Rewards-2 can be liquidated   Compound part of Rewards-1 should be just left on the balance   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.   Performance amounts are liquidated, result amount of underlying is returned in {amountToPerformanceAndInsurance}"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}