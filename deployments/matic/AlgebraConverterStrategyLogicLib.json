{
  "address": "0x79D957446Db135EA3a5f3A02a1770c42F7650aB6",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fee0",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "fee1",
          "type": "uint256"
        }
      ],
      "name": "AlgebraFeesClaimed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "reward",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "bonusReward",
          "type": "uint256"
        }
      ],
      "name": "AlgebraRewardsClaimed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "loss",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "profitToCover",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "coveredByRewards",
          "type": "uint256"
        }
      ],
      "name": "Rebalanced",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "asset",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "internalType": "address[]",
          "name": "rewardTokens",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        }
      ],
      "name": "calcEarned",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IAlgebraPool",
          "name": "pool",
          "type": "IAlgebraPool"
        },
        {
          "internalType": "int24",
          "name": "lowerTick",
          "type": "int24"
        },
        {
          "internalType": "int24",
          "name": "upperTick",
          "type": "int24"
        },
        {
          "internalType": "bool",
          "name": "depositorSwapTokens",
          "type": "bool"
        }
      ],
      "name": "getEntryData",
      "outputs": [
        {
          "internalType": "bytes",
          "name": "entryData",
          "type": "bytes"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x609e23197e3f2400a5baa143317944fcecf8212b50902a02ebd3e6e415e5d670",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0x79D957446Db135EA3a5f3A02a1770c42F7650aB6",
    "transactionIndex": 38,
    "gasUsed": "5063237",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000400000000000000000000000800000040000800000000100000000000000000000000000000000000200000000000000000000000080000000000000000000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000400000000004000000000000000000001000000000000008000000000000000100000000000000000000000000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x2d7cfa21662ff4056742a438418cbfb7322e07392e2022a7e637a6e200ef97c2",
    "transactionHash": "0x609e23197e3f2400a5baa143317944fcecf8212b50902a02ebd3e6e415e5d670",
    "logs": [
      {
        "transactionIndex": 38,
        "blockNumber": 46770618,
        "transactionHash": "0x609e23197e3f2400a5baa143317944fcecf8212b50902a02ebd3e6e415e5d670",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bbbbb8c4364ec2ce52c59d2ed3e56f307e529a94",
          "0x0000000000000000000000002c74ca71679cf1299936d6104d825c965448907b"
        ],
        "data": "0x000000000000000000000000000000000000000000000000022da29a9ec1ce0000000000000000000000000000000000000000000000000655062e1c01f539a800000000000000000000000000000000000000000000009637edb2a9e5b7916800000000000000000000000000000000000000000000000652d88b8163336ba80000000000000000000000000000000000000000000000963a1b554484795f68",
        "logIndex": 2656,
        "blockHash": "0x2d7cfa21662ff4056742a438418cbfb7322e07392e2022a7e637a6e200ef97c2"
      }
    ],
    "blockNumber": 46770618,
    "cumulativeGasUsed": "25129820",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 6,
  "solcInputHash": "9a67e5b94f62a52096a4af4ce8592dcc",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee0\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"fee1\",\"type\":\"uint256\"}],\"name\":\"AlgebraFeesClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"reward\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"bonusReward\",\"type\":\"uint256\"}],\"name\":\"AlgebraRewardsClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"loss\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"profitToCover\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"coveredByRewards\",\"type\":\"uint256\"}],\"name\":\"Rebalanced\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"asset\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"}],\"name\":\"calcEarned\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IAlgebraPool\",\"name\":\"pool\",\"type\":\"IAlgebraPool\"},{\"internalType\":\"int24\",\"name\":\"lowerTick\",\"type\":\"int24\"},{\"internalType\":\"int24\",\"name\":\"upperTick\",\"type\":\"int24\"},{\"internalType\":\"bool\",\"name\":\"depositorSwapTokens\",\"type\":\"bool\"}],\"name\":\"getEntryData\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"entryData\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"initStrategyState(AlgebraConverterStrategyLogicLib.State storage,address[2],int24,int24,address,bool,uint256[4],uint256[4])\":{\"params\":{\"controllerPool\":\"[controller, pool]\",\"fuseThresholdsA\":\"Fuse thresholds for token A (stable pool only)\",\"fuseThresholdsB\":\"Fuse thresholds for token B (stable pool only)\"}},\"needStrategyRebalance(PairBasedStrategyLogicLib.PairState storage,ITetuConverter)\":{\"returns\":{\"needRebalance\":\"A boolean indicating if {rebalanceNoSwaps} should be called\"}},\"rebalanceNoSwaps(PairBasedStrategyLogicLib.PairState storage,address[2],uint256,uint256,address,bool,mapping(address => uint256) storage)\":{\"params\":{\"checkNeedRebalance_\":\"True if the function should ensure that the rebalance is required\",\"converterLiquidator\":\"[TetuConverter, TetuLiquidator]\",\"totalAssets_\":\"Current value of totalAssets()\"},\"returns\":{\"tokenAmounts\":\"Token amounts for deposit. If length == 0 - rebalance wasn't made and no deposit is required.\"}},\"withdrawByAggStep(address[5],uint256[4],bytes,bytes,PairBasedStrategyLogicLib.PairState storage,mapping(address => uint256) storage)\":{\"params\":{\"addr_\":\"[tokenToSwap, aggregator, controller, converter, splitter]\",\"values_\":\"[amountToSwap_, profitToCover, oldTotalAssets, entryToPool]\"},\"returns\":{\"completed\":\"All debts were closed, leftovers were swapped to proper proportions\",\"tokenAmountsOut\":\"Amounts to be deposited to pool. This array is empty if no deposit allowed/required.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"getPropNotUnderlying18(PairBasedStrategyLogicLib.PairState storage)\":{\"notice\":\"Get proportion of not-underlying in the pool, [0...1e18]         prop.underlying : prop.not.underlying = 1e18 - PropNotUnderlying18 : propNotUnderlying18\"},\"needStrategyRebalance(PairBasedStrategyLogicLib.PairState storage,ITetuConverter)\":{\"notice\":\"Determine if the strategy needs to be rebalanced.\"},\"rebalanceNoSwaps(PairBasedStrategyLogicLib.PairState storage,address[2],uint256,uint256,address,bool,mapping(address => uint256) storage)\":{\"notice\":\"Make rebalance without swaps (using borrowing only).\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/algebra/AlgebraConverterStrategyLogicLib.sol\":\"AlgebraConverterStrategyLogicLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IControllable {\\n\\n  function isController(address _contract) external view returns (bool);\\n\\n  function isGovernance(address _contract) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0xc2ef11f0141e7e1a5df255be2e1552044deed377349cb886908f3f10ded57fa8\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IController {\\n\\n  // --- DEPENDENCY ADDRESSES\\n  function governance() external view returns (address);\\n\\n  function voter() external view returns (address);\\n\\n  function liquidator() external view returns (address);\\n\\n  function forwarder() external view returns (address);\\n\\n  function investFund() external view returns (address);\\n\\n  function veDistributor() external view returns (address);\\n\\n  function platformVoter() external view returns (address);\\n\\n  // --- VAULTS\\n\\n  function vaults(uint id) external view returns (address);\\n\\n  function vaultsList() external view returns (address[] memory);\\n\\n  function vaultsListLength() external view returns (uint);\\n\\n  function isValidVault(address _vault) external view returns (bool);\\n\\n  // --- restrictions\\n\\n  function isOperator(address _adr) external view returns (bool);\\n\\n\\n}\\n\",\"keccak256\":\"0x86716b8a4775605c31b8bb9f90f8f4a18b709ff4435182f3a148803368060a8c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x5f43ed533d0fc4dc2f8f081d2c4b77960f3e908d5f7359096b385e5673f1ba0c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n     */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n     */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n     */\\n  function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x953f20efa64081a325109a0e03602b889d2819c2b51c1e1fb21a062feeda74f3\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x9f69f84d864c2a84de9321871aa52f6f70d14afe46badbcd37c0d4f22af75e7b\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IForwarder {\\n\\n  function tetu() external view returns (address);\\n  function tetuThreshold() external view returns (uint);\\n\\n  function tokenPerDestinationLength(address destination) external view returns (uint);\\n\\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\\n\\n  function amountPerDestination(address token, address destination) external view returns (uint amount);\\n\\n  function registerIncome(\\n    address[] memory tokens,\\n    uint[] memory amounts,\\n    address vault,\\n    bool isDistribute\\n  ) external;\\n\\n  function distributeAll(address destination) external;\\n\\n  function distribute(address token) external;\\n\\n  function setInvestFundRatio(uint value) external;\\n\\n  function setGaugesRatio(uint value) external;\\n\\n}\\n\",\"keccak256\":\"0x687c497fc034e8d64bca403bac1bf4cd7bd1f107df414c2657325c1b3ab92822\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ISplitter {\\n\\n  function init(address controller_, address _asset, address _vault) external;\\n\\n  // *************** ACTIONS **************\\n\\n  function withdrawAllToVault() external;\\n\\n  function withdrawToVault(uint256 amount) external;\\n\\n  function coverPossibleStrategyLoss(uint earned, uint lost) external;\\n\\n  function doHardWork() external;\\n\\n  function investAll() external;\\n\\n  // **************** VIEWS ***************\\n\\n  function asset() external view returns (address);\\n\\n  function vault() external view returns (address);\\n\\n  function totalAssets() external view returns (uint256);\\n\\n  function isHardWorking() external view returns (bool);\\n\\n  function strategies(uint i) external view returns (address);\\n\\n  function strategiesLength() external view returns (uint);\\n\\n  function HARDWORK_DELAY() external view returns (uint);\\n\\n  function lastHardWorks(address strategy) external view returns (uint);\\n\\n  function pausedStrategies(address strategy) external view returns (bool);\\n\\n  function pauseInvesting(address strategy) external;\\n\\n  function continueInvesting(address strategy, uint apr) external;\\n\\n}\\n\",\"keccak256\":\"0x68f37a5089c98097159e7f18ef04c42d15e10e6c11602e47bc6092708c11e5fc\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IStrategyV2 {\\n\\n  function NAME() external view returns (string memory);\\n\\n  function strategySpecificName() external view returns (string memory);\\n\\n  function PLATFORM() external view returns (string memory);\\n\\n  function STRATEGY_VERSION() external view returns (string memory);\\n\\n  function asset() external view returns (address);\\n\\n  function splitter() external view returns (address);\\n\\n  function compoundRatio() external view returns (uint);\\n\\n  function totalAssets() external view returns (uint);\\n\\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\\n  function isReadyToHardWork() external view returns (bool);\\n\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawAllToSplitter() external returns (uint strategyLoss);\\n\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawToSplitter(uint amount) external returns (uint strategyLoss);\\n\\n  /// @notice Stakes everything the strategy holds into the reward pool.\\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\\n  ///                                       It can be false if we know exactly, that the amount is already actual.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function investAll(\\n    uint amount_,\\n    bool updateTotalAssetsBeforeInvest_\\n  ) external returns (\\n    uint strategyLoss\\n  );\\n\\n  function doHardWork() external returns (uint earned, uint lost);\\n\\n  function setCompoundRatio(uint value) external;\\n\\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\\n  ///         0 means no deposit is allowed at this moment\\n  function capacity() external view returns (uint);\\n\\n  /// @notice {performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\\n  function performanceReceiver() external view returns (address);\\n\\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\\n  /// @dev use FEE_DENOMINATOR\\n  function performanceFee() external view returns (uint);\\n}\\n\",\"keccak256\":\"0xc7dac6097df7310b510f1027ef9c1bd3ccd6a202ca69582f68233ee798f7c312\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IStrategyV2.sol\\\";\\n\\ninterface IStrategyV3 is IStrategyV2 {\\n  struct BaseState {\\n    /// @dev Underlying asset\\n    address asset;\\n\\n    /// @dev Linked splitter\\n    address splitter;\\n\\n    /// @notice {performanceFee}% of total profit is sent to {performanceReceiver} before compounding\\n    /// @dev governance by default\\n    address performanceReceiver;\\n\\n    /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\\n    /// @dev {DEFAULT_PERFORMANCE_FEE} by default, FEE_DENOMINATOR is used\\n    uint performanceFee;\\n\\n    /// @notice Ratio to split performance fee on toPerf + toInsurance, [0..100_000]\\n    ///         100_000 - send full amount toPerf, 0 - send full amount toInsurance.\\n    uint performanceFeeRatio;\\n\\n    /// @dev Percent of profit for autocompound inside this strategy.\\n    uint compoundRatio;\\n\\n    /// @dev Represent specific name for this strategy. Should include short strategy name and used assets. Uniq across the vault.\\n    string strategySpecificName;\\n  }\\n}\\n\",\"keccak256\":\"0xe8a0179a82c40ba0c372486c5ebcc7df6431216c8c0d91cc408fb8f881e72f70\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface ITetuLiquidator {\\n\\n  struct PoolData {\\n    address pool;\\n    address swapper;\\n    address tokenIn;\\n    address tokenOut;\\n  }\\n\\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\\n\\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\\n\\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\\n\\n  function buildRoute(\\n    address tokenIn,\\n    address tokenOut\\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\\n\\n  function liquidate(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n  function liquidateWithRoute(\\n    PoolData[] memory route,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n\\n}\\n\",\"keccak256\":\"0xd5fe6f3ab750cc2d23f573597db5607c701e74c39e13c20c07a921a26c6d5012\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IVaultInsurance.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISplitter.sol\\\";\\n\\ninterface ITetuVaultV2 {\\n\\n  function splitter() external view returns (ISplitter);\\n\\n  function insurance() external view returns (IVaultInsurance);\\n\\n  function depositFee() external view returns (uint);\\n\\n  function withdrawFee() external view returns (uint);\\n\\n  function init(\\n    address controller_,\\n    IERC20 _asset,\\n    string memory _name,\\n    string memory _symbol,\\n    address _gauge,\\n    uint _buffer\\n  ) external;\\n\\n  function setSplitter(address _splitter) external;\\n\\n  function coverLoss(uint amount) external;\\n\\n  function initInsurance(IVaultInsurance _insurance) external;\\n\\n}\\n\",\"keccak256\":\"0x9e77a10b32a52f826d28d17c420f776fd289e5e4f925ec87f7177a1ce224a412\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IVaultInsurance {\\n\\n  function init(address _vault, address _asset) external;\\n\\n  function vault() external view returns (address);\\n\\n  function asset() external view returns (address);\\n\\n  function transferToVault(uint amount) external;\\n\\n}\\n\",\"keccak256\":\"0x6461572763b1f6decec1dee9d2ffe8ca152369bdc68255ec083cb3da3ce507a1\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n\\nlibrary StringLib {\\n\\n  /// @dev Inspired by OraclizeAPI's implementation - MIT license\\n  ///      https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\\n  function toString(uint value) external pure returns (string memory) {\\n    return _toString(value);\\n  }\\n\\n  function _toString(uint value) internal pure returns (string memory) {\\n    if (value == 0) {\\n      return \\\"0\\\";\\n    }\\n    uint temp = value;\\n    uint digits;\\n    while (temp != 0) {\\n      digits++;\\n      temp /= 10;\\n    }\\n    bytes memory buffer = new bytes(digits);\\n    while (value != 0) {\\n      digits -= 1;\\n      buffer[digits] = bytes1(uint8(48 + uint(value % 10)));\\n      value /= 10;\\n    }\\n    return string(buffer);\\n  }\\n\\n  function toAsciiString(address x) external pure returns (string memory) {\\n    return _toAsciiString(x);\\n  }\\n\\n  function _toAsciiString(address x) internal pure returns (string memory) {\\n    bytes memory s = new bytes(40);\\n    for (uint i = 0; i < 20; i++) {\\n      bytes1 b = bytes1(uint8(uint(uint160(x)) / (2 ** (8 * (19 - i)))));\\n      bytes1 hi = bytes1(uint8(b) / 16);\\n      bytes1 lo = bytes1(uint8(b) - 16 * uint8(hi));\\n      s[2 * i] = _char(hi);\\n      s[2 * i + 1] = _char(lo);\\n    }\\n    return string(s);\\n  }\\n\\n  function char(bytes1 b) external pure returns (bytes1 c) {\\n    return _char(b);\\n  }\\n\\n  function _char(bytes1 b) internal pure returns (bytes1 c) {\\n    if (uint8(b) < 10) return bytes1(uint8(b) + 0x30);\\n    else return bytes1(uint8(b) + 0x57);\\n  }\\n\\n}\\n\",\"keccak256\":\"0xce525513ab06cdcbb2c4b6e5aa4396202b2f719e24d701f3739b1f89e64b7dd6\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        // only check isContract if the call was successful and the return data is empty\\n        // otherwise we already know that it was a contract\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n    // Look for revert reason and bubble it up if present\\n    if (returndata.length > 0) {\\n      // The easiest way to bubble the revert reason is using memory via assembly\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xcc7eeaafd4384e04ff39e0c01f0a6794736c34cad529751b8abd7b088ecc2e83\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n  enum Rounding {\\n    Down, // Toward negative infinity\\n    Up, // Toward infinity\\n    Zero // Toward zero\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b - 1) / b can overflow on addition, so we distribute.\\n    return a == 0 ? 0 : (a - 1) / b + 1;\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n  unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly {\\n      let mm := mulmod(x, y, not(0))\\n      prod0 := mul(x, y)\\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n      return prod0 / denominator;\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly {\\n    // Compute remainder using mulmod.\\n      remainder := mulmod(x, y, denominator)\\n\\n    // Subtract 256 bit number from 512 bit number.\\n      prod1 := sub(prod1, gt(remainder, prod0))\\n      prod0 := sub(prod0, remainder)\\n    }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n    // See https://cs.stackexchange.com/q/138556/92363.\\n\\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\\n    uint256 twos = denominator & (~denominator + 1);\\n    assembly {\\n    // Divide denominator by twos.\\n      denominator := div(denominator, twos)\\n\\n    // Divide [prod1 prod0] by twos.\\n      prod0 := div(prod0, twos)\\n\\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n      twos := add(div(sub(0, twos), twos), 1)\\n    }\\n\\n    // Shift in bits from prod1 into prod0.\\n    prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n    uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n    // in modular arithmetic, doubling the correct bits in each step.\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n    result = prod0 * inverse;\\n    return result;\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator,\\n    Rounding rounding\\n  ) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n  unchecked {\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    return min(result, a / result);\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = sqrt(a);\\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 128;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 64;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 32;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 16;\\n    }\\n    if (value >> 8 > 0) {\\n      value >>= 8;\\n      result += 8;\\n    }\\n    if (value >> 4 > 0) {\\n      value >>= 4;\\n      result += 4;\\n    }\\n    if (value >> 2 > 0) {\\n      value >>= 2;\\n      result += 2;\\n    }\\n    if (value >> 1 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log2(value);\\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >= 10**64) {\\n      value /= 10**64;\\n      result += 64;\\n    }\\n    if (value >= 10**32) {\\n      value /= 10**32;\\n      result += 32;\\n    }\\n    if (value >= 10**16) {\\n      value /= 10**16;\\n      result += 16;\\n    }\\n    if (value >= 10**8) {\\n      value /= 10**8;\\n      result += 8;\\n    }\\n    if (value >= 10**4) {\\n      value /= 10**4;\\n      result += 4;\\n    }\\n    if (value >= 10**2) {\\n      value /= 10**2;\\n      result += 2;\\n    }\\n    if (value >= 10**1) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log10(value);\\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 16;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 8;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 4;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 2;\\n    }\\n    if (value >> 8 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log256(value);\\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n  }\\n  }\\n}\\n\",\"keccak256\":\"0x2c5be0f4a60126b08e20f40586958ec1b76a27b69406c4b0db19e9dc6f771cfc\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n  unchecked {\\n    uint256 oldAllowance = token.allowance(address(this), spender);\\n    require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n    uint256 newAllowance = oldAllowance - value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n  }\\n\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x2378ee07b24e40c75781b27b2aa0812769c0000964e2d2501e3d234d3285dd18\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/SafeERC20.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\n\\nlibrary StrategyLib {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Denominator for fee calculation.\\n  uint internal constant FEE_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        EVENTS\\n  // *************************************************************\\n\\n  event CompoundRatioChanged(uint oldValue, uint newValue);\\n  event StrategySpecificNameChanged(string name);\\n  event EmergencyExit(address sender, uint amount);\\n  event ManualClaim(address sender);\\n  event InvestAll(uint balance);\\n  event WithdrawAllToSplitter(uint amount);\\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\\n\\n  // *************************************************************\\n  //                        ERRORS\\n  // *************************************************************\\n\\n  string internal constant DENIED = \\\"SB: Denied\\\";\\n  string internal constant TOO_HIGH = \\\"SB: Too high\\\";\\n  string internal constant WRONG_VALUE = \\\"SB: Wrong value\\\";\\n  /// @dev Denominator for compound ratio\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        CHECKS AND EMITS\\n  // *************************************************************\\n\\n  function _checkCompoundRatioChanged(address controller, uint oldValue, uint newValue) external {\\n    onlyPlatformVoter(controller);\\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\\n    emit CompoundRatioChanged(oldValue, newValue);\\n  }\\n\\n  function _checkStrategySpecificNameChanged(address controller, string calldata newName) external {\\n    onlyOperators(controller);\\n    emit StrategySpecificNameChanged(newName);\\n  }\\n\\n  function _checkManualClaim(address controller) external {\\n    onlyOperators(controller);\\n    emit ManualClaim(msg.sender);\\n  }\\n\\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\\n    onlySplitter(splitter);\\n    assetBalance = IERC20(asset).balanceOf(address(this));\\n    emit InvestAll(assetBalance);\\n  }\\n\\n  // *************************************************************\\n  //                     RESTRICTIONS\\n  // *************************************************************\\n\\n  /// @dev Restrict access only for operators\\n  function onlyOperators(address controller) public view {\\n    require(IController(controller).isOperator(msg.sender), DENIED);\\n  }\\n\\n  /// @dev Restrict access only for governance\\n  function onlyGovernance(address controller) public view {\\n    require(IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for platform voter\\n  function onlyPlatformVoter(address controller) public view {\\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for splitter\\n  function onlySplitter(address splitter) public view {\\n    require(splitter == msg.sender, DENIED);\\n  }\\n\\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_) external view {\\n    onlyGovernance(controller);\\n    require(fee_ <= 100_000, TOO_HIGH);\\n    require(receiver_ != address(0), WRONG_VALUE);\\n  }\\n\\n  // *************************************************************\\n  //                       HELPERS\\n  // *************************************************************\\n\\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\\n  ///         Revert if the amount is different from expected too much (high price impact)\\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\\n  /// @param assetPrice Price of the asset, decimals 18\\n  /// @return balance Current asset balance of the strategy\\n  function checkWithdrawImpact(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) public view returns (uint balance) {\\n    balance = IERC20(_asset).balanceOf(address(this));\\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\\n\\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\\n    }\\n  }\\n\\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\\n    onlyOperators(controller);\\n\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    IERC20(asset).safeTransfer(splitter, balance);\\n    emit EmergencyExit(msg.sender, balance);\\n  }\\n\\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\\n    onlySplitter(splitter);\\n    return IERC20(asset).balanceOf(address(this));\\n  }\\n\\n  function _withdrawAllToSplitterPostActions(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) external {\\n    uint balance = checkWithdrawImpact(\\n      _asset,\\n      balanceBefore,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n\\n    if (balance != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, balance);\\n    }\\n    emit WithdrawAllToSplitter(balance);\\n  }\\n\\n  function _withdrawToSplitterPostActions(\\n    uint amount,\\n    uint balance,\\n    address _asset,\\n    address _splitter\\n  ) external {\\n    uint amountAdjusted = Math.min(amount, balance);\\n    if (amountAdjusted != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\\n    }\\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\\n  }\\n}\\n\",\"keccak256\":\"0x81940f83bfee07d985fc82504e764db61673f99ae82e1d323f64f51843b7ef9f\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/SafeERC20.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\nimport \\\"../interfaces/IStrategyV3.sol\\\";\\n\\nlibrary StrategyLib2 {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Denominator for fee calculation.\\n  uint internal constant FEE_DENOMINATOR = 100_000;\\n  /// @notice 10% of total profit is sent to {performanceReceiver} before compounding\\n  uint internal constant DEFAULT_PERFORMANCE_FEE = 10_000;\\n  address internal constant DEFAULT_PERF_FEE_RECEIVER = 0x9Cc199D4353b5FB3e6C8EEBC99f5139e0d8eA06b;\\n  /// @dev Denominator for compound ratio\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        ERRORS\\n  // *************************************************************\\n\\n  string internal constant DENIED = \\\"SB: Denied\\\";\\n  string internal constant TOO_HIGH = \\\"SB: Too high\\\";\\n  string internal constant WRONG_VALUE = \\\"SB: Wrong value\\\";\\n\\n  // *************************************************************\\n  //                        EVENTS\\n  // *************************************************************\\n\\n  event CompoundRatioChanged(uint oldValue, uint newValue);\\n  event StrategySpecificNameChanged(string name);\\n  event EmergencyExit(address sender, uint amount);\\n  event ManualClaim(address sender);\\n  event InvestAll(uint balance);\\n  event WithdrawAllToSplitter(uint amount);\\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\\n  event PerformanceFeeChanged(uint fee, address receiver, uint ratio);\\n\\n  // *************************************************************\\n  //                        CHECKS AND EMITS\\n  // *************************************************************\\n\\n  function _checkManualClaim(address controller) external {\\n    onlyOperators(controller);\\n    emit ManualClaim(msg.sender);\\n  }\\n\\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\\n    onlySplitter(splitter);\\n    assetBalance = IERC20(asset).balanceOf(address(this));\\n    emit InvestAll(assetBalance);\\n  }\\n\\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_, uint ratio_) internal {\\n    onlyGovernance(controller);\\n    require(fee_ <= FEE_DENOMINATOR, TOO_HIGH);\\n    require(receiver_ != address(0), WRONG_VALUE);\\n    require(ratio_ <= FEE_DENOMINATOR, TOO_HIGH);\\n    emit PerformanceFeeChanged(fee_, receiver_, ratio_);\\n  }\\n\\n  // *************************************************************\\n  //                        SETTERS\\n  // *************************************************************\\n\\n  function _changeCompoundRatio(IStrategyV3.BaseState storage baseState, address controller, uint newValue) external {\\n    onlyPlatformVoter(controller);\\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\\n\\n    uint oldValue = baseState.compoundRatio;\\n    baseState.compoundRatio = newValue;\\n\\n    emit CompoundRatioChanged(oldValue, newValue);\\n  }\\n\\n  function _changeStrategySpecificName(IStrategyV3.BaseState storage baseState, string calldata newName) external {\\n    baseState.strategySpecificName = newName;\\n    emit StrategySpecificNameChanged(newName);\\n  }\\n\\n  // *************************************************************\\n  //                     RESTRICTIONS\\n  // *************************************************************\\n\\n  /// @dev Restrict access only for operators\\n  function onlyOperators(address controller) public view {\\n    require(IController(controller).isOperator(msg.sender), DENIED);\\n  }\\n\\n  /// @dev Restrict access only for governance\\n  function onlyGovernance(address controller) public view {\\n    require(IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for platform voter\\n  function onlyPlatformVoter(address controller) public view {\\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for splitter\\n  function onlySplitter(address splitter) public view {\\n    require(splitter == msg.sender, DENIED);\\n  }\\n\\n  // *************************************************************\\n  //                       HELPERS\\n  // *************************************************************\\n\\n  function init(\\n    IStrategyV3.BaseState storage baseState,\\n    address controller_,\\n    address splitter_\\n  ) external {\\n    baseState.asset = ISplitter(splitter_).asset();\\n    baseState.splitter = splitter_;\\n    baseState.performanceReceiver = DEFAULT_PERF_FEE_RECEIVER;\\n    baseState.performanceFee = DEFAULT_PERFORMANCE_FEE;\\n\\n    require(IControllable(splitter_).isController(controller_), WRONG_VALUE);\\n  }\\n\\n  function setupPerformanceFee(IStrategyV3.BaseState storage baseState, uint fee_, address receiver_, uint ratio_, address controller_) external {\\n    _checkSetupPerformanceFee(controller_, fee_, receiver_, ratio_);\\n    baseState.performanceFee = fee_;\\n    baseState.performanceReceiver = receiver_;\\n    baseState.performanceFeeRatio = ratio_;\\n  }\\n\\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\\n  ///         Revert if the amount is different from expected too much (high price impact)\\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\\n  /// @param assetPrice Price of the asset, decimals 18\\n  /// @return balance Current asset balance of the strategy\\n  function checkWithdrawImpact(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) public view returns (uint balance) {\\n    balance = IERC20(_asset).balanceOf(address(this));\\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\\n\\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\\n    }\\n  }\\n\\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\\n    onlyOperators(controller);\\n\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    IERC20(asset).safeTransfer(splitter, balance);\\n    emit EmergencyExit(msg.sender, balance);\\n  }\\n\\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\\n    onlySplitter(splitter);\\n    return IERC20(asset).balanceOf(address(this));\\n  }\\n\\n  function _withdrawAllToSplitterPostActions(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) external {\\n    uint balance = checkWithdrawImpact(\\n      _asset,\\n      balanceBefore,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n\\n    if (balance != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, balance);\\n    }\\n    emit WithdrawAllToSplitter(balance);\\n  }\\n\\n  function _withdrawToSplitterPostActions(\\n    uint amount,\\n    uint balance,\\n    address _asset,\\n    address _splitter\\n  ) external {\\n    uint amountAdjusted = Math.min(amount, balance);\\n    if (amountAdjusted != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\\n    }\\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\\n  }\\n}\\n\",\"keccak256\":\"0x3fc05bafdeef7b859555c93ed7426cca6ac3b2d243e47962b120f22f2dd41466\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/// @notice Keep and provide addresses of all application contracts\\ninterface IConverterController {\\n  function governance() external view returns (address);\\n\\n  // ********************* Health factor explanation  ****************\\n  // For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\\n  // For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\\n  // We set min-health-factor = 1.1, target-health-factor = 1.3\\n  // For collateral 100 we will borrow 100/1.3 = 76.92\\n  //\\n  // Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\\n  // Collateral * LT    85         65.45\\n  // Borrow value       65.38      65.38         but borrow value is the same as before\\n  // Health factor      1.3        1.001         liquidation almost happens here (!)\\n  //\\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\\n  // and the borrow value won't change at the same time, the liquidation happens at that point.\\n  // Min health factor marks the point at which a rebalancing must be made asap.\\n  // *****************************************************************\\n\\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\\n  function minHealthFactor2() external view returns (uint16);\\n  function setMinHealthFactor2(uint16 value_) external;\\n\\n  /// @notice target health factor with decimals 2\\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\\n  ///      or additional borrow and restore the health factor to the given target value\\n  function targetHealthFactor2() external view returns (uint16);\\n  function setTargetHealthFactor2(uint16 value_) external;\\n\\n  /// @notice max allowed health factor with decimals 2\\n  /// @dev For future versions, currently max health factor is not used\\n  function maxHealthFactor2() external view returns (uint16);\\n  /// @dev For future versions, currently max health factor is not used\\n  function setMaxHealthFactor2(uint16 value_) external;\\n\\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\\n  function blocksPerDay() external view returns (uint);\\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\\n  /// @notice Check if it's time to call updateBlocksPerDay()\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\\n  /// @notice Recalculate blocksPerDay value\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function updateBlocksPerDay(uint periodInSeconds_) external;\\n\\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\\n  function paused() external view returns (bool);\\n\\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\\n  function isWhitelisted(address user_) external view returns (bool);\\n\\n  /// @notice The size of the gap by which the debt should be increased upon repayment\\n  ///         Such gaps are required by AAVE pool adapters to workaround dust tokens problem\\n  ///         and be able to make full repayment.\\n  /// @dev Debt gap is applied as following: toPay = debt * (DEBT_GAP_DENOMINATOR + debtGap) / DEBT_GAP_DENOMINATOR\\n  function debtGap() external view returns (uint);\\n\\n  //-----------------------------------------------------\\n  //        Core application contracts\\n  //-----------------------------------------------------\\n\\n  function tetuConverter() external view returns (address);\\n  function borrowManager() external view returns (address);\\n  function debtMonitor() external view returns (address);\\n  function tetuLiquidator() external view returns (address);\\n  function swapManager() external view returns (address);\\n  function priceOracle() external view returns (address);\\n\\n  //-----------------------------------------------------\\n  //        External contracts\\n  //-----------------------------------------------------\\n  /// @notice A keeper to control health and efficiency of the borrows\\n  function keeper() external view returns (address);\\n  /// @notice Controller of tetu-contracts-v2, that is allowed to update proxy contracts\\n  function proxyUpdater() external view returns (address);\\n}\\n\",\"keccak256\":\"0xefb20480cab050b2e178982481efc65babd931bdb6aeb4f0e10c58684cee43f1\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterControllerProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IConverterControllerProvider {\\n  function controller() external view returns (address);\\n}\\n\",\"keccak256\":\"0x71dce61809acb75f9078290e90033ffe816a51f18b7cb296d161e278c36eec86\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IPriceOracle {\\n  /// @notice Return asset price in USD, decimals 18\\n  function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb11e653eb4d6d7c41f29ee1e3e498253cfa8df1aec3ff31ab527009b79bdb705\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IConverterControllerProvider.sol\\\";\\n\\n/// @notice Main contract of the TetuConverter application\\n/// @dev Borrower (strategy) makes all operations via this contract only.\\ninterface ITetuConverter is IConverterControllerProvider {\\n\\n  /// @notice Find possible borrow strategies and provide \\\"cost of money\\\" as interest for the period for each strategy\\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converters Array of available converters ordered in ascending order of APR.\\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\\n  ///                    This address should be passed to borrow-function during conversion.\\n  ///                    The length of array is always equal to the count of available lending platforms.\\n  ///                    Last items in array can contain zero addresses (it means they are not used)\\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\\n  /// @return amountToBorrowsOut Amounts that should be borrowed\\n  ///                            This amount is not zero if corresponded converter is not zero.\\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\\n  function findBorrowStrategies(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external view returns (\\n    address[] memory converters,\\n    uint[] memory collateralAmountsOut,\\n    uint[] memory amountToBorrowsOut,\\n    int[] memory aprs18\\n  );\\n\\n  /// @notice Find best swap strategy and provide \\\"cost of money\\\" as interest for the period\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findSwapStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_\\n  ) external returns (\\n    address converter,\\n    uint sourceAmountOut,\\n    uint targetAmountOut,\\n    int apr18\\n  );\\n\\n  /// @notice Find best conversion strategy (swap or borrow) and provide \\\"cost of money\\\" as interest for the period.\\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findConversionStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external returns (\\n    address converter,\\n    uint collateralAmountOut,\\n    uint amountToBorrowOut,\\n    int apr18\\n  );\\n\\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\\n  ///      Only whitelisted users are allowed to make borrows\\n  /// @param converter_ A converter received from findBestConversionStrategy.\\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\\n  ///                          This amount must be approved to TetuConverter before the call.\\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\\n  /// @param receiver_ A receiver of borrowed amount\\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\\n  function borrow(\\n    address converter_,\\n    address collateralAsset_,\\n    uint collateralAmount_,\\n    address borrowAsset_,\\n    uint amountToBorrow_,\\n    address receiver_\\n  ) external returns (\\n    uint borrowedAmountOut\\n  );\\n\\n  /// @notice Full or partial repay of the borrow\\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        You can know exact total amount of debt using {getStatusCurrent}.\\n  ///        if the amount exceed total amount of the debt:\\n  ///           - the debt will be fully repaid\\n  ///           - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\\n  ///        This amount should be calculated with taking into account possible debt gap,\\n  ///        You should call getDebtAmountCurrent(debtGap = true) to get this amount.\\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\\n  ///         If TetuConverter is not able to make the swap, it reverts\\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\\n  ///                                 This amount is returned back to the collateralReceiver_\\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\\n  function repay(\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_,\\n    address receiver_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint returnedBorrowAmountOut,\\n    uint swappedLeftoverCollateralOut,\\n    uint swappedLeftoverBorrowOut\\n  );\\n\\n  /// @notice Estimate result amount after making full or partial repay\\n  /// @dev It works in exactly same way as repay() but don't make actual repay\\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\\n  /// @param user_ user whose amount-to-repay will be calculated\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        This amount should be calculated without possible debt gap.\\n  ///        In this way it's differ from {repay}\\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\\n  /// @return swappedAmountOut A part of {collateralAmountOut} that were received by direct swap\\n  function quoteRepay(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint swappedAmountOut\\n  );\\n\\n  /// @notice Update status in all opened positions\\n  ///         After this call getDebtAmount will be able to return exact amount to repay\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountCurrent(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountStored(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external view returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\\n  /// @param user_ user whose debts will be returned\\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\\n  ///                                           even if all borrowed amount will be returned.\\n  ///                                           If this amount is not 0, you ask to get too much collateral.\\n  function estimateRepay(\\n    address user_,\\n    address collateralAsset_,\\n    uint collateralAmountRequired_,\\n    address borrowAsset_\\n  ) external view returns (\\n    uint borrowAssetAmount,\\n    uint unobtainableCollateralAssetAmount\\n  );\\n\\n  /// @notice Transfer all reward tokens to {receiver_}\\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\\n  function claimRewards(address receiver_) external returns (\\n    address[] memory rewardTokensOut,\\n    uint[] memory amountsOut\\n  );\\n\\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\\n  ///                      It should be transferred on balance of the TetuConverter before the function call\\n  /// @param receiver_ Result amount will be sent to this address\\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\\n  function safeLiquidate(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    address receiver_,\\n    uint priceImpactToleranceSource_,\\n    uint priceImpactToleranceTarget_\\n  ) external returns (\\n    uint amountOut\\n  );\\n\\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\\n  function isConversionValid(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    uint amountOut_,\\n    uint priceImpactTolerance_\\n  ) external view returns (bool);\\n\\n  /// @notice Close given borrow and return collateral back to the user, governance only\\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\\n  /// @param poolAdapter_ The pool adapter that represents the borrow\\n  /// @param closePosition Close position after repay\\n  ///        Usually it should be true, because the function always tries to repay all debt\\n  ///        false can be used if user doesn't have enough amount to pay full debt\\n  ///              and we are trying to pay \\\"as much as possible\\\"\\n  /// @return collateralAmountOut Amount of collateral returned to the user\\n  /// @return repaidAmountOut Amount of borrow asset paid to the lending platform\\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\\n    uint collateralAmountOut,\\n    uint repaidAmountOut\\n  );\\n\\n  /// @notice Get active borrows of the user with given collateral/borrowToken\\n  /// @dev Simple access to IDebtMonitor.getPositions\\n  /// @return poolAdaptersOut The instances of IPoolAdapter\\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external view returns (\\n    address[] memory poolAdaptersOut\\n  );\\n\\n  /// @notice Save token from TC-balance to {receiver}\\n  /// @dev Normally TetuConverter doesn't have any tokens on balance, they can appear there accidentally only\\n  function salvage(address receiver, address token, uint amount) external;\\n}\\n\",\"keccak256\":\"0xd30f740004b39189b18ab99299e9d673ff48b754e053415130a6eda95558fa7d\",\"license\":\"MIT\"},\"contracts/integrations/algebra/AlgebraFeeConfiguration.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n// coefficients for sigmoids: \\u03b1 / (1 + e^( (\\u03b2-x) / \\u03b3))\\n// alpha1 + alpha2 + baseFee must be <= type(uint16).max\\nstruct AlgebraFeeConfiguration {\\n  uint16 alpha1; // max value of the first sigmoid\\n  uint16 alpha2; // max value of the second sigmoid\\n  uint32 beta1; // shift along the x-axis for the first sigmoid\\n  uint32 beta2; // shift along the x-axis for the second sigmoid\\n  uint16 gamma1; // horizontal stretch factor for the first sigmoid\\n  uint16 gamma2; // horizontal stretch factor for the second sigmoid\\n  uint16 baseFee; // minimum possible fee\\n}\\n\",\"keccak256\":\"0x23bd41ba765c4f24dfecb3d60a6e69acfeac24f5692883e1af97bcdec8f8dfba\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IAlgebraEternalFarming.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IncentiveKey.sol\\\";\\n\\ninterface IAlgebraEternalFarming {\\n    /// @notice reward amounts can be outdated, actual amounts could be obtained via static call of `collectRewards` in FarmingCenter\\n    function getRewardInfo(\\n        IncentiveKey memory key,\\n        uint256 tokenId\\n    ) external view returns (uint256 reward, uint256 bonusReward);\\n}\",\"keccak256\":\"0xb4c25093c3cce483e49aed2dfcbcac7d241b04fb213fe92c692794b43a58f548\",\"license\":\"MIT\"},\"contracts/integrations/algebra/IAlgebraPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport './pool/IAlgebraPoolImmutables.sol';\\nimport './pool/IAlgebraPoolState.sol';\\nimport './pool/IAlgebraPoolDerivedState.sol';\\nimport './pool/IAlgebraPoolActions.sol';\\nimport './pool/IAlgebraPoolPermissionedActions.sol';\\nimport './pool/IAlgebraPoolEvents.sol';\\n\\n/**\\n * @title The interface for a Algebra Pool\\n * @dev The pool interface is broken up into many smaller pieces.\\n * Credit to Uniswap Labs under GPL-2.0-or-later license:\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\n */\\ninterface IAlgebraPool is\\nIAlgebraPoolImmutables,\\nIAlgebraPoolState,\\nIAlgebraPoolDerivedState,\\nIAlgebraPoolActions,\\nIAlgebraPoolPermissionedActions,\\nIAlgebraPoolEvents\\n{\\n  // used only for combining interfaces\\n}\\n\",\"keccak256\":\"0x1bc40e5f4b042df8aeeeafb2383b2565c39408d1b0cb28d63916dcf4d7883353\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IDataStorageOperator.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\npragma abicoder v2;\\n\\nimport './AlgebraFeeConfiguration.sol';\\n\\n/// @title The interface for the DataStorageOperator\\n/// @dev This contract stores timepoints and calculates adaptive fee and statistical averages\\ninterface IDataStorageOperator {\\n  /// @notice Emitted when the fee configuration is changed\\n  /// @param feeConfig The structure with dynamic fee parameters\\n  /// @dev See the AdaptiveFee library for more details\\n  event FeeConfiguration(AlgebraFeeConfiguration feeConfig);\\n\\n  /// @notice Returns data belonging to a certain timepoint\\n  /// @param index The index of timepoint in the array\\n  /// @dev There is more convenient function to fetch a timepoint: getTimepoints(). Which requires not an index but seconds\\n  /// @return initialized Whether the timepoint has been initialized and the values are safe to use\\n  /// @return blockTimestamp The timestamp of the timepoint\\n  /// @return tickCumulative The tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp\\n  /// @return volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp\\n  /// @return tick The tick at blockTimestamp\\n  /// @return averageTick Time-weighted average tick\\n  /// @return windowStartIndex Index of closest timepoint >= WINDOW seconds ago\\n  function timepoints(\\n    uint256 index\\n  )\\n    external\\n    view\\n    returns (\\n      bool initialized,\\n      uint32 blockTimestamp,\\n      int56 tickCumulative,\\n      uint88 volatilityCumulative,\\n      int24 tick,\\n      int24 averageTick,\\n      uint16 windowStartIndex\\n    );\\n\\n  /// @notice Initialize the dataStorage array by writing the first slot. Called once for the lifecycle of the timepoints array\\n  /// @param time The time of the dataStorage initialization, via block.timestamp truncated to uint32\\n  /// @param tick Initial tick\\n  function initialize(uint32 time, int24 tick) external;\\n\\n  /// @dev Reverts if a timepoint at or before the desired timepoint timestamp does not exist.\\n  /// 0 may be passed as `secondsAgo' to return the current cumulative values.\\n  /// If called with a timestamp falling between two timepoints, returns the counterfactual accumulator values\\n  /// at exactly the timestamp between the two timepoints.\\n  /// @param time The current block timestamp\\n  /// @param secondsAgo The amount of time to look back, in seconds, at which point to return a timepoint\\n  /// @param tick The current tick\\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\\n  /// @return tickCumulative The cumulative tick since the pool was first initialized, as of `secondsAgo`\\n  /// @return volatilityCumulative The cumulative volatility value since the pool was first initialized, as of `secondsAgo`\\n  function getSingleTimepoint(\\n    uint32 time,\\n    uint32 secondsAgo,\\n    int24 tick,\\n    uint16 index\\n  ) external view returns (int56 tickCumulative, uint112 volatilityCumulative);\\n\\n  /// @notice Returns the accumulator values as of each time seconds ago from the given time in the array of `secondsAgos`\\n  /// @dev Reverts if `secondsAgos` > oldest timepoint\\n  /// @param secondsAgos Each amount of time to look back, in seconds, at which point to return a timepoint\\n  /// @return tickCumulatives The cumulative tick since the pool was first initialized, as of each `secondsAgo`\\n  /// @return volatilityCumulatives The cumulative volatility values since the pool was first initialized, as of each `secondsAgo`\\n  function getTimepoints(uint32[] memory secondsAgos) external view returns (int56[] memory tickCumulatives, uint112[] memory volatilityCumulatives);\\n\\n  /// @notice Writes a dataStorage timepoint to the array\\n  /// @dev Writable at most once per block. Index represents the most recently written element. index must be tracked externally.\\n  /// @param index The index of the timepoint that was most recently written to the timepoints array\\n  /// @param blockTimestamp The timestamp of the new timepoint\\n  /// @param tick The active tick at the time of the new timepoint\\n  /// @return indexUpdated The new index of the most recently written element in the dataStorage array\\n  /// @return newFee The fee in hundredths of a bip, i.e. 1e-6\\n  function write(uint16 index, uint32 blockTimestamp, int24 tick) external returns (uint16 indexUpdated, uint16 newFee);\\n\\n  /// @notice Changes fee configuration for the pool\\n  function changeFeeConfiguration(AlgebraFeeConfiguration calldata feeConfig) external;\\n\\n  /// @notice Fills uninitialized timepoints with nonzero value\\n  /// @dev Can be used to reduce the gas cost of future swaps\\n  /// @param startIndex The start index, must be not initialized\\n  /// @param amount of slots to fill, startIndex + amount must be <= type(uint16).max\\n  function prepayTimepointsStorageSlots(uint16 startIndex, uint16 amount) external;\\n}\\n\",\"keccak256\":\"0x8f658d88ce259f0806d992a1174e8163b0fb3e5d592c01befaa8426316ca39fd\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/IFarmingCenter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IAlgebraEternalFarming.sol\\\";\\nimport \\\"./IncentiveKey.sol\\\";\\nimport \\\"./INonfungiblePositionManager.sol\\\";\\n\\ninterface IFarmingCenter {\\n    /// @notice Returns information about a deposited NFT\\n    /// @param tokenId The ID of the deposit (and token) that is being transferred\\n    /// @return L2TokenId The nft layer2 id,\\n    /// numberOfFarms The number of farms,\\n    /// inLimitFarming The parameter showing if the token is in the limit farm,\\n    /// owner The owner of deposit\\n    function deposits(uint256 tokenId)\\n    external\\n    view\\n    returns (\\n        uint256 L2TokenId,\\n        uint32 numberOfFarms,\\n        bool inLimitFarming,\\n        address owner\\n    );\\n\\n    /// @notice Enters in incentive (time-limited or eternal farming) with NFT-position token\\n    /// @dev token must be deposited in FarmingCenter\\n    /// @param key The incentive event key\\n    /// @param tokenId The id of position NFT\\n    /// @param tokensLocked Amount of tokens to lock for liquidity multiplier (if tiers are used)\\n    /// @param isLimit Is incentive time-limited or eternal\\n    function enterFarming(\\n        IncentiveKey memory key,\\n        uint256 tokenId,\\n        uint256 tokensLocked,\\n        bool isLimit\\n    ) external;\\n\\n    function eternalFarming() external view returns (IAlgebraEternalFarming);\\n\\n    /// @notice Collects up to a maximum amount of fees owed to a specific position to the recipient\\n    /// @dev \\\"proxies\\\" to NonfungiblePositionManager\\n    /// @param params tokenId The ID of the NFT for which tokens are being collected,\\n    /// recipient The account that should receive the tokens,\\n    /// amount0Max The maximum amount of token0 to collect,\\n    /// amount1Max The maximum amount of token1 to collect\\n    /// @return amount0 The amount of fees collected in token0\\n    /// @return amount1 The amount of fees collected in token1\\n    function collect(INonfungiblePositionManager.CollectParams calldata params)\\n    external\\n    returns (uint256 amount0, uint256 amount1);\\n\\n    /// @notice Used to collect reward from eternal farming. Then reward can be claimed.\\n    /// @param key The incentive event key\\n    /// @param tokenId The id of position NFT\\n    /// @return reward The amount of collected reward\\n    /// @return bonusReward The amount of collected  bonus reward\\n    function collectRewards(IncentiveKey memory key, uint256 tokenId)\\n    external\\n    returns (uint256 reward, uint256 bonusReward);\\n\\n    /// @notice Used to claim and send rewards from farming(s)\\n    /// @dev can be used via static call to get current rewards for user\\n    /// @param rewardToken The token that is a reward\\n    /// @param to The address to be rewarded\\n    /// @param amountRequestedIncentive Amount to claim in incentive (limit) farming\\n    /// @param amountRequestedEternal Amount to claim in eternal farming\\n    /// @return reward The summary amount of claimed rewards\\n    function claimReward(\\n        address rewardToken,\\n        address to,\\n        uint256 amountRequestedIncentive,\\n        uint256 amountRequestedEternal\\n    ) external returns (uint256 reward);\\n\\n    /// @notice Exits from incentive (time-limited or eternal farming) with NFT-position token\\n    /// @param key The incentive event key\\n    /// @param tokenId The id of position NFT\\n    /// @param isLimit Is incentive time-limited or eternal\\n    function exitFarming(\\n        IncentiveKey memory key,\\n        uint256 tokenId,\\n        bool isLimit\\n    ) external;\\n\\n    /// @notice Withdraw Algebra NFT-position token\\n    /// @dev can be used via static call to get current rewards for user\\n    /// @param tokenId The id of position NFT\\n    /// @param to New owner of position NFT\\n    /// @param data The additional data for NonfungiblePositionManager\\n    function withdrawToken(\\n        uint256 tokenId,\\n        address to,\\n        bytes memory data\\n    ) external;\\n}\",\"keccak256\":\"0xcbe2301d25bbf917a27d4afc001b9f31b3bedf8fb1dc3be043e9d4e7b80b51aa\",\"license\":\"MIT\"},\"contracts/integrations/algebra/INonfungiblePositionManager.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface INonfungiblePositionManager {\\n    struct MintParams {\\n        address token0;\\n        address token1;\\n        int24 tickLower;\\n        int24 tickUpper;\\n        uint amount0Desired;\\n        uint amount1Desired;\\n        uint amount0Min;\\n        uint amount1Min;\\n        address recipient;\\n        uint deadline;\\n    }\\n\\n    function mint(\\n        MintParams calldata params\\n    ) external payable returns (uint tokenId, uint128 liquidity, uint amount0, uint amount1);\\n\\n    struct IncreaseLiquidityParams {\\n        uint256 tokenId;\\n        uint256 amount0Desired;\\n        uint256 amount1Desired;\\n        uint256 amount0Min;\\n        uint256 amount1Min;\\n        uint256 deadline;\\n    }\\n\\n    function increaseLiquidity(IncreaseLiquidityParams calldata params)\\n    external\\n    payable\\n    returns (\\n        uint128 liquidity,\\n        uint256 amount0,\\n        uint256 amount1\\n    );\\n\\n    struct DecreaseLiquidityParams {\\n        uint tokenId;\\n        uint128 liquidity;\\n        uint amount0Min;\\n        uint amount1Min;\\n        uint deadline;\\n    }\\n\\n    function decreaseLiquidity(\\n        DecreaseLiquidityParams calldata params\\n    ) external payable returns (uint amount0, uint amount1);\\n\\n    struct CollectParams {\\n        uint tokenId;\\n        address recipient;\\n        uint128 amount0Max;\\n        uint128 amount1Max;\\n    }\\n\\n    function collect(CollectParams calldata params) external payable returns (uint amount0, uint amount1);\\n\\n    function burn(uint tokenId) external payable;\\n\\n    function safeTransferFrom(\\n        address from,\\n        address to,\\n        uint256 tokenId\\n    ) external;\\n\\n    function positions(uint256 tokenId)\\n    external\\n    view\\n    returns (\\n        uint96 nonce,\\n        address operator,\\n        address token0,\\n        address token1,\\n        int24 tickLower,\\n        int24 tickUpper,\\n        uint128 liquidity,\\n        uint256 feeGrowthInside0LastX128,\\n        uint256 feeGrowthInside1LastX128,\\n        uint128 tokensOwed0,\\n        uint128 tokensOwed1\\n    );\\n}\",\"keccak256\":\"0xc1ba265df609d9d2eeb14d4bd0dd9e1e8e9f0c11e5d47111ddf53d185578a391\",\"license\":\"MIT\"},\"contracts/integrations/algebra/IncentiveKey.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nstruct IncentiveKey {\\n    address rewardToken;\\n    address bonusRewardToken;\\n    address pool;\\n    uint256 startTime;\\n    uint256 endTime;\\n}\",\"keccak256\":\"0xbb5a5b0587571aaaf4ba6576228128a81a1be6cae32ba93357b0b992885c5aa5\",\"license\":\"MIT\"},\"contracts/integrations/algebra/pool/IAlgebraPoolActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Permissionless pool actions\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\ninterface IAlgebraPoolActions {\\n  /**\\n   * @notice Sets the initial price for the pool\\n   * @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\\n   * @param price the initial sqrt price of the pool as a Q64.96\\n   */\\n  function initialize(uint160 price) external;\\n\\n  /**\\n   * @notice Adds liquidity for the given recipient/bottomTick/topTick position\\n   * @dev The caller of this method receives a callback in the form of IAlgebraMintCallback# AlgebraMintCallback\\n   * in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\\n   * on bottomTick, topTick, the amount of liquidity, and the current price.\\n   * @param sender The address which will receive potential surplus of paid tokens\\n   * @param recipient The address for which the liquidity will be created\\n   * @param bottomTick The lower tick of the position in which to add liquidity\\n   * @param topTick The upper tick of the position in which to add liquidity\\n   * @param amount The desired amount of liquidity to mint\\n   * @param data Any data that should be passed through to the callback\\n   * @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n   * @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\\n   * @return liquidityActual The actual minted amount of liquidity\\n   */\\n  function mint(\\n    address sender,\\n    address recipient,\\n    int24 bottomTick,\\n    int24 topTick,\\n    uint128 amount,\\n    bytes calldata data\\n  )\\n  external\\n  returns (\\n    uint256 amount0,\\n    uint256 amount1,\\n    uint128 liquidityActual\\n  );\\n\\n  /**\\n   * @notice Collects tokens owed to a position\\n   * @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\\n   * Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\\n   * amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\\n   * actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\\n   * @param recipient The address which should receive the fees collected\\n   * @param bottomTick The lower tick of the position for which to collect fees\\n   * @param topTick The upper tick of the position for which to collect fees\\n   * @param amount0Requested How much token0 should be withdrawn from the fees owed\\n   * @param amount1Requested How much token1 should be withdrawn from the fees owed\\n   * @return amount0 The amount of fees collected in token0\\n   * @return amount1 The amount of fees collected in token1\\n   */\\n  function collect(\\n    address recipient,\\n    int24 bottomTick,\\n    int24 topTick,\\n    uint128 amount0Requested,\\n    uint128 amount1Requested\\n  ) external returns (uint128 amount0, uint128 amount1);\\n\\n  /**\\n   * @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\\n   * @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\\n   * @dev Fees must be collected separately via a call to #collect\\n   * @param bottomTick The lower tick of the position for which to burn liquidity\\n   * @param topTick The upper tick of the position for which to burn liquidity\\n   * @param amount How much liquidity to burn\\n   * @return amount0 The amount of token0 sent to the recipient\\n   * @return amount1 The amount of token1 sent to the recipient\\n   */\\n  function burn(\\n    int24 bottomTick,\\n    int24 topTick,\\n    uint128 amount\\n  ) external returns (uint256 amount0, uint256 amount1);\\n\\n  /**\\n   * @notice Swap token0 for token1, or token1 for token0\\n   * @dev The caller of this method receives a callback in the form of IAlgebraSwapCallback# AlgebraSwapCallback\\n   * @param recipient The address to receive the output of the swap\\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\\n   * SwapRouter#SwapCallbackData\\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n   */\\n  function swap(\\n    address recipient,\\n    bool zeroToOne,\\n    int256 amountSpecified,\\n    uint160 limitSqrtPrice,\\n    bytes calldata data\\n  ) external returns (int256 amount0, int256 amount1);\\n\\n  /**\\n   * @notice Swap token0 for token1, or token1 for token0 (tokens that have fee on transfer)\\n   * @dev The caller of this method receives a callback in the form of I AlgebraSwapCallback# AlgebraSwapCallback\\n   * @param sender The address called this function (Comes from the Router)\\n   * @param recipient The address to receive the output of the swap\\n   * @param zeroToOne The direction of the swap, true for token0 to token1, false for token1 to token0\\n   * @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\\n   * @param limitSqrtPrice The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\\n   * value after the swap. If one for zero, the price cannot be greater than this value after the swap\\n   * @param data Any data to be passed through to the callback. If using the Router it should contain\\n   * SwapRouter#SwapCallbackData\\n   * @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\\n   * @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\\n   */\\n  function swapSupportingFeeOnInputTokens(\\n    address sender,\\n    address recipient,\\n    bool zeroToOne,\\n    int256 amountSpecified,\\n    uint160 limitSqrtPrice,\\n    bytes calldata data\\n  ) external returns (int256 amount0, int256 amount1);\\n\\n  /**\\n   * @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\\n   * @dev The caller of this method receives a callback in the form of IAlgebraFlashCallback# AlgebraFlashCallback\\n   * @dev All excess tokens paid in the callback are distributed to liquidity providers as an additional fee. So this method can be used\\n   * to donate underlying tokens to currently in-range liquidity providers by calling with 0 amount{0,1} and sending\\n   * the donation amount(s) from the callback\\n   * @param recipient The address which will receive the token0 and token1 amounts\\n   * @param amount0 The amount of token0 to send\\n   * @param amount1 The amount of token1 to send\\n   * @param data Any data to be passed through to the callback\\n   */\\n  function flash(\\n    address recipient,\\n    uint256 amount0,\\n    uint256 amount1,\\n    bytes calldata data\\n  ) external;\\n}\\n\",\"keccak256\":\"0x75c099718641859b8434da326721229718c4bc48b8b8b416c0556781cab1fd27\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolDerivedState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/**\\n * @title Pool state that is not stored\\n * @notice Contains view functions to provide information about the pool that is computed rather than stored on the\\n * blockchain. The functions here may have variable gas costs.\\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\n */\\ninterface IAlgebraPoolDerivedState {\\n  /**\\n   * @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\\n   * @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\\n   * the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\\n   * you must call it with secondsAgos = [3600, 0].\\n   * @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\\n   * log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\\n   * @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\\n   * @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\\n   * @return secondsPerLiquidityCumulatives Cumulative seconds per liquidity-in-range value as of each `secondsAgos`\\n   * from the current block timestamp\\n   * @return volatilityCumulatives Cumulative standard deviation as of each `secondsAgos`\\n   * @return volumePerAvgLiquiditys Cumulative swap volume per liquidity as of each `secondsAgos`\\n   */\\n  function getTimepoints(uint32[] calldata secondsAgos)\\n  external\\n  view\\n  returns (\\n    int56[] memory tickCumulatives,\\n    uint160[] memory secondsPerLiquidityCumulatives,\\n    uint112[] memory volatilityCumulatives,\\n    uint256[] memory volumePerAvgLiquiditys\\n  );\\n\\n  /**\\n   * @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\\n   * @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\\n   * I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\\n   * snapshot is taken and the second snapshot is taken.\\n   * @param bottomTick The lower tick of the range\\n   * @param topTick The upper tick of the range\\n   * @return innerTickCumulative The snapshot of the tick accumulator for the range\\n   * @return innerSecondsSpentPerLiquidity The snapshot of seconds per liquidity for the range\\n   * @return innerSecondsSpent The snapshot of the number of seconds during which the price was in this range\\n   */\\n  function getInnerCumulatives(int24 bottomTick, int24 topTick)\\n  external\\n  view\\n  returns (\\n    int56 innerTickCumulative,\\n    uint160 innerSecondsSpentPerLiquidity,\\n    uint32 innerSecondsSpent\\n  );\\n}\\n\",\"keccak256\":\"0x76c81bd9ee28e501b7f7d54e329c61bd3013128b17aa25c3a62414dc62719754\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolEvents.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Events emitted by a pool\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\ninterface IAlgebraPoolEvents {\\n  /**\\n   * @notice Emitted exactly once by a pool when #initialize is first called on the pool\\n   * @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\\n   * @param price The initial sqrt price of the pool, as a Q64.96\\n   * @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\\n   */\\n  event Initialize(uint160 price, int24 tick);\\n\\n  /**\\n   * @notice Emitted when liquidity is minted for a given position\\n   * @param sender The address that minted the liquidity\\n   * @param owner The owner of the position and recipient of any minted liquidity\\n   * @param bottomTick The lower tick of the position\\n   * @param topTick The upper tick of the position\\n   * @param liquidityAmount The amount of liquidity minted to the position range\\n   * @param amount0 How much token0 was required for the minted liquidity\\n   * @param amount1 How much token1 was required for the minted liquidity\\n   */\\n  event Mint(\\n    address sender,\\n    address indexed owner,\\n    int24 indexed bottomTick,\\n    int24 indexed topTick,\\n    uint128 liquidityAmount,\\n    uint256 amount0,\\n    uint256 amount1\\n  );\\n\\n  /**\\n   * @notice Emitted when fees are collected by the owner of a position\\n   * @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\\n   * @param owner The owner of the position for which fees are collected\\n   * @param recipient The address that received fees\\n   * @param bottomTick The lower tick of the position\\n   * @param topTick The upper tick of the position\\n   * @param amount0 The amount of token0 fees collected\\n   * @param amount1 The amount of token1 fees collected\\n   */\\n  event Collect(address indexed owner, address recipient, int24 indexed bottomTick, int24 indexed topTick, uint128 amount0, uint128 amount1);\\n\\n  /**\\n   * @notice Emitted when a position's liquidity is removed\\n   * @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\\n   * @param owner The owner of the position for which liquidity is removed\\n   * @param bottomTick The lower tick of the position\\n   * @param topTick The upper tick of the position\\n   * @param liquidityAmount The amount of liquidity to remove\\n   * @param amount0 The amount of token0 withdrawn\\n   * @param amount1 The amount of token1 withdrawn\\n   */\\n  event Burn(address indexed owner, int24 indexed bottomTick, int24 indexed topTick, uint128 liquidityAmount, uint256 amount0, uint256 amount1);\\n\\n  /**\\n   * @notice Emitted by the pool for any swaps between token0 and token1\\n   * @param sender The address that initiated the swap call, and that received the callback\\n   * @param recipient The address that received the output of the swap\\n   * @param amount0 The delta of the token0 balance of the pool\\n   * @param amount1 The delta of the token1 balance of the pool\\n   * @param price The sqrt(price) of the pool after the swap, as a Q64.96\\n   * @param liquidity The liquidity of the pool after the swap\\n   * @param tick The log base 1.0001 of price of the pool after the swap\\n   */\\n  event Swap(address indexed sender, address indexed recipient, int256 amount0, int256 amount1, uint160 price, uint128 liquidity, int24 tick);\\n\\n  /**\\n   * @notice Emitted by the pool for any flashes of token0/token1\\n   * @param sender The address that initiated the swap call, and that received the callback\\n   * @param recipient The address that received the tokens from flash\\n   * @param amount0 The amount of token0 that was flashed\\n   * @param amount1 The amount of token1 that was flashed\\n   * @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\\n   * @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\\n   */\\n  event Flash(address indexed sender, address indexed recipient, uint256 amount0, uint256 amount1, uint256 paid0, uint256 paid1);\\n\\n  /**\\n   * @notice Emitted when the community fee is changed by the pool\\n   * @param communityFee0New The updated value of the token0 community fee percent\\n   * @param communityFee1New The updated value of the token1 community fee percent\\n   */\\n  event CommunityFee(uint8 communityFee0New, uint8 communityFee1New);\\n\\n  /**\\n   * @notice Emitted when new activeIncentive is set\\n   * @param virtualPoolAddress The address of a virtual pool associated with the current active incentive\\n   */\\n  event Incentive(address indexed virtualPoolAddress);\\n\\n  /**\\n   * @notice Emitted when the fee changes\\n   * @param fee The value of the token fee\\n   */\\n  event Fee(uint16 fee);\\n\\n  /**\\n   * @notice Emitted when the LiquidityCooldown changes\\n   * @param liquidityCooldown The value of locktime for added liquidity\\n   */\\n  event LiquidityCooldown(uint32 liquidityCooldown);\\n}\\n\",\"keccak256\":\"0xba47f5fe784ed90a37ad97fbefede84e692b75a15d29d1ce8dc6bc5886f3e68e\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolImmutables.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\nimport '../IDataStorageOperator.sol';\\n\\n/// @title Pool state that never changes\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\ninterface IAlgebraPoolImmutables {\\n  /**\\n   * @notice The contract that stores all the timepoints and can perform actions with them\\n   * @return The operator address\\n   */\\n  function dataStorageOperator() external view returns (address);\\n\\n  /**\\n   * @notice The contract that deployed the pool, which must adhere to the IAlgebraFactory interface\\n   * @return The contract address\\n   */\\n  function factory() external view returns (address);\\n\\n  /**\\n   * @notice The first of the two tokens of the pool, sorted by address\\n   * @return The token contract address\\n   */\\n  function token0() external view returns (address);\\n\\n  /**\\n   * @notice The second of the two tokens of the pool, sorted by address\\n   * @return The token contract address\\n   */\\n  function token1() external view returns (address);\\n\\n  /**\\n   * @notice The pool tick spacing\\n   * @dev Ticks can only be used at multiples of this value\\n   * e.g.: a tickSpacing of 60 means ticks can be initialized every 60th tick, i.e., ..., -120, -60, 0, 60, 120, ...\\n   * This value is an int24 to avoid casting even though it is always positive.\\n   * @return The tick spacing\\n   */\\n  function tickSpacing() external view returns (int24);\\n\\n  /**\\n   * @notice The maximum amount of position liquidity that can use any tick in the range\\n   * @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\\n   * also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\\n   * @return The max amount of liquidity per tick\\n   */\\n  function maxLiquidityPerTick() external view returns (uint128);\\n}\\n\",\"keccak256\":\"0x5cee007433243fd525dcd9113b52f67cd29128424e82bc682a38c97b45ec814e\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolPermissionedActions.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/**\\n * @title Permissioned pool actions\\n * @notice Contains pool methods that may only be called by the factory owner or tokenomics\\n * @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n * https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\n */\\ninterface IAlgebraPoolPermissionedActions {\\n  /**\\n   * @notice Set the community's % share of the fees. Cannot exceed 25% (250)\\n   * @param communityFee0 new community fee percent for token0 of the pool in thousandths (1e-3)\\n   * @param communityFee1 new community fee percent for token1 of the pool in thousandths (1e-3)\\n   */\\n  function setCommunityFee(uint8 communityFee0, uint8 communityFee1) external;\\n\\n  /**\\n   * @notice Sets an active incentive\\n   * @param virtualPoolAddress The address of a virtual pool associated with the incentive\\n   */\\n  function setIncentive(address virtualPoolAddress) external;\\n\\n  /**\\n   * @notice Sets new lock time for added liquidity\\n   * @param newLiquidityCooldown The time in seconds\\n   */\\n  function setLiquidityCooldown(uint32 newLiquidityCooldown) external;\\n}\\n\",\"keccak256\":\"0xc37a8b1f3e3742b79f17eac08cd191981f59ace5096aa1123803ddb081d30024\",\"license\":\"GPL-2.0-or-later\"},\"contracts/integrations/algebra/pool/IAlgebraPoolState.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Pool state that can change\\n/// @dev Credit to Uniswap Labs under GPL-2.0-or-later license:\\n/// https://github.com/Uniswap/v3-core/tree/main/contracts/interfaces\\ninterface IAlgebraPoolState {\\n  /**\\n   * @notice The globalState structure in the pool stores many values but requires only one slot\\n   * and is exposed as a single method to save gas when accessed externally.\\n   * @return price The current price of the pool as a sqrt(token1/token0) Q64.96 value;\\n   * Returns tick The current tick of the pool, i.e. according to the last tick transition that was run;\\n   * Returns This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(price) if the price is on a tick\\n   * boundary;\\n   * Returns fee The last pool fee value in hundredths of a bip, i.e. 1e-6;\\n   * Returns timepointIndex The index of the last written timepoint;\\n   * Returns communityFeeToken0 The community fee percentage of the swap fee in thousandths (1e-3) for token0;\\n   * Returns communityFeeToken1 The community fee percentage of the swap fee in thousandths (1e-3) for token1;\\n   * Returns unlocked Whether the pool is currently locked to reentrancy;\\n   */\\n  function globalState()\\n  external\\n  view\\n  returns (\\n    uint160 price,\\n    int24 tick,\\n    uint16 fee,\\n    uint16 timepointIndex,\\n    uint8 communityFeeToken0,\\n    uint8 communityFeeToken1,\\n    bool unlocked\\n  );\\n\\n  /**\\n   * @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\\n   * @dev This value can overflow the uint256\\n   */\\n  function totalFeeGrowth0Token() external view returns (uint256);\\n\\n  /**\\n   * @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\\n   * @dev This value can overflow the uint256\\n   */\\n  function totalFeeGrowth1Token() external view returns (uint256);\\n\\n  /**\\n   * @notice The currently in range liquidity available to the pool\\n   * @dev This value has no relationship to the total liquidity across all ticks.\\n   * Returned value cannot exceed type(uint128).max\\n   */\\n  function liquidity() external view returns (uint128);\\n\\n  /**\\n   * @notice Look up information about a specific tick in the pool\\n   * @dev This is a public structure, so the `return` natspec tags are omitted.\\n   * @param tick The tick to look up\\n   * @return liquidityTotal the total amount of position liquidity that uses the pool either as tick lower or\\n   * tick upper;\\n   * Returns liquidityDelta how much liquidity changes when the pool price crosses the tick;\\n   * Returns outerFeeGrowth0Token the fee growth on the other side of the tick from the current tick in token0;\\n   * Returns outerFeeGrowth1Token the fee growth on the other side of the tick from the current tick in token1;\\n   * Returns outerTickCumulative the cumulative tick value on the other side of the tick from the current tick;\\n   * Returns outerSecondsPerLiquidity the seconds spent per liquidity on the other side of the tick from the current tick;\\n   * Returns outerSecondsSpent the seconds spent on the other side of the tick from the current tick;\\n   * Returns initialized Set to true if the tick is initialized, i.e. liquidityTotal is greater than 0\\n   * otherwise equal to false. Outside values can only be used if the tick is initialized.\\n   * In addition, these values are only relative and must be used only in comparison to previous snapshots for\\n   * a specific position.\\n   */\\n  function ticks(int24 tick)\\n  external\\n  view\\n  returns (\\n    uint128 liquidityTotal,\\n    int128 liquidityDelta,\\n    uint256 outerFeeGrowth0Token,\\n    uint256 outerFeeGrowth1Token,\\n    int56 outerTickCumulative,\\n    uint160 outerSecondsPerLiquidity,\\n    uint32 outerSecondsSpent,\\n    bool initialized\\n  );\\n\\n  /** @notice Returns 256 packed tick initialized boolean values. See TickTable for more information */\\n  function tickTable(int16 wordPosition) external view returns (uint256);\\n\\n  /**\\n   * @notice Returns the information about a position by the position's key\\n   * @dev This is a public mapping of structures, so the `return` natspec tags are omitted.\\n   * @param key The position's key is a hash of a preimage composed by the owner, bottomTick and topTick\\n   * @return liquidityAmount The amount of liquidity in the position;\\n   * Returns lastLiquidityAddTimestamp Timestamp of last adding of liquidity;\\n   * Returns innerFeeGrowth0Token Fee growth of token0 inside the tick range as of the last mint/burn/poke;\\n   * Returns innerFeeGrowth1Token Fee growth of token1 inside the tick range as of the last mint/burn/poke;\\n   * Returns fees0 The computed amount of token0 owed to the position as of the last mint/burn/poke;\\n   * Returns fees1 The computed amount of token1 owed to the position as of the last mint/burn/poke\\n   */\\n  function positions(bytes32 key)\\n  external\\n  view\\n  returns (\\n    uint128 liquidityAmount,\\n    uint32 lastLiquidityAddTimestamp,\\n    uint256 innerFeeGrowth0Token,\\n    uint256 innerFeeGrowth1Token,\\n    uint128 fees0,\\n    uint128 fees1\\n  );\\n\\n  /**\\n   * @notice Returns data about a specific timepoint index\\n   * @param index The element of the timepoints array to fetch\\n   * @dev You most likely want to use #getTimepoints() instead of this method to get an timepoint as of some amount of time\\n   * ago, rather than at a specific index in the array.\\n   * This is a public mapping of structures, so the `return` natspec tags are omitted.\\n   * @return initialized whether the timepoint has been initialized and the values are safe to use;\\n   * Returns blockTimestamp The timestamp of the timepoint;\\n   * Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the timepoint timestamp;\\n   * Returns secondsPerLiquidityCumulative the seconds per in range liquidity for the life of the pool as of the timepoint timestamp;\\n   * Returns volatilityCumulative Cumulative standard deviation for the life of the pool as of the timepoint timestamp;\\n   * Returns averageTick Time-weighted average tick;\\n   * Returns volumePerLiquidityCumulative Cumulative swap volume per liquidity for the life of the pool as of the timepoint timestamp;\\n   */\\n  function timepoints(uint256 index)\\n  external\\n  view\\n  returns (\\n    bool initialized,\\n    uint32 blockTimestamp,\\n    int56 tickCumulative,\\n    uint160 secondsPerLiquidityCumulative,\\n    uint88 volatilityCumulative,\\n    int24 averageTick,\\n    uint144 volumePerLiquidityCumulative\\n  );\\n\\n  /**\\n   * @notice Returns the information about active incentive\\n   * @dev if there is no active incentive at the moment, virtualPool,endTimestamp,startTimestamp would be equal to 0\\n   * @return virtualPool The address of a virtual pool associated with the current active incentive\\n   */\\n  function activeIncentive() external view returns (address virtualPool);\\n\\n  /**\\n   * @notice Returns the lock time for added liquidity\\n   */\\n  function liquidityCooldown() external view returns (uint32 cooldownInSeconds);\\n}\\n\",\"keccak256\":\"0x2b1226fe9dd67d0759555d8ae8887b3120254f078ec5e0911ded034e594061e3\",\"license\":\"GPL-2.0-or-later\"},\"contracts/interfaces/IPoolProportionsProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IPoolProportionsProvider {\\n  /// @notice Calculate proportions of [underlying, not-underlying] required by the internal pool of the strategy\\n  /// @return Proportion of the not-underlying [0...1e18]\\n  function getPropNotUnderlying18() external view returns (uint);\\n}\\n\",\"keccak256\":\"0xb923a1c932c1cb5bba91d43b92de2fb5271e0ee770cfd31f9ccb133d247e8390\",\"license\":\"MIT\"},\"contracts/libs/AppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice List of all errors generated by the application\\n///         Each error should have unique code TS-XXX and descriptive comment\\nlibrary AppErrors {\\n  /// @notice Provided address should be not zero\\n  string public constant ZERO_ADDRESS = \\\"TS-1 zero address\\\";\\n\\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\\n  string public constant UNISWAP_PAIR_NOT_FOUND = \\\"TS-2 pair not found\\\";\\n\\n  /// @notice Lengths not matched\\n  string public constant WRONG_LENGTHS = \\\"TS-4 wrong lengths\\\";\\n\\n  /// @notice Unexpected zero balance\\n  string public constant ZERO_BALANCE = \\\"TS-5 zero balance\\\";\\n\\n  string public constant ITEM_NOT_FOUND = \\\"TS-6 not found\\\";\\n\\n  string public constant NOT_ENOUGH_BALANCE = \\\"TS-7 not enough balance\\\";\\n\\n  /// @notice Price oracle returns zero price\\n  string public constant ZERO_PRICE = \\\"TS-8 zero price\\\";\\n\\n  string public constant WRONG_VALUE = \\\"TS-9 wrong value\\\";\\n\\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\\n  string public constant ZERO_AMOUNT_BORROWED = \\\"TS-10 zero borrowed amount\\\";\\n\\n  string public constant WITHDRAW_TOO_MUCH = \\\"TS-11 try to withdraw too much\\\";\\n\\n  string public constant UNKNOWN_ENTRY_KIND = \\\"TS-12 unknown entry kind\\\";\\n\\n  string public constant ONLY_TETU_CONVERTER = \\\"TS-13 only TetuConverter\\\";\\n\\n  string public constant WRONG_ASSET = \\\"TS-14 wrong asset\\\";\\n\\n  string public constant NO_LIQUIDATION_ROUTE = \\\"TS-15 No liquidation route\\\";\\n\\n  string public constant PRICE_IMPACT = \\\"TS-16 price impact\\\";\\n\\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\\n  string public constant REPAY_MAKES_SWAP = \\\"TS-17 can not convert back\\\";\\n\\n  string public constant NO_INVESTMENTS = \\\"TS-18 no investments\\\";\\n\\n  string public constant INCORRECT_LENGTHS = \\\"TS-19 lengths\\\";\\n\\n  /// @notice We expect increasing of the balance, but it was decreased\\n  string public constant BALANCE_DECREASE = \\\"TS-20 balance decrease\\\";\\n\\n  /// @notice Prices changed and invested assets amount was increased on S, value of S is too high\\n  string public constant EARNED_AMOUNT_TOO_HIGH = \\\"TS-21 earned too high\\\";\\n\\n  string public constant GOVERNANCE_ONLY = \\\"TS-22 governance only\\\";\\n\\n  /// @notice BorrowLib has recursive call, sub-calls are not allowed\\n  ///         This error can happen if allowed proportion is too small, i.e. 0.0004 : (1-0.0004)\\n  ///         Such situation can happen if amount to swap is almost equal to the amount of the token in the current tick,\\n  ///         so swap will move us close to the border between ticks.\\n  ///         It was decided, that it's ok to have revert in that case\\n  ///         We can change this behavior by changing BorrowLib.rebalanceRepayBorrow implementation:\\n  ///             if amount-to-repay passed to _repayDebt is too small to be used,\\n  ///             we should increase it min amount required to make repay successfully (amount must be > threshold)\\n  string public constant NOT_ALLOWED = \\\"TS-23 not allowed\\\";\\n\\n  string public constant ZERO_VALUE = \\\"TS-24 zero value\\\";\\n\\n  string public constant INCORRECT_SWAP_BY_AGG_PARAM = \\\"TS-25 swap by agg\\\";\\n\\n  string public constant OVER_COLLATERAL_DETECTED = \\\"TS-27 over-collateral\\\";\\n\\n  string public constant NOT_IMPLEMENTED = \\\"TS-28 not implemented\\\";\\n\\n  /// @notice You are not allowed to make direct debt if a NOT-DUST reverse debt exists and visa verse.\\n  string public constant OPPOSITE_DEBT_EXISTS = \\\"TS-29 opposite debt exists\\\";\\n\\n  string public constant INVALID_VALUE = \\\"TS-30 invalid value\\\";\\n\\n  string public constant TOO_HIGH = \\\"TS-32 too high value\\\";\\n}\\n\",\"keccak256\":\"0xe0d15ebe1508ad4e5af4dfb630bdd4343d5006626d3dab4a47f1a6529dfcf632\",\"license\":\"MIT\"},\"contracts/libs/AppLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\\\";\\n\\n/// @notice Common internal utils\\nlibrary AppLib {\\n  using SafeERC20 for IERC20;\\n\\n  /// @notice 1% gap to cover possible liquidation inefficiency\\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\\n  uint internal constant GAP_CONVERSION = 1_000;\\n  /// @dev Absolute value for any token\\n  uint internal constant DEFAULT_LIQUIDATION_THRESHOLD = 100_000;\\n  uint internal constant DENOMINATOR = 100_000;\\n\\n  /// @notice Any amount less than the following is dust\\n  uint public constant DUST_AMOUNT_TOKENS = 100;\\n\\n  /// @notice Unchecked increment for for-cycles\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\n    unchecked {\\n      return i + 1;\\n    }\\n  }\\n\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\n  /// @dev Should NOT be used for third-party pools\\n  function approveIfNeeded(address token, uint amount, address spender) internal {\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\n      IERC20(token).safeApprove(spender, 0);\\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\\n      IERC20(token).safeApprove(spender, 2 ** 255);\\n    }\\n  }\\n\\n  function balance(address token) internal view returns (uint) {\\n    return IERC20(token).balanceOf(address(this));\\n  }\\n\\n  /// @return prices Asset prices in USD, decimals 18\\n  /// @return decs 10**decimals\\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\\n    uint[] memory prices,\\n    uint[] memory decs\\n  ) {\\n    prices = new uint[](len);\\n    decs = new uint[](len);\\n    {\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\\n    uint len = tokens_.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (tokens_[i] == asset_) {\\n        return i;\\n      }\\n    }\\n    return type(uint).max;\\n  }\\n\\n  function _getLiquidator(address controller_) internal view returns (ITetuLiquidator) {\\n    return ITetuLiquidator(IController(controller_).liquidator());\\n  }\\n\\n  function _getPriceOracle(ITetuConverter converter_) internal view returns (IPriceOracle) {\\n    return IPriceOracle(IConverterController(converter_.controller()).priceOracle());\\n  }\\n\\n  /// @notice Calculate liquidation threshold, use default value if the threshold is not set\\n  ///         It's allowed to set any not-zero threshold, it this case default value is not used\\n  /// @dev This function should be applied to the threshold at the moment of the reading its value from the storage.\\n  ///      So, if we pass {mapping(address => uint) storage liquidationThresholds}, the threshold can be zero\\n  ///      bug if we pass {uint liquidationThreshold} to a function, the threshold should be not zero\\n  function _getLiquidationThreshold(uint threshold) internal pure returns (uint) {\\n    return threshold == 0\\n      ? AppLib.DEFAULT_LIQUIDATION_THRESHOLD\\n      : threshold;\\n  }\\n}\\n\",\"keccak256\":\"0xe3c610fe303629445e9152e836ef95632a60a866f9f8ea865473360db80b6302\",\"license\":\"MIT\"},\"contracts/libs/BorrowLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"../strategies/ConverterStrategyBaseLib.sol\\\";\\n\\n/// @notice Library to make new borrow, extend/reduce exist borrows and repay to keep proper assets proportions\\n/// @dev Swap through liquidator is still allowed to be able to get required profitToCover, but this amount is small\\nlibrary BorrowLib {\\n  /// @notice prop0 + prop1\\n  uint constant public SUM_PROPORTIONS = 1e18;\\n\\n  //region -------------------------------------------------- Data types\\n  struct PricesDecs {\\n    /// @notice Asset prices in USD, decimals 18\\n    uint[] prices;\\n    /// @notice decs 10**decimals\\n    uint[] decs;\\n  }\\n\\n  struct ConverterLiquidator {\\n    ITetuConverter converter;\\n    ITetuLiquidator liquidator;\\n  }\\n\\n  struct RebalanceAssetsLocal {\\n    // ------- constant values\\n    address asset0;\\n    address asset1;\\n    /// @notice Proportion of {asset0}, > 0; proportion of {asset1} is SUM_PROPORTIONS - prop0\\n    uint prop0;\\n    /// @notice Min allowed amount of {asset0}-collateral, 0 - use default min value\\n    uint threshold0;\\n    /// @ntoice Min allowed amount of {asset1}-collateral, 0 - use default min value\\n    uint threshold1;\\n\\n    PricesDecs pd;\\n    // ------- refreshable values\\n\\n    // @notice Current balance of {asset0}\\n    uint amount0;\\n    // @notice Current balance of {asset1}\\n    uint amount1;\\n\\n    /// @notice Borrowed amount of not-underlying\\n    uint directDebt;\\n    /// @notice Borrowed amount of underlying\\n    uint reverseDebt;\\n\\n    uint addition0;\\n  }\\n\\n  /// @notice Params required to borrow {assetB} under {assetA}\\n  struct RebalanceAssetsCore {\\n    ConverterLiquidator converterLiquidator;\\n    address assetA;\\n    address assetB;\\n    uint propA;\\n    uint propB;\\n    /// @notice {assetA} to {assetB} ratio; {amountB} * {alpha} => {amountA}, decimals 18\\n    uint alpha18;\\n    /// @notice Min allowed amount of {assetA}-collateral, 0 - use default min value\\n    uint thresholdA;\\n\\n    uint addonA;\\n    uint addonB;\\n\\n    /// @notice Index of {assetA} in {prices} and {decs}\\n    uint indexA;\\n    /// @notice Index of {assetB} in {prices} and {decs}\\n    uint indexB;\\n  }\\n\\n  struct OpenPosition2Local {\\n    uint collateral;\\n    uint toBorrow;\\n    uint cc;\\n    uint cb;\\n    uint c0;\\n    uint cb2;\\n    uint ca0;\\n    uint gamma18;\\n    uint pa2;\\n    uint pb2;\\n    bytes entryData;\\n    uint alpha18;\\n  }\\n  //endregion -------------------------------------------------- Data types\\n\\n  //region -------------------------------------------------- External functions\\n  /// @notice Set balances of {asset0} and {asset1} in proportions {prop0}:{prop1} using borrow/repay (no swaps)\\n  /// @param prop0 Proportion of {asset0}, > 0. Proportion of {asset1} is calculates as 1e18 - prop0\\n  /// @param threshold0 Min allowed amount of {asset0}-collateral, 0 - use default min value\\n  /// @param threshold1 Min allowed amount of {asset1}-collateral, 0 - use default min value\\n  /// @param addition0 Additional amount A0 of {asset0}.\\n  ///                  Balance0 = A0 + B0\\n  ///                  We need following balances in results: B0 : Balance1 === {proportion}:{100_000-proportion}\\n  function rebalanceAssets(\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator_,\\n    address asset0,\\n    address asset1,\\n    uint prop0,\\n    uint threshold0,\\n    uint threshold1,\\n    uint addition0\\n  ) external {\\n    // pool always have TWO assets, it's not allowed ot have only one asset\\n    // so, we assume that the proportions are in the range (0...1e18)\\n    require(prop0 != 0, AppErrors.ZERO_VALUE);\\n    require(prop0 < 1e18, AppErrors.TOO_HIGH);\\n\\n    RebalanceAssetsLocal memory v;\\n    v.asset0 = asset0;\\n    v.asset1 = asset1;\\n    v.prop0 = prop0;\\n    v.threshold0 = threshold0;\\n    v.threshold1 = threshold1;\\n    v.addition0 = addition0;\\n\\n    IPriceOracle priceOracle = AppLib._getPriceOracle(converter_);\\n    address[] memory tokens = new address[](2);\\n    tokens[0] = asset0;\\n    tokens[1] = asset1;\\n    (v.pd.prices, v.pd.decs) = AppLib._getPricesAndDecs(priceOracle, tokens, 2);\\n\\n    _refreshRebalance(v, ConverterLiquidator(converter_, liquidator_), true);\\n  }\\n  //endregion -------------------------------------------------- External functions\\n\\n  //region -------------------------------------------------- Internal helper functions\\n\\n  /// @notice refresh state in {v} and call _rebalanceAssets()\\n  function _refreshRebalance(\\n    RebalanceAssetsLocal memory v,\\n    ConverterLiquidator memory converterLiquidator,\\n    bool repayAllowed\\n  ) internal {\\n    v.amount0 = IERC20(v.asset0).balanceOf(address(this));\\n    v.amount1 = IERC20(v.asset1).balanceOf(address(this));\\n\\n    (v.directDebt, ) = converterLiquidator.converter.getDebtAmountCurrent(address(this), v.asset0, v.asset1, true);\\n    (v.reverseDebt, ) = converterLiquidator.converter.getDebtAmountCurrent(address(this), v.asset1, v.asset0, true);\\n\\n    _rebalanceAssets(v, converterLiquidator, repayAllowed);\\n  }\\n\\n  /// @param repayAllowed Protection against recursion\\n  ///                     Assets can be rebalanced in two ways:\\n  ///                     1) openPosition\\n  ///                     2) repay + openPosition\\n  ///                     Only one repay is allowed.\\n  function _rebalanceAssets(\\n    RebalanceAssetsLocal memory v,\\n    ConverterLiquidator memory converterLiquidator,\\n    bool repayAllowed\\n  ) internal {\\n    uint cost0 = v.amount0 * v.pd.prices[0] / v.pd.decs[0];\\n    uint cost1 = v.amount1 * v.pd.prices[1] / v.pd.decs[1];\\n    uint costAddition0 = v.addition0 * v.pd.prices[0] / v.pd.decs[0];\\n\\n    if (cost0 + cost1 > costAddition0) {\\n      uint totalCost = cost0 + cost1 - costAddition0;\\n\\n      uint requiredCost0 = totalCost * v.prop0 / SUM_PROPORTIONS + costAddition0;\\n      uint requiredCost1 = totalCost * (SUM_PROPORTIONS - v.prop0) / SUM_PROPORTIONS;\\n\\n      if (requiredCost0 > cost0) {\\n        // we need to increase amount of asset 0 and decrease amount of asset 1, so we need to borrow asset 0 (reverse)\\n        RebalanceAssetsCore memory c10 = RebalanceAssetsCore({\\n          converterLiquidator: converterLiquidator,\\n          assetA: v.asset1,\\n          assetB: v.asset0,\\n          propA: SUM_PROPORTIONS - v.prop0,\\n          propB: v.prop0,\\n          alpha18: 1e18 * v.pd.prices[0] * v.pd.decs[1] / v.pd.prices[1] / v.pd.decs[0],\\n          thresholdA: v.threshold1,\\n          addonA: 0,\\n          addonB: v.addition0,\\n          indexA: 1,\\n          indexB: 0\\n        });\\n\\n        if (v.directDebt >= AppLib.DUST_AMOUNT_TOKENS) {\\n          // This branch of code cannot be called recursively.\\n          // Firstly repay(requiredAmount0) is called below. There are two possible results:\\n          // 1) requiredCost0 <= cost0\\n          // 2) v.directDebt == 0\\n          // so, this code cannot be called second time\\n          require(repayAllowed, AppErrors.NOT_ALLOWED);\\n\\n          // repay of v.asset1 is required\\n          uint requiredAmount0 = (requiredCost0 - cost0) * v.pd.decs[0] / v.pd.prices[0];\\n          rebalanceRepayBorrow(v, c10, requiredAmount0, v.directDebt);\\n        } else {\\n          // new (or additional) borrow of asset 0 under asset 1 is required\\n          openPosition(c10, v.pd, v.amount1, v.amount0);\\n        }\\n      } else if (requiredCost0 < cost0) {\\n        RebalanceAssetsCore memory c01 = RebalanceAssetsCore({\\n          converterLiquidator: converterLiquidator,\\n          assetA: v.asset0,\\n          assetB: v.asset1,\\n          propA: v.prop0,\\n          propB: SUM_PROPORTIONS - v.prop0,\\n          alpha18: 1e18 * v.pd.prices[1] * v.pd.decs[0] / v.pd.prices[0] / v.pd.decs[1],\\n          thresholdA: v.threshold0,\\n          addonA: v.addition0,\\n          addonB: 0,\\n          indexA: 0,\\n          indexB: 1\\n        });\\n        // we need to decrease amount of asset 0 and increase amount of asset 1, so we need to borrow asset 1 (direct)\\n        if (v.reverseDebt >= AppLib.DUST_AMOUNT_TOKENS) {\\n          require(repayAllowed, AppErrors.NOT_ALLOWED);\\n\\n          // repay of v.asset0 is required\\n          // requiredCost0 < cost0 => requiredCost1 > cost1\\n          uint requiredAmount1 = (requiredCost1 - cost1) * v.pd.decs[1] / v.pd.prices[1];\\n          rebalanceRepayBorrow(v, c01, requiredAmount1, v.reverseDebt);\\n        } else {\\n          // new or additional borrow of asset 1 under asset 0 is required\\n          openPosition(c01, v.pd, v.amount0, v.amount1);\\n        }\\n      }\\n    } else {\\n      // if costAddition0 exceeds cost0 + cost1, all amounts should be converted to asset 0\\n      // for simplicity, we don't make any swaps or borrows (amount addition0 is assumed to be small)\\n      // and just leave balances as is\\n      // as result, profit-to-cover will be reduced from costAddition0 to v.amount0\\n    }\\n  }\\n\\n  /// @notice Repay {amountDebtA} fully or partially to get at least {requiredAmountB} of collateral\\n  ///         then try to rebalance once more\\n  /// @param requiredAmountB Amount of collateral that we need to receive after repay\\n  /// @param amountDebtA Total amount that is required to pay to close the debt\\n  function rebalanceRepayBorrow(\\n    RebalanceAssetsLocal memory v,\\n    RebalanceAssetsCore memory c,\\n    uint requiredAmountB,\\n    uint amountDebtA\\n  ) internal {\\n    // we need to get {requiredAmountB}\\n    // we don't know exact amount to repay\\n    // but we are sure that amount {requiredAmountB ===> requiredAmountA} would be more than required\\n    uint capRequiredAmountA = requiredAmountB * c.alpha18 / 1e18;\\n    uint amountToRepay = Math.min(capRequiredAmountA, amountDebtA);\\n    if (amountToRepay >= AppLib.DUST_AMOUNT_TOKENS) {\\n      ConverterStrategyBaseLib._repayDebt(c.converterLiquidator.converter, c.assetB, c.assetA, amountToRepay);\\n      _refreshRebalance(v, c.converterLiquidator, false);\\n    } // else the assets are already in proper proportions\\n  }\\n\\n  //endregion -------------------------------------------------- Internal helper functions\\n\\n  //region -------------------------------------------------- Open position\\n  /// @notice borrow asset B under asset A. Result balances should be A0 + A1, B0 + B1\\n  ///         Where (A1 : B1) == (propA : propB), A0 and B0 are equal to {c.addonA} and {c.addonB}\\n  /// @param balanceA_ Current balance of the collateral\\n  /// @param balanceB_ Current balance of the borrow asset\\n  function openPosition(\\n    RebalanceAssetsCore memory c,\\n    PricesDecs memory pd,\\n    uint balanceA_,\\n    uint balanceB_\\n  ) internal returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    // if there are two not-zero addons, the caller should reduce balances before the call\\n    require(c.addonA == 0 || c.addonB == 0, AppErrors.INVALID_VALUE);\\n\\n    // we are going to borrow B under A\\n    if (c.addonB != 0) {\\n      // B is underlying, so we are going to borrow underlying\\n      if (balanceB_ >= c.addonB) {\\n        // simple case - we already have required addon on the balance. Just keep it unused\\n        return _openPosition(c, balanceA_, balanceB_ - c.addonB);\\n      } else {\\n        // we need to get 1) (c.addonB + balanceB_) amount, so we will have required c.addonB\\n        //                2) leftovers of A and B should be allocated in required proportions\\n        // it's too hard to calculate correctly required to borrow amount in this case without changing TetuConverter\\n        // but we can assume here, that amount (c.addonB - balanceB_) is pretty small (it's profitToCover)\\n        // so, we can swap this required amount through liquidator at first\\n        // then use _openPosition to re-allocated rest amounts to proper proportions\\n        (uint decA,) = _makeLittleSwap(c, pd, balanceA_, c.addonB - balanceB_);\\n        return _openPosition(c, balanceA_ - decA, balanceB_);\\n      }\\n    } else if (c.addonA != 0) {\\n      // A is underlying, we need to put aside c.addonA and allocate leftovers in right proportions.\\n      // we are going to borrow B under asset A, so the case (balanceA_ < c.addonA) is not valid here\\n      require(balanceA_ >= c.addonA, AppErrors.NOT_ENOUGH_BALANCE);\\n      return _openPosition(c, balanceA_ - c.addonA, balanceB_);\\n    } else {\\n      // simple logic, no addons\\n      return _openPosition(c, balanceA_, balanceB_);\\n    }\\n  }\\n\\n  /// @notice borrow asset B under asset A, result balances should have proportions: (propA : propB)\\n  function _openPosition(RebalanceAssetsCore memory c, uint balanceA_, uint balanceB_) internal returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    uint untouchedAmountA;\\n    bytes memory entryData = abi.encode(1, c.propA, c.propB);\\n\\n    if (balanceB_ != 0) {\\n      // we are going to use {balanceA_} as collateral\\n      // but there is some amount on {balanceB_}, so we need to keep corresponded part of {balanceA_} untouched\\n      untouchedAmountA = balanceB_ * c.alpha18 * c.propA / c.propB / 1e18;\\n\\n      // we are going to borrow B under A, so balance A must be greater then balance B\\n      // otherwise the function is called incorrectly - probably we need to borrow A under B\\n      require(untouchedAmountA <= balanceA_, AppErrors.WRONG_VALUE);\\n    }\\n\\n    AppLib.approveIfNeeded(c.assetA, balanceA_ - untouchedAmountA, address(c.converterLiquidator.converter));\\n\\n    return ConverterStrategyBaseLib.openPosition(\\n      c.converterLiquidator.converter,\\n      entryData,\\n      c.assetA,\\n      c.assetB,\\n      balanceA_ - untouchedAmountA,\\n      c.thresholdA\\n    );\\n  }\\n\\n  //endregion -------------------------------------------------- Open position\\n\\n  //region -------------------------------------------------- Little swap\\n  /// @notice Swap min amount of A to get {requiredAmountB}\\n  /// @return spentAmountIn how much the balance A has decreased\\n  /// @return receivedAmountOut how much the balance B has increased\\n  function _makeLittleSwap(\\n    RebalanceAssetsCore memory c,\\n    PricesDecs memory pd,\\n    uint balanceA_,\\n    uint requiredAmountB\\n  ) internal returns (\\n    uint spentAmountIn,\\n    uint receivedAmountOut\\n  ) {\\n    uint amountInA = requiredAmountB * pd.prices[c.indexB] * pd.decs[c.indexA] / pd.prices[c.indexA] / pd.decs[c.indexB];\\n    // we can have some loss because of slippage\\n    // so, let's increase input amount a bit\\n    amountInA = amountInA * (100_000 + ConverterStrategyBaseLib._ASSET_LIQUIDATION_SLIPPAGE) / 100_000;\\n\\n    // in practice the addition is required to pay ProfitToCover\\n    // we assume, that total addition amount is small enough, much smaller then the total balance\\n    // otherwise something is wrong: we are going to pay ProfitToCover, but we don't have enough amount on the balances.\\n    require(balanceA_ > amountInA, AppErrors.NOT_ENOUGH_BALANCE);\\n\\n    (spentAmountIn, receivedAmountOut) = ConverterStrategyBaseLib.liquidate(\\n      c.converterLiquidator.converter,\\n      c.converterLiquidator.liquidator,\\n      c.assetA,\\n      c.assetB,\\n      amountInA,\\n      ConverterStrategyBaseLib._ASSET_LIQUIDATION_SLIPPAGE,\\n      c.thresholdA,\\n      false\\n    );\\n  }\\n\\n  //endregion -------------------------------------------------- Little swap\\n\\n}\",\"keccak256\":\"0xdca0c50484bb82f660e583196d56d43192e0d8bf350ae105fd702a55f5884360\",\"license\":\"MIT\"},\"contracts/libs/ConverterEntryKinds.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\\nlibrary ConverterEntryKinds {\\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\\n\\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\\n  ///         C2 should be used as collateral to make a borrow B.\\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\\n\\n  /// @notice Borrow given amount using min possible collateral\\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\\n\\n  /// @notice Decode entryData, extract first uint - entry kind\\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\\n    if (entryData_.length == 0) {\\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\\n    }\\n    return abi.decode(entryData_, (uint));\\n  }\\n}\\n\",\"keccak256\":\"0x42e53e67f20fe11a5f5209e21f2d9b2ebeacdb197ae506ac796920907ea679a2\",\"license\":\"MIT\"},\"contracts/libs/IterationPlanLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"./AppErrors.sol\\\";\\nimport \\\"./AppLib.sol\\\";\\n\\n/// @notice Support of withdraw iteration plans\\nlibrary IterationPlanLib {\\n\\n//region ------------------------------------------------ Constants\\n  /// @notice Swap collateral asset to get required amount-to-repay, then repay and get more collateral back.\\n  ///         It tries to minimizes count of repay-operations.\\n  ///         If there are no debts, swap leftovers to get required proportions of the asset.\\n  ///         This mode is intended i.e. for \\\"withdraw all\\\"\\n  ///         (uint256, uint256) - (entry kind, propNotUnderlying18)\\n  /// propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\n  ///                     The assets should be swapped to get following result proportions:\\n  ///                     not-underlying : underlying === propNotUnderlying18 : (1e18 - propNotUnderlying18)\\n  ///                     Pass type(uint).max to read proportions from the pool.\\n  uint constant public PLAN_SWAP_REPAY = 0;\\n\\n  /// @notice Repay available amount-to-repay, swap all or part of collateral to borrowed-asset, make one repay if needed.\\n  ///         Swap + second repay tries to make asset balances to proportions required by the pool.\\n  ///         Proportions are read from pool through IPoolProportionsProvider(this) and re-read after swapping.\\n  ///         This mode is intended i.e. for rebalancing debts using single iteration.\\n  ///         (uint256, uint256) - (entry kind, propNotUnderlying18)\\n  /// propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\n  ///                     The assets should be swapped to get following result proportions:\\n  ///                     not-underlying : underlying === propNotUnderlying18 : (1e18 - propNotUnderlying18)\\n  ///                     Pass type(uint).max to read proportions from the pool.\\n  uint constant public PLAN_REPAY_SWAP_REPAY = 1;\\n\\n  /// @notice Swap leftovers to required proportions, don't repay any debts\\n  ///         (uint256, uint256) - (entry kind, propNotUnderlying18)\\n  /// propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\n  ///                     The assets should be swapped to get following result proportions:\\n  ///                     not-underlying : underlying === propNotUnderlying18 : (1e18 - propNotUnderlying18)\\n  ///                     Pass type(uint).max to read proportions from the pool.\\n  uint constant public PLAN_SWAP_ONLY = 2;\\n//endregion ------------------------------------------------ Constants\\n\\n//region ------------------------------------------------ Data types\\n  /// @notice Set of parameters required to liquidation through aggregators\\n  struct SwapRepayPlanParams {\\n    ITetuConverter converter;\\n    ITetuLiquidator liquidator;\\n\\n    /// @notice Assets used by depositor stored as following way: [underlying, not-underlying]\\n    address[] tokens;\\n\\n    /// @notice Liquidation thresholds for the {tokens}\\n    uint[] liquidationThresholds;\\n\\n    /// @notice Cost of $1 in terms of the assets, decimals 18\\n    uint[] prices;\\n    /// @notice 10**decimal for the assets\\n    uint[] decs;\\n\\n    /// @notice Amounts that will be received on balance before execution of the plan.\\n    uint[] balanceAdditions;\\n\\n    /// @notice Plan kind extracted from entry data, see {IterationPlanKinds}\\n    uint planKind;\\n\\n    /// @notice Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\n    ///         The leftovers should be swapped to get following result proportions of the assets:\\n    ///         not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\n    uint propNotUnderlying18;\\n\\n    /// @notice proportions should be taken from the pool and re-read from the pool after each swap\\n    bool usePoolProportions;\\n  }\\n\\n  struct GetIterationPlanLocal {\\n    /// @notice Underlying balance\\n    uint assetBalance;\\n    /// @notice Not-underlying balance\\n    uint tokenBalance;\\n\\n    uint totalDebt;\\n    uint totalCollateral;\\n\\n    uint debtReverse;\\n    uint collateralReverse;\\n\\n    address asset;\\n    address token;\\n\\n    bool swapLeftoversNeeded;\\n  }\\n\\n  struct EstimateSwapAmountForRepaySwapRepayLocal {\\n    uint x;\\n    uint y;\\n    uint bA1;\\n    uint bB1;\\n    uint alpha;\\n    uint swapRatio;\\n    uint aB3;\\n    uint cA1;\\n    uint cB1;\\n    uint aA2;\\n  }\\n//endregion ------------------------------------------------ Data types\\n\\n  /// @notice Decode entryData, extract first uint - entry kind\\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\\n    if (entryData_.length == 0) {\\n      return PLAN_SWAP_REPAY;\\n    }\\n    return abi.decode(entryData_, (uint));\\n  }\\n\\n//region ------------------------------------------------ Build plan\\n  /// @notice Build plan to make single iteration of withdraw according to the selected plan\\n  ///         The goal is to withdraw {requestedAmount} and receive {asset}:{token} in proper proportions on the balance\\n  /// @param converterLiquidator [TetuConverter, TetuLiquidator]\\n  /// @param tokens List of the pool tokens. One of them is underlying and one of then is not-underlying\\n  ///               that we are going to withdraw\\n  /// @param liquidationThresholds Liquidation thresholds for the {tokens}. If amount is less then the threshold,\\n  ///                              we cannot swap it.\\n  /// @param prices Prices of the {tokens}, decimals 18, [$/token]\\n  /// @param decs 10**decimal for each token of the {tokens}\\n  /// @param balanceAdditions Amounts that will be added to the current balances of the {tokens}\\n  ///                         to the moment of the plan execution\\n  /// @param packedData Several values packed to fixed-size array (to reduce number of params)\\n  ///    0: usePoolProportions: 1 - read proportions from the pool through IPoolProportionsProvider(this)\\n  ///    1: planKind: selected plan, one of PLAN_XXX\\n  ///    2: propNotUnderlying18: value of not-underlying proportion [0..1e18] if usePoolProportions == 0\\n  ///    3: requestedAmount: total amount that should be withdrawn, it can be type(uint).max\\n  ///    4: indexAsset: index of the underlying in {tokens} array\\n  ///    5: indexToken: index of the token in {tokens} array. We are going to withdraw the token and convert it to the asset\\n  function buildIterationPlan(\\n    address[2] memory converterLiquidator,\\n    address[] memory tokens,\\n    uint[] memory liquidationThresholds,\\n    uint[] memory prices,\\n    uint[] memory decs,\\n    uint[] memory balanceAdditions,\\n    uint[6] memory packedData\\n  ) external returns (\\n    uint indexToSwapPlus1,\\n    uint amountToSwap,\\n    uint indexToRepayPlus1\\n  ) {\\n    return _buildIterationPlan(\\n      SwapRepayPlanParams({\\n        converter: ITetuConverter(converterLiquidator[0]),\\n        liquidator: ITetuLiquidator(converterLiquidator[1]),\\n        tokens: tokens,\\n        liquidationThresholds: liquidationThresholds,\\n        prices: prices,\\n        decs: decs,\\n        balanceAdditions: balanceAdditions,\\n        planKind: packedData[1],\\n        propNotUnderlying18: packedData[2],\\n        usePoolProportions: packedData[0] != 0\\n      }),\\n      packedData[3],\\n      packedData[4],\\n      packedData[5]\\n    );\\n  }\\n\\n  /// @notice Generate plan for next withdraw iteration. We can do only one swap per iteration.\\n  ///         In general, we cam make 1) single swap (direct or reverse) and 2) repay\\n  ///         Swap is required to get required repay-amount OR to swap leftovers on final iteration.\\n  /// @param requestedAmount Amount of underlying that we need to get on balance finally.\\n  /// @param indexAsset Index of the underlying in {p.tokens} array\\n  /// @param indexToken Index of the not-underlying in {p.tokens} array\\n  /// @return indexToSwapPlus1 1-based index of the token to be swapped; 0 means swap is not required.\\n  /// @return amountToSwap Amount to be swapped. 0 - no swap\\n  /// @return indexToRepayPlus1 1-based index of the token that should be used to repay borrow in converter.\\n  ///                            0 - no repay is required - it means that this is a last step with swapping leftovers.\\n  function _buildIterationPlan(\\n    SwapRepayPlanParams memory p,\\n    uint requestedAmount,\\n    uint indexAsset,\\n    uint indexToken\\n  ) internal returns (\\n    uint indexToSwapPlus1,\\n    uint amountToSwap,\\n    uint indexToRepayPlus1\\n  ) {\\n    GetIterationPlanLocal memory v;\\n    v.asset = p.tokens[indexAsset];\\n    v.token = p.tokens[indexToken];\\n\\n    v.assetBalance = IERC20(v.asset).balanceOf(address(this)) + p.balanceAdditions[indexAsset];\\n    v.tokenBalance = IERC20(p.tokens[indexToken]).balanceOf(address(this)) + p.balanceAdditions[indexToken];\\n\\n    if (p.planKind == IterationPlanLib.PLAN_SWAP_ONLY) {\\n      v.swapLeftoversNeeded = true;\\n    } else {\\n      if (requestedAmount < p.liquidationThresholds[indexAsset]) {\\n        // we don't need to repay any debts anymore, but we should swap leftovers\\n        v.swapLeftoversNeeded = true;\\n      } else {\\n        // we need to increase balance on the following amount: requestedAmount - v.balance;\\n        // we can have two possible borrows:\\n        // 1) direct (p.tokens[INDEX_ASSET] => tokens[i]) and 2) reverse (tokens[i] => p.tokens[INDEX_ASSET])\\n        // normally we can have only one of them, not both..\\n        // but better to take into account possibility to have two debts simultaneously\\n\\n        // reverse debt\\n        (v.debtReverse, v.collateralReverse) = p.converter.getDebtAmountCurrent(address(this), v.token, v.asset, true);\\n\\n        if (v.debtReverse < AppLib.DUST_AMOUNT_TOKENS) { // there is reverse debt or the reverse debt is dust debt\\n          // direct debt\\n          (v.totalDebt, v.totalCollateral) = p.converter.getDebtAmountCurrent(address(this), v.asset, v.token, true);\\n\\n          if (v.totalDebt < AppLib.DUST_AMOUNT_TOKENS) { // there is direct debt or the direct debt is dust debt\\n            // This is final iteration - we need to swap leftovers and get amounts on balance in proper proportions.\\n            // The leftovers should be swapped to get following result proportions of the assets:\\n            //      underlying : not-underlying === 1e18 - propNotUnderlying18 : propNotUnderlying18\\n            v.swapLeftoversNeeded = true;\\n          } else {\\n            // repay direct debt\\n            if (p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY) {\\n              (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanRepaySwapRepay(\\n                p,\\n                [v.assetBalance, v.tokenBalance],\\n                [indexAsset, indexToken],\\n                p.propNotUnderlying18,\\n                v.totalCollateral,\\n                v.totalDebt\\n              );\\n            } else {\\n              (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanForSellAndRepay(\\n                requestedAmount,\\n                p,\\n                v.totalCollateral,\\n                v.totalDebt,\\n                indexAsset,\\n                indexToken,\\n                v.assetBalance,\\n                v.tokenBalance\\n              );\\n            }\\n          }\\n        } else {\\n          // repay reverse debt\\n          if (p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY) {\\n            (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanRepaySwapRepay(\\n              p,\\n              [v.tokenBalance, v.assetBalance],\\n              [indexToken, indexAsset],\\n              1e18 - p.propNotUnderlying18,\\n              v.collateralReverse,\\n              v.debtReverse\\n            );\\n          } else {\\n            (indexToSwapPlus1, amountToSwap, indexToRepayPlus1) = _buildPlanForSellAndRepay(\\n              requestedAmount == type(uint).max\\n                ? type(uint).max\\n                : requestedAmount * p.prices[indexAsset] * p.decs[indexToken] / p.prices[indexToken] / p.decs[indexAsset],\\n              p,\\n              v.collateralReverse,\\n              v.debtReverse,\\n              indexToken,\\n              indexAsset,\\n              v.tokenBalance,\\n              v.assetBalance\\n            );\\n          }\\n        }\\n      }\\n    }\\n\\n    if (v.swapLeftoversNeeded) {\\n      (indexToSwapPlus1, amountToSwap) = _buildPlanForLeftovers(p, v.assetBalance, v.tokenBalance, indexAsset, indexToken, p.propNotUnderlying18);\\n    }\\n\\n    return (indexToSwapPlus1, amountToSwap, indexToRepayPlus1);\\n  }\\n\\n  /// @notice Repay B, get collateral A, then swap A => B, [make one more repay B] => get A:B in required proportions\\n  /// @param balancesAB [balanceA, balanceB]\\n  /// @param idxAB [indexA, indexB]\\n  function _buildPlanRepaySwapRepay(\\n    SwapRepayPlanParams memory p,\\n    uint[2] memory balancesAB,\\n    uint[2] memory idxAB,\\n    uint propB,\\n    uint totalCollateralA,\\n    uint totalBorrowB\\n  ) internal returns (\\n    uint indexToSwapPlus1,\\n    uint amountToSwap,\\n    uint indexToRepayPlus1\\n  ) {\\n    // use all available tokenB to repay debt and receive as much as possible tokenA\\n    uint amountToRepay = Math.min(balancesAB[1], totalBorrowB);\\n\\n    uint collateralAmount;\\n    if (amountToRepay >= AppLib.DUST_AMOUNT_TOKENS) {\\n      (collateralAmount,) = p.converter.quoteRepay(address(this), p.tokens[idxAB[0]], p.tokens[idxAB[1]], amountToRepay);\\n    } else {\\n      amountToRepay = 0;\\n    }\\n\\n    // swap A to B: full or partial\\n    amountToSwap = estimateSwapAmountForRepaySwapRepay(\\n      p,\\n      balancesAB[0],\\n      balancesAB[1],\\n      idxAB[0],\\n      idxAB[1],\\n      propB,\\n      totalCollateralA,\\n      totalBorrowB,\\n      collateralAmount,\\n      amountToRepay\\n    );\\n\\n    return (idxAB[0] + 1, amountToSwap, idxAB[1] + 1);\\n  }\\n\\n  /// @notice Estimate swap amount for iteration \\\"repay-swap-repay\\\"\\n  ///         The iteration should give us amounts of assets in required proportions.\\n  ///         There are two cases here: full swap and partial swap. Second repay is not required if the swap is partial.\\n  /// @param collateralA Estimated value of collateral A received after repay balanceB\\n  /// @return amount of token A to be swapped\\n  function estimateSwapAmountForRepaySwapRepay(\\n    SwapRepayPlanParams memory p,\\n    uint balanceA,\\n    uint balanceB,\\n    uint indexA,\\n    uint indexB,\\n    uint propB,\\n    uint totalCollateralA,\\n    uint totalBorrowB,\\n    uint collateralA,\\n    uint amountToRepayB\\n  ) internal pure returns(uint) {\\n    // N - number of the state\\n    // bAN, bBN - balances of A and B; aAN, aBN - amounts of A and B; cAN, cBN - collateral/borrow amounts of A/B\\n    // alpha ~ cAN/cBN - estimated ratio of collateral/borrow\\n    // s = swap ratio, aA is swapped to aB, so aA = s * aB\\n    // g = split ratio, bA1 is divided on two parts: bA1 * gamma, bA1 * (1 - gamma). First part is swapped.\\n    // X = proportion of A, Y = proportion of B\\n\\n    // Formulas\\n    // aB3 = (x * bB2 - y * bA2) / (alpha * y + x)\\n    // gamma = (y * bA1 - x * bB1) / (bA1 * (x * s + y))\\n\\n    // There are following stages:\\n    // 0. init (we have at least not zero amount of B and not zero debt of B)\\n    // 1. repay 1 (repay all available amount of B OR all available debt)\\n    // 2. swap (swap A fully or partially to B)\\n    // 3. repay 2 (optional: we need this stage if full swap produces amount of B that is <= available debt)\\n    // 4. final (we have assets in right proportion on the balance)\\n    EstimateSwapAmountForRepaySwapRepayLocal memory v;\\n    v.x = 1e18 - propB;\\n    v.y = propB;\\n\\n// 1. repay 1\\n    // convert amounts A, amounts B to cost A, cost B in USD\\n    v.bA1 = (balanceA + collateralA) * p.prices[indexA] / p.decs[indexA];\\n    v.bB1 = (balanceB - amountToRepayB) * p.prices[indexB] / p.decs[indexB];\\n    v.cB1 = (totalBorrowB - amountToRepayB) * p.prices[indexB] / p.decs[indexB];\\n    v.alpha = 1e18 * totalCollateralA * p.prices[indexA] * p.decs[indexB]\\n      / p.decs[indexA] / p.prices[indexB] / totalBorrowB; // (!) approx estimation\\n\\n// 2. full swap\\n    v.aA2 = v.bA1;\\n    v.swapRatio = 1e18; // we assume swap ratio 1:1\\n\\n// 3. repay 2\\n    // aB3 = (x * bB2 - Y * bA2) / (alpha * y + x)\\n    v.aB3 = (\\n      v.x * (v.bB1 + v.aA2 * v.swapRatio / 1e18)    // bB2 = v.bB1 + v.aA2 * v.s / 1e18\\n      - v.y * (v.bA1 - v.aA2)                       // bA2 = v.bA1 - v.aA2;\\n    ) / (v.y * v.alpha / 1e18 + v.x);\\n\\n    if (v.aB3 > v.cB1) {\\n      // there is not enough debt to make second repay\\n      // we need to make partial swap and receive assets in right proportions in result\\n      // v.gamma = 1e18 * (v.y * v.bA1 - v.x * v.bB1) / (v.bA1 * (v.x * v.s / 1e18 + v.y));\\n      v.aA2 = v.bA1 * (v.y * v.bA1 - v.x * v.bB1) / (v.bA1 * (v.x * v.swapRatio / 1e18 + v.y));\\n    }\\n\\n    return v.aA2 * p.decs[indexA] / p.prices[indexA];\\n  }\\n\\n  /// @notice Prepare a plan to swap leftovers to required proportion\\n  /// @param balanceA Balance of token A, i.e. underlying\\n  /// @param balanceB Balance of token B, i.e. not-underlying\\n  /// @param indexA Index of the token A, i.e. underlying, in {p.prices} and {p.decs}\\n  /// @param indexB Index of the token B, i.e. not-underlying, in {p.prices} and {p.decs}\\n  /// @param propB Required proportion of TokenB [0..1e18]. Proportion of token A is (1e18-propB)\\n  /// @return indexTokenToSwapPlus1 Index of the token to be swapped. 0 - no swap is required\\n  /// @return amountToSwap Amount to be swapped. 0 - no swap is required\\n  function _buildPlanForLeftovers(\\n    SwapRepayPlanParams memory p,\\n    uint balanceA,\\n    uint balanceB,\\n    uint indexA,\\n    uint indexB,\\n    uint propB\\n  ) internal pure returns (\\n    uint indexTokenToSwapPlus1,\\n    uint amountToSwap\\n  ) {\\n    (uint targetA, uint targetB) = _getTargetAmounts(p.prices, p.decs, balanceA, balanceB, propB, indexA, indexB);\\n    if (balanceA < targetA) {\\n      // we need to swap not-underlying to underlying\\n      if (balanceB - targetB > p.liquidationThresholds[indexB]) {\\n        amountToSwap = balanceB - targetB;\\n        indexTokenToSwapPlus1 = indexB + 1;\\n      }\\n    } else {\\n      // we need to swap underlying to not-underlying\\n      if (balanceA - targetA > p.liquidationThresholds[indexA]) {\\n        amountToSwap = balanceA - targetA;\\n        indexTokenToSwapPlus1 = indexA + 1;\\n      }\\n    }\\n    return (indexTokenToSwapPlus1, amountToSwap);\\n  }\\n\\n  /// @notice Prepare a plan to swap some amount of collateral to get required repay-amount and make repaying\\n  ///         1) Sell collateral-asset to get missed amount-to-repay 2) make repay and get more collateral back\\n  /// @param requestedAmount Amount of underlying that we need to get on balance finally.\\n  /// @param totalCollateral Total amount of collateral used in the borrow\\n  /// @param totalDebt Total amount of debt that should be repaid to receive {totalCollateral}\\n  /// @param indexCollateral Index of collateral asset in {p.prices}, {p.decs}\\n  /// @param indexBorrow Index of borrow asset in {p.prices}, {p.decs}\\n  /// @param balanceCollateral Current balance of the collateral asset\\n  /// @param balanceBorrow Current balance of the borrowed asset\\n  /// @param indexTokenToSwapPlus1 1-based index of the token to be swapped. Swap of amount of collateral asset can be required\\n  ///                              to receive missed amount-to-repay. 0 - no swap is required\\n  /// @param amountToSwap Amount to be swapped. 0 - no swap is required\\n  /// @param indexRepayTokenPlus1 1-based index of the token to be repaied. 0 - no repaying is required\\n  function _buildPlanForSellAndRepay(\\n    uint requestedAmount,\\n    SwapRepayPlanParams memory p,\\n    uint totalCollateral,\\n    uint totalDebt,\\n    uint indexCollateral,\\n    uint indexBorrow,\\n    uint balanceCollateral,\\n    uint balanceBorrow\\n  ) internal pure returns (\\n    uint indexTokenToSwapPlus1,\\n    uint amountToSwap,\\n    uint indexRepayTokenPlus1\\n  ) {\\n    // what amount of collateral we should sell to get required amount-to-pay to pay the debt\\n    uint toSell = _getAmountToSell(\\n      requestedAmount,\\n      totalDebt,\\n      totalCollateral,\\n      p.prices,\\n      p.decs,\\n      indexCollateral,\\n      indexBorrow,\\n      balanceBorrow\\n    );\\n\\n    // convert {toSell} amount of underlying to token\\n    if (toSell != 0 && balanceCollateral != 0) {\\n      toSell = Math.min(toSell, balanceCollateral);\\n      uint threshold = p.liquidationThresholds[indexCollateral];\\n      if (toSell > threshold) {\\n        amountToSwap = toSell;\\n        indexTokenToSwapPlus1 = indexCollateral + 1;\\n      } else {\\n        // we need to sell amount less than the threshold, it's not allowed\\n        // but it's dangerous to just ignore the selling because there is a chance to have error 35\\n        // (There is a debt $3.29, we make repay $3.27 => error 35)\\n        // it would be safer to sell a bit more amount if it's possible\\n        if (balanceCollateral >= threshold + 1) {\\n          amountToSwap = threshold + 1;\\n          indexTokenToSwapPlus1 = indexCollateral + 1;\\n        }\\n      }\\n    }\\n\\n    return (indexTokenToSwapPlus1, amountToSwap, indexBorrow + 1);\\n  }\\n\\n  /// @notice Calculate what balances of underlying and not-underlying we need to fit {propNotUnderlying18}\\n  /// @param prices Prices of underlying and not underlying\\n  /// @param decs 10**decimals for underlying and not underlying\\n  /// @param assetBalance Current balance of underlying\\n  /// @param tokenBalance Current balance of not-underlying\\n  /// @param propNotUnderlying18 Required proportion of not-underlying [0..1e18]\\n  ///                            Proportion of underlying would be (1e18 - propNotUnderlying18)\\n  /// @param targetAssets What result balance of underlying is required to fit to required proportions\\n  /// @param targetTokens What result balance of not-underlying is required to fit to required proportions\\n  function _getTargetAmounts(\\n    uint[] memory prices,\\n    uint[] memory decs,\\n    uint assetBalance,\\n    uint tokenBalance,\\n    uint propNotUnderlying18,\\n    uint indexAsset,\\n    uint indexToken\\n  ) internal pure returns (\\n    uint targetAssets,\\n    uint targetTokens\\n  ) {\\n    uint costAssets = assetBalance * prices[indexAsset] / decs[indexAsset];\\n    uint costTokens = tokenBalance * prices[indexToken] / decs[indexToken];\\n    targetTokens = propNotUnderlying18 == 0\\n      ? 0\\n      : ((costAssets + costTokens) * propNotUnderlying18 / 1e18);\\n    targetAssets = ((costAssets + costTokens) - targetTokens) * decs[indexAsset] / prices[indexAsset];\\n    targetTokens = targetTokens * decs[indexToken] / prices[indexToken];\\n  }\\n\\n  /// @notice What amount of collateral should be sold to pay the debt and receive {requestedAmount}\\n  /// @dev It doesn't allow to sell more than the amount of total debt in the borrow\\n  /// @param requestedAmount We need to increase balance (of collateral asset) on this amount\\n  /// @param totalDebt Total debt of the borrow in terms of borrow asset\\n  /// @param totalCollateral Total collateral of the borrow in terms of collateral asset\\n  /// @param prices Cost of $1 in terms of the asset, decimals 18\\n  /// @param decs 10**decimals for each asset\\n  /// @param indexCollateral Index of the collateral asset in {prices} and {decs}\\n  /// @param indexBorrowAsset Index of the borrow asset in {prices} and {decs}\\n  /// @param balanceBorrowAsset Available balance of the borrow asset, it will be used to cover the debt\\n  /// @return amountOut Amount of collateral-asset that should be sold\\n  function _getAmountToSell(\\n    uint requestedAmount,\\n    uint totalDebt,\\n    uint totalCollateral,\\n    uint[] memory prices,\\n    uint[] memory decs,\\n    uint indexCollateral,\\n    uint indexBorrowAsset,\\n    uint balanceBorrowAsset\\n  ) internal pure returns (\\n    uint amountOut\\n  ) {\\n    if (totalDebt != 0) {\\n      if (balanceBorrowAsset != 0) {\\n        // there is some borrow asset on balance\\n        // it will be used to cover the debt\\n        // let's reduce the size of totalDebt/Collateral to exclude balanceBorrowAsset\\n        uint sub = Math.min(balanceBorrowAsset, totalDebt);\\n        totalCollateral -= totalCollateral * sub / totalDebt;\\n        totalDebt -= sub;\\n      }\\n\\n      // for definiteness: usdc - collateral asset, dai - borrow asset\\n      // Pc = price of the USDC, Pb = price of the DAI, alpha = Pc / Pb [DAI / USDC]\\n      // S [USDC] - amount to sell, R [DAI] = alpha * S - amount to repay\\n      // After repaying R we get: alpha * S * C / R\\n      // Balance should be increased on: requestedAmount = alpha * S * C / R - S\\n      // So, we should sell: S = requestedAmount / (alpha * C / R - 1))\\n      // We can lost some amount on liquidation of S => R, so we need to use some gap = {GAP_AMOUNT_TO_SELL}\\n      // Same formula: S * h = S + requestedAmount, where h = health factor => s = requestedAmount / (h - 1)\\n      // h = alpha * C / R\\n      uint alpha18 = prices[indexCollateral] * decs[indexBorrowAsset] * 1e18\\n        / prices[indexBorrowAsset] / decs[indexCollateral];\\n\\n      // if totalCollateral is zero (liquidation happens) we will have zero amount (the debt shouldn't be paid)\\n      amountOut = totalDebt != 0 && alpha18 * totalCollateral / totalDebt > 1e18\\n        ? Math.min(requestedAmount, totalCollateral) * 1e18 / (alpha18 * totalCollateral / totalDebt - 1e18)\\n        : 0;\\n\\n      if (amountOut != 0) {\\n        // we shouldn't try to sell amount greater than amount of totalDebt in terms of collateral asset\\n        // but we always asks +1% because liquidation results can be different a bit from expected\\n        amountOut = (AppLib.GAP_CONVERSION + AppLib.DENOMINATOR) * Math.min(amountOut, totalDebt * 1e18 / alpha18) / AppLib.DENOMINATOR;\\n      }\\n    }\\n\\n    return amountOut;\\n  }\\n//endregion ------------------------------------------------ Build plan\\n}\\n\",\"keccak256\":\"0xcb0390a862acc4c005f56db711de34757e1281a8905fe7f6eac0e0b77fc0de82\",\"license\":\"MIT\"},\"contracts/libs/TokenAmountsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./AppErrors.sol\\\";\\n\\n/// @title Library for clearing / joining token addresses & amounts arrays\\n/// @author bogdoslav\\nlibrary TokenAmountsLib {\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \\\"1.0.1\\\";\\n\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\n    unchecked {\\n      return i + 1;\\n    }\\n  }\\n\\n  function filterZeroAmounts(\\n    address[] memory tokens,\\n    uint[] memory amounts\\n  ) internal pure returns (\\n    address[] memory t,\\n    uint[] memory a\\n  ) {\\n    require(tokens.length == amounts.length, AppErrors.INCORRECT_LENGTHS);\\n    uint len2 = 0;\\n    uint len = tokens.length;\\n    for (uint i = 0; i < len; i++) {\\n      if (amounts[i] != 0) len2++;\\n    }\\n\\n    t = new address[](len2);\\n    a = new uint[](len2);\\n\\n    uint j = 0;\\n    for (uint i = 0; i < len; i++) {\\n      uint amount = amounts[i];\\n      if (amount != 0) {\\n        t[j] = tokens[i];\\n        a[j] = amount;\\n        j++;\\n      }\\n    }\\n  }\\n\\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\\n  function combineArrays(\\n    address[] memory tokens0,\\n    uint[] memory amounts0,\\n    address[] memory tokens1,\\n    uint[] memory amounts1,\\n    address[] memory tokens2,\\n    uint[] memory amounts2\\n  ) internal pure returns (\\n    address[] memory allTokens,\\n    uint[] memory allAmounts\\n  ) {\\n    uint[] memory lens = new uint[](3);\\n    lens[0] = tokens0.length;\\n    lens[1] = tokens1.length;\\n    lens[2] = tokens2.length;\\n\\n    require(\\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\\n      AppErrors.INCORRECT_LENGTHS\\n    );\\n\\n    uint maxLength = lens[0] + lens[1] + lens[2];\\n    address[] memory tokensOut = new address[](maxLength);\\n    uint[] memory amountsOut = new uint[](maxLength);\\n    uint unitedLength;\\n\\n    for (uint step; step < 3; ++step) {\\n      uint[] memory amounts = step == 0\\n        ? amounts0\\n        : (step == 1\\n          ? amounts1\\n          : amounts2);\\n      address[] memory tokens = step == 0\\n        ? tokens0\\n        : (step == 1\\n          ? tokens1\\n          : tokens2);\\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\\n        uint amount1 = amounts[i1];\\n        address token1 = tokens[i1];\\n        bool united = false;\\n\\n        for (uint i = 0; i < unitedLength; i++) {\\n          if (token1 == tokensOut[i]) {\\n            amountsOut[i] += amount1;\\n            united = true;\\n            break;\\n          }\\n        }\\n\\n        if (!united) {\\n          tokensOut[unitedLength] = token1;\\n          amountsOut[unitedLength] = amount1;\\n          unitedLength++;\\n        }\\n      }\\n    }\\n\\n    // copy united tokens to result array\\n    allTokens = new address[](unitedLength);\\n    allAmounts = new uint[](unitedLength);\\n    for (uint i; i < unitedLength; i++) {\\n      allTokens[i] = tokensOut[i];\\n      allAmounts[i] = amountsOut[i];\\n    }\\n\\n  }\\n}\\n\",\"keccak256\":\"0x6be459b8106584d7f9d3ad9f7a9fe6afa86bc41c5915c2d708715dba75c6174a\",\"license\":\"MIT\"},\"contracts/strategies/ConverterStrategyBaseLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib2.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"../libs/AppErrors.sol\\\";\\nimport \\\"../libs/AppLib.sol\\\";\\nimport \\\"../libs/TokenAmountsLib.sol\\\";\\nimport \\\"../libs/ConverterEntryKinds.sol\\\";\\nimport \\\"../libs/IterationPlanLib.sol\\\";\\n\\nlibrary ConverterStrategyBaseLib {\\n  using SafeERC20 for IERC20;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Data types\\n  /////////////////////////////////////////////////////////////////////\\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\\n  struct RecycleLocalParams {\\n    /// @notice Compound amount + Performance amount\\n    uint amountCP;\\n    /// @notice Amount to compound\\n    uint amountC;\\n    /// @notice Amount to send to performance and insurance\\n    uint amountP;\\n    /// @notice Amount to forwarder + amount to compound\\n    uint amountFC;\\n    address rewardToken;\\n    uint len;\\n    uint receivedAmountOut;\\n  }\\n\\n  struct OpenPositionLocal {\\n    uint entryKind;\\n    address[] converters;\\n    uint[] collateralsRequired;\\n    uint[] amountsToBorrow;\\n    uint collateral;\\n    uint amountToBorrow;\\n  }\\n\\n  struct OpenPositionEntryKind1Local {\\n    address[] converters;\\n    uint[] collateralsRequired;\\n    uint[] amountsToBorrow;\\n    uint collateral;\\n    uint amountToBorrow;\\n    uint c1;\\n    uint c3;\\n    uint alpha;\\n  }\\n\\n  struct SwapToGetAmountLocal {\\n    uint len;\\n    uint[] prices;\\n    uint[] decs;\\n  }\\n\\n  struct ConvertAfterWithdrawLocal {\\n    address asset;\\n    uint spent;\\n    uint received;\\n    uint balance;\\n    uint balanceBefore;\\n    uint len;\\n  }\\n\\n  struct SwapToGivenAmountInputParams {\\n    ITetuConverter converter;\\n    ITetuLiquidator liquidator;\\n    uint targetAmount;\\n    address[] tokens;\\n    uint[] amounts;\\n    /// @notice liquidationThresholds for the {tokens}\\n    uint[] liquidationThresholds;\\n    uint indexTargetAsset;\\n    address underlying;\\n    /// @notice Allow to swap more then required (i.e. 1_000 => +1%)\\n    ///         to avoid additional swap if the swap return amount a bit less than we expected\\n    uint overswap;\\n  }\\n\\n  struct SwapToGivenAmountLocal {\\n    uint len;\\n    uint[] availableAmounts;\\n    uint i;\\n  }\\n\\n  struct CloseDebtsForRequiredAmountLocal {\\n    address asset;\\n    uint balanceAsset;\\n    uint balanceToken;\\n\\n    uint newBalanceAsset;\\n    uint newBalanceToken;\\n\\n    uint idxToSwap1;\\n    uint amountToSwap;\\n    uint idxToRepay1;\\n\\n    /// @notice Cost of $1 in terms of the assets, decimals 18\\n    uint[] prices;\\n    /// @notice 10**decimal for the assets\\n    uint[] decs;\\n\\n    /// @notice Amounts that will be received on balance before execution of the plan.\\n    uint[] balanceAdditions;\\n\\n    /// @notice Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\n    ///         The leftovers should be swapped to get following result proportions of the assets:\\n    ///         not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\n    uint propNotUnderlying18;\\n\\n    /// @notice proportions should be taken from the pool and re-read from the pool after each swap\\n    bool usePoolProportions;\\n\\n    bool exitLoop;\\n  }\\n\\n  struct DataSetLocal {\\n    ITetuConverter converter;\\n    ITetuLiquidator liquidator;\\n    /// @notice Tokens received from {_depositorPoolAssets}\\n    address[] tokens;\\n    /// @notice Index of the main asset in {tokens}\\n    uint indexAsset;\\n    /// @notice Length of {tokens}\\n    uint len;\\n  }\\n\\n  struct RecycleLocal {\\n    address asset;\\n    uint compoundRatio;\\n    uint performanceFee;\\n    /// @notice // total amount for the performance receiver and insurance\\n    uint amountPerf;\\n    uint toPerf;\\n    uint toInsurance;\\n    uint[] amountsToForward;\\n  }\\n  //endregion Data types\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Constants\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice approx one month for average block time 2 sec\\n  uint internal constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\\n  uint internal constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\\n  uint internal constant PRICE_IMPACT_TOLERANCE = 300;\\n  /// @notice borrow/collateral amount cannot be less than given number of tokens\\n  uint internal constant DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD = 10;\\n  /// @notice Allow to swap more then required (i.e. 1_000 => +1%) inside {swapToGivenAmount}\\n  ///         to avoid additional swap if the swap will return amount a bit less than we expected\\n  uint internal constant OVERSWAP = PRICE_IMPACT_TOLERANCE + _ASSET_LIQUIDATION_SLIPPAGE;\\n  //endregion Constants\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Events\\n  /////////////////////////////////////////////////////////////////////\\n  /// @notice A borrow was made\\n  event OpenPosition(\\n    address converter,\\n    address collateralAsset,\\n    uint collateralAmount,\\n    address borrowAsset,\\n    uint borrowedAmount,\\n    address recepient\\n  );\\n\\n  /// @notice Some borrow(s) was/were repaid\\n  event ClosePosition(\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountRepay,\\n    address recepient,\\n    uint returnedAssetAmountOut,\\n    uint returnedBorrowAmountOut\\n  );\\n\\n  /// @notice A liquidation was made\\n  event Liquidation(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amountIn,\\n    uint spentAmountIn,\\n    uint receivedAmountOut\\n  );\\n\\n  event ReturnAssetToConverter(address asset, uint amount);\\n\\n  /// @notice Recycle was made\\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\\n  /// @param amountsToForward Amounts to be sent to forwarder\\n  event Recycle(\\n    address[] rewardTokens,\\n    uint[] amountsToForward,\\n    uint toPerf,\\n    uint toInsurance\\n  );\\n  //endregion Events\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Borrow and close positions\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\\n  ///         Max possible collateral should be approved before calling of this function.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\\n  /// @param amountIn_ Meaning depends on {entryData_}.\\n  function openPosition(\\n    ITetuConverter tetuConverter_,\\n    bytes memory entryData_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountIn_,\\n    uint thresholdAmountIn_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    return _openPosition(tetuConverter_, entryData_, collateralAsset_, borrowAsset_, amountIn_, thresholdAmountIn_);\\n  }\\n\\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\\n  ///         Max possible collateral should be approved before calling of this function.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\\n  /// @param amountIn_ Meaning depends on {entryData_}.\\n  /// @param thresholdAmountIn_ Min value of amountIn allowed for the second and subsequent conversions.\\n  ///        0 - use default min value\\n  ///        If amountIn becomes too low, no additional borrows are possible, so\\n  ///        the rest amountIn is just added to collateral/borrow amount of previous conversion.\\n  function _openPosition(\\n    ITetuConverter tetuConverter_,\\n    bytes memory entryData_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountIn_,\\n    uint thresholdAmountIn_\\n  ) internal returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    if (thresholdAmountIn_ == 0) {\\n      // zero threshold is not allowed because round-issues are possible, see openPosition.dust test\\n      // we assume here, that it's useless to borrow amount using collateral/borrow amount\\n      // less than given number of tokens (event for BTC)\\n      thresholdAmountIn_ = DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD;\\n    }\\n    if (amountIn_ <= thresholdAmountIn_) {\\n      return (0, 0);\\n    }\\n\\n    OpenPositionLocal memory vars;\\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\\n    vars.entryKind = ConverterEntryKinds.getEntryKind(entryData_);\\n    if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\\n      return openPositionEntryKind1(\\n        tetuConverter_,\\n        entryData_,\\n        collateralAsset_,\\n        borrowAsset_,\\n        amountIn_,\\n        thresholdAmountIn_\\n      );\\n    } else {\\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\\n        entryData_,\\n        collateralAsset_,\\n        amountIn_,\\n        borrowAsset_,\\n        _LOAN_PERIOD_IN_BLOCKS\\n      );\\n\\n      uint len = vars.converters.length;\\n      if (len > 0) {\\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\\n          vars.collateral;\\n          vars.amountToBorrow;\\n          if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\\n            // we have exact amount of total collateral amount\\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\\n              ? amountIn_\\n              : vars.collateralsRequired[i];\\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\\n              ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\\n              : vars.amountsToBorrow[i];\\n            amountIn_ -= vars.collateral;\\n          } else {\\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\\n            // we have exact amount of total amount-to-borrow\\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\\n              ? amountIn_\\n              : vars.amountsToBorrow[i];\\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\\n              ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\\n              : vars.collateralsRequired[i];\\n            amountIn_ -= vars.amountToBorrow;\\n          }\\n\\n          if (amountIn_ < thresholdAmountIn_ && amountIn_ != 0) {\\n            // dust amount is left, just leave it unused\\n            // we cannot add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\\n            amountIn_ = 0;\\n          }\\n\\n          if (vars.amountToBorrow != 0) {\\n            borrowedAmountOut += tetuConverter_.borrow(\\n              vars.converters[i],\\n              collateralAsset_,\\n              vars.collateral,\\n              borrowAsset_,\\n              vars.amountToBorrow,\\n              address(this)\\n            );\\n            collateralAmountOut += vars.collateral;\\n            emit OpenPosition(\\n              vars.converters[i],\\n              collateralAsset_,\\n              vars.collateral,\\n              borrowAsset_,\\n              vars.amountToBorrow,\\n              address(this)\\n            );\\n          }\\n\\n          if (amountIn_ == 0) break;\\n        }\\n      }\\n\\n      return (collateralAmountOut, borrowedAmountOut);\\n    }\\n  }\\n\\n  /// @notice Open position using entry kind 1 - split provided amount on two parts according provided proportions\\n  /// @param amountIn_ Amount of collateral to be divided on parts. We assume {amountIn_} > 0\\n  /// @param collateralThreshold_ Min allowed collateral amount to be used for new borrow, > 0\\n  /// @return collateralAmountOut Total collateral used to borrow {borrowedAmountOut}\\n  /// @return borrowedAmountOut Total borrowed amount\\n  function openPositionEntryKind1(\\n    ITetuConverter tetuConverter_,\\n    bytes memory entryData_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountIn_,\\n    uint collateralThreshold_\\n  ) internal returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    OpenPositionEntryKind1Local memory vars;\\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\\n      entryData_,\\n      collateralAsset_,\\n      amountIn_,\\n      borrowAsset_,\\n      _LOAN_PERIOD_IN_BLOCKS\\n    );\\n\\n    uint len = vars.converters.length;\\n    if (len > 0) {\\n      // we should split amountIn on two amounts with proportions x:y\\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\\n      // calculate prices conversion ratio using price oracle, decimals 18\\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\\n\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\\n        // and give us required proportions in result\\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\\n        // C1 is collateral amount left untouched (x)\\n        // C2 is collateral amount converted to B2 (y)\\n        // but if lending platform doesn't have enough liquidity\\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\\n        vars.c1 = x * vars.c3 / y;\\n\\n        // we doesn't calculate an intermediate ratio cR/(cR+c1) to avoid lost of precision\\n        if ((vars.collateralsRequired[i] + vars.c1) > amountIn_) {\\n          vars.collateral = vars.collateralsRequired[i] * amountIn_ / (vars.collateralsRequired[i] + vars.c1);\\n          vars.amountToBorrow = vars.amountsToBorrow[i] * amountIn_ / (vars.collateralsRequired[i] + vars.c1);\\n        } else {\\n          vars.collateral = vars.collateralsRequired[i];\\n          vars.amountToBorrow = vars.amountsToBorrow[i];\\n        }\\n\\n        // skip any attempts to borrow zero amount or use too little collateral\\n        if (vars.collateral < collateralThreshold_ || vars.amountToBorrow == 0) {\\n          if (vars.collateralsRequired[i] + vars.c1 + collateralThreshold_ > amountIn_) {\\n            // The lending platform has enough resources to make the borrow but amount of the borrow is too low\\n            // Skip the borrow, leave leftover of collateral untouched\\n            break;\\n          } else {\\n            // The lending platform doesn't have enough resources to make the borrow.\\n            // We should try to make borrow on the next platform (if any)\\n            continue;\\n          }\\n        }\\n\\n        require(\\n          tetuConverter_.borrow(\\n            vars.converters[i],\\n            collateralAsset_,\\n            vars.collateral,\\n            borrowAsset_,\\n            vars.amountToBorrow,\\n            address(this)\\n          ) == vars.amountToBorrow,\\n          StrategyLib2.WRONG_VALUE\\n        );\\n        emit OpenPosition(\\n          vars.converters[i],\\n          collateralAsset_,\\n          vars.collateral,\\n          borrowAsset_,\\n          vars.amountToBorrow,\\n          address(this)\\n        );\\n\\n        borrowedAmountOut += vars.amountToBorrow;\\n        collateralAmountOut += vars.collateral;\\n\\n        // calculate amount to be borrowed in the next converter\\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\\n        vars.c1 = x * vars.c3 / y;\\n        amountIn_ = (amountIn_ > vars.c1 + vars.collateral)\\n          ? amountIn_ - (vars.c1 + vars.collateral)\\n          : 0;\\n\\n        // protection against dust amounts, see \\\"openPosition.dust\\\", just leave dust amount unused\\n        // we CAN NOT add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\\n        // we assume here, that collateralThreshold_ != 0, so check amountIn_ != 0 is not required\\n        if (amountIn_ < collateralThreshold_) break;\\n      }\\n    }\\n\\n    return (collateralAmountOut, borrowedAmountOut);\\n  }\\n\\n  /// @notice Get ratio18 = collateral / borrow\\n  function _getCollateralToBorrowRatio(\\n    ITetuConverter converter_,\\n    address collateralAsset_,\\n    address borrowAsset_\\n  ) internal view returns (uint){\\n    IPriceOracle priceOracle = AppLib._getPriceOracle(converter_);\\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\\n    return 1e18 * priceBorrow * 10 ** IERC20Metadata(collateralAsset_).decimals()\\n    / priceCollateral / 10 ** IERC20Metadata(borrowAsset_).decimals();\\n  }\\n\\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\\n  ///         It doesn't repay more than the actual amount of the debt, so it can use less amount than {amountToRepay}\\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\\n  /// @return repaidAmountOut Amount that was actually repaid\\n  function _closePosition(\\n    ITetuConverter converter_,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountToRepay\\n  ) internal returns (\\n    uint returnedAssetAmountOut,\\n    uint repaidAmountOut\\n  ) {\\n\\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\\n\\n    // We shouldn't try to pay more than we actually need to repay\\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\\n    // Let's limit amountToRepay by needToRepay-amount\\n    (uint needToRepay,) = converter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\\n\\n    return _closePositionExact(converter_, collateralAsset, borrowAsset, amountRepay, balanceBefore);\\n  }\\n\\n  /// @notice Close the given position, pay {amountRepay} exactly and ensure that all amount was accepted,\\n  /// @param amountRepay Amount to repay in terms of {borrowAsset}\\n  /// @param balanceBorrowAsset Current balance of the borrow asset\\n  /// @return collateralOut Amount of collateral received back after repaying\\n  /// @return repaidAmountOut Amount that was actually repaid\\n  function _closePositionExact(\\n    ITetuConverter converter_,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountRepay,\\n    uint balanceBorrowAsset\\n  ) internal returns (\\n    uint collateralOut,\\n    uint repaidAmountOut\\n  ) {\\n    if (amountRepay >= AppLib.DUST_AMOUNT_TOKENS) {\\n      // Make full/partial repayment\\n      IERC20(borrowAsset).safeTransfer(address(converter_), amountRepay);\\n\\n      uint notUsedAmount;\\n      (collateralOut, notUsedAmount,,) = converter_.repay(collateralAsset, borrowAsset, amountRepay, address(this));\\n\\n      emit ClosePosition(collateralAsset, borrowAsset, amountRepay, address(this), collateralOut, notUsedAmount);\\n      uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\\n\\n      // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (debt-gap)\\n      repaidAmountOut = balanceBorrowAsset > balanceAfter\\n        ? balanceBorrowAsset - balanceAfter\\n        : 0;\\n      require(notUsedAmount == 0, StrategyLib2.WRONG_VALUE);\\n    }\\n\\n    return (collateralOut, repaidAmountOut);\\n  }\\n\\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\\n  /// @return repaidAmountOut Amount that was actually repaid\\n  function closePosition(\\n    ITetuConverter tetuConverter_,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountToRepay\\n  ) external returns (\\n    uint returnedAssetAmountOut,\\n    uint repaidAmountOut\\n  ) {\\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\\n  }\\n  //endregion Borrow and close positions\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Liquidation\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\\n  /// @param liquidationThresholdForTokenIn_ Liquidation threshold for {amountIn_}\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\n  /// @return spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\\n  /// @return receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\\n  function liquidate(\\n    ITetuConverter converter,\\n    ITetuLiquidator liquidator_,\\n    address tokenIn_,\\n    address tokenOut_,\\n    uint amountIn_,\\n    uint slippage_,\\n    uint liquidationThresholdForTokenIn_,\\n    bool skipValidation\\n  ) external returns (\\n    uint spentAmountIn,\\n    uint receivedAmountOut\\n  ) {\\n    return _liquidate(converter, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdForTokenIn_, skipValidation);\\n  }\\n\\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\\n  /// @param liquidationThresholdForTokenIn_ Liquidation threshold for {amountIn_}\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\n  /// @return spentAmountIn Amount of {tokenIn} has been consumed by the liquidator (== 0 | amountIn_)\\n  /// @return receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\\n  function _liquidate(\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator_,\\n    address tokenIn_,\\n    address tokenOut_,\\n    uint amountIn_,\\n    uint slippage_,\\n    uint liquidationThresholdForTokenIn_,\\n    bool skipValidation\\n  ) internal returns (\\n    uint spentAmountIn,\\n    uint receivedAmountOut\\n  ) {\\n    // we check amountIn by threshold, not amountOut\\n    // because {_closePositionsToGetAmount} is implemented in {get plan, make action}-way\\n    // {_closePositionsToGetAmount} can be used with swap by aggregators, where amountOut cannot be calculate\\n    // at the moment of plan building. So, for uniformity, only amountIn is checked everywhere\\n\\n    if (amountIn_ <= liquidationThresholdForTokenIn_) {\\n      return (0, 0);\\n    }\\n\\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\\n\\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\\n\\n    // if the expected value is higher than threshold distribute to destinations\\n    return (amountIn_, _liquidateWithRoute(converter_, route, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, skipValidation));\\n  }\\n\\n  /// @notice Make liquidation using given route and check correctness using TetuConverter's price oracle\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\n  function _liquidateWithRoute(\\n    ITetuConverter converter_,\\n    ITetuLiquidator.PoolData[] memory route,\\n    ITetuLiquidator liquidator_,\\n    address tokenIn_,\\n    address tokenOut_,\\n    uint amountIn_,\\n    uint slippage_,\\n    bool skipValidation\\n  ) internal returns (\\n    uint receivedAmountOut\\n  ) {\\n    // we need to approve each time, liquidator address can be changed in controller\\n    AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\\n\\n    uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\\n    liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\\n    uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\\n\\n    require(balanceAfter > balanceBefore, AppErrors.BALANCE_DECREASE);\\n    receivedAmountOut = balanceAfter - balanceBefore;\\n\\n    // Oracle in TetuConverter \\\"knows\\\" only limited number of the assets\\n    // It may not know prices for reward assets, so for rewards this validation should be skipped to avoid TC-4 error\\n    require(skipValidation || converter_.isConversionValid(tokenIn_, amountIn_, tokenOut_, receivedAmountOut, slippage_), AppErrors.PRICE_IMPACT);\\n    emit Liquidation(tokenIn_, tokenOut_, amountIn_, amountIn_, receivedAmountOut);\\n  }\\n  //endregion Liquidation\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region requirePayAmountBack\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @param amount_ Amount of the main asset requested by converter\\n  /// @param indexTheAsset Index of the asset required by converter in the {tokens}\\n  /// @param asset Main asset or underlying (it can be different from tokens[indexTheAsset])\\n  /// @return amountOut Amount of the main asset sent to converter\\n  function swapToGivenAmountAndSendToConverter(\\n    uint amount_,\\n    uint indexTheAsset,\\n    address[] memory tokens,\\n    address converter,\\n    address controller,\\n    address asset,\\n    mapping(address => uint) storage liquidationThresholds\\n  ) external returns (\\n    uint amountOut\\n  ) {\\n    address theAsset = tokens[indexTheAsset];\\n    uint[] memory thresholds = _getLiquidationThresholds(liquidationThresholds, tokens, tokens.length);\\n\\n    // msg.sender == converter; we assume here that it was checked before the call of this function\\n    amountOut = IERC20(theAsset).balanceOf(address(this));\\n\\n    // convert withdrawn assets to the target asset if not enough\\n    if (amountOut < amount_) {\\n      ConverterStrategyBaseLib.swapToGivenAmount(\\n        amount_ - amountOut,\\n        tokens,\\n        indexTheAsset,\\n        asset, // underlying === main asset\\n        ITetuConverter(converter),\\n        AppLib._getLiquidator(controller),\\n        thresholds,\\n        OVERSWAP\\n      );\\n      amountOut = IERC20(theAsset).balanceOf(address(this));\\n    }\\n\\n    // we should send the asset as is even if it is lower than requested\\n    // but shouldn't sent more amount than requested\\n    amountOut = Math.min(amount_, amountOut);\\n    if (amountOut != 0) {\\n      IERC20(theAsset).safeTransfer(converter, amountOut);\\n    }\\n\\n    // There are two cases of calling requirePayAmountBack by converter:\\n    // 1) close a borrow: we will receive collateral back and amount of investedAssets almost won't change\\n    // 2) rebalancing: we have real loss, it will be taken into account at next hard work\\n    emit ReturnAssetToConverter(theAsset, amountOut);\\n\\n    // let's leave any leftovers un-invested, they will be reinvested at next hardwork\\n  }\\n\\n  /// @notice Swap available amounts of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\\n  /// @param targetAmount_ Required amount of tokens[indexTheAsset_] that should be received by swap(s)\\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\\n  /// @param indexTargetAsset_ Index of target asset in tokens_ array\\n  /// @param underlying_ Index of underlying\\n  /// @param liquidationThresholds_ Liquidation thresholds for the {tokens_}\\n  /// @param overswap_ Allow to swap more then required (i.e. 1_000 => +1%)\\n  ///                  to avoid additional swap if the swap return amount a bit less than we expected\\n  /// @return spentAmounts Any amounts spent during the swaps\\n  /// @return receivedAmounts Any amounts received during the swaps\\n  function swapToGivenAmount(\\n    uint targetAmount_,\\n    address[] memory tokens_,\\n    uint indexTargetAsset_,\\n    address underlying_,\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator_,\\n    uint[] memory liquidationThresholds_,\\n    uint overswap_\\n  ) internal returns (\\n    uint[] memory spentAmounts,\\n    uint[] memory receivedAmounts\\n  ) {\\n    SwapToGivenAmountLocal memory v;\\n    v.len = tokens_.length;\\n\\n    v.availableAmounts = new uint[](v.len);\\n    for (; v.i < v.len; v.i = AppLib.uncheckedInc(v.i)) {\\n      v.availableAmounts[v.i] = IERC20(tokens_[v.i]).balanceOf(address(this));\\n    }\\n\\n    (spentAmounts, receivedAmounts) = _swapToGivenAmount(\\n      SwapToGivenAmountInputParams({\\n        targetAmount: targetAmount_,\\n        tokens: tokens_,\\n        indexTargetAsset: indexTargetAsset_,\\n        underlying: underlying_,\\n        amounts: v.availableAmounts,\\n        converter: converter_,\\n        liquidator: liquidator_,\\n        liquidationThresholds: liquidationThresholds_,\\n        overswap: overswap_\\n      })\\n    );\\n  }\\n\\n  /// @notice Swap available {amounts_} of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\\n  /// @return spentAmounts Any amounts spent during the swaps\\n  /// @return receivedAmounts Any amounts received during the swaps\\n  function _swapToGivenAmount(SwapToGivenAmountInputParams memory p) internal returns (\\n    uint[] memory spentAmounts,\\n    uint[] memory receivedAmounts\\n  ) {\\n    SwapToGetAmountLocal memory v;\\n    v.len = p.tokens.length;\\n    receivedAmounts = new uint[](v.len);\\n    spentAmounts = new uint[](v.len);\\n\\n    // calculate prices, decimals\\n    (v.prices, v.decs) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(p.converter), p.tokens, v.len);\\n\\n    // we need to swap other assets to the asset\\n    // at first we should swap NOT underlying.\\n    // if it would be not enough, we can swap underlying too.\\n\\n    // swap NOT underlying, initialize {indexUnderlying}\\n    uint indexUnderlying;\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (p.underlying == p.tokens[i]) {\\n        indexUnderlying = i;\\n        continue;\\n      }\\n      if (p.indexTargetAsset == i) continue;\\n\\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, i);\\n      spentAmounts[i] += spent;\\n      receivedAmounts[p.indexTargetAsset] += received;\\n\\n      if (receivedAmounts[p.indexTargetAsset] >= p.targetAmount) break;\\n    }\\n\\n    // swap underlying\\n    if (receivedAmounts[p.indexTargetAsset] < p.targetAmount && p.indexTargetAsset != indexUnderlying) {\\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, indexUnderlying);\\n      spentAmounts[indexUnderlying] += spent;\\n      receivedAmounts[p.indexTargetAsset] += received;\\n    }\\n  }\\n\\n  /// @notice Swap a part of amount of asset {tokens[indexTokenIn]} to {targetAsset} to get {targetAmount} in result\\n  /// @param receivedTargetAmount Already received amount of {targetAsset} in previous swaps\\n  /// @param indexTokenIn Index of the tokenIn in p.tokens\\n  function _swapToGetAmount(\\n    uint receivedTargetAmount,\\n    SwapToGivenAmountInputParams memory p,\\n    SwapToGetAmountLocal memory v,\\n    uint indexTokenIn\\n  ) internal returns (\\n    uint amountSpent,\\n    uint amountReceived\\n  ) {\\n    if (p.amounts[indexTokenIn] != 0) {\\n      // we assume here, that p.targetAmount > receivedTargetAmount, see _swapToGivenAmount implementation\\n\\n      // calculate amount that should be swapped\\n      // {overswap} allows to swap a bit more\\n      // to avoid additional swaps if the swap will give us a bit less amount than expected\\n      uint amountIn = (\\n        (p.targetAmount - receivedTargetAmount)\\n        * v.prices[p.indexTargetAsset] * v.decs[indexTokenIn]\\n        / v.prices[indexTokenIn] / v.decs[p.indexTargetAsset]\\n      ) * (p.overswap + AppLib.DENOMINATOR) / AppLib.DENOMINATOR;\\n\\n      (amountSpent, amountReceived) = _liquidate(\\n        p.converter,\\n        p.liquidator,\\n        p.tokens[indexTokenIn],\\n        p.tokens[p.indexTargetAsset],\\n        Math.min(amountIn, p.amounts[indexTokenIn]),\\n        _ASSET_LIQUIDATION_SLIPPAGE,\\n        p.liquidationThresholds[indexTokenIn],\\n        false\\n      );\\n    }\\n\\n    return (amountSpent, amountReceived);\\n  }\\n  //endregion requirePayAmountBack\\n\\n//region--------------------------------------------------- Recycle rewards\\n\\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\\n  /// We have two kinds of rewards:\\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\\n  /// 2) any other rewards\\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\\n  ///   Compound-part of Rewards-2 can be liquidated\\n  ///   Compound part of Rewards-1 should be just left on the balance\\n  ///   Performance amounts should be liquidate, result underlying should be sent to performance receiver and insurance.\\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\\n  /// @dev {_recycle} is implemented as separate (inline) function to simplify unit testing\\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\\n  /// @return Amounts sent to the forwarder\\n  function recycle(\\n    IStrategyV3.BaseState storage baseState,\\n    ITetuConverter converter,\\n    address[] memory tokens,\\n    address controller,\\n    mapping(address => uint) storage liquidationThresholds,\\n    address[] memory rewardTokens_,\\n    uint[] memory rewardAmounts_\\n  ) external returns (uint[] memory) {\\n    RecycleLocal memory v;\\n    v.asset = baseState.asset;\\n    v.compoundRatio = baseState.compoundRatio;\\n    v.performanceFee = baseState.performanceFee;\\n    (v.amountsToForward, v.amountPerf) = _recycle(\\n      converter,\\n      v.asset,\\n      v.compoundRatio,\\n      tokens,\\n      AppLib._getLiquidator(controller),\\n      liquidationThresholds,\\n      rewardTokens_,\\n      rewardAmounts_,\\n      v.performanceFee\\n    );\\n\\n    address splitter = baseState.splitter;\\n\\n    // send performance-part of the underlying to the performance receiver and insurance\\n    (v.toPerf, v.toInsurance) = _sendPerformanceFee(\\n      v.asset,\\n      v.amountPerf,\\n      splitter,\\n      baseState.performanceReceiver,\\n      baseState.performanceFeeRatio\\n    );\\n\\n    _sendTokensToForwarder(controller, splitter, rewardTokens_, v.amountsToForward);\\n\\n    emit Recycle(rewardTokens_, v.amountsToForward, v.toPerf, v.toInsurance);\\n    return v.amountsToForward;\\n  }\\n\\n  /// @notice Send {amount_} of {asset_} to {receiver_} and insurance\\n  /// @param asset_ Underlying asset\\n  /// @param amount_ Amount of underlying asset to be sent to\\n  /// @param receiver_ Performance receiver\\n  /// @param ratio [0..100_000], 100_000 - send full amount to perf, 0 - send full amount to the insurance.\\n  function _sendPerformanceFee(address asset_, uint amount_, address splitter, address receiver_, uint ratio) internal returns (\\n    uint toPerf,\\n    uint toInsurance\\n  ) {\\n    // read inside lib for reduce contract space in the main contract\\n    address insurance = address(ITetuVaultV2(ISplitter(splitter).vault()).insurance());\\n\\n    toPerf = amount_ * ratio / AppLib.DENOMINATOR;\\n    toInsurance = amount_ - toPerf;\\n\\n    if (toPerf != 0) {\\n      IERC20(asset_).safeTransfer(receiver_, toPerf);\\n    }\\n    if (toInsurance != 0) {\\n      IERC20(asset_).safeTransfer(insurance, toInsurance);\\n    }\\n  }\\n\\n  function _sendTokensToForwarder(\\n    address controller_,\\n    address splitter_,\\n    address[] memory tokens_,\\n    uint[] memory amounts_\\n  ) internal {\\n    uint len = tokens_.length;\\n    IForwarder forwarder = IForwarder(IController(controller_).forwarder());\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      AppLib.approveIfNeeded(tokens_[i], amounts_[i], address(forwarder));\\n    }\\n\\n    (tokens_, amounts_) = TokenAmountsLib.filterZeroAmounts(tokens_, amounts_);\\n    forwarder.registerIncome(tokens_, amounts_, ISplitter(splitter_).vault(), true);\\n  }\\n\\n  /// @notice Recycle the amounts: split each amount on tree parts: performance+insurance (P), forwarder (F), compound (C)\\n  ///         Liquidate P+C, send F to the forwarder.\\n  /// We have two kinds of rewards:\\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\\n  /// 2) any other rewards\\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\\n  ///   Compound-part of Rewards-2 can be liquidated\\n  ///   Compound part of Rewards-1 should be just left on the balance\\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\\n  ///   Performance amounts are liquidated, result amount of underlying is returned in {amountToPerformanceAndInsurance}\\n  /// @param asset Underlying asset\\n  /// @param compoundRatio Compound ration in the range [0...COMPOUND_DENOMINATOR]\\n  /// @param tokens tokens received from {_depositorPoolAssets}\\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\\n  /// @param rewardAmounts Amounts of {rewardTokens_}; we assume, there are no zero amounts here\\n  /// @param liquidationThresholds Liquidation thresholds for rewards tokens\\n  /// @param performanceFee Performance fee in the range [0...FEE_DENOMINATOR]\\n  /// @return amountsToForward Amounts of {rewardTokens} to be sent to forwarder, zero amounts are allowed here\\n  /// @return amountToPerformanceAndInsurance Amount of underlying to be sent to performance receiver and insurance\\n  function _recycle(\\n    ITetuConverter converter_,\\n    address asset,\\n    uint compoundRatio,\\n    address[] memory tokens,\\n    ITetuLiquidator liquidator,\\n    mapping(address => uint) storage liquidationThresholds,\\n    address[] memory rewardTokens,\\n    uint[] memory rewardAmounts,\\n    uint performanceFee\\n  ) internal returns (\\n    uint[] memory amountsToForward,\\n    uint amountToPerformanceAndInsurance\\n  ) {\\n    RecycleLocalParams memory p;\\n\\n    p.len = rewardTokens.length;\\n    require(p.len == rewardAmounts.length, AppErrors.WRONG_LENGTHS);\\n\\n    amountsToForward = new uint[](p.len);\\n\\n    // rewardAmounts => P + F + C, where P - performance + insurance, F - forwarder, C - compound\\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\\n      p.amountFC = rewardAmounts[i] * (COMPOUND_DENOMINATOR - performanceFee) / COMPOUND_DENOMINATOR;\\n      p.amountC = p.amountFC * compoundRatio / COMPOUND_DENOMINATOR;\\n      p.amountP = rewardAmounts[i] - p.amountFC;\\n      p.rewardToken = rewardTokens[i];\\n      p.amountCP = p.amountC + p.amountP;\\n\\n      if (p.amountCP > 0) {\\n        if (AppLib.getAssetIndex(tokens, p.rewardToken) != type(uint).max) {\\n          if (p.rewardToken == asset) {\\n            // This is underlying, liquidation of compound part is not allowed; just keep on the balance, should be handled later\\n            amountToPerformanceAndInsurance += p.amountP;\\n          } else {\\n            // This is secondary asset, Liquidation of compound part is not allowed, we should liquidate performance part only\\n            // If the performance amount is too small, liquidation will not happen and we will just keep that dust tokens on balance forever\\n            (, p.receivedAmountOut) = _liquidate(\\n              converter_,\\n              liquidator,\\n              p.rewardToken,\\n              asset,\\n              p.amountP,\\n              _REWARD_LIQUIDATION_SLIPPAGE,\\n              AppLib._getLiquidationThreshold(liquidationThresholds[p.rewardToken]),\\n              false // use conversion validation for these rewards\\n            );\\n            amountToPerformanceAndInsurance += p.receivedAmountOut;\\n          }\\n        } else {\\n          // If amount is too small, the liquidation won't be allowed and we will just keep that dust tokens on balance forever\\n          // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\\n          // We assume here, that {token} cannot be equal to {_asset}\\n          // because the {_asset} is always included to the list of depositor's assets\\n          (, p.receivedAmountOut) = _liquidate(\\n            converter_,\\n            liquidator,\\n            p.rewardToken,\\n            asset,\\n            p.amountCP,\\n            _REWARD_LIQUIDATION_SLIPPAGE,\\n            AppLib._getLiquidationThreshold(liquidationThresholds[p.rewardToken]),\\n            true // skip conversion validation for rewards because we can have arbitrary assets here\\n          );\\n          amountToPerformanceAndInsurance += p.receivedAmountOut * (rewardAmounts[i] - p.amountFC) / p.amountCP;\\n        }\\n      }\\n      amountsToForward[i] = p.amountFC - p.amountC;\\n    }\\n    return (amountsToForward, amountToPerformanceAndInsurance);\\n  }\\n//endregion----------------------------------------------- Recycle rewards\\n\\n//region--------------------------------------------------- Before deposit\\n  /// @notice Default implementation of ConverterStrategyBase.beforeDeposit\\n  /// @param amount_ Amount of underlying to be deposited\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\n  /// @param weights_ Depositor pool weights\\n  /// @param totalWeight_ Sum of {weights_}\\n  function beforeDeposit(\\n    ITetuConverter converter_,\\n    uint amount_,\\n    address[] memory tokens_,\\n    uint indexAsset_,\\n    uint[] memory weights_,\\n    uint totalWeight_,\\n    mapping(address => uint) storage liquidationThresholds\\n  ) external returns (\\n    uint[] memory tokenAmounts\\n  ) {\\n    // temporary save collateral to tokensAmounts\\n    tokenAmounts = _getCollaterals(amount_, tokens_, weights_, totalWeight_, indexAsset_, AppLib._getPriceOracle(converter_));\\n\\n    // make borrow and save amounts of tokens available for deposit to tokenAmounts, zero result amounts are possible\\n    tokenAmounts = _getTokenAmounts(\\n      converter_,\\n      tokens_,\\n      indexAsset_,\\n      tokenAmounts,\\n      AppLib._getLiquidationThreshold(liquidationThresholds[tokens_[indexAsset_]])\\n    );\\n  }\\n\\n  /// @notice For each {token_} calculate a part of {amount_} to be used as collateral according to the weights.\\n  ///         I.e. we have 300 USDC, we need to split it on 100 USDC, 100 USDT, 100 DAI\\n  ///         USDC is main asset, USDT and DAI should be borrowed. We check amounts of USDT and DAI on the balance\\n  ///         and return collaterals reduced on that amounts. For main asset, we return full amount always (100 USDC).\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\n  /// @return tokenAmountsOut Length of the array is equal to the length of {tokens_}\\n  function _getCollaterals(\\n    uint amount_,\\n    address[] memory tokens_,\\n    uint[] memory weights_,\\n    uint totalWeight_,\\n    uint indexAsset_,\\n    IPriceOracle priceOracle\\n  ) internal view returns (\\n    uint[] memory tokenAmountsOut\\n  ) {\\n    uint len = tokens_.length;\\n    tokenAmountsOut = new uint[](len);\\n\\n    // get token prices and decimals\\n    (uint[] memory prices, uint[] memory decs) = AppLib._getPricesAndDecs(priceOracle, tokens_, len);\\n\\n    // split the amount on tokens proportionally to the weights\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      uint amountAssetForToken = amount_ * weights_[i] / totalWeight_;\\n\\n      if (i == indexAsset_) {\\n        tokenAmountsOut[i] = amountAssetForToken;\\n      } else {\\n        // if we have some tokens on balance then we need to use only a part of the collateral\\n        uint tokenAmountToBeBorrowed = amountAssetForToken\\n          * prices[indexAsset_]\\n          * decs[i]\\n          / prices[i]\\n          / decs[indexAsset_];\\n\\n        uint tokenBalance = IERC20(tokens_[i]).balanceOf(address(this));\\n        if (tokenBalance < tokenAmountToBeBorrowed) {\\n          tokenAmountsOut[i] = amountAssetForToken * (tokenAmountToBeBorrowed - tokenBalance) / tokenAmountToBeBorrowed;\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Make borrow and return amounts of {tokens} available to deposit\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\n  /// @param collaterals_ Amounts of main asset that can be used as collateral to borrow {tokens_}\\n  /// @param thresholdAsset_ Value of liquidation threshold for the main (collateral) asset\\n  /// @return tokenAmountsOut Amounts of {tokens}  available to deposit\\n  function _getTokenAmounts(\\n    ITetuConverter converter_,\\n    address[] memory tokens_,\\n    uint indexAsset_,\\n    uint[] memory collaterals_,\\n    uint thresholdAsset_\\n  ) internal returns (\\n    uint[] memory tokenAmountsOut\\n  ) {\\n    // content of tokenAmounts will be modified in place\\n    uint len = tokens_.length;\\n    tokenAmountsOut = new uint[](len);\\n    address asset = tokens_[indexAsset_];\\n\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i != indexAsset_) {\\n        address token = tokens_[i];\\n        if (collaterals_[i] != 0) {\\n          AppLib.approveIfNeeded(asset, collaterals_[i], address(converter_));\\n          _openPosition(\\n            converter_,\\n            \\\"\\\", // entry kind = 0: fixed collateral amount, max possible borrow amount\\n            asset,\\n            token,\\n            collaterals_[i],\\n            thresholdAsset_\\n          );\\n\\n          // zero borrowed amount is possible here (conversion is not available)\\n          // if it's not suitable for depositor, the depositor should check zero amount in other places\\n        }\\n        tokenAmountsOut[i] = IERC20(token).balanceOf(address(this));\\n      }\\n    }\\n\\n    tokenAmountsOut[indexAsset_] = Math.min(\\n      collaterals_[indexAsset_],\\n      IERC20(asset).balanceOf(address(this))\\n    );\\n  }\\n//endregion--------------------------------------------------- Before deposit\\n\\n//region--------------------------------------------------- Make requested amount\\n\\n\\n\\n  /// @notice Convert {amountsToConvert_} to the main {asset}\\n  ///         Swap leftovers (if any) to the main asset.\\n  ///         If result amount is less than expected, try to close any other available debts (1 repay per block only)\\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\n  /// @param requestedAmount Total amount of main asset that we need to receive on balance (to be withdrawn).\\n  ///                        Max uint means attempt to withdraw all possible invested assets.\\n  /// @param amountsToConvert_ Amounts available for conversion after withdrawing from the pool\\n  /// @param expectedMainAssetAmounts Amounts of main asset that we expect to receive after conversion amountsToConvert_\\n  /// @return expectedAmount Expected total amount of main asset after all conversions, swaps and repays\\n  function makeRequestedAmount(\\n    address[] memory tokens_,\\n    uint indexAsset_,\\n    uint[] memory amountsToConvert_,\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator_,\\n    uint requestedAmount,\\n    uint[] memory expectedMainAssetAmounts,\\n    mapping(address => uint) storage liquidationThresholds_\\n  ) external returns (uint expectedAmount) {\\n    DataSetLocal memory v = DataSetLocal({\\n      len: tokens_.length,\\n      converter: converter_,\\n      tokens: tokens_,\\n      indexAsset: indexAsset_,\\n      liquidator: liquidator_\\n    });\\n    return _makeRequestedAmount(v, amountsToConvert_, requestedAmount, expectedMainAssetAmounts, liquidationThresholds_);\\n  }\\n\\n  function _makeRequestedAmount(\\n    DataSetLocal memory d_,\\n    uint[] memory amountsToConvert_,\\n    uint requestedAmount,\\n    uint[] memory expectedMainAssetAmounts,\\n    mapping(address => uint) storage liquidationThresholds_\\n  ) internal returns (uint expectedAmount) {\\n    // get the total expected amount\\n    for (uint i; i < d_.len; i = AppLib.uncheckedInc(i)) {\\n      expectedAmount += expectedMainAssetAmounts[i];\\n    }\\n\\n    uint[] memory _liquidationThresholds = _getLiquidationThresholds(liquidationThresholds_, d_.tokens, d_.len);\\n    // we shouldn't repay a debt twice, it's inefficient\\n    // suppose, we have usdt = 1 and we need to convert it to usdc, then get additional usdt=10 and make second repay\\n    // But: we shouldn't make repay(1) and than repay(10), we should make single repay(11)\\n    // Note: AAVE3 allows to make two repays in a single block, see Aave3SingleBlockTest in TetuConverter\\n    //       but it doesn't allow to make borrow and repay in a single block.\\n\\n    if (requestedAmount != type(uint).max\\n      && expectedAmount > requestedAmount * (AppLib.GAP_CONVERSION + AppLib.DENOMINATOR) / AppLib.DENOMINATOR\\n    ) {\\n      // amountsToConvert_ are enough to get requestedAmount\\n      _convertAfterWithdraw(d_, _liquidationThresholds, amountsToConvert_);\\n    } else {\\n      uint balance = IERC20(d_.tokens[d_.indexAsset]).balanceOf(address(this));\\n      if (requestedAmount != type(uint).max) {\\n        requestedAmount = requestedAmount > balance\\n          ? requestedAmount - balance\\n          : 0;\\n      }\\n\\n      // amountsToConvert_ are NOT enough to get requestedAmount\\n      // We are allowed to make only one repay per block, so, we shouldn't try to convert amountsToConvert_\\n      // We should try to close the exist debts instead:\\n      //    convert a part of main assets to get amount of secondary assets required to repay the debts\\n      // and only then make conversion.\\n      expectedAmount = _closePositionsToGetAmount(d_, _liquidationThresholds, requestedAmount);\\n    }\\n\\n    return expectedAmount;\\n  }\\n  //endregion-------------------------------------------- Make requested amount\\n\\n//region ------------------------------------------------ Withdraw helpers\\n\\n  /// @notice Convert {amountsToConvert_} (available on balance) to the main asset\\n  ///         Swap leftovers if any.\\n  ///         Result amount can be less than requested one, we don't try to close any other debts here\\n  /// @param liquidationThreshold_ Min allowed amount of main asset to be liquidated in {liquidator} for {tokens}\\n  /// @param amountsToConvert Amounts to convert, the order of asset is same as in {tokens}\\n  /// @return collateralOut Total amount of main asset returned after closing positions\\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\\n  function _convertAfterWithdraw(\\n    DataSetLocal memory d_,\\n    uint[] memory liquidationThreshold_,\\n    uint[] memory amountsToConvert\\n  ) internal returns (\\n    uint collateralOut,\\n    uint[] memory repaidAmountsOut\\n  ) {\\n    ConvertAfterWithdrawLocal memory v;\\n    v.asset = d_.tokens[d_.indexAsset];\\n    v.balanceBefore = IERC20(v.asset).balanceOf(address(this));\\n    v.len = d_.tokens.length;\\n\\n    // Close positions to convert all required amountsToConvert\\n    repaidAmountsOut = new uint[](d_.tokens.length);\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == d_.indexAsset || amountsToConvert[i] == 0) continue;\\n      (, repaidAmountsOut[i]) = _closePosition(d_.converter, v.asset, d_.tokens[i], amountsToConvert[i]);\\n    }\\n\\n    // Manually swap remain leftovers\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == d_.indexAsset || amountsToConvert[i] == 0) continue;\\n      if (amountsToConvert[i] > repaidAmountsOut[i]) {\\n        (v.spent, v.received) = _liquidate(\\n          d_.converter,\\n          d_.liquidator,\\n          d_.tokens[i],\\n          v.asset,\\n          amountsToConvert[i] - repaidAmountsOut[i],\\n          _ASSET_LIQUIDATION_SLIPPAGE,\\n          liquidationThreshold_[i],\\n          false\\n        );\\n        collateralOut += v.received;\\n        repaidAmountsOut[i] += v.spent;\\n      }\\n    }\\n\\n    // Calculate amount of received collateral\\n    v.balance = IERC20(v.asset).balanceOf(address(this));\\n    collateralOut = v.balance > v.balanceBefore\\n      ? v.balance - v.balanceBefore\\n      : 0;\\n\\n    return (collateralOut, repaidAmountsOut);\\n  }\\n//endregion ------------------------------------------------ convertAfterWithdraw\\n\\n//region ------------------------------------------------ Close position\\n  /// @notice Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\\n  /// @dev We assume here that this function is called before closing any positions in the current block\\n  /// @param liquidationThresholds Min allowed amounts-out for liquidations\\n  /// @param requestedAmount Requested amount of main asset that should be added to the current balance.\\n  ///                        Pass type(uint).max to request all.\\n  /// @return expectedAmount Main asset amount expected to be received on balance after all conversions and swaps\\n  function closePositionsToGetAmount(\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator,\\n    uint indexAsset,\\n    mapping(address => uint) storage liquidationThresholds,\\n    uint requestedAmount,\\n    address[] memory tokens\\n  ) external returns (uint expectedAmount) {\\n    uint len = tokens.length;\\n    return _closePositionsToGetAmount(\\n      DataSetLocal({\\n        len: len,\\n        converter: converter_,\\n        tokens: tokens,\\n        indexAsset: indexAsset,\\n        liquidator: liquidator\\n      }),\\n      _getLiquidationThresholds(liquidationThresholds, tokens, len),\\n      requestedAmount\\n    );\\n  }\\n\\n  /// @dev Implements {IterationPlanLib.PLAN_SWAP_REPAY} only\\n  function _closePositionsToGetAmount(\\n    DataSetLocal memory d_,\\n    uint[] memory liquidationThresholds_,\\n    uint requestedAmount\\n  ) internal returns (\\n    uint expectedAmount\\n  ) {\\n    if (requestedAmount != 0) {\\n      CloseDebtsForRequiredAmountLocal memory v;\\n      v.asset = d_.tokens[d_.indexAsset];\\n\\n      // v.planKind = IterationPlanLib.PLAN_SWAP_REPAY; // PLAN_SWAP_REPAY == 0, so we don't need this line\\n      v.balanceAdditions = new uint[](d_.len);\\n\\n      (v.prices, v.decs) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(d_.converter), d_.tokens, d_.len);\\n\\n      for (uint i; i < d_.len; i = AppLib.uncheckedInc(i)) {\\n        if (i == d_.indexAsset) continue;\\n\\n        v.balanceAsset = IERC20(v.asset).balanceOf(address(this));\\n        v.balanceToken = IERC20(d_.tokens[i]).balanceOf(address(this));\\n\\n        // Make one or several iterations. Do single swap and single repaying (both are optional) on each iteration.\\n        // Calculate expectedAmount of received underlying. Swap leftovers at the end even if requestedAmount is 0 at that moment.\\n        do {\\n          // generate iteration plan: [swap], [repay]\\n          (v.idxToSwap1, v.amountToSwap, v.idxToRepay1) = IterationPlanLib.buildIterationPlan(\\n            [address(d_.converter), address(d_.liquidator)],\\n            d_.tokens,\\n            liquidationThresholds_,\\n            v.prices,\\n            v.decs,\\n            v.balanceAdditions,\\n            [0, IterationPlanLib.PLAN_SWAP_REPAY, 0, requestedAmount, d_.indexAsset, i]\\n          );\\n          if (v.idxToSwap1 == 0 && v.idxToRepay1 == 0) break;\\n\\n          // make swap if necessary\\n          uint spentAmountIn;\\n          if (v.idxToSwap1 != 0) {\\n            uint indexIn = v.idxToSwap1 - 1;\\n            uint indexOut = indexIn == d_.indexAsset ? i : d_.indexAsset;\\n            (spentAmountIn,) = _liquidate(\\n              d_.converter,\\n              d_.liquidator,\\n              d_.tokens[indexIn],\\n              d_.tokens[indexOut],\\n              v.amountToSwap,\\n              _ASSET_LIQUIDATION_SLIPPAGE,\\n              liquidationThresholds_[indexIn],\\n              false\\n            );\\n\\n            if (spentAmountIn != 0 && indexIn == i && v.idxToRepay1 == 0) {\\n              // spentAmountIn can be zero if token balance is less than liquidationThreshold\\n              // we need to calculate expectedAmount only if not-underlying-leftovers are swapped to underlying\\n              // we don't need to take into account conversion to get toSell amount\\n              expectedAmount += spentAmountIn * v.prices[i] * v.decs[d_.indexAsset] / v.prices[d_.indexAsset] / v.decs[i];\\n            }\\n          }\\n\\n          // repay a debt if necessary\\n          if (v.idxToRepay1 != 0) {\\n            uint indexBorrow = v.idxToRepay1 - 1;\\n            uint indexCollateral = indexBorrow == d_.indexAsset ? i : d_.indexAsset;\\n            uint amountToRepay = IERC20(d_.tokens[indexBorrow]).balanceOf(address(this));\\n\\n            // repay can be made only if we haven't received requested amount after swap\\n            // we cannot relay on amount that was planned to get after swap, so idxToRepay1 != 0 here\\n            // but if swapped amount actually was enough, we should avoid additional repay to avoid high gas consumption\\n            // in the cases like SCB-787\\n\\n            if (\\n              (indexBorrow != d_.indexAsset)\\n              || ( // received amount of asset is not enough, we need next swap-repay cycle\\n                (amountToRepay > v.balanceAsset ? amountToRepay - v.balanceAsset : 0) < requestedAmount\\n              )\\n            ) {\\n              (uint expectedAmountOut, uint repaidAmountOut, uint amountSendToRepay) = _repayDebt(\\n                d_.converter,\\n                d_.tokens[indexCollateral],\\n                d_.tokens[indexBorrow],\\n                amountToRepay\\n              );\\n              if (indexCollateral == d_.indexAsset) {\\n                require(expectedAmountOut >= spentAmountIn, AppErrors.BALANCE_DECREASE);\\n                if (repaidAmountOut < amountSendToRepay) {\\n                  // SCB-779: expectedAmountOut was estimated for amountToRepay, but we have paid repaidAmountOut only\\n                  expectedAmount += expectedAmountOut * repaidAmountOut / amountSendToRepay - spentAmountIn;\\n                } else {\\n                  expectedAmount += expectedAmountOut - spentAmountIn;\\n                }\\n              }\\n            }\\n          }\\n\\n          // update balances and requestedAmount\\n          v.newBalanceAsset = IERC20(v.asset).balanceOf(address(this));\\n          v.newBalanceToken = IERC20(d_.tokens[i]).balanceOf(address(this));\\n\\n          if (v.newBalanceAsset > v.balanceAsset) {\\n            if (requestedAmount != type(uint).max) {\\n              requestedAmount = requestedAmount > v.newBalanceAsset - v.balanceAsset\\n                ? requestedAmount - (v.newBalanceAsset - v.balanceAsset)\\n                : 0;\\n            } // requestedAmount can be checked for equality to type(uint).max below, we cannot change max value\\n          }\\n\\n          v.exitLoop = (v.balanceAsset == v.newBalanceAsset && v.balanceToken == v.newBalanceToken);\\n          v.balanceAsset = v.newBalanceAsset;\\n          v.balanceToken = v.newBalanceToken;\\n        } while (!v.exitLoop);\\n\\n        if (requestedAmount < liquidationThresholds_[d_.indexAsset]) break;\\n      }\\n    }\\n\\n    return expectedAmount;\\n  }\\n//endregion ------------------------------------------------ Close position\\n\\n//region ------------------------------------------------ Repay debts\\n  /// @notice Repay {amountIn} and get collateral in return, calculate expected amount\\n  ///         Take into account possible debt-gap and the fact that the amount of debt may be less than {amountIn}\\n  /// @param amountToRepay Max available amount of borrow asset that we can repay\\n  /// @return expectedAmountOut Estimated amount of main asset that should be added to balance = collateral - {toSell}\\n  /// @return repaidAmountOut Actually paid amount\\n  /// @return amountSendToRepay Amount send to repay\\n  function _repayDebt(\\n    ITetuConverter converter,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountToRepay\\n  ) internal returns (\\n    uint expectedAmountOut,\\n    uint repaidAmountOut,\\n    uint amountSendToRepay\\n  ) {\\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\\n\\n    // get amount of debt with debt-gap\\n    (uint needToRepay,) = converter.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\\n    amountSendToRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\\n\\n    // get expected amount without debt-gap\\n    uint swappedAmountOut;\\n    (expectedAmountOut, swappedAmountOut) = converter.quoteRepay(address(this), collateralAsset, borrowAsset, amountSendToRepay);\\n\\n    if (expectedAmountOut > swappedAmountOut) {\\n      // Following situation is possible\\n      //    needToRepay = 100, needToRepayExact = 90 (debt gap is 10)\\n      //    1) amountRepay = 80\\n      //       expectedAmountOut is calculated for 80, no problems\\n      //    2) amountRepay = 99,\\n      //       expectedAmountOut is calculated for 90 + 9 (90 - repay, 9 - direct swap)\\n      //       expectedAmountOut must be reduced on 9 here (!)\\n      expectedAmountOut -= swappedAmountOut;\\n    }\\n\\n    // close the debt\\n    (, repaidAmountOut) = _closePositionExact(converter, collateralAsset, borrowAsset, amountSendToRepay, balanceBefore);\\n\\n    return (expectedAmountOut, repaidAmountOut, amountSendToRepay);\\n  }\\n  //endregion ------------------------------------------------ Repay debts\\n\\n//region------------------------------------------------ Other helpers\\n\\n  /// @return liquidationThresholdsOut Liquidation thresholds of the {tokens_}, result values > 0\\n  function _getLiquidationThresholds(\\n    mapping(address => uint) storage liquidationThresholds,\\n    address[] memory tokens_,\\n    uint len\\n  ) internal view returns (\\n    uint[] memory liquidationThresholdsOut\\n  ) {\\n    liquidationThresholdsOut = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      liquidationThresholdsOut[i] = AppLib._getLiquidationThreshold(liquidationThresholds[tokens_[i]]);\\n    }\\n  }\\n//endregion--------------------------------------------- Other helpers\\n}\\n\\n\",\"keccak256\":\"0xd33dda395db95950527eac0654c38d367d2d28d9da209c8d0f1dd6e82d98ad50\",\"license\":\"MIT\"},\"contracts/strategies/ConverterStrategyBaseLib2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV3.sol\\\";\\nimport \\\"../libs/AppErrors.sol\\\";\\nimport \\\"../libs/AppLib.sol\\\";\\nimport \\\"../libs/TokenAmountsLib.sol\\\";\\nimport \\\"../libs/ConverterEntryKinds.sol\\\";\\n\\n/// @notice Continuation of ConverterStrategyBaseLib (workaround for size limits)\\nlibrary ConverterStrategyBaseLib2 {\\n  using SafeERC20 for IERC20;\\n\\n//region --------------------------------------- Data types\\n  struct CalcInvestedAssetsLocal {\\n    uint len;\\n    uint[] prices;\\n    uint[] decs;\\n    uint[] debts;\\n    address asset;\\n    address token;\\n  }\\n//endregion --------------------------------------- Data types\\n\\n//region --------------------------------------- CONSTANTS\\n  uint internal constant DENOMINATOR = 100_000;\\n\\n  /// @dev 0.5% of max loss for strategy TVL\\n  /// @notice Same value as StrategySplitterV2.HARDWORK_LOSS_TOLERANCE\\n  uint public constant HARDWORK_LOSS_TOLERANCE = 500;\\n\\n  /// @dev 0.5% of max profit for strategy TVL\\n  /// @notice Limit max amount of profit that can be send to insurance after price changing\\n  uint public constant PRICE_CHANGE_PROFIT_TOLERANCE = HARDWORK_LOSS_TOLERANCE;\\n\\n//endregion --------------------------------------- CONSTANTS\\n\\n//region----------------------------------------- EVENTS\\n  event LiquidationThresholdChanged(address token, uint amount);\\n  event ReinvestThresholdPercentChanged(uint amount);\\n  event FixPriceChanges(uint investedAssetsBefore, uint investedAssetsOut);\\n  /// @notice Compensation of losses is not carried out completely\\n  event UncoveredLoss(uint lossCovered, uint lossUncovered, uint investedAssetsBefore, uint investedAssetsAfter);\\n  /// @notice Payment to insurance was carried out only partially\\n  event UnsentAmountToInsurance(uint sentAmount, uint unsentAmount, uint balance, uint totalAssets);\\n  /// @notice Insurance balance were not enough to cover the loss, {lossUncovered} was uncovered\\n  event NotEnoughInsurance(uint lossUncovered);\\n//endregion----------------------------------------- EVENTS\\n\\n//region----------------------------------------- MAIN LOGIC\\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\\n  function getAvailableBalances(\\n    address[] memory tokens_,\\n    uint indexAsset\\n  ) external view returns (uint[] memory) {\\n    uint len = tokens_.length;\\n    uint[] memory amountsToConvert = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) continue;\\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this));\\n    }\\n    return amountsToConvert;\\n  }\\n\\n\\n  /// @notice Calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\\n  ///         User needs to withdraw {targetAmount_} in main asset.\\n  ///         There are two kinds of available liquidity:\\n  ///         1) liquidity in the pool - {depositorLiquidity_}\\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\\n  ///         To withdraw {targetAmount_} we need\\n  ///         1) Reconvert converted amounts back to main asset\\n  ///         2) IF result amount is not necessary - withdraw some liquidity from the pool\\n  ///            and also convert it to the main asset.\\n  /// @dev This is a writable function with read-only behavior (because of the quote-call)\\n  /// @param targetAmount_ Required amount of main asset to be withdrawn from the strategy; 0 - withdraw all\\n  /// @param strategy_ Address of the strategy\\n  /// @return resultAmount Amount of liquidity that should be withdrawn from the pool, cannot exceed depositorLiquidity\\n  /// @return amountsToConvertOut Amounts of {tokens} that should be converted to the main asset\\n  function getLiquidityAmount(\\n    uint targetAmount_,\\n    address strategy_,\\n    address[] memory tokens,\\n    uint indexAsset,\\n    ITetuConverter converter,\\n    uint investedAssets,\\n    uint depositorLiquidity\\n  ) external returns (\\n    uint resultAmount,\\n    uint[] memory amountsToConvertOut\\n  ) {\\n    bool all = targetAmount_ == 0;\\n\\n    uint len = tokens.length;\\n    amountsToConvertOut = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) continue;\\n\\n      address token = tokens[i];\\n      uint balance = IERC20(token).balanceOf(address(this));\\n      if (balance != 0) {\\n        // let's estimate collateral that we received back after repaying balance-amount\\n        (uint expectedCollateral,) = converter.quoteRepay(strategy_, tokens[indexAsset], token, balance);\\n\\n        if (all || targetAmount_ != 0) {\\n          // We always repay WHOLE available balance-amount even if it gives us much more amount then we need.\\n          // We cannot repay a part of it because converter doesn't allow to know\\n          // what amount should be repaid to get given amount of collateral.\\n          // And it's too dangerous to assume that we can calculate this amount\\n          // by reducing balance-amount proportionally to expectedCollateral/targetAmount_\\n          amountsToConvertOut[i] = balance;\\n        }\\n\\n        targetAmount_ = targetAmount_ > expectedCollateral\\n          ? targetAmount_ - expectedCollateral\\n          : 0;\\n\\n        investedAssets = investedAssets > expectedCollateral\\n          ? investedAssets - expectedCollateral\\n          : 0;\\n      }\\n    }\\n\\n    uint liquidityRatioOut = all || investedAssets == 0\\n      ? 1e18\\n      : ((targetAmount_ == 0)\\n        ? 0\\n        : 1e18\\n        * 101 // add 1% on top...\\n        * targetAmount_ / investedAssets // a part of amount that we are going to withdraw\\n        / 100 // .. add 1% on top\\n      );\\n\\n    resultAmount = liquidityRatioOut != 0\\n      ? Math.min(liquidityRatioOut * depositorLiquidity / 1e18, depositorLiquidity)\\n      : 0;\\n  }\\n\\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\\n  /// @dev The post-processing is rewards conversion to the main asset\\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\\n  /// @param rewardTokens_ List of rewards claimed from the internal pool\\n  /// @param rewardTokens_ Amounts of rewards claimed from the internal pool\\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\\n  /// @param amountsOut Amounts of available rewards\\n  function claimConverterRewards(\\n    ITetuConverter converter_,\\n    address[] memory tokens_,\\n    address[] memory rewardTokens_,\\n    uint[] memory rewardAmounts_,\\n    uint[] memory balancesBefore\\n  ) external returns (\\n    address[] memory tokensOut,\\n    uint[] memory amountsOut\\n  ) {\\n    // Rewards from TetuConverter\\n    (address[] memory tokensTC, uint[] memory amountsTC) = converter_.claimRewards(address(this));\\n\\n    // Join arrays and recycle tokens\\n    (tokensOut, amountsOut) = TokenAmountsLib.combineArrays(\\n      rewardTokens_, rewardAmounts_,\\n      tokensTC, amountsTC,\\n      // by default, depositor assets have zero amounts here\\n      tokens_, new uint[](tokens_.length)\\n    );\\n\\n    // set fresh balances for depositor tokens\\n    uint len = tokensOut.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      for (uint j; j < tokens_.length; j = AppLib.uncheckedInc(j)) {\\n        if (tokensOut[i] == tokens_[j]) {\\n          amountsOut[i] = IERC20(tokens_[j]).balanceOf(address(this)) - balancesBefore[j];\\n        }\\n      }\\n    }\\n\\n    // filter zero amounts out\\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\\n  }\\n\\n  /// @notice Get prices of {tokenA} and {tokenB}\\n  function getOracleAssetsPrices(ITetuConverter converter, address tokenA, address tokenB) external view returns (\\n    uint priceA,\\n    uint priceB\\n  ) {\\n    IPriceOracle oracle = AppLib._getPriceOracle(converter);\\n    priceA = oracle.getAssetPrice(tokenA);\\n    priceB = oracle.getAssetPrice(tokenB);\\n  }\\n\\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\\n    return AppLib._getPriceOracle(converter).getAssetPrice(token);\\n  }\\n\\n  /// @notice Try to find zero amount\\n  /// @return True if {amounts_} array contains zero amount\\n  function findZeroAmount(uint[] memory amounts_) internal pure returns (bool) {\\n    uint len = amounts_.length;\\n    for (uint i = 0; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (amounts_[i] == 0) return true;\\n    }\\n    return false;\\n  }\\n//endregion ----------------------------------------- MAIN LOGIC\\n\\n//region -------------------------------------------- Cover loss, send profit to insurance\\n  /// @notice Send given amount of underlying to the insurance\\n  /// @param totalAssets_ Total strategy balance = balance of underlying + current invested assets amount\\n  /// @return sentAmount Amount of underlying sent to the insurance\\n  /// @return unsentAmount Missed part of the {amount} that were not sent to the insurance\\n  function sendToInsurance(address asset, uint amount, address splitter, uint totalAssets_) external returns (\\n    uint sentAmount,\\n    uint unsentAmount\\n  ) {\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    uint amountToSend = Math.min(amount, balance);\\n    if (amountToSend != 0) {\\n      // max amount that can be send to insurance is limited by PRICE_CHANGE_PROFIT_TOLERANCE\\n\\n      // Amount limitation should be implemented in the same way as in StrategySplitterV2._coverLoss\\n      // Revert or cut amount in both cases\\n\\n      require(totalAssets_ != 0, AppErrors.ZERO_BALANCE);\\n      amountToSend = Math.min(amountToSend, PRICE_CHANGE_PROFIT_TOLERANCE * totalAssets_ / 100_000);\\n      //require(amountToSend <= PRICE_CHANGE_PROFIT_TOLERANCE * strategyBalance / 100_000, AppErrors.EARNED_AMOUNT_TOO_HIGH);\\n\\n      IERC20(asset).safeTransfer(address(ITetuVaultV2(ISplitter(splitter).vault()).insurance()), amountToSend);\\n    }\\n\\n    sentAmount = amountToSend;\\n    unsentAmount = amount > amountToSend\\n      ? amount - amountToSend\\n      : 0;\\n\\n    if (unsentAmount != 0) {\\n      emit UnsentAmountToInsurance(sentAmount, unsentAmount, balance, totalAssets_);\\n    }\\n  }\\n\\n  function _registerIncome(uint assetBefore, uint assetAfter) internal pure returns (uint earned, uint lost) {\\n    if (assetAfter > assetBefore) {\\n      earned = assetAfter - assetBefore;\\n    } else {\\n      lost = assetBefore - assetAfter;\\n    }\\n    return (earned, lost);\\n  }\\n\\n  /// @notice Register income and cover possible loss after price changing, emit FixPriceChanges\\n  function coverLossAfterPriceChanging(\\n    uint investedAssetsBefore,\\n    uint investedAssetsAfter,\\n    IStrategyV3.BaseState storage baseState\\n  ) external returns (uint earned) {\\n    uint lost;\\n    (earned, lost) = _registerIncome(investedAssetsBefore, investedAssetsAfter);\\n    if (lost != 0) {\\n      (uint lossToCover, uint lossUncovered) = getSafeLossToCover(\\n        lost,\\n        investedAssetsAfter + IERC20(baseState.asset).balanceOf(address(this)) // totalAssets\\n      );\\n      _coverLossAndCheckResults(baseState.splitter, earned, lossToCover);\\n\\n      if (lossUncovered != 0) {\\n        emit UncoveredLoss(lossToCover, lossUncovered, investedAssetsBefore, investedAssetsAfter);\\n      }\\n    }\\n    emit FixPriceChanges(investedAssetsBefore, investedAssetsAfter);\\n  }\\n\\n  /// @notice Call coverPossibleStrategyLoss, covered loss will be sent to vault.\\n  ///         If the loss were covered only partially, emit {NotEnoughInsurance}\\n  function _coverLossAndCheckResults(address splitter, uint earned, uint lossToCover) internal {\\n    address asset = ISplitter(splitter).asset();\\n    address vault = ISplitter(splitter).vault();\\n    uint balanceBefore = IERC20(asset).balanceOf(vault);\\n    ISplitter(splitter).coverPossibleStrategyLoss(earned, lossToCover);\\n    uint delta = IERC20(asset).balanceOf(vault); // temporary save balance-after to delta\\n    delta = delta > balanceBefore\\n      ? delta - balanceBefore\\n      : 0;\\n    if (delta < lossToCover) {\\n      emit NotEnoughInsurance(lossToCover - delta);\\n    }\\n  }\\n\\n  /// @notice Cut loss-value to safe value that doesn't produce revert inside splitter\\n  function getSafeLossToCover(uint loss, uint totalAssets_) internal pure returns (\\n    uint lossToCover,\\n    uint lossUncovered\\n  ) {\\n    // see StrategySplitterV2._declareStrategyIncomeAndCoverLoss, _coverLoss implementations\\n    lossToCover = Math.min(loss, HARDWORK_LOSS_TOLERANCE * totalAssets_ / 100_000);\\n    lossUncovered = loss > lossToCover\\n      ? loss - lossToCover\\n      : 0;\\n  }\\n//endregion -------------------------------------------- Cover loss, send profit to insurance\\n\\n//region ---------------------------------------- Setters\\n  function checkReinvestThresholdPercentChanged(address controller, uint percent_) external {\\n    StrategyLib.onlyOperators(controller);\\n    require(percent_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\\n    emit ReinvestThresholdPercentChanged(percent_);\\n  }\\n\\n  function checkLiquidationThresholdChanged(address controller, address token, uint amount) external {\\n    StrategyLib.onlyOperators(controller);\\n    emit LiquidationThresholdChanged(token, amount);\\n  }\\n//endregion ---------------------------------------- Setters\\n\\n//region ---------------------------------------- Withdraw helpers\\n  /// @notice Get amount of assets that we expect to receive after withdrawing\\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\\n  ///                  one of assets must be {asset_}\\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\\n  function getExpectedWithdrawnAmounts(\\n    uint[] memory reserves_,\\n    uint liquidityAmount_,\\n    uint totalSupply_\\n  ) internal pure returns (\\n    uint[] memory withdrawnAmountsOut\\n  ) {\\n    uint ratio = totalSupply_ == 0\\n      ? 0\\n      : (liquidityAmount_ >= totalSupply_\\n        ? 1e18\\n        : 1e18 * liquidityAmount_ / totalSupply_\\n      );\\n\\n    uint len = reserves_.length;\\n    withdrawnAmountsOut = new uint[](len);\\n\\n    if (ratio != 0) {\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\\n      }\\n    }\\n  }\\n\\n  /// @notice Calculate expected amount of the main asset after withdrawing\\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\\n  /// @return amountsOut Expected amounts of the main asset received after conversion withdrawnAmounts+amountsToConvert\\n  function getExpectedAmountMainAsset(\\n    address[] memory tokens,\\n    uint indexAsset,\\n    ITetuConverter converter,\\n    uint[] memory withdrawnAmounts_,\\n    uint[] memory amountsToConvert_\\n  ) internal returns (\\n    uint[] memory amountsOut\\n  ) {\\n    uint len = tokens.length;\\n    amountsOut = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) {\\n        amountsOut[i] = withdrawnAmounts_[i];\\n      } else {\\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\\n        if (amount != 0) {\\n          (amountsOut[i],) = converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\\n        }\\n      }\\n    }\\n\\n    return amountsOut;\\n  }\\n\\n  /// @notice Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\\n  /// @param amountsToConvert Amounts of {tokens} to be converted, they are located on the balance before withdraw\\n  /// @param withdrawnAmounts Amounts of {tokens} that were withdrew from the pool\\n  function postWithdrawActions(\\n    ITetuConverter converter,\\n    address[] memory tokens,\\n    uint indexAsset,\\n\\n    uint[] memory reservesBeforeWithdraw,\\n    uint liquidityAmountWithdrew,\\n    uint totalSupplyBeforeWithdraw,\\n\\n    uint[] memory amountsToConvert,\\n    uint[] memory withdrawnAmounts\\n  ) external returns (\\n    uint[] memory expectedMainAssetAmounts,\\n    uint[] memory _amountsToConvert\\n  ) {\\n    // estimate expected amount of assets to be withdrawn\\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\\n      reservesBeforeWithdraw,\\n      liquidityAmountWithdrew,\\n      totalSupplyBeforeWithdraw\\n    );\\n\\n    // from received amounts after withdraw calculate how much we receive from converter for them in terms of the underlying asset\\n    expectedMainAssetAmounts = getExpectedAmountMainAsset(\\n      tokens,\\n      indexAsset,\\n      converter,\\n      expectedWithdrawAmounts,\\n      amountsToConvert\\n    );\\n\\n    uint len = tokens.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      amountsToConvert[i] += withdrawnAmounts[i];\\n    }\\n\\n    return (expectedMainAssetAmounts, amountsToConvert);\\n  }\\n\\n  /// @notice return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\\n  function postWithdrawActionsEmpty(\\n    ITetuConverter converter,\\n    address[] memory tokens,\\n    uint indexAsset,\\n    uint[] memory amountsToConvert_\\n  ) external returns (\\n    uint[] memory expectedAmountsMainAsset\\n  ) {\\n    expectedAmountsMainAsset = getExpectedAmountMainAsset(\\n      tokens,\\n      indexAsset,\\n      converter,\\n      // there are no withdrawn amounts\\n      new uint[](tokens.length), // array with all zero values\\n      amountsToConvert_\\n    );\\n  }\\n//endregion ------------------------------------- Withdraw helpers\\n\\n//region---------------------------------------- calcInvestedAssets\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\n  /// @param indexAsset Index of the underlying (main asset) in {tokens}\\n  /// @return amountOut Invested asset amount under control (in terms of underlying)\\n  function calcInvestedAssets(\\n    address[] memory tokens,\\n    uint[] memory depositorQuoteExitAmountsOut,\\n    uint indexAsset,\\n    ITetuConverter converter_\\n  ) external returns (\\n    uint amountOut\\n  ) {\\n    return _calcInvestedAssets(tokens, depositorQuoteExitAmountsOut, indexAsset, converter_);\\n  }\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\n  /// @param indexAsset Index of the underlying (main asset) in {tokens}\\n  /// @return amountOut Invested asset amount under control (in terms of underlying)\\n  function _calcInvestedAssets(\\n    address[] memory tokens,\\n    uint[] memory depositorQuoteExitAmountsOut,\\n    uint indexAsset,\\n    ITetuConverter converter_\\n  ) internal returns (\\n    uint amountOut\\n  ) {\\n    CalcInvestedAssetsLocal memory v;\\n    v.len = tokens.length;\\n    v.asset = tokens[indexAsset];\\n\\n    // calculate prices, decimals\\n    (v.prices, v.decs) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(converter_), tokens, v.len);\\n\\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) {\\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\\n        amountOut += depositorQuoteExitAmountsOut[i];\\n      } else {\\n        v.token = tokens[i];\\n        // possible reverse debt: collateralAsset = tokens[i], borrowAsset = underlying\\n        // investedAssets is calculated using exact debts, debt-gaps are not taken into account\\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(address(this), v.token, v.asset, false);\\n        if (amountOut < toPay) {\\n          setDebt(v, indexAsset, toPay);\\n        } else {\\n          amountOut -= toPay;\\n        }\\n\\n        // available amount to repay\\n        uint toRepay = collateral + IERC20(v.token).balanceOf(address(this)) + depositorQuoteExitAmountsOut[i];\\n\\n        // direct debt: collateralAsset = underlying, borrowAsset = tokens[i]\\n        // investedAssets is calculated using exact debts, debt-gaps are not taken into account\\n        (toPay, collateral) = converter_.getDebtAmountCurrent(address(this), v.asset, v.token, false);\\n        amountOut += collateral;\\n\\n        if (toRepay >= toPay) {\\n          amountOut += (toRepay - toPay) * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\\n        } else {\\n          // there is not enough amount to pay the debt\\n          // let's register a debt and try to resolve it later below\\n          setDebt(v, i, toPay - toRepay);\\n        }\\n      }\\n    }\\n    if (v.debts.length == v.len) {\\n      // we assume here, that it would be always profitable to save collateral\\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n        if (v.debts[i] == 0) continue;\\n\\n        // estimatedAssets should be reduced on the debt-value\\n        // this estimation is approx and do not count price impact on the liquidation\\n        // we will able to count the real output only after withdraw process\\n        uint debtInAsset = v.debts[i] * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\\n        if (debtInAsset > amountOut) {\\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\\n          amountOut = 0;\\n        } else {\\n          amountOut -= debtInAsset;\\n        }\\n      }\\n    }\\n\\n    return amountOut;\\n  }\\n\\n  /// @notice Lazy initialization of v.debts, add {value} to {v.debts[index]}\\n  function setDebt(CalcInvestedAssetsLocal memory v, uint index, uint value) pure internal {\\n    if (v.debts.length == 0) {\\n      // lazy initialization\\n      v.debts = new uint[](v.len);\\n    }\\n\\n    // to pay the following amount we need to swap some other asset at first\\n    v.debts[index] += value;\\n  }\\n\\n  /// @notice Calculate the token amounts for deposit and amount of loss (as old-total-asset - new-total-asset)\\n  /// @param liquidationThresholdsAB [liquidityThreshold of token A, liquidityThreshold of tokenB]\\n  /// @return loss New total assets - old total assets\\n  /// @return tokenAmounts Balances of the token A and token B.\\n  ///                     If any balance is zero it's not possible to enter to the pool, so return empty array (len 0)\\n  function getTokenAmountsPair(\\n    ITetuConverter converter,\\n    uint totalAssets,\\n    address tokenA,\\n    address tokenB,\\n    uint[2] calldata liquidationThresholdsAB\\n  ) external returns (\\n    uint loss,\\n    uint[] memory tokenAmounts\\n  ) {\\n    tokenAmounts = new uint[](2);\\n    tokenAmounts[0] = AppLib.balance(tokenA);\\n    tokenAmounts[1] = AppLib.balance(tokenB);\\n\\n    address[] memory tokens = new address[](2);\\n    tokens[0] = tokenA;\\n    tokens[1] = tokenB;\\n\\n    uint[] memory amounts = new uint[](2);\\n    amounts[0] = tokenAmounts[0];\\n\\n    uint newTotalAssets = _calcInvestedAssets(tokens, amounts, 0, converter);\\n    return (\\n      newTotalAssets < totalAssets\\n        ? totalAssets - newTotalAssets\\n        : 0,\\n      (tokenAmounts[0] < liquidationThresholdsAB[0] || tokenAmounts[1] < liquidationThresholdsAB[1])\\n        ? new uint[](0)\\n        : tokenAmounts\\n    );\\n  }\\n//endregion------------------------------------- calcInvestedAssets\\n}\\n\\n\",\"keccak256\":\"0x364e2487b7c031702ad0ec6b2f615468c825a31f4d9fac6d7e14d218ba5a0893\",\"license\":\"MIT\"},\"contracts/strategies/algebra/AlgebraConverterStrategyLogicLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./AlgebraLib.sol\\\";\\nimport \\\"./AlgebraDebtLib.sol\\\";\\nimport \\\"./AlgebraStrategyErrors.sol\\\";\\nimport \\\"../../libs/AppLib.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/lib/StringLib.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\nimport \\\"../pair/PairBasedStrategyLogicLib.sol\\\";\\n\\nlibrary AlgebraConverterStrategyLogicLib {\\n  using SafeERC20 for IERC20;\\n\\n  //region ------------------------------------------------ Constants\\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_STABLE = 300;\\n  uint internal constant LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE = 500;\\n  uint internal constant HARD_WORK_USD_FEE_THRESHOLD = 100;\\n\\n  INonfungiblePositionManager internal constant ALGEBRA_NFT = INonfungiblePositionManager(0x8eF88E4c7CfbbaC1C163f7eddd4B578792201de6);\\n  IFarmingCenter internal constant FARMING_CENTER = IFarmingCenter(0x7F281A8cdF66eF5e9db8434Ec6D97acc1bc01E78);\\n  //endregion ------------------------------------------------ Constants\\n\\n  //region ------------------------------------------------ Events\\n  event Rebalanced(uint loss, uint profitToCover, uint coveredByRewards);\\n  event AlgebraFeesClaimed(uint fee0, uint fee1);\\n  event AlgebraRewardsClaimed(uint reward, uint bonusReward);\\n  //endregion ------------------------------------------------ Data types\\n\\n  //region ------------------------------------------------ Data types\\n\\n  struct State {\\n    PairBasedStrategyLogicLib.PairState pair;\\n    // additional (specific) state\\n\\n    uint tokenId;\\n    // farming\\n    address rewardToken;\\n    address bonusRewardToken;\\n    uint256 startTime;\\n    uint256 endTime;\\n  }\\n\\n  struct RebalanceLocal {\\n    /// @notice Fuse for token A and token B\\n    PairBasedStrategyLib.FuseStateParams[2] fuseAB;\\n    ITetuConverter converter;\\n    IAlgebraPool pool;\\n    address tokenA;\\n    address tokenB;\\n    bool isStablePool;\\n    uint[2] liquidationThresholdsAB;\\n\\n    bool[2] fuseStatusChangedAB;\\n    PairBasedStrategyLib.FuseStatus[2] fuseStatusAB;\\n  }\\n\\n  struct EnterLocalVariables {\\n    bool depositorSwapTokens;\\n    uint128 liquidity;\\n    uint tokenId;\\n    int24 lowerTick;\\n    int24 upperTick;\\n  }\\n\\n  struct IsReadyToHardWorkLocal {\\n    address tokenA;\\n    address tokenB;\\n    uint rewardInTermOfTokenA;\\n    uint bonusRewardInTermOfTokenA;\\n    uint fee0;\\n    uint fee1;\\n  }\\n  //endregion ------------------------------------------------ Data types\\n\\n  //region ------------------------------------------------ Helpers\\n\\n  /// @param controllerPool [controller, pool]\\n  /// @param fuseThresholdsA Fuse thresholds for token A (stable pool only)\\n  /// @param fuseThresholdsB Fuse thresholds for token B (stable pool only)\\n  function initStrategyState(\\n    State storage state,\\n    address[2] calldata controllerPool,\\n    int24 tickRange,\\n    int24 rebalanceTickRange,\\n    address asset_,\\n    bool isStablePool,\\n    uint[4] calldata fuseThresholdsA,\\n    uint[4] calldata fuseThresholdsB\\n  ) external {\\n    require(controllerPool[1] != address(0), AppErrors.ZERO_ADDRESS);\\n    address token0 = IAlgebraPool(controllerPool[1]).token0();\\n    address token1 = IAlgebraPool(controllerPool[1]).token1();\\n\\n    int24[4] memory tickData;\\n    {\\n      int24 tickSpacing = AlgebraLib.tickSpacing();\\n      if (tickRange != 0) {\\n        require(tickRange == tickRange / tickSpacing * tickSpacing, AlgebraStrategyErrors.INCORRECT_TICK_RANGE);\\n        require(rebalanceTickRange == rebalanceTickRange / tickSpacing * tickSpacing, AlgebraStrategyErrors.INCORRECT_REBALANCE_TICK_RANGE);\\n      }\\n      tickData[0] = tickSpacing;\\n      (tickData[1], tickData[2]) = AlgebraDebtLib.calcTickRange(IAlgebraPool(controllerPool[1]), tickRange, tickSpacing);\\n      tickData[3] = rebalanceTickRange;\\n    }\\n\\n    PairBasedStrategyLogicLib.setInitialDepositorValues(\\n      state.pair,\\n      [controllerPool[1], asset_, token0, token1],\\n      tickData,\\n      isStablePool,\\n      fuseThresholdsA,\\n      fuseThresholdsB\\n    );\\n\\n    address liquidator = IController(controllerPool[0]).liquidator();\\n    IERC20(token0).approve(liquidator, type(uint).max);\\n    IERC20(token1).approve(liquidator, type(uint).max);\\n    IERC20(token0).approve(address(ALGEBRA_NFT), type(uint).max);\\n    IERC20(token1).approve(address(ALGEBRA_NFT), type(uint).max);\\n  }\\n\\n  function initFarmingState(\\n    State storage state,\\n    IncentiveKey calldata key\\n  ) external {\\n    state.rewardToken = key.rewardToken;\\n    state.bonusRewardToken = key.bonusRewardToken;\\n    state.startTime = key.startTime;\\n    state.endTime = key.endTime;\\n  }\\n\\n  function createSpecificName(PairBasedStrategyLogicLib.PairState storage pairState) external view returns (string memory) {\\n    return string(abi.encodePacked(\\\"Algebra \\\", IERC20Metadata(pairState.tokenA).symbol(), \\\"/\\\", IERC20Metadata(pairState.tokenB).symbol()));\\n  }\\n\\n  function getIncentiveKey(State storage state) internal view returns (IncentiveKey memory) {\\n    return IncentiveKey(state.rewardToken, state.bonusRewardToken, state.pair.pool, state.startTime, state.endTime);\\n  }\\n\\n  function getFees(State storage state) public view returns (uint fee0, uint fee1) {\\n    (fee0, fee1) = AlgebraLib.getFees(IAlgebraPool(state.pair.pool), ALGEBRA_NFT, state.tokenId);\\n  }\\n\\n  function getPoolReserves(PairBasedStrategyLogicLib.PairState storage pairState) external view returns (\\n    uint[] memory reserves\\n  ) {\\n    reserves = new uint[](2);\\n    (uint160 sqrtRatioX96, , , , , ,) = IAlgebraPool(pairState.pool).globalState();\\n\\n    (reserves[0], reserves[1]) = AlgebraLib.getAmountsForLiquidity(\\n      sqrtRatioX96,\\n      pairState.lowerTick,\\n      pairState.upperTick,\\n      pairState.totalLiquidity\\n    );\\n\\n    if (pairState.depositorSwapTokens) {\\n      (reserves[0], reserves[1]) = (reserves[1], reserves[0]);\\n    }\\n  }\\n\\n  /// @dev Gets the liquidator swap slippage based on the pool type (stable or volatile).\\n  /// @return The liquidator swap slippage percentage.\\n  function _getLiquidatorSwapSlippage(bool isStablePool) internal pure returns (uint) {\\n    return isStablePool ? LIQUIDATOR_SWAP_SLIPPAGE_STABLE : LIQUIDATOR_SWAP_SLIPPAGE_VOLATILE;\\n  }\\n  //endregion ------------------------------------------------ Helpers\\n\\n  //region ------------------------------------------------ Pool info\\n  function getEntryData(\\n    IAlgebraPool pool,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    bool depositorSwapTokens\\n  ) public view returns (bytes memory entryData) {\\n    return AlgebraDebtLib.getEntryData(pool, lowerTick, upperTick, depositorSwapTokens);\\n  }\\n  //endregion ------------------------------------------------ Helpers\\n\\n  //region ------------------------------------------------ Join the pool\\n\\n  function enter(\\n    State storage state,\\n    uint[] memory amountsDesired_\\n  ) external returns (uint[] memory amountsConsumed, uint liquidityOut) {\\n    EnterLocalVariables memory vars = EnterLocalVariables({\\n      depositorSwapTokens : state.pair.depositorSwapTokens,\\n      liquidity : 0,\\n      tokenId : state.tokenId,\\n      lowerTick : state.pair.lowerTick,\\n      upperTick : state.pair.upperTick\\n    });\\n\\n    (address token0, address token1) = vars.depositorSwapTokens\\n      ? (state.pair.tokenB, state.pair.tokenA)\\n      : (state.pair.tokenA, state.pair.tokenB);\\n    if (vars.depositorSwapTokens) {\\n      (amountsDesired_[0], amountsDesired_[1]) = (amountsDesired_[1], amountsDesired_[0]);\\n    }\\n\\n    amountsConsumed = new uint[](2);\\n\\n    if (vars.tokenId > 0) {\\n      (,,,,int24 nftLowerTick, int24 nftUpperTick,,,,,) = ALGEBRA_NFT.positions(vars.tokenId);\\n      if (nftLowerTick != vars.lowerTick || nftUpperTick != vars.upperTick) {\\n        ALGEBRA_NFT.burn(vars.tokenId);\\n        vars.tokenId = 0;\\n      }\\n    }\\n\\n    IncentiveKey memory key = getIncentiveKey(state);\\n\\n    if (vars.tokenId == 0) {\\n      (vars.tokenId, vars.liquidity, amountsConsumed[0], amountsConsumed[1]) = ALGEBRA_NFT.mint(INonfungiblePositionManager.MintParams(\\n        token0,\\n        token1,\\n        vars.lowerTick,\\n        vars.upperTick,\\n        amountsDesired_[0],\\n        amountsDesired_[1],\\n        0,\\n        0,\\n        address(this),\\n        block.timestamp\\n      ));\\n\\n      state.tokenId = vars.tokenId;\\n\\n      ALGEBRA_NFT.safeTransferFrom(address(this), address(FARMING_CENTER), vars.tokenId);\\n    } else {\\n      (vars.liquidity, amountsConsumed[0], amountsConsumed[1]) = ALGEBRA_NFT.increaseLiquidity(INonfungiblePositionManager.IncreaseLiquidityParams(\\n        vars.tokenId,\\n        amountsDesired_[0],\\n        amountsDesired_[1],\\n        0,\\n        0,\\n        block.timestamp\\n      ));\\n\\n      if (state.pair.totalLiquidity > 0) {\\n        // get reward amounts\\n        (uint reward, uint bonusReward) = FARMING_CENTER.collectRewards(key, vars.tokenId);\\n\\n        // exit farming (undeposit)\\n        FARMING_CENTER.exitFarming(key, vars.tokenId, false);\\n\\n        // claim rewards and send to profit holder\\n        {\\n          address strategyProfitHolder = state.pair.strategyProfitHolder;\\n\\n          if (reward > 0) {\\n            address token = state.rewardToken;\\n            reward = FARMING_CENTER.claimReward(token, address(this), 0, reward);\\n            IERC20(token).safeTransfer(strategyProfitHolder, reward);\\n          }\\n          if (bonusReward > 0) {\\n            address token = state.bonusRewardToken;\\n            bonusReward = FARMING_CENTER.claimReward(token, address(this), 0, bonusReward);\\n            IERC20(token).safeTransfer(strategyProfitHolder, bonusReward);\\n          }\\n        }\\n      } else {\\n        ALGEBRA_NFT.safeTransferFrom(address(this), address(FARMING_CENTER), vars.tokenId);\\n      }\\n    }\\n\\n    FARMING_CENTER.enterFarming(key, vars.tokenId, 0, false);\\n\\n    state.pair.totalLiquidity += vars.liquidity;\\n    liquidityOut = uint(vars.liquidity);\\n  }\\n  //endregion ------------------------------------------------ Join the pool\\n\\n  //region ------------------------------------------------ Exit the pool\\n\\n  function exit(\\n    State storage state,\\n    uint128 liquidityAmountToExit\\n  ) external returns (uint[] memory amountsOut) {\\n    amountsOut = new uint[](2);\\n    address strategyProfitHolder = state.pair.strategyProfitHolder;\\n    IncentiveKey memory key = getIncentiveKey(state);\\n\\n    uint128 liquidity = state.pair.totalLiquidity;\\n\\n    require(liquidity >= liquidityAmountToExit, AlgebraStrategyErrors.WRONG_LIQUIDITY);\\n\\n    // we assume here, that liquidity is not zero (otherwise it doesn't worth to call exit)\\n    uint tokenId = state.tokenId;\\n\\n    // get reward amounts\\n    (uint reward, uint bonusReward) = FARMING_CENTER.collectRewards(key, tokenId);\\n\\n    // exit farming (undeposit)\\n    FARMING_CENTER.exitFarming(getIncentiveKey(state), state.tokenId, false);\\n\\n    // claim rewards and send to profit holder\\n    {\\n      if (reward > 0) {\\n        address token = state.rewardToken;\\n        reward = FARMING_CENTER.claimReward(token, address(this), 0, reward);\\n        IERC20(token).safeTransfer(strategyProfitHolder, reward);\\n      }\\n      if (bonusReward > 0) {\\n        address token = state.bonusRewardToken;\\n        bonusReward = FARMING_CENTER.claimReward(token, address(this), 0, bonusReward);\\n        IERC20(token).safeTransfer(strategyProfitHolder, bonusReward);\\n      }\\n    }\\n\\n    // withdraw nft\\n    FARMING_CENTER.withdrawToken(tokenId, address(this), '');\\n\\n    // burn liquidity\\n    (amountsOut[0], amountsOut[1]) = ALGEBRA_NFT.decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams(tokenId, liquidityAmountToExit, 0, 0, block.timestamp));\\n\\n    {\\n      // collect tokens and fee\\n      (uint collected0, uint collected1) = ALGEBRA_NFT.collect(INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max));\\n\\n      uint fee0 = collected0 > amountsOut[0] ? (collected0 - amountsOut[0]) : 0;\\n      uint fee1 = collected1 > amountsOut[1] ? (collected1 - amountsOut[1]) : 0;\\n\\n      emit AlgebraFeesClaimed(fee0, fee1);\\n\\n      if (state.pair.depositorSwapTokens) {\\n        (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\\n        (fee0, fee1) = (fee1, fee0);\\n      }\\n\\n      // send fees to profit holder\\n      if (fee0 > 0) {\\n        IERC20(state.pair.tokenA).safeTransfer(strategyProfitHolder, fee0);\\n      }\\n      if (fee1 > 0) {\\n        IERC20(state.pair.tokenB).safeTransfer(strategyProfitHolder, fee1);\\n      }\\n    }\\n\\n    liquidity -= liquidityAmountToExit;\\n    state.pair.totalLiquidity = liquidity;\\n\\n    if (liquidity > 0) {\\n      ALGEBRA_NFT.safeTransferFrom(address(this), address(FARMING_CENTER), tokenId);\\n      FARMING_CENTER.enterFarming(key, tokenId, 0, false);\\n    }\\n  }\\n\\n  function quoteExit(\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\n    uint128 liquidityAmountToExit\\n  ) public view returns (uint[] memory amountsOut) {\\n    (uint160 sqrtRatioX96, , , , , ,) = IAlgebraPool(pairState.pool).globalState();\\n    amountsOut = new uint[](2);\\n    (amountsOut[0], amountsOut[1]) = AlgebraLib.getAmountsForLiquidity(\\n      sqrtRatioX96,\\n      pairState.lowerTick,\\n      pairState.upperTick,\\n      liquidityAmountToExit\\n    );\\n    if (pairState.depositorSwapTokens) {\\n      (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\\n    }\\n  }\\n  //endregion ------------------------------------------------ Exit the pool\\n\\n  //region ------------------------------------------------ Rewards\\n\\n  function isReadyToHardWork(State storage state, ITetuConverter converter, address controller) external view returns (bool isReady) {\\n    IsReadyToHardWorkLocal memory v;\\n    v.tokenA = state.pair.tokenA;\\n    v.tokenB = state.pair.tokenB;\\n    address h = state.pair.strategyProfitHolder;\\n\\n    if (state.pair.totalLiquidity != 0) {\\n      address rewardToken = state.rewardToken;\\n      address bonusRewardToken = state.bonusRewardToken;\\n      IncentiveKey memory key = getIncentiveKey(state);\\n      (uint reward, uint bonusReward) = FARMING_CENTER.eternalFarming().getRewardInfo(key, state.tokenId);\\n      reward += IERC20(rewardToken).balanceOf(h);\\n      bonusReward += IERC20(bonusRewardToken).balanceOf(h);\\n      ITetuLiquidator liquidator = ITetuLiquidator(IController(controller).liquidator());\\n      if (reward > 0) {\\n        v.rewardInTermOfTokenA = liquidator.getPrice(rewardToken, v.tokenA, reward);\\n      }\\n      if (v.bonusRewardInTermOfTokenA > 0) {\\n        v.bonusRewardInTermOfTokenA = liquidator.getPrice(bonusRewardToken, v.tokenA, bonusReward);\\n      }\\n      (v.fee0, v.fee1) = getFees(state);\\n    }\\n\\n    // check claimable amounts and compare with thresholds\\n    if (state.pair.depositorSwapTokens) {\\n      (v.fee0, v.fee1) = (v.fee1, v.fee0);\\n    }\\n\\n    v.fee0 += IERC20(v.tokenA).balanceOf(h);\\n    v.fee1 += IERC20(v.tokenB).balanceOf(h);\\n\\n    IPriceOracle oracle = AppLib._getPriceOracle(converter);\\n    uint priceA = oracle.getAssetPrice(v.tokenA);\\n    uint priceB = oracle.getAssetPrice(v.tokenB);\\n\\n    uint fee0USD = v.fee0 * priceA / 1e18;\\n    uint fee1USD = v.fee1 * priceB / 1e18;\\n\\n    return\\n      fee0USD > HARD_WORK_USD_FEE_THRESHOLD\\n      || fee1USD > HARD_WORK_USD_FEE_THRESHOLD\\n      || v.rewardInTermOfTokenA * priceA / 1e18 > HARD_WORK_USD_FEE_THRESHOLD\\n      || v.bonusRewardInTermOfTokenA * priceA / 1e18 > HARD_WORK_USD_FEE_THRESHOLD\\n    ;\\n  }\\n\\n  function claimRewards(State storage state) external returns (\\n    address[] memory tokensOut,\\n    uint[] memory amountsOut,\\n    uint[] memory balancesBefore\\n  ) {\\n    address strategyProfitHolder = state.pair.strategyProfitHolder;\\n    uint tokenId = state.tokenId;\\n    tokensOut = new address[](4);\\n    tokensOut[0] = state.pair.tokenA;\\n    tokensOut[1] = state.pair.tokenB;\\n    tokensOut[2] = state.rewardToken;\\n    tokensOut[3] = state.bonusRewardToken;\\n\\n    balancesBefore = new uint[](4);\\n    for (uint i; i < tokensOut.length; i++) {\\n      balancesBefore[i] = IERC20(tokensOut[i]).balanceOf(address(this));\\n    }\\n\\n    amountsOut = new uint[](4);\\n    if (tokenId > 0 && state.pair.totalLiquidity > 0) {\\n      (amountsOut[0], amountsOut[1]) = FARMING_CENTER.collect(INonfungiblePositionManager.CollectParams(tokenId, address(this), type(uint128).max, type(uint128).max));\\n\\n      emit AlgebraFeesClaimed(amountsOut[0], amountsOut[1]);\\n\\n      if (state.pair.depositorSwapTokens) {\\n        (amountsOut[0], amountsOut[1]) = (amountsOut[1], amountsOut[0]);\\n      }\\n\\n      (amountsOut[2], amountsOut[3]) = FARMING_CENTER.collectRewards(getIncentiveKey(state), tokenId);\\n\\n      if (amountsOut[2] > 0) {\\n        amountsOut[2] = FARMING_CENTER.claimReward(tokensOut[2], address(this), 0, amountsOut[2]);\\n      }\\n\\n      if (amountsOut[3] > 0) {\\n        amountsOut[3] = FARMING_CENTER.claimReward(tokensOut[3], address(this), 0, amountsOut[3]);\\n      }\\n\\n      emit AlgebraRewardsClaimed(amountsOut[2], amountsOut[3]);\\n    }\\n\\n    for (uint i; i < tokensOut.length; ++i) {\\n      uint b = IERC20(tokensOut[i]).balanceOf(strategyProfitHolder);\\n      if (b > 0) {\\n        IERC20(tokensOut[i]).transferFrom(strategyProfitHolder, address(this), b);\\n        amountsOut[i] += b;\\n      }\\n    }\\n  }\\n\\n  function calcEarned(address asset, address controller, address[] memory rewardTokens, uint[] memory amounts) external view returns (uint) {\\n    ITetuLiquidator liquidator = ITetuLiquidator(IController(controller).liquidator());\\n    uint len = rewardTokens.length;\\n    uint earned;\\n    for (uint i; i < len; ++i) {\\n      address token = rewardTokens[i];\\n      if (token == asset) {\\n        earned += amounts[i];\\n      } else {\\n        earned += liquidator.getPrice(rewardTokens[i], asset, amounts[i]);\\n      }\\n    }\\n\\n    return earned;\\n  }\\n  //endregion ------------------------------------------------ Rewards\\n\\n  //region ------------------------------------------------ Rebalance\\n\\n  /// @notice Determine if the strategy needs to be rebalanced.\\n  /// @return needRebalance A boolean indicating if {rebalanceNoSwaps} should be called\\n  function needStrategyRebalance(PairBasedStrategyLogicLib.PairState storage pairState, ITetuConverter converter_) external view returns (\\n    bool needRebalance\\n  ) {\\n    (needRebalance, , ) = PairBasedStrategyLogicLib.needStrategyRebalance(\\n      pairState,\\n      converter_,\\n      AlgebraDebtLib.getCurrentTick(IAlgebraPool(pairState.pool))\\n    );\\n  }\\n\\n  /// @notice Make rebalance without swaps (using borrowing only).\\n  /// @param converterLiquidator [TetuConverter, TetuLiquidator]\\n  /// @param checkNeedRebalance_ True if the function should ensure that the rebalance is required\\n  /// @param totalAssets_ Current value of totalAssets()\\n  /// @return tokenAmounts Token amounts for deposit. If length == 0 - rebalance wasn't made and no deposit is required.\\n  function rebalanceNoSwaps(\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\n    address[2] calldata converterLiquidator,\\n    uint totalAssets_,\\n    uint profitToCover,\\n    address splitter,\\n    bool checkNeedRebalance_,\\n    mapping(address => uint) storage liquidityThresholds_\\n  ) external returns (\\n    uint[] memory tokenAmounts\\n  ) {\\n    RebalanceLocal memory v;\\n    _initLocalVars(v, ITetuConverter(converterLiquidator[0]), pairState, liquidityThresholds_);\\n\\n    bool needRebalance;\\n    int24 tick = AlgebraDebtLib.getCurrentTick(IAlgebraPool(pairState.pool));\\n    (needRebalance, v.fuseStatusChangedAB, v.fuseStatusAB) = PairBasedStrategyLogicLib.needStrategyRebalance(\\n      pairState,\\n      v.converter,\\n      tick\\n    );\\n\\n    // update fuse status if necessary\\n    if (needRebalance) {\\n      // we assume here, that needRebalance is true if any fuse has changed state, see needStrategyRebalance impl\\n      PairBasedStrategyLogicLib.updateFuseStatus(pairState, v.fuseStatusChangedAB, v.fuseStatusAB);\\n    }\\n\\n    require(!checkNeedRebalance_ || needRebalance, AlgebraStrategyErrors.NO_REBALANCE_NEEDED);\\n\\n    // rebalancing debt, setting new tick range\\n    if (needRebalance) {\\n      uint coveredByRewards;\\n      AlgebraDebtLib.rebalanceNoSwaps(converterLiquidator, pairState, profitToCover, totalAssets_, splitter, v.liquidationThresholdsAB, tick);\\n\\n      uint loss;\\n      (loss, tokenAmounts) = ConverterStrategyBaseLib2.getTokenAmountsPair(v.converter, totalAssets_, v.tokenA, v.tokenB, v.liquidationThresholdsAB);\\n\\n      if (loss != 0) {\\n        coveredByRewards = _coverLoss(splitter, loss, pairState.strategyProfitHolder, v.tokenA, v.tokenB, address(v.pool));\\n      }\\n      emit Rebalanced(loss, profitToCover, coveredByRewards);\\n    }\\n\\n    return tokenAmounts;\\n  }\\n\\n  /// @notice Try to cover loss from rewards then cover remain loss from insurance.\\n  function _coverLoss(address splitter, uint loss, address profitHolder, address tokenA, address tokenB, address pool) internal returns (\\n    uint coveredByRewards\\n  ) {\\n    if (loss != 0) {\\n      coveredByRewards = AlgebraDebtLib.coverLossFromRewards(loss, profitHolder, tokenA, tokenB, pool);\\n      uint notCovered = loss - coveredByRewards;\\n      if (notCovered != 0) {\\n        ConverterStrategyBaseLib2._coverLossAndCheckResults(splitter, 0, notCovered);\\n      }\\n    }\\n\\n    return coveredByRewards;\\n  }\\n\\n  /// @notice Initialize {v} by state values\\n  function _initLocalVars(\\n    RebalanceLocal memory v,\\n    ITetuConverter converter_,\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\n    mapping(address => uint) storage liquidityThresholds_\\n  ) internal view {\\n    v.pool = IAlgebraPool(pairState.pool);\\n    v.fuseAB = pairState.fuseAB;\\n    v.converter = converter_;\\n    v.tokenA = pairState.tokenA;\\n    v.tokenB = pairState.tokenB;\\n    v.isStablePool = pairState.isStablePool;\\n    v.liquidationThresholdsAB[0] = AppLib._getLiquidationThreshold(liquidityThresholds_[v.tokenA]);\\n    v.liquidationThresholdsAB[1] = AppLib._getLiquidationThreshold(liquidityThresholds_[v.tokenB]);\\n  }\\n\\n  /// @notice Get proportion of not-underlying in the pool, [0...1e18]\\n  ///         prop.underlying : prop.not.underlying = 1e18 - PropNotUnderlying18 : propNotUnderlying18\\n  function getPropNotUnderlying18(PairBasedStrategyLogicLib.PairState storage pairState) view external returns (uint) {\\n    // get pool proportions\\n    IAlgebraPool pool = IAlgebraPool(pairState.pool);\\n    bool depositorSwapTokens = pairState.depositorSwapTokens;\\n    (int24 newLowerTick, int24 newUpperTick) = AlgebraDebtLib._calcNewTickRange(pool, pairState.lowerTick, pairState.upperTick, pairState.tickSpacing);\\n    (uint consumed0, uint consumed1) = AlgebraDebtLib.getEntryDataProportions(pool, newLowerTick, newUpperTick, depositorSwapTokens);\\n\\n    require(consumed0 + consumed1 > 0, AppErrors.ZERO_VALUE);\\n    return consumed1 * 1e18 / (consumed0 + consumed1);\\n  }\\n  //endregion ------------------------------------------------ Rebalance\\n\\n  //region ------------------------------------------------ WithdrawByAgg\\n  /// @param addr_ [tokenToSwap, aggregator, controller, converter, splitter]\\n  /// @param values_ [amountToSwap_, profitToCover, oldTotalAssets, entryToPool]\\n  /// @return completed All debts were closed, leftovers were swapped to proper proportions\\n  /// @return tokenAmountsOut Amounts to be deposited to pool. This array is empty if no deposit allowed/required.\\n  function withdrawByAggStep(\\n    address[5] calldata addr_,\\n    uint[4] calldata values_,\\n    bytes memory swapData,\\n    bytes memory planEntryData,\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\n    mapping(address => uint) storage liquidationThresholds\\n  ) external returns (\\n    bool completed,\\n    uint[] memory tokenAmountsOut\\n  ) {\\n    address splitter = addr_[4];\\n    uint entryToPool = values_[3];\\n    address[2] memory tokens = [pairState.tokenA, pairState.tokenB];\\n    IAlgebraPool pool = IAlgebraPool(pairState.pool);\\n\\n    // Calculate amounts to be deposited to pool, calculate loss, fix profitToCover\\n    uint[] memory tokenAmounts;\\n    uint loss;\\n    (completed, tokenAmounts, loss) = PairBasedStrategyLogicLib.withdrawByAggStep(addr_, values_, swapData, planEntryData, tokens, liquidationThresholds);\\n\\n    // cover loss\\n    if (loss != 0) {\\n      _coverLoss(splitter, loss, pairState.strategyProfitHolder, tokens[0], tokens[1], address(pool));\\n    }\\n\\n    if (entryToPool == PairBasedStrategyLib.ENTRY_TO_POOL_IS_ALLOWED\\n      || (entryToPool == PairBasedStrategyLib.ENTRY_TO_POOL_IS_ALLOWED_IF_COMPLETED && completed)\\n    ) {\\n      // We are going to enter to the pool: update lowerTick and upperTick, initialize tokenAmountsOut\\n      (pairState.lowerTick, pairState.upperTick) = AlgebraDebtLib._calcNewTickRange(pool, pairState.lowerTick, pairState.upperTick, pairState.tickSpacing);\\n      tokenAmountsOut = tokenAmounts;\\n    }\\n\\n    return (completed, tokenAmountsOut); // hide warning\\n  }\\n  //endregion ------------------------------------------------ WithdrawByAgg\\n\\n}\\n\\n\",\"keccak256\":\"0x9df4bb14cce7c46347ae0cd04233745f421e3b3c2e8e6089faa7586fba154c55\",\"license\":\"MIT\"},\"contracts/strategies/algebra/AlgebraDebtLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../ConverterStrategyBaseLib.sol\\\";\\nimport \\\"../ConverterStrategyBaseLib2.sol\\\";\\nimport \\\"./AlgebraLib.sol\\\";\\nimport \\\"./AlgebraStrategyErrors.sol\\\";\\nimport \\\"./AlgebraConverterStrategyLogicLib.sol\\\";\\nimport \\\"../../libs/BorrowLib.sol\\\";\\nimport \\\"../pair/PairBasedStrategyLib.sol\\\";\\nimport \\\"../pair/PairBasedStrategyLogicLib.sol\\\";\\n\\nlibrary AlgebraDebtLib {\\n  using SafeERC20 for IERC20;\\n\\n//region  -------------------------------------------- Constants\\n  uint public constant SELL_GAP = 100;\\n  address internal constant ONEINCH = 0x1111111254EEB25477B68fb85Ed929f73A960582; // 1inch router V5\\n  address internal constant OPENOCEAN = 0x6352a56caadC4F1E25CD6c75970Fa768A3304e64; // OpenOceanExchangeProxy\\n//endregion  -------------------------------------------- Constants\\n\\n//region  -------------------------------------------- Rewards\\n  function coverLossFromRewards(uint loss, address strategyProfitHolder, address tokenA, address tokenB, address pool) external returns (uint covered) {\\n    uint bA = IERC20Metadata(tokenA).balanceOf(strategyProfitHolder);\\n    uint bB = IERC20Metadata(tokenB).balanceOf(strategyProfitHolder);\\n\\n    if (loss <= bA) {\\n      IERC20(tokenA).safeTransferFrom(strategyProfitHolder, address(this), loss);\\n      covered = loss;\\n    } else {\\n      uint needToCoverA = loss;\\n      if (bA > 0) {\\n        IERC20(tokenA).safeTransferFrom(strategyProfitHolder, address(this), bA);\\n        needToCoverA -= bA;\\n      }\\n      if (bB > 0) {\\n        uint needTransferB = AlgebraLib.getPrice(pool, tokenA) * needToCoverA / 10 ** IERC20Metadata(tokenA).decimals();\\n        uint canTransferB = Math.min(needTransferB, bB);\\n        // There is a chance to have needTransferB == canTransferB == 0 if loss = 1\\n        if (canTransferB != 0) {\\n          IERC20(tokenB).safeTransferFrom(strategyProfitHolder, address(this), canTransferB);\\n          needToCoverA -= needToCoverA * canTransferB / needTransferB;\\n        }\\n      }\\n      covered = loss - needToCoverA;\\n    }\\n  }\\n//endregion  -------------------------------------------- Rewards\\n\\n//region  -------------------------------------------- Entry data\\n  /// @notice Calculate proportions of the tokens for entry kind 1\\n  function getEntryDataProportions(\\n    IAlgebraPool pool,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    bool depositorSwapTokens\\n  ) public view returns (uint, uint) {\\n    address token1 = pool.token1();\\n    uint token1Price = AlgebraLib.getPrice(address(pool), token1);\\n\\n    uint token1Decimals = IERC20Metadata(token1).decimals();\\n\\n    uint token0Desired = token1Price;\\n    uint token1Desired = 10 ** token1Decimals;\\n    require(token1Desired != 0, AppErrors.ZERO_VALUE);\\n\\n    // calculate proportions\\n    (uint consumed0, uint consumed1,) = AlgebraLib.addLiquidityPreview(address(pool), lowerTick, upperTick, token0Desired, token1Desired);\\n    return depositorSwapTokens\\n      ? (1e18*consumed1 * token1Price / token1Desired, 1e18*consumed0)\\n      : (1e18*consumed0, 1e18*consumed1 * token1Price / token1Desired);\\n  }\\n\\n  function getEntryData(\\n    IAlgebraPool pool,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    bool depositorSwapTokens\\n  ) public view returns (bytes memory entryData) {\\n    (uint prop0, uint prop1) = getEntryDataProportions(pool, lowerTick, upperTick, depositorSwapTokens);\\n    entryData = abi.encode(1, prop0, prop1);\\n  }\\n//endregion  -------------------------------------------- Entry data\\n\\n//region  -------------------------------------------- Calc tick range\\n  function calcTickRange(IAlgebraPool pool, int24 tickRange, int24 tickSpacing) public view returns (int24 lowerTick, int24 upperTick) {\\n    return PairBasedStrategyLogicLib.calcTickRange(getCurrentTick(pool), tickRange, tickSpacing);\\n  }\\n\\n  function getCurrentTick(IAlgebraPool pool) public view returns(int24 tick) {\\n    (, tick, , , , ,) = pool.globalState();\\n  }\\n\\n  /// @notice Calculate the new tick range for a Algebra pool, the tick is read from the pool.\\n  /// @param pool The Algebra pool to calculate the new tick range for.\\n  /// @param lowerTick The current lower tick value for the pool.\\n  /// @param upperTick The current upper tick value for the pool.\\n  /// @param tickSpacing The tick spacing for the pool.\\n  /// @return lowerTickNew The new lower tick value for the pool.\\n  /// @return upperTickNew The new upper tick value for the pool.\\n  function _calcNewTickRange(\\n    IAlgebraPool pool,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    int24 tickSpacing\\n  ) internal view returns (int24 lowerTickNew, int24 upperTickNew) {\\n    int24 currentTick = getCurrentTick(pool);\\n    return _calcNewTickRangeForTick(currentTick, lowerTick, upperTick, tickSpacing);\\n  }\\n\\n  /// @notice Calculate the new tick range for a Algebra pool, the tick is known.\\n  function _calcNewTickRangeForTick(\\n    int24 currentTick,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    int24 tickSpacing\\n  ) internal pure returns (int24 lowerTickNew, int24 upperTickNew) {\\n    int24 fullTickRange = upperTick - lowerTick;\\n    int24 tickRange = fullTickRange == tickSpacing\\n      ? int24(0)\\n      : fullTickRange / 2;\\n    return PairBasedStrategyLogicLib.calcTickRange(currentTick, tickRange, tickSpacing);\\n  }\\n//endregion  -------------------------------------------- Calc tick range\\n\\n//region  -------------------------------------------- Rebalance\\n  /// @param liquidationThresholdsAB [liquidityThreshold of token A, liquidityThreshold of tokenB]\\n  function rebalanceNoSwaps(\\n    address[2] calldata converterLiquidator,\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\n    uint profitToCover,\\n    uint totalAssets,\\n    address splitter,\\n    uint[2] calldata liquidationThresholdsAB,\\n    int24 tick\\n  ) external {\\n    (int24 newLowerTick, int24 newUpperTick) = _calcNewTickRangeForTick(tick, pairState.lowerTick, pairState.upperTick, pairState.tickSpacing);\\n    (uint prop0, uint prop1) = getEntryDataProportions(IAlgebraPool(pairState.pool), newLowerTick, newUpperTick, pairState.depositorSwapTokens);\\n    PairBasedStrategyLogicLib.rebalanceNoSwaps(\\n      converterLiquidator,\\n      pairState,\\n      profitToCover,\\n      totalAssets,\\n      splitter,\\n  liquidationThresholdsAB,\\n      prop0 * BorrowLib.SUM_PROPORTIONS / (prop0 + prop1)\\n    );\\n    (pairState.lowerTick, pairState.upperTick) = (newLowerTick, newUpperTick);\\n  }\\n//endregion  -------------------------------------------- Rebalance\\n\\n}\",\"keccak256\":\"0x6e2da22de97eb45ee3278e8229c4d75500f7f459cb99cd954b8c24a536e12862\",\"license\":\"MIT\"},\"contracts/strategies/algebra/AlgebraLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../../integrations/algebra/IAlgebraPool.sol\\\";\\nimport \\\"../../integrations/algebra/INonfungiblePositionManager.sol\\\";\\nimport \\\"../../integrations/algebra/IFarmingCenter.sol\\\";\\nimport \\\"../../integrations/algebra/IncentiveKey.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\n\\nlibrary AlgebraLib {\\n  int24 internal constant TICKSPACING = 60;\\n  uint8 internal constant RESOLUTION = 96;\\n  uint internal constant Q96 = 0x1000000000000000000000000;\\n  uint private constant TWO_96 = 2 ** 96;\\n  /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n  uint160 private constant MIN_SQRT_RATIO = 4295128739 + 1;\\n  /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n  uint160 private constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342 - 1;\\n  /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n  int24 internal constant MIN_TICK = - 887272;\\n  /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n  int24 internal constant MAX_TICK = - MIN_TICK;\\n\\n  function tickSpacing() external pure returns (int24) {\\n    return TICKSPACING;\\n  }\\n\\n  function addLiquidityPreview(address pool_, int24 lowerTick_, int24 upperTick_, uint amount0Desired_, uint amount1Desired_) external view returns (uint amount0Consumed, uint amount1Consumed, uint128 liquidityOut) {\\n    IAlgebraPool pool = IAlgebraPool(pool_);\\n    (uint160 sqrtRatioX96, , , , , ,) = pool.globalState();\\n    liquidityOut = getLiquidityForAmounts(sqrtRatioX96, lowerTick_, upperTick_, amount0Desired_, amount1Desired_);\\n    (amount0Consumed, amount1Consumed) = getAmountsForLiquidity(sqrtRatioX96, lowerTick_, upperTick_, liquidityOut);\\n  }\\n\\n  /// @notice Computes the maximum amount of liquidity received for a given amount of token0, token1, the current\\n  /// pool prices and the prices at the tick boundaries\\n  function getLiquidityForAmounts(\\n    uint160 sqrtRatioX96,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    uint amount0,\\n    uint amount1\\n  ) public pure returns (uint128 liquidity) {\\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n\\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\\n      liquidity = _getLiquidityForAmount0(sqrtRatioAX96, sqrtRatioBX96, amount0);\\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n      uint128 liquidity0 = _getLiquidityForAmount0(sqrtRatioX96, sqrtRatioBX96, amount0);\\n      uint128 liquidity1 = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioX96, amount1);\\n      liquidity = liquidity0 < liquidity1 ? liquidity0 : liquidity1;\\n    } else {\\n      liquidity = _getLiquidityForAmount1(sqrtRatioAX96, sqrtRatioBX96, amount1);\\n    }\\n  }\\n\\n  /// @notice Computes the token0 and token1 value for a given amount of liquidity, the current\\n  /// pool prices and the prices at the tick boundaries\\n  function getAmountsForLiquidity(\\n    uint160 sqrtRatioX96,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    uint128 liquidity\\n  ) public pure returns (uint amount0, uint amount1) {\\n    uint160 sqrtRatioAX96 = _getSqrtRatioAtTick(lowerTick);\\n    uint160 sqrtRatioBX96 = _getSqrtRatioAtTick(upperTick);\\n\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n\\n    if (sqrtRatioX96 <= sqrtRatioAX96) {\\n      amount0 = _getAmount0ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n    } else if (sqrtRatioX96 < sqrtRatioBX96) {\\n      amount0 = _getAmount0ForLiquidity(sqrtRatioX96, sqrtRatioBX96, liquidity);\\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioX96, liquidity);\\n    } else {\\n      amount1 = _getAmount1ForLiquidity(sqrtRatioAX96, sqrtRatioBX96, liquidity);\\n    }\\n  }\\n\\n  /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\\n  /// @param a The multiplicand\\n  /// @param b The multiplier\\n  /// @param denominator The divisor\\n  /// @return result The 256-bit result\\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\n  function mulDiv(\\n    uint a,\\n    uint b,\\n    uint denominator\\n  ) public pure returns (uint result) {\\n    unchecked {\\n      // 512-bit multiply [prod1 prod0] = a * b\\n      // Compute the product mod 2**256 and mod 2**256 - 1\\n      // then use the Chinese Remainder Theorem to reconstruct\\n      // the 512 bit result. The result is stored in two 256\\n      // variables such that product = prod1 * 2**256 + prod0\\n      uint prod0;\\n      // Least significant 256 bits of the product\\n      uint prod1;\\n      // Most significant 256 bits of the product\\n      assembly {\\n        let mm := mulmod(a, b, not(0))\\n        prod0 := mul(a, b)\\n        prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n      }\\n\\n      // Handle non-overflow cases, 256 by 256 division\\n      if (prod1 == 0) {\\n        require(denominator > 0);\\n        assembly {\\n          result := div(prod0, denominator)\\n        }\\n        return result;\\n      }\\n\\n      // Make sure the result is less than 2**256.\\n      // Also prevents denominator == 0\\n      require(denominator > prod1);\\n\\n      ///////////////////////////////////////////////\\n      // 512 by 256 division.\\n      ///////////////////////////////////////////////\\n\\n      // Make division exact by subtracting the remainder from [prod1 prod0]\\n      // Compute remainder using mulmod\\n      uint remainder;\\n      assembly {\\n        remainder := mulmod(a, b, denominator)\\n      }\\n      // Subtract 256 bit number from 512 bit number\\n      assembly {\\n        prod1 := sub(prod1, gt(remainder, prod0))\\n        prod0 := sub(prod0, remainder)\\n      }\\n\\n      // Factor powers of two out of denominator\\n      // Compute largest power of two divisor of denominator.\\n      // Always >= 1.\\n      // EDIT for 0.8 compatibility:\\n      // see: https://ethereum.stackexchange.com/questions/96642/unary-operator-cannot-be-applied-to-type-uint\\n      uint twos = denominator & (~denominator + 1);\\n\\n      // Divide denominator by power of two\\n      assembly {\\n        denominator := div(denominator, twos)\\n      }\\n\\n      // Divide [prod1 prod0] by the factors of two\\n      assembly {\\n        prod0 := div(prod0, twos)\\n      }\\n      // Shift in bits from prod1 into prod0. For this we need\\n      // to flip `twos` such that it is 2**256 / twos.\\n      // If twos is zero, then it becomes one\\n      assembly {\\n        twos := add(div(sub(0, twos), twos), 1)\\n      }\\n      prod0 |= prod1 * twos;\\n\\n      // Invert denominator mod 2**256\\n      // Now that denominator is an odd number, it has an inverse\\n      // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\n      // Compute the inverse by starting with a seed that is correct\\n      // correct for four bits. That is, denominator * inv = 1 mod 2**4\\n      uint inv = (3 * denominator) ^ 2;\\n      // Now use Newton-Raphson iteration to improve the precision.\\n      // Thanks to Hensel's lifting lemma, this also works in modular\\n      // arithmetic, doubling the correct bits in each step.\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**8\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**16\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**32\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**64\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**128\\n      inv *= 2 - denominator * inv;\\n      // inverse mod 2**256\\n\\n      // Because the division is now exact we can divide by multiplying\\n      // with the modular inverse of denominator. This will give us the\\n      // correct result modulo 2**256. Since the precoditions guarantee\\n      // that the outcome is less than 2**256, this is the final result.\\n      // We don't need to compute the high bits of the result and prod1\\n      // is no longer required.\\n      result = prod0 * inv;\\n      return result;\\n    }\\n  }\\n\\n  /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint or denominator == 0\\n  /// @param a The multiplicand\\n  /// @param b The multiplier\\n  /// @param denominator The divisor\\n  /// @return result The 256-bit result\\n  function mulDivRoundingUp(\\n    uint a,\\n    uint b,\\n    uint denominator\\n  ) internal pure returns (uint result) {\\n    result = mulDiv(a, b, denominator);\\n    if (mulmod(a, b, denominator) > 0) {\\n      require(result < type(uint).max);\\n      result++;\\n    }\\n  }\\n\\n  /// @notice Calculates price in pool\\n  function getPrice(address pool_, address tokenIn) public view returns (uint) {\\n    IAlgebraPool pool = IAlgebraPool(pool_);\\n    address token0 = pool.token0();\\n    address token1 = pool.token1();\\n\\n    uint tokenInDecimals = tokenIn == token0 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\\n    uint tokenOutDecimals = tokenIn == token1 ? IERC20Metadata(token0).decimals() : IERC20Metadata(token1).decimals();\\n    (uint160 sqrtPriceX96,,,,,,) = pool.globalState();\\n\\n    uint divider = tokenOutDecimals < 18 ? _max(10 ** tokenOutDecimals / 10 ** tokenInDecimals, 1) : 1;\\n\\n    uint priceDigits = _countDigits(uint(sqrtPriceX96));\\n    uint purePrice;\\n    uint precision;\\n    if (tokenIn == token0) {\\n      precision = 10 ** ((priceDigits < 29 ? 29 - priceDigits : 0) + tokenInDecimals);\\n      uint part = uint(sqrtPriceX96) * precision / TWO_96;\\n      purePrice = part * part;\\n    } else {\\n      precision = 10 ** ((priceDigits > 29 ? priceDigits - 29 : 0) + tokenInDecimals);\\n      uint part = TWO_96 * precision / uint(sqrtPriceX96);\\n      purePrice = part * part;\\n    }\\n    return purePrice / divider / precision / (precision > 1e18 ? (precision / 1e18) : 1);\\n  }\\n\\n  function getFees(IAlgebraPool pool, INonfungiblePositionManager nft, uint tokenId) public view returns (uint fee0, uint fee1) {\\n    (, int24 tick, , , , ,) = pool.globalState();\\n    (,,,,int24 lowerTick,int24 upperTick,uint128 liquidity,uint feeGrowthInside0Last, uint feeGrowthInside1Last, uint128 tokensOwed0, uint128 tokensOwed1) = nft.positions(tokenId);\\n    fee0 = _computeFeesEarned(pool, lowerTick, upperTick, liquidity, true, feeGrowthInside0Last, tick) + uint(tokensOwed0);\\n    fee1 = _computeFeesEarned(pool, lowerTick, upperTick, liquidity, false, feeGrowthInside1Last, tick) + uint(tokensOwed1);\\n  }\\n\\n  function _computeFeesEarned(\\n    IAlgebraPool pool,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    uint128 liquidity,\\n    bool isZero,\\n    uint feeGrowthInsideLast,\\n    int24 tick\\n  ) internal view returns (uint fee) {\\n    uint feeGrowthOutsideLower;\\n    uint feeGrowthOutsideUpper;\\n    uint feeGrowthGlobal;\\n    if (isZero) {\\n      feeGrowthGlobal = pool.totalFeeGrowth0Token();\\n      (,, feeGrowthOutsideLower,,,,,) = pool.ticks(lowerTick);\\n      (,, feeGrowthOutsideUpper,,,,,) = pool.ticks(upperTick);\\n    } else {\\n      feeGrowthGlobal = pool.totalFeeGrowth1Token();\\n      (,,, feeGrowthOutsideLower,,,,) = pool.ticks(lowerTick);\\n      (,,, feeGrowthOutsideUpper,,,,) = pool.ticks(upperTick);\\n    }\\n\\n    unchecked {\\n      // calculate fee growth below\\n      uint feeGrowthBelow;\\n      if (tick >= lowerTick) {\\n        feeGrowthBelow = feeGrowthOutsideLower;\\n      } else {\\n        feeGrowthBelow = feeGrowthGlobal - feeGrowthOutsideLower;\\n      }\\n      // calculate fee growth above\\n      uint feeGrowthAbove;\\n      if (tick < upperTick) {\\n        feeGrowthAbove = feeGrowthOutsideUpper;\\n      } else {\\n        feeGrowthAbove = feeGrowthGlobal - feeGrowthOutsideUpper;\\n      }\\n\\n      uint feeGrowthInside = feeGrowthGlobal - feeGrowthBelow - feeGrowthAbove;\\n      fee = mulDiv(\\n        liquidity,\\n        feeGrowthInside - feeGrowthInsideLast,\\n        0x100000000000000000000000000000000\\n      );\\n    }\\n  }\\n\\n  /// @notice Computes the amount of liquidity received for a given amount of token0 and price range\\n  /// @dev Calculates amount0 * (sqrt(upper) * sqrt(lower)) / (sqrt(upper) - sqrt(lower)).\\n  /// @param sqrtRatioAX96 A sqrt price\\n  /// @param sqrtRatioBX96 Another sqrt price\\n  /// @param amount0 The amount0 being sent in\\n  /// @return liquidity The amount of returned liquidity\\n  function _getLiquidityForAmount0(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount0) internal pure returns (uint128 liquidity) {\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n    uint intermediate = mulDiv(sqrtRatioAX96, sqrtRatioBX96, Q96);\\n    return _toUint128(mulDiv(amount0, intermediate, sqrtRatioBX96 - sqrtRatioAX96));\\n  }\\n\\n  /// @notice Computes the amount of liquidity received for a given amount of token1 and price range\\n  /// @dev Calculates amount1 / (sqrt(upper) - sqrt(lower)).\\n  /// @param sqrtRatioAX96 A sqrt price\\n  /// @param sqrtRatioBX96 Another sqrt price\\n  /// @param amount1 The amount1 being sent in\\n  /// @return liquidity The amount of returned liquidity\\n  function _getLiquidityForAmount1(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint amount1) internal pure returns (uint128 liquidity) {\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n    return _toUint128(mulDiv(amount1, Q96, sqrtRatioBX96 - sqrtRatioAX96));\\n  }\\n\\n  /// @notice Computes the amount of token0 for a given amount of liquidity and a price range\\n  /// @param sqrtRatioAX96 A sqrt price\\n  /// @param sqrtRatioBX96 Another sqrt price\\n  /// @param liquidity The liquidity being valued\\n  /// @return amount0 The amount0\\n  function _getAmount0ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount0) {\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n    return mulDivRoundingUp(1, mulDivRoundingUp(uint(liquidity) << RESOLUTION, sqrtRatioBX96 - sqrtRatioAX96, sqrtRatioBX96), sqrtRatioAX96);\\n  }\\n\\n  /// @notice Computes the amount of token1 for a given amount of liquidity and a price range\\n  /// @param sqrtRatioAX96 A sqrt price\\n  /// @param sqrtRatioBX96 Another sqrt price\\n  /// @param liquidity The liquidity being valued\\n  /// @return amount1 The amount1\\n  function _getAmount1ForLiquidity(uint160 sqrtRatioAX96, uint160 sqrtRatioBX96, uint128 liquidity) internal pure returns (uint amount1) {\\n    if (sqrtRatioAX96 > sqrtRatioBX96) {\\n      (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\\n    }\\n    return mulDivRoundingUp(liquidity, sqrtRatioBX96 - sqrtRatioAX96, Q96);\\n  }\\n\\n  function _countDigits(uint n) internal pure returns (uint) {\\n    if (n == 0) {\\n      return 0;\\n    }\\n    uint count = 0;\\n    while (n != 0) {\\n      n = n / 10;\\n      ++count;\\n    }\\n    return count;\\n  }\\n\\n  function _min(uint a, uint b) internal pure returns (uint) {\\n    return a < b ? a : b;\\n  }\\n\\n  function _max(uint a, uint b) internal pure returns (uint) {\\n    return a > b ? a : b;\\n  }\\n\\n  function _toUint128(uint x) private pure returns (uint128 y) {\\n    require((y = uint128(x)) == x);\\n  }\\n\\n  /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n  /// @dev Throws if |tick| > max tick\\n  /// @param tick The input tick for the above formula\\n  /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n  /// at the given tick\\n  function _getSqrtRatioAtTick(int24 tick)\\n  internal\\n  pure\\n  returns (uint160 sqrtPriceX96)\\n  {\\n    uint256 absTick =\\n      tick < 0 ? uint256(- int256(tick)) : uint256(int256(tick));\\n\\n    // EDIT: 0.8 compatibility\\n    require(absTick <= uint256(int256(MAX_TICK)), \\\"T\\\");\\n\\n    uint256 ratio =\\n      absTick & 0x1 != 0\\n        ? 0xfffcb933bd6fad37aa2d162d1a594001\\n        : 0x100000000000000000000000000000000;\\n    if (absTick & 0x2 != 0)\\n      ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n    if (absTick & 0x4 != 0)\\n      ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n    if (absTick & 0x8 != 0)\\n      ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n    if (absTick & 0x10 != 0)\\n      ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n    if (absTick & 0x20 != 0)\\n      ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n    if (absTick & 0x40 != 0)\\n      ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n    if (absTick & 0x80 != 0)\\n      ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n    if (absTick & 0x100 != 0)\\n      ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n    if (absTick & 0x200 != 0)\\n      ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n    if (absTick & 0x400 != 0)\\n      ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n    if (absTick & 0x800 != 0)\\n      ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n    if (absTick & 0x1000 != 0)\\n      ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n    if (absTick & 0x2000 != 0)\\n      ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n    if (absTick & 0x4000 != 0)\\n      ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n    if (absTick & 0x8000 != 0)\\n      ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n    if (absTick & 0x10000 != 0)\\n      ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n    if (absTick & 0x20000 != 0)\\n      ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n    if (absTick & 0x40000 != 0)\\n      ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n    if (absTick & 0x80000 != 0)\\n      ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n    if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n    // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n    // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n    sqrtPriceX96 = uint160(\\n      (ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1)\\n    );\\n  }\\n\\n  /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n  /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n  /// ever return.\\n  /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n  /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n  function _getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n    // second inequality must be < because the price can never reach the price at the max tick\\n    require(\\n      sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO,\\n      \\\"R\\\"\\n    );\\n    uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n    uint256 r = ratio;\\n    uint256 msb = 0;\\n\\n    assembly {\\n      let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(5, gt(r, 0xFFFFFFFF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(4, gt(r, 0xFFFF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(3, gt(r, 0xFF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(2, gt(r, 0xF))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := shl(1, gt(r, 0x3))\\n      msb := or(msb, f)\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      let f := gt(r, 0x1)\\n      msb := or(msb, f)\\n    }\\n\\n    if (msb >= 128) r = ratio >> (msb - 127);\\n    else r = ratio << (127 - msb);\\n\\n    int256 log_2 = (int256(msb) - 128) << 64;\\n\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(63, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(62, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(61, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(60, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(59, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(58, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(57, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(56, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(55, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(54, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(53, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(52, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(51, f))\\n      r := shr(f, r)\\n    }\\n    assembly {\\n      r := shr(127, mul(r, r))\\n      let f := shr(128, r)\\n      log_2 := or(log_2, shl(50, f))\\n    }\\n\\n    tick = _getFinalTick(log_2, sqrtPriceX96);\\n  }\\n\\n  function _getFinalTick(int256 log_2, uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n    // 128.128 number\\n    int256 log_sqrt10001 = log_2 * 255738958999603826347141;\\n\\n    int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n    int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n    tick = (tickLow == tickHi)\\n      ? tickLow\\n      : (_getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow);\\n  }\\n}\",\"keccak256\":\"0x3b9abee12ed91715f61dbb29110c30d8df2d6fd6ab9bea4520b2441e558e73d2\",\"license\":\"MIT\"},\"contracts/strategies/algebra/AlgebraStrategyErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nlibrary AlgebraStrategyErrors {\\n\\n  string public constant NEED_REBALANCE = \\\"AS-1 Need rebalance\\\";\\n  string public constant WRONG_BALANCE = \\\"AS-2 Wrong balance\\\";\\n  string public constant INCORRECT_TICK_RANGE = \\\"AS-3 Incorrect tickRange\\\";\\n  string public constant INCORRECT_REBALANCE_TICK_RANGE = \\\"AS-4 Incorrect rebalanceTickRange\\\";\\n  string public constant INCORRECT_ASSET = \\\"AS-5 Incorrect asset\\\";\\n  string public constant WRONG_FEE = \\\"AS-6 Wrong fee\\\";\\n  string public constant WRONG_LIQUIDITY = \\\"AS-7 Wrong liquidity\\\";\\n  string public constant NO_REBALANCE_NEEDED = \\\"AS-9 No rebalance needed\\\";\\n  string public constant BALANCE_LOWER_THAN_FEE = \\\"AS-10 Balance lower than fee\\\";\\n  string public constant NOT_CALLBACK_CALLER = \\\"AS-11 Not callback caller\\\";\\n  string public constant ZERO_PROFIT_HOLDER = \\\"AS-13 Zero strategy profit holder\\\";\\n  string public constant FUSE_IS_ACTIVE = \\\"AS-14 Fuse is active\\\";\\n}\",\"keccak256\":\"0xf185f93fbd1e1afec51ab220c63b3b01cf2a571f81e8aa96c57cf6b821ea8f68\",\"license\":\"MIT\"},\"contracts/strategies/pair/PairBasedStrategyLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\nimport \\\"../ConverterStrategyBaseLib.sol\\\";\\nimport \\\"../../interfaces/IPoolProportionsProvider.sol\\\";\\nimport \\\"../../libs/BorrowLib.sol\\\";\\n\\n/// @notice Library for the UniV3-like strategies with two tokens in the pool\\n/// @dev The library contains quoteWithdrawStep/withdrawStep-related logic\\nlibrary PairBasedStrategyLib {\\n  //region ------------------------------------------------ Constants\\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\\n  /// @notice In all functions below array {token} contains underlying at the first position\\n  uint internal constant IDX_ASSET = 0;\\n  /// @notice In all functions below array {token} contains not-underlying at the second position\\n  uint internal constant IDX_TOKEN = 1;\\n\\n  uint internal constant IDX_SWAP_1 = 0;\\n  uint internal constant IDX_REPAY_1 = 1;\\n  uint internal constant IDX_SWAP_2 = 2;\\n  uint internal constant IDX_REPAY_2 = 3;\\n\\n  /// @notice A gap to reduce AmountToSwap calculated inside quoteWithdrawByAgg, [0...100_000]\\n  uint public constant GAP_AMOUNT_TO_SWAP = 100;\\n\\n  /// @notice Enter to the pool at the end of withdrawByAggStep\\n  uint public constant ENTRY_TO_POOL_IS_ALLOWED = 1;\\n  /// @notice Enter to the pool at the end of withdrawByAggStep only if full withdrawing has been completed\\n  uint public constant ENTRY_TO_POOL_IS_ALLOWED_IF_COMPLETED = 2;\\n\\n  /// @notice Fuse thresholds are set as array: [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\\n  ///         If the price falls below LOWER_LIMIT_ON the fuse is turned ON\\n  ///         When the prices raises back and reaches LOWER_LIMIT_OFF, the fuse is turned OFF\\n  ///         In the same way, if the price raises above UPPER_LIMIT_ON the fuse is turned ON\\n  ///         When the prices falls back and reaches UPPER_LIMIT_OFF, the fuse is turned OFF\\n  ///\\n  ///         Example: [0.9, 0.92, 1.08, 1.1]\\n  ///         Price falls below 0.9 - fuse is ON. Price rises back up to 0.92 - fuse is OFF.\\n  ///         Price raises more and reaches 1.1 - fuse is ON again. Price falls back and reaches 1.08 - fuse OFF again.\\n  uint public constant FUSE_IDX_LOWER_LIMIT_ON = 0;\\n  uint public constant FUSE_IDX_LOWER_LIMIT_OFF = 1;\\n  uint public constant FUSE_IDX_UPPER_LIMIT_ON = 2;\\n  uint public constant FUSE_IDX_UPPER_LIMIT_OFF = 3;\\n\\n  uint public constant IDX_ADDR_DEFAULT_STATE_TOKEN_A = 0;\\n  uint public constant IDX_ADDR_DEFAULT_STATE_TOKEN_B = 1;\\n  uint public constant IDX_ADDR_DEFAULT_STATE_POOL = 2;\\n  uint public constant IDX_ADDR_DEFAULT_STATE_PROFIT_HOLDER = 3;\\n\\n  uint public constant IDX_TICK_DEFAULT_STATE_TICK_SPACING = 0;\\n  uint public constant IDX_TICK_DEFAULT_STATE_LOWER_TICK = 1;\\n  uint public constant IDX_TICK_DEFAULT_STATE_UPPER_TICK = 2;\\n  uint public constant IDX_TICK_DEFAULT_STATE_REBALANCE_TICK_RANGE = 3;\\n\\n  uint public constant IDX_NUMS_DEFAULT_STATE_TOTAL_LIQUIDITY = 0;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_FUSE_STATUS_A = 1;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_FUSE_STATUS_B = 2;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_WITHDRAW_DONE = 3;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_A_0 = 4;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_A_1 = 5;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_A_2 = 6;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_A_3 = 7;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_B_0 = 8;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_B_1 = 9;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_B_2 = 10;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_THRESHOLD_B_3 = 11;\\n  uint public constant IDX_NUMS_DEFAULT_STATE_LAST_REBALANCE_NO_SWAP = 12;\\n\\n  uint public constant IDX_BOOL_VALUES_DEFAULT_STATE_IS_STABLE_POOL = 0;\\n  uint public constant IDX_BOOL_VALUES_DEFAULT_STATE_DEPOSITOR_SWAP_TOKENS = 1;\\n\\n  /// @notice 1inch router V5\\n  address internal constant ONEINCH = 0x1111111254EEB25477B68fb85Ed929f73A960582;\\n  /// @notice OpenOceanExchangeProxy\\n  address internal constant OPENOCEAN = 0x6352a56caadC4F1E25CD6c75970Fa768A3304e64;\\n\\n  string public constant UNKNOWN_SWAP_ROUTER = \\\"PBS-1 Unknown router\\\";\\n  string public constant INCORRECT_TICK_RANGE = \\\"PBS-3 Incorrect tickRange\\\";\\n  string public constant INCORRECT_REBALANCE_TICK_RANGE = \\\"PBS-4 Incorrect rebalanceTickRange\\\";\\n  string public constant INCORRECT_ASSET = \\\"PBS-5 Incorrect asset\\\";\\n\\n  //endregion ------------------------------------------------ Constants\\n\\n  //region ------------------------------------------------ Data types\\n  /// @notice The fuse is triggered when the price rises above or falls below the limit 1.\\n  ///         If the fuse was triggered, all assets are withdrawn from the pool on the strategy balance.\\n  ///         Then all debts should be closed and all assets should be converted to underlying.\\n  ///         The fuse is turned off automatically when the price falls below or rises above the limit 2\\n  ///         and all assets are deposited back to the pool.\\n  enum FuseStatus {\\n    /// @notice Fuse is not used at all\\n    FUSE_DISABLED_0,\\n    /// @notice Fuse is not triggered, assets are deposited to the pool\\n    FUSE_OFF_1,\\n    /// @notice Fuse was triggered by lower limit, assets was withdrawn from the pool, but active debts can exist\\n    FUSE_ON_LOWER_LIMIT_2,\\n    /// @notice Fuse was triggered by upper limit, assets was withdrawn from the pool, but active debts can exist\\n    FUSE_ON_UPPER_LIMIT_3\\n  }\\n\\n  struct SwapByAggParams {\\n    bool useLiquidator;\\n    address tokenToSwap;\\n    /// @notice Aggregator to make swap\\n    ///         It is 0 if useLiquidator is true\\n    ///         It can be equal to address of liquidator if we use liquidator as aggregator (in tests)\\n    address aggregator;\\n    uint amountToSwap;\\n    /// @notice Swap-data prepared off-chain (route, amounts, etc). 0 - use liquidator to make swap\\n    bytes swapData;\\n  }\\n\\n  struct GetAmountToRepay2Local {\\n    uint x;\\n    uint y;\\n    uint c0;\\n    uint b0;\\n    uint alpha;\\n    int b;\\n  }\\n\\n  struct FuseStateParams {\\n    FuseStatus status;\\n    /// @notice Price thresholds [LOWER_LIMIT_ON, LOWER_LIMIT_OFF, UPPER_LIMIT_ON, UPPER_LIMIT_OFF]\\n    /// @dev see PairBasedStrategyLib.FUSE_IDX_XXX\\n    uint[4] thresholds;\\n  }\\n  //endregion ------------------------------------------------ Data types\\n\\n  //region ------------------------------------------------ Events\\n  event FuseStatusChanged(uint fuseStatus);\\n  event NewFuseThresholds(uint[4] newFuseThresholds);\\n  //endregion ------------------------------------------------ Events\\n\\n  //region ------------------------------------------------ External withdraw functions\\n\\n  /// @notice Get info for the swap that will be made on the next call of {withdrawStep}\\n  /// @param converterLiquidator_ [TetuConverter, TetuLiquidator]\\n  /// @param tokens Tokens used by depositor (length == 2: underlying and not-underlying)\\n  /// @param liquidationThresholds Liquidation thresholds for the {tokens}\\n  /// @param propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\n  ///                            The leftovers should be swapped to get following result proportions of the assets:\\n  ///                            not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\n  ///                            Value type(uint).max means that the proportions should be read from the pool.\\n  /// @param amountsFromPool Amounts of {tokens} that will be received from the pool before calling withdraw\\n  /// @return tokenToSwap Address of the token that will be swapped on the next swap. 0 - no swap\\n  /// @return amountToSwap Amount that will be swapped on the next swap. 0 - no swap\\n  ///                      This amount is NOT reduced on {GAP_AMOUNT_TO_SWAP}, it should be reduced after the call if necessary.\\n  function quoteWithdrawStep(\\n    address[2] memory converterLiquidator_,\\n    address[] memory tokens,\\n    uint[] memory liquidationThresholds,\\n    uint[] memory amountsFromPool,\\n    uint planKind,\\n    uint propNotUnderlying18\\n  ) external returns (\\n    address tokenToSwap,\\n    uint amountToSwap\\n  ){\\n    (uint[] memory prices,\\n     uint[] memory decs\\n    ) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(ITetuConverter(converterLiquidator_[0])), tokens, 2);\\n    IterationPlanLib.SwapRepayPlanParams memory p = IterationPlanLib.SwapRepayPlanParams({\\n      converter: ITetuConverter(converterLiquidator_[0]),\\n      liquidator: ITetuLiquidator(converterLiquidator_[1]),\\n      tokens: tokens,\\n      liquidationThresholds: liquidationThresholds,\\n      propNotUnderlying18: propNotUnderlying18 == type(uint).max\\n        ? IPoolProportionsProvider(address(this)).getPropNotUnderlying18()\\n        : propNotUnderlying18,\\n      prices: prices,\\n      decs: decs,\\n      balanceAdditions: amountsFromPool,\\n      planKind: planKind,\\n      usePoolProportions: propNotUnderlying18 == type(uint).max\\n    });\\n    return _quoteWithdrawStep(p);\\n  }\\n\\n  /// @notice Make withdraw step with 0 or 1 swap only. The step can make one of the following actions:\\n  ///         1) repay direct debt 2) repay reverse debt 3) final swap leftovers of not-underlying asset\\n  /// @param converterLiquidator_ [TetuConverter, TetuLiquidator]\\n  /// @param tokens Tokens used by depositor (length == 2: underlying and not-underlying)\\n  /// @param liquidationThresholds Liquidation thresholds for the {tokens}\\n  /// @param tokenToSwap_ Address of the token that will be swapped on the next swap. 0 - no swap\\n  /// @param amountToSwap_ Amount that will be swapped on the next swap. 0 - no swap\\n  /// @param aggregator_ Aggregator that should be used for the next swap. 0 - no swap\\n  /// @param swapData_ Swap data to be passed to the aggregator on the next swap.\\n  ///                  Swap data contains swap-route, amount and all other required info for the swap.\\n  ///                  Swap data should be prepared on-chain on the base of data received by {quoteWithdrawStep}\\n  /// @param useLiquidator_ Use liquidator instead of aggregator.\\n  ///                       Aggregator swaps amount reduced on {GAP_AMOUNT_TO_SWAP}.\\n  ///                       Liquidator doesn't use {GAP_AMOUNT_TO_SWAP}.\\n  ///                       It's allowed to pass liquidator address in {aggregator_} and set {useLiquidator_} to false -\\n  ///                       the liquidator will be used in same way as aggregator in this case.\\n  /// @param planKind One of IterationPlanLib.PLAN_XXX\\n  /// @param propNotUnderlying18 Required proportion of not-underlying for the final swap of leftovers, [0...1e18].\\n  ///                           The leftovers should be swapped to get following result proportions of the assets:\\n  ///                           not-underlying : underlying === propNotUnderlying18 : 1e18 - propNotUnderlying18\\n  /// @return completed All debts were closed, leftovers were swapped to the required proportions\\n  function withdrawStep(\\n    address[2] memory converterLiquidator_,\\n    address[] memory tokens,\\n    uint[] memory liquidationThresholds,\\n    address tokenToSwap_,\\n    uint amountToSwap_,\\n    address aggregator_,\\n    bytes memory swapData_,\\n    bool useLiquidator_,\\n    uint planKind,\\n    uint propNotUnderlying18\\n  ) external returns (\\n    bool completed\\n  ){\\n    (uint[] memory prices,\\n     uint[] memory decs\\n    ) = AppLib._getPricesAndDecs(AppLib._getPriceOracle(ITetuConverter(converterLiquidator_[0])), tokens, 2);\\n\\n    IterationPlanLib.SwapRepayPlanParams memory p = IterationPlanLib.SwapRepayPlanParams({\\n      converter: ITetuConverter(converterLiquidator_[0]),\\n      liquidator: ITetuLiquidator(converterLiquidator_[1]),\\n      tokens: tokens,\\n      liquidationThresholds: liquidationThresholds,\\n      propNotUnderlying18: propNotUnderlying18 == type(uint).max\\n        ? IPoolProportionsProvider(address(this)).getPropNotUnderlying18()\\n        : propNotUnderlying18,\\n      prices: prices,\\n      decs: decs,\\n      balanceAdditions: new uint[](2), // 2 = tokens.length\\n      planKind: planKind,\\n      usePoolProportions: propNotUnderlying18 == type(uint).max\\n    });\\n    SwapByAggParams memory aggParams = SwapByAggParams({\\n      tokenToSwap: tokenToSwap_,\\n      amountToSwap: amountToSwap_,\\n      useLiquidator: useLiquidator_,\\n      aggregator: aggregator_,\\n      swapData: swapData_\\n    });\\n    return _withdrawStep(p, aggParams);\\n  }\\n  //endregion ------------------------------------------------ External withdraw functions\\n\\n  //region ------------------------------------------------ Fuse functions\\n  function setFuseStatus(FuseStateParams storage fuse, FuseStatus status) external {\\n    fuse.status = status;\\n    emit FuseStatusChanged(uint(status));\\n  }\\n\\n  function setFuseThresholds(FuseStateParams storage state, uint[4] memory values) external {\\n    require(\\n      (values[FUSE_IDX_LOWER_LIMIT_ON] == 0 && values[FUSE_IDX_LOWER_LIMIT_OFF] == 0)\\n      || (values[FUSE_IDX_LOWER_LIMIT_ON] <= values[FUSE_IDX_LOWER_LIMIT_OFF]),\\n      AppErrors.INVALID_VALUE\\n    );\\n    require(\\n      (values[FUSE_IDX_UPPER_LIMIT_ON] == 0 && values[FUSE_IDX_UPPER_LIMIT_OFF] == 0)\\n      || (values[FUSE_IDX_UPPER_LIMIT_ON] >= values[FUSE_IDX_UPPER_LIMIT_OFF]),\\n      AppErrors.INVALID_VALUE\\n    );\\n    if (values[FUSE_IDX_LOWER_LIMIT_ON] != 0 && values[FUSE_IDX_UPPER_LIMIT_ON] != 0) {\\n      require(\\n        values[FUSE_IDX_UPPER_LIMIT_ON] > values[FUSE_IDX_LOWER_LIMIT_ON],\\n        AppErrors.INVALID_VALUE\\n      );\\n    }\\n    state.thresholds = values;\\n    emit NewFuseThresholds(values);\\n  }\\n\\n  function isFuseTriggeredOn(PairBasedStrategyLib.FuseStatus fuseStatus) internal pure returns (bool) {\\n    return uint(fuseStatus) > uint(PairBasedStrategyLib.FuseStatus.FUSE_OFF_1);\\n  }\\n\\n  /// @notice Check if the fuse should be turned ON/OFF\\n  /// @param price Current price\\n  /// @return needToChange A boolean indicating if the fuse status should be changed\\n  /// @return status Exist fuse status or new fuse status (if needToChange is true)\\n  function needChangeFuseStatus(FuseStateParams memory fuse, uint price) internal pure returns (\\n    bool needToChange,\\n    FuseStatus status\\n  ) {\\n    if (fuse.status != FuseStatus.FUSE_DISABLED_0) {\\n      if (fuse.status == FuseStatus.FUSE_OFF_1) {\\n        // currently fuse is OFF\\n        if (price <= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_ON]) {\\n          needToChange = true;\\n          status = FuseStatus.FUSE_ON_LOWER_LIMIT_2;\\n        } else if (price >= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_ON]) {\\n          needToChange = true;\\n          status = FuseStatus.FUSE_ON_UPPER_LIMIT_3;\\n        }\\n      } else {\\n        if (fuse.status == FuseStatus.FUSE_ON_LOWER_LIMIT_2) {\\n          // currently fuse is triggered ON by lower limit\\n          if (price >= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_OFF]) {\\n            needToChange = true;\\n            if (price >= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_ON]) {\\n              status = FuseStatus.FUSE_ON_UPPER_LIMIT_3;\\n            } else {\\n              status = FuseStatus.FUSE_OFF_1;\\n            }\\n          }\\n        } else {\\n          // currently fuse is triggered ON by upper limit\\n          if (price <= fuse.thresholds[FUSE_IDX_UPPER_LIMIT_OFF]) {\\n            needToChange = true;\\n            if (price <= fuse.thresholds[FUSE_IDX_LOWER_LIMIT_OFF]) {\\n              status = FuseStatus.FUSE_ON_LOWER_LIMIT_2;\\n            } else {\\n              status = FuseStatus.FUSE_OFF_1;\\n            }\\n          }\\n        }\\n      }\\n    }\\n\\n    return (needToChange, needToChange ? status : fuse.status);\\n  }\\n  //endregion ------------------------------------------------ Fuse functions\\n\\n  //region ------------------------------------------------ Internal helper functions\\n  /// @notice Quote amount of the next swap if any.\\n  ///         Swaps are required if direct-borrow exists OR reverse-borrow exists or not underlying leftovers exist\\n  ///         Function returns info for first swap only.\\n  /// @return tokenToSwap What token should be swapped. Zero address if no swap is required\\n  /// @return amountToSwap Amount to swap. Zero if no swap is required.\\n  function _quoteWithdrawStep(IterationPlanLib.SwapRepayPlanParams memory p) internal returns (\\n    address tokenToSwap,\\n    uint amountToSwap\\n  ) {\\n    uint indexTokenToSwapPlus1;\\n    (indexTokenToSwapPlus1, amountToSwap,) = IterationPlanLib.buildIterationPlan(\\n      [address(p.converter), address(p.liquidator)],\\n      p.tokens,\\n      p.liquidationThresholds,\\n      p.prices,\\n      p.decs,\\n      p.balanceAdditions,\\n      [\\n        p.usePoolProportions ? 1 : 0,\\n        p.planKind,\\n        p.propNotUnderlying18,\\n        type(uint).max,\\n        IDX_ASSET,\\n        IDX_TOKEN\\n      ]\\n    );\\n    if (indexTokenToSwapPlus1 != 0) {\\n      tokenToSwap = p.tokens[indexTokenToSwapPlus1 - 1];\\n    }\\n    return (tokenToSwap, amountToSwap);\\n  }\\n\\n  /// @notice Make one iteration of withdraw. Each iteration can make 0 or 1 swap only\\n  ///         We can make only 1 of the following 3 operations per single call:\\n  ///         1) repay direct debt 2) repay reverse debt 3) swap leftovers to underlying\\n  function _withdrawStep(IterationPlanLib.SwapRepayPlanParams memory p, SwapByAggParams memory aggParams) internal returns (\\n    bool completed\\n  ) {\\n    (uint idxToSwap1, uint amountToSwap, uint idxToRepay1) = IterationPlanLib.buildIterationPlan(\\n      [address(p.converter), address(p.liquidator)],\\n      p.tokens,\\n      p.liquidationThresholds,\\n      p.prices,\\n      p.decs,\\n      p.balanceAdditions,\\n      [\\n        p.usePoolProportions ? 1 : 0,\\n        p.planKind,\\n        p.propNotUnderlying18,\\n        type(uint).max,\\n        IDX_ASSET,\\n        IDX_TOKEN\\n      ]\\n    );\\n\\n    bool[4] memory actions = [\\n      p.planKind == IterationPlanLib.PLAN_SWAP_ONLY || p.planKind == IterationPlanLib.PLAN_SWAP_REPAY, // swap 1\\n      p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY || p.planKind == IterationPlanLib.PLAN_SWAP_REPAY, // repay 1\\n      p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY, // swap 2\\n      p.planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY // repay 2\\n    ];\\n\\n    if (idxToSwap1 != 0 && actions[IDX_SWAP_1]) {\\n      (, p.propNotUnderlying18) = _swap(p, aggParams, idxToSwap1 - 1, idxToSwap1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, amountToSwap);\\n    }\\n\\n    if (idxToRepay1 != 0 && actions[IDX_REPAY_1]) {\\n      ConverterStrategyBaseLib._repayDebt(\\n        p.converter,\\n        p.tokens[idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET],\\n        p.tokens[idxToRepay1 - 1],\\n        IERC20(p.tokens[idxToRepay1 - 1]).balanceOf(address(this))\\n      );\\n    }\\n\\n    if (idxToSwap1 != 0) {\\n      if (actions[IDX_SWAP_2]) {\\n        (, p.propNotUnderlying18) = _swap(p, aggParams, idxToSwap1 - 1, idxToSwap1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, amountToSwap);\\n\\n        if (actions[IDX_REPAY_2] && idxToRepay1 != 0) {\\n          // see calculations inside estimateSwapAmountForRepaySwapRepay\\n          // There are two possibilities here:\\n          // 1) All collateral asset available on balance was swapped. We need additional repay to get assets in right proportions\\n          // 2) Only part of collateral asset was swapped, so assets are already in right proportions. Repay 2 is not needed\\n          (uint amountToRepay2, bool borrowInsteadRepay) = _getAmountToRepay2(\\n            p,\\n            idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET,\\n            idxToRepay1 - 1\\n          );\\n\\n          if (borrowInsteadRepay) {\\n            borrowToProportions(p, idxToRepay1 - 1, idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, true);\\n\\n          } else if (amountToRepay2 > p.liquidationThresholds[idxToRepay1 - 1]) {\\n            _secondRepay(p, idxToRepay1 - 1 == IDX_ASSET ? IDX_TOKEN : IDX_ASSET, idxToRepay1 - 1, amountToRepay2, type(uint).max);\\n          }\\n        }\\n      } else {\\n        // leftovers were swapped, there are no debts anymore\\n        // the swap can change pool proportions, so probably it's necessary to make additional borrow here\\n        if (\\n          idxToRepay1 == 0 // there are no debts anymore\\n          && p.usePoolProportions  // we use proportions from the pool\\n          && p.propNotUnderlying18 != 0 && p.propNotUnderlying18 != 1e18 // BorrowLib doesn't allow prop=0\\n        ) {\\n          _fixLeftoversProportions(p);\\n        }\\n      }\\n    }\\n\\n    // Withdraw is completed on last iteration (no debts, swapping leftovers)\\n    return idxToRepay1 == 0;\\n  }\\n\\n  /// @notice Make final repay in the scheme REPAY-SWAP-REPAY\\n  ///         Depending on condition the final repay can be made several times or additional borrow can be made\\n  /// @param amountToRepay Amount of {indexBorrow} asset that should be repaid\\n  /// @param needToRepayPrev Amount-to-repay on previous call of the {_secondRepay}\\n  ///                        This amount should decrease on each step of recursion.\\n  ///                        if it doesn't decrease repay is not successfull and it's useless to continue to call repays\\n  ///                        It can happen if liquidationThreshold has incorrect value (i.t. it's too low or zero)\\n  function _secondRepay(\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\n    uint indexCollateral,\\n    uint indexBorrow,\\n    uint amountToRepay,\\n    uint needToRepayPrev\\n  ) internal {\\n    // we need to know repaidAmount\\n    // we cannot relay on the value returned by _repayDebt because of SCB-710, we need to check balances\\n    uint balanceBefore = IERC20(p.tokens[indexBorrow]).balanceOf(address(this));\\n    ConverterStrategyBaseLib._repayDebt(p.converter, p.tokens[indexCollateral], p.tokens[indexBorrow], amountToRepay);\\n    uint balanceAfter = IERC20(p.tokens[indexBorrow]).balanceOf(address(this));\\n\\n    uint repaidAmount = balanceBefore > balanceAfter\\n      ? balanceBefore - balanceAfter\\n      : 0;\\n\\n    if (repaidAmount < amountToRepay && amountToRepay - repaidAmount > p.liquidationThresholds[indexBorrow]) {\\n      // repaidAmount is less than expected\\n      // we need to make additional borrow OR probably make one more repay\\n      // repaidAmount can be less amountToRepay2 even if there is still opened debt, see SCB-777\\n      (uint needToRepay,) = p.converter.getDebtAmountStored(address(this), p.tokens[indexCollateral], p.tokens[indexBorrow], true);\\n      if (\\n        needToRepay > p.liquidationThresholds[indexBorrow]\\n        && needToRepay < needToRepayPrev // amount of debt was reduced on prev iteration of recursion\\n      ) {\\n        // more repays are required\\n        _secondRepay(p, indexCollateral, indexBorrow, amountToRepay - repaidAmount, needToRepay);\\n      } else {\\n        borrowToProportions(p, indexBorrow, indexCollateral, false);\\n      }\\n    }\\n  }\\n\\n  /// @notice Set balances to right proportions using borrow\\n  ///         (it can be necessary if propNotUnderlying18 was changed after swap)\\n  function _fixLeftoversProportions(IterationPlanLib.SwapRepayPlanParams memory p) internal {\\n    uint balanceAsset = IERC20(p.tokens[IDX_ASSET]).balanceOf(address(this));\\n    uint balanceToken = IERC20(p.tokens[IDX_TOKEN]).balanceOf(address(this));\\n    (uint targetAssets,\\n      uint targetTokens\\n    ) = IterationPlanLib._getTargetAmounts(p.prices, p.decs, balanceAsset, balanceToken, p.propNotUnderlying18, IDX_ASSET, IDX_TOKEN);\\n\\n    if (balanceAsset > targetAssets) {\\n      if (balanceAsset - targetAssets > p.liquidationThresholds[IDX_ASSET]) {\\n        _borrowToProportions(p, IDX_ASSET, IDX_TOKEN, balanceAsset, balanceToken, true);\\n      }\\n    } else if (balanceToken > targetTokens) {\\n      if (balanceToken - targetTokens > p.liquidationThresholds[IDX_ASSET]) {\\n        _borrowToProportions(p, IDX_TOKEN, IDX_ASSET, balanceToken, balanceAsset, true);\\n      }\\n    }\\n  }\\n\\n  /// @notice borrow borrow-asset under collateral-asset, result balances should match to propNotUnderlying18\\n  function borrowToProportions(\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\n    uint indexCollateral,\\n    uint indexBorrow,\\n    bool checkOppositDebtDoesntExist\\n  ) internal {\\n    _borrowToProportions(\\n      p,\\n      indexCollateral,\\n      indexBorrow,\\n      IERC20(p.tokens[indexCollateral]).balanceOf(address(this)),\\n      IERC20(p.tokens[indexBorrow]).balanceOf(address(this)),\\n      checkOppositDebtDoesntExist\\n    );\\n  }\\n\\n  /// @notice borrow borrow-asset under collateral-asset, result balances should match to propNotUnderlying18\\n  function _borrowToProportions(\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\n    uint indexCollateral,\\n    uint indexBorrow,\\n    uint balanceCollateral,\\n    uint balanceBorrow,\\n    bool checkOppositDebtDoesntExist\\n  ) internal {\\n    // we are going to change direction of the borrow\\n    // let's ensure that there is no debt in opposite direction\\n    if (checkOppositDebtDoesntExist) {\\n      (uint needToRepay,) = p.converter.getDebtAmountStored(address(this), p.tokens[indexBorrow],  p.tokens[indexCollateral], false);\\n      require(needToRepay < AppLib.DUST_AMOUNT_TOKENS, AppErrors.OPPOSITE_DEBT_EXISTS);\\n    }\\n\\n    BorrowLib.RebalanceAssetsCore memory cac = BorrowLib.RebalanceAssetsCore({\\n      converterLiquidator: BorrowLib.ConverterLiquidator(p.converter, p.liquidator),\\n      assetA: p.tokens[indexCollateral],\\n      assetB: p.tokens[indexBorrow],\\n      propA: indexCollateral == IDX_ASSET ? 1e18 - p.propNotUnderlying18 : p.propNotUnderlying18,\\n      propB: indexCollateral == IDX_ASSET ? p.propNotUnderlying18 : 1e18 - p.propNotUnderlying18,\\n      // {assetA} to {assetB} ratio; {amountB} * {alpha} => {amountA}, decimals 18\\n      alpha18: 1e18 * p.prices[indexBorrow] * p.decs[indexCollateral] / p.prices[indexCollateral] / p.decs[indexBorrow],\\n      thresholdA: p.liquidationThresholds[indexCollateral],\\n      addonA: 0,\\n      addonB: 0,\\n      indexA: indexCollateral,\\n      indexB: indexBorrow\\n    });\\n\\n    BorrowLib.openPosition(\\n      cac,\\n      BorrowLib.PricesDecs({\\n        prices: p.prices,\\n        decs: p.decs\\n      }),\\n      balanceCollateral,\\n      balanceBorrow\\n    );\\n  }\\n\\n  /// @notice Calculate amount that should be repaid to get right proportions of assets on balance\\n  ///         Analyse only single borrow-direction: indexCollateral => indexBorrow\\n  /// @return amountToRepay Amount that should be repaid\\n  /// @return borrowInsteadRepay true if repay is not necessary at all and borrow is required instead\\n  ///                            if we need both repay and borrow then false is returned\\n  function _getAmountToRepay2(\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\n    uint indexCollateral,\\n    uint indexBorrow\\n  ) internal view returns (\\n    uint amountToRepay,\\n    bool borrowInsteadRepay\\n  ) {\\n    GetAmountToRepay2Local memory v;\\n    v.c0 = IERC20(p.tokens[indexCollateral]).balanceOf(address(this)) * p.prices[indexCollateral] / p.decs[indexCollateral];\\n    v.b0 = IERC20(p.tokens[indexBorrow]).balanceOf(address(this)) * p.prices[indexBorrow] / p.decs[indexBorrow];\\n\\n    v.x = indexCollateral == IDX_ASSET ? 1e18 - p.propNotUnderlying18 : p.propNotUnderlying18;\\n    v.y = indexCollateral == IDX_ASSET ? p.propNotUnderlying18 : 1e18 - p.propNotUnderlying18;\\n    v.alpha = p.prices[indexCollateral] * p.decs[indexBorrow] * 1e18 / p.prices[indexBorrow] / p.decs[indexCollateral];\\n\\n    (uint needToRepay, uint collateralAmountOut) = p.converter.getDebtAmountStored(\\n      address(this),\\n      p.tokens[indexCollateral],\\n      p.tokens[indexBorrow],\\n      true\\n    );\\n\\n    if (needToRepay == 0) {\\n      // check if we need to make reverse borrow to fit to proportions: borrow collateral-asset under borrow-asset\\n      uint targetCollateral = (v.c0 + v.b0) * v.x / (v.x + v.y);\\n      borrowInsteadRepay = targetCollateral > v.c0\\n        && targetCollateral - v.c0\\n        > (p.liquidationThresholds[indexCollateral] * p.prices[indexCollateral] / p.decs[indexCollateral]);\\n    } else {\\n      // initial balances: c0, b0\\n      // we are going to repay amount b and receive (betta * b, b), where betta ~ alpha * totalCollateral / totalBorrow\\n      // we should have x/y = (c0 + betta * b) / (b0 - b)\\n      // so b = (x * b0 - y * c0) / (betta * y + x)\\n      v.b = (int(v.x * v.b0) - int(v.y * v.c0)) / (int(v.y * v.alpha * collateralAmountOut / needToRepay / 1e18) + int(v.x));\\n      if (v.b > 0) {\\n        amountToRepay = uint(v.b);\\n      }\\n    }\\n\\n    return (amountToRepay * p.decs[indexBorrow] / p.prices[indexBorrow], borrowInsteadRepay);\\n  }\\n\\n  /// @notice Swap {aggParams.amountToSwap} using either liquidator or aggregator\\n  /// @dev You can use liquidator as aggregator, so aggregator's logic will be used for the liquidator\\n  /// @param amountIn Calculated amount to be swapped. It can be different from {aggParams.amountToSwap} a bit,\\n  ///                 but aggregators require exact value {aggParams.amountToSwap}, so amountIn is not used with agg.\\n  function _swap(\\n    IterationPlanLib.SwapRepayPlanParams memory p,\\n    SwapByAggParams memory aggParams,\\n    uint indexIn,\\n    uint indexOut,\\n    uint amountIn\\n  ) internal returns (\\n    uint spentAmountIn,\\n    uint updatedPropNotUnderlying18\\n  ) {\\n    // liquidator and aggregator have different logic here:\\n    // - liquidator uses amountIn to swap\\n    // - Aggregator uses amountToSwap for which a route was built off-chain before the call of the swap()\\n    // It's allowed to use aggregator == liquidator, so in this way liquidator will use aggregator's logic (for tests)\\n\\n    if (!aggParams.useLiquidator) {\\n      // aggregator requires exact input amount - aggParams.amountToSwap\\n      // actual amount can be a bit different because the quote function was called in different block\\n      amountIn = aggParams.amountToSwap;\\n    }\\n    address aggregator = aggParams.useLiquidator\\n      ? address(p.liquidator)\\n      : aggParams.aggregator;\\n\\n    require(amountIn <= IERC20(p.tokens[indexIn]).balanceOf(address(this)), AppErrors.NOT_ENOUGH_BALANCE);\\n    // let's ensure that \\\"next swap\\\" is made using correct token\\n    require(aggParams.tokenToSwap == p.tokens[indexIn], AppErrors.INCORRECT_SWAP_BY_AGG_PARAM);\\n\\n    if (amountIn > p.liquidationThresholds[indexIn]) {\\n      AppLib.approveIfNeeded(p.tokens[indexIn], amountIn, aggregator);\\n\\n      uint balanceTokenOutBefore = AppLib.balance(p.tokens[indexOut]);\\n\\n      if (aggParams.useLiquidator) {\\n        (spentAmountIn,) = ConverterStrategyBaseLib._liquidate(\\n          p.converter,\\n          ITetuLiquidator(aggregator),\\n          p.tokens[indexIn],\\n          p.tokens[indexOut],\\n          amountIn,\\n          _ASSET_LIQUIDATION_SLIPPAGE,\\n          p.liquidationThresholds[indexIn],\\n          true\\n        );\\n      } else {\\n        if (aggregator != address(p.liquidator)) {\\n          _checkSwapRouter(aggregator);\\n        }\\n\\n        (bool success, bytes memory result) = aggregator.call(aggParams.swapData);\\n        require(success, string(result));\\n\\n        spentAmountIn = amountIn;\\n      }\\n\\n      require(\\n        p.converter.isConversionValid(\\n          p.tokens[indexIn],\\n          amountIn,\\n          p.tokens[indexOut],\\n          AppLib.balance(p.tokens[indexOut]) - balanceTokenOutBefore,\\n          _ASSET_LIQUIDATION_SLIPPAGE\\n        ), AppErrors.PRICE_IMPACT);\\n    }\\n\\n    return (\\n      spentAmountIn,\\n    // p.propNotUnderlying18 contains original proportions that were valid before the swap\\n    // after swap() we need to re-read new values from the pool\\n      p.usePoolProportions\\n        ? IPoolProportionsProvider(address(this)).getPropNotUnderlying18()\\n      : p.propNotUnderlying18\\n    );\\n  }\\n  //endregion ------------------------------------------------ Internal helper functions\\n\\n  //region ----------------------------------------- Utils\\n  function _checkSwapRouter(address router) internal pure {\\n    require(router == ONEINCH || router == OPENOCEAN, UNKNOWN_SWAP_ROUTER);\\n  }\\n\\n  /// @notice Extract propNotUnderlying18 from {planEntryData} of the given {planKind}\\n  function _extractProp(uint planKind, bytes memory planEntryData) internal pure returns(uint propNotUnderlying18) {\\n    require(planKind == IterationPlanLib.PLAN_SWAP_REPAY\\n    || planKind == IterationPlanLib.PLAN_REPAY_SWAP_REPAY\\n    || planKind == IterationPlanLib.PLAN_SWAP_ONLY,\\n      AppErrors.WRONG_VALUE\\n    );\\n    (, propNotUnderlying18) = abi.decode(planEntryData, (uint, uint));\\n    require(propNotUnderlying18 <= 1e18 || propNotUnderlying18 == type(uint).max, AppErrors.INVALID_VALUE); // 0 is allowed\\n  }\\n  //endregion ------------------------------------------ Utils\\n}\",\"keccak256\":\"0x9258b0abb42d61c65c69f0e99731e694e0e0ab5a72c8156ca4b528f0fbb53735\",\"license\":\"MIT\"},\"contracts/strategies/pair/PairBasedStrategyLogicLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"../ConverterStrategyBaseLib.sol\\\";\\nimport \\\"./PairBasedStrategyLib.sol\\\";\\nimport \\\"../ConverterStrategyBaseLib2.sol\\\";\\n\\n/// @notice Library for the UniV3-like strategies with two tokens in the pool\\nlibrary PairBasedStrategyLogicLib {\\n  //region ------------------------------------------------------- Data types\\n  /// @notice Local variables required inside withdrawByAggStep and quoteWithdrawByAgg\\n  struct WithdrawLocal {\\n    /// @notice [underlying, not-underlying]\\n    address[] tokens;\\n    address controller;\\n    /// @notice liquidationThresholds for the {tokens}, greater or equal to {DEFAULT_LIQUIDATION_THRESHOLD}\\n    uint[] liquidationThresholds;\\n    uint planKind;\\n    uint propNotUnderlying18;\\n  }\\n\\n  /// @notice Common part of all XXXXConverterStrategyLogicLib.State\\n  struct PairState {\\n    address pool;\\n    address strategyProfitHolder;\\n    /// @notice This is underlying\\n    address tokenA;\\n    /// @notice This is not underlying\\n    address tokenB;\\n\\n    bool isStablePool;\\n    /// @notice Tokens are swapped in the pool (pool.tokenB is underlying, pool.tokenA is not-underlying)\\n    bool depositorSwapTokens;\\n\\n    int24 tickSpacing;\\n    int24 lowerTick;\\n    int24 upperTick;\\n    int24 rebalanceTickRange;\\n    uint128 totalLiquidity;\\n\\n    /// @notice Fuse for token A and token B\\n    PairBasedStrategyLib.FuseStateParams[2] fuseAB;\\n    /// @notice 1 means that the fuse was triggered ON and then all debts were closed\\n    ///         and assets were converter to underlying using withdrawStepByAgg.\\n    ///         This flag is automatically cleared to 0 if fuse is triggered OFF.\\n    uint withdrawDone;\\n\\n    /// @notice Timestamp of last call of rebalanceNoSwaps() or zero if withdrawByAggStep() was called last\\n    uint lastRebalanceNoSwap;\\n  }\\n\\n  struct RebalanceNoSwapsLocal {\\n    address tokenA;\\n    address tokenB;\\n    bool depositorSwapTokens;\\n    int24 newLowerTick;\\n    int24 newUpperTick;\\n    uint prop0;\\n    uint prop1;\\n  }\\n\\n  struct WithdrawByAggStepLocal {\\n    PairBasedStrategyLogicLib.WithdrawLocal w;\\n    address tokenToSwap;\\n    address aggregator;\\n    address controller;\\n    address converter;\\n    address splitter;\\n    uint amountToSwap;\\n    uint profitToCover;\\n    uint oldTotalAssets;\\n    uint entryToPool;\\n  }\\n  //endregion ------------------------------------------------------- Data types\\n\\n  //region ------------------------------------------------------- Events\\n  event ProfitToCoverNotEnough(uint profitToCoverRequired, uint profitToCoverSent);\\n  //endregion ------------------------------------------------------- Events\\n\\n  //region ------------------------------------------------------- Helpers\\n  /// @notice Prepare array of amounts ready to deposit, borrow missed amounts\\n  function _beforeDeposit(\\n    ITetuConverter tetuConverter_,\\n    uint amount_,\\n    address tokenA,\\n    address tokenB,\\n    bytes memory entryData,\\n    mapping(address => uint) storage liquidationThresholds\\n  ) external returns (\\n    uint[] memory tokenAmounts\\n  ) {\\n    tokenAmounts = new uint[](2);\\n    uint spentCollateral;\\n\\n    AppLib.approveIfNeeded(tokenA, amount_, address(tetuConverter_));\\n    (spentCollateral, tokenAmounts[1]) = ConverterStrategyBaseLib.openPosition(\\n      tetuConverter_,\\n      entryData,\\n      tokenA,\\n      tokenB,\\n      amount_,\\n      liquidationThresholds[tokenA] // amount_ is set in terms of collateral asset\\n    );\\n\\n    tokenAmounts[0] = amount_ > spentCollateral\\n      ? amount_ - spentCollateral\\n      : 0;\\n  }\\n\\n  /// @notice Initialize {dest} in place. Underlying is always first in {dest.tokens}.\\n  /// @param tokens_ [underlying, not-underlying]\\n  function initWithdrawLocal(\\n    WithdrawLocal memory dest,\\n    address[2] memory tokens_,\\n    mapping(address => uint) storage liquidationThresholds,\\n    bytes memory planEntryData,\\n    address controller\\n  ) internal view { // it's internal because it initializes {dest}\\n    dest.controller = controller;\\n    StrategyLib2.onlyOperators(dest.controller);\\n\\n    dest.planKind = IterationPlanLib.getEntryKind(planEntryData);\\n    dest.propNotUnderlying18 = PairBasedStrategyLib._extractProp(dest.planKind, planEntryData);\\n\\n    dest.tokens = new address[](2);\\n    (dest.tokens[0], dest.tokens[1]) = (tokens_[0], tokens_[1]);\\n\\n    dest.liquidationThresholds = new uint[](2);\\n    dest.liquidationThresholds[0] = AppLib._getLiquidationThreshold(liquidationThresholds[dest.tokens[0]]);\\n    dest.liquidationThresholds[1] = AppLib._getLiquidationThreshold(liquidationThresholds[dest.tokens[1]]);\\n  }\\n\\n  function calcTickRange(int24 tick, int24 tickRange, int24 tickSpacing) public pure returns (\\n    int24 lowerTick,\\n    int24 upperTick\\n  ) {\\n    if (tick < 0 && tick / tickSpacing * tickSpacing != tick) {\\n      lowerTick = ((tick - tickRange) / tickSpacing - 1) * tickSpacing;\\n    } else {\\n      lowerTick = (tick - tickRange) / tickSpacing * tickSpacing;\\n    }\\n    upperTick = tickRange == 0 ? lowerTick + tickSpacing : lowerTick + tickRange * 2;\\n  }\\n  //endregion ------------------------------------------------------- Helpers\\n\\n  //region ------------------------------------------------------- PairState-helpers\\n  /// @notice Set the initial values to PairState instance\\n  /// @param pairState Depositor storage state struct to be initialized\\n  /// @param addr [pool, asset, pool.token0(), pool.token1()]\\n  ///        asset: Underlying asset of the depositor.\\n  /// @param tickData [tickSpacing, lowerTick, upperTick, rebalanceTickRange]\\n  /// @param fuseThresholdsA Fuse thresholds for token A (stable pool only)\\n  /// @param fuseThresholdsB Fuse thresholds for token B (stable pool only)\\n  function setInitialDepositorValues(\\n    PairState storage pairState,\\n    address[4] calldata addr,\\n    int24[4] calldata tickData,\\n    bool isStablePool_,\\n    uint[4] calldata fuseThresholdsA,\\n    uint[4] calldata fuseThresholdsB\\n  ) external {\\n    pairState.pool = addr[0];\\n    address asset = addr[1];\\n    address token0 = addr[2];\\n    address token1 = addr[3];\\n\\n    pairState.tickSpacing = tickData[0];\\n    pairState.lowerTick = tickData[1];\\n    pairState.upperTick = tickData[2];\\n    pairState.rebalanceTickRange = tickData[3];\\n\\n    require(asset == token0 || asset == token1, PairBasedStrategyLib.INCORRECT_ASSET);\\n    if (asset == token0) {\\n      pairState.tokenA = token0;\\n      pairState.tokenB = token1;\\n      pairState.depositorSwapTokens = false;\\n    } else {\\n      pairState.tokenA = token1;\\n      pairState.tokenB = token0;\\n      pairState.depositorSwapTokens = true;\\n    }\\n\\n    if (isStablePool_) {\\n      /// for stable pools fuse can be enabled\\n      pairState.isStablePool = true;\\n      PairBasedStrategyLib.setFuseStatus(pairState.fuseAB[0], PairBasedStrategyLib.FuseStatus.FUSE_OFF_1);\\n      PairBasedStrategyLib.setFuseThresholds(pairState.fuseAB[0], fuseThresholdsA);\\n      PairBasedStrategyLib.setFuseStatus(pairState.fuseAB[1], PairBasedStrategyLib.FuseStatus.FUSE_OFF_1);\\n      PairBasedStrategyLib.setFuseThresholds(pairState.fuseAB[1], fuseThresholdsB);\\n    }\\n\\n    // totalLiquidity is 0, no need to initialize\\n    // withdrawDone is 0, no need to initialize\\n  }\\n\\n  function updateFuseStatus(\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\n    bool[2] calldata fuseStatusChangedAB,\\n    PairBasedStrategyLib.FuseStatus[2] calldata fuseStatusAB\\n  ) external {\\n    bool updated;\\n    for (uint i = 0; i < 2; i = AppLib.uncheckedInc(i)) {\\n      if (fuseStatusChangedAB[i]) {\\n        PairBasedStrategyLib.setFuseStatus(pairState.fuseAB[i], fuseStatusAB[i]);\\n        updated = true;\\n      }\\n    }\\n\\n    if (updated) {\\n      // if fuse is triggered ON, full-withdraw is required\\n      // if fuse is triggered OFF, the assets will be deposited back to pool\\n      // in both cases withdrawDone should be reset\\n      pairState.withdrawDone = 0;\\n    }\\n  }\\n\\n  /// @notice Returns the current state of the contract\\n  /// @return addr [tokenA, tokenB, pool, profitHolder]\\n  /// @return tickData [tickSpacing, lowerTick, upperTick, rebalanceTickRange]\\n  /// @return nums [totalLiquidity, fuse-status-tokenA, fuse-status-tokenB, withdrawDone, 4 thresholds of token A, 4 thresholds of token B, lastRebalanceNoSwap]\\n  /// @return boolValues [isStablePool, depositorSwapTokens]\\n  function getDefaultState(PairBasedStrategyLogicLib.PairState storage pairState) external view returns (\\n    address[] memory addr,\\n    int24[] memory tickData,\\n    uint[] memory nums,\\n    bool[] memory boolValues\\n  ) {\\n    addr = new address[](4);\\n    tickData = new int24[](4);\\n    nums = new uint[](13);\\n    boolValues = new bool[](2);\\n\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_TOKEN_A] = pairState.tokenA;\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_TOKEN_B] = pairState.tokenB;\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_POOL] = pairState.pool;\\n    addr[PairBasedStrategyLib.IDX_ADDR_DEFAULT_STATE_PROFIT_HOLDER] = pairState.strategyProfitHolder;\\n\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_TICK_SPACING] = pairState.tickSpacing;\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_LOWER_TICK] = pairState.lowerTick;\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_UPPER_TICK] = pairState.upperTick;\\n    tickData[PairBasedStrategyLib.IDX_TICK_DEFAULT_STATE_REBALANCE_TICK_RANGE] = pairState.rebalanceTickRange;\\n\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_TOTAL_LIQUIDITY] = uint(pairState.totalLiquidity);\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_FUSE_STATUS_A] = uint(pairState.fuseAB[0].status);\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_FUSE_STATUS_B] = uint(pairState.fuseAB[1].status);\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_WITHDRAW_DONE] = pairState.withdrawDone;\\n    for (uint i = 0; i < 4; ++i) {\\n      nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_THRESHOLD_A_0 + i] = pairState.fuseAB[0].thresholds[i];\\n      nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_THRESHOLD_B_0 + i] = pairState.fuseAB[1].thresholds[i];\\n    }\\n    nums[PairBasedStrategyLib.IDX_NUMS_DEFAULT_STATE_LAST_REBALANCE_NO_SWAP] = pairState.lastRebalanceNoSwap;\\n\\n    boolValues[PairBasedStrategyLib.IDX_BOOL_VALUES_DEFAULT_STATE_IS_STABLE_POOL] = pairState.isStablePool;\\n    boolValues[PairBasedStrategyLib.IDX_BOOL_VALUES_DEFAULT_STATE_DEPOSITOR_SWAP_TOKENS] = pairState.depositorSwapTokens;\\n  }\\n\\n  /// @notice Get info about a swap required by next call of {withdrawByAggStep} within the given plan\\n  /// @param amounts_ Amounts of [underlying, not-underlying] that will be received from the pool before withdrawing\\n  function quoteWithdrawByAgg(\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\n    bytes memory planEntryData,\\n    uint[] memory amounts_,\\n    address controller_,\\n    ITetuConverter converter_,\\n    mapping(address => uint) storage liquidationThresholds\\n  ) external returns (\\n    address tokenToSwap,\\n    uint amountToSwap\\n  ) {\\n    // check operator-only, initialize w\\n    WithdrawLocal memory w;\\n    initWithdrawLocal(\\n      w,\\n      [pairState.tokenA, pairState.tokenB],\\n      liquidationThresholds,\\n      planEntryData,\\n      controller_\\n    );\\n\\n    (tokenToSwap, amountToSwap) = PairBasedStrategyLib.quoteWithdrawStep(\\n      [address(converter_), address(AppLib._getLiquidator(w.controller))],\\n      w.tokens,\\n      w.liquidationThresholds,\\n      amounts_,\\n      w.planKind,\\n      w.propNotUnderlying18\\n    );\\n\\n    if (amountToSwap != 0) {\\n      // withdrawByAggStep will execute REPAY1 - SWAP - REPAY2\\n      // but quoteWithdrawByAgg and withdrawByAggStep are executed in different blocks\\n      // so, REPAY1 can return less collateral than quoteWithdrawByAgg expected\\n      // As result, we can have less amount on balance than required amountToSwap\\n      // So, we need to reduce amountToSwap on small gap amount\\n      amountToSwap -= amountToSwap * PairBasedStrategyLib.GAP_AMOUNT_TO_SWAP / 100_000;\\n    }\\n  }\\n\\n  /// @notice Calculate amounts to be deposited to pool, calculate loss, fix profitToCover\\n  /// @param addr_ [tokenToSwap, aggregator, controller, converter, splitter]\\n  /// @param values_ [amountToSwap_, profitToCover, oldTotalAssets, not used here]\\n  /// @param tokens [underlying, not-underlying] (values been read from pairBase)\\n  /// @return completed All debts were closed, leftovers were swapped to proper proportions\\n  /// @return tokenAmounts Amounts to be deposited to pool. If {tokenAmounts} contains zero amount return empty array.\\n  /// @return loss Loss to cover\\n  function withdrawByAggStep(\\n    address[5] calldata addr_,\\n    uint[4] calldata values_,\\n    bytes memory swapData,\\n    bytes memory planEntryData,\\n    address[2] memory tokens,\\n    mapping(address => uint) storage liquidationThresholds\\n  ) external returns (\\n    bool completed,\\n    uint[] memory tokenAmounts,\\n    uint loss\\n  ) {\\n    WithdrawByAggStepLocal memory v;\\n\\n    v.tokenToSwap = addr_[0];\\n    v.aggregator = addr_[1];\\n    v.controller = addr_[2];\\n    v.converter = addr_[3];\\n    v.splitter = addr_[4];\\n\\n    v.amountToSwap = values_[0];\\n    v.profitToCover = values_[1];\\n    v.oldTotalAssets = values_[2];\\n\\n    // initialize v\\n    PairBasedStrategyLogicLib.initWithdrawLocal(v.w, tokens, liquidationThresholds, planEntryData, v.controller);\\n\\n    // make withdraw iteration according to the selected plan\\n    completed = PairBasedStrategyLib.withdrawStep(\\n      [v.converter, address(AppLib._getLiquidator(v.w.controller))],\\n      v.w.tokens,\\n      v.w.liquidationThresholds,\\n      v.tokenToSwap,\\n      v.amountToSwap,\\n      v.aggregator,\\n      swapData,\\n      v.aggregator == address(0),\\n      v.w.planKind,\\n      v.w.propNotUnderlying18\\n    );\\n\\n    // fix loss / profitToCover\\n    if (v.profitToCover > 0) {\\n      uint profitToSend = Math.min(v.profitToCover, IERC20(v.w.tokens[0]).balanceOf(address(this)));\\n      ConverterStrategyBaseLib2.sendToInsurance(v.w.tokens[0], profitToSend, v.splitter, v.oldTotalAssets);\\n    }\\n\\n    (loss, tokenAmounts) = ConverterStrategyBaseLib2.getTokenAmountsPair(\\n      ITetuConverter(v.converter),\\n      v.oldTotalAssets,\\n      v.w.tokens[0],\\n      v.w.tokens[1],\\n      [v.w.liquidationThresholds[0], v.w.liquidationThresholds[1]]\\n    );\\n  }\\n\\n  /// @notice Rebalance asset to proportions {propTokenA}:{1e18-propTokenA}, fix profitToCover\\n  /// @param propTokenA Proportion of {tokenA}, > 0. Proportion of {tokenB} is calculates as 1e18 - prop0\\n  /// @param liquidationThresholdsAB [liquidityThreshold of token A, liquidityThreshold of tokenB]\\n  function rebalanceNoSwaps(\\n    address[2] calldata converterLiquidator,\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\n    uint profitToCover,\\n    uint totalAssets,\\n    address splitter,\\n    uint[2] calldata liquidationThresholdsAB,\\n    uint propTokenA\\n  ) internal {\\n    address tokenA = pairState.tokenA;\\n    address tokenB = pairState.tokenB;\\n\\n    BorrowLib.rebalanceAssets(\\n      ITetuConverter(converterLiquidator[0]),\\n      ITetuLiquidator(converterLiquidator[1]),\\n      tokenA,\\n      tokenB,\\n      propTokenA,\\n      liquidationThresholdsAB[0], // liquidityThreshold of token A\\n      liquidationThresholdsAB[1], // liquidityThreshold of token B\\n      profitToCover\\n    );\\n\\n    // we assume here, that rebalanceAssets provides profitToCover on balance and set leftovers to right proportions\\n    if (profitToCover != 0) {\\n      uint profitToSend = Math.min(profitToCover, IERC20(tokenA).balanceOf(address(this)));\\n      ConverterStrategyBaseLib2.sendToInsurance(tokenA, profitToSend, splitter, totalAssets);\\n      if (profitToSend != profitToCover) {\\n        emit ProfitToCoverNotEnough(profitToCover, profitToSend);\\n      }\\n    }\\n  }\\n  //endregion ------------------------------------------------------- PairState-helpers\\n\\n  //region ------------------------------------------------------- needStrategyRebalance\\n  /// @notice Determine if the strategy needs to be rebalanced.\\n  /// @return needRebalance A boolean indicating if {rebalanceNoSwaps} should be called\\n  function needStrategyRebalance(\\n    PairBasedStrategyLogicLib.PairState storage pairState,\\n    ITetuConverter converter_,\\n    int24 tick\\n  ) external view returns (\\n    bool needRebalance,\\n    bool[2] memory fuseStatusChangedAB,\\n    PairBasedStrategyLib.FuseStatus[2] memory fuseStatusAB\\n  ) {\\n    if (pairState.isStablePool) {\\n      uint[2] memory prices;\\n      (prices[0], prices[1]) = ConverterStrategyBaseLib2.getOracleAssetsPrices(converter_, pairState.tokenA, pairState.tokenB);\\n      for (uint i = 0; i < 2; i = AppLib.uncheckedInc(i)) {\\n        (fuseStatusChangedAB[i], fuseStatusAB[i]) = PairBasedStrategyLib.needChangeFuseStatus(pairState.fuseAB[i], prices[i]);\\n      }\\n      needRebalance = fuseStatusChangedAB[0]\\n        || fuseStatusChangedAB[1]\\n        || (\\n          !PairBasedStrategyLib.isFuseTriggeredOn(fuseStatusAB[0])\\n          && !PairBasedStrategyLib.isFuseTriggeredOn(fuseStatusAB[1])\\n          && _needPoolRebalance(pairState, tick)\\n        );\\n    } else {\\n      needRebalance = _needPoolRebalance(pairState, tick);\\n    }\\n\\n    return (needRebalance, fuseStatusChangedAB, fuseStatusAB); // hide warning\\n  }\\n\\n  /// @notice Determine if the pool needs to be rebalanced.\\n  /// @return A boolean indicating if the pool needs to be rebalanced.\\n  function _needPoolRebalance(\\n    int24 tick,\\n    int24 lowerTick,\\n    int24 upperTick,\\n    int24 tickSpacing,\\n    int24 rebalanceTickRange\\n  ) internal pure returns (bool) {\\n    if (upperTick - lowerTick == tickSpacing) {\\n      return tick < lowerTick || tick >= upperTick;\\n    } else {\\n      int24 halfRange = (upperTick - lowerTick) / 2;\\n      int24 oldMedianTick = lowerTick + halfRange;\\n      return (tick > oldMedianTick)\\n        ? tick - oldMedianTick >= rebalanceTickRange\\n        : oldMedianTick - tick > rebalanceTickRange;\\n    }\\n  }\\n\\n  function _needPoolRebalance(PairBasedStrategyLogicLib.PairState storage pairState, int24 tick) internal view returns (bool) {\\n    return _needPoolRebalance(\\n      tick,\\n      pairState.lowerTick,\\n      pairState.upperTick,\\n      pairState.tickSpacing,\\n      pairState.rebalanceTickRange\\n    );\\n  }\\n  //endregion ------------------------------------------------------- needStrategyRebalance\\n}\",\"keccak256\":\"0x25146732f775e4fbec90646bd3f70b24676f2a02df331eca14e717d8aa885ed4\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x615aa36200003b600b82828239805160001a60731461002e57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe730000000000000000000000000000000000000000301460806040526004361061010a5760003560e01c80638fb5468e116100a1578063c1bbbea711610070578063c1bbbea71461029b578063c3724a89146102bb578063d1585fc4146102db578063f6e26117146102ee57600080fd5b80638fb5468e14610234578063a7aced0914610247578063b67626211461025a578063bd85be291461028857600080fd5b806334d2ec3d116100dd57806334d2ec3d146101bc5780637269cb3a146101cf5780637799c1d1146101f25780638ac339a51461021257600080fd5b8063203250ee1461010f57806328f0aec4146101455780632aed8d41146101665780632cc58ef914610194575b600080fd5b81801561011b57600080fd5b5061012f61012a366004614683565b61031d565b60405161013c91906146ee565b60405180910390f35b610158610153366004614701565b610b0a565b60405190815260200161013c565b81801561017257600080fd5b50610186610181366004614816565b610c68565b60405161013c9291906148b9565b6101a76101a2366004614701565b610e6e565b6040805192835260208301919091520161013c565b6101586101ca366004614967565b610f16565b6101e26101dd366004614a4f565b6110be565b604051901515815260200161013c565b610205610200366004614a91565b6111e7565b60405161013c9190614b3d565b81801561021e57600080fd5b5061023261022d366004614b61565b611275565b005b61012f610242366004614701565b61195e565b61012f610255366004614683565b611b68565b81801561026657600080fd5b5061027a610275366004614bfd565b611d84565b60405161013c929190614c43565b610205610296366004614701565b612720565b8180156102a757600080fd5b5061012f6102b6366004614c65565b612838565b8180156102c757600080fd5b506102326102d6366004614cd7565b612bff565b6101e26102e9366004614d0f565b612c76565b8180156102fa57600080fd5b5061030e610309366004614701565b61334a565b60405161013c93929190614d51565b604080516002808252606080830184529260208301908036833750505060018401549091506001600160a01b0316600061035685613bef565b600486015460408051808201909152601481527341532d372057726f6e67206c697175696469747960601b60208201529192506001600160801b0363010000009091048116919086168210156103c85760405162461bcd60e51b81526004016103bf9190614b3d565b60405180910390fd5b5060118601546040516307cf0b0f60e31b81526000908190600080516020615a2d83398151915290633e785878906104069088908790600401614df9565b60408051808303816000875af1158015610424573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104489190614e14565b9092509050600080516020615a2d8339815191526334267cbc61046a8b613bef565b8b6011015460006040518463ffffffff1660e01b815260040161048f93929190614e38565b600060405180830381600087803b1580156104a957600080fd5b505af11580156104bd573d6000803e3d6000fd5b50505050600082111561056e576012890154604051633f46232960e21b81526001600160a01b0390911690600080516020615a2d8339815191529063fd188ca49061051390849030906000908990600401614e5c565b6020604051808303816000875af1158015610532573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105569190614e85565b925061056c6001600160a01b0382168885613c65565b505b8015610618576013890154604051633f46232960e21b81526001600160a01b0390911690600080516020615a2d8339815191529063fd188ca4906105bd90849030906000908890600401614e5c565b6020604051808303816000875af11580156105dc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106009190614e85565b91506106166001600160a01b0382168884613c65565b505b604051633c423f0b60e01b8152600481018490523060248201526060604482015260006064820152600080516020615a2d83398151915290633c423f0b90608401600060405180830381600087803b15801561067357600080fd5b505af1158015610687573d6000803e3d6000fd5b50506040805160a0810182528681526001600160801b038c81166020830190815260008385018181526060850191825242608086019081529551630624e65f60e11b8152945160048601529151909216602484015251604483015251606482015290516084820152600080516020615a0d8339815191529250630c49ccbe915060a40160408051808303816000875af1158015610728573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074c9190614e14565b8860008151811061075f5761075f614e9e565b602002602001018960018151811061077957610779614e9e565b602090810291909101810192909252919091526040805160808101825285815230928101929092526001600160801b0382820181905260608301525163fc6f786560e01b81526000918291600080516020615a0d8339815191529163fc6f7865916107e79190600401614eb4565b60408051808303816000875af1158015610805573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108299190614e14565b9150915060008960008151811061084257610842614e9e565b6020026020010151831161085757600061087d565b8960008151811061086a5761086a614e9e565b60200260200101518361087d9190614f0d565b905060008a60018151811061089457610894614e9e565b602002602001015183116108a95760006108cf565b8a6001815181106108bc576108bc614e9e565b6020026020010151836108cf9190614f0d565b60408051848152602081018390529192507f15097721483fb2e62f76b9953e3601b26e7cc79208a0191df6fa701c6148744d910160405180910390a160038d0154600160a81b900460ff1615610993578a60018151811061093257610932614e9e565b60200260200101518b60008151811061094d5761094d614e9e565b60200260200101518c60008151811061096857610968614e9e565b602002602001018d60018151811061098257610982614e9e565b602090810291909101019190915252905b81156109b25760028d01546109b2906001600160a01b03168b84613c65565b80156109d15760038d01546109d1906001600160a01b03168b83613c65565b5050505087846109e19190614f20565b60048a01805472ffffffffffffffffffffffffffffffff000000191663010000006001600160801b0384169081029190911790915590945015610afe57604051632142170760e11b8152600080516020615a0d833981519152906342842e0e90610a61903090600080516020615a2d833981519152908890600401614f40565b600060405180830381600087803b158015610a7b57600080fd5b505af1158015610a8f573d6000803e3d6000fd5b5050604051631143967160e11b8152600080516020615a2d83398151915292506322872ce29150610acb90889087906000908190600401614f64565b600060405180830381600087803b158015610ae557600080fd5b505af1158015610af9573d6000803e3d6000fd5b505050505b50505050505092915050565b805460038201546000916001600160a01b03169060ff600160a81b8204169083908190610b59908590600160c81b8104600290810b91600160e01b8104820b91600160b01b909104900b613cc0565b9150915060008073Abb00AE121f27666607E1a32924eef53693064b362438b7e878686896040518563ffffffff1660e01b8152600401610b9c9493929190614f90565b6040805180830381865af4158015610bb8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bdc9190614e14565b90925090506000610bed8284614fbc565b116040518060400160405280601081526020016f54532d3234207a65726f2076616c756560801b81525090610c355760405162461bcd60e51b81526004016103bf9190614b3d565b50610c408183614fbc565b610c5282670de0b6b3a7640000614fcf565b610c5c9190614ffc565b98975050505050505050565b6000606081610c7d60a08a0160808b01615010565b9050600088600360200201359050600060405180604001604052808860020160009054906101000a90046001600160a01b03166001600160a01b03166001600160a01b031681526020018860030160009054906101000a90046001600160a01b03166001600160a01b03166001600160a01b0316815250905060008760000160009054906101000a90046001600160a01b0316905060606000739D7226Fe5fa1b4a470497C4D0573B10F5eB21F0E63bd13c5298f8f8f8f898f6040518763ffffffff1660e01b8152600401610d5796959493929190615036565b600060405180830381865af4158015610d74573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d9c9190810190615148565b919950925090508015610dd15760018a015484516020860151610dcf92899285926001600160a01b039092169188613cea565b505b6001851480610de85750600285148015610de85750875b15610e5d5760038a0154610e1e908490600160c81b8104600290810b91600160e01b8104820b91600160b01b909104900b613cc0565b60038c01805465ffffffffffff60c81b1916600160e01b62ffffff9384160262ffffff60c81b191617600160c81b939092169290920217905590955085905b505050505050965096945050505050565b805460118201546040516308aaf22f60e31b8152600092839273b1450ADeb76257593B97ABdC06ba908300847AAe92634557917892610ecc926001600160a01b0390911691600080516020615a0d8339815191529190600401614f40565b6040805180830381865af4158015610ee8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f0c9190614e14565b9094909350915050565b600080846001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610f57573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f7b91906151b1565b84519091506000805b828110156110b0576000878281518110610fa057610fa0614e9e565b60200260200101519050896001600160a01b0316816001600160a01b031603610fef57868281518110610fd557610fd5614e9e565b602002602001015183610fe89190614fbc565b925061109f565b846001600160a01b031663a9dd14d689848151811061101057611010614e9e565b60200260200101518c8a868151811061102b5761102b614e9e565b60200260200101516040518463ffffffff1660e01b815260040161105193929190614f40565b602060405180830381865afa15801561106e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110929190614e85565b61109c9084614fbc565b92505b506110a9816151ce565b9050610f84565b50925050505b949350505050565b815460405163ecc8941960e01b8152600091739D7226Fe5fa1b4a470497C4D0573B10F5eB21F0E9163498162cf918691869173Abb00AE121f27666607E1a32924eef53693064b39163ecc8941991611124916001600160a01b03909116906004016151e7565b602060405180830381865af4158015611141573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111659190615206565b6040516001600160e01b031960e086901b16815260048101939093526001600160a01b03909116602483015260020b604482015260640160a060405180830381865af41580156111b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111dd9190615223565b5090949350505050565b604051637799c1d160e01b815260609073Abb00AE121f27666607E1a32924eef53693064b390637799c1d190611227908890889088908890600401614f90565b600060405180830381865af4158015611244573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261126c919081019061532b565b95945050505050565b60006112876040890160208a01615010565b6001600160a01b031614156040518060400160405280601181526020017054532d31207a65726f206164647265737360781b815250906112da5760405162461bcd60e51b81526004016103bf9190614b3d565b5060006112ed6040890160208a01615010565b6001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa15801561132a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061134e91906151b1565b9050600061136260408a0160208b01615010565b6001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561139f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113c391906151b1565b90506113cd614585565b600073b1450ADeb76257593B97ABdC06ba908300847AAe63d0c93a7c6040518163ffffffff1660e01b8152600401602060405180830381865af4158015611418573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061143c9190615206565b90508960020b60001461150c5780611454818c615373565b61145e91906153ad565b60020b8a60020b146040518060400160405280601881526020017741532d3320496e636f7272656374207469636b52616e676560401b815250906114b55760405162461bcd60e51b81526004016103bf9190614b3d565b50806114c1818b615373565b6114cb91906153ad565b60020b8960020b14604051806060016040528060218152602001615a4d602191399061150a5760405162461bcd60e51b81526004016103bf9190614b3d565b505b600281900b825273Abb00AE121f27666607E1a32924eef53693064b36358817a9861153d60408e0160208f01615010565b6040516001600160e01b031960e084901b1681526001600160a01b03909116600482015260028d810b602483015284900b60448201526064016040805180830381865af4158015611592573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115b691906153cd565b836001602002018460028093840b602091909102919091015291900b90528882600360029290920b60209092020152506040805160808101909152739D7226Fe5fa1b4a470497C4D0573B10F5eB21F0E906341fcc755908d90808e60016020020160208101906116269190615010565b6001600160a01b03166001600160a01b031681526020018b6001600160a01b03166001600160a01b03168152602001876001600160a01b03166001600160a01b03168152602001866001600160a01b03166001600160a01b0316815250848a8a8a6040518763ffffffff1660e01b81526004016116a8969594939291906153fc565b60006040518083038186803b1580156116c057600080fd5b505af41580156116d4573d6000803e3d6000fd5b5050505060008a6000600281106116ed576116ed614e9e565b6020020160208101906117009190615010565b6001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561173d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061176191906151b1565b60405163095ea7b360e01b81529091506001600160a01b0385169063095ea7b39061179490849060001990600401615487565b6020604051808303816000875af11580156117b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117d791906154a0565b5060405163095ea7b360e01b81526001600160a01b0384169063095ea7b39061180890849060001990600401615487565b6020604051808303816000875af1158015611827573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061184b91906154a0565b5060405163095ea7b360e01b81526001600160a01b0385169063095ea7b39061188a90600080516020615a0d8339815191529060001990600401615487565b6020604051808303816000875af11580156118a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118cd91906154a0565b5060405163095ea7b360e01b81526001600160a01b0384169063095ea7b39061190c90600080516020615a0d8339815191529060001990600401615487565b6020604051808303816000875af115801561192b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194f91906154a0565b50505050505050505050505050565b604080516002808252606080830184529260208301908036833750508354604080516339db007960e21b815290519394506000936001600160a01b03909216925063e76c01e49160048083019260e09291908290030181865afa1580156119c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119ed91906154e0565b505050506003860154600480880154604051630544f36560e31b815295965073b1450ADeb76257593B97ABdC06ba908300847AAe95632a279b289550611a5f94508793600160c81b8104600290810b94600160e01b909204900b92630100000090046001600160801b0316910161556f565b6040805180830381865af4158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190614e14565b83600081518110611ab257611ab2614e9e565b6020026020010184600181518110611acc57611acc614e9e565b6020908102919091010191909152526003830154600160a81b900460ff1615611b625781600181518110611b0257611b02614e9e565b602002602001015182600081518110611b1d57611b1d614e9e565b602002602001015183600081518110611b3857611b38614e9e565b6020026020010184600181518110611b5257611b52614e9e565b6020908102919091010191909152525b50919050565b606060008360000160009054906101000a90046001600160a01b03166001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa158015611bc1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611be591906154e0565b5094955060029450611bf79350505050565b604051908082528060200260200182016040528015611c20578160200160208202803683370190505b506003850154604051630544f36560e31b815291935073b1450ADeb76257593B97ABdC06ba908300847AAe91632a279b2891611c7a918591600160c81b8104600290810b92600160e01b909204900b90899060040161556f565b6040805180830381865af4158015611c96573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cba9190614e14565b83600081518110611ccd57611ccd614e9e565b6020026020010184600181518110611ce757611ce7614e9e565b6020908102919091010191909152526003840154600160a81b900460ff1615611d7d5781600181518110611d1d57611d1d614e9e565b602002602001015182600081518110611d3857611d38614e9e565b602002602001015183600081518110611d5357611d53614e9e565b6020026020010184600181518110611d6d57611d6d614e9e565b6020908102919091010191909152525b5092915050565b6040805160a081018252600384015460ff600160a81b8204161515808352600060208401819052601187015494840194909452600160c81b8204600290810b606085810191909152600160e01b909304900b60808401529092919082908190611e0357600287015460038801546001600160a01b039182169116611e1b565b600387015460028801546001600160a01b0391821691165b8451919350915015611e9a5785600181518110611e3a57611e3a614e9e565b602002602001015186600081518110611e5557611e55614e9e565b602002602001015187600081518110611e7057611e70614e9e565b6020026020010188600181518110611e8a57611e8a614e9e565b6020908102919091010191909152525b6040805160028082526060820183529091602083019080368337505050604084015190955015611fe357604083810151905163133f757160e31b815260048101919091526000908190600080516020615a0d833981519152906399fbab889060240161016060405180830381865afa158015611f1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f3e91906155ad565b50505050509550955050505050846060015160020b8260020b141580611f6e5750846080015160020b8160020b14155b15611fe0576040858101519051630852cd8d60e31b81526004810191909152600080516020615a0d833981519152906342966c6890602401600060405180830381600087803b158015611fc057600080fd5b505af1158015611fd4573d6000803e3d6000fd5b50506000604088015250505b50505b6000611fee88613bef565b905083604001516000036121f757600080516020615a0d8339815191526001600160a01b0316639cc1a283604051806101400160405280866001600160a01b03168152602001856001600160a01b03168152602001876060015160020b8152602001876080015160020b81526020018a60008151811061207057612070614e9e565b602002602001015181526020018a60018151811061209057612090614e9e565b602002602001015181526020016000815260200160008152602001306001600160a01b03168152602001428152506040518263ffffffff1660e01b81526004016120da9190615684565b6080604051808303816000875af11580156120f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061211d919061572f565b87604001886020018b60008151811061213857612138614e9e565b602002602001018c60018151811061215257612152614e9e565b6020908102919091010193909352929091526001600160801b0390921690525260408085015160118a018190559051632142170760e11b8152600080516020615a0d833981519152916342842e0e916121c0913091600080516020615a2d8339815191529190600401614f40565b600060405180830381600087803b1580156121da57600080fd5b505af11580156121ee573d6000803e3d6000fd5b5050505061264b565b600080516020615a0d8339815191526001600160a01b031663219f5d176040518060c00160405280876040015181526020018a60008151811061223c5761223c614e9e565b602002602001015181526020018a60018151811061225c5761225c614e9e565b602002602001015181526020016000815260200160008152602001428152506040518263ffffffff1660e01b81526004016122d69190600060c082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015292915050565b6060604051808303816000875af11580156122f5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612319919061576d565b866020018960008151811061233057612330614e9e565b602002602001018a60018151811061234a5761234a614e9e565b60209081029190910101929092529190526001600160801b03918216905260048901546301000000900416156125d15760408085015190516307cf0b0f60e31b81526000918291600080516020615a2d83398151915291633e785878916123b5918791600401614df9565b60408051808303816000875af11580156123d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123f79190614e14565b6040808901519051630d099f2f60e21b8152929450909250600080516020615a2d833981519152916334267cbc9161243791879190600090600401614e38565b600060405180830381600087803b15801561245157600080fd5b505af1158015612465573d6000803e3d6000fd5b5050505060018a01546001600160a01b031682156125215760128b0154604051633f46232960e21b81526001600160a01b0390911690600080516020615a2d8339815191529063fd188ca4906124c690849030906000908a90600401614e5c565b6020604051808303816000875af11580156124e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125099190614e85565b935061251f6001600160a01b0382168386613c65565b505b81156125c95760138b0154604051633f46232960e21b81526001600160a01b0390911690600080516020615a2d8339815191529063fd188ca49061257090849030906000908990600401614e5c565b6020604051808303816000875af115801561258f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125b39190614e85565b92506121ee6001600160a01b0382168385613c65565b50505061264b565b6040808501519051632142170760e11b8152600080516020615a0d833981519152916342842e0e91612618913091600080516020615a2d8339815191529190600401614f40565b600060405180830381600087803b15801561263257600080fd5b505af1158015612646573d6000803e3d6000fd5b505050505b6040808501519051631143967160e11b8152600080516020615a2d833981519152916322872ce2916126869185916000908190600401614f64565b600060405180830381600087803b1580156126a057600080fd5b505af11580156126b4573d6000803e3d6000fd5b5050505060208401516004890180546003906126e1908490630100000090046001600160801b03166157a4565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555083602001516001600160801b03169450505050509250929050565b6002810154604080516395d89b4160e01b815290516060926001600160a01b0316916395d89b419160048083019260009291908290030181865afa15801561276c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612794919081019061532b565b8260030160009054906101000a90046001600160a01b03166001600160a01b03166395d89b416040518163ffffffff1660e01b8152600401600060405180830381865afa1580156127e9573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612811919081019061532b565b6040516020016128229291906157c4565b6040516020818303038152906040529050919050565b60606128426145a3565b61285a8161285360208b018b615010565b8b86613dbb565b885460405163ecc8941960e01b8152600091829173Abb00AE121f27666607E1a32924eef53693064b39163ecc89419916128a0916001600160a01b0316906004016151e7565b602060405180830381865af41580156128bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128e19190615206565b602084015160405163498162cf60e01b8152600481018e90526001600160a01b039091166024820152600282900b6044820152909150739D7226Fe5fa1b4a470497C4D0573B10F5eB21F0E9063498162cf9060640160a060405180830381865af4158015612953573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129779190615223565b61010086015260e0850152915081156129ff57739D7226Fe5fa1b4a470497C4D0573B10F5eB21F0E636280ea0e8c8560e001518661010001516040518463ffffffff1660e01b81526004016129ce9392919061582a565b60006040518083038186803b1580156129e657600080fd5b505af41580156129fa573d6000803e3d6000fd5b505050505b851580612a095750815b604051806040016040528060188152602001771054cb4e48139bc81c9958985b185b98d9481b995959195960421b81525090612a585760405162461bcd60e51b81526004016103bf9190614b3d565b508115612bf057600073Abb00AE121f27666607E1a32924eef53693064b363e4ee4bf78c8e8c8e8d8a60c00151896040518863ffffffff1660e01b8152600401612aa897969594939291906158d5565b60006040518083038186803b158015612ac057600080fd5b505af4158015612ad4573d6000803e3d6000fd5b50505050600073E11BFbFAf8e53ADC8e67552e8A1607a1b9CB735963ac2a37d686602001518d886060015189608001518a60c001516040518663ffffffff1660e01b8152600401612b2995949392919061595b565b600060405180830381865af4158015612b46573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612b6e919081019061598f565b965090508015612bac57612ba989828f60010160009054906101000a90046001600160a01b0316886060015189608001518a60400151613cea565b91505b60408051828152602081018c90529081018390527f83387a3342ff1ebc5e437dc9ae0f98274afda12a11cf547eebec05a3e0b8f8a79060600160405180910390a150505b5050505b979650505050505050565b612c0c6020820182615010565b6012830180546001600160a01b0319166001600160a01b0392909216919091179055612c3e6040820160208301615010565b6013830180546001600160a01b0319166001600160a01b03929092169190911790556060810135601483015560800135601590910155565b6040805160c0810182526000918101829052606081018290526080810182905260a0810182905260028501546001600160a01b03908116825260038601548116602083015260018601546004870154911690630100000090046001600160801b03161561305b57601286015460138701546001600160a01b0391821691166000612cff89613bef565b9050600080600080516020615a2d8339815191526001600160a01b031663de2356d16040518163ffffffff1660e01b8152600401602060405180830381865afa158015612d50573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d7491906151b1565b6001600160a01b031663704972f4848d601101546040518363ffffffff1660e01b8152600401612da5929190614df9565b6040805180830381865afa158015612dc1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612de59190614e14565b6040516370a0823160e01b815291935091506001600160a01b038616906370a0823190612e169089906004016151e7565b602060405180830381865afa158015612e33573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e579190614e85565b612e619083614fbc565b6040516370a0823160e01b81529092506001600160a01b038516906370a0823190612e909089906004016151e7565b602060405180830381865afa158015612ead573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ed19190614e85565b612edb9082614fbc565b90506000896001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612f1d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f4191906151b1565b90508215612fc05787516040516354ee8a6b60e11b81526001600160a01b0383169163a9dd14d691612f79918a918890600401614f40565b602060405180830381865afa158015612f96573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612fba9190614e85565b60408901525b6060880151156130415787516040516354ee8a6b60e11b81526001600160a01b0383169163a9dd14d691612ffa9189918790600401614f40565b602060405180830381865afa158015613017573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061303b9190614e85565b60608901525b61304a8c610e6e565b60a08a015260808901525050505050505b6003860154600160a81b900460ff16156130815760a08201805160808401805190925290525b81516040516370a0823160e01b81526001600160a01b03909116906370a08231906130b09084906004016151e7565b602060405180830381865afa1580156130cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130f19190614e85565b826080018181516131029190614fbc565b90525060208201516040516370a0823160e01b81526001600160a01b03909116906370a08231906131379084906004016151e7565b602060405180830381865afa158015613154573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131789190614e85565b8260a0018181516131899190614fbc565b905250600061319786613f09565b835160405163b3596f0760e01b81529192506000916001600160a01b0384169163b3596f07916131ca91906004016151e7565b602060405180830381865afa1580156131e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061320b9190614e85565b90506000826001600160a01b031663b3596f0786602001516040518263ffffffff1660e01b815260040161323f91906151e7565b602060405180830381865afa15801561325c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132809190614e85565b90506000670de0b6b3a764000083876080015161329d9190614fcf565b6132a79190614ffc565b90506000670de0b6b3a7640000838860a001516132c49190614fcf565b6132ce9190614ffc565b905060648211806132df5750606481115b8061330c57506064670de0b6b3a76400008589604001516133009190614fcf565b61330a9190614ffc565b115b8061333957506064670de0b6b3a764000085896060015161332d9190614fcf565b6133379190614ffc565b115b9750505050505050505b9392505050565b6001810154601182015460408051600480825260a08201909252606093849384936001600160a01b0390921692909160208201608080368337505050600287015481519196506001600160a01b03169086906000906133ab576133ab614e9e565b6001600160a01b03928316602091820292909201015260038701548651911690869060019081106133de576133de614e9e565b6001600160a01b039283166020918202929092010152601287015486519116908690600290811061341157613411614e9e565b6001600160a01b039283166020918202929092010152601387015486519116908690600390811061344457613444614e9e565b6001600160a01b039290921660209283029190910182015260408051600480825260a0820190925291820160808036833701905050925060005b855181101561353c5785818151811061349957613499614e9e565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016134cc91906151e7565b602060405180830381865afa1580156134e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061350d9190614e85565b84828151811061351f5761351f614e9e565b602090810291909101015280613534816151ce565b91505061347e565b5060408051600480825260a08201909252906020820160808036833701905050935060008111801561358157506004860154630100000090046001600160801b031615155b15613a8057604080516080810182528281523060208201526001600160801b038183018190526060820152905163fc6f786560e01b8152600080516020615a2d8339815191529163fc6f7865916135db9190600401614eb4565b60408051808303816000875af11580156135f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061361d9190614e14565b8560008151811061363057613630614e9e565b602002602001018660018151811061364a5761364a614e9e565b60200260200101828152508281525050507f15097721483fb2e62f76b9953e3601b26e7cc79208a0191df6fa701c6148744d8460008151811061368f5761368f614e9e565b6020026020010151856001815181106136aa576136aa614e9e565b60200260200101516040516136c9929190918252602082015260400190565b60405180910390a16003860154600160a81b900460ff161561375857836001815181106136f8576136f8614e9e565b60200260200101518460008151811061371357613713614e9e565b60200260200101518560008151811061372e5761372e614e9e565b602002602001018660018151811061374857613748614e9e565b6020908102919091010191909152525b600080516020615a2d833981519152633e78587861377588613bef565b836040518363ffffffff1660e01b8152600401613793929190614df9565b60408051808303816000875af11580156137b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137d59190614e14565b856002815181106137e8576137e8614e9e565b602002602001018660038151811061380257613802614e9e565b602002602001018281525082815250505060008460028151811061382857613828614e9e565b6020026020010151111561390e57600080516020615a2d8339815191526001600160a01b031663fd188ca48660028151811061386657613866614e9e565b60200260200101513060008860028151811061388457613884614e9e565b60200260200101516040518563ffffffff1660e01b81526004016138ab9493929190614e5c565b6020604051808303816000875af11580156138ca573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138ee9190614e85565b8460028151811061390157613901614e9e565b6020026020010181815250505b60008460038151811061392357613923614e9e565b60200260200101511115613a0957600080516020615a2d8339815191526001600160a01b031663fd188ca48660038151811061396157613961614e9e565b60200260200101513060008860038151811061397f5761397f614e9e565b60200260200101516040518563ffffffff1660e01b81526004016139a69493929190614e5c565b6020604051808303816000875af11580156139c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139e99190614e85565b846003815181106139fc576139fc614e9e565b6020026020010181815250505b7f2f1396dffa36013d7e1df1ec39cb355b5ff604d56e817a88ed2a0d40995adcb884600281518110613a3d57613a3d614e9e565b602002602001015185600381518110613a5857613a58614e9e565b6020026020010151604051613a77929190918252602082015260400190565b60405180910390a15b60005b8551811015613be5576000868281518110613aa057613aa0614e9e565b60200260200101516001600160a01b03166370a08231856040518263ffffffff1660e01b8152600401613ad391906151e7565b602060405180830381865afa158015613af0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b149190614e85565b90508015613bd457868281518110613b2e57613b2e614e9e565b60200260200101516001600160a01b03166323b872dd8530846040518463ffffffff1660e01b8152600401613b6593929190614f40565b6020604051808303816000875af1158015613b84573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613ba891906154a0565b5080868381518110613bbc57613bbc614e9e565b60200260200101818151613bd09190614fbc565b9052505b50613bde816151ce565b9050613a83565b5050509193909250565b6040805160a081018252600080825260208201819052918101829052606081018290526080810191909152506040805160a08101825260128301546001600160a01b0390811682526013840154811660208301528354169181019190915260148201546060820152601590910154608082015290565b613cbb8363a9059cbb60e01b8484604051602401613c84929190615487565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152613fd4565b505050565b6000806000613cce876140a6565b9050613cdc81878787614117565b925092505094509492505050565b60008515613db1576040516367acb54b60e01b8152600481018790526001600160a01b038087166024830152808616604483015280851660648301528316608482015273Abb00AE121f27666607E1a32924eef53693064b3906367acb54b9060a401602060405180830381865af4158015613d69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613d8d9190614e85565b90506000613d9b8288614f0d565b90508015613daf57613daf886000836141e1565b505b9695505050505050565b81546001600160a01b031660408086019190915280518082019091526005830160026000835b82821015613e6d57604080518082019091526005830285018054829060ff166003811115613e1157613e11615814565b6003811115613e2257613e22615814565b815260408051608081019182905260209092019190600184019060049082845b815481526020019060010190808311613e425750505050508152505081526020019060010190613de1565b505050908552506001600160a01b03838116602080870191909152600284015482166060870181905260038501549283166080880152600160a01b90920460ff16151560a087015260009182528290526040902054613ecb9061445a565b60c08501515260808401516001600160a01b0316600090815260208290526040902054613ef79061445a565b60c08501516001602002015250505050565b6000816001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015613f49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613f6d91906151b1565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613faa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613fce91906151b1565b92915050565b6000614029826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166144729092919063ffffffff16565b805190915015613cbb578080602001905181019061404791906154a0565b613cbb5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016103bf565b6000816001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa1580156140e6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061410a91906154e0565b5093979650505050505050565b6000808061412586866159cb565b905060008460020b8260020b1461414657614141600283615373565b614149565b60005b60405163cd8e20e760e01b815260028a810b600483015282810b602483015287900b6044820152909150739D7226Fe5fa1b4a470497C4D0573B10F5eB21F0E9063cd8e20e7906064016040805180830381865af41580156141ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141d291906153cd565b93509350505094509492505050565b6000836001600160a01b03166338d52e0f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614221573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061424591906151b1565b90506000846001600160a01b031663fbfa77cf6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614287573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906142ab91906151b1565b90506000826001600160a01b03166370a08231836040518263ffffffff1660e01b81526004016142db91906151e7565b602060405180830381865afa1580156142f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061431c9190614e85565b604051630855081f60e01b815260048101879052602481018690529091506001600160a01b03871690630855081f90604401600060405180830381600087803b15801561436857600080fd5b505af115801561437c573d6000803e3d6000fd5b50506040516370a0823160e01b8152600092506001600160a01b03861691506370a08231906143af9086906004016151e7565b602060405180830381865afa1580156143cc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906143f09190614e85565b905081811161440057600061440a565b61440a8282614f0d565b905084811015614451577fdf392b47ba4bbae72ff7c68976df0acdc2813e181199d2b2f65187eeb0ee610561443f8287614f0d565b60405190815260200160405180910390a15b50505050505050565b600081156144685781613fce565b620186a092915050565b60606110b6848460008585600080866001600160a01b0316858760405161449991906159f0565b60006040518083038185875af1925050503d80600081146144d6576040519150601f19603f3d011682016040523d82523d6000602084013e6144db565b606091505b5091509150612bf4878383876060831561455657825160000361454f576001600160a01b0385163b61454f5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016103bf565b50816110b6565b6110b6838381511561456b5781518083602001fd5b8060405162461bcd60e51b81526004016103bf9190614b3d565b60405180608001604052806004906020820280368337509192915050565b6040518061012001604052806145b7614606565b815260006020820181905260408201819052606082018190526080820181905260a082015260c0016145e7614633565b81526020016145f4614633565b8152602001614601614633565b905290565b60405180604001604052806002905b61461d614651565b8152602001906001900390816146155790505090565b60405180604001604052806002906020820280368337509192915050565b604080518082019091528060008152602001614601614585565b6001600160801b038116811461468057600080fd5b50565b6000806040838503121561469657600080fd5b8235915060208301356146a88161466b565b809150509250929050565b600081518084526020808501945080840160005b838110156146e3578151875295820195908201906001016146c7565b509495945050505050565b60208152600061334360208301846146b3565b60006020828403121561471357600080fd5b5035919050565b8060808101831015613fce57600080fd5b634e487b7160e01b600052604160045260246000fd5b604080519081016001600160401b03811182821017156147635761476361472b565b60405290565b604051601f8201601f191681016001600160401b03811182821017156147915761479161472b565b604052919050565b60006001600160401b038211156147b2576147b261472b565b50601f01601f191660200190565b600082601f8301126147d157600080fd5b81356147e46147df82614799565b614769565b8181528460208386010111156147f957600080fd5b816020850160208301376000918101602001919091529392505050565b6000806000806000806101a0878903121561483057600080fd5b60a087018881111561484157600080fd5b87965061484e898261471a565b9550506101208701356001600160401b038082111561486c57600080fd5b6148788a838b016147c0565b955061014089013591508082111561488f57600080fd5b5061489c89828a016147c0565b935050610160870135915061018087013590509295509295509295565b82151581526040602082015260006110b660408301846146b3565b6001600160a01b038116811461468057600080fd5b60006001600160401b038211156149025761490261472b565b5060051b60200190565b600082601f83011261491d57600080fd5b8135602061492d6147df836148e9565b82815260059290921b8401810191818101908684111561494c57600080fd5b8286015b84811015613daf5780358352918301918301614950565b6000806000806080858703121561497d57600080fd5b8435614988816148d4565b9350602085810135614999816148d4565b935060408601356001600160401b03808211156149b557600080fd5b818801915088601f8301126149c957600080fd5b81356149d76147df826148e9565b81815260059190911b8301840190848101908b8311156149f657600080fd5b938501935b82851015614a1d578435614a0e816148d4565b825293850193908501906149fb565b965050506060880135925080831115614a3557600080fd5b5050614a438782880161490c565b91505092959194509250565b60008060408385031215614a6257600080fd5b8235915060208301356146a8816148d4565b8060020b811461468057600080fd5b801515811461468057600080fd5b60008060008060808587031215614aa757600080fd5b8435614ab2816148d4565b93506020850135614ac281614a74565b92506040850135614ad281614a74565b91506060850135614ae281614a83565b939692955090935050565b60005b83811015614b08578181015183820152602001614af0565b50506000910152565b60008151808452614b29816020860160208601614aed565b601f01601f19169290920160200192915050565b6020815260006133436020830184614b11565b8060408101831015613fce57600080fd5b6000806000806000806000806101e0898b031215614b7e57600080fd5b88359750614b8f8a60208b01614b50565b96506060890135614b9f81614a74565b95506080890135614baf81614a74565b945060a0890135614bbf816148d4565b935060c0890135614bcf81614a83565b9250614bde8a60e08b0161471a565b9150614bee8a6101608b0161471a565b90509295985092959890939650565b60008060408385031215614c1057600080fd5b8235915060208301356001600160401b03811115614c2d57600080fd5b614c398582860161490c565b9150509250929050565b604081526000614c5660408301856146b3565b90508260208301529392505050565b6000806000806000806000610100888a031215614c8157600080fd5b87359650614c928960208a01614b50565b9550606088013594506080880135935060a0880135614cb0816148d4565b925060c0880135614cc081614a83565b8092505060e0880135905092959891949750929550565b60008082840360c0811215614ceb57600080fd5b8335925060a0601f1982011215614d0157600080fd5b506020830190509250929050565b600080600060608486031215614d2457600080fd5b833592506020840135614d36816148d4565b91506040840135614d46816148d4565b809150509250925092565b606080825284519082018190526000906020906080840190828801845b82811015614d935781516001600160a01b031684529284019290840190600101614d6e565b50505083810382850152614da781876146b3565b9150508281036040840152613db181856146b3565b80516001600160a01b0390811683526020808301518216908401526040808301519091169083015260608082015190830152608090810151910152565b60c08101614e078285614dbc565b8260a08301529392505050565b60008060408385031215614e2757600080fd5b505080516020909101519092909150565b60e08101614e468286614dbc565b8360a083015282151560c0830152949350505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060208284031215614e9757600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b815181526020808301516001600160a01b0316908201526040808301516001600160801b0390811691830191909152606092830151169181019190915260800190565b634e487b7160e01b600052601160045260246000fd5b81810381811115613fce57613fce614ef7565b6001600160801b03828116828216039080821115611d7d57611d7d614ef7565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6101008101614f738287614dbc565b8460a08301528360c083015282151560e083015295945050505050565b6001600160a01b03949094168452600292830b6020850152910b60408301521515606082015260800190565b80820180821115613fce57613fce614ef7565b8082028115828204841417613fce57613fce614ef7565b634e487b7160e01b600052601260045260246000fd5b60008261500b5761500b614fe6565b500490565b60006020828403121561502257600080fd5b8135613343816148d4565b60808183375050565b60006101c08289835b6005811015615071578135615053816148d4565b6001600160a01b03168352602092830192919091019060010161503f565b50505060808860a08501378061012084015261508f81840188614b11565b90508281036101408401526150a48187614b11565b91505061016082018460005b60028110156150d85781516001600160a01b03168352602092830192909101906001016150b0565b505050826101a0830152979650505050505050565b600082601f8301126150fe57600080fd5b8151602061510e6147df836148e9565b82815260059290921b8401810191818101908684111561512d57600080fd5b8286015b84811015613daf5780518352918301918301615131565b60008060006060848603121561515d57600080fd5b835161516881614a83565b60208501519093506001600160401b0381111561518457600080fd5b615190868287016150ed565b925050604084015190509250925092565b80516151ac816148d4565b919050565b6000602082840312156151c357600080fd5b8151613343816148d4565b6000600182016151e0576151e0614ef7565b5060010190565b6001600160a01b0391909116815260200190565b80516151ac81614a74565b60006020828403121561521857600080fd5b815161334381614a74565b600080600060a0848603121561523857600080fd5b835161524381614a83565b92506020603f8501861361525657600080fd5b61525e614741565b80606087018881111561527057600080fd5b8388015b8181101561529457805161528781614a83565b8452928401928401615274565b5081955088607f8901126152a757600080fd5b6152af614741565b925082915060a08801898111156152c557600080fd5b808210156152ec578151600481106152dd5760008081fd5b845292840192908401906152c5565b50508093505050509250925092565b60006153096147df84614799565b905082815283838301111561531d57600080fd5b613343836020830184614aed565b60006020828403121561533d57600080fd5b81516001600160401b0381111561535357600080fd5b8201601f8101841361536457600080fd5b6110b6848251602084016152fb565b60008160020b8360020b8061538a5761538a614fe6565b627fffff198214600019821416156153a4576153a4614ef7565b90059392505050565b60008260020b8260020b028060020b9150808214611d7d57611d7d614ef7565b600080604083850312156153e057600080fd5b82516153eb81614a74565b60208401519092506146a881614a74565b868152610240810160208083018860005b60048110156154335781516001600160a01b03168352918301919083019060010161540d565b50505060a083018760005b600481101561545e57815160020b8352918301919083019060010161543e565b5050505084151561012083015261547961014083018561502d565b612bf46101c083018461502d565b6001600160a01b03929092168252602082015260400190565b6000602082840312156154b257600080fd5b815161334381614a83565b805161ffff811681146151ac57600080fd5b805160ff811681146151ac57600080fd5b600080600080600080600060e0888a0312156154fb57600080fd5b8751615506816148d4565b602089015190975061551781614a74565b9550615525604089016154bd565b9450615533606089016154bd565b9350615541608089016154cf565b925061554f60a089016154cf565b915060c088015161555f81614a83565b8091505092959891949750929550565b6001600160a01b03949094168452600292830b6020850152910b60408301526001600160801b0316606082015260800190565b80516151ac8161466b565b60008060008060008060008060008060006101608c8e0312156155cf57600080fd5b8b516bffffffffffffffffffffffff811681146155eb57600080fd5b60208d0151909b506155fc816148d4565b60408d0151909a5061560d816148d4565b985061561b60608d016151a1565b975061562960808d016151fb565b965061563760a08d016151fb565b955061564560c08d016155a2565b945060e08c015193506101008c015192506156636101208d016155a2565b91506156726101408d016155a2565b90509295989b509295989b9093969950565b81516001600160a01b03168152610140810160208301516156b060208401826001600160a01b03169052565b5060408301516156c5604084018260020b9052565b5060608301516156da606084018260020b9052565b506080830151608083015260a083015160a083015260c083015160c083015260e083015160e08301526101008084015161571e828501826001600160a01b03169052565b505061012092830151919092015290565b6000806000806080858703121561574557600080fd5b8451935060208501516157578161466b565b6040860151606090960151949790965092505050565b60008060006060848603121561578257600080fd5b835161578d8161466b565b602085015160409095015190969495509392505050565b6001600160801b03818116838216019080821115611d7d57611d7d614ef7565b67020b633b2b13930960c51b8152600083516157e7816008850160208801614aed565b602f60f81b6008918401918201528351615808816009840160208801614aed565b01600901949350505050565b634e487b7160e01b600052602160045260246000fd5b83815260a0810160208083018560005b600281101561585957815115158352918301919083019060010161583a565b505050606083018460005b60028110156158a0578151600480821061588d57634e487b7160e01b6000526021815260246000fd5b5083529183019190830190600101615864565b50505050949350505050565b8060005b60028110156158cf5781518452602093840193909101906001016158b0565b50505050565b6101208101818960005b60028110156159115781356158f3816148d4565b6001600160a01b0316835260209283019291909101906001016158df565b5050506040820188905260608201879052608082018690526001600160a01b03851660a083015261594560c08301856158ac565b8260020b61010083015298975050505050505050565b6001600160a01b0386811682526020820186905284811660408301528316606082015260c08101613db160808301846158ac565b600080604083850312156159a257600080fd5b8251915060208301516001600160401b038111156159bf57600080fd5b614c39858286016150ed565b600282810b9082900b03627fffff198112627fffff82131715613fce57613fce614ef7565b60008251615a02818460208701614aed565b919091019291505056fe0000000000000000000000008ef88e4c7cfbbac1c163f7eddd4b578792201de60000000000000000000000007f281a8cdf66ef5e9db8434ec6d97acc1bc01e7841532d3420496e636f727265637420726562616c616e63655469636b52616e6765a26469706673582212201fc4dfefcba1d22b46a4a7b12929405436463e799531610ef8808c1d2a34966864736f6c63430008110033",
  "deployedBytecode": "0x730000000000000000000000000000000000000000301460806040526004361061010a5760003560e01c80638fb5468e116100a1578063c1bbbea711610070578063c1bbbea71461029b578063c3724a89146102bb578063d1585fc4146102db578063f6e26117146102ee57600080fd5b80638fb5468e14610234578063a7aced0914610247578063b67626211461025a578063bd85be291461028857600080fd5b806334d2ec3d116100dd57806334d2ec3d146101bc5780637269cb3a146101cf5780637799c1d1146101f25780638ac339a51461021257600080fd5b8063203250ee1461010f57806328f0aec4146101455780632aed8d41146101665780632cc58ef914610194575b600080fd5b81801561011b57600080fd5b5061012f61012a366004614683565b61031d565b60405161013c91906146ee565b60405180910390f35b610158610153366004614701565b610b0a565b60405190815260200161013c565b81801561017257600080fd5b50610186610181366004614816565b610c68565b60405161013c9291906148b9565b6101a76101a2366004614701565b610e6e565b6040805192835260208301919091520161013c565b6101586101ca366004614967565b610f16565b6101e26101dd366004614a4f565b6110be565b604051901515815260200161013c565b610205610200366004614a91565b6111e7565b60405161013c9190614b3d565b81801561021e57600080fd5b5061023261022d366004614b61565b611275565b005b61012f610242366004614701565b61195e565b61012f610255366004614683565b611b68565b81801561026657600080fd5b5061027a610275366004614bfd565b611d84565b60405161013c929190614c43565b610205610296366004614701565b612720565b8180156102a757600080fd5b5061012f6102b6366004614c65565b612838565b8180156102c757600080fd5b506102326102d6366004614cd7565b612bff565b6101e26102e9366004614d0f565b612c76565b8180156102fa57600080fd5b5061030e610309366004614701565b61334a565b60405161013c93929190614d51565b604080516002808252606080830184529260208301908036833750505060018401549091506001600160a01b0316600061035685613bef565b600486015460408051808201909152601481527341532d372057726f6e67206c697175696469747960601b60208201529192506001600160801b0363010000009091048116919086168210156103c85760405162461bcd60e51b81526004016103bf9190614b3d565b60405180910390fd5b5060118601546040516307cf0b0f60e31b81526000908190600080516020615a2d83398151915290633e785878906104069088908790600401614df9565b60408051808303816000875af1158015610424573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104489190614e14565b9092509050600080516020615a2d8339815191526334267cbc61046a8b613bef565b8b6011015460006040518463ffffffff1660e01b815260040161048f93929190614e38565b600060405180830381600087803b1580156104a957600080fd5b505af11580156104bd573d6000803e3d6000fd5b50505050600082111561056e576012890154604051633f46232960e21b81526001600160a01b0390911690600080516020615a2d8339815191529063fd188ca49061051390849030906000908990600401614e5c565b6020604051808303816000875af1158015610532573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105569190614e85565b925061056c6001600160a01b0382168885613c65565b505b8015610618576013890154604051633f46232960e21b81526001600160a01b0390911690600080516020615a2d8339815191529063fd188ca4906105bd90849030906000908890600401614e5c565b6020604051808303816000875af11580156105dc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106009190614e85565b91506106166001600160a01b0382168884613c65565b505b604051633c423f0b60e01b8152600481018490523060248201526060604482015260006064820152600080516020615a2d83398151915290633c423f0b90608401600060405180830381600087803b15801561067357600080fd5b505af1158015610687573d6000803e3d6000fd5b50506040805160a0810182528681526001600160801b038c81166020830190815260008385018181526060850191825242608086019081529551630624e65f60e11b8152945160048601529151909216602484015251604483015251606482015290516084820152600080516020615a0d8339815191529250630c49ccbe915060a40160408051808303816000875af1158015610728573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061074c9190614e14565b8860008151811061075f5761075f614e9e565b602002602001018960018151811061077957610779614e9e565b602090810291909101810192909252919091526040805160808101825285815230928101929092526001600160801b0382820181905260608301525163fc6f786560e01b81526000918291600080516020615a0d8339815191529163fc6f7865916107e79190600401614eb4565b60408051808303816000875af1158015610805573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108299190614e14565b9150915060008960008151811061084257610842614e9e565b6020026020010151831161085757600061087d565b8960008151811061086a5761086a614e9e565b60200260200101518361087d9190614f0d565b905060008a60018151811061089457610894614e9e565b602002602001015183116108a95760006108cf565b8a6001815181106108bc576108bc614e9e565b6020026020010151836108cf9190614f0d565b60408051848152602081018390529192507f15097721483fb2e62f76b9953e3601b26e7cc79208a0191df6fa701c6148744d910160405180910390a160038d0154600160a81b900460ff1615610993578a60018151811061093257610932614e9e565b60200260200101518b60008151811061094d5761094d614e9e565b60200260200101518c60008151811061096857610968614e9e565b602002602001018d60018151811061098257610982614e9e565b602090810291909101019190915252905b81156109b25760028d01546109b2906001600160a01b03168b84613c65565b80156109d15760038d01546109d1906001600160a01b03168b83613c65565b5050505087846109e19190614f20565b60048a01805472ffffffffffffffffffffffffffffffff000000191663010000006001600160801b0384169081029190911790915590945015610afe57604051632142170760e11b8152600080516020615a0d833981519152906342842e0e90610a61903090600080516020615a2d833981519152908890600401614f40565b600060405180830381600087803b158015610a7b57600080fd5b505af1158015610a8f573d6000803e3d6000fd5b5050604051631143967160e11b8152600080516020615a2d83398151915292506322872ce29150610acb90889087906000908190600401614f64565b600060405180830381600087803b158015610ae557600080fd5b505af1158015610af9573d6000803e3d6000fd5b505050505b50505050505092915050565b805460038201546000916001600160a01b03169060ff600160a81b8204169083908190610b59908590600160c81b8104600290810b91600160e01b8104820b91600160b01b909104900b613cc0565b9150915060008073__$461d2a13b6c4ece874725da1f5491a2777$__62438b7e878686896040518563ffffffff1660e01b8152600401610b9c9493929190614f90565b6040805180830381865af4158015610bb8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bdc9190614e14565b90925090506000610bed8284614fbc565b116040518060400160405280601081526020016f54532d3234207a65726f2076616c756560801b81525090610c355760405162461bcd60e51b81526004016103bf9190614b3d565b50610c408183614fbc565b610c5282670de0b6b3a7640000614fcf565b610c5c9190614ffc565b98975050505050505050565b6000606081610c7d60a08a0160808b01615010565b9050600088600360200201359050600060405180604001604052808860020160009054906101000a90046001600160a01b03166001600160a01b03166001600160a01b031681526020018860030160009054906101000a90046001600160a01b03166001600160a01b03166001600160a01b0316815250905060008760000160009054906101000a90046001600160a01b031690506060600073__$b1ba452cecccdd06eb05ace2d0a762c7e1$__63bd13c5298f8f8f8f898f6040518763ffffffff1660e01b8152600401610d5796959493929190615036565b600060405180830381865af4158015610d74573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d9c9190810190615148565b919950925090508015610dd15760018a015484516020860151610dcf92899285926001600160a01b039092169188613cea565b505b6001851480610de85750600285148015610de85750875b15610e5d5760038a0154610e1e908490600160c81b8104600290810b91600160e01b8104820b91600160b01b909104900b613cc0565b60038c01805465ffffffffffff60c81b1916600160e01b62ffffff9384160262ffffff60c81b191617600160c81b939092169290920217905590955085905b505050505050965096945050505050565b805460118201546040516308aaf22f60e31b8152600092839273__$5ce7b97fe3b9dad27bffcf1c56869f0b10$__92634557917892610ecc926001600160a01b0390911691600080516020615a0d8339815191529190600401614f40565b6040805180830381865af4158015610ee8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f0c9190614e14565b9094909350915050565b600080846001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610f57573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f7b91906151b1565b84519091506000805b828110156110b0576000878281518110610fa057610fa0614e9e565b60200260200101519050896001600160a01b0316816001600160a01b031603610fef57868281518110610fd557610fd5614e9e565b602002602001015183610fe89190614fbc565b925061109f565b846001600160a01b031663a9dd14d689848151811061101057611010614e9e565b60200260200101518c8a868151811061102b5761102b614e9e565b60200260200101516040518463ffffffff1660e01b815260040161105193929190614f40565b602060405180830381865afa15801561106e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110929190614e85565b61109c9084614fbc565b92505b506110a9816151ce565b9050610f84565b50925050505b949350505050565b815460405163ecc8941960e01b815260009173__$b1ba452cecccdd06eb05ace2d0a762c7e1$__9163498162cf918691869173__$461d2a13b6c4ece874725da1f5491a2777$__9163ecc8941991611124916001600160a01b03909116906004016151e7565b602060405180830381865af4158015611141573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111659190615206565b6040516001600160e01b031960e086901b16815260048101939093526001600160a01b03909116602483015260020b604482015260640160a060405180830381865af41580156111b9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906111dd9190615223565b5090949350505050565b604051637799c1d160e01b815260609073__$461d2a13b6c4ece874725da1f5491a2777$__90637799c1d190611227908890889088908890600401614f90565b600060405180830381865af4158015611244573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261126c919081019061532b565b95945050505050565b60006112876040890160208a01615010565b6001600160a01b031614156040518060400160405280601181526020017054532d31207a65726f206164647265737360781b815250906112da5760405162461bcd60e51b81526004016103bf9190614b3d565b5060006112ed6040890160208a01615010565b6001600160a01b0316630dfe16816040518163ffffffff1660e01b8152600401602060405180830381865afa15801561132a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061134e91906151b1565b9050600061136260408a0160208b01615010565b6001600160a01b031663d21220a76040518163ffffffff1660e01b8152600401602060405180830381865afa15801561139f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113c391906151b1565b90506113cd614585565b600073__$5ce7b97fe3b9dad27bffcf1c56869f0b10$__63d0c93a7c6040518163ffffffff1660e01b8152600401602060405180830381865af4158015611418573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061143c9190615206565b90508960020b60001461150c5780611454818c615373565b61145e91906153ad565b60020b8a60020b146040518060400160405280601881526020017741532d3320496e636f7272656374207469636b52616e676560401b815250906114b55760405162461bcd60e51b81526004016103bf9190614b3d565b50806114c1818b615373565b6114cb91906153ad565b60020b8960020b14604051806060016040528060218152602001615a4d602191399061150a5760405162461bcd60e51b81526004016103bf9190614b3d565b505b600281900b825273__$461d2a13b6c4ece874725da1f5491a2777$__6358817a9861153d60408e0160208f01615010565b6040516001600160e01b031960e084901b1681526001600160a01b03909116600482015260028d810b602483015284900b60448201526064016040805180830381865af4158015611592573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906115b691906153cd565b836001602002018460028093840b602091909102919091015291900b90528882600360029290920b6020909202015250604080516080810190915273__$b1ba452cecccdd06eb05ace2d0a762c7e1$__906341fcc755908d90808e60016020020160208101906116269190615010565b6001600160a01b03166001600160a01b031681526020018b6001600160a01b03166001600160a01b03168152602001876001600160a01b03166001600160a01b03168152602001866001600160a01b03166001600160a01b0316815250848a8a8a6040518763ffffffff1660e01b81526004016116a8969594939291906153fc565b60006040518083038186803b1580156116c057600080fd5b505af41580156116d4573d6000803e3d6000fd5b5050505060008a6000600281106116ed576116ed614e9e565b6020020160208101906117009190615010565b6001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561173d573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061176191906151b1565b60405163095ea7b360e01b81529091506001600160a01b0385169063095ea7b39061179490849060001990600401615487565b6020604051808303816000875af11580156117b3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117d791906154a0565b5060405163095ea7b360e01b81526001600160a01b0384169063095ea7b39061180890849060001990600401615487565b6020604051808303816000875af1158015611827573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061184b91906154a0565b5060405163095ea7b360e01b81526001600160a01b0385169063095ea7b39061188a90600080516020615a0d8339815191529060001990600401615487565b6020604051808303816000875af11580156118a9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118cd91906154a0565b5060405163095ea7b360e01b81526001600160a01b0384169063095ea7b39061190c90600080516020615a0d8339815191529060001990600401615487565b6020604051808303816000875af115801561192b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061194f91906154a0565b50505050505050505050505050565b604080516002808252606080830184529260208301908036833750508354604080516339db007960e21b815290519394506000936001600160a01b03909216925063e76c01e49160048083019260e09291908290030181865afa1580156119c9573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119ed91906154e0565b505050506003860154600480880154604051630544f36560e31b815295965073__$5ce7b97fe3b9dad27bffcf1c56869f0b10$__95632a279b289550611a5f94508793600160c81b8104600290810b94600160e01b909204900b92630100000090046001600160801b0316910161556f565b6040805180830381865af4158015611a7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a9f9190614e14565b83600081518110611ab257611ab2614e9e565b6020026020010184600181518110611acc57611acc614e9e565b6020908102919091010191909152526003830154600160a81b900460ff1615611b625781600181518110611b0257611b02614e9e565b602002602001015182600081518110611b1d57611b1d614e9e565b602002602001015183600081518110611b3857611b38614e9e565b6020026020010184600181518110611b5257611b52614e9e565b6020908102919091010191909152525b50919050565b606060008360000160009054906101000a90046001600160a01b03166001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa158015611bc1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611be591906154e0565b5094955060029450611bf79350505050565b604051908082528060200260200182016040528015611c20578160200160208202803683370190505b506003850154604051630544f36560e31b815291935073__$5ce7b97fe3b9dad27bffcf1c56869f0b10$__91632a279b2891611c7a918591600160c81b8104600290810b92600160e01b909204900b90899060040161556f565b6040805180830381865af4158015611c96573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611cba9190614e14565b83600081518110611ccd57611ccd614e9e565b6020026020010184600181518110611ce757611ce7614e9e565b6020908102919091010191909152526003840154600160a81b900460ff1615611d7d5781600181518110611d1d57611d1d614e9e565b602002602001015182600081518110611d3857611d38614e9e565b602002602001015183600081518110611d5357611d53614e9e565b6020026020010184600181518110611d6d57611d6d614e9e565b6020908102919091010191909152525b5092915050565b6040805160a081018252600384015460ff600160a81b8204161515808352600060208401819052601187015494840194909452600160c81b8204600290810b606085810191909152600160e01b909304900b60808401529092919082908190611e0357600287015460038801546001600160a01b039182169116611e1b565b600387015460028801546001600160a01b0391821691165b8451919350915015611e9a5785600181518110611e3a57611e3a614e9e565b602002602001015186600081518110611e5557611e55614e9e565b602002602001015187600081518110611e7057611e70614e9e565b6020026020010188600181518110611e8a57611e8a614e9e565b6020908102919091010191909152525b6040805160028082526060820183529091602083019080368337505050604084015190955015611fe357604083810151905163133f757160e31b815260048101919091526000908190600080516020615a0d833981519152906399fbab889060240161016060405180830381865afa158015611f1a573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611f3e91906155ad565b50505050509550955050505050846060015160020b8260020b141580611f6e5750846080015160020b8160020b14155b15611fe0576040858101519051630852cd8d60e31b81526004810191909152600080516020615a0d833981519152906342966c6890602401600060405180830381600087803b158015611fc057600080fd5b505af1158015611fd4573d6000803e3d6000fd5b50506000604088015250505b50505b6000611fee88613bef565b905083604001516000036121f757600080516020615a0d8339815191526001600160a01b0316639cc1a283604051806101400160405280866001600160a01b03168152602001856001600160a01b03168152602001876060015160020b8152602001876080015160020b81526020018a60008151811061207057612070614e9e565b602002602001015181526020018a60018151811061209057612090614e9e565b602002602001015181526020016000815260200160008152602001306001600160a01b03168152602001428152506040518263ffffffff1660e01b81526004016120da9190615684565b6080604051808303816000875af11580156120f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061211d919061572f565b87604001886020018b60008151811061213857612138614e9e565b602002602001018c60018151811061215257612152614e9e565b6020908102919091010193909352929091526001600160801b0390921690525260408085015160118a018190559051632142170760e11b8152600080516020615a0d833981519152916342842e0e916121c0913091600080516020615a2d8339815191529190600401614f40565b600060405180830381600087803b1580156121da57600080fd5b505af11580156121ee573d6000803e3d6000fd5b5050505061264b565b600080516020615a0d8339815191526001600160a01b031663219f5d176040518060c00160405280876040015181526020018a60008151811061223c5761223c614e9e565b602002602001015181526020018a60018151811061225c5761225c614e9e565b602002602001015181526020016000815260200160008152602001428152506040518263ffffffff1660e01b81526004016122d69190600060c082019050825182526020830151602083015260408301516040830152606083015160608301526080830151608083015260a083015160a083015292915050565b6060604051808303816000875af11580156122f5573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612319919061576d565b866020018960008151811061233057612330614e9e565b602002602001018a60018151811061234a5761234a614e9e565b60209081029190910101929092529190526001600160801b03918216905260048901546301000000900416156125d15760408085015190516307cf0b0f60e31b81526000918291600080516020615a2d83398151915291633e785878916123b5918791600401614df9565b60408051808303816000875af11580156123d3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906123f79190614e14565b6040808901519051630d099f2f60e21b8152929450909250600080516020615a2d833981519152916334267cbc9161243791879190600090600401614e38565b600060405180830381600087803b15801561245157600080fd5b505af1158015612465573d6000803e3d6000fd5b5050505060018a01546001600160a01b031682156125215760128b0154604051633f46232960e21b81526001600160a01b0390911690600080516020615a2d8339815191529063fd188ca4906124c690849030906000908a90600401614e5c565b6020604051808303816000875af11580156124e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125099190614e85565b935061251f6001600160a01b0382168386613c65565b505b81156125c95760138b0154604051633f46232960e21b81526001600160a01b0390911690600080516020615a2d8339815191529063fd188ca49061257090849030906000908990600401614e5c565b6020604051808303816000875af115801561258f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125b39190614e85565b92506121ee6001600160a01b0382168385613c65565b50505061264b565b6040808501519051632142170760e11b8152600080516020615a0d833981519152916342842e0e91612618913091600080516020615a2d8339815191529190600401614f40565b600060405180830381600087803b15801561263257600080fd5b505af1158015612646573d6000803e3d6000fd5b505050505b6040808501519051631143967160e11b8152600080516020615a2d833981519152916322872ce2916126869185916000908190600401614f64565b600060405180830381600087803b1580156126a057600080fd5b505af11580156126b4573d6000803e3d6000fd5b5050505060208401516004890180546003906126e1908490630100000090046001600160801b03166157a4565b92506101000a8154816001600160801b0302191690836001600160801b0316021790555083602001516001600160801b03169450505050509250929050565b6002810154604080516395d89b4160e01b815290516060926001600160a01b0316916395d89b419160048083019260009291908290030181865afa15801561276c573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612794919081019061532b565b8260030160009054906101000a90046001600160a01b03166001600160a01b03166395d89b416040518163ffffffff1660e01b8152600401600060405180830381865afa1580156127e9573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612811919081019061532b565b6040516020016128229291906157c4565b6040516020818303038152906040529050919050565b60606128426145a3565b61285a8161285360208b018b615010565b8b86613dbb565b885460405163ecc8941960e01b8152600091829173__$461d2a13b6c4ece874725da1f5491a2777$__9163ecc89419916128a0916001600160a01b0316906004016151e7565b602060405180830381865af41580156128bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906128e19190615206565b602084015160405163498162cf60e01b8152600481018e90526001600160a01b039091166024820152600282900b604482015290915073__$b1ba452cecccdd06eb05ace2d0a762c7e1$__9063498162cf9060640160a060405180830381865af4158015612953573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129779190615223565b61010086015260e0850152915081156129ff5773__$b1ba452cecccdd06eb05ace2d0a762c7e1$__636280ea0e8c8560e001518661010001516040518463ffffffff1660e01b81526004016129ce9392919061582a565b60006040518083038186803b1580156129e657600080fd5b505af41580156129fa573d6000803e3d6000fd5b505050505b851580612a095750815b604051806040016040528060188152602001771054cb4e48139bc81c9958985b185b98d9481b995959195960421b81525090612a585760405162461bcd60e51b81526004016103bf9190614b3d565b508115612bf057600073__$461d2a13b6c4ece874725da1f5491a2777$__63e4ee4bf78c8e8c8e8d8a60c00151896040518863ffffffff1660e01b8152600401612aa897969594939291906158d5565b60006040518083038186803b158015612ac057600080fd5b505af4158015612ad4573d6000803e3d6000fd5b50505050600073__$8f1afe7577f9ab973017c74eca19b86f3c$__63ac2a37d686602001518d886060015189608001518a60c001516040518663ffffffff1660e01b8152600401612b2995949392919061595b565b600060405180830381865af4158015612b46573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052612b6e919081019061598f565b965090508015612bac57612ba989828f60010160009054906101000a90046001600160a01b0316886060015189608001518a60400151613cea565b91505b60408051828152602081018c90529081018390527f83387a3342ff1ebc5e437dc9ae0f98274afda12a11cf547eebec05a3e0b8f8a79060600160405180910390a150505b5050505b979650505050505050565b612c0c6020820182615010565b6012830180546001600160a01b0319166001600160a01b0392909216919091179055612c3e6040820160208301615010565b6013830180546001600160a01b0319166001600160a01b03929092169190911790556060810135601483015560800135601590910155565b6040805160c0810182526000918101829052606081018290526080810182905260a0810182905260028501546001600160a01b03908116825260038601548116602083015260018601546004870154911690630100000090046001600160801b03161561305b57601286015460138701546001600160a01b0391821691166000612cff89613bef565b9050600080600080516020615a2d8339815191526001600160a01b031663de2356d16040518163ffffffff1660e01b8152600401602060405180830381865afa158015612d50573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d7491906151b1565b6001600160a01b031663704972f4848d601101546040518363ffffffff1660e01b8152600401612da5929190614df9565b6040805180830381865afa158015612dc1573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612de59190614e14565b6040516370a0823160e01b815291935091506001600160a01b038616906370a0823190612e169089906004016151e7565b602060405180830381865afa158015612e33573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612e579190614e85565b612e619083614fbc565b6040516370a0823160e01b81529092506001600160a01b038516906370a0823190612e909089906004016151e7565b602060405180830381865afa158015612ead573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ed19190614e85565b612edb9082614fbc565b90506000896001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015612f1d573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f4191906151b1565b90508215612fc05787516040516354ee8a6b60e11b81526001600160a01b0383169163a9dd14d691612f79918a918890600401614f40565b602060405180830381865afa158015612f96573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612fba9190614e85565b60408901525b6060880151156130415787516040516354ee8a6b60e11b81526001600160a01b0383169163a9dd14d691612ffa9189918790600401614f40565b602060405180830381865afa158015613017573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061303b9190614e85565b60608901525b61304a8c610e6e565b60a08a015260808901525050505050505b6003860154600160a81b900460ff16156130815760a08201805160808401805190925290525b81516040516370a0823160e01b81526001600160a01b03909116906370a08231906130b09084906004016151e7565b602060405180830381865afa1580156130cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130f19190614e85565b826080018181516131029190614fbc565b90525060208201516040516370a0823160e01b81526001600160a01b03909116906370a08231906131379084906004016151e7565b602060405180830381865afa158015613154573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131789190614e85565b8260a0018181516131899190614fbc565b905250600061319786613f09565b835160405163b3596f0760e01b81529192506000916001600160a01b0384169163b3596f07916131ca91906004016151e7565b602060405180830381865afa1580156131e7573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061320b9190614e85565b90506000826001600160a01b031663b3596f0786602001516040518263ffffffff1660e01b815260040161323f91906151e7565b602060405180830381865afa15801561325c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132809190614e85565b90506000670de0b6b3a764000083876080015161329d9190614fcf565b6132a79190614ffc565b90506000670de0b6b3a7640000838860a001516132c49190614fcf565b6132ce9190614ffc565b905060648211806132df5750606481115b8061330c57506064670de0b6b3a76400008589604001516133009190614fcf565b61330a9190614ffc565b115b8061333957506064670de0b6b3a764000085896060015161332d9190614fcf565b6133379190614ffc565b115b9750505050505050505b9392505050565b6001810154601182015460408051600480825260a08201909252606093849384936001600160a01b0390921692909160208201608080368337505050600287015481519196506001600160a01b03169086906000906133ab576133ab614e9e565b6001600160a01b03928316602091820292909201015260038701548651911690869060019081106133de576133de614e9e565b6001600160a01b039283166020918202929092010152601287015486519116908690600290811061341157613411614e9e565b6001600160a01b039283166020918202929092010152601387015486519116908690600390811061344457613444614e9e565b6001600160a01b039290921660209283029190910182015260408051600480825260a0820190925291820160808036833701905050925060005b855181101561353c5785818151811061349957613499614e9e565b60200260200101516001600160a01b03166370a08231306040518263ffffffff1660e01b81526004016134cc91906151e7565b602060405180830381865afa1580156134e9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061350d9190614e85565b84828151811061351f5761351f614e9e565b602090810291909101015280613534816151ce565b91505061347e565b5060408051600480825260a08201909252906020820160808036833701905050935060008111801561358157506004860154630100000090046001600160801b031615155b15613a8057604080516080810182528281523060208201526001600160801b038183018190526060820152905163fc6f786560e01b8152600080516020615a2d8339815191529163fc6f7865916135db9190600401614eb4565b60408051808303816000875af11580156135f9573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061361d9190614e14565b8560008151811061363057613630614e9e565b602002602001018660018151811061364a5761364a614e9e565b60200260200101828152508281525050507f15097721483fb2e62f76b9953e3601b26e7cc79208a0191df6fa701c6148744d8460008151811061368f5761368f614e9e565b6020026020010151856001815181106136aa576136aa614e9e565b60200260200101516040516136c9929190918252602082015260400190565b60405180910390a16003860154600160a81b900460ff161561375857836001815181106136f8576136f8614e9e565b60200260200101518460008151811061371357613713614e9e565b60200260200101518560008151811061372e5761372e614e9e565b602002602001018660018151811061374857613748614e9e565b6020908102919091010191909152525b600080516020615a2d833981519152633e78587861377588613bef565b836040518363ffffffff1660e01b8152600401613793929190614df9565b60408051808303816000875af11580156137b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906137d59190614e14565b856002815181106137e8576137e8614e9e565b602002602001018660038151811061380257613802614e9e565b602002602001018281525082815250505060008460028151811061382857613828614e9e565b6020026020010151111561390e57600080516020615a2d8339815191526001600160a01b031663fd188ca48660028151811061386657613866614e9e565b60200260200101513060008860028151811061388457613884614e9e565b60200260200101516040518563ffffffff1660e01b81526004016138ab9493929190614e5c565b6020604051808303816000875af11580156138ca573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138ee9190614e85565b8460028151811061390157613901614e9e565b6020026020010181815250505b60008460038151811061392357613923614e9e565b60200260200101511115613a0957600080516020615a2d8339815191526001600160a01b031663fd188ca48660038151811061396157613961614e9e565b60200260200101513060008860038151811061397f5761397f614e9e565b60200260200101516040518563ffffffff1660e01b81526004016139a69493929190614e5c565b6020604051808303816000875af11580156139c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139e99190614e85565b846003815181106139fc576139fc614e9e565b6020026020010181815250505b7f2f1396dffa36013d7e1df1ec39cb355b5ff604d56e817a88ed2a0d40995adcb884600281518110613a3d57613a3d614e9e565b602002602001015185600381518110613a5857613a58614e9e565b6020026020010151604051613a77929190918252602082015260400190565b60405180910390a15b60005b8551811015613be5576000868281518110613aa057613aa0614e9e565b60200260200101516001600160a01b03166370a08231856040518263ffffffff1660e01b8152600401613ad391906151e7565b602060405180830381865afa158015613af0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b149190614e85565b90508015613bd457868281518110613b2e57613b2e614e9e565b60200260200101516001600160a01b03166323b872dd8530846040518463ffffffff1660e01b8152600401613b6593929190614f40565b6020604051808303816000875af1158015613b84573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613ba891906154a0565b5080868381518110613bbc57613bbc614e9e565b60200260200101818151613bd09190614fbc565b9052505b50613bde816151ce565b9050613a83565b5050509193909250565b6040805160a081018252600080825260208201819052918101829052606081018290526080810191909152506040805160a08101825260128301546001600160a01b0390811682526013840154811660208301528354169181019190915260148201546060820152601590910154608082015290565b613cbb8363a9059cbb60e01b8484604051602401613c84929190615487565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152613fd4565b505050565b6000806000613cce876140a6565b9050613cdc81878787614117565b925092505094509492505050565b60008515613db1576040516367acb54b60e01b8152600481018790526001600160a01b038087166024830152808616604483015280851660648301528316608482015273__$461d2a13b6c4ece874725da1f5491a2777$__906367acb54b9060a401602060405180830381865af4158015613d69573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613d8d9190614e85565b90506000613d9b8288614f0d565b90508015613daf57613daf886000836141e1565b505b9695505050505050565b81546001600160a01b031660408086019190915280518082019091526005830160026000835b82821015613e6d57604080518082019091526005830285018054829060ff166003811115613e1157613e11615814565b6003811115613e2257613e22615814565b815260408051608081019182905260209092019190600184019060049082845b815481526020019060010190808311613e425750505050508152505081526020019060010190613de1565b505050908552506001600160a01b03838116602080870191909152600284015482166060870181905260038501549283166080880152600160a01b90920460ff16151560a087015260009182528290526040902054613ecb9061445a565b60c08501515260808401516001600160a01b0316600090815260208290526040902054613ef79061445a565b60c08501516001602002015250505050565b6000816001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa158015613f49573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613f6d91906151b1565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613faa573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613fce91906151b1565b92915050565b6000614029826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166144729092919063ffffffff16565b805190915015613cbb578080602001905181019061404791906154a0565b613cbb5760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016103bf565b6000816001600160a01b031663e76c01e46040518163ffffffff1660e01b815260040160e060405180830381865afa1580156140e6573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061410a91906154e0565b5093979650505050505050565b6000808061412586866159cb565b905060008460020b8260020b1461414657614141600283615373565b614149565b60005b60405163cd8e20e760e01b815260028a810b600483015282810b602483015287900b604482015290915073__$b1ba452cecccdd06eb05ace2d0a762c7e1$__9063cd8e20e7906064016040805180830381865af41580156141ae573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141d291906153cd565b93509350505094509492505050565b6000836001600160a01b03166338d52e0f6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614221573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061424591906151b1565b90506000846001600160a01b031663fbfa77cf6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614287573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906142ab91906151b1565b90506000826001600160a01b03166370a08231836040518263ffffffff1660e01b81526004016142db91906151e7565b602060405180830381865afa1580156142f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061431c9190614e85565b604051630855081f60e01b815260048101879052602481018690529091506001600160a01b03871690630855081f90604401600060405180830381600087803b15801561436857600080fd5b505af115801561437c573d6000803e3d6000fd5b50506040516370a0823160e01b8152600092506001600160a01b03861691506370a08231906143af9086906004016151e7565b602060405180830381865afa1580156143cc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906143f09190614e85565b905081811161440057600061440a565b61440a8282614f0d565b905084811015614451577fdf392b47ba4bbae72ff7c68976df0acdc2813e181199d2b2f65187eeb0ee610561443f8287614f0d565b60405190815260200160405180910390a15b50505050505050565b600081156144685781613fce565b620186a092915050565b60606110b6848460008585600080866001600160a01b0316858760405161449991906159f0565b60006040518083038185875af1925050503d80600081146144d6576040519150601f19603f3d011682016040523d82523d6000602084013e6144db565b606091505b5091509150612bf4878383876060831561455657825160000361454f576001600160a01b0385163b61454f5760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016103bf565b50816110b6565b6110b6838381511561456b5781518083602001fd5b8060405162461bcd60e51b81526004016103bf9190614b3d565b60405180608001604052806004906020820280368337509192915050565b6040518061012001604052806145b7614606565b815260006020820181905260408201819052606082018190526080820181905260a082015260c0016145e7614633565b81526020016145f4614633565b8152602001614601614633565b905290565b60405180604001604052806002905b61461d614651565b8152602001906001900390816146155790505090565b60405180604001604052806002906020820280368337509192915050565b604080518082019091528060008152602001614601614585565b6001600160801b038116811461468057600080fd5b50565b6000806040838503121561469657600080fd5b8235915060208301356146a88161466b565b809150509250929050565b600081518084526020808501945080840160005b838110156146e3578151875295820195908201906001016146c7565b509495945050505050565b60208152600061334360208301846146b3565b60006020828403121561471357600080fd5b5035919050565b8060808101831015613fce57600080fd5b634e487b7160e01b600052604160045260246000fd5b604080519081016001600160401b03811182821017156147635761476361472b565b60405290565b604051601f8201601f191681016001600160401b03811182821017156147915761479161472b565b604052919050565b60006001600160401b038211156147b2576147b261472b565b50601f01601f191660200190565b600082601f8301126147d157600080fd5b81356147e46147df82614799565b614769565b8181528460208386010111156147f957600080fd5b816020850160208301376000918101602001919091529392505050565b6000806000806000806101a0878903121561483057600080fd5b60a087018881111561484157600080fd5b87965061484e898261471a565b9550506101208701356001600160401b038082111561486c57600080fd5b6148788a838b016147c0565b955061014089013591508082111561488f57600080fd5b5061489c89828a016147c0565b935050610160870135915061018087013590509295509295509295565b82151581526040602082015260006110b660408301846146b3565b6001600160a01b038116811461468057600080fd5b60006001600160401b038211156149025761490261472b565b5060051b60200190565b600082601f83011261491d57600080fd5b8135602061492d6147df836148e9565b82815260059290921b8401810191818101908684111561494c57600080fd5b8286015b84811015613daf5780358352918301918301614950565b6000806000806080858703121561497d57600080fd5b8435614988816148d4565b9350602085810135614999816148d4565b935060408601356001600160401b03808211156149b557600080fd5b818801915088601f8301126149c957600080fd5b81356149d76147df826148e9565b81815260059190911b8301840190848101908b8311156149f657600080fd5b938501935b82851015614a1d578435614a0e816148d4565b825293850193908501906149fb565b965050506060880135925080831115614a3557600080fd5b5050614a438782880161490c565b91505092959194509250565b60008060408385031215614a6257600080fd5b8235915060208301356146a8816148d4565b8060020b811461468057600080fd5b801515811461468057600080fd5b60008060008060808587031215614aa757600080fd5b8435614ab2816148d4565b93506020850135614ac281614a74565b92506040850135614ad281614a74565b91506060850135614ae281614a83565b939692955090935050565b60005b83811015614b08578181015183820152602001614af0565b50506000910152565b60008151808452614b29816020860160208601614aed565b601f01601f19169290920160200192915050565b6020815260006133436020830184614b11565b8060408101831015613fce57600080fd5b6000806000806000806000806101e0898b031215614b7e57600080fd5b88359750614b8f8a60208b01614b50565b96506060890135614b9f81614a74565b95506080890135614baf81614a74565b945060a0890135614bbf816148d4565b935060c0890135614bcf81614a83565b9250614bde8a60e08b0161471a565b9150614bee8a6101608b0161471a565b90509295985092959890939650565b60008060408385031215614c1057600080fd5b8235915060208301356001600160401b03811115614c2d57600080fd5b614c398582860161490c565b9150509250929050565b604081526000614c5660408301856146b3565b90508260208301529392505050565b6000806000806000806000610100888a031215614c8157600080fd5b87359650614c928960208a01614b50565b9550606088013594506080880135935060a0880135614cb0816148d4565b925060c0880135614cc081614a83565b8092505060e0880135905092959891949750929550565b60008082840360c0811215614ceb57600080fd5b8335925060a0601f1982011215614d0157600080fd5b506020830190509250929050565b600080600060608486031215614d2457600080fd5b833592506020840135614d36816148d4565b91506040840135614d46816148d4565b809150509250925092565b606080825284519082018190526000906020906080840190828801845b82811015614d935781516001600160a01b031684529284019290840190600101614d6e565b50505083810382850152614da781876146b3565b9150508281036040840152613db181856146b3565b80516001600160a01b0390811683526020808301518216908401526040808301519091169083015260608082015190830152608090810151910152565b60c08101614e078285614dbc565b8260a08301529392505050565b60008060408385031215614e2757600080fd5b505080516020909101519092909150565b60e08101614e468286614dbc565b8360a083015282151560c0830152949350505050565b6001600160a01b0394851681529290931660208301526040820152606081019190915260800190565b600060208284031215614e9757600080fd5b5051919050565b634e487b7160e01b600052603260045260246000fd5b815181526020808301516001600160a01b0316908201526040808301516001600160801b0390811691830191909152606092830151169181019190915260800190565b634e487b7160e01b600052601160045260246000fd5b81810381811115613fce57613fce614ef7565b6001600160801b03828116828216039080821115611d7d57611d7d614ef7565b6001600160a01b039384168152919092166020820152604081019190915260600190565b6101008101614f738287614dbc565b8460a08301528360c083015282151560e083015295945050505050565b6001600160a01b03949094168452600292830b6020850152910b60408301521515606082015260800190565b80820180821115613fce57613fce614ef7565b8082028115828204841417613fce57613fce614ef7565b634e487b7160e01b600052601260045260246000fd5b60008261500b5761500b614fe6565b500490565b60006020828403121561502257600080fd5b8135613343816148d4565b60808183375050565b60006101c08289835b6005811015615071578135615053816148d4565b6001600160a01b03168352602092830192919091019060010161503f565b50505060808860a08501378061012084015261508f81840188614b11565b90508281036101408401526150a48187614b11565b91505061016082018460005b60028110156150d85781516001600160a01b03168352602092830192909101906001016150b0565b505050826101a0830152979650505050505050565b600082601f8301126150fe57600080fd5b8151602061510e6147df836148e9565b82815260059290921b8401810191818101908684111561512d57600080fd5b8286015b84811015613daf5780518352918301918301615131565b60008060006060848603121561515d57600080fd5b835161516881614a83565b60208501519093506001600160401b0381111561518457600080fd5b615190868287016150ed565b925050604084015190509250925092565b80516151ac816148d4565b919050565b6000602082840312156151c357600080fd5b8151613343816148d4565b6000600182016151e0576151e0614ef7565b5060010190565b6001600160a01b0391909116815260200190565b80516151ac81614a74565b60006020828403121561521857600080fd5b815161334381614a74565b600080600060a0848603121561523857600080fd5b835161524381614a83565b92506020603f8501861361525657600080fd5b61525e614741565b80606087018881111561527057600080fd5b8388015b8181101561529457805161528781614a83565b8452928401928401615274565b5081955088607f8901126152a757600080fd5b6152af614741565b925082915060a08801898111156152c557600080fd5b808210156152ec578151600481106152dd5760008081fd5b845292840192908401906152c5565b50508093505050509250925092565b60006153096147df84614799565b905082815283838301111561531d57600080fd5b613343836020830184614aed565b60006020828403121561533d57600080fd5b81516001600160401b0381111561535357600080fd5b8201601f8101841361536457600080fd5b6110b6848251602084016152fb565b60008160020b8360020b8061538a5761538a614fe6565b627fffff198214600019821416156153a4576153a4614ef7565b90059392505050565b60008260020b8260020b028060020b9150808214611d7d57611d7d614ef7565b600080604083850312156153e057600080fd5b82516153eb81614a74565b60208401519092506146a881614a74565b868152610240810160208083018860005b60048110156154335781516001600160a01b03168352918301919083019060010161540d565b50505060a083018760005b600481101561545e57815160020b8352918301919083019060010161543e565b5050505084151561012083015261547961014083018561502d565b612bf46101c083018461502d565b6001600160a01b03929092168252602082015260400190565b6000602082840312156154b257600080fd5b815161334381614a83565b805161ffff811681146151ac57600080fd5b805160ff811681146151ac57600080fd5b600080600080600080600060e0888a0312156154fb57600080fd5b8751615506816148d4565b602089015190975061551781614a74565b9550615525604089016154bd565b9450615533606089016154bd565b9350615541608089016154cf565b925061554f60a089016154cf565b915060c088015161555f81614a83565b8091505092959891949750929550565b6001600160a01b03949094168452600292830b6020850152910b60408301526001600160801b0316606082015260800190565b80516151ac8161466b565b60008060008060008060008060008060006101608c8e0312156155cf57600080fd5b8b516bffffffffffffffffffffffff811681146155eb57600080fd5b60208d0151909b506155fc816148d4565b60408d0151909a5061560d816148d4565b985061561b60608d016151a1565b975061562960808d016151fb565b965061563760a08d016151fb565b955061564560c08d016155a2565b945060e08c015193506101008c015192506156636101208d016155a2565b91506156726101408d016155a2565b90509295989b509295989b9093969950565b81516001600160a01b03168152610140810160208301516156b060208401826001600160a01b03169052565b5060408301516156c5604084018260020b9052565b5060608301516156da606084018260020b9052565b506080830151608083015260a083015160a083015260c083015160c083015260e083015160e08301526101008084015161571e828501826001600160a01b03169052565b505061012092830151919092015290565b6000806000806080858703121561574557600080fd5b8451935060208501516157578161466b565b6040860151606090960151949790965092505050565b60008060006060848603121561578257600080fd5b835161578d8161466b565b602085015160409095015190969495509392505050565b6001600160801b03818116838216019080821115611d7d57611d7d614ef7565b67020b633b2b13930960c51b8152600083516157e7816008850160208801614aed565b602f60f81b6008918401918201528351615808816009840160208801614aed565b01600901949350505050565b634e487b7160e01b600052602160045260246000fd5b83815260a0810160208083018560005b600281101561585957815115158352918301919083019060010161583a565b505050606083018460005b60028110156158a0578151600480821061588d57634e487b7160e01b6000526021815260246000fd5b5083529183019190830190600101615864565b50505050949350505050565b8060005b60028110156158cf5781518452602093840193909101906001016158b0565b50505050565b6101208101818960005b60028110156159115781356158f3816148d4565b6001600160a01b0316835260209283019291909101906001016158df565b5050506040820188905260608201879052608082018690526001600160a01b03851660a083015261594560c08301856158ac565b8260020b61010083015298975050505050505050565b6001600160a01b0386811682526020820186905284811660408301528316606082015260c08101613db160808301846158ac565b600080604083850312156159a257600080fd5b8251915060208301516001600160401b038111156159bf57600080fd5b614c39858286016150ed565b600282810b9082900b03627fffff198112627fffff82131715613fce57613fce614ef7565b60008251615a02818460208701614aed565b919091019291505056fe0000000000000000000000008ef88e4c7cfbbac1c163f7eddd4b578792201de60000000000000000000000007f281a8cdf66ef5e9db8434ec6d97acc1bc01e7841532d3420496e636f727265637420726562616c616e63655469636b52616e6765a26469706673582212201fc4dfefcba1d22b46a4a7b12929405436463e799531610ef8808c1d2a34966864736f6c63430008110033",
  "libraries": {
    "AlgebraLib": "0xb1450ADeb76257593B97ABdC06ba908300847AAe",
    "AlgebraDebtLib": "0xAbb00AE121f27666607E1a32924eef53693064b3",
    "ConverterStrategyBaseLib2": "0xE11BFbFAf8e53ADC8e67552e8A1607a1b9CB7359",
    "PairBasedStrategyLogicLib": "0x9D7226Fe5fa1b4a470497C4D0573B10F5eB21F0E"
  },
  "devdoc": {
    "kind": "dev",
    "methods": {
      "initStrategyState(AlgebraConverterStrategyLogicLib.State storage,address[2],int24,int24,address,bool,uint256[4],uint256[4])": {
        "params": {
          "controllerPool": "[controller, pool]",
          "fuseThresholdsA": "Fuse thresholds for token A (stable pool only)",
          "fuseThresholdsB": "Fuse thresholds for token B (stable pool only)"
        }
      },
      "needStrategyRebalance(PairBasedStrategyLogicLib.PairState storage,ITetuConverter)": {
        "returns": {
          "needRebalance": "A boolean indicating if {rebalanceNoSwaps} should be called"
        }
      },
      "rebalanceNoSwaps(PairBasedStrategyLogicLib.PairState storage,address[2],uint256,uint256,address,bool,mapping(address => uint256) storage)": {
        "params": {
          "checkNeedRebalance_": "True if the function should ensure that the rebalance is required",
          "converterLiquidator": "[TetuConverter, TetuLiquidator]",
          "totalAssets_": "Current value of totalAssets()"
        },
        "returns": {
          "tokenAmounts": "Token amounts for deposit. If length == 0 - rebalance wasn't made and no deposit is required."
        }
      },
      "withdrawByAggStep(address[5],uint256[4],bytes,bytes,PairBasedStrategyLogicLib.PairState storage,mapping(address => uint256) storage)": {
        "params": {
          "addr_": "[tokenToSwap, aggregator, controller, converter, splitter]",
          "values_": "[amountToSwap_, profitToCover, oldTotalAssets, entryToPool]"
        },
        "returns": {
          "completed": "All debts were closed, leftovers were swapped to proper proportions",
          "tokenAmountsOut": "Amounts to be deposited to pool. This array is empty if no deposit allowed/required."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "getPropNotUnderlying18(PairBasedStrategyLogicLib.PairState storage)": {
        "notice": "Get proportion of not-underlying in the pool, [0...1e18]         prop.underlying : prop.not.underlying = 1e18 - PropNotUnderlying18 : propNotUnderlying18"
      },
      "needStrategyRebalance(PairBasedStrategyLogicLib.PairState storage,ITetuConverter)": {
        "notice": "Determine if the strategy needs to be rebalanced."
      },
      "rebalanceNoSwaps(PairBasedStrategyLogicLib.PairState storage,address[2],uint256,uint256,address,bool,mapping(address => uint256) storage)": {
        "notice": "Make rebalance without swaps (using borrowing only)."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}