{
  "address": "0x9AA5a4e6245b57885984334c3C3007A02dAb5434",
  "abi": [
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "controller",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "ts",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "block",
          "type": "uint256"
        }
      ],
      "name": "ContractInitialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint8",
          "name": "version",
          "type": "uint8"
        }
      ],
      "name": "Initialized",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "withdrawnAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "OnDepositorEmergencyExit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "amounts",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "consumedAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "OnDepositorEnter",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "liquidityAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "withdrawnAmounts",
          "type": "uint256[]"
        }
      ],
      "name": "OnDepositorExit",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "investedAssetsNewPrices",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "earnedByPrices",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "earnedHandleRewards",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lostHandleRewards",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "earnedDeposit",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "lostDeposit",
          "type": "uint256"
        }
      ],
      "name": "OnHardWorkEarnedLost",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address[]",
          "name": "rewardTokens",
          "type": "address[]"
        },
        {
          "indexed": false,
          "internalType": "uint256[]",
          "name": "amountsToForward",
          "type": "uint256[]"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "toPerf",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "toInsurance",
          "type": "uint256"
        }
      ],
      "name": "Recycle",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "RevisionIncreased",
      "type": "event"
    },
    {
      "inputs": [],
      "name": "BALANCER_BOOSTED_DEPOSITOR_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CONTROLLABLE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "CONVERTER_STRATEGY_BASE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "NAME",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "PLATFORM",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "STRATEGY_BASE_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "STRATEGY_VERSION",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "asset",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "calcInvestedAssets",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "capacity",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "claim",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "compoundRatio",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "controller",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "converter",
      "outputs": [
        {
          "internalType": "contract ITetuConverter",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "created",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "createdBlock",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "doHardWork",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "earned",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "lost",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "emergencyExit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "gauge",
      "outputs": [
        {
          "internalType": "contract IBalancerGauge",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "oldLogic",
          "type": "address"
        }
      ],
      "name": "increaseRevision",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "controller_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "splitter_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "converter_",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "pool_",
          "type": "address"
        }
      ],
      "name": "init",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        },
        {
          "internalType": "bool",
          "name": "updateTotalAssetsBeforeInvest_",
          "type": "bool"
        }
      ],
      "name": "investAll",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "strategyLoss",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "investedAssets",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_value",
          "type": "address"
        }
      ],
      "name": "isController",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_value",
          "type": "address"
        }
      ],
      "name": "isGovernance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "isReadyToHardWork",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "liquidationThresholds",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address[]",
          "name": "assets_",
          "type": "address[]"
        },
        {
          "internalType": "uint256[]",
          "name": "amounts_",
          "type": "uint256[]"
        }
      ],
      "name": "onTransferAmounts",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "performanceFee",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "performanceFeeRatio",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "performanceReceiver",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "poolId",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "previousImplementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "reinvestThresholdPercent",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "theAsset_",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount_",
          "type": "uint256"
        }
      ],
      "name": "requirePayAmountBack",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "revision",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rewardTokens",
      "outputs": [
        {
          "internalType": "address[]",
          "name": "tokens",
          "type": "address[]"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "value",
          "type": "uint256"
        }
      ],
      "name": "setCompoundRatio",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "token",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "setLiquidationThreshold",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "ratio_",
          "type": "uint256"
        }
      ],
      "name": "setPerformanceFeeRatio",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "percent_",
          "type": "uint256"
        }
      ],
      "name": "setReinvestThresholdPercent",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "string",
          "name": "name",
          "type": "string"
        }
      ],
      "name": "setStrategySpecificName",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "fee_",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "receiver_",
          "type": "address"
        }
      ],
      "name": "setupPerformanceFee",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "splitter",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "strategySpecificName",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "interfaceId",
          "type": "bytes4"
        }
      ],
      "name": "supportsInterface",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalAssets",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "withdrawAllToSplitter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "strategyLoss",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "amount",
          "type": "uint256"
        }
      ],
      "name": "withdrawToSplitter",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "strategyLoss",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0xed74fbe603bbd5e109f62b6bdc1ad8991763eeb937b2e37b0d93fffe9197439f",
  "receipt": {
    "to": null,
    "from": "0xbbbbb8C4364eC2ce52c59D2Ed3E56F307E529a94",
    "contractAddress": "0x9AA5a4e6245b57885984334c3C3007A02dAb5434",
    "transactionIndex": 47,
    "gasUsed": "4748660",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000008000000000000000000000000000000000400000000000000000000000800000000000800000000100000000000000000000000000000000000000000000000000000000000080000000000000000040000000040000000000000000000000000000000080000000000000000000200000000000000000000000000400000000000000000000000000000000004000000000000000000001000000040000008000000000000000120000000000000000000000000000000000000000000000000000000002000000080000100000",
    "blockHash": "0xeeb3f8402bb8e3827e46487dc0a88c60a3c3f110eaac2375a5662fc6d904d11c",
    "transactionHash": "0xed74fbe603bbd5e109f62b6bdc1ad8991763eeb937b2e37b0d93fffe9197439f",
    "logs": [
      {
        "transactionIndex": 47,
        "blockNumber": 43744816,
        "transactionHash": "0xed74fbe603bbd5e109f62b6bdc1ad8991763eeb937b2e37b0d93fffe9197439f",
        "address": "0x9AA5a4e6245b57885984334c3C3007A02dAb5434",
        "topics": [
          "0x7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb3847402498"
        ],
        "data": "0x00000000000000000000000000000000000000000000000000000000000000ff",
        "logIndex": 195,
        "blockHash": "0xeeb3f8402bb8e3827e46487dc0a88c60a3c3f110eaac2375a5662fc6d904d11c"
      },
      {
        "transactionIndex": 47,
        "blockNumber": 43744816,
        "transactionHash": "0xed74fbe603bbd5e109f62b6bdc1ad8991763eeb937b2e37b0d93fffe9197439f",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000bbbbb8c4364ec2ce52c59d2ed3e56f307e529a94",
          "0x0000000000000000000000009ead03f7136fc6b4bdb0780b00a1c14ae5a8b6d0"
        ],
        "data": "0x000000000000000000000000000000000000000000000000020afd507e3b78000000000000000000000000000000000000000000000000038401c252ebacabc500000000000000000000000000000000000000000000060c11c846f4cc5cb49b00000000000000000000000000000000000000000000000381f6c5026d7133c500000000000000000000000000000000000000000000060c13d344454a982c9b",
        "logIndex": 196,
        "blockHash": "0xeeb3f8402bb8e3827e46487dc0a88c60a3c3f110eaac2375a5662fc6d904d11c"
      }
    ],
    "blockNumber": 43744816,
    "cumulativeGasUsed": "12113452",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 6,
  "solcInputHash": "26c6b397cd96df26aa08cb428a27c8ff",
  "metadata": "{\"compiler\":{\"version\":\"0.8.17+commit.8df45f5f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"ContractInitialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint8\",\"name\":\"version\",\"type\":\"uint8\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"withdrawnAmounts\",\"type\":\"uint256[]\"}],\"name\":\"OnDepositorEmergencyExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"consumedAmounts\",\"type\":\"uint256[]\"}],\"name\":\"OnDepositorEnter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"liquidityAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"withdrawnAmounts\",\"type\":\"uint256[]\"}],\"name\":\"OnDepositorExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"investedAssetsNewPrices\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnedByPrices\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnedHandleRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lostHandleRewards\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"earnedDeposit\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"lostDeposit\",\"type\":\"uint256\"}],\"name\":\"OnHardWorkEarnedLost\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address[]\",\"name\":\"rewardTokens\",\"type\":\"address[]\"},{\"indexed\":false,\"internalType\":\"uint256[]\",\"name\":\"amountsToForward\",\"type\":\"uint256[]\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toPerf\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"toInsurance\",\"type\":\"uint256\"}],\"name\":\"Recycle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"RevisionIncreased\",\"type\":\"event\"},{\"inputs\":[],\"name\":\"BALANCER_BOOSTED_DEPOSITOR_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONTROLLABLE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"CONVERTER_STRATEGY_BASE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"PLATFORM\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STRATEGY_BASE_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"STRATEGY_VERSION\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"asset\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"calcInvestedAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"capacity\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"compoundRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"converter\",\"outputs\":[{\"internalType\":\"contract ITetuConverter\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"created\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"createdBlock\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"doHardWork\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"earned\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"lost\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"emergencyExit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"gauge\",\"outputs\":[{\"internalType\":\"contract IBalancerGauge\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"oldLogic\",\"type\":\"address\"}],\"name\":\"increaseRevision\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"controller_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"splitter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"converter_\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"pool_\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"updateTotalAssetsBeforeInvest_\",\"type\":\"bool\"}],\"name\":\"investAll\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyLoss\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"investedAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isController\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_value\",\"type\":\"address\"}],\"name\":\"isGovernance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"isReadyToHardWork\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"liquidationThresholds\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"assets_\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"amounts_\",\"type\":\"uint256[]\"}],\"name\":\"onTransferAmounts\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFee\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceFeeRatio\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"performanceReceiver\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"poolId\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"previousImplementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"reinvestThresholdPercent\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"theAsset_\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount_\",\"type\":\"uint256\"}],\"name\":\"requirePayAmountBack\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"revision\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardTokens\",\"outputs\":[{\"internalType\":\"address[]\",\"name\":\"tokens\",\"type\":\"address[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setCompoundRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"token\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setLiquidationThreshold\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"ratio_\",\"type\":\"uint256\"}],\"name\":\"setPerformanceFeeRatio\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"percent_\",\"type\":\"uint256\"}],\"name\":\"setReinvestThresholdPercent\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"string\",\"name\":\"name\",\"type\":\"string\"}],\"name\":\"setStrategySpecificName\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"fee_\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"receiver_\",\"type\":\"address\"}],\"name\":\"setupPerformanceFee\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"splitter\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"strategySpecificName\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalAssets\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"withdrawAllToSplitter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyLoss\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToSplitter\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"strategyLoss\",\"type\":\"uint256\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"author\":\"a17, dvpublic\",\"kind\":\"dev\",\"methods\":{\"claim()\":{\"details\":\"Manual claim rewards.\"},\"created()\":{\"returns\":{\"_0\":\"Creation timestamp\"}},\"createdBlock()\":{\"returns\":{\"_0\":\"Creation block number\"}},\"doHardWork()\":{\"returns\":{\"earned\":\"Earned amount in terms of {asset}\",\"lost\":\"Lost amount in terms of {asset}\"}},\"emergencyExit()\":{\"details\":\"In case of any issue operator can withdraw all from pool.\"},\"increaseRevision(address)\":{\"details\":\"Revision should be increased on each contract upgrade\"},\"investAll(uint256,bool)\":{\"params\":{\"updateTotalAssetsBeforeInvest_\":\"Recalculate total assets amount before depositing.                                       It can be false if we know exactly, that the amount is already actual.\"},\"returns\":{\"strategyLoss\":\"Loss should be covered from Insurance\"}},\"isController(address)\":{\"details\":\"Return true if given address is controller\"},\"onTransferAmounts(address[],uint256[])\":{\"params\":{\"amounts_\":\"Amount of {asset_} that has been sent to the user's balance\",\"assets_\":\"Any asset sent to the balance, i.e. inside repayTheBorrow\"}},\"previousImplementation()\":{\"details\":\"Previous logic implementation\"},\"requirePayAmountBack(address,uint256)\":{\"params\":{\"amount_\":\"Required amount of the {theAsset_}\",\"theAsset_\":\"Required asset (either collateral or borrow)\"},\"returns\":{\"amountOut\":\"Amount sent to balance of TetuConverter, amountOut <= amount_\"}},\"revision()\":{\"details\":\"Contract upgrade counter\"},\"rewardTokens()\":{\"details\":\"Returns reward token addresses array.\"},\"setCompoundRatio(uint256)\":{\"details\":\"PlatformVoter can change compound ratio for some strategies.      A strategy can implement another logic for some uniq cases.\"},\"setReinvestThresholdPercent(uint256)\":{\"params\":{\"percent_\":\"New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\"}},\"setStrategySpecificName(string)\":{\"details\":\"The name will be used for UI.\"},\"supportsInterface(bytes4)\":{\"details\":\"See {IERC165-supportsInterface}.\"},\"totalAssets()\":{\"details\":\"Total amount of underlying assets under control of this strategy.\"},\"withdrawAllToSplitter()\":{\"details\":\"Withdraws all underlying assets to the vault\",\"returns\":{\"strategyLoss\":\"Loss should be covered from Insurance\"}},\"withdrawToSplitter(uint256)\":{\"details\":\"Withdraws some assets to the splitter\",\"returns\":{\"strategyLoss\":\"Loss should be covered from Insurance\"}}},\"title\":\"Delta-neutral converter strategy for Balancer boosted pools\",\"version\":1},\"userdoc\":{\"events\":{\"Recycle(address[],uint256[],uint256,uint256)\":{\"notice\":\"Recycle was made\"}},\"kind\":\"user\",\"methods\":{\"CONTROLLABLE_VERSION()\":{\"notice\":\"Version of the contract\"},\"capacity()\":{\"notice\":\"Unlimited capacity by default\"},\"controller()\":{\"notice\":\"Return controller address saved in the contract slot\"},\"created()\":{\"notice\":\"Return creation timestamp\"},\"createdBlock()\":{\"notice\":\"Return creation block number\"},\"doHardWork()\":{\"notice\":\"Do hard work with reinvesting\"},\"investAll(uint256,bool)\":{\"notice\":\"Stakes everything the strategy holds into the reward pool. amount_ Amount transferred to the strategy balance just before calling this function\"},\"investedAssets()\":{\"notice\":\"Amount of underlying assets converted to pool assets and invested to the pool.\"},\"isGovernance(address)\":{\"notice\":\"Return true if given address is setup as governance in Controller\"},\"isReadyToHardWork()\":{\"notice\":\"Is strategy ready to hard work\"},\"liquidationThresholds(address)\":{\"notice\":\"Minimum token amounts that can be liquidated\"},\"onTransferAmounts(address[],uint256[])\":{\"notice\":\"TetuConverter calls this function when it sends any amount to user's balance\"},\"performanceFee()\":{\"notice\":\"A percent of total profit that is sent to the {performanceReceiver} before compounding\"},\"performanceFeeRatio()\":{\"notice\":\"Ratio to split performance fee on toPerf + toInsurance, [0..100_000]         100_000 - send full amount toPerf, 0 - send full amount toInsurance.\"},\"performanceReceiver()\":{\"notice\":\"{performanceFee}% of total profit is sent to {performanceReceiver} before compounding\"},\"poolId()\":{\"notice\":\"i.e. for \\\"Balancer Boosted Aave USD\\\": 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075bi.e. for \\\"Balancer Boosted Tetu USD\\\": 0xb3d658d5b95bf04e2932370dd1ff976fe18dd66a000000000000000000000ace\"},\"reinvestThresholdPercent()\":{\"notice\":\"Percent of asset amount that can be not invested, it's allowed to just keep it on balance         decimals = {DENOMINATOR}\"},\"requirePayAmountBack(address,uint256)\":{\"notice\":\"Converters asks to send some amount back.\"},\"setPerformanceFeeRatio(uint256)\":{\"notice\":\"[0..100_000], 100_000 - send full amount toPerf, 0 - send full amount toInsurance.\"},\"setupPerformanceFee(uint256,address)\":{\"notice\":\"Set performance fee and receiver\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/strategies/balancer/BalancerBoostedStrategy.sol\":\"BalancerBoostedStrategy\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":150},\"remappings\":[]},\"sources\":{\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IControllable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IControllable {\\n\\n  function isController(address _contract) external view returns (bool);\\n\\n  function isGovernance(address _contract) external view returns (bool);\\n\\n  function created() external view returns (uint256);\\n\\n  function createdBlock() external view returns (uint256);\\n\\n  function controller() external view returns (address);\\n\\n  function increaseRevision(address oldLogic) external;\\n\\n}\\n\",\"keccak256\":\"0xc2ef11f0141e7e1a5df255be2e1552044deed377349cb886908f3f10ded57fa8\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IController {\\n\\n  // --- DEPENDENCY ADDRESSES\\n  function governance() external view returns (address);\\n\\n  function voter() external view returns (address);\\n\\n  function liquidator() external view returns (address);\\n\\n  function forwarder() external view returns (address);\\n\\n  function investFund() external view returns (address);\\n\\n  function veDistributor() external view returns (address);\\n\\n  function platformVoter() external view returns (address);\\n\\n  // --- VAULTS\\n\\n  function vaults(uint id) external view returns (address);\\n\\n  function vaultsList() external view returns (address[] memory);\\n\\n  function vaultsListLength() external view returns (uint);\\n\\n  function isValidVault(address _vault) external view returns (bool);\\n\\n  // --- restrictions\\n\\n  function isOperator(address _adr) external view returns (bool);\\n\\n\\n}\\n\",\"keccak256\":\"0x86716b8a4775605c31b8bb9f90f8f4a18b709ff4435182f3a148803368060a8c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC165 standard, as defined in the\\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\\n *\\n * Implementers can declare support of contract interfaces, which can then be\\n * queried by others ({ERC165Checker}).\\n *\\n * For an implementation, see {ERC165}.\\n */\\ninterface IERC165 {\\n  /**\\n   * @dev Returns true if this contract implements the interface defined by\\n   * `interfaceId`. See the corresponding\\n   * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\\n   * to learn more about how these ids are created.\\n   *\\n   * This function call must use less than 30 000 gas.\\n   */\\n  function supportsInterface(bytes4 interfaceId) external view returns (bool);\\n}\\n\",\"keccak256\":\"0xaeca7db2074d7c66a20c609539e1f1656e67f6981bf01f83ad6aa8aa140c8d2e\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n  /**\\n   * @dev Returns the amount of tokens in existence.\\n   */\\n  function totalSupply() external view returns (uint);\\n\\n  /**\\n   * @dev Returns the amount of tokens owned by `account`.\\n   */\\n  function balanceOf(address account) external view returns (uint);\\n\\n  /**\\n   * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transfer(address recipient, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Returns the remaining number of tokens that `spender` will be\\n   * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n   * zero by default.\\n   *\\n   * This value changes when {approve} or {transferFrom} are called.\\n   */\\n  function allowance(address owner, address spender) external view returns (uint);\\n\\n  /**\\n   * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n   * that someone may use both the old and the new allowance by unfortunate\\n   * transaction ordering. One possible solution to mitigate this race\\n   * condition is to first reduce the spender's allowance to 0 and set the\\n   * desired value afterwards:\\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n   *\\n   * Emits an {Approval} event.\\n   */\\n  function approve(address spender, uint amount) external returns (bool);\\n\\n  /**\\n   * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n   * allowance mechanism. `amount` is then deducted from the caller's\\n   * allowance.\\n   *\\n   * Returns a boolean value indicating whether the operation succeeded.\\n   *\\n   * Emits a {Transfer} event.\\n   */\\n  function transferFrom(\\n    address sender,\\n    address recipient,\\n    uint amount\\n  ) external returns (bool);\\n\\n  /**\\n   * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n   * another (`to`).\\n   *\\n   * Note that `value` may be zero.\\n   */\\n  event Transfer(address indexed from, address indexed to, uint value);\\n\\n  /**\\n   * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n   * a call to {approve}. `value` is the new allowance.\\n   */\\n  event Approval(address indexed owner, address indexed spender, uint value);\\n}\\n\",\"keccak256\":\"0x5f43ed533d0fc4dc2f8f081d2c4b77960f3e908d5f7359096b385e5673f1ba0c\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IERC20.sol\\\";\\n\\n/**\\n * https://github.com/OpenZeppelin/openzeppelin-contracts-upgradeable/blob/release-v4.6/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol\\n * @dev Interface for the optional metadata functions from the ERC20 standard.\\n *\\n * _Available since v4.1._\\n */\\ninterface IERC20Metadata is IERC20 {\\n  /**\\n   * @dev Returns the name of the token.\\n     */\\n  function name() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the symbol of the token.\\n     */\\n  function symbol() external view returns (string memory);\\n\\n  /**\\n   * @dev Returns the decimals places of the token.\\n     */\\n  function decimals() external view returns (uint8);\\n}\\n\",\"keccak256\":\"0x953f20efa64081a325109a0e03602b889d2819c2b51c1e1fb21a062feeda74f3\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n */\\ninterface IERC20Permit {\\n  /**\\n   * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     */\\n  function permit(\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) external;\\n\\n  /**\\n   * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n  function nonces(address owner) external view returns (uint256);\\n\\n  /**\\n   * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n  // solhint-disable-next-line func-name-mixedcase\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0x9f69f84d864c2a84de9321871aa52f6f70d14afe46badbcd37c0d4f22af75e7b\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IForwarder {\\n\\n  function tetu() external view returns (address);\\n  function tetuThreshold() external view returns (uint);\\n\\n  function tokenPerDestinationLength(address destination) external view returns (uint);\\n\\n  function tokenPerDestinationAt(address destination, uint i) external view returns (address);\\n\\n  function amountPerDestination(address token, address destination) external view returns (uint amount);\\n\\n  function registerIncome(\\n    address[] memory tokens,\\n    uint[] memory amounts,\\n    address vault,\\n    bool isDistribute\\n  ) external;\\n\\n  function distributeAll(address destination) external;\\n\\n  function distribute(address token) external;\\n\\n  function setInvestFundRatio(uint value) external;\\n\\n  function setGaugesRatio(uint value) external;\\n\\n}\\n\",\"keccak256\":\"0x687c497fc034e8d64bca403bac1bf4cd7bd1f107df414c2657325c1b3ab92822\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface ISplitter {\\n\\n  function init(address controller_, address _asset, address _vault) external;\\n\\n  // *************** ACTIONS **************\\n\\n  function withdrawAllToVault() external;\\n\\n  function withdrawToVault(uint256 amount) external;\\n\\n  function coverPossibleStrategyLoss(uint earned, uint lost) external;\\n\\n  function doHardWork() external;\\n\\n  function investAll() external;\\n\\n  // **************** VIEWS ***************\\n\\n  function asset() external view returns (address);\\n\\n  function vault() external view returns (address);\\n\\n  function totalAssets() external view returns (uint256);\\n\\n  function isHardWorking() external view returns (bool);\\n\\n  function strategies(uint i) external view returns (address);\\n\\n  function strategiesLength() external view returns (uint);\\n\\n  function HARDWORK_DELAY() external view returns (uint);\\n\\n  function lastHardWorks(address strategy) external view returns (uint);\\n\\n  function pausedStrategies(address strategy) external view returns (bool);\\n\\n  function pauseInvesting(address strategy) external;\\n\\n  function continueInvesting(address strategy, uint apr) external;\\n\\n}\\n\",\"keccak256\":\"0x68f37a5089c98097159e7f18ef04c42d15e10e6c11602e47bc6092708c11e5fc\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IStrategyV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\ninterface IStrategyV2 {\\n\\n  function NAME() external view returns (string memory);\\n\\n  function strategySpecificName() external view returns (string memory);\\n\\n  function PLATFORM() external view returns (string memory);\\n\\n  function STRATEGY_VERSION() external view returns (string memory);\\n\\n  function asset() external view returns (address);\\n\\n  function splitter() external view returns (address);\\n\\n  function compoundRatio() external view returns (uint);\\n\\n  function totalAssets() external view returns (uint);\\n\\n  /// @dev Usually, indicate that claimable rewards have reasonable amount.\\n  function isReadyToHardWork() external view returns (bool);\\n\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawAllToSplitter() external returns (uint strategyLoss);\\n\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawToSplitter(uint amount) external returns (uint strategyLoss);\\n\\n  /// @notice Stakes everything the strategy holds into the reward pool.\\n  /// @param amount_ Amount transferred to the strategy balance just before calling this function\\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\\n  ///                                       It can be false if we know exactly, that the amount is already actual.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function investAll(\\n    uint amount_,\\n    bool updateTotalAssetsBeforeInvest_\\n  ) external returns (\\n    uint strategyLoss\\n  );\\n\\n  function doHardWork() external returns (uint earned, uint lost);\\n\\n  function setCompoundRatio(uint value) external;\\n\\n  /// @notice Max amount that can be deposited to the strategy (its internal capacity), see SCB-593.\\n  ///         0 means no deposit is allowed at this moment\\n  function capacity() external view returns (uint);\\n\\n  /// @notice {performanceFee}% of total profit is sent to the {performanceReceiver} before compounding\\n  function performanceReceiver() external view returns (address);\\n\\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\\n  /// @dev use FEE_DENOMINATOR\\n  function performanceFee() external view returns (uint);\\n}\\n\",\"keccak256\":\"0xc7dac6097df7310b510f1027ef9c1bd3ccd6a202ca69582f68233ee798f7c312\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface ITetuLiquidator {\\n\\n  struct PoolData {\\n    address pool;\\n    address swapper;\\n    address tokenIn;\\n    address tokenOut;\\n  }\\n\\n  function addLargestPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function addBlueChipsPools(PoolData[] memory _pools, bool rewrite) external;\\n\\n  function getPrice(address tokenIn, address tokenOut, uint amount) external view returns (uint);\\n\\n  function getPriceForRoute(PoolData[] memory route, uint amount) external view returns (uint);\\n\\n  function isRouteExist(address tokenIn, address tokenOut) external view returns (bool);\\n\\n  function buildRoute(\\n    address tokenIn,\\n    address tokenOut\\n  ) external view returns (PoolData[] memory route, string memory errorMessage);\\n\\n  function liquidate(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n  function liquidateWithRoute(\\n    PoolData[] memory route,\\n    uint amount,\\n    uint slippage\\n  ) external;\\n\\n\\n}\\n\",\"keccak256\":\"0xd5fe6f3ab750cc2d23f573597db5607c701e74c39e13c20c07a921a26c6d5012\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IVaultInsurance.sol\\\";\\nimport \\\"./IERC20.sol\\\";\\nimport \\\"./ISplitter.sol\\\";\\n\\ninterface ITetuVaultV2 {\\n\\n  function splitter() external view returns (ISplitter);\\n\\n  function insurance() external view returns (IVaultInsurance);\\n\\n  function depositFee() external view returns (uint);\\n\\n  function withdrawFee() external view returns (uint);\\n\\n  function init(\\n    address controller_,\\n    IERC20 _asset,\\n    string memory _name,\\n    string memory _symbol,\\n    address _gauge,\\n    uint _buffer\\n  ) external;\\n\\n  function setSplitter(address _splitter) external;\\n\\n  function coverLoss(uint amount) external;\\n\\n  function initInsurance(IVaultInsurance _insurance) external;\\n\\n}\\n\",\"keccak256\":\"0x9e77a10b32a52f826d28d17c420f776fd289e5e4f925ec87f7177a1ce224a412\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IVaultInsurance.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IVaultInsurance {\\n\\n  function init(address _vault, address _asset) external;\\n\\n  function vault() external view returns (address);\\n\\n  function asset() external view returns (address);\\n\\n  function transferToVault(uint amount) external;\\n\\n}\\n\",\"keccak256\":\"0x6461572763b1f6decec1dee9d2ffe8ca152369bdc68255ec083cb3da3ce507a1\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/lib/InterfaceIds.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/// @title Library for interface IDs\\n/// @author bogdoslav\\nlibrary InterfaceIds {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant INTERFACE_IDS_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  /// default notation:\\n  /// bytes4 public constant I_VOTER = type(IVoter).interfaceId;\\n\\n  /// As type({Interface}).interfaceId can be changed,\\n  /// when some functions changed at the interface,\\n  /// so used hardcoded interface identifiers\\n\\n  bytes4 public constant I_VOTER = bytes4(keccak256(\\\"IVoter\\\"));\\n  bytes4 public constant I_BRIBE = bytes4(keccak256(\\\"IBribe\\\"));\\n  bytes4 public constant I_GAUGE = bytes4(keccak256(\\\"IGauge\\\"));\\n  bytes4 public constant I_VE_TETU = bytes4(keccak256(\\\"IVeTetu\\\"));\\n  bytes4 public constant I_SPLITTER = bytes4(keccak256(\\\"ISplitter\\\"));\\n  bytes4 public constant I_FORWARDER = bytes4(keccak256(\\\"IForwarder\\\"));\\n  bytes4 public constant I_MULTI_POOL = bytes4(keccak256(\\\"IMultiPool\\\"));\\n  bytes4 public constant I_CONTROLLER = bytes4(keccak256(\\\"IController\\\"));\\n  bytes4 public constant I_TETU_ERC165 = bytes4(keccak256(\\\"ITetuERC165\\\"));\\n  bytes4 public constant I_STRATEGY_V2 = bytes4(keccak256(\\\"IStrategyV2\\\"));\\n  bytes4 public constant I_CONTROLLABLE = bytes4(keccak256(\\\"IControllable\\\"));\\n  bytes4 public constant I_TETU_VAULT_V2 = bytes4(keccak256(\\\"ITetuVaultV2\\\"));\\n  bytes4 public constant I_PLATFORM_VOTER = bytes4(keccak256(\\\"IPlatformVoter\\\"));\\n  bytes4 public constant I_VE_DISTRIBUTOR = bytes4(keccak256(\\\"IVeDistributor\\\"));\\n  bytes4 public constant I_TETU_CONVERTER = bytes4(keccak256(\\\"ITetuConverter\\\"));\\n  bytes4 public constant I_VAULT_INSURANCE = bytes4(keccak256(\\\"IVaultInsurance\\\"));\\n  bytes4 public constant I_STRATEGY_STRICT = bytes4(keccak256(\\\"IStrategyStrict\\\"));\\n  bytes4 public constant I_ERC4626 = bytes4(keccak256(\\\"IERC4626\\\"));\\n\\n}\\n\",\"keccak256\":\"0x7b04986058295c9dbb143dccdb2fc3e9ad38da9d03ef976163b695c394166d9b\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/lib/SlotsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/// @title Library for setting / getting slot variables (used in upgradable proxy contracts)\\n/// @author bogdoslav\\nlibrary SlotsLib {\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant SLOT_LIB_VERSION = \\\"1.0.0\\\";\\n\\n  // ************* GETTERS *******************\\n\\n  /// @dev Gets a slot as bytes32\\n  function getBytes32(bytes32 slot) internal view returns (bytes32 result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as an address\\n  function getAddress(bytes32 slot) internal view returns (address result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot as uint256\\n  function getUint(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  // ************* ARRAY GETTERS *******************\\n\\n  /// @dev Gets an array length\\n  function arrayLength(bytes32 slot) internal view returns (uint result) {\\n    assembly {\\n      result := sload(slot)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function addressAt(bytes32 slot, uint index) internal view returns (address result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  /// @dev Gets a slot array by index as uint\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function uintAt(bytes32 slot, uint index) internal view returns (uint result) {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      result := sload(pointer)\\n    }\\n  }\\n\\n  // ************* SETTERS *******************\\n\\n  /// @dev Sets a slot with bytes32\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, bytes32 value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with address\\n  /// @notice Check address for 0 at the setter\\n  function set(bytes32 slot, address value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot with uint\\n  function set(bytes32 slot, uint value) internal {\\n    assembly {\\n      sstore(slot, value)\\n    }\\n  }\\n\\n  // ************* ARRAY SETTERS *******************\\n\\n  /// @dev Sets a slot array at index with address\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function setAt(bytes32 slot, uint index, address value) internal {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      sstore(pointer, value)\\n    }\\n  }\\n\\n  /// @dev Sets a slot array at index with uint\\n  /// @notice First slot is array length, elements ordered backward in memory\\n  /// @notice This is unsafe, without checking array length.\\n  function setAt(bytes32 slot, uint index, uint value) internal {\\n    bytes32 pointer = bytes32(uint(slot) - 1 - index);\\n    assembly {\\n      sstore(pointer, value)\\n    }\\n  }\\n\\n  /// @dev Sets an array length\\n  function setLength(bytes32 slot, uint length) internal {\\n    assembly {\\n      sstore(slot, length)\\n    }\\n  }\\n\\n  /// @dev Pushes an address to the array\\n  function push(bytes32 slot, address value) internal {\\n    uint length = arrayLength(slot);\\n    setAt(slot, length, value);\\n    setLength(slot, length + 1);\\n  }\\n\\n}\\n\",\"keccak256\":\"0xeb47d071d7ab39d233646b44319ecb2d4d69cd064af8618452822652ce60f23d\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/Address.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n  /**\\n   * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n  function isContract(address account) internal view returns (bool) {\\n    // This method relies on extcodesize/address.code.length, which returns 0\\n    // for contracts in construction, since the code is only stored at the end\\n    // of the constructor execution.\\n\\n    return account.code.length > 0;\\n  }\\n\\n  /**\\n   * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n  function sendValue(address payable recipient, uint256 amount) internal {\\n    require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n    (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n    require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n  }\\n\\n  /**\\n   * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, 0, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value\\n  ) internal returns (bytes memory) {\\n    return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n  function functionCallWithValue(\\n    address target,\\n    bytes memory data,\\n    uint256 value,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n    (bool success, bytes memory returndata) = target.call{value: value}(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n    return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n  function functionStaticCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.staticcall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n    return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n  }\\n\\n  /**\\n   * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n  function functionDelegateCall(\\n    address target,\\n    bytes memory data,\\n    string memory errorMessage\\n  ) internal returns (bytes memory) {\\n    (bool success, bytes memory returndata) = target.delegatecall(data);\\n    return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n  function verifyCallResultFromTarget(\\n    address target,\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal view returns (bytes memory) {\\n    if (success) {\\n      if (returndata.length == 0) {\\n        // only check isContract if the call was successful and the return data is empty\\n        // otherwise we already know that it was a contract\\n        require(isContract(target), \\\"Address: call to non-contract\\\");\\n      }\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  /**\\n   * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n  function verifyCallResult(\\n    bool success,\\n    bytes memory returndata,\\n    string memory errorMessage\\n  ) internal pure returns (bytes memory) {\\n    if (success) {\\n      return returndata;\\n    } else {\\n      _revert(returndata, errorMessage);\\n    }\\n  }\\n\\n  function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n    // Look for revert reason and bubble it up if present\\n    if (returndata.length > 0) {\\n      // The easiest way to bubble the revert reason is using memory via assembly\\n      /// @solidity memory-safe-assembly\\n      assembly {\\n        let returndata_size := mload(returndata)\\n        revert(add(32, returndata), returndata_size)\\n      }\\n    } else {\\n      revert(errorMessage);\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0xcc7eeaafd4384e04ff39e0c01f0a6794736c34cad529751b8abd7b088ecc2e83\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/ERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IERC165.sol\\\";\\n\\n/**\\n * @dev Implementation of the {IERC165} interface.\\n *\\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\\n * for the additional interface id that will be supported. For example:\\n *\\n * ```solidity\\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\\n * }\\n * ```\\n *\\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\\n */\\nabstract contract ERC165 is IERC165 {\\n  /**\\n   * @dev See {IERC165-supportsInterface}.\\n     */\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == type(IERC165).interfaceId;\\n  }\\n}\\n\",\"keccak256\":\"0xcaaf196e5c26fdcd072a9f0833b54cf9fbd12d08be59898f04611f685d31707a\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (proxy/utils/Initializable.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\\n *\\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\\n * reused. This mechanism prevents re-execution of each \\\"step\\\" but allows the creation of new initialization steps in\\n * case an upgrade adds a module that needs to be initialized.\\n *\\n * For example:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * contract MyToken is ERC20Upgradeable {\\n *     function initialize() initializer public {\\n *         __ERC20_init(\\\"MyToken\\\", \\\"MTK\\\");\\n *     }\\n * }\\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\\n *     function initializeV2() reinitializer(2) public {\\n *         __ERC20Permit_init(\\\"MyToken\\\");\\n *     }\\n * }\\n * ```\\n *\\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\\n *\\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\\n *\\n * [CAUTION]\\n * ====\\n * Avoid leaving a contract uninitialized.\\n *\\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\\n *\\n * [.hljs-theme-light.nopadding]\\n * ```\\n * /// @custom:oz-upgrades-unsafe-allow constructor\\n * constructor() {\\n *     _disableInitializers();\\n * }\\n * ```\\n * ====\\n */\\nabstract contract Initializable {\\n  /**\\n   * @dev Indicates that the contract has been initialized.\\n     * @custom:oz-retyped-from bool\\n     */\\n  uint8 private _initialized;\\n\\n  /**\\n   * @dev Indicates that the contract is in the process of being initialized.\\n     */\\n  bool private _initializing;\\n\\n  /**\\n   * @dev Triggered when the contract has been initialized or reinitialized.\\n     */\\n  event Initialized(uint8 version);\\n\\n  /**\\n   * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\\n     * `onlyInitializing` functions can be used to initialize parent contracts.\\n     *\\n     * Similar to `reinitializer(1)`, except that functions marked with `initializer` can be nested in the context of a\\n     * constructor.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier initializer() {\\n    bool isTopLevelCall = !_initializing;\\n    require(\\n      (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\\n      \\\"Initializable: contract is already initialized\\\"\\n    );\\n    _initialized = 1;\\n    if (isTopLevelCall) {\\n      _initializing = true;\\n    }\\n    _;\\n    if (isTopLevelCall) {\\n      _initializing = false;\\n      emit Initialized(1);\\n    }\\n  }\\n\\n  /**\\n   * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\\n     * used to initialize parent contracts.\\n     *\\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\\n     * are added through upgrades and that require initialization.\\n     *\\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\\n     *\\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\\n     * a contract, executing them in the right order is up to the developer or operator.\\n     *\\n     * WARNING: setting the version to 255 will prevent any future reinitialization.\\n     *\\n     * Emits an {Initialized} event.\\n     */\\n  modifier reinitializer(uint8 version) {\\n    require(!_initializing && _initialized < version, \\\"Initializable: contract is already initialized\\\");\\n    _initialized = version;\\n    _initializing = true;\\n    _;\\n    _initializing = false;\\n    emit Initialized(version);\\n  }\\n\\n  /**\\n   * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\\n     */\\n  modifier onlyInitializing() {\\n    require(_initializing, \\\"Initializable: contract is not initializing\\\");\\n    _;\\n  }\\n\\n  /**\\n   * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\\n     * through proxies.\\n     *\\n     * Emits an {Initialized} event the first time it is successfully executed.\\n     */\\n  function _disableInitializers() internal virtual {\\n    require(!_initializing, \\\"Initializable: contract is initializing\\\");\\n    if (_initialized != type(uint8).max) {\\n      _initialized = type(uint8).max;\\n      emit Initialized(type(uint8).max);\\n    }\\n  }\\n\\n  /**\\n   * @dev Returns the highest version that has been initialized. See {reinitializer}.\\n     */\\n  function _getInitializedVersion() internal view returns (uint8) {\\n    return _initialized;\\n  }\\n\\n  /**\\n   * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\\n     */\\n  function _isInitializing() internal view returns (bool) {\\n    return _initializing;\\n  }\\n}\\n\",\"keccak256\":\"0x3c7a20b7e9d134311f43e27990f32c75ff6cb461a6136c4f83fc20734f1d82e0\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/Math.sol)\\n\\npragma solidity 0.8.17;\\n\\n/**\\n * @dev Standard math utilities missing in the Solidity language.\\n */\\nlibrary Math {\\n  enum Rounding {\\n    Down, // Toward negative infinity\\n    Up, // Toward infinity\\n    Zero // Toward zero\\n  }\\n\\n  /**\\n   * @dev Returns the largest of two numbers.\\n     */\\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a > b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the smallest of two numbers.\\n     */\\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\\n    return a < b ? a : b;\\n  }\\n\\n  /**\\n   * @dev Returns the average of two numbers. The result is rounded towards\\n     * zero.\\n     */\\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b) / 2 can overflow.\\n    return (a & b) + (a ^ b) / 2;\\n  }\\n\\n  /**\\n   * @dev Returns the ceiling of the division of two numbers.\\n     *\\n     * This differs from standard division with `/` in that it rounds up instead\\n     * of rounding down.\\n     */\\n  function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\\n    // (a + b - 1) / b can overflow on addition, so we distribute.\\n    return a == 0 ? 0 : (a - 1) / b + 1;\\n  }\\n\\n  /**\\n   * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\\n     * with further edits by Uniswap Labs also under MIT license.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator\\n  ) internal pure returns (uint256 result) {\\n  unchecked {\\n    // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\\n    // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\\n    // variables such that product = prod1 * 2^256 + prod0.\\n    uint256 prod0; // Least significant 256 bits of the product\\n    uint256 prod1; // Most significant 256 bits of the product\\n    assembly {\\n      let mm := mulmod(x, y, not(0))\\n      prod0 := mul(x, y)\\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\n    }\\n\\n    // Handle non-overflow cases, 256 by 256 division.\\n    if (prod1 == 0) {\\n      return prod0 / denominator;\\n    }\\n\\n    // Make sure the result is less than 2^256. Also prevents denominator == 0.\\n    require(denominator > prod1, \\\"Math: mulDiv overflow\\\");\\n\\n    ///////////////////////////////////////////////\\n    // 512 by 256 division.\\n    ///////////////////////////////////////////////\\n\\n    // Make division exact by subtracting the remainder from [prod1 prod0].\\n    uint256 remainder;\\n    assembly {\\n    // Compute remainder using mulmod.\\n      remainder := mulmod(x, y, denominator)\\n\\n    // Subtract 256 bit number from 512 bit number.\\n      prod1 := sub(prod1, gt(remainder, prod0))\\n      prod0 := sub(prod0, remainder)\\n    }\\n\\n    // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\\n    // See https://cs.stackexchange.com/q/138556/92363.\\n\\n    // Does not overflow because the denominator cannot be zero at this stage in the function.\\n    uint256 twos = denominator & (~denominator + 1);\\n    assembly {\\n    // Divide denominator by twos.\\n      denominator := div(denominator, twos)\\n\\n    // Divide [prod1 prod0] by twos.\\n      prod0 := div(prod0, twos)\\n\\n    // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\\n      twos := add(div(sub(0, twos), twos), 1)\\n    }\\n\\n    // Shift in bits from prod1 into prod0.\\n    prod0 |= prod1 * twos;\\n\\n    // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\\n    // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\\n    // four bits. That is, denominator * inv = 1 mod 2^4.\\n    uint256 inverse = (3 * denominator) ^ 2;\\n\\n    // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\\n    // in modular arithmetic, doubling the correct bits in each step.\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^8\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^16\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^32\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^64\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^128\\n    inverse *= 2 - denominator * inverse; // inverse mod 2^256\\n\\n    // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\\n    // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\\n    // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\\n    // is no longer required.\\n    result = prod0 * inverse;\\n    return result;\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\\n     */\\n  function mulDiv(\\n    uint256 x,\\n    uint256 y,\\n    uint256 denominator,\\n    Rounding rounding\\n  ) internal pure returns (uint256) {\\n    uint256 result = mulDiv(x, y, denominator);\\n    if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\\n      result += 1;\\n    }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\\n     *\\n     * Inspired by Henry S. Warren, Jr.'s \\\"Hacker's Delight\\\" (Chapter 11).\\n     */\\n  function sqrt(uint256 a) internal pure returns (uint256) {\\n    if (a == 0) {\\n      return 0;\\n    }\\n\\n    // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\\n    //\\n    // We know that the \\\"msb\\\" (most significant bit) of our target number `a` is a power of 2 such that we have\\n    // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\\n    //\\n    // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\\n    // \\u2192 `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\\n    // \\u2192 `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\\n    //\\n    // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\\n    uint256 result = 1 << (log2(a) >> 1);\\n\\n    // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\\n    // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\\n    // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\\n    // into the expected uint128 result.\\n  unchecked {\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    result = (result + a / result) >> 1;\\n    return min(result, a / result);\\n  }\\n  }\\n\\n  /**\\n   * @notice Calculates sqrt(a), following the selected rounding direction.\\n     */\\n  function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = sqrt(a);\\n    return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 128;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 64;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 32;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 16;\\n    }\\n    if (value >> 8 > 0) {\\n      value >>= 8;\\n      result += 8;\\n    }\\n    if (value >> 4 > 0) {\\n      value >>= 4;\\n      result += 4;\\n    }\\n    if (value >> 2 > 0) {\\n      value >>= 2;\\n      result += 2;\\n    }\\n    if (value >> 1 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log2(value);\\n    return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >= 10**64) {\\n      value /= 10**64;\\n      result += 64;\\n    }\\n    if (value >= 10**32) {\\n      value /= 10**32;\\n      result += 32;\\n    }\\n    if (value >= 10**16) {\\n      value /= 10**16;\\n      result += 16;\\n    }\\n    if (value >= 10**8) {\\n      value /= 10**8;\\n      result += 8;\\n    }\\n    if (value >= 10**4) {\\n      value /= 10**4;\\n      result += 4;\\n    }\\n    if (value >= 10**2) {\\n      value /= 10**2;\\n      result += 2;\\n    }\\n    if (value >= 10**1) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log10(value);\\n    return result + (rounding == Rounding.Up && 10**result < value ? 1 : 0);\\n  }\\n  }\\n\\n  /**\\n   * @dev Return the log in base 256, rounded down, of a positive value.\\n     * Returns 0 if given 0.\\n     *\\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\\n     */\\n  function log256(uint256 value) internal pure returns (uint256) {\\n    uint256 result = 0;\\n  unchecked {\\n    if (value >> 128 > 0) {\\n      value >>= 128;\\n      result += 16;\\n    }\\n    if (value >> 64 > 0) {\\n      value >>= 64;\\n      result += 8;\\n    }\\n    if (value >> 32 > 0) {\\n      value >>= 32;\\n      result += 4;\\n    }\\n    if (value >> 16 > 0) {\\n      value >>= 16;\\n      result += 2;\\n    }\\n    if (value >> 8 > 0) {\\n      result += 1;\\n    }\\n  }\\n    return result;\\n  }\\n\\n  /**\\n   * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\\n     * Returns 0 if given 0.\\n     */\\n  function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\\n  unchecked {\\n    uint256 result = log256(value);\\n    return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\\n  }\\n  }\\n}\\n\",\"keccak256\":\"0x2c5be0f4a60126b08e20f40586958ec1b76a27b69406c4b0db19e9dc6f771cfc\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.8.0) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../interfaces/IERC20Permit.sol\\\";\\nimport \\\"./Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n  using Address for address;\\n\\n  function safeTransfer(\\n    IERC20 token,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n  }\\n\\n  function safeTransferFrom(\\n    IERC20 token,\\n    address from,\\n    address to,\\n    uint256 value\\n  ) internal {\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n  }\\n\\n  /**\\n   * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n  function safeApprove(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    // safeApprove should only be called when setting an initial allowance,\\n    // or when resetting it to zero. To increase and decrease it, use\\n    // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n    require(\\n      (value == 0) || (token.allowance(address(this), spender) == 0),\\n      \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n    );\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n  }\\n\\n  function safeIncreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n    uint256 newAllowance = token.allowance(address(this), spender) + value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n\\n  function safeDecreaseAllowance(\\n    IERC20 token,\\n    address spender,\\n    uint256 value\\n  ) internal {\\n  unchecked {\\n    uint256 oldAllowance = token.allowance(address(this), spender);\\n    require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n    uint256 newAllowance = oldAllowance - value;\\n    _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\\n  }\\n  }\\n\\n  function safePermit(\\n    IERC20Permit token,\\n    address owner,\\n    address spender,\\n    uint256 value,\\n    uint256 deadline,\\n    uint8 v,\\n    bytes32 r,\\n    bytes32 s\\n  ) internal {\\n    uint256 nonceBefore = token.nonces(owner);\\n    token.permit(owner, spender, value, deadline, v, r, s);\\n    uint256 nonceAfter = token.nonces(owner);\\n    require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n  }\\n\\n  /**\\n   * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n  function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n    // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n    // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n    // the target address contains contract code and also asserts for success in the low-level call.\\n\\n    bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n    if (returndata.length > 0) {\\n      // Return data is optional\\n      require(abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x2378ee07b24e40c75781b27b2aa0812769c0000964e2d2501e3d234d3285dd18\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/proxy/ControllableV3.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/Initializable.sol\\\";\\nimport \\\"../tools/TetuERC165.sol\\\";\\nimport \\\"../interfaces/IControllable.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../lib/SlotsLib.sol\\\";\\nimport \\\"../lib/InterfaceIds.sol\\\";\\n\\n/// @title Implement basic functionality for any contract that require strict control\\n/// @dev Can be used with upgradeable pattern.\\n///      Require call __Controllable_init() in any case.\\n/// @author belbix\\nabstract contract ControllableV3 is Initializable, TetuERC165, IControllable {\\n  using SlotsLib for bytes32;\\n\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string public constant CONTROLLABLE_VERSION = \\\"3.0.0\\\";\\n\\n  bytes32 internal constant _CONTROLLER_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.controller\\\")) - 1);\\n  bytes32 internal constant _CREATED_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created\\\")) - 1);\\n  bytes32 internal constant _CREATED_BLOCK_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.created_block\\\")) - 1);\\n  bytes32 internal constant _REVISION_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.revision\\\")) - 1);\\n  bytes32 internal constant _PREVIOUS_LOGIC_SLOT = bytes32(uint256(keccak256(\\\"eip1967.controllable.prev_logic\\\")) - 1);\\n\\n  event ContractInitialized(address controller, uint ts, uint block);\\n  event RevisionIncreased(uint value, address oldLogic);\\n\\n  /// @dev Prevent implementation init\\n  constructor() {\\n    _disableInitializers();\\n  }\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  ///         Save block.timestamp in the \\\"created\\\" variable\\n  /// @dev Use it only once after first logic setup\\n  /// @param controller_ Controller address\\n  function __Controllable_init(address controller_) internal onlyInitializing {\\n    require(controller_ != address(0), \\\"Zero controller\\\");\\n    _requireInterface(controller_, InterfaceIds.I_CONTROLLER);\\n    require(IController(controller_).governance() != address(0), \\\"Zero governance\\\");\\n    _CONTROLLER_SLOT.set(controller_);\\n    _CREATED_SLOT.set(block.timestamp);\\n    _CREATED_BLOCK_SLOT.set(block.number);\\n    emit ContractInitialized(controller_, block.timestamp, block.number);\\n  }\\n\\n  /// @dev Return true if given address is controller\\n  function isController(address _value) public override view returns (bool) {\\n    return _value == controller();\\n  }\\n\\n  /// @notice Return true if given address is setup as governance in Controller\\n  function isGovernance(address _value) public override view returns (bool) {\\n    return IController(controller()).governance() == _value;\\n  }\\n\\n  /// @dev Contract upgrade counter\\n  function revision() external view returns (uint){\\n    return _REVISION_SLOT.getUint();\\n  }\\n\\n  /// @dev Previous logic implementation\\n  function previousImplementation() external view returns (address){\\n    return _PREVIOUS_LOGIC_SLOT.getAddress();\\n  }\\n\\n  /// @dev See {IERC165-supportsInterface}.\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == InterfaceIds.I_CONTROLLABLE || super.supportsInterface(interfaceId);\\n  }\\n\\n  // ************* SETTERS/GETTERS *******************\\n\\n  /// @notice Return controller address saved in the contract slot\\n  function controller() public view override returns (address) {\\n    return _CONTROLLER_SLOT.getAddress();\\n  }\\n\\n  /// @notice Return creation timestamp\\n  /// @return Creation timestamp\\n  function created() external view override returns (uint256) {\\n    return _CREATED_SLOT.getUint();\\n  }\\n\\n  /// @notice Return creation block number\\n  /// @return Creation block number\\n  function createdBlock() external override view returns (uint256) {\\n    return _CREATED_BLOCK_SLOT.getUint();\\n  }\\n\\n  /// @dev Revision should be increased on each contract upgrade\\n  function increaseRevision(address oldLogic) external override {\\n    require(msg.sender == address(this), \\\"Increase revision forbidden\\\");\\n    uint r = _REVISION_SLOT.getUint() + 1;\\n    _REVISION_SLOT.set(r);\\n    _PREVIOUS_LOGIC_SLOT.set(oldLogic);\\n    emit RevisionIncreased(r, oldLogic);\\n  }\\n\\n}\\n\",\"keccak256\":\"0xb29542898f4d28ccc5c9d01bf1a45a9a15331ec7f9accad4a0c673025896ec44\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../interfaces/IStrategyV2.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\nimport \\\"../interfaces/IForwarder.sol\\\";\\nimport \\\"../proxy/ControllableV3.sol\\\";\\nimport \\\"./StrategyLib.sol\\\";\\n\\n/// @title Abstract contract for base strategy functionality\\n/// @author belbix\\nabstract contract StrategyBaseV2 is IStrategyV2, ControllableV3 {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Version of this contract. Adjust manually on each code modification.\\n  string public constant STRATEGY_BASE_VERSION = \\\"2.3.0\\\";\\n  /// @notice 10% of total profit is sent to {performanceReceiver} before compounding\\n  uint internal constant DEFAULT_PERFORMANCE_FEE = 10_000;\\n  address internal constant DEFAULT_PERF_FEE_RECEIVER = 0x9Cc199D4353b5FB3e6C8EEBC99f5139e0d8eA06b;\\n\\n  // *************************************************************\\n  //                        VARIABLES\\n  //                Keep names and ordering!\\n  //                 Add only in the bottom.\\n  // *************************************************************\\n\\n  /// @dev Underlying asset\\n  address public override asset;\\n  /// @dev Linked splitter\\n  address public override splitter;\\n  /// @dev Percent of profit for autocompound inside this strategy.\\n  uint public override compoundRatio;\\n  uint private __deprecatedSlot1;\\n\\n  /// @notice {performanceFee}% of total profit is sent to {performanceReceiver} before compounding\\n  /// @dev governance by default\\n  address public override performanceReceiver;\\n\\n  /// @notice A percent of total profit that is sent to the {performanceReceiver} before compounding\\n  /// @dev {DEFAULT_PERFORMANCE_FEE} by default, FEE_DENOMINATOR is used\\n  uint public override performanceFee;\\n  /// @dev Represent specific name for this strategy. Should include short strategy name and used assets. Uniq across the vault.\\n  string public override strategySpecificName;\\n\\n  // *************************************************************\\n  //                        INIT\\n  // *************************************************************\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  function __StrategyBase_init(\\n    address controller_,\\n    address _splitter\\n  ) internal onlyInitializing {\\n    _requireInterface(_splitter, InterfaceIds.I_SPLITTER);\\n    __Controllable_init(controller_);\\n\\n    require(IControllable(_splitter).isController(controller_), StrategyLib.WRONG_VALUE);\\n\\n    asset = ISplitter(_splitter).asset();\\n    splitter = _splitter;\\n\\n    performanceReceiver = DEFAULT_PERF_FEE_RECEIVER;\\n    performanceFee = DEFAULT_PERFORMANCE_FEE;\\n  }\\n\\n  // *************************************************************\\n  //                     PERFORMANCE FEE\\n  // *************************************************************\\n  /// @notice Set performance fee and receiver\\n  function setupPerformanceFee(uint fee_, address receiver_) external {\\n    StrategyLib._checkSetupPerformanceFee(controller(), fee_, receiver_);\\n    performanceFee = fee_;\\n    performanceReceiver = receiver_;\\n  }\\n\\n  // *************************************************************\\n  //                        VIEWS\\n  // *************************************************************\\n\\n  /// @dev Total amount of underlying assets under control of this strategy.\\n  function totalAssets() public view override returns (uint) {\\n    return IERC20(asset).balanceOf(address(this)) + investedAssets();\\n  }\\n\\n  /// @dev See {IERC165-supportsInterface}.\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == InterfaceIds.I_STRATEGY_V2 || super.supportsInterface(interfaceId);\\n  }\\n\\n  // *************************************************************\\n  //                   VOTER ACTIONS\\n  // *************************************************************\\n\\n  /// @dev PlatformVoter can change compound ratio for some strategies.\\n  ///      A strategy can implement another logic for some uniq cases.\\n  function setCompoundRatio(uint value) external virtual override {\\n    StrategyLib._checkCompoundRatioChanged(controller(), compoundRatio, value);\\n    compoundRatio = value;\\n  }\\n\\n  // *************************************************************\\n  //                   OPERATOR ACTIONS\\n  // *************************************************************\\n\\n  /// @dev The name will be used for UI.\\n  function setStrategySpecificName(string calldata name) external {\\n    StrategyLib._checkStrategySpecificNameChanged(controller(), name);\\n    strategySpecificName = name;\\n  }\\n\\n  /// @dev In case of any issue operator can withdraw all from pool.\\n  function emergencyExit() external {\\n    // check inside lib call\\n\\n    _emergencyExitFromPool();\\n    StrategyLib.sendOnEmergencyExit(controller(), asset, splitter);\\n  }\\n\\n  /// @dev Manual claim rewards.\\n  function claim() external {\\n    StrategyLib._checkManualClaim(controller());\\n    _claim();\\n  }\\n\\n  // *************************************************************\\n  //                    DEPOSIT/WITHDRAW\\n  // *************************************************************\\n\\n  /// @notice Stakes everything the strategy holds into the reward pool.\\n  /// amount_ Amount transferred to the strategy balance just before calling this function\\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\\n  ///                                       It can be false if we know exactly, that the amount is already actual.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function investAll(\\n    uint /*amount_*/,\\n    bool updateTotalAssetsBeforeInvest_\\n  ) external override returns (\\n    uint strategyLoss\\n  ) {\\n    uint balance = StrategyLib._checkInvestAll(splitter, asset);\\n\\n    if (balance > 0) {\\n      strategyLoss = _depositToPool(balance, updateTotalAssetsBeforeInvest_);\\n    }\\n\\n    return strategyLoss;\\n  }\\n\\n  /// @dev Withdraws all underlying assets to the vault\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawAllToSplitter() external override returns (uint strategyLoss) {\\n    address _splitter = splitter;\\n    address _asset = asset;\\n\\n    uint balance = StrategyLib._checkSplitterSenderAndGetBalance(_splitter, _asset);\\n\\n    (uint expectedWithdrewUSD, uint assetPrice, uint _strategyLoss) = _withdrawAllFromPool();\\n\\n    StrategyLib._withdrawAllToSplitterPostActions(\\n      _asset,\\n      balance,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n    return _strategyLoss;\\n  }\\n\\n  /// @dev Withdraws some assets to the splitter\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function withdrawToSplitter(uint amount) external override returns (uint strategyLoss) {\\n    address _splitter = splitter;\\n    address _asset = asset;\\n\\n    uint balance = StrategyLib._checkSplitterSenderAndGetBalance(_splitter, _asset);\\n\\n    if (amount > balance) {\\n      uint expectedWithdrewUSD;\\n      uint assetPrice;\\n\\n      (expectedWithdrewUSD, assetPrice, strategyLoss) = _withdrawFromPool(amount - balance);\\n      balance = StrategyLib.checkWithdrawImpact(\\n        _asset,\\n        balance,\\n        expectedWithdrewUSD,\\n        assetPrice,\\n        _splitter\\n      );\\n    }\\n\\n    StrategyLib._withdrawToSplitterPostActions(\\n      amount,\\n      balance,\\n      _asset,\\n      _splitter\\n    );\\n    return strategyLoss;\\n  }\\n\\n  // *************************************************************\\n  //                       VIRTUAL\\n  // These functions must be implemented in the strategy contract\\n  // *************************************************************\\n\\n  /// @dev Amount of underlying assets invested to the pool.\\n  function investedAssets() public view virtual returns (uint);\\n\\n  /// @notice Deposit given amount to the pool.\\n  /// @param updateTotalAssetsBeforeInvest_ Recalculate total assets amount before depositing.\\n  ///                                       It can be false if we know exactly, that the amount is already actual.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function _depositToPool(\\n    uint amount,\\n    bool updateTotalAssetsBeforeInvest_\\n  ) internal virtual returns (\\n    uint strategyLoss\\n  );\\n\\n  /// @dev Withdraw given amount from the pool.\\n  /// @return expectedWithdrewUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\\n  /// @return assetPrice Price of the strategy {asset}.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function _withdrawFromPool(uint amount) internal virtual returns (\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    uint strategyLoss\\n  );\\n\\n  /// @dev Withdraw all from the pool.\\n  /// @return expectedWithdrewUSD Sum of USD value of each asset in the pool that was withdrawn, decimals of {asset}.\\n  /// @return assetPrice Price of the strategy {asset}.\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function _withdrawAllFromPool() internal virtual returns (\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    uint strategyLoss\\n  );\\n\\n  /// @dev If pool support emergency withdraw need to call it for emergencyExit()\\n  ///      Withdraw assets without impact checking.\\n  function _emergencyExitFromPool() internal virtual;\\n\\n  /// @dev Claim all possible rewards.\\n  function _claim() internal virtual returns (address[] memory rewardTokens, uint[] memory amounts);\\n\\n  /// @dev This empty reserved space is put in place to allow future versions to add new\\n  ///      variables without shifting down storage in the inheritance chain.\\n  ///      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n  uint[43] private __gap;\\n}\\n\",\"keccak256\":\"0x6763c4b6a10419acdce87d871759ae4a06c283839fe5cb6143ff80bcac318b1f\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/SafeERC20.sol\\\";\\nimport \\\"../openzeppelin/Math.sol\\\";\\nimport \\\"../interfaces/IController.sol\\\";\\nimport \\\"../interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"../interfaces/ISplitter.sol\\\";\\n\\nlibrary StrategyLib {\\n  using SafeERC20 for IERC20;\\n\\n  // *************************************************************\\n  //                        CONSTANTS\\n  // *************************************************************\\n\\n  /// @dev Denominator for fee calculation.\\n  uint internal constant FEE_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        EVENTS\\n  // *************************************************************\\n\\n  event CompoundRatioChanged(uint oldValue, uint newValue);\\n  event StrategySpecificNameChanged(string name);\\n  event EmergencyExit(address sender, uint amount);\\n  event ManualClaim(address sender);\\n  event InvestAll(uint balance);\\n  event WithdrawAllToSplitter(uint amount);\\n  event WithdrawToSplitter(uint amount, uint sent, uint balance);\\n\\n  // *************************************************************\\n  //                        ERRORS\\n  // *************************************************************\\n\\n  string internal constant DENIED = \\\"SB: Denied\\\";\\n  string internal constant TOO_HIGH = \\\"SB: Too high\\\";\\n  string internal constant WRONG_VALUE = \\\"SB: Wrong value\\\";\\n  /// @dev Denominator for compound ratio\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n\\n  // *************************************************************\\n  //                        CHECKS AND EMITS\\n  // *************************************************************\\n\\n  function _checkCompoundRatioChanged(address controller, uint oldValue, uint newValue) external {\\n    onlyPlatformVoter(controller);\\n    require(newValue <= COMPOUND_DENOMINATOR, TOO_HIGH);\\n    emit CompoundRatioChanged(oldValue, newValue);\\n  }\\n\\n  function _checkStrategySpecificNameChanged(address controller, string calldata newName) external {\\n    onlyOperators(controller);\\n    emit StrategySpecificNameChanged(newName);\\n  }\\n\\n  function _checkManualClaim(address controller) external {\\n    onlyOperators(controller);\\n    emit ManualClaim(msg.sender);\\n  }\\n\\n  function _checkInvestAll(address splitter, address asset) external returns (uint assetBalance) {\\n    onlySplitter(splitter);\\n    assetBalance = IERC20(asset).balanceOf(address(this));\\n    emit InvestAll(assetBalance);\\n  }\\n\\n  // *************************************************************\\n  //                     RESTRICTIONS\\n  // *************************************************************\\n\\n  /// @dev Restrict access only for operators\\n  function onlyOperators(address controller) public view {\\n    require(IController(controller).isOperator(msg.sender), DENIED);\\n  }\\n\\n  /// @dev Restrict access only for governance\\n  function onlyGovernance(address controller) public view {\\n    require(IController(controller).governance() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for platform voter\\n  function onlyPlatformVoter(address controller) public view {\\n    require(IController(controller).platformVoter() == msg.sender, DENIED);\\n  }\\n\\n  /// @dev Restrict access only for splitter\\n  function onlySplitter(address splitter) public view {\\n    require(splitter == msg.sender, DENIED);\\n  }\\n\\n  function _checkSetupPerformanceFee(address controller, uint fee_, address receiver_) external view {\\n    onlyGovernance(controller);\\n    require(fee_ <= 100_000, TOO_HIGH);\\n    require(receiver_ != address(0), WRONG_VALUE);\\n  }\\n\\n  // *************************************************************\\n  //                       HELPERS\\n  // *************************************************************\\n\\n  /// @notice Calculate withdrawn amount in USD using the {assetPrice}.\\n  ///         Revert if the amount is different from expected too much (high price impact)\\n  /// @param balanceBefore Asset balance of the strategy before withdrawing\\n  /// @param expectedWithdrewUSD Expected amount in USD, decimals are same to {_asset}\\n  /// @param assetPrice Price of the asset, decimals 18\\n  /// @return balance Current asset balance of the strategy\\n  function checkWithdrawImpact(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) public view returns (uint balance) {\\n    balance = IERC20(_asset).balanceOf(address(this));\\n    if (assetPrice != 0 && expectedWithdrewUSD != 0) {\\n\\n      uint withdrew = balance > balanceBefore ? balance - balanceBefore : 0;\\n      uint withdrewUSD = withdrew * assetPrice / 1e18;\\n      uint priceChangeTolerance = ITetuVaultV2(ISplitter(_splitter).vault()).withdrawFee();\\n      uint difference = expectedWithdrewUSD > withdrewUSD ? expectedWithdrewUSD - withdrewUSD : 0;\\n      require(difference * FEE_DENOMINATOR / expectedWithdrewUSD <= priceChangeTolerance, TOO_HIGH);\\n    }\\n  }\\n\\n  function sendOnEmergencyExit(address controller, address asset, address splitter) external {\\n    onlyOperators(controller);\\n\\n    uint balance = IERC20(asset).balanceOf(address(this));\\n    IERC20(asset).safeTransfer(splitter, balance);\\n    emit EmergencyExit(msg.sender, balance);\\n  }\\n\\n  function _checkSplitterSenderAndGetBalance(address splitter, address asset) external view returns (uint balance) {\\n    onlySplitter(splitter);\\n    return IERC20(asset).balanceOf(address(this));\\n  }\\n\\n  function _withdrawAllToSplitterPostActions(\\n    address _asset,\\n    uint balanceBefore,\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    address _splitter\\n  ) external {\\n    uint balance = checkWithdrawImpact(\\n      _asset,\\n      balanceBefore,\\n      expectedWithdrewUSD,\\n      assetPrice,\\n      _splitter\\n    );\\n\\n    if (balance != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, balance);\\n    }\\n    emit WithdrawAllToSplitter(balance);\\n  }\\n\\n  function _withdrawToSplitterPostActions(\\n    uint amount,\\n    uint balance,\\n    address _asset,\\n    address _splitter\\n  ) external {\\n    uint amountAdjusted = Math.min(amount, balance);\\n    if (amountAdjusted != 0) {\\n      IERC20(_asset).safeTransfer(_splitter, amountAdjusted);\\n    }\\n    emit WithdrawToSplitter(amount, amountAdjusted, balance);\\n  }\\n}\\n\",\"keccak256\":\"0x81940f83bfee07d985fc82504e764db61673f99ae82e1d323f64f51843b7ef9f\",\"license\":\"MIT\"},\"@tetu_io/tetu-contracts-v2/contracts/tools/TetuERC165.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../openzeppelin/ERC165.sol\\\";\\nimport \\\"../interfaces/IERC20.sol\\\";\\nimport \\\"../lib/InterfaceIds.sol\\\";\\n\\n/// @dev Tetu Implementation of the {IERC165} interface extended with helper functions.\\n/// @author bogdoslav\\nabstract contract TetuERC165 is ERC165 {\\n\\n  function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\\n    return interfaceId == InterfaceIds.I_TETU_ERC165 || super.supportsInterface(interfaceId);\\n  }\\n\\n  // *************************************************************\\n  //                        HELPER FUNCTIONS\\n  // *************************************************************\\n  /// @author bogdoslav\\n\\n  /// @dev Checks what interface with id is supported by contract.\\n  /// @return bool. Do not throws\\n  function _isInterfaceSupported(address contractAddress, bytes4 interfaceId) internal view returns (bool) {\\n    require(contractAddress != address(0), \\\"Zero address\\\");\\n    // check what address is contract\\n    uint codeSize;\\n    assembly {\\n      codeSize := extcodesize(contractAddress)\\n    }\\n    if (codeSize == 0) return false;\\n\\n    try IERC165(contractAddress).supportsInterface(interfaceId) returns (bool isSupported) {\\n      return isSupported;\\n    } catch {\\n    }\\n    return false;\\n  }\\n\\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\\n  function _requireInterface(address contractAddress, bytes4 interfaceId) internal view {\\n    require(_isInterfaceSupported(contractAddress, interfaceId), \\\"Interface is not supported\\\");\\n  }\\n\\n  /// @dev Checks what address is ERC20.\\n  /// @return bool. Do not throws\\n  function _isERC20(address contractAddress) internal view returns (bool) {\\n    require(contractAddress != address(0), \\\"Zero address\\\");\\n    // check what address is contract\\n    uint codeSize;\\n    assembly {\\n      codeSize := extcodesize(contractAddress)\\n    }\\n    if (codeSize == 0) return false;\\n\\n    bool totalSupplySupported;\\n    try IERC20(contractAddress).totalSupply() returns (uint) {\\n      totalSupplySupported = true;\\n    } catch {\\n    }\\n\\n    bool balanceSupported;\\n    try IERC20(contractAddress).balanceOf(address(this)) returns (uint) {\\n      balanceSupported = true;\\n    } catch {\\n    }\\n\\n    return totalSupplySupported && balanceSupported;\\n  }\\n\\n\\n  /// @dev Checks what interface with id is supported by contract and reverts otherwise\\n  function _requireERC20(address contractAddress) internal view {\\n    require(_isERC20(contractAddress), \\\"Not ERC20\\\");\\n  }\\n}\\n\",\"keccak256\":\"0xeb61b3112015589667319274e5284107728bd4846cc357d158a51397cedacaba\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\n/// @notice Keep and provide addresses of all application contracts\\ninterface IConverterController {\\n  function governance() external view returns (address);\\n\\n  // ********************* Health factor explanation  ****************\\n  // For example, a landing platform has: liquidity threshold = 0.85, LTV=0.8, LTV / LT = 1.0625\\n  // For collateral $100 we can borrow $80. A liquidation happens if the cost of collateral will reduce below $85.\\n  // We set min-health-factor = 1.1, target-health-factor = 1.3\\n  // For collateral 100 we will borrow 100/1.3 = 76.92\\n  //\\n  // Collateral value   100        77            assume that collateral value is decreased at 100/77=1.3 times\\n  // Collateral * LT    85         65.45\\n  // Borrow value       65.38      65.38         but borrow value is the same as before\\n  // Health factor      1.3        1.001         liquidation almost happens here (!)\\n  //\\n  /// So, if we have target factor 1.3, it means, that if collateral amount will decreases at 1.3 times\\n  // and the borrow value won't change at the same time, the liquidation happens at that point.\\n  // Min health factor marks the point at which a rebalancing must be made asap.\\n  // *****************************************************************\\n\\n  /// @notice min allowed health factor with decimals 2, must be >= 1e2\\n  function minHealthFactor2() external view returns (uint16);\\n  function setMinHealthFactor2(uint16 value_) external;\\n\\n  /// @notice target health factor with decimals 2\\n  /// @dev If the health factor is below/above min/max threshold, we need to make repay\\n  ///      or additional borrow and restore the health factor to the given target value\\n  function targetHealthFactor2() external view returns (uint16);\\n  function setTargetHealthFactor2(uint16 value_) external;\\n\\n  /// @notice max allowed health factor with decimals 2\\n  /// @dev For future versions, currently max health factor is not used\\n  function maxHealthFactor2() external view returns (uint16);\\n  /// @dev For future versions, currently max health factor is not used\\n  function setMaxHealthFactor2(uint16 value_) external;\\n\\n  /// @notice get current value of blocks per day. The value is set manually at first and can be auto-updated later\\n  function blocksPerDay() external view returns (uint);\\n  /// @notice set value of blocks per day manually and enable/disable auto update of this value\\n  function setBlocksPerDay(uint blocksPerDay_, bool enableAutoUpdate_) external;\\n  /// @notice Check if it's time to call updateBlocksPerDay()\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function isBlocksPerDayAutoUpdateRequired(uint periodInSeconds_) external view returns (bool);\\n  /// @notice Recalculate blocksPerDay value\\n  /// @param periodInSeconds_ Period of auto-update in seconds\\n  function updateBlocksPerDay(uint periodInSeconds_) external;\\n\\n  /// @notice 0 - new borrows are allowed, 1 - any new borrows are forbidden\\n  function paused() external view returns (bool);\\n\\n  /// @notice the given user is whitelisted and is allowed to make borrow/swap using TetuConverter\\n  function isWhitelisted(address user_) external view returns (bool);\\n\\n  /// @notice The size of the gap by which the debt should be increased upon repayment\\n  ///         Such gaps are required by AAVE pool adapters to workaround dust tokens problem\\n  ///         and be able to make full repayment.\\n  /// @dev Debt gap is applied as following: toPay = debt * (DEBT_GAP_DENOMINATOR + debtGap) / DEBT_GAP_DENOMINATOR\\n  function debtGap() external view returns (uint);\\n\\n  //-----------------------------------------------------\\n  //        Core application contracts\\n  //-----------------------------------------------------\\n\\n  function tetuConverter() external view returns (address);\\n  function borrowManager() external view returns (address);\\n  function debtMonitor() external view returns (address);\\n  function tetuLiquidator() external view returns (address);\\n  function swapManager() external view returns (address);\\n  function priceOracle() external view returns (address);\\n\\n  //-----------------------------------------------------\\n  //        External contracts\\n  //-----------------------------------------------------\\n  /// @notice A keeper to control health and efficiency of the borrows\\n  function keeper() external view returns (address);\\n  /// @notice Controller of tetu-contracts-v2, that is allowed to update proxy contracts\\n  function proxyUpdater() external view returns (address);\\n}\\n\",\"keccak256\":\"0xefb20480cab050b2e178982481efc65babd931bdb6aeb4f0e10c58684cee43f1\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IConverterControllerProvider.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IConverterControllerProvider {\\n  function controller() external view returns (address);\\n}\\n\",\"keccak256\":\"0x71dce61809acb75f9078290e90033ffe816a51f18b7cb296d161e278c36eec86\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\ninterface IPriceOracle {\\n  /// @notice Return asset price in USD, decimals 18\\n  function getAssetPrice(address asset) external view returns (uint256);\\n}\\n\",\"keccak256\":\"0xb11e653eb4d6d7c41f29ee1e3e498253cfa8df1aec3ff31ab527009b79bdb705\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n\\npragma solidity 0.8.17;\\n\\nimport \\\"./IConverterControllerProvider.sol\\\";\\n\\n/// @notice Main contract of the TetuConverter application\\n/// @dev Borrower (strategy) makes all operations via this contract only.\\ninterface ITetuConverter is IConverterControllerProvider {\\n\\n  /// @notice Find possible borrow strategies and provide \\\"cost of money\\\" as interest for the period for each strategy\\n  ///         Result arrays of the strategy are ordered in ascending order of APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converters Array of available converters ordered in ascending order of APR.\\n  ///                    Each item contains a result contract that should be used for conversion; it supports IConverter\\n  ///                    This address should be passed to borrow-function during conversion.\\n  ///                    The length of array is always equal to the count of available lending platforms.\\n  ///                    Last items in array can contain zero addresses (it means they are not used)\\n  /// @return collateralAmountsOut Amounts that should be provided as a collateral\\n  /// @return amountToBorrowsOut Amounts that should be borrowed\\n  ///                            This amount is not zero if corresponded converter is not zero.\\n  /// @return aprs18 Interests on the use of {amountIn_} during the given period, decimals 18\\n  function findBorrowStrategies(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external view returns (\\n    address[] memory converters,\\n    uint[] memory collateralAmountsOut,\\n    uint[] memory amountToBorrowsOut,\\n    int[] memory aprs18\\n  );\\n\\n  /// @notice Find best swap strategy and provide \\\"cost of money\\\" as interest for the period\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow()\\n  /// @return sourceAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                         It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return targetAmountOut Result amount of {targetToken_} after swap\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findSwapStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_\\n  ) external returns (\\n    address converter,\\n    uint sourceAmountOut,\\n    uint targetAmountOut,\\n    int apr18\\n  );\\n\\n  /// @notice Find best conversion strategy (swap or borrow) and provide \\\"cost of money\\\" as interest for the period.\\n  ///         It calls both findBorrowStrategy and findSwapStrategy and selects a best strategy.\\n  /// @dev This is writable function with read-only behavior.\\n  ///      It should be writable to be able to simulate real swap and get a real APR for swapping.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 is used by default\\n  /// @param amountIn_  The meaning depends on entryData\\n  ///                   For entryKind=0 it's max available amount of collateral\\n  ///                   This amount must be approved to TetuConverter before the call.\\n  ///                   For entryKind=2 we don't know amount of collateral before the call,\\n  ///                   so it's necessary to approve large enough amount (or make infinity approve)\\n  /// @param periodInBlocks_ Estimated period to keep target amount. It's required to compute APR\\n  /// @return converter Result contract that should be used for conversion to be passed to borrow().\\n  /// @return collateralAmountOut Amount of {sourceToken_} that should be swapped to get {targetToken_}\\n  ///                             It can be different from the {sourceAmount_} for some entry kinds.\\n  /// @return amountToBorrowOut Result amount of {targetToken_} after conversion\\n  /// @return apr18 Interest on the use of {outMaxTargetAmount} during the given period, decimals 18\\n  function findConversionStrategy(\\n    bytes memory entryData_,\\n    address sourceToken_,\\n    uint amountIn_,\\n    address targetToken_,\\n    uint periodInBlocks_\\n  ) external returns (\\n    address converter,\\n    uint collateralAmountOut,\\n    uint amountToBorrowOut,\\n    int apr18\\n  );\\n\\n  /// @notice Convert {collateralAmount_} to {amountToBorrow_} using {converter_}\\n  ///         Target amount will be transferred to {receiver_}. No re-balancing here.\\n  /// @dev Transferring of {collateralAmount_} by TetuConverter-contract must be approved by the caller before the call\\n  ///      Only whitelisted users are allowed to make borrows\\n  /// @param converter_ A converter received from findBestConversionStrategy.\\n  /// @param collateralAmount_ Amount of {collateralAsset_} to be converted.\\n  ///                          This amount must be approved to TetuConverter before the call.\\n  /// @param amountToBorrow_ Amount of {borrowAsset_} to be borrowed and sent to {receiver_}\\n  /// @param receiver_ A receiver of borrowed amount\\n  /// @return borrowedAmountOut Exact borrowed amount transferred to {receiver_}\\n  function borrow(\\n    address converter_,\\n    address collateralAsset_,\\n    uint collateralAmount_,\\n    address borrowAsset_,\\n    uint amountToBorrow_,\\n    address receiver_\\n  ) external returns (\\n    uint borrowedAmountOut\\n  );\\n\\n  /// @notice Full or partial repay of the borrow\\n  /// @dev A user should transfer {amountToRepay_} to TetuConverter before calling repay()\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        You can know exact total amount of debt using {getStatusCurrent}.\\n  ///        if the amount exceed total amount of the debt:\\n  ///           - the debt will be fully repaid\\n  ///           - remain amount will be swapped from {borrowAsset_} to {collateralAsset_}\\n  ///        This amount should be calculated with taking into account possible debt gap,\\n  ///        You should call getDebtAmountCurrent(debtGap = true) to get this amount.\\n  /// @param receiver_ A receiver of the collateral that will be withdrawn after the repay\\n  ///                  The remained amount of borrow asset will be returned to the {receiver_} too\\n  /// @return collateralAmountOut Exact collateral amount transferred to {collateralReceiver_}\\n  ///         If TetuConverter is not able to make the swap, it reverts\\n  /// @return returnedBorrowAmountOut A part of amount-to-repay that wasn't converted to collateral asset\\n  ///                                 because of any reasons (i.e. there is no available conversion strategy)\\n  ///                                 This amount is returned back to the collateralReceiver_\\n  /// @return swappedLeftoverCollateralOut A part of collateral received through the swapping\\n  /// @return swappedLeftoverBorrowOut A part of amountToRepay_ that was swapped\\n  function repay(\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_,\\n    address receiver_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint returnedBorrowAmountOut,\\n    uint swappedLeftoverCollateralOut,\\n    uint swappedLeftoverBorrowOut\\n  );\\n\\n  /// @notice Estimate result amount after making full or partial repay\\n  /// @dev It works in exactly same way as repay() but don't make actual repay\\n  ///      Anyway, the function is write, not read-only, because it makes updateStatus()\\n  /// @param user_ user whose amount-to-repay will be calculated\\n  /// @param amountToRepay_ Amount of borrowed asset to repay.\\n  ///        This amount should be calculated without possible debt gap.\\n  ///        In this way it's differ from {repay}\\n  /// @return collateralAmountOut Total collateral amount to be returned after repay in exchange of {amountToRepay_}\\n  /// @return swappedAmountOut A part of {collateralAmountOut} that were received by direct swap\\n  function quoteRepay(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountToRepay_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint swappedAmountOut\\n  );\\n\\n  /// @notice Update status in all opened positions\\n  ///         After this call getDebtAmount will be able to return exact amount to repay\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountCurrent(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice Total amount of borrow tokens that should be repaid to close the borrow completely.\\n  /// @param user_ user whose debts will be returned\\n  /// @param useDebtGap_ Calculate exact value of the debt (false) or amount to pay (true)\\n  ///        Exact value of the debt can be a bit different from amount to pay, i.e. AAVE has dust tokens problem.\\n  ///        Exact amount of debt should be used to calculate shared price, amount to pay - for repayment\\n  /// @return totalDebtAmountOut Borrowed amount that should be repaid to pay off the loan in full\\n  /// @return totalCollateralAmountOut Amount of collateral that should be received after paying off the loan\\n  function getDebtAmountStored(\\n    address user_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    bool useDebtGap_\\n  ) external view returns (\\n    uint totalDebtAmountOut,\\n    uint totalCollateralAmountOut\\n  );\\n\\n  /// @notice User needs to redeem some collateral amount. Calculate an amount of borrow token that should be repaid\\n  /// @param user_ user whose debts will be returned\\n  /// @param collateralAmountRequired_ Amount of collateral required by the user\\n  /// @return borrowAssetAmount Borrowed amount that should be repaid to receive back following amount of collateral:\\n  ///                           amountToReceive = collateralAmountRequired_ - unobtainableCollateralAssetAmount\\n  /// @return unobtainableCollateralAssetAmount A part of collateral that cannot be obtained in any case\\n  ///                                           even if all borrowed amount will be returned.\\n  ///                                           If this amount is not 0, you ask to get too much collateral.\\n  function estimateRepay(\\n    address user_,\\n    address collateralAsset_,\\n    uint collateralAmountRequired_,\\n    address borrowAsset_\\n  ) external view returns (\\n    uint borrowAssetAmount,\\n    uint unobtainableCollateralAssetAmount\\n  );\\n\\n  /// @notice Transfer all reward tokens to {receiver_}\\n  /// @return rewardTokensOut What tokens were transferred. Same reward token can appear in the array several times\\n  /// @return amountsOut Amounts of transferred rewards, the array is synced with {rewardTokens}\\n  function claimRewards(address receiver_) external returns (\\n    address[] memory rewardTokensOut,\\n    uint[] memory amountsOut\\n  );\\n\\n  /// @notice Swap {amountIn_} of {assetIn_} to {assetOut_} and send result amount to {receiver_}\\n  ///         The swapping is made using TetuLiquidator with checking price impact using embedded price oracle.\\n  /// @param amountIn_ Amount of {assetIn_} to be swapped.\\n  ///                      It should be transferred on balance of the TetuConverter before the function call\\n  /// @param receiver_ Result amount will be sent to this address\\n  /// @param priceImpactToleranceSource_ Price impact tolerance for liquidate-call, decimals = 100_000\\n  /// @param priceImpactToleranceTarget_ Price impact tolerance for price-oracle-check, decimals = 100_000\\n  /// @return amountOut The amount of {assetOut_} that has been sent to the receiver\\n  function safeLiquidate(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    address receiver_,\\n    uint priceImpactToleranceSource_,\\n    uint priceImpactToleranceTarget_\\n  ) external returns (\\n    uint amountOut\\n  );\\n\\n  /// @notice Check if {amountOut_} is too different from the value calculated directly using price oracle prices\\n  /// @return Price difference is ok for the given {priceImpactTolerance_}\\n  function isConversionValid(\\n    address assetIn_,\\n    uint amountIn_,\\n    address assetOut_,\\n    uint amountOut_,\\n    uint priceImpactTolerance_\\n  ) external view returns (bool);\\n\\n  /// @notice Close given borrow and return collateral back to the user, governance only\\n  /// @dev The pool adapter asks required amount-to-repay from the user internally\\n  /// @param poolAdapter_ The pool adapter that represents the borrow\\n  /// @param closePosition Close position after repay\\n  ///        Usually it should be true, because the function always tries to repay all debt\\n  ///        false can be used if user doesn't have enough amount to pay full debt\\n  ///              and we are trying to pay \\\"as much as possible\\\"\\n  /// @return collateralAmountOut Amount of collateral returned to the user\\n  /// @return repaidAmountOut Amount of borrow asset paid to the lending platform\\n  function repayTheBorrow(address poolAdapter_, bool closePosition) external returns (\\n    uint collateralAmountOut,\\n    uint repaidAmountOut\\n  );\\n\\n  /// @notice Get active borrows of the user with given collateral/borrowToken\\n  /// @dev Simple access to IDebtMonitor.getPositions\\n  /// @return poolAdaptersOut The instances of IPoolAdapter\\n  function getPositions(address user_, address collateralToken_, address borrowedToken_) external view returns (\\n    address[] memory poolAdaptersOut\\n  );\\n\\n  /// @notice Save token from TC-balance to {receiver}\\n  /// @dev Normally TetuConverter doesn't have any tokens on balance, they can appear there accidentally only\\n  function salvage(address receiver, address token, uint amount) external;\\n}\\n\",\"keccak256\":\"0xd30f740004b39189b18ab99299e9d673ff48b754e053415130a6eda95558fa7d\",\"license\":\"MIT\"},\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice TetuConverter sends callback notifications to its user via this interface\\ninterface ITetuConverterCallback {\\n  /// @notice Converters calls this function if user should return some amount back.\\n  ///         f.e. when the health factor is unhealthy and the converter needs more tokens to fix it.\\n  ///         or when the full repay is required and converter needs to get full amount-to-repay.\\n  /// @param asset_ Required asset (either collateral or borrow)\\n  /// @param amount_ Required amount of the {asset_}\\n  /// @return amountOut Exact amount that borrower has sent to balance of TetuConverter\\n  function requirePayAmountBack(address asset_, uint amount_) external returns (uint amountOut);\\n\\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external;\\n}\\n\",\"keccak256\":\"0x1ab7657c44e7725e32ef1a25293f1895911943bb25a8d0afb22a218ee4fa9d5b\",\"license\":\"MIT\"},\"contracts/integrations/balancer/IBVault.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\n\\ninterface IAsset {\\n}\\n\\ninterface IBVault {\\n  // Internal Balance\\n  //\\n  // Users can deposit tokens into the Vault, where they are allocated to their Internal Balance, and later\\n  // transferred or withdrawn. It can also be used as a source of tokens when joining Pools, as a destination\\n  // when exiting them, and as either when performing swaps. This usage of Internal Balance results in greatly reduced\\n  // gas costs when compared to relying on plain ERC20 transfers, leading to large savings for frequent users.\\n  //\\n  // Internal Balance management features batching, which means a single contract call can be used to perform multiple\\n  // operations of different kinds, with different senders and recipients, at once.\\n\\n  /**\\n   * @dev Returns `user`'s Internal Balance for a set of tokens.\\n     */\\n  function getInternalBalance(address user, IERC20[] calldata tokens) external view returns (uint256[] memory);\\n\\n  /**\\n   * @dev Performs a set of user balance operations, which involve Internal Balance (deposit, withdraw or transfer)\\n     * and plain ERC20 transfers using the Vault's allowance. This last feature is particularly useful for relayers, as\\n     * it lets integrators reuse a user's Vault allowance.\\n     *\\n     * For each operation, if the caller is not `sender`, it must be an authorized relayer for them.\\n     */\\n  function manageUserBalance(UserBalanceOp[] calldata ops) external payable;\\n\\n  /**\\n   * @dev Data for `manageUserBalance` operations, which include the possibility for ETH to be sent and received\\n     without manual WETH wrapping or unwrapping.\\n     */\\n  struct UserBalanceOp {\\n    UserBalanceOpKind kind;\\n    IAsset asset;\\n    uint256 amount;\\n    address sender;\\n    address payable recipient;\\n  }\\n\\n  // There are four possible operations in `manageUserBalance`:\\n  //\\n  // - DEPOSIT_INTERNAL\\n  // Increases the Internal Balance of the `recipient` account by transferring tokens from the corresponding\\n  // `sender`. The sender must have allowed the Vault to use their tokens via `IERC20.approve()`.\\n  //\\n  // ETH can be used by passing the ETH sentinel value as the asset and forwarding ETH in the call: it will be wrapped\\n  // and deposited as WETH. Any ETH amount remaining will be sent back to the caller (not the sender, which is\\n  // relevant for relayers).\\n  //\\n  // Emits an `InternalBalanceChanged` event.\\n  //\\n  //\\n  // - WITHDRAW_INTERNAL\\n  // Decreases the Internal Balance of the `sender` account by transferring tokens to the `recipient`.\\n  //\\n  // ETH can be used by passing the ETH sentinel value as the asset. This will deduct WETH instead, unwrap it and send\\n  // it to the recipient as ETH.\\n  //\\n  // Emits an `InternalBalanceChanged` event.\\n  //\\n  //\\n  // - TRANSFER_INTERNAL\\n  // Transfers tokens from the Internal Balance of the `sender` account to the Internal Balance of `recipient`.\\n  //\\n  // Reverts if the ETH sentinel value is passed.\\n  //\\n  // Emits an `InternalBalanceChanged` event.\\n  //\\n  //\\n  // - TRANSFER_EXTERNAL\\n  // Transfers tokens from `sender` to `recipient`, using the Vault's ERC20 allowance. This is typically used by\\n  // relayers, as it lets them reuse a user's Vault allowance.\\n  //\\n  // Reverts if the ETH sentinel value is passed.\\n  //\\n  // Emits an `ExternalBalanceTransfer` event.\\n\\n  enum UserBalanceOpKind {DEPOSIT_INTERNAL, WITHDRAW_INTERNAL, TRANSFER_INTERNAL, TRANSFER_EXTERNAL}\\n\\n  /**\\n   * @dev Emitted when a user's Internal Balance changes, either from calls to `manageUserBalance`, or through\\n     * interacting with Pools using Internal Balance.\\n     *\\n     * Because Internal Balance works exclusively with ERC20 tokens, ETH deposits and withdrawals will use the WETH\\n     * address.\\n     */\\n  event InternalBalanceChanged(address indexed user, IERC20 indexed token, int256 delta);\\n\\n  /**\\n   * @dev Emitted when a user's Vault ERC20 allowance is used by the Vault to transfer tokens to an external account.\\n     */\\n  event ExternalBalanceTransfer(IERC20 indexed token, address indexed sender, address recipient, uint256 amount);\\n\\n  // Pools\\n  //\\n  // There are three specialization settings for Pools, which allow for cheaper swaps at the cost of reduced\\n  // functionality:\\n  //\\n  //  - General: no specialization, suited for all Pools. IGeneralPool is used for swap request callbacks, passing the\\n  // balance of all tokens in the Pool. These Pools have the largest swap costs (because of the extra storage reads),\\n  // which increase with the number of registered tokens.\\n  //\\n  //  - Minimal Swap Info: IMinimalSwapInfoPool is used instead of IGeneralPool, which saves gas by only passing the\\n  // balance of the two tokens involved in the swap. This is suitable for some pricing algorithms, like the weighted\\n  // constant product one popularized by Balancer V1. Swap costs are smaller compared to general Pools, and are\\n  // independent of the number of registered tokens.\\n  //\\n  //  - Two Token: only allows two tokens to be registered. This achieves the lowest possible swap gas cost. Like\\n  // minimal swap info Pools, these are called via IMinimalSwapInfoPool.\\n\\n  enum PoolSpecialization {GENERAL, MINIMAL_SWAP_INFO, TWO_TOKEN}\\n\\n  /**\\n   * @dev Registers the caller account as a Pool with a given specialization setting. Returns the Pool's ID, which\\n     * is used in all Pool-related functions. Pools cannot be deregistered, nor can the Pool's specialization be\\n     * changed.\\n     *\\n     * The caller is expected to be a smart contract that implements either `IGeneralPool` or `IMinimalSwapInfoPool`,\\n     * depending on the chosen specialization setting. This contract is known as the Pool's contract.\\n     *\\n     * Note that the same contract may register itself as multiple Pools with unique Pool IDs, or in other words,\\n     * multiple Pools may share the same contract.\\n     *\\n     * Emits a `PoolRegistered` event.\\n     */\\n  function registerPool(PoolSpecialization specialization) external returns (bytes32);\\n\\n  /**\\n   * @dev Emitted when a Pool is registered by calling `registerPool`.\\n     */\\n  event PoolRegistered(bytes32 indexed poolId, address indexed poolAddress, PoolSpecialization specialization);\\n\\n  /**\\n   * @dev Returns a Pool's contract address and specialization setting.\\n     */\\n  function getPool(bytes32 poolId) external view returns (address, PoolSpecialization);\\n\\n  /**\\n   * @dev Registers `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Pools can only interact with tokens they have registered. Users join a Pool by transferring registered tokens,\\n     * exit by receiving registered tokens, and can only swap registered tokens.\\n     *\\n     * Each token can only be registered once. For Pools with the Two Token specialization, `tokens` must have a length\\n     * of two, that is, both tokens must be registered in the same `registerTokens` call, and they must be sorted in\\n     * ascending order.\\n     *\\n     * The `tokens` and `assetManagers` arrays must have the same length, and each entry in these indicates the Asset\\n     * Manager for the corresponding token. Asset Managers can manage a Pool's tokens via `managePoolBalance`,\\n     * depositing and withdrawing them directly, and can even set their balance to arbitrary amounts. They are therefore\\n     * expected to be highly secured smart contracts with sound design principles, and the decision to register an\\n     * Asset Manager should not be made lightly.\\n     *\\n     * Pools can choose not to assign an Asset Manager to a given token by passing in the zero address. Once an Asset\\n     * Manager is set, it cannot be changed except by deregistering the associated token and registering again with a\\n     * different Asset Manager.\\n     *\\n     * Emits a `TokensRegistered` event.\\n     */\\n  function registerTokens(\\n    bytes32 poolId,\\n    IERC20[] calldata tokens,\\n    address[] calldata assetManagers\\n  ) external;\\n\\n  /**\\n   * @dev Emitted when a Pool registers tokens by calling `registerTokens`.\\n     */\\n  event TokensRegistered(bytes32 indexed poolId, IERC20[] tokens, address[] assetManagers);\\n\\n  /**\\n   * @dev Deregisters `tokens` for the `poolId` Pool. Must be called by the Pool's contract.\\n     *\\n     * Only registered tokens (via `registerTokens`) can be deregistered. Additionally, they must have zero total\\n     * balance. For Pools with the Two Token specialization, `tokens` must have a length of two, that is, both tokens\\n     * must be deregistered in the same `deregisterTokens` call.\\n     *\\n     * A deregistered token can be re-registered later on, possibly with a different Asset Manager.\\n     *\\n     * Emits a `TokensDeregistered` event.\\n     */\\n  function deregisterTokens(bytes32 poolId, IERC20[] calldata tokens) external;\\n\\n  /**\\n   * @dev Emitted when a Pool deregisters tokens by calling `deregisterTokens`.\\n     */\\n  event TokensDeregistered(bytes32 indexed poolId, IERC20[] tokens);\\n\\n  /**\\n   * @dev Returns detailed information for a Pool's registered token.\\n     *\\n     * `cash` is the number of tokens the Vault currently holds for the Pool. `managed` is the number of tokens\\n     * withdrawn and held outside the Vault by the Pool's token Asset Manager. The Pool's total balance for `token`\\n     * equals the sum of `cash` and `managed`.\\n     *\\n     * Internally, `cash` and `managed` are stored using 112 bits. No action can ever cause a Pool's token `cash`,\\n     * `managed` or `total` balance to be greater than 2^112 - 1.\\n     *\\n     * `lastChangeBlock` is the number of the block in which `token`'s total balance was last modified (via either a\\n     * join, exit, swap, or Asset Manager update). This value is useful to avoid so-called 'sandwich attacks', for\\n     * example when developing price oracles. A change of zero (e.g. caused by a swap with amount zero) is considered a\\n     * change for this purpose, and will update `lastChangeBlock`.\\n     *\\n     * `assetManager` is the Pool's token Asset Manager.\\n     */\\n  function getPoolTokenInfo(bytes32 poolId, IERC20 token)\\n  external\\n  view\\n  returns (\\n    uint256 cash,\\n    uint256 managed,\\n    uint256 lastChangeBlock,\\n    address assetManager\\n  );\\n\\n  /**\\n   * @dev Returns a Pool's registered tokens, the total balance for each, and the latest block when *any* of\\n     * the tokens' `balances` changed.\\n     *\\n     * The order of the `tokens` array is the same order that will be used in `joinPool`, `exitPool`, as well as in all\\n     * Pool hooks (where applicable). Calls to `registerTokens` and `deregisterTokens` may change this order.\\n     *\\n     * If a Pool only registers tokens once, and these are sorted in ascending order, they will be stored in the same\\n     * order as passed to `registerTokens`.\\n     *\\n     * Total balances include both tokens held by the Vault and those withdrawn by the Pool's Asset Managers. These are\\n     * the amounts used by joins, exits and swaps. For a detailed breakdown of token balances, use `getPoolTokenInfo`\\n     * instead.\\n     */\\n  function getPoolTokens(bytes32 poolId)\\n  external\\n  view\\n  returns (\\n    IERC20[] memory tokens,\\n    uint256[] memory balances,\\n    uint256 lastChangeBlock\\n  );\\n\\n  /**\\n   * @dev Called by users to join a Pool, which transfers tokens from `sender` into the Pool's balance. This will\\n     * trigger custom Pool behavior, which will typically grant something in return to `recipient` - often tokenized\\n     * Pool shares.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `assets` and `maxAmountsIn` arrays must have the same length, and each entry indicates the maximum amount\\n     * to send for each asset. The amounts to send are decided by the Pool and not the Vault: it just enforces\\n     * these maximums.\\n     *\\n     * If joining a Pool that holds WETH, it is possible to send ETH directly: the Vault will do the wrapping. To enable\\n     * this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead of the\\n     * WETH address. Note that it is not possible to combine ETH and WETH in the same join. Any excess ETH will be sent\\n     * back to the caller (not the sender, which is important for relayers).\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If sending ETH however, the array must be\\n     * sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the final\\n     * `assets` array might not be sorted. Pools with no registered tokens cannot be joined.\\n     *\\n     * If `fromInternalBalance` is true, the caller's Internal Balance will be preferred: ERC20 transfers will only\\n     * be made for the difference between the requested amount and Internal Balance (if any). Note that ETH cannot be\\n     * withdrawn from Internal Balance: attempting to do so will trigger a revert.\\n     *\\n     * This causes the Vault to call the `IBasePool.onJoinPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares). This can be encoded in the `userData` argument, which is ignored by the Vault and passed\\n     * directly to the Pool's contract, as is `recipient`.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     *\\n     * See https://dev.balancer.fi/resources/joins-and-exits/pool-joins\\n     */\\n  function joinPool(\\n    bytes32 poolId,\\n    address sender,\\n    address recipient,\\n    JoinPoolRequest calldata request\\n  ) external payable;\\n\\n  enum JoinKind {INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT}\\n\\n  /// @notice WeightedPool ExitKinds\\n  enum ExitKind {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT}\\n  /// @notice Composable Stable V2 ExitKinds\\n  enum ExitKindComposableStable {EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT, EXACT_BPT_IN_FOR_ALL_TOKENS_OUT}\\n\\n\\n  struct JoinPoolRequest {\\n    IAsset[] assets;\\n    uint256[] maxAmountsIn;\\n    bytes userData;\\n    bool fromInternalBalance;\\n  }\\n\\n  /**\\n   * @dev Called by users to exit a Pool, which transfers tokens from the Pool's balance to `recipient`. This will\\n     * trigger custom Pool behavior, which will typically ask for something in return from `sender` - often tokenized\\n     * Pool shares. The amount of tokens that can be withdrawn is limited by the Pool's `cash` balance (see\\n     * `getPoolTokenInfo`).\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * The `tokens` and `minAmountsOut` arrays must have the same length, and each entry in these indicates the minimum\\n     * token amount to receive for each token contract. The amounts to send are decided by the Pool and not the Vault:\\n     * it just enforces these minimums.\\n     *\\n     * If exiting a Pool that holds WETH, it is possible to receive ETH directly: the Vault will do the unwrapping. To\\n     * enable this mechanism, the IAsset sentinel value (the zero address) must be passed in the `assets` array instead\\n     * of the WETH address. Note that it is not possible to combine ETH and WETH in the same exit.\\n     *\\n     * `assets` must have the same length and order as the array returned by `getPoolTokens`. This prevents issues when\\n     * interacting with Pools that register and deregister tokens frequently. If receiving ETH however, the array must\\n     * be sorted *before* replacing the WETH address with the ETH sentinel value (the zero address), which means the\\n     * final `assets` array might not be sorted. Pools with no registered tokens cannot be exited.\\n     *\\n     * If `toInternalBalance` is true, the tokens will be deposited to `recipient`'s Internal Balance. Otherwise,\\n     * an ERC20 transfer will be performed. Note that ETH cannot be deposited to Internal Balance: attempting to\\n     * do so will trigger a revert.\\n     *\\n     * `minAmountsOut` is the minimum amount of tokens the user expects to get out of the Pool, for each token in the\\n     * `tokens` array. This array must match the Pool's registered tokens.\\n     *\\n     * This causes the Vault to call the `IBasePool.onExitPool` hook on the Pool's contract, where Pools implement\\n     * their own custom logic. This typically requires additional information from the user (such as the expected number\\n     * of Pool shares to return). This can be encoded in the `userData` argument, which is ignored by the Vault and\\n     * passed directly to the Pool's contract.\\n     *\\n     * Emits a `PoolBalanceChanged` event.\\n     */\\n  function exitPool(\\n    bytes32 poolId,\\n    address sender,\\n    address payable recipient,\\n    ExitPoolRequest calldata request\\n  ) external;\\n\\n  struct ExitPoolRequest {\\n    IAsset[] assets;\\n    uint256[] minAmountsOut;\\n    bytes userData;\\n    bool toInternalBalance;\\n  }\\n\\n  /**\\n   * @dev Emitted when a user joins or exits a Pool by calling `joinPool` or `exitPool`, respectively.\\n     */\\n  event PoolBalanceChanged(\\n    bytes32 indexed poolId,\\n    address indexed liquidityProvider,\\n    IERC20[] tokens,\\n    int256[] deltas,\\n    uint256[] protocolFeeAmounts\\n  );\\n\\n  enum PoolBalanceChangeKind {JOIN, EXIT}\\n\\n  // Swaps\\n  //\\n  // Users can swap tokens with Pools by calling the `swap` and `batchSwap` functions. To do this,\\n  // they need not trust Pool contracts in any way: all security checks are made by the Vault. They must however be\\n  // aware of the Pools' pricing algorithms in order to estimate the prices Pools will quote.\\n  //\\n  // The `swap` function executes a single swap, while `batchSwap` can perform multiple swaps in sequence.\\n  // In each individual swap, tokens of one kind are sent from the sender to the Pool (this is the 'token in'),\\n  // and tokens of another kind are sent from the Pool to the recipient in exchange (this is the 'token out').\\n  // More complex swaps, such as one token in to multiple tokens out can be achieved by batching together\\n  // individual swaps.\\n  //\\n  // There are two swap kinds:\\n  //  - 'given in' swaps, where the amount of tokens in (sent to the Pool) is known, and the Pool determines (via the\\n  // `onSwap` hook) the amount of tokens out (to send to the recipient).\\n  //  - 'given out' swaps, where the amount of tokens out (received from the Pool) is known, and the Pool determines\\n  // (via the `onSwap` hook) the amount of tokens in (to receive from the sender).\\n  //\\n  // Additionally, it is possible to chain swaps using a placeholder input amount, which the Vault replaces with\\n  // the calculated output of the previous swap. If the previous swap was 'given in', this will be the calculated\\n  // tokenOut amount. If the previous swap was 'given out', it will use the calculated tokenIn amount. These extended\\n  // swaps are known as 'multihop' swaps, since they 'hop' through a number of intermediate tokens before arriving at\\n  // the final intended token.\\n  //\\n  // In all cases, tokens are only transferred in and out of the Vault (or withdrawn from and deposited into Internal\\n  // Balance) after all individual swaps have been completed, and the net token balance change computed. This makes\\n  // certain swap patterns, such as multihops, or swaps that interact with the same token pair in multiple Pools, cost\\n  // much less gas than they would otherwise.\\n  //\\n  // It also means that under certain conditions it is possible to perform arbitrage by swapping with multiple\\n  // Pools in a way that results in net token movement out of the Vault (profit), with no tokens being sent in (only\\n  // updating the Pool's internal accounting).\\n  //\\n  // To protect users from front-running or the market changing rapidly, they supply a list of 'limits' for each token\\n  // involved in the swap, where either the maximum number of tokens to send (by passing a positive value) or the\\n  // minimum amount of tokens to receive (by passing a negative value) is specified.\\n  //\\n  // Additionally, a 'deadline' timestamp can also be provided, forcing the swap to fail if it occurs after\\n  // this point in time (e.g. if the transaction failed to be included in a block promptly).\\n  //\\n  // If interacting with Pools that hold WETH, it is possible to both send and receive ETH directly: the Vault will do\\n  // the wrapping and unwrapping. To enable this mechanism, the IAsset sentinel value (the zero address) must be\\n  // passed in the `assets` array instead of the WETH address. Note that it is possible to combine ETH and WETH in the\\n  // same swap. Any excess ETH will be sent back to the caller (not the sender, which is relevant for relayers).\\n  //\\n  // Finally, Internal Balance can be used when either sending or receiving tokens.\\n\\n  enum SwapKind {GIVEN_IN, GIVEN_OUT}\\n\\n  /**\\n   * @dev Performs a swap with a single Pool.\\n     *\\n     * If the swap is 'given in' (the number of tokens to send to the Pool is known), it returns the amount of tokens\\n     * taken from the Pool, which must be greater than or equal to `limit`.\\n     *\\n     * If the swap is 'given out' (the number of tokens to take from the Pool is known), it returns the amount of tokens\\n     * sent to the Pool, which must be less than or equal to `limit`.\\n     *\\n     * Internal Balance usage and the recipient are determined by the `funds` struct.\\n     *\\n     * Emits a `Swap` event.\\n     */\\n  function swap(\\n    SingleSwap calldata singleSwap,\\n    FundManagement calldata funds,\\n    uint256 limit,\\n    uint256 deadline\\n  ) external payable returns (uint256);\\n\\n  /**\\n   * @dev Data for a single swap executed by `swap`. `amount` is either `amountIn` or `amountOut` depending on\\n     * the `kind` value.\\n     *\\n     * `assetIn` and `assetOut` are either token addresses, or the IAsset sentinel value for ETH (the zero address).\\n     * Note that Pools never interact with ETH directly: it will be wrapped to or unwrapped from WETH by the Vault.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n  struct SingleSwap {\\n    bytes32 poolId;\\n    SwapKind kind;\\n    IAsset assetIn;\\n    IAsset assetOut;\\n    uint256 amount;\\n    bytes userData;\\n  }\\n\\n  /**\\n   * @dev Performs a series of swaps with one or multiple Pools. In each individual swap, the caller determines either\\n     * the amount of tokens sent to or received from the Pool, depending on the `kind` value.\\n     *\\n     * Returns an array with the net Vault asset balance deltas. Positive amounts represent tokens (or ETH) sent to the\\n     * Vault, and negative amounts represent tokens (or ETH) sent by the Vault. Each delta corresponds to the asset at\\n     * the same index in the `assets` array.\\n     *\\n     * Swaps are executed sequentially, in the order specified by the `swaps` array. Each array element describes a\\n     * Pool, the token to be sent to this Pool, the token to receive from it, and an amount that is either `amountIn` or\\n     * `amountOut` depending on the swap kind.\\n     *\\n     * Multihop swaps can be executed by passing an `amount` value of zero for a swap. This will cause the amount in/out\\n     * of the previous swap to be used as the amount in for the current one. In a 'given in' swap, 'tokenIn' must equal\\n     * the previous swap's `tokenOut`. For a 'given out' swap, `tokenOut` must equal the previous swap's `tokenIn`.\\n     *\\n     * The `assets` array contains the addresses of all assets involved in the swaps. These are either token addresses,\\n     * or the IAsset sentinel value for ETH (the zero address). Each entry in the `swaps` array specifies tokens in and\\n     * out by referencing an index in `assets`. Note that Pools never interact with ETH directly: it will be wrapped to\\n     * or unwrapped from WETH by the Vault.\\n     *\\n     * Internal Balance usage, sender, and recipient are determined by the `funds` struct. The `limits` array specifies\\n     * the minimum or maximum amount of each token the vault is allowed to transfer.\\n     *\\n     * `batchSwap` can be used to make a single swap, like `swap` does, but doing so requires more gas than the\\n     * equivalent `swap` call.\\n     *\\n     * Emits `Swap` events.\\n     */\\n  function batchSwap(\\n    SwapKind kind,\\n    BatchSwapStep[] calldata swaps,\\n    IAsset[] calldata assets,\\n    FundManagement calldata funds,\\n    int256[] calldata limits,\\n    uint256 deadline\\n  ) external payable returns (int256[] memory);\\n\\n  /**\\n   * @dev Data for each individual swap executed by `batchSwap`. The asset in and out fields are indexes into the\\n     * `assets` array passed to that function, and ETH assets are converted to WETH.\\n     *\\n     * If `amount` is zero, the multihop mechanism is used to determine the actual amount based on the amount in/out\\n     * from the previous swap, depending on the swap kind.\\n     *\\n     * The `userData` field is ignored by the Vault, but forwarded to the Pool in the `onSwap` hook, and may be\\n     * used to extend swap behavior.\\n     */\\n  struct BatchSwapStep {\\n    bytes32 poolId;\\n    uint256 assetInIndex;\\n    uint256 assetOutIndex;\\n    uint256 amount;\\n    bytes userData;\\n  }\\n\\n  /**\\n   * @dev Emitted for each individual swap performed by `swap` or `batchSwap`.\\n     */\\n  event Swap(\\n    bytes32 indexed poolId,\\n    IERC20 indexed tokenIn,\\n    IERC20 indexed tokenOut,\\n    uint256 amountIn,\\n    uint256 amountOut\\n  );\\n\\n  /**\\n   * @dev All tokens in a swap are either sent from the `sender` account to the Vault, or from the Vault to the\\n     * `recipient` account.\\n     *\\n     * If the caller is not `sender`, it must be an authorized relayer for them.\\n     *\\n     * If `fromInternalBalance` is true, the `sender`'s Internal Balance will be preferred, performing an ERC20\\n     * transfer for the difference between the requested amount and the User's Internal Balance (if any). The `sender`\\n     * must have allowed the Vault to use their tokens via `IERC20.approve()`. This matches the behavior of\\n     * `joinPool`.\\n     *\\n     * If `toInternalBalance` is true, tokens will be deposited to `recipient`'s internal balance instead of\\n     * transferred. This matches the behavior of `exitPool`.\\n     *\\n     * Note that ETH cannot be deposited to or withdrawn from Internal Balance: attempting to do so will trigger a\\n     * revert.\\n     */\\n  struct FundManagement {\\n    address sender;\\n    bool fromInternalBalance;\\n    address payable recipient;\\n    bool toInternalBalance;\\n  }\\n\\n  /**\\n   * @dev Simulates a call to `batchSwap`, returning an array of Vault asset deltas. Calls to `swap` cannot be\\n     * simulated directly, but an equivalent `batchSwap` call can and will yield the exact same result.\\n     *\\n     * Each element in the array corresponds to the asset at the same index, and indicates the number of tokens (or ETH)\\n     * the Vault would take from the sender (if positive) or send to the recipient (if negative). The arguments it\\n     * receives are the same that an equivalent `batchSwap` call would receive.\\n     *\\n     * Unlike `batchSwap`, this function performs no checks on the sender or recipient field in the `funds` struct.\\n     * This makes it suitable to be called by off-chain applications via eth_call without needing to hold tokens,\\n     * approve them for the Vault, or even know a user's address.\\n     *\\n     * Note that this function is not 'view' (due to implementation details): the client code must explicitly execute\\n     * eth_call instead of eth_sendTransaction.\\n     */\\n  function queryBatchSwap(\\n    SwapKind kind,\\n    BatchSwapStep[] calldata swaps,\\n    IAsset[] calldata assets,\\n    FundManagement calldata funds\\n  ) external returns (int256[] memory assetDeltas);\\n\\n  // BasePool.sol\\n\\n  /**\\n* @dev Returns the amount of BPT that would be burned from `sender` if the `onExitPool` hook were called by the\\n     * Vault with the same arguments, along with the number of tokens `recipient` would receive.\\n     *\\n     * This function is not meant to be called directly, but rather from a helper contract that fetches current Vault\\n     * data, such as the protocol swap fee percentage and Pool balances.\\n     *\\n     * Like `IVault.queryBatchSwap`, this function is not view due to internal implementation details: the caller must\\n     * explicitly use eth_call instead of eth_sendTransaction.\\n     */\\n  function queryExit(\\n    bytes32 poolId,\\n    address sender,\\n    address recipient,\\n    uint256[] memory balances,\\n    uint256 lastChangeBlock,\\n    uint256 protocolSwapFeePercentage,\\n    bytes memory userData\\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\\n\\n\\n}\\n\",\"keccak256\":\"0x2b2e887f0da61add43d50ec2fec09e2c4efa10f2c0bf230e4918b82a61a4b8a0\",\"license\":\"ISC\"},\"contracts/integrations/balancer/IBalancerGauge.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.17;\\n\\ninterface IBalancerGauge {\\n  function decimals() external view returns (uint256);\\n\\n  function version() external view returns (string memory);\\n\\n  function last_claim() external view returns (uint256);\\n\\n  function claimed_reward(address _addr, address _token) external view returns (uint256);\\n\\n  function claimable_reward(address _addr, address _token) external view returns (uint256);\\n\\n  function claimable_reward_write(address _addr, address _token) external returns (uint256);\\n\\n  function reward_contract() external view returns (address);\\n\\n  function reward_data(address _token) external view returns (\\n    address token,\\n    address distributor,\\n    uint256 period_finish,\\n    uint256 rate,\\n    uint256 last_update,\\n    uint256 integral\\n  );\\n\\n  function reward_tokens(uint256 arg0) external view returns (address);\\n\\n  function reward_balances(address arg0) external view returns (uint256);\\n\\n  function rewards_receiver(address arg0) external view returns (address);\\n\\n  function reward_integral(address arg0) external view returns (uint256);\\n\\n  function reward_integral_for(address arg0, address arg1) external view returns (uint256);\\n\\n  function set_rewards_receiver(address _receiver) external;\\n\\n  function set_rewards(\\n    address _reward_contract,\\n    bytes32 _claim_sig,\\n    address[8] memory _reward_tokens\\n  ) external;\\n\\n  function claim_rewards() external;\\n\\n  function claim_rewards(address _addr) external;\\n\\n  function claim_rewards(address _addr, address _receiver) external;\\n\\n  function deposit(uint256 _value) external;\\n\\n  function deposit(uint256 _value, address _addr) external;\\n\\n  function deposit(uint256 _value, address _addr, bool _claim_rewards) external;\\n\\n  function withdraw(uint256 _value) external;\\n\\n  function withdraw(uint256 _value, bool _claim_rewards) external;\\n\\n  function transfer(address _to, uint256 _value) external returns (bool);\\n\\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\\n\\n  function allowance(address owner, address spender) external view returns (uint256);\\n\\n  function approve(address _spender, uint256 _value) external returns (bool);\\n\\n  function permit(\\n    address _owner,\\n    address _spender,\\n    uint256 _value,\\n    uint256 _deadline,\\n    uint8 _v,\\n    bytes32 _r,\\n    bytes32 _s\\n  ) external returns (bool);\\n\\n  function increaseAllowance(address _spender, uint256 _added_value) external returns (bool);\\n\\n  function decreaseAllowance(address _spender, uint256 _subtracted_value) external returns (bool);\\n\\n  function initialize(\\n    address _lp_token,\\n    address _reward_contract,\\n    bytes32 _claim_sig\\n  ) external;\\n\\n  function lp_token() external view returns (address);\\n\\n  function balanceOf(address arg0) external view returns (uint256);\\n\\n  function totalSupply() external view returns (uint256);\\n\\n  function name() external view returns (string memory);\\n\\n  function symbol() external view returns (string memory);\\n\\n  function DOMAIN_SEPARATOR() external view returns (bytes32);\\n\\n  function nonces(address arg0) external view returns (uint256);\\n\\n  function claim_sig() external view returns (bytes memory);\\n}\\n\",\"keccak256\":\"0x8cb270fd43c89c384b29a0ce1b6ddd4d51ed66041df9775edeba0c88c5140ad9\",\"license\":\"ISC\"},\"contracts/integrations/balancer/IBalancerHelper.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./IBVault.sol\\\";\\n\\ninterface IBalancerHelper {\\n  function queryExit(\\n    bytes32 poolId,\\n    address sender,\\n    address recipient,\\n    IBVault.ExitPoolRequest memory request\\n  ) external returns (uint256 bptIn, uint256[] memory amountsOut);\\n\\n  function queryJoin(\\n    bytes32 poolId,\\n    address sender,\\n    address recipient,\\n    IBVault.JoinPoolRequest memory request\\n  ) external returns (uint256 bptOut, uint256[] memory amountsIn);\\n\\n  function vault() external view returns (address);\\n}\\n\",\"keccak256\":\"0x96bc57bb3b52f36aebaf700f2a5fa44bcc3222b70c2d19c59213dd3bd96b9b3e\",\"license\":\"MIT\"},\"contracts/integrations/balancer/IChildChainLiquidityGaugeFactory.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.17;\\n\\n/// @notice ChildChainLiquidityGaugeFactory, restored for 0x3b8cA519122CdD8efb272b0D3085453404B25bD0\\n/// @dev See https://dev.balancer.fi/resources/vebal-and-gauges/gauges\\ninterface IChildChainLiquidityGaugeFactory {\\n  event RewardsOnlyGaugeCreated(\\n    address indexed gauge,\\n    address indexed pool,\\n    address streamer\\n  );\\n\\n  function create(address pool) external returns (address);\\n\\n  function getChildChainStreamerImplementation() external view returns (address);\\n\\n  function getGaugeImplementation() external view returns (address);\\n\\n  function getGaugePool(address gauge) external view returns (address);\\n\\n  function getGaugeStreamer(address gauge) external view returns (address);\\n\\n  function getPoolGauge(address pool) external view returns (address);\\n\\n  function getPoolStreamer(address pool) external view returns (address);\\n\\n  function isGaugeFromFactory(address gauge) external view returns (bool);\\n\\n  function isStreamerFromFactory(address streamer) external view returns (bool);\\n}\\n\\n\",\"keccak256\":\"0xa294b677f4a7dad2fde2ecd9c1ad212e32325ed711a3e518b6864d704e11540d\",\"license\":\"ISC\"},\"contracts/integrations/balancer/IComposableStablePool.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.17;\\n\\ninterface IComposableStablePool {\\n  function balanceOf(address account) external view returns (uint256);\\n  function getActualSupply() external view returns (uint256);\\n  function getPoolId() external view returns (bytes32);\\n  function getBptIndex() external view returns (uint256);\\n  function updateTokenRateCache(address token) external;\\n}\",\"keccak256\":\"0xfdbd081e55daeb69baa5889d77a842f44ea8502537aea0a73befabf386a33e97\",\"license\":\"ISC\"},\"contracts/integrations/balancer/ILinearPool.sol\":{\"content\":\"// SPDX-License-Identifier: ISC\\npragma solidity 0.8.17;\\n\\ninterface ILinearPool {\\n  function getPoolId() external view returns (bytes32);\\n\\n  function getMainIndex() external view returns (uint);\\n\\n  function getMainToken() external view returns (address);\\n\\n  function getWrappedIndex() external view returns (uint);\\n\\n  function getWrappedToken() external view returns (address);\\n\\n  function getWrappedTokenRate() external view returns (uint);\\n\\n  function getRate() external view returns (uint);\\n\\n  function getBptIndex() external pure returns (uint);\\n\\n  function getVirtualSupply() external view returns (uint);\\n\\n  function getSwapFeePercentage() external view returns (uint);\\n\\n  function getTargets() external view returns (uint lowerTarget, uint upperTarget);\\n\\n  function totalSupply() external view returns (uint);\\n\\n  function getScalingFactors() external view returns (uint[] memory);\\n}\",\"keccak256\":\"0x4561203c56e362b2dd3618624bb2a49193379cc465460eabc0dfdd9bb363b2da\",\"license\":\"ISC\"},\"contracts/libs/AppErrors.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice List of all errors generated by the application\\n///         Each error should have unique code TS-XXX and descriptive comment\\nlibrary AppErrors {\\n  /// @notice Provided address should be not zero\\n  string public constant ZERO_ADDRESS = \\\"TS-1 zero address\\\";\\n\\n  /// @notice A pair of the tokens cannot be found in the factory of uniswap pairs\\n  string public constant UNISWAP_PAIR_NOT_FOUND = \\\"TS-2 pair not found\\\";\\n\\n  /// @notice Lengths not matched\\n  string public constant WRONG_LENGTHS = \\\"TS-4 wrong lengths\\\";\\n\\n  /// @notice Unexpected zero balance\\n  string public constant ZERO_BALANCE = \\\"TS-5 zero balance\\\";\\n\\n  string public constant ITEM_NOT_FOUND = \\\"TS-6 not found\\\";\\n\\n  string public constant NOT_ENOUGH_BALANCE = \\\"TS-7 not enough balance\\\";\\n\\n  /// @notice Price oracle returns zero price\\n  string public constant ZERO_PRICE = \\\"TS-8 zero price\\\";\\n\\n  string public constant WRONG_VALUE = \\\"TS-9 wrong value\\\";\\n\\n  /// @notice TetuConvertor wasn't able to make borrow, i.e. borrow-strategy wasn't found\\n  string public constant ZERO_AMOUNT_BORROWED = \\\"TS-10 zero borrowed amount\\\";\\n\\n  string public constant WITHDRAW_TOO_MUCH = \\\"TS-11 try to withdraw too much\\\";\\n\\n  string public constant UNKNOWN_ENTRY_KIND = \\\"TS-12 unknown entry kind\\\";\\n\\n  string public constant ONLY_TETU_CONVERTER = \\\"TS-13 only TetuConverter\\\";\\n\\n  string public constant WRONG_ASSET = \\\"TS-14 wrong asset\\\";\\n\\n  string public constant NO_LIQUIDATION_ROUTE = \\\"TS-15 No liquidation route\\\";\\n\\n  string public constant PRICE_IMPACT = \\\"TS-16 price impact\\\";\\n\\n  /// @notice tetuConverter_.repay makes swap internally. It's not efficient and not allowed\\n  string public constant REPAY_MAKES_SWAP = \\\"TS-17 can not convert back\\\";\\n\\n  string public constant NO_INVESTMENTS = \\\"TS-18 no investments\\\";\\n\\n  string public constant INCORRECT_LENGTHS = \\\"TS-19 lengths\\\";\\n\\n  /// @notice We expect increasing of the balance, but it was decreased\\n  string public constant BALANCE_DECREASE = \\\"TS-20 balance decrease\\\";\\n\\n  /// @notice Prices changed and invested assets amount was increased on S, value of S is too high\\n  string public constant EARNED_AMOUNT_TOO_HIGH = \\\"TS-21 earned too high\\\";\\n}\\n\",\"keccak256\":\"0x13ba3c11c4c87d6dfb6e76fdd06d848e627f800eb771f8e55b0d4eb784c1766c\",\"license\":\"MIT\"},\"contracts/libs/AppLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\\\";\\n\\n/// @notice Common internal utils\\nlibrary AppLib {\\n  using SafeERC20 for IERC20;\\n\\n  /// @notice Unchecked increment for for-cycles\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\n    unchecked {\\n      return i + 1;\\n    }\\n  }\\n\\n  /// @notice Make infinite approve of {token} to {spender} if the approved amount is less than {amount}\\n  /// @dev Should NOT be used for third-party pools\\n  function approveIfNeeded(address token, uint amount, address spender) internal {\\n    if (IERC20(token).allowance(address(this), spender) < amount) {\\n      IERC20(token).safeApprove(spender, 0);\\n      // infinite approve, 2*255 is more gas efficient then type(uint).max\\n      IERC20(token).safeApprove(spender, 2 ** 255);\\n    }\\n  }\\n\\n  function balance(address token) internal view returns (uint) {\\n    return IERC20(token).balanceOf(address(this));\\n  }\\n}\\n\",\"keccak256\":\"0xfab865a9b68066722b1ffea0123683a3a0515bc4cfa03c067c93d191a625e63d\",\"license\":\"MIT\"},\"contracts/libs/AppPlatforms.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity 0.8.17;\\r\\n\\r\\nlibrary AppPlatforms {\\r\\n  string public constant UNIV3 = \\\"UniswapV3\\\";\\r\\n  string public constant BALANCER = \\\"Balancer\\\";\\r\\n}\\r\\n\",\"keccak256\":\"0xca5bb09d394af89464d0e2b4ae848694f4b8adccb896052154ff46010bdaa834\",\"license\":\"MIT\"},\"contracts/libs/ConverterEntryKinds.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @notice Utils and constants related to entryKind param of ITetuConverter.findBorrowStrategy\\nlibrary ConverterEntryKinds {\\n  /// @notice Amount of collateral is fixed. Amount of borrow should be max possible.\\n  uint constant public ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0 = 0;\\n\\n  /// @notice Split provided source amount S on two parts: C1 and C2 (C1 + C2 = S)\\n  ///         C2 should be used as collateral to make a borrow B.\\n  ///         Results amounts of C1 and B (both in terms of USD) must be in the given proportion\\n  uint constant public ENTRY_KIND_EXACT_PROPORTION_1 = 1;\\n\\n  /// @notice Borrow given amount using min possible collateral\\n  uint constant public ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2 = 2;\\n\\n  /// @notice Decode entryData, extract first uint - entry kind\\n  ///         Valid values of entry kinds are given by ENTRY_KIND_XXX constants above\\n  function getEntryKind(bytes memory entryData_) internal pure returns (uint) {\\n    if (entryData_.length == 0) {\\n      return ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0;\\n    }\\n    return abi.decode(entryData_, (uint));\\n  }\\n}\\n\",\"keccak256\":\"0x42e53e67f20fe11a5f5209e21f2d9b2ebeacdb197ae506ac796920907ea679a2\",\"license\":\"MIT\"},\"contracts/libs/TokenAmountsLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"./AppErrors.sol\\\";\\n\\n/// @title Library for clearing / joining token addresses & amounts arrays\\n/// @author bogdoslav\\nlibrary TokenAmountsLib {\\n  /// @notice Version of the contract\\n  /// @dev Should be incremented when contract changed\\n  string internal constant TOKEN_AMOUNTS_LIB_VERSION = \\\"1.0.1\\\";\\n\\n  function uncheckedInc(uint i) internal pure returns (uint) {\\n    unchecked {\\n      return i + 1;\\n    }\\n  }\\n\\n  function filterZeroAmounts(\\n    address[] memory tokens,\\n    uint[] memory amounts\\n  ) internal pure returns (\\n    address[] memory t,\\n    uint[] memory a\\n  ) {\\n    require(tokens.length == amounts.length, AppErrors.INCORRECT_LENGTHS);\\n    uint len2 = 0;\\n    uint len = tokens.length;\\n    for (uint i = 0; i < len; i++) {\\n      if (amounts[i] != 0) len2++;\\n    }\\n\\n    t = new address[](len2);\\n    a = new uint[](len2);\\n\\n    uint j = 0;\\n    for (uint i = 0; i < len; i++) {\\n      uint amount = amounts[i];\\n      if (amount != 0) {\\n        t[j] = tokens[i];\\n        a[j] = amount;\\n        j++;\\n      }\\n    }\\n  }\\n\\n  /// @notice unites three arrays to single array without duplicates, amounts are sum, zero amounts are allowed\\n  function combineArrays(\\n    address[] memory tokens0,\\n    uint[] memory amounts0,\\n    address[] memory tokens1,\\n    uint[] memory amounts1,\\n    address[] memory tokens2,\\n    uint[] memory amounts2\\n  ) internal pure returns (\\n    address[] memory allTokens,\\n    uint[] memory allAmounts\\n  ) {\\n    uint[] memory lens = new uint[](3);\\n    lens[0] = tokens0.length;\\n    lens[1] = tokens1.length;\\n    lens[2] = tokens2.length;\\n\\n    require(\\n      lens[0] == amounts0.length && lens[1] == amounts1.length && lens[2] == amounts2.length,\\n      AppErrors.INCORRECT_LENGTHS\\n    );\\n\\n    uint maxLength = lens[0] + lens[1] + lens[2];\\n    address[] memory tokensOut = new address[](maxLength);\\n    uint[] memory amountsOut = new uint[](maxLength);\\n    uint unitedLength;\\n\\n    for (uint step; step < 3; ++step) {\\n      uint[] memory amounts = step == 0\\n        ? amounts0\\n        : (step == 1\\n          ? amounts1\\n          : amounts2);\\n      address[] memory tokens = step == 0\\n        ? tokens0\\n        : (step == 1\\n          ? tokens1\\n          : tokens2);\\n      for (uint i1 = 0; i1 < lens[step]; i1++) {\\n        uint amount1 = amounts[i1];\\n        address token1 = tokens[i1];\\n        bool united = false;\\n\\n        for (uint i = 0; i < unitedLength; i++) {\\n          if (token1 == tokensOut[i]) {\\n            amountsOut[i] += amount1;\\n            united = true;\\n            break;\\n          }\\n        }\\n\\n        if (!united) {\\n          tokensOut[unitedLength] = token1;\\n          amountsOut[unitedLength] = amount1;\\n          unitedLength++;\\n        }\\n      }\\n    }\\n\\n    // copy united tokens to result array\\n    allTokens = new address[](unitedLength);\\n    allAmounts = new uint[](unitedLength);\\n    for (uint i; i < unitedLength; i++) {\\n      allTokens[i] = tokensOut[i];\\n      allAmounts[i] = amountsOut[i];\\n    }\\n\\n  }\\n}\\n\",\"keccak256\":\"0x6be459b8106584d7f9d3ad9f7a9fe6afa86bc41c5915c2d708715dba75c6174a\",\"license\":\"MIT\"},\"contracts/strategies/ConverterStrategyBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyBaseV2.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverterCallback.sol\\\";\\nimport \\\"./ConverterStrategyBaseLib.sol\\\";\\nimport \\\"./ConverterStrategyBaseLib2.sol\\\";\\nimport \\\"./DepositorBase.sol\\\";\\n/////////////////////////////////////////////////////////////////////\\n///                        TERMS\\n///  Main asset == underlying: the asset deposited to the vault by users\\n///  Secondary assets: all assets deposited to the internal pool except the main asset\\n/////////////////////////////////////////////////////////////////////\\n\\n/// @title Abstract contract for base Converter strategy functionality\\n/// @notice All depositor assets must be correlated (ie USDC/USDT/DAI)\\n/// @author bogdoslav, dvpublic\\nabstract contract ConverterStrategyBase is ITetuConverterCallback, DepositorBase, StrategyBaseV2 {\\n  using SafeERC20 for IERC20;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region DATA TYPES\\n  /////////////////////////////////////////////////////////////////////\\n\\n  struct WithdrawUniversalLocal {\\n    bool all;\\n    uint[] reservesBeforeWithdraw;\\n    uint totalSupplyBeforeWithdraw;\\n    uint depositorLiquidity;\\n    uint liquidityAmountToWithdraw;\\n    uint assetPrice;\\n    uint[] amountsToConvert;\\n    uint expectedTotalMainAssetAmount;\\n    uint[] expectedMainAssetAmounts;\\n    uint investedAssetsAfterWithdraw;\\n    uint balanceAfterWithdraw;\\n    address[] tokens;\\n    address asset;\\n    uint indexAsset;\\n    uint balanceBefore;\\n    uint[] withdrawnAmounts;\\n    ITetuConverter converter;\\n  }\\n  //endregion DATA TYPES\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region CONSTANTS\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Version of this contract. Adjust manually on each code modification.\\n  string public constant CONVERTER_STRATEGY_BASE_VERSION = \\\"1.2.0\\\";\\n\\n  /// @notice 1% gap to cover possible liquidation inefficiency\\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\\n  uint internal constant GAP_CONVERSION = 1_000;\\n  uint internal constant DENOMINATOR = 100_000;\\n  //endregion CONSTANTS\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region VARIABLES\\n  //                Keep names and ordering!\\n  // Add only in the bottom and don't forget to decrease gap variable\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Amount of underlying assets invested to the pool.\\n  uint internal _investedAssets;\\n\\n  /// @dev Linked Tetu Converter\\n  ITetuConverter public converter;\\n\\n  /// @notice Minimum token amounts that can be liquidated\\n  mapping(address => uint) public liquidationThresholds;\\n\\n  /// @notice Percent of asset amount that can be not invested, it's allowed to just keep it on balance\\n  ///         decimals = {DENOMINATOR}\\n  /// @dev We need this threshold to avoid numerous conversions of small amounts\\n  uint public reinvestThresholdPercent;\\n\\n  /// @notice Ratio to split performance fee on toPerf + toInsurance, [0..100_000]\\n  ///         100_000 - send full amount toPerf, 0 - send full amount toInsurance.\\n  uint public performanceFeeRatio;\\n  //endregion VARIABLES\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Events\\n  /////////////////////////////////////////////////////////////////////\\n  event OnDepositorEnter(uint[] amounts, uint[] consumedAmounts);\\n  event OnDepositorExit(uint liquidityAmount, uint[] withdrawnAmounts);\\n  event OnDepositorEmergencyExit(uint[] withdrawnAmounts);\\n  event OnHardWorkEarnedLost(\\n    uint investedAssetsNewPrices,\\n    uint earnedByPrices,\\n    uint earnedHandleRewards,\\n    uint lostHandleRewards,\\n    uint earnedDeposit,\\n    uint lostDeposit\\n  );\\n\\n  /// @notice Recycle was made\\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\\n  /// @param amountsToForward Amounts to be sent to forwarder\\n  event Recycle(\\n    address[] rewardTokens,\\n    uint[] amountsToForward,\\n    uint toPerf,\\n    uint toInsurance\\n  );\\n  //endregion Events\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Initialization and configuration\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Initialize contract after setup it as proxy implementation\\n  function __ConverterStrategyBase_init(\\n    address controller_,\\n    address splitter_,\\n    address converter_\\n  ) internal onlyInitializing {\\n    __StrategyBase_init(controller_, splitter_);\\n    converter = ITetuConverter(converter_);\\n\\n    // 1% by default\\n    reinvestThresholdPercent = DENOMINATOR / 100;\\n    emit ConverterStrategyBaseLib2.ReinvestThresholdPercentChanged(DENOMINATOR / 100);\\n  }\\n\\n  function setLiquidationThreshold(address token, uint amount) external {\\n    ConverterStrategyBaseLib2.checkLiquidationThresholdChanged(controller(), token, amount);\\n    liquidationThresholds[token] = amount;\\n  }\\n\\n  /// @param percent_ New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}\\n  function setReinvestThresholdPercent(uint percent_) external {\\n    ConverterStrategyBaseLib2.checkReinvestThresholdPercentChanged(controller(), percent_);\\n    reinvestThresholdPercent = percent_;\\n  }\\n\\n  /// @notice [0..100_000], 100_000 - send full amount toPerf, 0 - send full amount toInsurance.\\n  function setPerformanceFeeRatio(uint ratio_) external {\\n    ConverterStrategyBaseLib2.checkPerformanceFeeRatioChanged(controller(), ratio_);\\n    performanceFeeRatio = ratio_;\\n  }\\n  //endregion Initialization and configuration\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Deposit to the pool\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Amount of underlying assets converted to pool assets and invested to the pool.\\n  function investedAssets() override public view virtual returns (uint) {\\n    return _investedAssets;\\n  }\\n\\n  /// @notice Deposit given amount to the pool.\\n  function _depositToPool(uint amount_, bool updateTotalAssetsBeforeInvest_) override internal virtual returns (\\n    uint strategyLoss\\n  ){\\n    (uint updatedInvestedAssets, uint earnedByPrices) = _fixPriceChanges(updateTotalAssetsBeforeInvest_);\\n    (strategyLoss,) = _depositToPoolUniversal(amount_, earnedByPrices, updatedInvestedAssets);\\n  }\\n\\n  /// @notice Deposit {amount_} to the pool, send {earnedByPrices_} to insurance.\\n  ///         totalAsset will decrease on earnedByPrices_ and sharePrice won't change after all recalculations.\\n  /// @dev We need to deposit {amount_} and withdraw {earnedByPrices_} here\\n  /// @param amount_ Amount of underlying to be deposited\\n  /// @param earnedByPrices_ Profit received because of price changing\\n  /// @param investedAssets_ Invested assets value calculated with updated prices\\n  /// @return strategyLoss Loss happened on the depositing. It doesn't include any price-changing losses\\n  /// @return amountSentToInsurance Price-changing-profit that was sent to the insurance\\n  function _depositToPoolUniversal(uint amount_, uint earnedByPrices_, uint investedAssets_) internal virtual returns (\\n    uint strategyLoss,\\n    uint amountSentToInsurance\\n  ){\\n    address _asset = asset;\\n\\n    uint amountToDeposit = amount_ > earnedByPrices_\\n      ? amount_ - earnedByPrices_\\n      : 0;\\n\\n    // skip deposit for small amounts\\n    if (amountToDeposit > reinvestThresholdPercent * investedAssets_ / DENOMINATOR) {\\n      if (earnedByPrices_ != 0) {\\n        amountSentToInsurance = ConverterStrategyBaseLib2.sendToInsurance(\\n          _asset,\\n          earnedByPrices_,\\n          splitter,\\n          investedAssets_ + AppLib.balance(_asset)\\n        );\\n      }\\n      uint balanceBefore = AppLib.balance(_asset);\\n\\n      (address[] memory tokens, uint indexAsset) = _getTokens(asset);\\n\\n      // prepare array of amounts ready to deposit, borrow missed amounts\\n      uint[] memory amounts = _beforeDeposit(converter, amountToDeposit, tokens, indexAsset);\\n\\n      // make deposit, actually consumed amounts can be different from the desired amounts\\n      (uint[] memory consumedAmounts,) = _depositorEnter(amounts);\\n      emit OnDepositorEnter(amounts, consumedAmounts);\\n\\n      // update _investedAssets with new deposited amount\\n      uint updatedInvestedAssetsAfterDeposit = _updateInvestedAssets();\\n      // after deposit some asset can exist\\n      uint balanceAfter = AppLib.balance(_asset);\\n      // we need to compensate difference if during deposit we lost some assets\\n      if ((updatedInvestedAssetsAfterDeposit + balanceAfter) < (investedAssets_ + balanceBefore)) {\\n        strategyLoss = (investedAssets_ + balanceBefore) - (updatedInvestedAssetsAfterDeposit + balanceAfter);\\n      }\\n    } else if (earnedByPrices_ != 0) {\\n      // we just skip check of expectedWithdrewUSD here\\n      uint balance = AppLib.balance(_asset);\\n      if (balance < earnedByPrices_) {\\n        (/* expectedWithdrewUSD */,, strategyLoss, amountSentToInsurance) = _withdrawUniversal(0, earnedByPrices_, investedAssets_);\\n      } else {\\n        amountSentToInsurance = ConverterStrategyBaseLib2.sendToInsurance(\\n          _asset,\\n          earnedByPrices_,\\n          splitter,\\n          investedAssets_ + balance\\n        );\\n      }\\n    }\\n\\n    return (strategyLoss, amountSentToInsurance);\\n  }\\n  //endregion Deposit to the pool\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Convert amounts before deposit\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Prepare {tokenAmounts} to be passed to depositorEnter\\n  /// @dev Override this function to customize entry kind\\n  /// @param amount_ The amount of main asset that should be invested\\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\n  /// @return tokenAmounts Amounts of depositor's assets ready to invest (this array can be passed to depositorEnter)\\n  function _beforeDeposit(\\n    ITetuConverter tetuConverter_,\\n    uint amount_,\\n    address[] memory tokens_,\\n    uint indexAsset_\\n  ) internal virtual returns (\\n    uint[] memory tokenAmounts\\n  ) {\\n    // calculate required collaterals for each token and temporary save them to tokenAmounts\\n    (uint[] memory weights, uint totalWeight) = _depositorPoolWeights();\\n    // temporary save collateral to tokensAmounts\\n    tokenAmounts = ConverterStrategyBaseLib2.getCollaterals(\\n      amount_,\\n      tokens_,\\n      weights,\\n      totalWeight,\\n      indexAsset_,\\n      IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle())\\n    );\\n\\n    // make borrow and save amounts of tokens available for deposit to tokenAmounts, zero result amounts are possible\\n    tokenAmounts = ConverterStrategyBaseLib.getTokenAmounts(\\n      tetuConverter_,\\n      tokens_,\\n      indexAsset_,\\n      tokenAmounts,\\n      liquidationThresholds[tokens_[indexAsset_]]\\n    );\\n  }\\n  //endregion Convert amounts before deposit\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Withdraw from the pool\\n  /////////////////////////////////////////////////////////////////////\\n\\n  function _beforeWithdraw(uint /*amount*/) internal virtual {\\n    // do nothing\\n  }\\n\\n  /// @notice Withdraw given amount from the pool.\\n  /// @param amount Amount to be withdrawn in terms of the asset in addition to the exist balance.\\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing (in USD, decimals of the {asset})\\n  /// @return assetPrice Price of the {asset} from the price oracle\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function _withdrawFromPool(uint amount) override internal virtual returns (\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    uint strategyLoss\\n  ) {\\n    // calculate profit/loss because of price changes, try to compensate the loss from the insurance\\n    (uint investedAssetsNewPrices, uint earnedByPrices) = _fixPriceChanges(true);\\n    (expectedWithdrewUSD, assetPrice, strategyLoss,) = _withdrawUniversal(amount, earnedByPrices, investedAssetsNewPrices);\\n  }\\n\\n  /// @notice Withdraw all from the pool.\\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing\\n  /// @return assetPrice Price of the {asset} taken from the price oracle\\n  /// @return strategyLoss Loss should be covered from Insurance\\n  function _withdrawAllFromPool() override internal virtual returns (\\n    uint expectedWithdrewUSD,\\n    uint assetPrice,\\n    uint strategyLoss\\n  ) {\\n    return _withdrawFromPool(type(uint).max);\\n  }\\n\\n  /// @param amount Amount to be trying to withdrawn. Max uint means attempt to withdraw all possible invested assets.\\n  /// @param earnedByPrices_ Additional amount that should be withdrawn and send to the insurance\\n  /// @param investedAssets_ Value of invested assets recalculated using current prices\\n  /// @return expectedWithdrewUSD The value that we should receive after withdrawing in terms of USD value of each asset in the pool\\n  /// @return __assetPrice Price of the {asset} taken from the price oracle\\n  /// @return strategyLoss Loss before withdrawing: [new-investedAssets - old-investedAssets]\\n  /// @return amountSentToInsurance Actual amount of underlying sent to the insurance\\n  function _withdrawUniversal(uint amount, uint earnedByPrices_, uint investedAssets_) internal returns (\\n    uint expectedWithdrewUSD,\\n    uint __assetPrice,\\n    uint strategyLoss,\\n    uint amountSentToInsurance\\n  ) {\\n    _beforeWithdraw(amount);\\n\\n    WithdrawUniversalLocal memory v;\\n    v.all = amount == type(uint).max;\\n    strategyLoss = 0;\\n\\n    if ((v.all || amount + earnedByPrices_ != 0) && investedAssets_ != 0) {\\n\\n      // --- init variables ---\\n      v.tokens = _depositorPoolAssets();\\n      v.asset = asset;\\n      v.converter = converter;\\n      v.indexAsset = ConverterStrategyBaseLib.getAssetIndex(v.tokens, v.asset);\\n      v.balanceBefore = AppLib.balance(v.asset);\\n\\n      v.reservesBeforeWithdraw = _depositorPoolReserves();\\n      v.totalSupplyBeforeWithdraw = _depositorTotalSupply();\\n      v.depositorLiquidity = _depositorLiquidity();\\n      v.assetPrice = ConverterStrategyBaseLib.getAssetPriceFromConverter(v.converter, v.asset);\\n      // -----------------------\\n\\n      // calculate how much liquidity we need to withdraw for getting the requested amount\\n      (v.liquidityAmountToWithdraw, v.amountsToConvert) = ConverterStrategyBaseLib2.getLiquidityAmount(\\n        v.all ? 0 : amount + earnedByPrices_,\\n        address(this),\\n        v.tokens,\\n        v.indexAsset,\\n        v.converter,\\n        investedAssets_,\\n        v.depositorLiquidity\\n      );\\n\\n      if (v.liquidityAmountToWithdraw != 0) {\\n\\n        // =============== WITHDRAW =====================\\n        // make withdraw\\n        v.withdrawnAmounts = _depositorExit(v.liquidityAmountToWithdraw);\\n        // the depositor is able to use less liquidity than it was asked, i.e. Balancer-depositor leaves some BPT unused\\n        // use what exactly was withdrew instead of the expectation\\n        // assume that liquidity cannot increase in _depositorExit\\n        v.liquidityAmountToWithdraw = v.depositorLiquidity - _depositorLiquidity();\\n        emit OnDepositorExit(v.liquidityAmountToWithdraw, v.withdrawnAmounts);\\n        // ==============================================\\n\\n        // we need to call expectation after withdraw for calculate it based on the real liquidity amount that was withdrew\\n        // it should be called BEFORE the converter will touch our positions coz we need to call quote the estimations\\n        // amountsToConvert should contains amounts was withdrawn from the pool and amounts received from the converter\\n        (v.expectedMainAssetAmounts, v.amountsToConvert) = ConverterStrategyBaseLib.postWithdrawActions(\\n          v.converter,\\n          v.tokens,\\n          v.indexAsset,\\n          v.reservesBeforeWithdraw,\\n          v.liquidityAmountToWithdraw,\\n          v.totalSupplyBeforeWithdraw,\\n          v.amountsToConvert,\\n          v.withdrawnAmounts\\n        );\\n      } else {\\n        // we don't need to withdraw any amounts from the pool, available converted amounts are enough for us\\n        v.expectedMainAssetAmounts = ConverterStrategyBaseLib.postWithdrawActionsEmpty(\\n          v.converter,\\n          v.tokens,\\n          v.indexAsset,\\n          v.amountsToConvert\\n        );\\n      }\\n\\n      // convert amounts to main asset\\n      // it is safe to use amountsToConvert from expectation - we will try to repay only necessary amounts\\n      v.expectedTotalMainAssetAmount += ConverterStrategyBaseLib.makeRequestedAmount(\\n        v.tokens,\\n        v.indexAsset,\\n        v.amountsToConvert,\\n        v.converter,\\n        _getLiquidator(controller()),\\n        v.all ? amount : amount + earnedByPrices_,\\n        v.expectedMainAssetAmounts,\\n        liquidationThresholds\\n      );\\n\\n      if (earnedByPrices_ != 0) {\\n        amountSentToInsurance = ConverterStrategyBaseLib2.sendToInsurance(\\n          v.asset,\\n          earnedByPrices_,\\n          splitter,\\n          investedAssets_ + v.balanceBefore\\n        );\\n      }\\n\\n      v.investedAssetsAfterWithdraw = _updateInvestedAssets();\\n      v.balanceAfterWithdraw = AppLib.balance(v.asset);\\n\\n      // we need to compensate difference if during withdraw we lost some assets\\n      if ((v.investedAssetsAfterWithdraw + v.balanceAfterWithdraw + earnedByPrices_) < (investedAssets_ + v.balanceBefore)) {\\n        strategyLoss += (investedAssets_ + v.balanceBefore) - (v.investedAssetsAfterWithdraw + v.balanceAfterWithdraw + earnedByPrices_);\\n      }\\n\\n      return (\\n        v.expectedTotalMainAssetAmount * v.assetPrice / 1e18,\\n        v.assetPrice,\\n        strategyLoss,\\n        amountSentToInsurance\\n      );\\n    }\\n    return (0, 0, 0, 0);\\n  }\\n\\n  /// @notice If pool supports emergency withdraw need to call it for emergencyExit()\\n  function _emergencyExitFromPool() override internal virtual {\\n    uint[] memory withdrawnAmounts = _depositorEmergencyExit();\\n    emit OnDepositorEmergencyExit(withdrawnAmounts);\\n\\n    // convert amounts to main asset\\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\\n    ConverterStrategyBaseLib.closePositionsToGetAmount(\\n      converter,\\n      _getLiquidator(controller()),\\n      indexAsset,\\n      liquidationThresholds,\\n      type(uint).max,\\n      tokens\\n    );\\n\\n    // adjust _investedAssets\\n    _updateInvestedAssets();\\n  }\\n  //endregion Withdraw from the pool\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Claim rewards\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Claim all possible rewards.\\n  function _claim() override internal virtual returns (address[] memory rewardTokensOut, uint[] memory amountsOut) {\\n    // get rewards from the Depositor\\n    (address[] memory rewardTokens, uint[] memory rewardAmounts, uint[] memory balancesBefore) = _depositorClaimRewards();\\n\\n    (rewardTokensOut, amountsOut) = ConverterStrategyBaseLib2.claimConverterRewards(\\n      converter,\\n      _depositorPoolAssets(),\\n      rewardTokens,\\n      rewardAmounts,\\n      balancesBefore\\n    );\\n  }\\n\\n  /// @dev Call recycle process and send tokens to forwarder.\\n  ///      Need to be separated from the claim process - the claim can be called by operator for other purposes.\\n  function _rewardsLiquidation(address[] memory rewardTokens, uint[] memory amounts) internal {\\n    uint len = rewardTokens.length;\\n    if (len > 0) {\\n      uint[] memory amountsToForward = _recycle(rewardTokens, amounts);\\n\\n      // send forwarder-part of the rewards to the forwarder\\n      ConverterStrategyBaseLib2.sendTokensToForwarder(controller(), splitter, rewardTokens, amountsToForward);\\n    }\\n  }\\n\\n  /// @notice Recycle the amounts: liquidate a part of each amount, send the other part to the forwarder.\\n  /// We have two kinds of rewards:\\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\\n  /// 2) any other rewards\\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\\n  ///   Compound-part of Rewards-2 can be liquidated\\n  ///   Compound part of Rewards-1 should be just left on the balance\\n  ///   Performance amounts should be liquidate, result underlying should be sent to performance receiver and insurance.\\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\\n  /// @dev {_recycle} is implemented as separate (inline) function to simplify unit testing\\n  /// @param rewardTokens_ Full list of reward tokens received from tetuConverter and depositor\\n  /// @param rewardAmounts_ Amounts of {rewardTokens_}; we assume, there are no zero amounts here\\n  /// @return amountsToForward Amounts to be sent to forwarder\\n  function _recycle(address[] memory rewardTokens_, uint[] memory rewardAmounts_) internal returns (\\n    uint[] memory amountsToForward\\n  ) {\\n    address _asset = asset; // save gas\\n\\n    uint amountPerf; // total amount for the performance receiver and insurance\\n    (amountsToForward, amountPerf) = ConverterStrategyBaseLib.recycle(\\n      converter,\\n      _asset,\\n      compoundRatio,\\n      _depositorPoolAssets(),\\n      _getLiquidator(controller()),\\n      liquidationThresholds,\\n      rewardTokens_,\\n      rewardAmounts_,\\n      performanceFee\\n    );\\n\\n    // send performance-part of the underlying to the performance receiver and insurance\\n    (uint toPerf, uint toInsurance) = ConverterStrategyBaseLib2.sendPerformanceFee(\\n      _asset,\\n      amountPerf,\\n      splitter,\\n      performanceReceiver,\\n      performanceFeeRatio\\n    );\\n\\n    emit Recycle(rewardTokens_, amountsToForward, toPerf, toInsurance);\\n  }\\n  //endregion Claim rewards\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Hardwork\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice A virtual handler to make any action before hardwork\\n  function _preHardWork(bool reInvest) internal virtual {}\\n\\n  /// @notice A virtual handler to make any action after hardwork\\n  function _postHardWork() internal virtual {}\\n\\n  /// @notice Is strategy ready to hard work\\n  function isReadyToHardWork() override external virtual view returns (bool) {\\n    // check claimable amounts and compare with thresholds\\n    return true;\\n  }\\n\\n  /// @notice Do hard work with reinvesting\\n  /// @return earned Earned amount in terms of {asset}\\n  /// @return lost Lost amount in terms of {asset}\\n  function doHardWork() override public returns (uint earned, uint lost) {\\n    require(msg.sender == splitter, StrategyLib.DENIED);\\n    return _doHardWork(true);\\n  }\\n\\n  /// @notice Claim rewards, do _processClaims() after claiming, calculate earned and lost amounts\\n  function _handleRewards() internal virtual returns (uint earned, uint lost, uint assetBalanceAfterClaim);\\n\\n  /// @param reInvest Deposit to pool all available amount if it's greater than the threshold\\n  /// @return earned Earned amount in terms of {asset}\\n  /// @return lost Lost amount in terms of {asset}\\n  function _doHardWork(bool reInvest) internal returns (uint earned, uint lost) {\\n    // ATTENTION! splitter will not cover the loss if it is lower than profit\\n    (uint investedAssetsNewPrices, uint earnedByPrices) = _fixPriceChanges(true);\\n\\n    _preHardWork(reInvest);\\n\\n    // claim rewards and get current asset balance\\n    uint assetBalance;\\n    (earned, lost, assetBalance) = _handleRewards();\\n\\n    // re-invest income\\n    (, uint amountSentToInsurance) = _depositToPoolUniversal(\\n      reInvest && assetBalance > reinvestThresholdPercent * investedAssetsNewPrices / DENOMINATOR\\n        ? assetBalance\\n        : 0,\\n      earnedByPrices,\\n      investedAssetsNewPrices\\n    );\\n    (uint earned2, uint lost2) = ConverterStrategyBaseLib.registerIncome(\\n      investedAssetsNewPrices + assetBalance, // assets in use before deposit\\n      _investedAssets + AppLib.balance(asset) + amountSentToInsurance // assets in use after deposit\\n    );\\n\\n    _postHardWork();\\n\\n    emit OnHardWorkEarnedLost(investedAssetsNewPrices, earnedByPrices, earned, lost, earned2, lost2);\\n    return (earned + earned2, lost + lost2);\\n  }\\n  //endregion Hardwork\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region InvestedAssets Calculations\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Updates cached _investedAssets to actual value\\n  /// @dev Should be called after deposit / withdraw / claim; virtual - for ut\\n  function _updateInvestedAssets() internal returns (uint investedAssetsOut) {\\n    investedAssetsOut = _calcInvestedAssets();\\n    _investedAssets = investedAssetsOut;\\n  }\\n\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\n  /// @return Invested asset amount under control (in terms of {asset})\\n  function _calcInvestedAssets() internal returns (uint) {\\n    (address[] memory tokens, uint indexAsset) = _getTokens(asset);\\n    return ConverterStrategyBaseLib.calcInvestedAssets(\\n      tokens,\\n      // quote exit should check zero liquidity\\n      _depositorQuoteExit(_depositorLiquidity()),\\n      indexAsset,\\n      converter\\n    );\\n  }\\n\\n  function calcInvestedAssets() external returns (uint) {\\n    StrategyLib.onlyOperators(controller());\\n    return _calcInvestedAssets();\\n  }\\n\\n  /// @notice Calculate profit/loss happened because of price changing. Try to cover the loss, send the profit to the insurance\\n  /// @param updateInvestedAssetsAmount_ If false - just return current value of invested assets\\n  /// @return investedAssetsOut Updated value of {_investedAssets}\\n  /// @return earnedOut Profit that was received because of price changes. It should be sent back to insurance.\\n  ///                   It's to dangerous to get this to try to get this amount here because of the problem \\\"borrow-repay is not allowed in a single block\\\"\\n  ///                   So, we need to handle it in the caller code.\\n  function _fixPriceChanges(bool updateInvestedAssetsAmount_) internal returns (uint investedAssetsOut, uint earnedOut) {\\n    if (updateInvestedAssetsAmount_) {\\n      uint investedAssetsBefore = _investedAssets;\\n      investedAssetsOut = _updateInvestedAssets();\\n      earnedOut = ConverterStrategyBaseLib.coverPossibleStrategyLoss(investedAssetsBefore, investedAssetsOut, splitter);\\n    } else {\\n      investedAssetsOut = _investedAssets;\\n      earnedOut = 0;\\n    }\\n  }\\n  //endregion InvestedAssets Calculations\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region ITetuConverterCallback\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Converters asks to send some amount back.\\n  /// @param theAsset_ Required asset (either collateral or borrow)\\n  /// @param amount_ Required amount of the {theAsset_}\\n  /// @return amountOut Amount sent to balance of TetuConverter, amountOut <= amount_\\n  function requirePayAmountBack(address theAsset_, uint amount_) external override returns (uint amountOut) {\\n    address __converter = address(converter);\\n    require(msg.sender == __converter, StrategyLib.DENIED);\\n\\n    // detect index of the target asset\\n    (address[] memory tokens, uint indexTheAsset) = _getTokens(theAsset_);\\n    // get amount of target asset available to be sent\\n    uint balance = AppLib.balance(theAsset_);\\n\\n    // withdraw from the pool if not enough\\n    if (balance < amount_) {\\n      // the strategy doesn't have enough target asset on balance\\n      // withdraw all from the pool but don't convert assets to underlying\\n      uint liquidity = _depositorLiquidity();\\n      if (liquidity != 0) {\\n        uint[] memory withdrawnAmounts = _depositorExit(liquidity);\\n        emit OnDepositorExit(liquidity, withdrawnAmounts);\\n      }\\n    }\\n\\n    amountOut = ConverterStrategyBaseLib.swapToGivenAmountAndSendToConverter(\\n      amount_,\\n      indexTheAsset,\\n      tokens,\\n      __converter,\\n      controller(),\\n      asset,\\n      liquidationThresholds\\n    );\\n\\n    // update invested assets anyway, even if we suppose it will be called in other places\\n    _updateInvestedAssets();\\n  }\\n\\n  /// @notice TetuConverter calls this function when it sends any amount to user's balance\\n  /// @param assets_ Any asset sent to the balance, i.e. inside repayTheBorrow\\n  /// @param amounts_ Amount of {asset_} that has been sent to the user's balance\\n  function onTransferAmounts(address[] memory assets_, uint[] memory amounts_) external override {\\n    require(msg.sender == address(converter), StrategyLib.DENIED);\\n\\n    uint len = assets_.length;\\n    require(len == amounts_.length, AppErrors.INCORRECT_LENGTHS);\\n\\n    // TetuConverter is able two call this function in two cases:\\n    // 1) rebalancing (the health factor of some borrow is too low)\\n    // 2) forcible closing of the borrow\\n    // In both cases we update invested assets value here\\n    // and avoid fixing any related losses in hardwork\\n    _updateInvestedAssets();\\n  }\\n  //endregion ITetuConverterCallback\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Others\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Unlimited capacity by default\\n  function capacity() external virtual view returns (uint) {\\n    return 2 ** 255;\\n    // almost same as type(uint).max but more gas efficient\\n  }\\n\\n  function _getTokens(address asset_) internal view returns (address[] memory tokens, uint indexAsset) {\\n    tokens = _depositorPoolAssets();\\n    indexAsset = ConverterStrategyBaseLib.getAssetIndex(tokens, asset_);\\n    require(indexAsset != type(uint).max, StrategyLib.WRONG_VALUE);\\n  }\\n\\n  function _getLiquidator(address controller_) internal view returns (ITetuLiquidator) {\\n    return ITetuLiquidator(IController(controller_).liquidator());\\n  }\\n  //endregion Others\\n\\n\\n  /// @dev This empty reserved space is put in place to allow future versions to add new\\n  /// variables without shifting down storage in the inheritance chain.\\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n  uint[50 - 5] private __gap; // 50 - count of variables\\n\\n}\\n\",\"keccak256\":\"0x3a6c240ac81767e18dc9e79286fe84563e58f728724d13b6512439718a1a2a57\",\"license\":\"MIT\"},\"contracts/strategies/ConverterStrategyBaseLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IConverterController.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"../libs/AppErrors.sol\\\";\\nimport \\\"../libs/AppLib.sol\\\";\\nimport \\\"../libs/TokenAmountsLib.sol\\\";\\nimport \\\"../libs/ConverterEntryKinds.sol\\\";\\n\\nlibrary ConverterStrategyBaseLib {\\n  using SafeERC20 for IERC20;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Data types\\n  /////////////////////////////////////////////////////////////////////\\n  /// @notice Local vars for {_recycle}, workaround for stack too deep\\n  struct RecycleLocalParams {\\n    /// @notice Compound amount + Performance amount\\n    uint amountCP;\\n    /// @notice Amount to compound\\n    uint amountC;\\n    /// @notice Amount to send to performance and insurance\\n    uint amountP;\\n    /// @notice Amount to forwarder + amount to compound\\n    uint amountFC;\\n    address rewardToken;\\n    uint liquidationThresholdAsset;\\n    uint len;\\n    uint receivedAmountOut;\\n  }\\n\\n  struct OpenPositionLocal {\\n    uint entryKind;\\n    address[] converters;\\n    uint[] collateralsRequired;\\n    uint[] amountsToBorrow;\\n    uint collateral;\\n    uint amountToBorrow;\\n  }\\n\\n  struct OpenPositionEntryKind1Local {\\n    address[] converters;\\n    uint[] collateralsRequired;\\n    uint[] amountsToBorrow;\\n    uint collateral;\\n    uint amountToBorrow;\\n    uint c1;\\n    uint c3;\\n    uint ratio;\\n    uint alpha;\\n  }\\n\\n  struct CalcInvestedAssetsLocal {\\n    uint len;\\n    uint[] prices;\\n    uint[] decs;\\n    uint[] debts;\\n  }\\n\\n  struct ConvertAfterWithdrawLocal {\\n    address asset;\\n    uint collateral;\\n    uint spent;\\n    uint received;\\n    uint balance;\\n    uint balanceBefore;\\n    uint len;\\n  }\\n\\n  struct SwapToGivenAmountInputParams {\\n    uint targetAmount;\\n    address[] tokens;\\n    uint indexTargetAsset;\\n    address underlying;\\n    uint[] amounts;\\n    ITetuConverter converter;\\n    ITetuLiquidator liquidator;\\n    uint liquidationThresholdForTargetAsset;\\n    /// @notice Allow to swap more then required (i.e. 1_000 => +1%)\\n    ///         to avoid additional swap if the swap return amount a bit less than we expected\\n    uint overswap;\\n  }\\n\\n  struct SwapToGivenAmountLocal {\\n    uint len;\\n    uint[] availableAmounts;\\n    uint i;\\n  }\\n\\n  struct CloseDebtsForRequiredAmountLocal {\\n    uint len;\\n    address asset;\\n    uint collateral;\\n    uint spentAmountIn;\\n    uint receivedAmount;\\n    uint balance;\\n    uint[] tokensBalancesBefore;\\n\\n    uint totalDebt;\\n    uint totalCollateral;\\n\\n    /// @notice Cost of $1 in terms of the assets, decimals 18\\n    uint[] prices;\\n    /// @notice 10**decimal for the assets\\n    uint[] decs;\\n\\n    uint newBalance;\\n  }\\n  //endregion Data types\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Constants\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice approx one month for average block time 2 sec\\n  uint internal constant _LOAN_PERIOD_IN_BLOCKS = 30 days / 2;\\n  uint internal constant _REWARD_LIQUIDATION_SLIPPAGE = 5_000; // 5%\\n  uint internal constant COMPOUND_DENOMINATOR = 100_000;\\n  uint internal constant DENOMINATOR = 100_000;\\n  uint internal constant _ASSET_LIQUIDATION_SLIPPAGE = 300;\\n  uint internal constant PRICE_IMPACT_TOLERANCE = 300;\\n  /// @notice borrow/collateral amount cannot be less than given number of tokens\\n  uint internal constant DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD = 10;\\n  /// @notice Allow to swap more then required (i.e. 1_000 => +1%) inside {swapToGivenAmount}\\n  ///         to avoid additional swap if the swap will return amount a bit less than we expected\\n  uint internal constant OVERSWAP = PRICE_IMPACT_TOLERANCE + _ASSET_LIQUIDATION_SLIPPAGE;\\n  /// @dev Absolute value for any token\\n  uint internal constant DEFAULT_LIQUIDATION_THRESHOLD = 100_000;\\n  /// @notice 1% gap to cover possible liquidation inefficiency\\n  /// @dev We assume that: conversion-result-calculated-by-prices - liquidation-result <= the-gap\\n  uint internal constant GAP_CONVERSION = 1_000;\\n  //endregion Constants\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Events\\n  /////////////////////////////////////////////////////////////////////\\n  /// @notice A borrow was made\\n  event OpenPosition(\\n    address converter,\\n    address collateralAsset,\\n    uint collateralAmount,\\n    address borrowAsset,\\n    uint borrowedAmount,\\n    address recepient\\n  );\\n\\n  /// @notice Some borrow(s) was/were repaid\\n  event ClosePosition(\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountRepay,\\n    address recepient,\\n    uint returnedAssetAmountOut,\\n    uint returnedBorrowAmountOut\\n  );\\n\\n  /// @notice A liquidation was made\\n  event Liquidation(\\n    address tokenIn,\\n    address tokenOut,\\n    uint amountIn,\\n    uint spentAmountIn,\\n    uint receivedAmountOut\\n  );\\n\\n  event ReturnAssetToConverter(address asset, uint amount);\\n\\n  event FixPriceChanges(uint investedAssetsBefore, uint investedAssetsOut);\\n  //endregion Events\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region View functions\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Get amount of assets that we expect to receive after withdrawing\\n  ///         ratio = amount-LP-tokens-to-withdraw / total-amount-LP-tokens-in-pool\\n  /// @param reserves_ Reserves of the {poolAssets_}, same order, same length (we don't check it)\\n  ///                  The order of tokens should be same as in {_depositorPoolAssets()},\\n  ///                  one of assets must be {asset_}\\n  /// @param liquidityAmount_ Amount of LP tokens that we are going to withdraw\\n  /// @param totalSupply_ Total amount of LP tokens in the depositor\\n  /// @return withdrawnAmountsOut Expected withdrawn amounts (decimals == decimals of the tokens)\\n  function getExpectedWithdrawnAmounts(\\n    uint[] memory reserves_,\\n    uint liquidityAmount_,\\n    uint totalSupply_\\n  ) internal pure returns (\\n    uint[] memory withdrawnAmountsOut\\n  ) {\\n    uint ratio = totalSupply_ == 0\\n      ? 0\\n      : (liquidityAmount_ >= totalSupply_\\n        ? 1e18\\n        : 1e18 * liquidityAmount_ / totalSupply_\\n      );\\n\\n    uint len = reserves_.length;\\n    withdrawnAmountsOut = new uint[](len);\\n\\n    if (ratio != 0) {\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        withdrawnAmountsOut[i] = reserves_[i] * ratio / 1e18;\\n      }\\n    }\\n  }\\n\\n  /// @return prices Asset prices in USD, decimals 18\\n  /// @return decs 10**decimals\\n  function _getPricesAndDecs(IPriceOracle priceOracle, address[] memory tokens_, uint len) internal view returns (\\n    uint[] memory prices,\\n    uint[] memory decs\\n  ) {\\n    prices = new uint[](len);\\n    decs = new uint[](len);\\n    {\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\\n        prices[i] = priceOracle.getAssetPrice(tokens_[i]);\\n      }\\n    }\\n  }\\n\\n  /// @notice Find index of the given {asset_} in array {tokens_}, return type(uint).max if not found\\n  function getAssetIndex(address[] memory tokens_, address asset_) internal pure returns (uint) {\\n    uint len = tokens_.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (tokens_[i] == asset_) {\\n        return i;\\n      }\\n    }\\n    return type(uint).max;\\n  }\\n  //endregion View functions\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Borrow and close positions\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\\n  ///         Max possible collateral should be approved before calling of this function.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\\n  /// @param amountIn_ Meaning depends on {entryData_}.\\n  function openPosition(\\n    ITetuConverter tetuConverter_,\\n    bytes memory entryData_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountIn_,\\n    uint thresholdAmountIn_\\n  ) external returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    return _openPosition(tetuConverter_, entryData_, collateralAsset_, borrowAsset_, amountIn_, thresholdAmountIn_);\\n  }\\n\\n  /// @notice Make one or several borrow necessary to supply/borrow required {amountIn_} according to {entryData_}\\n  ///         Max possible collateral should be approved before calling of this function.\\n  /// @param entryData_ Encoded entry kind and additional params if necessary (set of params depends on the kind)\\n  ///                   See TetuConverter\\\\EntryKinds.sol\\\\ENTRY_KIND_XXX constants for possible entry kinds\\n  ///                   0 or empty: Amount of collateral {amountIn_} is fixed, amount of borrow should be max possible.\\n  /// @param amountIn_ Meaning depends on {entryData_}.\\n  /// @param thresholdAmountIn_ Min value of amountIn allowed for the second and subsequent conversions.\\n  ///        0 - use default min value\\n  ///        If amountIn becomes too low, no additional borrows are possible, so\\n  ///        the rest amountIn is just added to collateral/borrow amount of previous conversion.\\n  function _openPosition(\\n    ITetuConverter tetuConverter_,\\n    bytes memory entryData_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountIn_,\\n    uint thresholdAmountIn_\\n  ) internal returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    if (thresholdAmountIn_ == 0) {\\n      // zero threshold is not allowed because round-issues are possible, see openPosition.dust test\\n      // we assume here, that it's useless to borrow amount using collateral/borrow amount\\n      // less than given number of tokens (event for BTC)\\n      thresholdAmountIn_ = DEFAULT_OPEN_POSITION_AMOUNT_IN_THRESHOLD;\\n    }\\n    if (amountIn_ <= thresholdAmountIn_) {\\n      return (0, 0);\\n    }\\n\\n    OpenPositionLocal memory vars;\\n    // we assume here, that max possible collateral amount is already approved (as it's required by TetuConverter)\\n    vars.entryKind = ConverterEntryKinds.getEntryKind(entryData_);\\n    if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_PROPORTION_1) {\\n      return openPositionEntryKind1(\\n        tetuConverter_,\\n        entryData_,\\n        collateralAsset_,\\n        borrowAsset_,\\n        amountIn_,\\n        thresholdAmountIn_\\n      );\\n    } else {\\n      (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\\n        entryData_,\\n        collateralAsset_,\\n        amountIn_,\\n        borrowAsset_,\\n        _LOAN_PERIOD_IN_BLOCKS\\n      );\\n\\n      uint len = vars.converters.length;\\n      if (len > 0) {\\n        for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n          // we need to approve collateralAmount before the borrow-call but it's already approved, see above comments\\n          vars.collateral;\\n          vars.amountToBorrow;\\n          if (vars.entryKind == ConverterEntryKinds.ENTRY_KIND_EXACT_COLLATERAL_IN_FOR_MAX_BORROW_OUT_0) {\\n            // we have exact amount of total collateral amount\\n            // Case ENTRY_KIND_EXACT_PROPORTION_1 is here too because we consider first platform only\\n            vars.collateral = amountIn_ < vars.collateralsRequired[i]\\n              ? amountIn_\\n              : vars.collateralsRequired[i];\\n            vars.amountToBorrow = amountIn_ < vars.collateralsRequired[i]\\n              ? vars.amountsToBorrow[i] * amountIn_ / vars.collateralsRequired[i]\\n              : vars.amountsToBorrow[i];\\n            amountIn_ -= vars.collateral;\\n          } else {\\n            // assume here that entryKind == EntryKinds.ENTRY_KIND_EXACT_BORROW_OUT_FOR_MIN_COLLATERAL_IN_2\\n            // we have exact amount of total amount-to-borrow\\n            vars.amountToBorrow = amountIn_ < vars.amountsToBorrow[i]\\n              ? amountIn_\\n              : vars.amountsToBorrow[i];\\n            vars.collateral = amountIn_ < vars.amountsToBorrow[i]\\n              ? vars.collateralsRequired[i] * amountIn_ / vars.amountsToBorrow[i]\\n              : vars.collateralsRequired[i];\\n            amountIn_ -= vars.amountToBorrow;\\n          }\\n\\n          if (amountIn_ < thresholdAmountIn_ && amountIn_ != 0) {\\n            // dust amount is left, just leave it unused\\n            // we cannot add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\\n            amountIn_ = 0;\\n          }\\n\\n          if (vars.amountToBorrow != 0) {\\n            borrowedAmountOut += tetuConverter_.borrow(\\n              vars.converters[i],\\n              collateralAsset_,\\n              vars.collateral,\\n              borrowAsset_,\\n              vars.amountToBorrow,\\n              address(this)\\n            );\\n            collateralAmountOut += vars.collateral;\\n            emit OpenPosition(\\n              vars.converters[i],\\n              collateralAsset_,\\n              vars.collateral,\\n              borrowAsset_,\\n              vars.amountToBorrow,\\n              address(this)\\n            );\\n          }\\n\\n          if (amountIn_ == 0) break;\\n        }\\n      }\\n\\n      return (collateralAmountOut, borrowedAmountOut);\\n    }\\n  }\\n\\n  /// @notice Open position using entry kind 1 - split provided amount on two parts according provided proportions\\n  /// @param amountIn_ Amount of collateral to be divided on parts. We assume {amountIn_} > 0\\n  /// @param collateralThreshold_ Min allowed collateral amount to be used for new borrow, > 0\\n  /// @return collateralAmountOut Total collateral used to borrow {borrowedAmountOut}\\n  /// @return borrowedAmountOut Total borrowed amount\\n  function openPositionEntryKind1(\\n    ITetuConverter tetuConverter_,\\n    bytes memory entryData_,\\n    address collateralAsset_,\\n    address borrowAsset_,\\n    uint amountIn_,\\n    uint collateralThreshold_\\n  ) internal returns (\\n    uint collateralAmountOut,\\n    uint borrowedAmountOut\\n  ) {\\n    OpenPositionEntryKind1Local memory vars;\\n    (vars.converters, vars.collateralsRequired, vars.amountsToBorrow,) = tetuConverter_.findBorrowStrategies(\\n      entryData_,\\n      collateralAsset_,\\n      amountIn_,\\n      borrowAsset_,\\n      _LOAN_PERIOD_IN_BLOCKS\\n    );\\n\\n    uint len = vars.converters.length;\\n    if (len > 0) {\\n      // we should split amountIn on two amounts with proportions x:y\\n      (, uint x, uint y) = abi.decode(entryData_, (uint, uint, uint));\\n      // calculate prices conversion ratio using price oracle, decimals 18\\n      // i.e. alpha = 1e18 * 75e6 usdc / 25e18 matic = 3e6 usdc/matic\\n      vars.alpha = _getCollateralToBorrowRatio(tetuConverter_, collateralAsset_, borrowAsset_);\\n\\n      for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n        // the lending platform allows to convert {collateralsRequired[i]} to {amountsToBorrow[i]}\\n        // and give us required proportions in result\\n        // C = C1 + C2, C2 => B2, B2 * alpha = C3, C1/C3 must be equal to x/y\\n        // C1 is collateral amount left untouched (x)\\n        // C2 is collateral amount converted to B2 (y)\\n        // but if lending platform doesn't have enough liquidity\\n        // it reduces {collateralsRequired[i]} and {amountsToBorrow[i]} proportionally to fit the limits\\n        // as result, remaining C1 will be too big after conversion and we need to make another borrow\\n        vars.c3 = vars.alpha * vars.amountsToBorrow[i] / 1e18;\\n        vars.c1 = x * vars.c3 / y;\\n        vars.ratio = (vars.collateralsRequired[i] + vars.c1) > amountIn_\\n          ? 1e18 * amountIn_ / (vars.collateralsRequired[i] + vars.c1)\\n          : 1e18;\\n\\n        vars.collateral = vars.collateralsRequired[i] * vars.ratio / 1e18;\\n        vars.amountToBorrow = vars.amountsToBorrow[i] * vars.ratio / 1e18;\\n\\n        // skip any attempts to borrow zero amount or use too little collateral\\n        if (vars.collateral < collateralThreshold_ || vars.amountToBorrow == 0) {\\n          if (vars.collateralsRequired[i] + vars.c1 + collateralThreshold_ > amountIn_) {\\n            // The lending platform has enough resources to make the borrow but amount of the borrow is too low\\n            // Skip the borrow, leave leftover of collateral untouched\\n            break;\\n          } else {\\n            // The lending platform doesn't have enough resources to make the borrow.\\n            // We should try to make borrow on the next platform (if any)\\n            continue;\\n          }\\n        }\\n\\n        require(\\n          tetuConverter_.borrow(\\n            vars.converters[i],\\n            collateralAsset_,\\n            vars.collateral,\\n            borrowAsset_,\\n            vars.amountToBorrow,\\n            address(this)\\n          ) == vars.amountToBorrow,\\n          StrategyLib.WRONG_VALUE\\n        );\\n        emit OpenPosition(\\n          vars.converters[i],\\n          collateralAsset_,\\n          vars.collateral,\\n          borrowAsset_,\\n          vars.amountToBorrow,\\n          address(this)\\n        );\\n\\n        borrowedAmountOut += vars.amountToBorrow;\\n        collateralAmountOut += vars.collateral;\\n\\n        // calculate amount to be borrowed in the next converter\\n        vars.c3 = vars.alpha * vars.amountToBorrow / 1e18;\\n        vars.c1 = x * vars.c3 / y;\\n        amountIn_ = (amountIn_ > vars.c1 + vars.collateral)\\n          ? amountIn_ - (vars.c1 + vars.collateral)\\n          : 0;\\n\\n        // protection against dust amounts, see \\\"openPosition.dust\\\", just leave dust amount unused\\n        // we CAN NOT add it to collateral/borrow amounts - there is a risk to exceed max allowed amounts\\n        // we assume here, that collateralThreshold_ != 0, so check amountIn_ != 0 is not required\\n        if (amountIn_ < collateralThreshold_) break;\\n      }\\n    }\\n\\n    return (collateralAmountOut, borrowedAmountOut);\\n  }\\n\\n  /// @notice Get ratio18 = collateral / borrow\\n  function _getCollateralToBorrowRatio(\\n    ITetuConverter tetuConverter_,\\n    address collateralAsset_,\\n    address borrowAsset_\\n  ) internal view returns (uint){\\n    IPriceOracle priceOracle = IPriceOracle(IConverterController(tetuConverter_.controller()).priceOracle());\\n    uint priceCollateral = priceOracle.getAssetPrice(collateralAsset_);\\n    uint priceBorrow = priceOracle.getAssetPrice(borrowAsset_);\\n    return 1e18 * priceBorrow * 10 ** IERC20Metadata(collateralAsset_).decimals()\\n    / priceCollateral / 10 ** IERC20Metadata(borrowAsset_).decimals();\\n  }\\n\\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\\n  ///         It doesn't repay more than the actual amount of the debt, so it can use less amount than {amountToRepay}\\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\\n  /// @return repaidAmountOut Amount that was actually repaid\\n  function _closePosition(\\n    ITetuConverter converter_,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountToRepay\\n  ) internal returns (\\n    uint returnedAssetAmountOut,\\n    uint repaidAmountOut\\n  ) {\\n\\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\\n\\n    // We shouldn't try to pay more than we actually need to repay\\n    // The leftover will be swapped inside TetuConverter, it's inefficient.\\n    // Let's limit amountToRepay by needToRepay-amount\\n    (uint needToRepay,) = converter_.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\\n\\n    return _closePositionExact(converter_, collateralAsset, borrowAsset, amountRepay, balanceBefore);\\n  }\\n\\n  /// @notice Close the given position, pay {amountRepay} exactly and ensure that all amount was accepted,\\n  /// @param amountRepay Amount to repay in terms of {borrowAsset}\\n  /// @param balanceBorrowAsset Current balance of the borrow asset\\n  /// @return collateralOut Amount of collateral received back after repaying\\n  /// @return repaidAmountOut Amount that was actually repaid\\n  function _closePositionExact(\\n    ITetuConverter converter_,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountRepay,\\n    uint balanceBorrowAsset\\n  ) internal returns (\\n    uint collateralOut,\\n    uint repaidAmountOut\\n  ) {\\n    // Make full/partial repayment\\n    IERC20(borrowAsset).safeTransfer(address(converter_), amountRepay);\\n\\n    uint notUsedAmount;\\n    (collateralOut, notUsedAmount,,) = converter_.repay(collateralAsset, borrowAsset, amountRepay, address(this));\\n\\n    emit ClosePosition(collateralAsset, borrowAsset, amountRepay, address(this), collateralOut, notUsedAmount);\\n    uint balanceAfter = IERC20(borrowAsset).balanceOf(address(this));\\n\\n    // we cannot use amountRepay here because AAVE pool adapter is able to send tiny amount back (debt-gap)\\n    repaidAmountOut = balanceBorrowAsset > balanceAfter\\n      ? balanceBorrowAsset - balanceAfter\\n      : 0;\\n\\n    require(notUsedAmount == 0, StrategyLib.WRONG_VALUE);\\n  }\\n\\n  /// @notice Close the given position, pay {amountToRepay}, return collateral amount in result\\n  /// @param amountToRepay Amount to repay in terms of {borrowAsset}\\n  /// @return returnedAssetAmountOut Amount of collateral received back after repaying\\n  /// @return repaidAmountOut Amount that was actually repaid\\n  function closePosition(\\n    ITetuConverter tetuConverter_,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountToRepay\\n  ) external returns (\\n    uint returnedAssetAmountOut,\\n    uint repaidAmountOut\\n  ) {\\n    return _closePosition(tetuConverter_, collateralAsset, borrowAsset, amountToRepay);\\n  }\\n  //endregion Borrow and close positions\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Liquidation\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator\\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\n  function liquidate(\\n    ITetuConverter converter,\\n    ITetuLiquidator liquidator_,\\n    address tokenIn_,\\n    address tokenOut_,\\n    uint amountIn_,\\n    uint slippage_,\\n    uint liquidationThresholdTokenOut_,\\n    bool skipValidation\\n  ) external returns (\\n    uint spentAmountIn,\\n    uint receivedAmountOut\\n  ) {\\n    return _liquidate(converter, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, liquidationThresholdTokenOut_, skipValidation);\\n  }\\n\\n  /// @notice Make liquidation if estimated amountOut exceeds the given threshold\\n  /// @param spentAmountIn Amount of {tokenIn} has been consumed by the liquidator (== 0 | amountIn_)\\n  /// @param receivedAmountOut Amount of {tokenOut_} has been returned by the liquidator\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\n  function _liquidate(\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator_,\\n    address tokenIn_,\\n    address tokenOut_,\\n    uint amountIn_,\\n    uint slippage_,\\n    uint liquidationThresholdForTokenOut_,\\n    bool skipValidation\\n  ) internal returns (\\n    uint spentAmountIn,\\n    uint receivedAmountOut\\n  ) {\\n    if (amountIn_ == 0) {\\n      return (0, 0);\\n    }\\n\\n    (ITetuLiquidator.PoolData[] memory route,) = liquidator_.buildRoute(tokenIn_, tokenOut_);\\n\\n    require(route.length != 0, AppErrors.NO_LIQUIDATION_ROUTE);\\n\\n    // calculate balance in out value for check threshold\\n    uint amountOut = liquidator_.getPriceForRoute(route, amountIn_);\\n\\n    // if the expected value is higher than threshold distribute to destinations\\n    return amountOut > liquidationThresholdForTokenOut_\\n      ? (amountIn_, _liquidateWithRoute(converter_, route, liquidator_, tokenIn_, tokenOut_, amountIn_, slippage_, skipValidation))\\n      : (0, 0);\\n  }\\n\\n  /// @notice Make liquidation using given route and check correctness using TetuConverter's price oracle\\n  /// @param skipValidation Don't check correctness of conversion using TetuConverter's oracle (i.e. for reward tokens)\\n  function _liquidateWithRoute(\\n    ITetuConverter converter_,\\n    ITetuLiquidator.PoolData[] memory route,\\n    ITetuLiquidator liquidator_,\\n    address tokenIn_,\\n    address tokenOut_,\\n    uint amountIn_,\\n    uint slippage_,\\n    bool skipValidation\\n  ) internal returns (\\n    uint receivedAmountOut\\n  ) {\\n    // we need to approve each time, liquidator address can be changed in controller\\n    AppLib.approveIfNeeded(tokenIn_, amountIn_, address(liquidator_));\\n\\n    uint balanceBefore = IERC20(tokenOut_).balanceOf(address(this));\\n    liquidator_.liquidateWithRoute(route, amountIn_, slippage_);\\n    uint balanceAfter = IERC20(tokenOut_).balanceOf(address(this));\\n\\n    require(balanceAfter > balanceBefore, AppErrors.BALANCE_DECREASE);\\n    receivedAmountOut = balanceAfter - balanceBefore;\\n\\n    // Oracle in TetuConverter \\\"knows\\\" only limited number of the assets\\n    // It may not know prices for reward assets, so for rewards this validation should be skipped to avoid TC-4 error\\n    require(skipValidation || converter_.isConversionValid(tokenIn_, amountIn_, tokenOut_, receivedAmountOut, slippage_), AppErrors.PRICE_IMPACT);\\n    emit Liquidation(tokenIn_, tokenOut_, amountIn_, amountIn_, receivedAmountOut);\\n  }\\n  //endregion Liquidation\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region requirePayAmountBack\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @param amount_ Amount of the main asset requested by converter\\n  /// @param indexTheAsset Index of the asset required by converter in the {tokens}\\n  /// @param asset Main asset or underlying (it can be different from tokens[indexTheAsset])\\n  /// @return amountOut Amount of the main asset sent to converter\\n  function swapToGivenAmountAndSendToConverter(\\n    uint amount_,\\n    uint indexTheAsset,\\n    address[] memory tokens,\\n    address converter,\\n    address controller,\\n    address asset,\\n    mapping(address => uint) storage liquidationThresholds\\n  ) external returns (\\n    uint amountOut\\n  ) {\\n    // msg.sender == converter; we assume here that it was checked before the call of this function\\n    address theAsset = tokens[indexTheAsset];\\n\\n    amountOut = IERC20(theAsset).balanceOf(address(this));\\n\\n    // convert withdrawn assets to the target asset if not enough\\n    if (amountOut < amount_) {\\n      ConverterStrategyBaseLib.swapToGivenAmount(\\n        amount_ - amountOut,\\n        tokens,\\n        indexTheAsset,\\n        asset, // underlying === main asset\\n        ITetuConverter(converter),\\n        ITetuLiquidator(IController(controller).liquidator()),\\n        liquidationThresholds[theAsset],\\n        OVERSWAP\\n      );\\n      amountOut = IERC20(theAsset).balanceOf(address(this));\\n    }\\n\\n    // we should send the asset as is even if it is lower than requested\\n    // but shouldn't sent more amount than requested\\n    amountOut = Math.min(amount_, amountOut);\\n    if (amountOut != 0) {\\n      IERC20(theAsset).safeTransfer(converter, amountOut);\\n    }\\n\\n    // There are two cases of calling requirePayAmountBack by converter:\\n    // 1) close a borrow: we will receive collateral back and amount of investedAssets almost won't change\\n    // 2) rebalancing: we have real loss, it will be taken into account at next hard work\\n    emit ReturnAssetToConverter(theAsset, amountOut);\\n\\n    // let's leave any leftovers un-invested, they will be reinvested at next hardwork\\n  }\\n\\n  /// @notice Swap available amounts of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\\n  /// @param targetAmount_ Required amount of tokens[indexTheAsset_] that should be received by swap(s)\\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\\n  /// @param indexTargetAsset_ Index of target asset in tokens_ array\\n  /// @param underlying_ Index of underlying\\n  /// @param liquidationThresholdForTargetAsset_ Liquidation thresholds for the target asset\\n  /// @param overswap_ Allow to swap more then required (i.e. 1_000 => +1%)\\n  ///                  to avoid additional swap if the swap return amount a bit less than we expected\\n  /// @return spentAmounts Any amounts spent during the swaps\\n  function swapToGivenAmount(\\n    uint targetAmount_,\\n    address[] memory tokens_,\\n    uint indexTargetAsset_,\\n    address underlying_,\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator_,\\n    uint liquidationThresholdForTargetAsset_,\\n    uint overswap_\\n  ) internal returns (\\n    uint[] memory spentAmounts,\\n    uint[] memory receivedAmounts\\n  ) {\\n    SwapToGivenAmountLocal memory v;\\n    v.len = tokens_.length;\\n\\n    v.availableAmounts = new uint[](v.len);\\n    for (; v.i < v.len; v.i = AppLib.uncheckedInc(v.i)) {\\n      v.availableAmounts[v.i] = IERC20(tokens_[v.i]).balanceOf(address(this));\\n    }\\n\\n    (spentAmounts, receivedAmounts) = _swapToGivenAmount(\\n      SwapToGivenAmountInputParams({\\n        targetAmount: targetAmount_,\\n        tokens: tokens_,\\n        indexTargetAsset: indexTargetAsset_,\\n        underlying: underlying_,\\n        amounts: v.availableAmounts,\\n        converter: converter_,\\n        liquidator: liquidator_,\\n        liquidationThresholdForTargetAsset: Math.max(liquidationThresholdForTargetAsset_, DEFAULT_LIQUIDATION_THRESHOLD),\\n        overswap: overswap_\\n      })\\n    );\\n  }\\n\\n  /// @notice Swap available {amounts_} of {tokens_} to receive {targetAmount_} of {tokens[indexTheAsset_]}\\n  /// @return spentAmounts Any amounts spent during the swaps\\n  /// @return receivedAmounts Any amounts received during the swaps\\n  function _swapToGivenAmount(SwapToGivenAmountInputParams memory p) internal returns (\\n    uint[] memory spentAmounts,\\n    uint[] memory receivedAmounts\\n  ) {\\n    CalcInvestedAssetsLocal memory v;\\n    v.len = p.tokens.length;\\n    receivedAmounts = new uint[](v.len);\\n    spentAmounts = new uint[](v.len);\\n\\n    // calculate prices, decimals\\n    (v.prices, v.decs) = _getPricesAndDecs(\\n      IPriceOracle(IConverterController(p.converter.controller()).priceOracle()),\\n      p.tokens,\\n      v.len\\n    );\\n\\n    // we need to swap other assets to the asset\\n    // at first we should swap NOT underlying.\\n    // if it would be not enough, we can swap underlying too.\\n\\n    // swap NOT underlying, initialize {indexUnderlying}\\n    uint indexUnderlying;\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (p.underlying == p.tokens[i]) {\\n        indexUnderlying = i;\\n        continue;\\n      }\\n      if (p.indexTargetAsset == i) continue;\\n\\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, i);\\n      spentAmounts[i] += spent;\\n      receivedAmounts[p.indexTargetAsset] += received;\\n\\n      if (receivedAmounts[p.indexTargetAsset] >= p.targetAmount) break;\\n    }\\n\\n    // swap underlying\\n    if (receivedAmounts[p.indexTargetAsset] < p.targetAmount && p.indexTargetAsset != indexUnderlying) {\\n      (uint spent, uint received) = _swapToGetAmount(receivedAmounts[p.indexTargetAsset], p, v, indexUnderlying);\\n      spentAmounts[indexUnderlying] += spent;\\n      receivedAmounts[p.indexTargetAsset] += received;\\n    }\\n  }\\n\\n  /// @notice Swap a part of amount of asset {tokens[indexTokenIn]} to {targetAsset} to get {targetAmount} in result\\n  /// @param receivedTargetAmount Already received amount of {targetAsset} in previous swaps\\n  /// @param indexTokenIn Index of the tokenIn in p.tokens\\n  function _swapToGetAmount(\\n    uint receivedTargetAmount,\\n    SwapToGivenAmountInputParams memory p,\\n    CalcInvestedAssetsLocal memory v,\\n    uint indexTokenIn\\n  ) internal returns (\\n    uint amountSpent,\\n    uint amountReceived\\n  ) {\\n    if (p.amounts[indexTokenIn] != 0) {\\n      // we assume here, that p.targetAmount > receivedTargetAmount, see _swapToGivenAmount implementation\\n\\n      // calculate amount that should be swapped\\n      // {overswap} allows to swap a bit more\\n      // to avoid additional swaps if the swap will give us a bit less amount than expected\\n      uint amountIn = (\\n        (p.targetAmount - receivedTargetAmount)\\n        * v.prices[p.indexTargetAsset] * v.decs[indexTokenIn]\\n        / v.prices[indexTokenIn] / v.decs[p.indexTargetAsset]\\n      ) * (p.overswap + DENOMINATOR) / DENOMINATOR;\\n\\n      (amountSpent, amountReceived) = _liquidate(\\n        p.converter,\\n        p.liquidator,\\n        p.tokens[indexTokenIn],\\n        p.tokens[p.indexTargetAsset],\\n        Math.min(amountIn, p.amounts[indexTokenIn]),\\n        _ASSET_LIQUIDATION_SLIPPAGE,\\n        p.liquidationThresholdForTargetAsset,\\n        false\\n      );\\n    }\\n\\n    return (amountSpent, amountReceived);\\n  }\\n  //endregion requirePayAmountBack\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Recycle rewards\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Recycle the amounts: split each amount on tree parts: performance+insurance (P), forwarder (F), compound (C)\\n  ///         Liquidate P+C, send F to the forwarder.\\n  /// We have two kinds of rewards:\\n  /// 1) rewards in depositor's assets (the assets returned by _depositorPoolAssets)\\n  /// 2) any other rewards\\n  /// All received rewards divided on three parts: to performance receiver+insurance, to forwarder, to compound\\n  ///   Compound-part of Rewards-2 can be liquidated\\n  ///   Compound part of Rewards-1 should be just left on the balance\\n  ///   All forwarder-parts are returned in amountsToForward and should be transferred to the forwarder outside.\\n  ///   Performance amounts are liquidated, result amount of underlying is returned in {amountToPerformanceAndInsurance}\\n  /// @param asset Underlying asset\\n  /// @param compoundRatio Compound ration in the range [0...COMPOUND_DENOMINATOR]\\n  /// @param tokens tokens received from {_depositorPoolAssets}\\n  /// @param rewardTokens Full list of reward tokens received from tetuConverter and depositor\\n  /// @param rewardAmounts Amounts of {rewardTokens_}; we assume, there are no zero amounts here\\n  /// @param liquidationThresholds Liquidation thresholds for rewards tokens\\n  /// @param performanceFee Performance fee in the range [0...FEE_DENOMINATOR]\\n  /// @return amountsToForward Amounts of {rewardTokens} to be sent to forwarder, zero amounts are allowed here\\n  /// @return amountToPerformanceAndInsurance Amount of underlying to be sent to performance receiver and insurance\\n  function recycle(\\n    ITetuConverter converter_,\\n    address asset,\\n    uint compoundRatio,\\n    address[] memory tokens,\\n    ITetuLiquidator liquidator,\\n    mapping(address => uint) storage liquidationThresholds,\\n    address[] memory rewardTokens,\\n    uint[] memory rewardAmounts,\\n    uint performanceFee\\n  ) external returns (\\n    uint[] memory amountsToForward,\\n    uint amountToPerformanceAndInsurance\\n  ) {\\n    RecycleLocalParams memory p;\\n\\n    p.len = rewardTokens.length;\\n    require(p.len == rewardAmounts.length, AppErrors.WRONG_LENGTHS);\\n\\n    p.liquidationThresholdAsset = Math.max(liquidationThresholds[asset], DEFAULT_LIQUIDATION_THRESHOLD);\\n\\n    amountsToForward = new uint[](p.len);\\n\\n    // rewardAmounts => P + F + C, where P - performance + insurance, F - forwarder, C - compound\\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\\n      p.amountFC = rewardAmounts[i] * (COMPOUND_DENOMINATOR - performanceFee) / COMPOUND_DENOMINATOR;\\n      p.amountC = p.amountFC * compoundRatio / COMPOUND_DENOMINATOR;\\n      p.amountP = rewardAmounts[i] - p.amountFC;\\n      p.rewardToken = rewardTokens[i];\\n      p.amountCP = p.amountC + p.amountP;\\n\\n      if (p.amountCP > 0) {\\n        if (ConverterStrategyBaseLib.getAssetIndex(tokens, p.rewardToken) != type(uint).max) {\\n          if (p.rewardToken == asset) {\\n            // This is underlying, liquidation of compound part is not allowed; just keep on the balance, should be handled later\\n            amountToPerformanceAndInsurance += p.amountP;\\n          } else {\\n            // This is secondary asset, Liquidation of compound part is not allowed, we should liquidate performance part only\\n            if (p.amountP < Math.max(liquidationThresholds[p.rewardToken], DEFAULT_LIQUIDATION_THRESHOLD)) {\\n              // performance amount is too small, liquidation is not allowed, we just keep that dust tokens on balance forever\\n            } else {\\n              (, p.receivedAmountOut) = _liquidate(\\n                converter_,\\n                liquidator,\\n                p.rewardToken,\\n                asset,\\n                p.amountP,\\n                _REWARD_LIQUIDATION_SLIPPAGE,\\n                p.liquidationThresholdAsset,\\n                false // use conversion validation for these rewards\\n              );\\n              amountToPerformanceAndInsurance += p.receivedAmountOut;\\n            }\\n          }\\n        } else {\\n          if (p.amountCP < Math.max(liquidationThresholds[p.rewardToken], DEFAULT_LIQUIDATION_THRESHOLD)) {\\n            // amount is too small, liquidation is not allowed, we just keep that dust tokens on balance forever\\n          } else {\\n            // The asset is not in the list of depositor's assets, its amount is big enough and should be liquidated\\n            // We assume here, that {token} cannot be equal to {_asset}\\n            // because the {_asset} is always included to the list of depositor's assets\\n            (, p.receivedAmountOut) = _liquidate(\\n              converter_,\\n              liquidator,\\n              p.rewardToken,\\n              asset,\\n              p.amountCP,\\n              _REWARD_LIQUIDATION_SLIPPAGE,\\n              p.liquidationThresholdAsset,\\n              true // skip conversion validation for rewards becase we can have arbitrary assets here\\n            );\\n\\n            amountToPerformanceAndInsurance += p.receivedAmountOut * (rewardAmounts[i] - p.amountFC) / p.amountCP;\\n          }\\n        }\\n      }\\n      amountsToForward[i] = p.amountFC - p.amountC;\\n    }\\n    return (amountsToForward, amountToPerformanceAndInsurance);\\n  }\\n  //endregion Recycle rewards\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region calcInvestedAssets\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Calculate amount we will receive when we withdraw all from pool\\n  /// @dev This is writable function because we need to update current balances in the internal protocols.\\n  /// @return amountOut Invested asset amount under control (in terms of {asset})\\n  function calcInvestedAssets(\\n    address[] memory tokens,\\n    uint[] memory depositorQuoteExitAmountsOut,\\n    uint indexAsset,\\n    ITetuConverter converter_\\n  ) external returns (\\n    uint amountOut\\n  ) {\\n    CalcInvestedAssetsLocal memory v;\\n    v.len = tokens.length;\\n\\n    // calculate prices, decimals\\n    (v.prices, v.decs) = _getPricesAndDecs(\\n      IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\\n      tokens,\\n      v.len\\n    );\\n    // A debt is registered below if we have X amount of asset, need to pay Y amount of the asset and X < Y\\n    // In this case: debt = Y - X, the order of tokens is the same as in {tokens} array\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) {\\n        // Current strategy balance of main asset is not taken into account here because it's add by splitter\\n        amountOut += depositorQuoteExitAmountsOut[i];\\n      } else {\\n        // available amount to repay\\n        uint toRepay = IERC20(tokens[i]).balanceOf(address(this)) + depositorQuoteExitAmountsOut[i];\\n\\n        (uint toPay, uint collateral) = converter_.getDebtAmountCurrent(\\n          address(this),\\n          tokens[indexAsset],\\n          tokens[i],\\n          // investedAssets is calculated using exact debts, debt-gaps are not taken into account\\n          false\\n        );\\n        amountOut += collateral;\\n\\n        if (toRepay >= toPay) {\\n          amountOut += (toRepay - toPay) * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\\n        } else {\\n          // there is not enough amount to pay the debt\\n          // let's register a debt and try to resolve it later below\\n          if (v.debts.length == 0) {\\n            // lazy initialization\\n            v.debts = new uint[](v.len);\\n          }\\n\\n          // to pay the following amount we need to swap some other asset at first\\n          v.debts[i] = toPay - toRepay;\\n        }\\n      }\\n    }\\n    if (v.debts.length == v.len) {\\n      // we assume here, that it would be always profitable to save collateral\\n      // f.e. if there is not enough amount of USDT on our balance and we have a debt in USDT,\\n      // it's profitable to change any available asset to USDT, pay the debt and return the collateral back\\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n        if (v.debts[i] == 0) continue;\\n\\n        // estimatedAssets should be reduced on the debt-value\\n        // this estimation is approx and do not count price impact on the liquidation\\n        // we will able to count the real output only after withdraw process\\n        uint debtInAsset = v.debts[i] * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\\n        if (debtInAsset > amountOut) {\\n          // The debt is greater than we can pay. We shouldn't try to pay the debt in this case\\n          amountOut = 0;\\n        } else {\\n          amountOut -= debtInAsset;\\n        }\\n      }\\n    }\\n\\n    return amountOut;\\n  }\\n  //endregion calcInvestedAssets\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region getExpectedAmountMainAsset\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Calculate expected amount of the main asset after withdrawing\\n  /// @param withdrawnAmounts_ Expected amounts to be withdrawn from the pool\\n  /// @param amountsToConvert_ Amounts on balance initially available for the conversion\\n  /// @return amountsOut Expected amounts of the main asset received after conversion withdrawnAmounts+amountsToConvert\\n  function getExpectedAmountMainAsset(\\n    address[] memory tokens,\\n    uint indexAsset,\\n    ITetuConverter converter,\\n    uint[] memory withdrawnAmounts_,\\n    uint[] memory amountsToConvert_\\n  ) internal returns (\\n    uint[] memory amountsOut\\n  ) {\\n    uint len = tokens.length;\\n    amountsOut = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) {\\n        amountsOut[i] = withdrawnAmounts_[i];\\n      } else {\\n        uint amount = withdrawnAmounts_[i] + amountsToConvert_[i];\\n        if (amount != 0) {\\n          (amountsOut[i],) = converter.quoteRepay(address(this), tokens[indexAsset], tokens[i], amount);\\n        }\\n      }\\n    }\\n\\n    return amountsOut;\\n  }\\n  //endregion getExpectedAmountMainAsset\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Reduce size of ConverterStrategyBase\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Make borrow and save amounts of tokens available for deposit to tokenAmounts\\n  /// @param thresholdMainAsset_ Min allowed value of collateral in terms of main asset, 0 - use default min value\\n  /// @param tokens_ Tokens received from {_depositorPoolAssets}\\n  /// @param collaterals_ Amounts of main asset that can be used as collateral to borrow {tokens_}\\n  /// @param thresholdMainAsset_ Value of liquidation threshold for the main (collateral) asset\\n  /// @return tokenAmountsOut Amounts available for deposit\\n  function getTokenAmounts(\\n    ITetuConverter tetuConverter_,\\n    address[] memory tokens_,\\n    uint indexAsset_,\\n    uint[] memory collaterals_,\\n    uint thresholdMainAsset_\\n  ) external returns (\\n    uint[] memory tokenAmountsOut\\n  ) {\\n    // content of tokenAmounts will be modified in place\\n    uint len = tokens_.length;\\n    tokenAmountsOut = new uint[](len);\\n\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i != indexAsset_) {\\n        if (collaterals_[i] != 0) {\\n          AppLib.approveIfNeeded(tokens_[indexAsset_], collaterals_[i], address(tetuConverter_));\\n          _openPosition(\\n            tetuConverter_,\\n            \\\"\\\", // entry kind = 0: fixed collateral amount, max possible borrow amount\\n            tokens_[indexAsset_],\\n            tokens_[i],\\n            collaterals_[i],\\n            Math.max(thresholdMainAsset_, DEFAULT_LIQUIDATION_THRESHOLD)\\n          );\\n\\n          // zero borrowed amount is possible here (conversion is not available)\\n          // if it's not suitable for depositor, the depositor should check zero amount in other places\\n        }\\n        tokenAmountsOut[i] = IERC20(tokens_[i]).balanceOf(address(this));\\n      }\\n    }\\n\\n    tokenAmountsOut[indexAsset_] = Math.min(\\n      collaterals_[indexAsset_],\\n      IERC20(tokens_[indexAsset_]).balanceOf(address(this))\\n    );\\n  }\\n\\n  /// @notice Convert {amountsToConvert_} to the main {asset}\\n  ///         Swap leftovers (if any) to the main asset.\\n  ///         If result amount is less than expected, try to close any other available debts (1 repay per block only)\\n  /// @param tokens_ Results of _depositorPoolAssets() call (list of depositor's asset in proper order)\\n  /// @param indexAsset_ Index of main {asset} in {tokens}\\n  /// @param requestedAmount Amount to be withdrawn in terms of the asset in addition to the exist balance.\\n  ///        Max uint means attempt to withdraw all possible invested assets.\\n  /// @param amountsToConvert_ Amounts available for conversion after withdrawing from the pool\\n  /// @param expectedMainAssetAmounts Amounts of main asset that we expect to receive after conversion amountsToConvert_\\n  /// @return expectedAmount Expected total amount of main asset after all conversions, swaps and repays\\n  function makeRequestedAmount(\\n    address[] memory tokens_,\\n    uint indexAsset_,\\n    uint[] memory amountsToConvert_,\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator_,\\n    uint requestedAmount,\\n    uint[] memory expectedMainAssetAmounts,\\n    mapping(address => uint) storage liquidationThresholds\\n  ) external returns (uint expectedAmount) {\\n    // get the total expected amount\\n    for (uint i; i < tokens_.length; i = AppLib.uncheckedInc(i)) {\\n      expectedAmount += expectedMainAssetAmounts[i];\\n    }\\n\\n    // we cannot repay a debt twice\\n    // suppose, we have usdt = 1 and we need to convert it to usdc, then get additional usdt=10 and make second repay\\n    // But: we cannot make repay(1) and than repay(10). We MUST make single repay(11)\\n\\n    if (requestedAmount != type(uint).max\\n      && expectedAmount > requestedAmount * (GAP_CONVERSION + DENOMINATOR) / DENOMINATOR\\n    ) {\\n      // amountsToConvert_ are enough to get requestedAmount\\n      _convertAfterWithdraw(\\n        converter_,\\n        liquidator_,\\n        indexAsset_,\\n        liquidationThresholds[tokens_[indexAsset_]],\\n        tokens_,\\n        amountsToConvert_\\n      );\\n    } else {\\n      // amountsToConvert_ are NOT enough to get requestedAmount\\n      // We are allowed to make only one repay per block, so, we shouldn't try to convert amountsToConvert_\\n      // We should try to close the exist debts instead:\\n      //    convert a part of main assets to get amount of secondary assets required to repay the debts\\n      // and only then make conversion.\\n      expectedAmount = _closePositionsToGetAmount(\\n        converter_,\\n        liquidator_,\\n        indexAsset_,\\n        liquidationThresholds,\\n        requestedAmount,\\n        tokens_\\n      ) + expectedMainAssetAmounts[indexAsset_];\\n    }\\n\\n    return expectedAmount;\\n  }\\n  //endregion Reduce size of ConverterStrategyBase\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Withdraw helpers\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Add {withdrawnAmounts} to {amountsToConvert}, calculate {expectedAmountMainAsset}\\n  /// @param amountsToConvert Amounts of {tokens} to be converted, they are located on the balance before withdraw\\n  /// @param withdrawnAmounts Amounts of {tokens} that were withdrew from the pool\\n  function postWithdrawActions(\\n    ITetuConverter converter,\\n    address[] memory tokens,\\n    uint indexAsset,\\n\\n    uint[] memory reservesBeforeWithdraw,\\n    uint liquidityAmountWithdrew,\\n    uint totalSupplyBeforeWithdraw,\\n\\n    uint[] memory amountsToConvert,\\n    uint[] memory withdrawnAmounts\\n  ) external returns (\\n    uint[] memory expectedMainAssetAmounts,\\n    uint[] memory _amountsToConvert\\n  ) {\\n    // estimate expected amount of assets to be withdrawn\\n    uint[] memory expectedWithdrawAmounts = getExpectedWithdrawnAmounts(\\n      reservesBeforeWithdraw,\\n      liquidityAmountWithdrew,\\n      totalSupplyBeforeWithdraw\\n    );\\n\\n    // from received amounts after withdraw calculate how much we receive from converter for them in terms of the underlying asset\\n    expectedMainAssetAmounts = getExpectedAmountMainAsset(\\n      tokens,\\n      indexAsset,\\n      converter,\\n      expectedWithdrawAmounts,\\n      amountsToConvert\\n    );\\n\\n    uint len = tokens.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      amountsToConvert[i] += withdrawnAmounts[i];\\n    }\\n\\n    return (expectedMainAssetAmounts, amountsToConvert);\\n  }\\n\\n  /// @notice return {withdrawnAmounts} with zero values and expected amount calculated using {amountsToConvert_}\\n  function postWithdrawActionsEmpty(\\n    ITetuConverter converter,\\n    address[] memory tokens,\\n    uint indexAsset,\\n    uint[] memory amountsToConvert_\\n  ) external returns (\\n    uint[] memory expectedAmountsMainAsset\\n  ) {\\n    expectedAmountsMainAsset = getExpectedAmountMainAsset(\\n      tokens,\\n      indexAsset,\\n      converter,\\n      // there are no withdrawn amounts\\n      new uint[](tokens.length), // array with all zero values\\n      amountsToConvert_\\n    );\\n  }\\n\\n  //endregion Withdraw helpers\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region convertAfterWithdraw\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Convert {amountsToConvert_} (available on balance) to the main asset\\n  ///         Swap leftovers if any.\\n  ///         Result amount can be less than requested one, we don't try to close any other debts here\\n  /// @param indexAsset Index of the main asset in {tokens}\\n  /// @param liquidationThreshold Min allowed amount of main asset to be liquidated in {liquidator}\\n  /// @param tokens Tokens received from {_depositorPoolAssets}\\n  /// @param amountsToConvert Amounts to convert, the order of asset is same as in {tokens}\\n  /// @return collateralOut Total amount of main asset returned after closing positions\\n  /// @return repaidAmountsOut What amounts were spent in exchange of the {collateralOut}\\n  function _convertAfterWithdraw(\\n    ITetuConverter tetuConverter,\\n    ITetuLiquidator liquidator,\\n    uint indexAsset,\\n    uint liquidationThreshold,\\n    address[] memory tokens,\\n    uint[] memory amountsToConvert\\n  ) internal returns (\\n    uint collateralOut,\\n    uint[] memory repaidAmountsOut\\n  ) {\\n    ConvertAfterWithdrawLocal memory v;\\n    v.asset = tokens[indexAsset];\\n    v.balanceBefore = IERC20(v.asset).balanceOf(address(this));\\n    v.len = tokens.length;\\n\\n    // Close positions to convert all required amountsToConvert\\n    repaidAmountsOut = new uint[](tokens.length);\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset || amountsToConvert[i] == 0) continue;\\n      (, repaidAmountsOut[i]) = _closePosition(tetuConverter, v.asset, tokens[i], amountsToConvert[i]);\\n    }\\n\\n    // Manually swap remain leftovers\\n    for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset || amountsToConvert[i] == 0) continue;\\n      if (amountsToConvert[i] > repaidAmountsOut[i]) {\\n        (v.spent, v.received) = _liquidate(\\n          tetuConverter,\\n          liquidator,\\n          tokens[i],\\n          v.asset,\\n          amountsToConvert[i] - repaidAmountsOut[i],\\n          _ASSET_LIQUIDATION_SLIPPAGE,\\n          liquidationThreshold,\\n          false\\n        );\\n        collateralOut += v.received;\\n        repaidAmountsOut[i] += v.spent;\\n      }\\n    }\\n\\n    // Calculate amount of received collateral\\n    v.balance = IERC20(v.asset).balanceOf(address(this));\\n    collateralOut = v.balance > v.balanceBefore\\n      ? v.balance - v.balanceBefore\\n      : 0;\\n\\n    return (collateralOut, repaidAmountsOut);\\n  }\\n\\n  /// @notice Close debts (if it's allowed) in converter until we don't have {requestedAmount} on balance\\n  /// @dev We assume here that this function is called before closing any positions in the current block\\n  /// @param liquidationThresholds Min allowed amounts-out for liquidations\\n  /// @param requestedAmount Requested amount of main asset that should be added to the current balance\\n  /// @return expectedAmount Main asset amount expected to be received on balance after all conversions and swaps\\n  function closePositionsToGetAmount(\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator,\\n    uint indexAsset,\\n    mapping(address => uint) storage liquidationThresholds,\\n    uint requestedAmount,\\n    address[] memory tokens\\n  ) external returns (\\n    uint expectedAmount\\n  ) {\\n    return _closePositionsToGetAmount(\\n      converter_,\\n      liquidator,\\n      indexAsset,\\n      liquidationThresholds,\\n      requestedAmount,\\n      tokens\\n    );\\n  }\\n\\n  function _closePositionsToGetAmount(\\n    ITetuConverter converter_,\\n    ITetuLiquidator liquidator,\\n    uint indexAsset,\\n    mapping(address => uint) storage liquidationThresholds,\\n    uint requestedAmount,\\n    address[] memory tokens\\n  ) internal returns (\\n    uint expectedAmount\\n  ) {\\n    if (requestedAmount != 0) {\\n      CloseDebtsForRequiredAmountLocal memory v;\\n      v.asset = tokens[indexAsset];\\n      v.len = tokens.length;\\n      v.balance = IERC20(v.asset).balanceOf(address(this));\\n\\n      for (uint i; i < v.len; i = AppLib.uncheckedInc(i)) {\\n        if (i == indexAsset) continue;\\n\\n        // we need to increase balance on the following amount: requestedAmount - v.balance;\\n        // we have following borrow: amount-to-pay and corresponded collateral\\n        (v.totalDebt, v.totalCollateral) = converter_.getDebtAmountCurrent(address(this), v.asset, tokens[i], true);\\n\\n        uint tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\\n\\n        if (v.totalDebt != 0 || tokenBalance != 0) {\\n          //lazy initialization of the prices and decs\\n          if (v.prices.length == 0) {\\n            (v.prices, v.decs) = _getPricesAndDecs(\\n              IPriceOracle(IConverterController(converter_.controller()).priceOracle()),\\n              tokens,\\n              v.len\\n            );\\n          }\\n\\n          // repay the debt if any\\n          if (v.totalDebt != 0) {\\n            // what amount of main asset we should sell to pay the debt\\n            uint toSell = _getAmountToSell(\\n              requestedAmount,\\n              v.totalDebt,\\n              v.totalCollateral,\\n              v.prices,\\n              v.decs,\\n              indexAsset,\\n              i,\\n              tokenBalance\\n            );\\n\\n            // convert {toSell} amount of main asset to tokens[i]\\n            if (toSell != 0 && v.balance != 0) {\\n              toSell = Math.min(toSell, v.balance);\\n              (toSell,) = _liquidate(\\n                converter_,\\n                liquidator,\\n                v.asset,\\n                tokens[i],\\n                toSell,\\n                _ASSET_LIQUIDATION_SLIPPAGE,\\n                liquidationThresholds[tokens[i]],\\n                false\\n              );\\n              tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\\n            }\\n\\n            // sell {toSell}, repay the debt, return collateral back; we should receive amount > toSell\\n            expectedAmount += _repayDebt(converter_, v.asset, tokens[i], tokenBalance) - toSell;\\n\\n            // we can have some leftovers after closing the debt\\n            tokenBalance = IERC20(tokens[i]).balanceOf(address(this));\\n          }\\n\\n          // directly swap leftovers\\n          if (tokenBalance != 0) {\\n            (uint spentAmountIn,) = _liquidate(\\n              converter_,\\n              liquidator,\\n              tokens[i],\\n              v.asset,\\n              tokenBalance,\\n              _ASSET_LIQUIDATION_SLIPPAGE,\\n              liquidationThresholds[v.asset],\\n              false\\n            );\\n            if (spentAmountIn != 0) {\\n              // spentAmountIn can be zero if token balance is less than liquidationThreshold\\n              expectedAmount += spentAmountIn * v.prices[i] * v.decs[indexAsset] / v.prices[indexAsset] / v.decs[i];\\n            }\\n          }\\n\\n          // reduce of requestedAmount on the balance increment\\n          v.newBalance = IERC20(v.asset).balanceOf(address(this));\\n          require(v.newBalance >= v.balance, AppErrors.BALANCE_DECREASE);\\n\\n          if (requestedAmount > v.newBalance - v.balance) {\\n            requestedAmount -= (v.newBalance - v.balance);\\n            v.balance = v.newBalance;\\n          } else {\\n            // we get requestedAmount on the balance and don't need to make any other conversions\\n            break;\\n          }\\n        }\\n      }\\n    }\\n\\n    return expectedAmount;\\n  }\\n\\n  /// @notice What amount of collateral should be sold to pay the debt and receive {requestedAmount}\\n  /// @dev It doesn't allow to sell more than the amount of total debt in the borrow\\n  /// @param requestedAmount We need to increase balance (of collateral asset) on this amount\\n  /// @param totalDebt Total debt of the borrow in terms of borrow asset\\n  /// @param totalCollateral Total collateral of the borrow in terms of collateral asset\\n  /// @param prices Cost of $1 in terms of the asset, decimals 18\\n  /// @param decs 10**decimals for each asset\\n  /// @param indexCollateral Index of the collateral asset in {prices} and {decs}\\n  /// @param indexBorrowAsset Index of the borrow asset in {prices} and {decs}\\n  /// @param balanceBorrowAsset Available balance of the borrow asset, it will be used to cover the debt\\n  function _getAmountToSell(\\n    uint requestedAmount,\\n    uint totalDebt,\\n    uint totalCollateral,\\n    uint[] memory prices,\\n    uint[] memory decs,\\n    uint indexCollateral,\\n    uint indexBorrowAsset,\\n    uint balanceBorrowAsset\\n  ) internal pure returns (\\n    uint amountOut\\n  ) {\\n    if (totalDebt != 0) {\\n      if (balanceBorrowAsset != 0) {\\n        // there is some borrow asset on balance\\n        // it will be used to cover the debt\\n        // let's reduce the size of totalDebt/Collateral to exclude balanceBorrowAsset\\n        uint sub = Math.min(balanceBorrowAsset, totalDebt);\\n        totalCollateral -= totalCollateral * sub / totalDebt;\\n        totalDebt -= sub;\\n      }\\n\\n      // for definiteness: usdc - collateral asset, dai - borrow asset\\n      // Pc = price of the USDC, Pb = price of the DAI, alpha = Pc / Pb [DAI / USDC]\\n      // S [USDC] - amount to sell, R [DAI] = alpha * S - amount to repay\\n      // After repaying R we get: alpha * S * C / R\\n      // Balance should be increased on: requestedAmount = alpha * S * C / R - S\\n      // So, we should sell: S = requestedAmount / (alpha * C / R - 1))\\n      // We can lost some amount on liquidation of S => R, so we need to use some gap = {GAP_AMOUNT_TO_SELL}\\n      // Same formula: S * h = S + requestedAmount, where h = health factor => s = requestedAmount / (h - 1)\\n      // h = alpha * C / R\\n      uint alpha18 = prices[indexCollateral] * decs[indexBorrowAsset] * 1e18\\n        / prices[indexBorrowAsset] / decs[indexCollateral];\\n\\n      // if totalCollateral is zero (liquidation happens) we will have zero amount (the debt shouldn't be paid)\\n      amountOut = totalDebt != 0 && alpha18 * totalCollateral / totalDebt > 1e18\\n        ? Math.min(requestedAmount, totalCollateral) * 1e18 / (alpha18 * totalCollateral / totalDebt - 1e18)\\n        : 0;\\n\\n      if (amountOut != 0) {\\n        // we shouldn't try to sell amount greater than amount of totalDebt in terms of collateral asset\\n        // but we always asks +1% because liquidation results can be different a bit from expected\\n        amountOut = (GAP_CONVERSION + DENOMINATOR) * Math.min(amountOut, totalDebt * 1e18 / alpha18) / DENOMINATOR;\\n      }\\n    }\\n\\n    return amountOut;\\n  }\\n\\n  /// @notice Repay {amountIn} and get collateral in return, calculate expected amount\\n  ///         Take into account possible debt-gap and the fact that the amount of debt may be less than {amountIn}\\n  /// @param amountToRepay Max available amount of borrow asset that we can repay\\n  /// @return expectedAmountOut Estimated amount of main asset that should be added to balance = collateral - {toSell}\\n  function _repayDebt(\\n    ITetuConverter converter,\\n    address collateralAsset,\\n    address borrowAsset,\\n    uint amountToRepay\\n  ) internal returns (\\n    uint expectedAmountOut\\n  ) {\\n    uint balanceBefore = IERC20(borrowAsset).balanceOf(address(this));\\n\\n    // get amount of debt with debt-gap\\n    (uint needToRepay,) = converter.getDebtAmountCurrent(address(this), collateralAsset, borrowAsset, true);\\n    uint amountRepay = Math.min(amountToRepay < needToRepay ? amountToRepay : needToRepay, balanceBefore);\\n\\n    // get expected amount without debt-gap\\n    uint swappedAmountOut;\\n    (expectedAmountOut, swappedAmountOut) = converter.quoteRepay(address(this), collateralAsset, borrowAsset, amountRepay);\\n\\n    if (expectedAmountOut > swappedAmountOut) {\\n      // Following situation is possible\\n      //    needToRepay = 100, needToRepayExact = 90 (debt gap is 10)\\n      //    1) amountRepay = 80\\n      //       expectedAmountOut is calculated for 80, no problems\\n      //    2) amountRepay = 99,\\n      //       expectedAmountOut is calculated for 90 + 9 (90 - repay, 9 - direct swap)\\n      //       expectedAmountOut must be reduced on 9 here (!)\\n      expectedAmountOut -= swappedAmountOut;\\n    }\\n\\n    // close the debt\\n    _closePositionExact(converter, collateralAsset, borrowAsset, amountRepay, balanceBefore);\\n\\n    return expectedAmountOut;\\n  }\\n  //endregion convertAfterWithdraw\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Other helpers\\n  /////////////////////////////////////////////////////////////////////\\n\\n  function getAssetPriceFromConverter(ITetuConverter converter, address token) external view returns (uint) {\\n    return IPriceOracle(IConverterController(converter.controller()).priceOracle()).getAssetPrice(token);\\n  }\\n\\n  function registerIncome(uint assetBefore, uint assetAfter) internal pure returns (uint earned, uint lost) {\\n    if (assetAfter > assetBefore) {\\n      earned = assetAfter - assetBefore;\\n    } else {\\n      lost = assetBefore - assetAfter;\\n    }\\n    return (earned, lost);\\n  }\\n\\n  /// @notice Register income and cover possible loss\\n  function coverPossibleStrategyLoss(uint assetBefore, uint assetAfter, address splitter) external returns (uint earned) {\\n    uint lost;\\n    (earned, lost) = ConverterStrategyBaseLib.registerIncome(assetBefore, assetAfter);\\n    if (lost != 0) {\\n      ISplitter(splitter).coverPossibleStrategyLoss(earned, lost);\\n    }\\n    emit FixPriceChanges(assetBefore, assetAfter);\\n  }\\n\\n  //endregion Other helpers\\n}\\n\\n\",\"keccak256\":\"0x4d3338e5591a662416721c2348c450d7d89af66d092c19f753f208911e668a9e\",\"license\":\"MIT\"},\"contracts/strategies/ConverterStrategyBaseLib2.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IForwarder.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuVaultV2.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ISplitter.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/strategy/StrategyLib.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/IPriceOracle.sol\\\";\\nimport \\\"@tetu_io/tetu-converter/contracts/interfaces/ITetuConverter.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Math.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/ITetuLiquidator.sol\\\";\\nimport \\\"../libs/AppErrors.sol\\\";\\nimport \\\"../libs/AppLib.sol\\\";\\nimport \\\"../libs/TokenAmountsLib.sol\\\";\\nimport \\\"../libs/ConverterEntryKinds.sol\\\";\\n\\n/// @notice Continuation of ConverterStrategyBaseLib (workaround for size limits)\\nlibrary ConverterStrategyBaseLib2 {\\n  using SafeERC20 for IERC20;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///                        DATA TYPES\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///                        CONSTANTS\\n  /////////////////////////////////////////////////////////////////////\\n\\n  uint internal constant DENOMINATOR = 100_000;\\n\\n  /// @dev 0.5% of max profit for strategy TVL\\n  /// @notice Limit max amount of profit that can be send to insurance after price changing\\n  uint public constant PRICE_CHANGE_PROFIT_TOLERANCE = 500;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///                        EVENTS\\n  /////////////////////////////////////////////////////////////////////\\n\\n  event OnChangePerformanceFeeRatio(uint newRatio);\\n  event LiquidationThresholdChanged(address token, uint amount);\\n  event ReinvestThresholdPercentChanged(uint amount);\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///                        MAIN LOGIC\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Get balances of the {tokens_} except balance of the token at {indexAsset} position\\n  function getAvailableBalances(\\n    address[] memory tokens_,\\n    uint indexAsset\\n  ) external view returns (uint[] memory) {\\n    uint len = tokens_.length;\\n    uint[] memory amountsToConvert = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) continue;\\n      amountsToConvert[i] = IERC20(tokens_[i]).balanceOf(address(this));\\n    }\\n    return amountsToConvert;\\n  }\\n\\n  /// @notice Send {amount_} of {asset_} to {receiver_} and insurance\\n  /// @param asset_ Underlying asset\\n  /// @param amount_ Amount of underlying asset to be sent to\\n  /// @param receiver_ Performance receiver\\n  /// @param ratio [0..100_000], 100_000 - send full amount to perf, 0 - send full amount to the insurance.\\n  function sendPerformanceFee(address asset_, uint amount_, address splitter, address receiver_, uint ratio) external returns (\\n    uint toPerf,\\n    uint toInsurance\\n  ) {\\n    // read inside lib for reduce contract space in the main contract\\n    address insurance = address(ITetuVaultV2(ISplitter(splitter).vault()).insurance());\\n\\n    toPerf = amount_ * ratio / DENOMINATOR;\\n    toInsurance = amount_ - toPerf;\\n\\n    if (toPerf != 0) {\\n      IERC20(asset_).safeTransfer(receiver_, toPerf);\\n    }\\n    if (toInsurance != 0) {\\n      IERC20(asset_).safeTransfer(insurance, toInsurance);\\n    }\\n  }\\n\\n  function sendTokensToForwarder(\\n    address controller_,\\n    address splitter_,\\n    address[] memory tokens_,\\n    uint[] memory amounts_\\n  ) external {\\n    uint len = tokens_.length;\\n    IForwarder forwarder = IForwarder(IController(controller_).forwarder());\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      AppLib.approveIfNeeded(tokens_[i], amounts_[i], address(forwarder));\\n    }\\n\\n    (tokens_, amounts_) = TokenAmountsLib.filterZeroAmounts(tokens_, amounts_);\\n    forwarder.registerIncome(tokens_, amounts_, ISplitter(splitter_).vault(), true);\\n  }\\n\\n  /// @notice For each {token_} calculate a part of {amount_} to be used as collateral according to the weights.\\n  ///         I.e. we have 300 USDC, we need to split it on 100 USDC, 100 USDT, 100 DAI\\n  ///         USDC is main asset, USDT and DAI should be borrowed. We check amounts of USDT and DAI on the balance\\n  ///         and return collaterals reduced on that amounts. For main asset, we return full amount always (100 USDC).\\n  function getCollaterals(\\n    uint amount_,\\n    address[] memory tokens_,\\n    uint[] memory weights_,\\n    uint totalWeight_,\\n    uint indexAsset_,\\n    IPriceOracle priceOracle\\n  ) external view returns (\\n    uint[] memory tokenAmountsOut\\n  ) {\\n    uint len = tokens_.length;\\n    tokenAmountsOut = new uint[](len);\\n\\n    // get token prices and decimals\\n    uint[] memory prices = new uint[](len);\\n    uint[] memory decs = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      decs[i] = 10 ** IERC20Metadata(tokens_[i]).decimals();\\n      prices[i] = priceOracle.getAssetPrice(tokens_[i]);\\n    }\\n\\n    // split the amount on tokens proportionally to the weights\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      uint amountAssetForToken = amount_ * weights_[i] / totalWeight_;\\n\\n      if (i == indexAsset_) {\\n        tokenAmountsOut[i] = amountAssetForToken;\\n      } else {\\n        // if we have some tokens on balance then we need to use only a part of the collateral\\n        uint tokenAmountToBeBorrowed = amountAssetForToken\\n          * prices[indexAsset_]\\n          * decs[i]\\n          / prices[i]\\n          / decs[indexAsset_];\\n\\n        uint tokenBalance = IERC20(tokens_[i]).balanceOf(address(this));\\n        if (tokenBalance < tokenAmountToBeBorrowed) {\\n          tokenAmountsOut[i] = amountAssetForToken * (tokenAmountToBeBorrowed - tokenBalance) / tokenAmountToBeBorrowed;\\n        }\\n      }\\n    }\\n  }\\n\\n  /// @notice Calculate amount of liquidity that should be withdrawn from the pool to get {targetAmount_}\\n  ///               liquidityAmount = _depositorLiquidity() * {liquidityRatioOut} / 1e18\\n  ///         User needs to withdraw {targetAmount_} in main asset.\\n  ///         There are two kinds of available liquidity:\\n  ///         1) liquidity in the pool - {depositorLiquidity_}\\n  ///         2) Converted amounts on balance of the strategy - {baseAmounts_}\\n  ///         To withdraw {targetAmount_} we need\\n  ///         1) Reconvert converted amounts back to main asset\\n  ///         2) IF result amount is not necessary - withdraw some liquidity from the pool\\n  ///            and also convert it to the main asset.\\n  /// @dev This is a writable function with read-only behavior (because of the quote-call)\\n  /// @param targetAmount_ Required amount of main asset to be withdrawn from the strategy; 0 - withdraw all\\n  /// @param strategy_ Address of the strategy\\n  /// @return resultAmount Amount of liquidity that should be withdrawn from the pool, cannot exceed depositorLiquidity\\n  /// @return amountsToConvertOut Amounts of {tokens} that should be converted to the main asset\\n  function getLiquidityAmount(\\n    uint targetAmount_,\\n    address strategy_,\\n    address[] memory tokens,\\n    uint indexAsset,\\n    ITetuConverter converter,\\n    uint investedAssets,\\n    uint depositorLiquidity\\n  ) external returns (\\n    uint resultAmount,\\n    uint[] memory amountsToConvertOut\\n  ) {\\n    bool all = targetAmount_ == 0;\\n\\n    uint len = tokens.length;\\n    amountsToConvertOut = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == indexAsset) continue;\\n\\n      uint balance = IERC20(tokens[i]).balanceOf(address(this));\\n      if (balance != 0) {\\n        // let's estimate collateral that we received back after repaying balance-amount\\n        (uint expectedCollateral,) = converter.quoteRepay(strategy_, tokens[indexAsset], tokens[i], balance);\\n\\n        if (all || targetAmount_ != 0) {\\n          // We always repay WHOLE available balance-amount even if it gives us much more amount then we need.\\n          // We cannot repay a part of it because converter doesn't allow to know\\n          // what amount should be repaid to get given amount of collateral.\\n          // And it's too dangerous to assume that we can calculate this amount\\n          // by reducing balance-amount proportionally to expectedCollateral/targetAmount_\\n          amountsToConvertOut[i] = balance;\\n        }\\n\\n        targetAmount_ = targetAmount_ > expectedCollateral\\n          ? targetAmount_ - expectedCollateral\\n          : 0;\\n\\n        investedAssets = investedAssets > expectedCollateral\\n          ? investedAssets - expectedCollateral\\n          : 0;\\n      }\\n    }\\n\\n    uint liquidityRatioOut = all || investedAssets == 0\\n      ? 1e18\\n      : ((targetAmount_ == 0)\\n        ? 0\\n        : 1e18\\n        * 101 // add 1% on top...\\n        * targetAmount_ / investedAssets // a part of amount that we are going to withdraw\\n        / 100 // .. add 1% on top\\n      );\\n\\n    resultAmount = liquidityRatioOut != 0\\n      ? Math.min(liquidityRatioOut * depositorLiquidity / 1e18, depositorLiquidity)\\n      : 0;\\n  }\\n\\n  /// @notice Claim rewards from tetuConverter, generate result list of all available rewards and airdrops\\n  /// @dev The post-processing is rewards conversion to the main asset\\n  /// @param tokens_ tokens received from {_depositorPoolAssets}\\n  /// @param rewardTokens_ List of rewards claimed from the internal pool\\n  /// @param rewardTokens_ Amounts of rewards claimed from the internal pool\\n  /// @param tokensOut List of available rewards - not zero amounts, reward tokens don't repeat\\n  /// @param amountsOut Amounts of available rewards\\n  function claimConverterRewards(\\n    ITetuConverter converter_,\\n    address[] memory tokens_,\\n    address[] memory rewardTokens_,\\n    uint[] memory rewardAmounts_,\\n    uint[] memory balancesBefore\\n  ) external returns (\\n    address[] memory tokensOut,\\n    uint[] memory amountsOut\\n  ) {\\n    // Rewards from TetuConverter\\n    (address[] memory tokensTC, uint[] memory amountsTC) = converter_.claimRewards(address(this));\\n\\n    // Join arrays and recycle tokens\\n    (tokensOut, amountsOut) = TokenAmountsLib.combineArrays(\\n      rewardTokens_, rewardAmounts_,\\n      tokensTC, amountsTC,\\n      // by default, depositor assets have zero amounts here\\n      tokens_, new uint[](tokens_.length)\\n    );\\n\\n    // set fresh balances for depositor tokens\\n    uint len = tokensOut.length;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      for (uint j; j < tokens_.length; j = AppLib.uncheckedInc(j)) {\\n        if (tokensOut[i] == tokens_[j]) {\\n          amountsOut[i] = IERC20(tokens_[j]).balanceOf(address(this)) - balancesBefore[j];\\n        }\\n      }\\n    }\\n\\n    // filter zero amounts out\\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\\n  }\\n\\n  /// @notice Send given amount of underlying to the insurance\\n  /// @param strategyBalance Total strategy balance = balance of underlying + current invested assets amount\\n  /// @return Amount of underlying sent to the insurance\\n  function sendToInsurance(address asset, uint amount, address splitter, uint strategyBalance) external returns (uint) {\\n    uint amountToSend = Math.min(amount, IERC20(asset).balanceOf(address(this)));\\n    if (amountToSend != 0) {\\n      // max amount that can be send to insurance is limited by PRICE_CHANGE_PROFIT_TOLERANCE\\n\\n      // Amount limitation should be implemented in the same way as in StrategySplitterV2._coverLoss\\n      // Revert or cutting amount in both cases\\n\\n      // amountToSend = Math.min(amountToSend, PRICE_CHANGE_PROFIT_TOLERANCE * strategyBalance / 100_000);\\n      require(strategyBalance != 0, AppErrors.ZERO_BALANCE);\\n      require(amountToSend <= PRICE_CHANGE_PROFIT_TOLERANCE * strategyBalance / 100_000, AppErrors.EARNED_AMOUNT_TOO_HIGH);\\n      IERC20(asset).safeTransfer(address(ITetuVaultV2(ISplitter(splitter).vault()).insurance()), amountToSend);\\n    }\\n    return amountToSend;\\n  }\\n\\n  //region ---------------------------------------- Setters\\n  function checkPerformanceFeeRatioChanged(address controller, uint ratio_) external {\\n    StrategyLib.onlyOperators(controller);\\n    require(ratio_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\\n    emit OnChangePerformanceFeeRatio(ratio_);\\n  }\\n\\n  function checkReinvestThresholdPercentChanged(address controller, uint percent_) external {\\n    StrategyLib.onlyOperators(controller);\\n    require(percent_ <= DENOMINATOR, StrategyLib.WRONG_VALUE);\\n    emit ReinvestThresholdPercentChanged(percent_);\\n  }\\n\\n  function checkLiquidationThresholdChanged(address controller, address token, uint amount) external {\\n    StrategyLib.onlyOperators(controller);\\n    emit LiquidationThresholdChanged(token, amount);\\n  }\\n  //endregion ---------------------------------------- Setters\\n\\n}\\n\\n\",\"keccak256\":\"0xdca7b5e309602ec348eca44cae0e0411664c4b085c6a6e57f3a94464aa106f65\",\"license\":\"MIT\"},\"contracts/strategies/DepositorBase.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\n/// @title Abstract base Depositor contract.\\n/// @notice Converter strategies should inherit xDepositor.\\n/// @notice All communication with external pools should be done at inherited contract\\n/// @author bogdoslav\\nabstract contract DepositorBase {\\n\\n  /// @notice Returns pool assets\\n  function _depositorPoolAssets() internal virtual view returns (address[] memory assets);\\n\\n  /// @notice Returns pool token proportions\\n  function _depositorPoolWeights() internal virtual view returns (uint[] memory weights, uint total);\\n\\n  /// @notice Returns pool token reserves\\n  function _depositorPoolReserves() internal virtual view returns (uint[] memory reserves);\\n\\n  /// @notice Returns depositor's pool shares / lp token amount\\n  function _depositorLiquidity() internal virtual view returns (uint);\\n\\n  //// @notice Total amount of LP tokens in the depositor\\n  function _depositorTotalSupply() internal view virtual returns (uint);\\n\\n  /// @notice Deposit given amount to the pool.\\n  /// @dev Depositor must care about tokens approval by itself.\\n  function _depositorEnter(uint[] memory amountsDesired_) internal virtual returns (\\n    uint[] memory amountsConsumed,\\n    uint liquidityOut\\n  );\\n\\n  /// @notice Withdraw given lp amount from the pool.\\n  /// @param liquidityAmount Amount of liquidity to be converted\\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\\n  function _depositorExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\\n\\n  /// @notice Quotes output for given lp amount from the pool.\\n  /// @dev Write function with read-only behavior. BalanceR's depositor requires not-view.\\n  /// @param liquidityAmount Amount of liquidity to be converted\\n  ///                        If requested liquidityAmount >= invested, then should make full exit.\\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\\n  function _depositorQuoteExit(uint liquidityAmount) internal virtual returns (uint[] memory amountsOut);\\n\\n  /// @dev If pool supports emergency withdraw need to call it for emergencyExit()\\n  /// @return amountsOut The order of amounts is the same as in {_depositorPoolAssets}\\n  function _depositorEmergencyExit() internal virtual returns (uint[] memory amountsOut) {\\n    return _depositorExit(_depositorLiquidity());\\n  }\\n\\n  /// @notice Claim all possible rewards.\\n  /// @return rewardTokens Claimed token addresses\\n  /// @return rewardAmounts Claimed token amounts\\n  /// @return depositorBalancesBefore Must have the same length as _depositorPoolAssets and represent balances before claim in the same order\\n  function _depositorClaimRewards() internal virtual returns (\\n    address[] memory rewardTokens,\\n    uint[] memory rewardAmounts,\\n    uint[] memory depositorBalancesBefore\\n  );\\n}\\n\",\"keccak256\":\"0x70915b03d5b7fb42f7a930745974b9cf8f735d6a82b1b9054c2ccaf68c5c9436\",\"license\":\"MIT\"},\"contracts/strategies/balancer/BalancerBoostedDepositor.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/Initializable.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"../DepositorBase.sol\\\";\\nimport \\\"./BalancerLogicLib.sol\\\";\\nimport \\\"../../integrations/balancer/IBVault.sol\\\";\\nimport \\\"../../integrations/balancer/IBalancerHelper.sol\\\";\\nimport \\\"../../integrations/balancer/IComposableStablePool.sol\\\";\\nimport \\\"../../integrations/balancer/IChildChainLiquidityGaugeFactory.sol\\\";\\nimport \\\"../../integrations/balancer/IBalancerGauge.sol\\\";\\n\\n\\n/// @title Depositor for Composable Stable Pool with several embedded linear pools like \\\"Balancer Boosted Tetu USD\\\"\\n/// @dev See https://app.balancer.fi/polygon#/polygon/pool/0xb3d658d5b95bf04e2932370dd1ff976fe18dd66a000000000000000000000ace\\n///            bb-t-DAI (DAI + tDAI) + bb-t-USDC (USDC + tUSDC) + bb-t-USDT (USDT + tUSDT)\\n///      See https://docs.balancer.fi/products/balancer-pools/boosted-pools for explanation of Boosted Pools on BalanceR.\\n///      Terms\\n///         bb-t-USD = pool bpt\\n///         bb-t-DAI, bb-t-USDC, bb-t-USDT = underlying bpt\\nabstract contract BalancerBoostedDepositor is DepositorBase, Initializable {\\n  using SafeERC20 for IERC20;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///region Constants\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Version of this contract. Adjust manually on each code modification.\\n  string public constant BALANCER_BOOSTED_DEPOSITOR_VERSION = \\\"1.0.0\\\";\\n\\n  /// @dev https://dev.balancer.fi/references/contracts/deployment-addresses\\n  IBVault internal constant BALANCER_VAULT = IBVault(0xBA12222222228d8Ba445958a75a0704d566BF2C8);\\n  address internal constant BALANCER_HELPER = 0x239e55F427D44C3cc793f49bFB507ebe76638a2b;\\n  /// @notice ChildChainLiquidityGaugeFactory allows to get gauge address by pool id\\n  /// @dev see https://dev.balancer.fi/resources/vebal-and-gauges/gauges\\n  /// todo Update to new gauges, new ChildChainGauge is 0xc9b36096f5201ea332Db35d6D195774ea0D5988f\\n  address internal constant CHILD_CHAIN_LIQUIDITY_GAUGE_FACTORY = 0x3b8cA519122CdD8efb272b0D3085453404B25bD0;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///endregion Constants\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /////////////////////////////////////////////////////////////////////\\n  //region Variables\\n  //                Keep names and ordering!\\n  // Add only in the bottom and don't forget to decrease gap variable\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice i.e. for \\\"Balancer Boosted Aave USD\\\": 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075b\\n  /// @notice i.e. for \\\"Balancer Boosted Tetu USD\\\": 0xb3d658d5b95bf04e2932370dd1ff976fe18dd66a000000000000000000000ace\\n  bytes32 public poolId;\\n  IBalancerGauge public gauge;\\n  /////////////////////////////////////////////////////////////////////\\n  ///endregion Variables\\n  /////////////////////////////////////////////////////////////////////\\n\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///                   Initialization\\n  /////////////////////////////////////////////////////////////////////\\n\\n  function __BalancerBoostedDepositor_init(address pool_) internal onlyInitializing {\\n    poolId = IComposableStablePool(pool_).getPoolId();\\n\\n    gauge = IBalancerGauge(\\n      IChildChainLiquidityGaugeFactory(\\n        CHILD_CHAIN_LIQUIDITY_GAUGE_FACTORY\\n      ).getPoolGauge(pool_)\\n    );\\n    // infinite approve of pool-BPT to the gauge todo is it safe for the external gauge?\\n    IERC20(pool_).safeApprove(address(gauge), type(uint).max);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///                       View\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\\n  function _depositorPoolAssets() override internal virtual view returns (address[] memory poolAssets) {\\n    return BalancerLogicLib.depositorPoolAssets(BALANCER_VAULT, poolId);\\n  }\\n\\n  /// @notice Returns pool weights\\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\\n  /// @return totalWeight Total sum of all items of {weights}\\n  function _depositorPoolWeights() override internal virtual view returns (uint[] memory weights, uint totalWeight) {\\n    return BalancerLogicLib.depositorPoolWeights(BALANCER_VAULT, poolId);\\n  }\\n\\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of DAI, USDC, USDT\\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \\\"Balancer Boosted Aave USD\\\" we return:\\n  ///                     0: balance DAI + (balance amDAI recalculated to DAI)\\n  ///                     1: balance USDC + (amUSDC recalculated to USDC)\\n  ///                     2: balance USDT + (amUSDT recalculated to USDT)\\n  function _depositorPoolReserves() override internal virtual view returns (uint[] memory reservesOut) {\\n    reservesOut = BalancerLogicLib.depositorPoolReserves(BALANCER_VAULT, poolId);\\n  }\\n\\n  /// @notice Returns depositor's pool shares / lp token amount\\n  function _depositorLiquidity() override internal virtual view returns (uint liquidityOut) {\\n    liquidityOut = gauge.balanceOf(address(this))\\n    + IComposableStablePool(BalancerLogicLib.getPoolAddress(poolId)).balanceOf(address(this));\\n  }\\n\\n  //// @notice Total amount of liquidity (LP tokens) in the depositor\\n  function _depositorTotalSupply() override internal view returns (uint totalSupplyOut) {\\n    totalSupplyOut = IComposableStablePool(BalancerLogicLib.getPoolAddress(poolId)).getActualSupply();\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///             Enter, exit\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Deposit given amount to the pool.\\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\\n  ///         i.e. for \\\"Balancer Boosted Aave USD\\\" we have DAI, USDC, USDT\\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\\n  function _depositorEnter(uint[] memory amountsDesired_) override internal virtual returns (\\n    uint[] memory amountsConsumedOut,\\n    uint liquidityOut\\n  ) {\\n    bytes32 _poolId = poolId;\\n    IComposableStablePool pool = IComposableStablePool(BalancerLogicLib.getPoolAddress(_poolId));\\n\\n    // join to the pool, receive pool-BPTs\\n    (amountsConsumedOut, liquidityOut) = BalancerLogicLib.depositorEnter(BALANCER_VAULT, _poolId, amountsDesired_);\\n\\n    // stake all available pool-BPTs to the gauge\\n    // we can have pool-BPTs on depositor's balance after previous exit, stake them too\\n    gauge.deposit(pool.balanceOf(address(this)));\\n  }\\n\\n  /// @notice Withdraw given amount of LP-tokens from the pool.\\n  /// @dev if requested liquidityAmount >= invested, then should make full exit\\n  /// @param liquidityAmount_ Max amount to withdraw in bpt. Actual withdrawn amount will be less,\\n  ///                         so it worth to add a gap to this amount, i.e. 1%\\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\\n  function _depositorExit(uint liquidityAmount_) override internal virtual returns (\\n    uint[] memory amountsOut\\n  ) {\\n    bytes32 _poolId = poolId;\\n    IBalancerGauge __gauge = gauge;\\n    IComposableStablePool pool = IComposableStablePool(BalancerLogicLib.getPoolAddress(_poolId));\\n\\n    // we need to withdraw pool-BPTs from the _gauge\\n    // at first, let's try to use exist pool-BPTs on the depositor balance, probably it's enough\\n    // we can have pool-BPTs on depositor's balance after previous exit, see BalancerLogicLib.depositorExit\\n    uint depositorBalance = pool.balanceOf(address(this));\\n    uint gaugeBalance = __gauge.balanceOf(address(this));\\n\\n    uint liquidityToWithdraw = liquidityAmount_ > depositorBalance\\n    ? liquidityAmount_ - depositorBalance\\n    : 0;\\n\\n    // calculate how much pool-BPTs we should withdraw from the gauge\\n    if (liquidityToWithdraw > 0) {\\n      if (liquidityToWithdraw > gaugeBalance) {\\n        liquidityToWithdraw = gaugeBalance;\\n      }\\n    }\\n\\n    // un-stake required pool-BPTs from the gauge\\n    if (liquidityToWithdraw > 0) {\\n      __gauge.withdraw(liquidityToWithdraw);\\n    }\\n\\n    // withdraw the liquidity from the pool\\n    amountsOut = (liquidityAmount_ >= depositorBalance + gaugeBalance)\\n    ? BalancerLogicLib.depositorExitFull(BALANCER_VAULT, _poolId)\\n    : BalancerLogicLib.depositorExit(BALANCER_VAULT, _poolId, liquidityToWithdraw);\\n  }\\n\\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\\n  /// @dev if requested liquidityAmount >= invested, then full exit is required\\n  ///      we emulate is at normal exit + conversion of remain BPT directly to the main asset\\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\\n  function _depositorQuoteExit(uint liquidityAmount_) override internal virtual returns (uint[] memory amountsOut) {\\n    uint liquidity = _depositorLiquidity();\\n    if (liquidity == 0) {\\n      // there is no liquidity, output is zero\\n      return new uint[](_depositorPoolAssets().length);\\n    } else {\\n      // BalancerLogicLib.depositorQuoteExit takes into account the cost of unused BPT\\n      // so we don't need a special logic here for the full exit\\n      return BalancerLogicLib.depositorQuoteExit(\\n        BALANCER_VAULT,\\n        IBalancerHelper(BALANCER_HELPER),\\n        poolId,\\n        liquidityAmount_\\n      );\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///             Claim rewards\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @dev Claim all possible rewards.\\n  function _depositorClaimRewards() override internal virtual returns (\\n    address[] memory tokensOut,\\n    uint[] memory amountsOut,\\n    uint[] memory depositorBalancesBefore\\n  ) {\\n    return BalancerLogicLib.depositorClaimRewards(gauge, _depositorPoolAssets(), rewardTokens());\\n  }\\n\\n  /// @dev Returns reward token addresses array.\\n  function rewardTokens() public view returns (address[] memory tokens) {\\n    uint total;\\n    for (; total < 8; ++total) {\\n      if (gauge.reward_tokens(total) == address(0)) {\\n        break;\\n      }\\n    }\\n    tokens = new address[](total);\\n    for (uint i; i < total; ++i) {\\n      tokens[i] = gauge.reward_tokens(i);\\n    }\\n  }\\n\\n  /// @dev This empty reserved space is put in place to allow future versions to add new\\n  /// variables without shifting down storage in the inheritance chain.\\n  /// See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\\n  uint[50-2] private __gap; // 50 - count of variables\\n}\\n\",\"keccak256\":\"0x93d3e8ae824b4ddd8954994ed886ecfcb4426226ee0fbfe5e6b39a8ab2bef104\",\"license\":\"MIT\"},\"contracts/strategies/balancer/BalancerBoostedStrategy.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"../ConverterStrategyBase.sol\\\";\\nimport \\\"./BalancerBoostedDepositor.sol\\\";\\nimport \\\"../../libs/AppPlatforms.sol\\\";\\n\\n/// @title Delta-neutral converter strategy for Balancer boosted pools\\n/// @author a17, dvpublic\\ncontract BalancerBoostedStrategy is ConverterStrategyBase, BalancerBoostedDepositor {\\n  string public constant override NAME = \\\"Balancer Boosted Strategy\\\";\\n  string public constant override PLATFORM = AppPlatforms.BALANCER;\\n  string public constant override STRATEGY_VERSION = \\\"1.0.1\\\";\\n\\n  function init(\\n    address controller_,\\n    address splitter_,\\n    address converter_,\\n    address pool_\\n  ) external initializer {\\n    __BalancerBoostedDepositor_init(pool_);\\n    __ConverterStrategyBase_init(controller_, splitter_, converter_);\\n\\n    // setup specific name for UI\\n    strategySpecificName = BalancerLogicLib.createSpecificName(pool_);\\n    emit StrategyLib.StrategySpecificNameChanged(strategySpecificName); // todo: change to _checkStrategySpecificNameChanged\\n  }\\n\\n  function _handleRewards() internal virtual override returns (uint earned, uint lost, uint assetBalanceAfterClaim) {\\n    uint assetBalanceBefore = AppLib.balance(asset);\\n    (address[] memory rewardTokens, uint[] memory amounts) = _claim();\\n    _rewardsLiquidation(rewardTokens, amounts);\\n    assetBalanceAfterClaim = AppLib.balance(asset);\\n    (uint earned2, uint lost2) = ConverterStrategyBaseLib.registerIncome(assetBalanceBefore, assetBalanceAfterClaim);\\n    return (earned + earned2, lost + lost2, assetBalanceAfterClaim);\\n  }\\n}\\n\",\"keccak256\":\"0x1892a997c0bccdf14ad9e8b3c7e5c98873bbfee064dfa717b388d9cddcdb2fe6\",\"license\":\"MIT\"},\"contracts/strategies/balancer/BalancerLogicLib.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.17;\\n\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/interfaces/IERC20Metadata.sol\\\";\\nimport \\\"@tetu_io/tetu-contracts-v2/contracts/openzeppelin/SafeERC20.sol\\\";\\nimport \\\"../../libs/AppErrors.sol\\\";\\nimport \\\"../../libs/AppLib.sol\\\";\\nimport \\\"../../libs/TokenAmountsLib.sol\\\";\\nimport \\\"../../integrations/balancer/IComposableStablePool.sol\\\";\\nimport \\\"../../integrations/balancer/ILinearPool.sol\\\";\\nimport \\\"../../integrations/balancer/IBVault.sol\\\";\\nimport \\\"../../integrations/balancer/IBalancerHelper.sol\\\";\\nimport \\\"../../integrations/balancer/IBalancerGauge.sol\\\";\\n\\n/// @notice Functions of BalancerBoostedDepositor\\n/// @dev Many of functions are declared as external to reduce contract size\\nlibrary BalancerLogicLib {\\n  using SafeERC20 for IERC20;\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///             Types\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @dev local vars in getAmountsToDeposit to avoid stack too deep\\n  struct LocalGetAmountsToDeposit {\\n    /// @notice Decimals of {tokens_}, 0 for BPT\\n    uint[] decimals;\\n    /// @notice Length of {tokens_} array\\n    uint len;\\n    /// @notice amountBPT / underlyingAmount, decimals 18, 0 for BPT\\n    uint[] rates;\\n  }\\n\\n  /// @notice Local variables required inside _depositorEnter/Exit/QuoteExit, avoid stack too deep\\n  struct DepositorLocal {\\n    uint bptIndex;\\n    uint len;\\n    IERC20[] tokens;\\n    uint[] balances;\\n  }\\n\\n  /// @notice Used in linear pool quote swap math logic\\n  struct LinearPoolParams {\\n    uint fee;\\n    uint lowerTarget;\\n    uint upperTarget;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///             Asset related utils\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @notice Calculate amounts of {tokens} to be deposited to POOL_ID in proportions according to the {balances}\\n  /// @param amountsDesired_ Desired amounts of tokens. The order of the tokens is exactly the same as in {tokens}.\\n  ///                        But the array has length 3, not 4, because there is no amount for bb-am-USD here.\\n  /// @param tokens_ All bb-am-* tokens (including bb-am-USD) received through getPoolTokens\\n  ///                           The order of the tokens is exactly the same as in getPoolTokens-results\\n  /// @param balances_ Balances of bb-am-* pools in terms of bb-am-USD tokens (received through getPoolTokens)\\n  ///                           The order of the tokens is exactly the same as in {tokens}\\n  /// @param totalUnderlying_ Total amounts of underlying assets (DAI, USDC, etc) in embedded linear pools.\\n  ///                         The array should have same order of tokens as {tokens_}, value for BPT token is not used\\n  /// @param indexBpt_ Index of BPT token inside {balances_}, {tokens_} and {totalUnderlying_} arrays\\n  /// @return amountsOut Desired amounts in proper proportions for depositing.\\n  ///         The order of the tokens is exactly the same as in results of getPoolTokens, 0 for BPT\\n  ///         i.e. DAI, BB-AM-USD, USDC, USDT\\n  function getAmountsToDeposit(\\n    uint[] memory amountsDesired_,\\n    IERC20[] memory tokens_,\\n    uint[] memory balances_,\\n    uint[] memory totalUnderlying_,\\n    uint indexBpt_\\n  ) internal view returns (\\n    uint[] memory amountsOut\\n  ) {\\n    LocalGetAmountsToDeposit memory p;\\n    // check not zero balances, cache index of bbAmUSD, save 10**decimals to array\\n    p.len = tokens_.length;\\n    require(p.len == balances_.length, AppErrors.WRONG_LENGTHS);\\n    require(p.len == amountsDesired_.length || p.len - 1 == amountsDesired_.length, AppErrors.WRONG_LENGTHS);\\n\\n    p.decimals = new uint[](p.len);\\n    p.rates = new uint[](p.len);\\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\\n      if (i != indexBpt_) {\\n        require(balances_[i] != 0, AppErrors.ZERO_BALANCE);\\n        p.decimals[i] = 10 ** IERC20Metadata(address(tokens_[i])).decimals();\\n\\n        // Let's calculate a rate: amountBPT / underlyingAmount, decimals 18\\n        p.rates[i] = balances_[i] * 1e18 / totalUnderlying_[i];\\n      }\\n    }\\n\\n    amountsOut = new uint[](p.len - 1);\\n\\n    // The balances set proportions of underlying-bpt, i.e. bb-am-DAI : bb-am-USDC : bb-am-USDT\\n    // Our task is find amounts of DAI : USDC : USDT that won't change that proportions after deposit.\\n    // We have arbitrary desired amounts, i.e. DAI = X, USDC = Y, USDT = Z\\n    // For each token: assume that it can be used in full.\\n    // If so, what amounts will have other tokens in this case according to the given proportions?\\n    // i.e. DAI = X = 100.0 => USDC = 200.0, USDT = 400.0. We need: Y >= 200, Z >= 400\\n    // or   USDC = Y = 100.0 => DAI = 50.0, USDT = 200.0. We need: X >= 50, Z >= 200\\n    // If any amount is less then expected, the token cannot be used in full.\\n    // A token with min amount can be used in full, let's try to find its index.\\n    // [0 : len - 1]\\n    uint i3;\\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\\n      if (indexBpt_ == i) continue;\\n\\n      uint amountInBpt18 = amountsDesired_[i3] * p.rates[i];\\n\\n      // [0 : len]\\n      uint j;\\n      // [0 : len - 1]\\n      uint j3;\\n      for (; j < p.len; j = AppLib.uncheckedInc(j)) {\\n        if (indexBpt_ == j) continue;\\n\\n        // alpha = balancesDAI / balancesUSDC * decimalsDAI / decimalsUSDC\\n        // amountDAI = amountUSDC * alpha * rateUSDC / rateDAI\\n        amountsOut[j3] = amountInBpt18 * balances_[j] / p.rates[j] * p.decimals[j] / balances_[i] / p.decimals[i];\\n        if (amountsOut[j3] > amountsDesired_[j3]) break;\\n        j3++;\\n      }\\n\\n      if (j == p.len) break;\\n      i3++;\\n    }\\n  }\\n\\n\\n  /// @notice Calculate total amount of underlying asset for each token except BPT\\n  /// @dev Amount is calculated as MainTokenAmount + WrappedTokenAmount * WrappedTokenRate, see AaveLinearPool src\\n  function getTotalAssetAmounts(IBVault vault_, IERC20[] memory tokens_, uint indexBpt_) internal view returns (\\n    uint[] memory amountsOut\\n  ) {\\n    uint len = tokens_.length;\\n    amountsOut = new uint[](len);\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i != indexBpt_) {\\n        ILinearPool linearPool = ILinearPool(address(tokens_[i]));\\n        (, uint[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\\n\\n        amountsOut[i] =\\n        balances[linearPool.getMainIndex()]\\n        + balances[linearPool.getWrappedIndex()] * linearPool.getWrappedTokenRate() / 1e18;\\n      }\\n    }\\n  }\\n\\n  /// @notice Split {liquidityAmount_} by assets according to proportions of their total balances\\n  /// @param liquidityAmount_ Amount to withdraw in bpt\\n  /// @param balances_ Balances received from getPoolTokens\\n  /// @param bptIndex_ Index of pool-pbt inside {balances_}\\n  /// @return bptAmountsOut Amounts of underlying-BPT. The array doesn't include an amount for pool-bpt\\n  ///         Total amount of {bptAmountsOut}-items is equal to {liquidityAmount_}\\n  function getBtpAmountsOut(\\n    uint liquidityAmount_,\\n    uint[] memory balances_,\\n    uint bptIndex_\\n  ) internal pure returns (uint[] memory bptAmountsOut) {\\n    // we assume here, that len >= 2\\n    // we don't check it because StableMath.sol in balancer has _MIN_TOKENS = 2;\\n    uint len = balances_.length;\\n    bptAmountsOut = new uint[](len - 1);\\n\\n    // compute total balance, skip pool-bpt\\n    uint totalBalances;\\n    uint k;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == bptIndex_) continue;\\n      totalBalances += balances_[i];\\n      // temporary save incomplete amounts to bptAmountsOut\\n      bptAmountsOut[k] = liquidityAmount_ * balances_[i];\\n      ++k;\\n    }\\n\\n    // finalize computation of bptAmountsOut using known totalBalances\\n    uint total;\\n    for (k = 0; k < len - 1; k = AppLib.uncheckedInc(k)) {\\n      if (k == len - 2) {\\n        // leftovers => last item\\n        bptAmountsOut[k] = total > liquidityAmount_\\n        ? 0\\n        : liquidityAmount_ - total;\\n      } else {\\n        bptAmountsOut[k] /= totalBalances;\\n        total += bptAmountsOut[k];\\n      }\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///             Depositor view logic\\n  /////////////////////////////////////////////////////////////////////\\n  /// @notice Total amounts of the main assets under control of the pool, i.e amounts of USDT, USDC, DAI\\n  /// @return reservesOut Total amounts of embedded assets, i.e. for \\\"Balancer Boosted Tetu USD\\\" we return:\\n  ///                     0: balance USDT + (tUSDT recalculated to USDT)\\n  ///                     1: balance USDC + (tUSDC recalculated to USDC)\\n  ///                     2: balance DAI + (balance tDAI recalculated to DAI)\\n  function depositorPoolReserves(IBVault vault_, bytes32 poolId_) external view returns (uint[] memory reservesOut) {\\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\\n    uint bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\\n    uint len = tokens.length;\\n    // exclude pool-BPT\\n    reservesOut = new uint[](len - 1);\\n\\n    uint k;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == bptIndex) continue;\\n      ILinearPool linearPool = ILinearPool(address(tokens[i]));\\n\\n      // Each bb-t-* returns (main-token, wrapped-token, bb-t-itself), the order of tokens is arbitrary\\n      // i.e. (DAI + tDAI + bb-t-DAI) or (bb-t-USDC, tUSDC, USDC)\\n\\n      // get balances of all tokens of bb-am-XXX token, i.e. balances of (DAI, amDAI, bb-am-DAI)\\n      (, uint[] memory balances,) = vault_.getPoolTokens(linearPool.getPoolId());\\n      // DAI\\n      uint mainIndex = linearPool.getMainIndex();\\n      // tDAI\\n      uint wrappedIndex = linearPool.getWrappedIndex();\\n\\n      reservesOut[k] = balances[mainIndex] + balances[wrappedIndex] * linearPool.getWrappedTokenRate() / 1e18;\\n      ++k;\\n    }\\n  }\\n\\n  /// @notice Returns pool assets, same as getPoolTokens but without pool-bpt\\n  function depositorPoolAssets(IBVault vault_, bytes32 poolId_) external view returns (address[] memory poolAssets) {\\n    (IERC20[] memory tokens,,) = vault_.getPoolTokens(poolId_);\\n    uint bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\\n    uint len = tokens.length;\\n\\n    poolAssets = new address[](len - 1);\\n    uint k;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i == bptIndex) continue;\\n\\n      poolAssets[k] = ILinearPool(address(tokens[i])).getMainToken();\\n      ++k;\\n    }\\n  }\\n\\n  /// @notice Returns pool weights\\n  /// @return weights Array with weights, length = getPoolTokens.tokens - 1 (all assets except BPT)\\n  /// @return totalWeight Total sum of all items of {weights}\\n  function depositorPoolWeights(IBVault vault_, bytes32 poolId_) external view returns (\\n    uint[] memory weights,\\n    uint totalWeight\\n  ) {\\n    (IERC20[] memory tokens,uint[] memory balances,) = vault_.getPoolTokens(poolId_);\\n    uint len = tokens.length;\\n    uint bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\\n    weights = new uint[](len - 1);\\n    uint j;\\n    for (uint i; i < len; i = AppLib.uncheckedInc(i)) {\\n      if (i != bptIndex) {\\n        totalWeight += balances[i];\\n        weights[j] = balances[i];\\n        j = AppLib.uncheckedInc(j);\\n      }\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///             Depositor enter, exit logic\\n  /////////////////////////////////////////////////////////////////////\\n  /// @notice Deposit given amount to the pool.\\n  /// @param amountsDesired_ Amounts of assets on the balance of the depositor\\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\\n  ///         i.e. for \\\"Balancer Boosted Aave USD\\\" we have DAI, USDC, USDT\\n  /// @return amountsConsumedOut Amounts of assets deposited to balanceR pool\\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\\n  /// @return liquidityOut Total amount of liquidity added to balanceR pool in terms of pool-bpt tokens\\n  function depositorEnter(IBVault vault_, bytes32 poolId_, uint[] memory amountsDesired_) external returns (\\n    uint[] memory amountsConsumedOut,\\n    uint liquidityOut\\n  ) {\\n    DepositorLocal memory p;\\n\\n    // The implementation below assumes, that getPoolTokens returns the assets in following order:\\n    //    bb-am-dai, bb-am-usd, bb-am-usdc, bb-am-usdt\\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\\n    p.len = p.tokens.length;\\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\\n\\n    // temporary save current liquidity\\n    liquidityOut = IComposableStablePool(address(p.tokens[p.bptIndex])).balanceOf(address(this));\\n\\n    // Original amounts can have any values.\\n    // But we need amounts in such proportions that won't move the current balances\\n    {\\n      uint[] memory underlying = BalancerLogicLib.getTotalAssetAmounts(vault_, p.tokens, p.bptIndex);\\n      amountsConsumedOut = BalancerLogicLib.getAmountsToDeposit(amountsDesired_, p.tokens, p.balances, underlying, p.bptIndex);\\n    }\\n\\n    // we can create funds_ once and use it several times\\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\\n      sender : address(this),\\n      fromInternalBalance : false,\\n      recipient : payable(address(this)),\\n      toInternalBalance : false\\n    });\\n\\n    // swap all tokens XX => bb-am-XX\\n    // we need two arrays with same amounts: amountsToDeposit (with 0 for BB-AM-USD) and userDataAmounts (no BB-AM-USD)\\n    uint[] memory amountsToDeposit = new uint[](p.len);\\n    // no bpt\\n    uint[] memory userDataAmounts = new uint[](p.len - 1);\\n    uint k;\\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == p.bptIndex) continue;\\n      amountsToDeposit[i] = BalancerLogicLib.swap(\\n        vault_,\\n        ILinearPool(address(p.tokens[i])).getPoolId(),\\n        ILinearPool(address(p.tokens[i])).getMainToken(),\\n        address(p.tokens[i]),\\n        amountsConsumedOut[k],\\n        funds\\n      );\\n      userDataAmounts[k] = amountsToDeposit[i];\\n      AppLib.approveIfNeeded(address(p.tokens[i]), amountsToDeposit[i], address(vault_));\\n      ++k;\\n    }\\n\\n    // add liquidity to balancer\\n    vault_.joinPool(\\n      poolId_,\\n      address(this),\\n      address(this),\\n      IBVault.JoinPoolRequest({\\n        assets : asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\\n        maxAmountsIn : amountsToDeposit,\\n        userData : abi.encode(IBVault.JoinKind.EXACT_TOKENS_IN_FOR_BPT_OUT, userDataAmounts, 0),\\n        fromInternalBalance : false\\n      })\\n    );\\n\\n    uint liquidityAfter = IERC20(address(p.tokens[p.bptIndex])).balanceOf(address(this));\\n\\n    liquidityOut = liquidityAfter > liquidityOut\\n    ? liquidityAfter - liquidityOut\\n    : 0;\\n  }\\n\\n  /// @notice Withdraw given amount of LP-tokens from the pool.\\n  /// @param liquidityAmount_ Amount to withdraw in bpt\\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\\n  function depositorExit(IBVault vault_, bytes32 poolId_, uint liquidityAmount_) external returns (\\n    uint[] memory amountsOut\\n  ) {\\n    DepositorLocal memory p;\\n\\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\\n    p.len = p.tokens.length;\\n\\n    require(liquidityAmount_ <= p.tokens[p.bptIndex].balanceOf(address(this)), AppErrors.NOT_ENOUGH_BALANCE);\\n\\n    // BalancerR can spend a bit less amount of liquidity than {liquidityAmount_}\\n    // i.e. we if liquidityAmount_ = 2875841, we can have leftovers = 494 after exit\\n    vault_.exitPool(\\n      poolId_,\\n      address(this),\\n      payable(address(this)),\\n      IBVault.ExitPoolRequest({\\n        assets : asIAsset(p.tokens), // must have the same length and order as the array returned by `getPoolTokens`\\n        minAmountsOut : new uint[](p.len), // no limits\\n        userData : abi.encode(IBVault.ExitKindComposableStable.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT, liquidityAmount_),\\n        toInternalBalance : false\\n      })\\n    );\\n\\n    // now we have amBbXXX tokens; swap them to XXX assets\\n\\n    // we can create funds_ once and use it several times\\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\\n    sender : address(this),\\n    fromInternalBalance : false,\\n    recipient : payable(address(this)),\\n    toInternalBalance : false\\n    });\\n\\n    amountsOut = new uint[](p.len - 1);\\n    uint k;\\n    for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == p.bptIndex) continue;\\n      uint amountIn = p.tokens[i].balanceOf(address(this));\\n      if (amountIn != 0) {\\n        amountsOut[k] = swap(\\n          vault_,\\n          ILinearPool(address(p.tokens[i])).getPoolId(),\\n          address(p.tokens[i]),\\n          ILinearPool(address(p.tokens[i])).getMainToken(),\\n          amountIn,\\n          funds\\n        );\\n      }\\n      ++k;\\n    }\\n  }\\n\\n  /// @notice Withdraw all available amount of LP-tokens from the pool\\n  ///         BalanceR doesn't allow to withdraw exact amount, so it's allowed to leave dust amount on the balance\\n  /// @dev We make at most N attempts to withdraw (not more, each attempt takes a lot of gas).\\n  ///      Each attempt reduces available balance at ~1e4 times.\\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\\n  ///                    The order of assets is the same as in getPoolTokens, but there is no pool-bpt\\n  function depositorExitFull(IBVault vault_, bytes32 poolId_) external returns (\\n    uint[] memory amountsOut\\n  ) {\\n    DepositorLocal memory p;\\n\\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\\n    p.len = p.tokens.length;\\n    amountsOut = new uint[](p.len - 1);\\n\\n    // we can create funds_ once and use it several times\\n    IBVault.FundManagement memory funds = IBVault.FundManagement({\\n      sender : address(this),\\n      fromInternalBalance : false,\\n      recipient : payable(address(this)),\\n      toInternalBalance : false\\n    });\\n\\n    uint liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\\n    if (liquidityAmount > 0) {\\n      uint liquidityThreshold = 10 ** IERC20Metadata(address(p.tokens[p.bptIndex])).decimals() / 100;\\n\\n      // we can make at most N attempts to withdraw amounts from the balanceR pool\\n      for (uint i = 0; i < 2; ++i) {\\n        vault_.exitPool(\\n          poolId_,\\n          address(this),\\n          payable(address(this)),\\n          IBVault.ExitPoolRequest({\\n            assets : asIAsset(p.tokens),\\n            minAmountsOut : new uint[](p.len), // no limits\\n            userData : abi.encode(IBVault.ExitKindComposableStable.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT, liquidityAmount),\\n            toInternalBalance : false\\n          })\\n        );\\n        liquidityAmount = p.tokens[p.bptIndex].balanceOf(address(this));\\n        if (liquidityAmount < liquidityThreshold || i == 1) {\\n          break;\\n        }\\n        (, p.balances,) = vault_.getPoolTokens(poolId_);\\n      }\\n\\n      // now we have amBbXXX tokens; swap them to XXX assets\\n      uint k;\\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\\n        if (i == p.bptIndex) continue;\\n\\n        uint amountIn = p.tokens[i].balanceOf(address(this));\\n        if (amountIn != 0) {\\n          amountsOut[k] = swap(\\n            vault_,\\n            ILinearPool(address(p.tokens[i])).getPoolId(),\\n            address(p.tokens[i]),\\n            ILinearPool(address(p.tokens[i])).getMainToken(),\\n            amountIn,\\n            funds\\n          );\\n        }\\n        ++k;\\n      }\\n    }\\n\\n    uint depositorBalance = p.tokens[p.bptIndex].balanceOf(address(this));\\n    if (depositorBalance > 0) {\\n      uint k = 0;\\n      for (uint i; i < p.len; i = AppLib.uncheckedInc(i)) {\\n        if (i == p.bptIndex) continue;\\n\\n        // we assume here, that the depositorBalance is small\\n        // so we can directly swap it to any single asset without changing of pool resources proportions\\n        amountsOut[k] += _convertSmallBptRemainder(vault_, poolId_, p, funds, depositorBalance, i);\\n        break;\\n      }\\n    }\\n\\n    return amountsOut;\\n  }\\n\\n  /// @notice convert remained SMALL amount of bpt => am-bpt => main token of the am-bpt\\n  /// @return amountOut Received amount of am-bpt's main token\\n  function _convertSmallBptRemainder(\\n    IBVault vault_,\\n    bytes32 poolId_,\\n    DepositorLocal memory p,\\n    IBVault.FundManagement memory funds,\\n    uint bptAmountIn_,\\n    uint indexTargetAmBpt_\\n  ) internal returns (uint amountOut) {\\n    uint amountAmBpt = BalancerLogicLib.swap(\\n      vault_,\\n      poolId_,\\n      address(p.tokens[p.bptIndex]),\\n      address(p.tokens[indexTargetAmBpt_]),\\n      bptAmountIn_,\\n      funds\\n    );\\n    amountOut = swap(\\n      vault_,\\n      ILinearPool(address(p.tokens[indexTargetAmBpt_])).getPoolId(),\\n      address(p.tokens[indexTargetAmBpt_]),\\n      ILinearPool(address(p.tokens[indexTargetAmBpt_])).getMainToken(),\\n      amountAmBpt,\\n      funds\\n    );\\n  }\\n\\n  /// @notice Quotes output for given amount of LP-tokens from the pool.\\n  /// @return amountsOut Result amounts of underlying (DAI, USDC..) that will be received from BalanceR\\n  ///         The order of assets is the same as in getPoolTokens, but there is no pool-bpt\\n  function depositorQuoteExit(\\n    IBVault vault_,\\n    IBalancerHelper helper_,\\n    bytes32 poolId_,\\n    uint liquidityAmount_\\n  ) external returns (\\n    uint[] memory amountsOut\\n  ) {\\n    DepositorLocal memory p;\\n\\n    p.bptIndex = IComposableStablePool(getPoolAddress(poolId_)).getBptIndex();\\n    (p.tokens, p.balances,) = vault_.getPoolTokens(poolId_);\\n    p.len = p.tokens.length;\\n\\n    (, uint[] memory amountsBpt) = helper_.queryExit(\\n      poolId_,\\n      address(this),\\n      payable(address(this)),\\n      IBVault.ExitPoolRequest({\\n        assets : asIAsset(p.tokens),\\n        minAmountsOut : new uint[](p.len), // no limits\\n        userData : abi.encode(\\n          IBVault.ExitKindComposableStable.EXACT_BPT_IN_FOR_ALL_TOKENS_OUT,\\n          liquidityAmount_\\n        ),\\n        toInternalBalance : false\\n      })\\n    );\\n\\n    uint k;\\n    amountsOut = new uint[](p.len - 1);\\n    for (uint i = 0; i < p.len; i = AppLib.uncheckedInc(i)) {\\n      if (i == p.bptIndex) continue;\\n      ILinearPool linearPool = ILinearPool(address(p.tokens[i]));\\n      amountsOut[k] = _calcLinearMainOutPerBptIn(vault_, linearPool, amountsBpt[i]);\\n      ++k;\\n    }\\n  }\\n\\n  /// @notice Swap given {amountIn_} of {assetIn_} to {assetOut_} using the given BalanceR pool\\n  function swap(\\n    IBVault vault_,\\n    bytes32 poolId_,\\n    address assetIn_,\\n    address assetOut_,\\n    uint amountIn_,\\n    IBVault.FundManagement memory funds_\\n  ) internal returns (uint amountOut) {\\n    uint balanceBefore = IERC20(assetOut_).balanceOf(address(this));\\n\\n    IERC20(assetIn_).approve(address(vault_), amountIn_);\\n    vault_.swap(\\n      IBVault.SingleSwap({\\n    poolId : poolId_,\\n    kind : IBVault.SwapKind.GIVEN_IN,\\n    assetIn : IAsset(assetIn_),\\n    assetOut : IAsset(assetOut_),\\n    amount : amountIn_,\\n    userData : bytes(\\\"\\\")\\n    }),\\n      funds_,\\n      1,\\n      block.timestamp\\n    );\\n\\n    // we assume here, that the balance cannot be decreased\\n    amountOut = IERC20(assetOut_).balanceOf(address(this)) - balanceBefore;\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///             Rewards\\n  /////////////////////////////////////////////////////////////////////\\n\\n  function depositorClaimRewards(IBalancerGauge gauge_, address[] memory tokens_, address[] memory rewardTokens_) external returns (\\n    address[] memory tokensOut,\\n    uint[] memory amountsOut,\\n    uint[] memory depositorBalancesBefore\\n  ) {\\n    uint tokensLen = tokens_.length;\\n    uint rewardTokensLen = rewardTokens_.length;\\n\\n    tokensOut = new address[](rewardTokensLen);\\n    amountsOut = new uint[](rewardTokensLen);\\n    depositorBalancesBefore = new uint[](tokensLen);\\n\\n    for (uint i; i < tokensLen; i = AppLib.uncheckedInc(i)) {\\n      depositorBalancesBefore[i] = IERC20(tokens_[i]).balanceOf(address(this));\\n    }\\n\\n    for (uint i; i < rewardTokensLen; i = AppLib.uncheckedInc(i)) {\\n      tokensOut[i] = rewardTokens_[i];\\n\\n      // temporary store current reward balance\\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this));\\n    }\\n\\n    gauge_.claim_rewards();\\n\\n    for (uint i; i < rewardTokensLen; i = AppLib.uncheckedInc(i)) {\\n      amountsOut[i] = IERC20(rewardTokens_[i]).balanceOf(address(this)) - amountsOut[i];\\n    }\\n\\n    (tokensOut, amountsOut) = TokenAmountsLib.filterZeroAmounts(tokensOut, amountsOut);\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///             Utils\\n  /////////////////////////////////////////////////////////////////////\\n\\n  function createSpecificName(address pool_) external view returns (string memory) {\\n    return string(abi.encodePacked(\\\"Balancer \\\", IERC20Metadata(pool_).symbol()));\\n  }\\n\\n  /// @dev Returns the address of a Pool's contract.\\n  ///      Due to how Pool IDs are created, this is done with no storage accesses and costs little gas.\\n  function getPoolAddress(bytes32 id) internal pure returns (address) {\\n    // 12 byte logical shift left to remove the nonce and specialization setting. We don't need to mask,\\n    // since the logical shift already sets the upper bits to zero.\\n    return address(uint160(uint(id) >> (12 * 8)));\\n  }\\n\\n  /// @dev see balancer-labs, ERC20Helpers.sol\\n  function asIAsset(IERC20[] memory tokens) internal pure returns (IAsset[] memory assets) {\\n    // solhint-disable-next-line no-inline-assembly\\n    assembly {\\n      assets := tokens\\n    }\\n  }\\n\\n  /////////////////////////////////////////////////////////////////////\\n  ///             Linear pool quote swap math logic\\n  /////////////////////////////////////////////////////////////////////\\n\\n  /// @dev This logic is needed for hardworks in conditions of lack of funds in linear pools.\\n  ///      The lack of funds in linear pools is a typical situation caused by pool rebalancing after deposits from the strategy.\\n  ///      Main tokens are leaving linear pools to mint wrapped tokens.\\n  function _calcLinearMainOutPerBptIn(IBVault vault, ILinearPool pool, uint amount) internal view returns (uint) {\\n    (uint lowerTarget, uint upperTarget) = pool.getTargets();\\n    LinearPoolParams memory params = LinearPoolParams(pool.getSwapFeePercentage(), lowerTarget, upperTarget);\\n    (,uint[] memory balances,) = vault.getPoolTokens(pool.getPoolId());\\n    uint[] memory scalingFactors = pool.getScalingFactors();\\n    _upscaleArray(balances, scalingFactors);\\n    amount *= scalingFactors[0] / 1e18;\\n    uint mainIndex = pool.getMainIndex();\\n    uint mainBalance = balances[mainIndex];\\n    uint bptSupply = pool.totalSupply() - balances[0];\\n    uint previousNominalMain = _toNominal(mainBalance, params);\\n    uint invariant = previousNominalMain + balances[pool.getWrappedIndex()];\\n    uint deltaNominalMain = invariant * amount / bptSupply;\\n    uint afterNominalMain = previousNominalMain > deltaNominalMain ? previousNominalMain - deltaNominalMain : 0;\\n    uint newMainBalance = _fromNominal(afterNominalMain, params);\\n    return (mainBalance - newMainBalance) * 1e18 / scalingFactors[mainIndex];\\n  }\\n\\n  function _toNominal(uint real, LinearPoolParams memory params) internal pure returns (uint) {\\n    if (real < params.lowerTarget) {\\n      uint fees = (params.lowerTarget - real) * params.fee / 1e18;\\n      return real - fees;\\n    } else if (real <= params.upperTarget) {\\n      return real;\\n    } else {\\n      uint fees = (real - params.upperTarget) * params.fee / 1e18;\\n      return real - fees;\\n    }\\n  }\\n\\n  function _fromNominal(uint nominal, LinearPoolParams memory params) internal pure returns (uint) {\\n    if (nominal < params.lowerTarget) {\\n      return (nominal + (params.fee * params.lowerTarget / 1e18)) * 1e18 / (1e18 + params.fee);\\n    } else if (nominal <= params.upperTarget) {\\n      return nominal;\\n    } else {\\n      return (nominal - (params.fee * params.upperTarget / 1e18)) * 1e18/ (1e18 - params.fee);\\n    }\\n  }\\n\\n  function _upscaleArray(uint[] memory amounts, uint[] memory scalingFactors) internal pure {\\n    uint length = amounts.length;\\n    for (uint i; i < length; ++i) {\\n      amounts[i] = amounts[i] * scalingFactors[i] / 1e18;\\n    }\\n  }\\n}\\n\",\"keccak256\":\"0x3d43f0e01f035a772517fa73b02bac76529849c553565f070d1b768873dc8d7e\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b506200001c62000022565b620000e3565b600054610100900460ff16156200008f5760405162461bcd60e51b815260206004820152602760248201527f496e697469616c697a61626c653a20636f6e747261637420697320696e697469604482015266616c697a696e6760c81b606482015260840160405180910390fd5b60005460ff90811614620000e1576000805460ff191660ff9081179091556040519081527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b565b61547680620000f36000396000f3fe608060405234801561001057600080fd5b50600436106102ab5760003560e01c80636ffb4c8e11610172578063a3f4df7e116100d9578063c2b18aa011610092578063c2b18aa0146105f5578063cd4c81561461060a578063ceee861d1461061d578063d295ea7014610641578063de3d047c1461064a578063dee1f0e41461065d578063f77c47911461067057600080fd5b8063a3f4df7e14610566578063a6f19c84146105a2578063ab9e3eee146105b5578063b2457556146105bc578063b429afeb146105cf578063bd38837b146105e257600080fd5b8063877887821161012b57806387788782146104e757806387c7f770146104f05780638b4c770714610503578063936725ec1461052757806396b7b14e1461054b5780639d0bcca01461055e57600080fd5b80636ffb4c8e1461045857806371ee01751461046b57806373a50ef51461047457806378327438146104985780637cc96380146104b85780637efc77fa146104c057600080fd5b80634593144c1161021657806354679963116101cf57806354679963146103e75780635641ec03146103fc5780635cfc1a51146104045780636207a0cf1461040e57806363e27734146104325780636855f30e1461044557600080fd5b80634593144c1461038c5780634ad0b684146103945780634e71d92d1461039c5780634fa5d854146103a45780634fac6ccd146103c157806351e03fbe146103d457600080fd5b8063261efa1211610268578063261efa1214610331578063325a19f11461033a57806333c5b58e1461034257806338d52e0f1461034a5780633cd8045e146103705780633e0dc34e1461038357600080fd5b806301e1d114146102b057806301ffc9a7146102cb57806306552ff3146102ee5780630acd12c7146103035780630e30428d1461030b57806322b6f5e21461031e575b600080fd5b6102b8610678565b6040519081526020015b60405180910390f35b6102de6102d9366004614289565b610708565b60405190151581526020016102c2565b6103016102fc3660046142c8565b610733565b005b6102b861091b565b610301610319366004614324565b610a44565b61030161032c366004614350565b610ae8565b6102b860365481565b6102b8610b98565b6102b8610bcc565b600054610363906201000090046001600160a01b031681565b6040516102c29190614380565b600154610363906001600160a01b031681565b6102b860645481565b6102b8610c44565b6032546102b8565b610301610c74565b6103ac610cee565b604080519283526020830191909152016102c2565b6103016103cf366004614394565b610d53565b6102b86103e23660046143b1565b610e85565b6103ef611054565b6040516102c291906143ee565b6103016110e2565b600160ff1b6102b8565b6103ef60405180604001604052806005815260200164312e302e3160d81b81525081565b610301610440366004614421565b611182565b6103016104533660046143b1565b611209565b6103016104663660046143b1565b611281565b6102b860355481565b6103ef604051806040016040528060058152602001640322e332e360dc1b81525081565b6102b86104a6366004614394565b60346020526000908152604090205481565b6102b86112f9565b6103ef604051806040016040528060088152602001672130b630b731b2b960c11b81525081565b6102b860055481565b6102b86104fe366004614324565b611329565b6103ef604051806040016040528060058152602001640312e302e360dc1b81525081565b6103ef604051806040016040528060058152602001640332e302e360dc1b81525081565b610301610559366004614566565b6114b3565b610363611552565b6103ef6040518060400160405280601981526020017f42616c616e63657220426f6f737465642053747261746567790000000000000081525081565b606554610363906001600160a01b031681565b60016102de565b6102b86105ca366004614635565b611582565b6102de6105dd366004614394565b611638565b603354610363906001600160a01b031681565b6105fd61165d565b6040516102c2919061469e565b600454610363906001600160a01b031681565b6103ef604051806040016040528060058152602001640312e322e360dc1b81525081565b6102b860025481565b6103016106583660046143b1565b6117f2565b6102de61066b366004614394565b61186e565b6103636118f3565b600061068360325490565b6000546040516370a0823160e01b8152620100009091046001600160a01b0316906370a08231906106b8903090600401614380565b602060405180830381865afa1580156106d5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f991906146b1565b61070391906146e0565b905090565b60006001600160e01b0319821663f73147b360e01b148061072d575061072d82611923565b92915050565b600054610100900460ff16158080156107535750600054600160ff909116105b8061076d5750303b15801561076d575060005460ff166001145b6107d55760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b6000805460ff1916600117905580156107f8576000805461ff0019166101001790555b61080182611948565b61080c858585611a7d565b60405163923a3ca960e01b815273599d50a55Ae457d6d0014F71b32af2cAB05D5C969063923a3ca990610843908590600401614380565b600060405180830381865af4158015610860573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261088891908101906146f3565b6006906108959082614808565b507f13bdeb5b5bb760c04b92d93e56c576c6805359d41a13d3cca178aa7c8526b98460066040516108c691906148c7565b60405180910390a18015610914576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b60015460008054604051633e53813360e11b815291926001600160a01b03908116926201000090920416908390733BEB969c0cd273eA1d7a39137a757Cf1c474510a90637ca70266906109749086908690600401614952565b602060405180830381865af4158015610991573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b591906146b1565b905060008060006109c4611b1f565b925092509250733BEB969c0cd273eA1d7a39137a757Cf1c474510a639ad00ec2868686868b6040518663ffffffff1660e01b8152600401610a0995949392919061496c565b60006040518083038186803b158015610a2157600080fd5b505af4158015610a35573d6000803e3d6000fd5b50929998505050505050505050565b73c989b6183E5af088FD04DB1A3C93bE69c8Ff25E063142395ef610a666118f3565b6040516001600160e01b031960e084901b1681526001600160a01b03918216600482015290851660248201526044810184905260640160006040518083038186803b158015610ab457600080fd5b505af4158015610ac8573d6000803e3d6000fd5b5050506001600160a01b0390921660009081526034602052604090205550565b733BEB969c0cd273eA1d7a39137a757Cf1c474510a63b4339948610b0a6118f3565b6040516001600160e01b031960e084901b1681526001600160a01b03918216600482015260248101869052908416604482015260640160006040518083038186803b158015610b5857600080fd5b505af4158015610b6c573d6000803e3d6000fd5b505050600592909255600480546001600160a01b0319166001600160a01b039290921691909117905550565b6000610703610bc860017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b61499c565b5490565b6000733BEB969c0cd273eA1d7a39137a757Cf1c474510a63493f6edc610bf06118f3565b6040518263ffffffff1660e01b8152600401610c0c9190614380565b60006040518083038186803b158015610c2457600080fd5b505af4158015610c38573d6000803e3d6000fd5b50505050610703611b3a565b6000610703610bc860017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f161499c565b733BEB969c0cd273eA1d7a39137a757Cf1c474510a63d19cc38a610c966118f3565b6040518263ffffffff1660e01b8152600401610cb29190614380565b60006040518083038186803b158015610cca57600080fd5b505af4158015610cde573d6000803e3d6000fd5b50505050610cea611c07565b5050565b60015460408051808201909152600a81526914d08e8811195b9a595960b21b60208201526000918291906001600160a01b03163314610d405760405162461bcd60e51b81526004016107cc91906143ee565b50610d4b6001611cc3565b915091509091565b333014610da25760405162461bcd60e51b815260206004820152601b60248201527f496e637265617365207265766973696f6e20666f7262696464656e000000000060448201526064016107cc565b6000610dd2610bc860017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd61499c565b610ddd9060016146e0565b9050610e1181610e0e60017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd61499c565b55565b610e4082610e0e60017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e461499c565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c8910160405180910390a15050565b60015460008054604051633e53813360e11b815291926001600160a01b03908116926201000090920416908390733BEB969c0cd273eA1d7a39137a757Cf1c474510a90637ca7026690610ede9086908690600401614952565b602060405180830381865af4158015610efb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f1f91906146b1565b905080851115610fcb57600080610f3e610f39848961499c565b611df2565b604051631594b05b60e01b81529098509193509150733BEB969c0cd273eA1d7a39137a757Cf1c474510a90631594b05b90610f859087908790879087908c9060040161496c565b602060405180830381865af4158015610fa2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fc691906146b1565b925050505b6040516333bbb20360e11b815260048101869052602481018290526001600160a01b03808416604483015284166064820152733BEB969c0cd273eA1d7a39137a757Cf1c474510a9063677764069060840160006040518083038186803b15801561103457600080fd5b505af4158015611048573d6000803e3d6000fd5b50505050505050919050565b6006805461106190614786565b80601f016020809104026020016040519081016040528092919081815260200182805461108d90614786565b80156110da5780601f106110af576101008083540402835291602001916110da565b820191906000526020600020905b8154815290600101906020018083116110bd57829003601f168201915b505050505081565b6110ea611e23565b733BEB969c0cd273eA1d7a39137a757Cf1c474510a63bd02068261110c6118f3565b60005460015460405160e085901b6001600160e01b03191681526001600160a01b039384166004820152620100009092048316602483015291909116604482015260640160006040518083038186803b15801561116857600080fd5b505af415801561117c573d6000803e3d6000fd5b50505050565b733BEB969c0cd273eA1d7a39137a757Cf1c474510a63eae13e766111a46118f3565b84846040518463ffffffff1660e01b81526004016111c4939291906149af565b60006040518083038186803b1580156111dc57600080fd5b505af41580156111f0573d6000803e3d6000fd5b5060069250611204915083905084836149ef565b505050565b73c989b6183E5af088FD04DB1A3C93bE69c8Ff25E063a0113d4861122b6118f3565b836040518363ffffffff1660e01b8152600401611249929190614aae565b60006040518083038186803b15801561126157600080fd5b505af4158015611275573d6000803e3d6000fd5b50505060369190915550565b73c989b6183E5af088FD04DB1A3C93bE69c8Ff25E063d2c3cf256112a36118f3565b836040518363ffffffff1660e01b81526004016112c1929190614aae565b60006040518083038186803b1580156112d957600080fd5b505af41580156112ed573d6000803e3d6000fd5b50505060359190915550565b6000610703610bc860017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd61499c565b60335460408051808201909152600a81526914d08e8811195b9a595960b21b60208201526000916001600160a01b03169033821461137a5760405162461bcd60e51b81526004016107cc91906143ee565b5060008061138786611f2a565b91509150600061139687611f96565b9050858110156113fc5760006113aa612006565b905080156113fa5760006113bd826120b0565b90507faebc771af58936b05e89b0be7d3f9761480181abcd4a649fbdd01753fda1697082826040516113f0929190614af7565b60405180910390a1505b505b736b2ca816F59b3d66ded56A5aBE6f186Fa30650DA6399c1fde4878486886114226118f3565b60005460405160e088901b6001600160e01b031916815261145d9695949392916201000090046001600160a01b031690603490600401614b10565b602060405180830381865af415801561147a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061149e91906146b1565b94506114a8612378565b505050505092915050565b60335460408051808201909152600a81526914d08e8811195b9a595960b21b6020820152906001600160a01b031633146115005760405162461bcd60e51b81526004016107cc91906143ee565b508151815160408051808201909152600d81526c54532d3139206c656e6774687360981b60208201529082146115495760405162461bcd60e51b81526004016107cc91906143ee565b5061117c612378565b6000610703610bc860017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e461499c565b600154600080546040516001625acc3160e01b0319815291928392733BEB969c0cd273eA1d7a39137a757Cf1c474510a9263ffa533cf926115db926001600160a01b039182169262010000900490911690600401614952565b602060405180830381865af41580156115f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061161c91906146b1565b905080156116315761162e818461238c565b91505b5092915050565b60006116426118f3565b6001600160a01b0316826001600160a01b0316149050919050565b606060005b60088110156116f7576065546040516354c49fe960e01b8152600481018390526000916001600160a01b0316906354c49fe990602401602060405180830381865afa1580156116b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116d99190614b5f565b6001600160a01b0316146116f7576116f081614b7c565b9050611662565b806001600160401b0381111561170f5761170f614492565b604051908082528060200260200182016040528015611738578160200160208202803683370190505b50915060005b818110156117ed576065546040516354c49fe960e01b8152600481018390526001600160a01b03909116906354c49fe990602401602060405180830381865afa15801561178f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117b39190614b5f565b8382815181106117c5576117c5614b95565b6001600160a01b03909216602092830291909101909101526117e681614b7c565b905061173e565b505090565b733BEB969c0cd273eA1d7a39137a757Cf1c474510a630568a9d56118146118f3565b600254846040518463ffffffff1660e01b815260040161183693929190614bab565b60006040518083038186803b15801561184e57600080fd5b505af4158015611862573d6000803e3d6000fd5b50505060029190915550565b6000816001600160a01b03166118826118f3565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa1580156118bf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118e39190614b5f565b6001600160a01b03161492915050565b6000610703610bc860017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c361861499c565b60006001600160e01b0319821663c19fa56160e01b148061072d575061072d826123b3565b600054610100900460ff1661196f5760405162461bcd60e51b81526004016107cc90614bcc565b806001600160a01b03166338fff2d06040518163ffffffff1660e01b8152600401602060405180830381865afa1580156119ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119d191906146b1565b60645560405163a8ea687560e01b8152733b8ca519122cdd8efb272b0d3085453404b25bd09063a8ea687590611a0b908490600401614380565b602060405180830381865afa158015611a28573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a4c9190614b5f565b606580546001600160a01b0319166001600160a01b03928316908117909155611a7a918316906000196123e8565b50565b600054610100900460ff16611aa45760405162461bcd60e51b81526004016107cc90614bcc565b611aae8383612522565b603380546001600160a01b0319166001600160a01b038316179055611ad76064620186a0614c17565b6035557fe4166dfcf23bbd3e3f764a99dc8fa740554c03c82d6019b81cf265f396f6f2fe611b096064620186a0614c17565b60405190815260200160405180910390a1505050565b6000806000611b2f600019611df2565b925092509250909192565b6000806000611b5d600060029054906101000a90046001600160a01b0316611f2a565b91509150736b2ca816F59b3d66ded56A5aBE6f186Fa30650DA63c9bce69083611b8c611b87612006565b6126f6565b6033546040516001600160e01b031960e086901b168152611bbf93929187916001600160a01b0390911690600401614c39565b602060405180830381865af4158015611bdc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c0091906146b1565b9250505090565b6060806000806000611c17612821565b603354929550909350915073c989b6183E5af088FD04DB1A3C93bE69c8Ff25E09063e99de4da906001600160a01b0316611c4f6128c3565b8686866040518663ffffffff1660e01b8152600401611c72959493929190614c80565b600060405180830381865af4158015611c8f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611cb79190810190614d9d565b90969095509350505050565b600080600080611cd3600161295a565b915091506000611ce1612a13565b919650945090506000611d28878015611d145750620186a085603554611d079190614df6565b611d119190614c17565b83115b611d1f576000611d21565b825b8486612aa3565b91506000905080611d75611d3c85886146e0565b6000548590611d59906201000090046001600160a01b0316611f96565b603254611d6691906146e0565b611d7091906146e0565b612d6e565b915091506040805187815260208101879052908101899052606081018890526080810183905260a081018290527f3e9abbc366dbf9fe260e2640c06eefbedd7720cf986ae553374e46b804f4ff559060c00160405180910390a1611dd982896146e0565b611de382896146e0565b97509750505050505050915091565b6000806000806000611e04600161295a565b91509150611e13868284612d9e565b5091989097509095509350505050565b6000611e2d613479565b90507f768a28cb3459382a3d2173feb2dad0235f8de680b109872da581a3aa269fe5f481604051611e5e9190614e0d565b60405180910390a1600080548190611e84906201000090046001600160a01b0316611f2a565b6033549193509150736b2ca816F59b3d66ded56A5aBE6f186Fa30650DA906358b54f16906001600160a01b0316611ec1611ebc6118f3565b61348b565b846034600019886040518763ffffffff1660e01b8152600401611ee996959493929190614e20565b602060405180830381865af4158015611f06573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061154991906146b1565b60606000611f366128c3565b9150611f4282846134ef565b90506000198114156040518060400160405280600f81526020016e53423a2057726f6e672076616c756560881b81525090611f905760405162461bcd60e51b81526004016107cc91906143ee565b50915091565b6040516370a0823160e01b81526000906001600160a01b038316906370a0823190611fc5903090600401614380565b602060405180830381865afa158015611fe2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072d91906146b1565b600061201460645460601c90565b6001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161203f9190614380565b602060405180830381865afa15801561205c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061208091906146b1565b6065546040516370a0823160e01b81526001600160a01b03909116906370a08231906106b8903090600401614380565b6064546065546040516370a0823160e01b8152606092916001600160a01b03169082841c9060009082906370a08231906120ee903090600401614380565b602060405180830381865afa15801561210b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061212f91906146b1565b90506000836001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161215f9190614380565b602060405180830381865afa15801561217c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121a091906146b1565b905060008288116121b25760006121bc565b6121bc838961499c565b905080156121cf57818111156121cf5750805b801561223057604051632e1a7d4d60e01b8152600481018290526001600160a01b03861690632e1a7d4d90602401600060405180830381600087803b15801561221757600080fd5b505af115801561222b573d6000803e3d6000fd5b505050505b61223a82846146e0565b8810156122da5760405163209f6ae760e01b815273599d50a55Ae457d6d0014F71b32af2cAB05D5C969063209f6ae7906122909073ba12222222228d8ba445958a75a0704d566bf2c8908a908690600401614bab565b600060405180830381865af41580156122ad573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526122d59190810190614e5d565b61236c565b604051634b4c46fd60e01b815273599d50a55Ae457d6d0014F71b32af2cAB05D5C9690634b4c46fd906123279073ba12222222228d8ba445958a75a0704d566bf2c8908a90600401614aae565b600060405180830381865af4158015612344573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261236c9190810190614e5d565b98975050505050505050565b6000612382611b3a565b6032819055919050565b600080600061239a8461295a565b915091506123a9858284612aa3565b5095945050505050565b60006001600160e01b0319821663b7b79fa960e01b148061072d57506301ffc9a760e01b6001600160e01b031983161461072d565b8015806124615750604051636eb1769f60e11b81526001600160a01b0384169063dd62ed3e9061241e9030908690600401614952565b602060405180830381865afa15801561243b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061245f91906146b1565b155b6124cc5760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084016107cc565b6112048363095ea7b360e01b84846040516024016124eb929190614aae565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b03199093169290921790915261354d565b600054610100900460ff166125495760405162461bcd60e51b81526004016107cc90614bcc565b612573817fd2de0374d4479f33e63ae5ed6ca772a10463dd883a90c612050b51fab619640061361f565b61257c82613675565b60405163b429afeb60e01b81526001600160a01b0382169063b429afeb906125a8908590600401614380565b602060405180830381865afa1580156125c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125e99190614e91565b6040518060400160405280600f81526020016e53423a2057726f6e672076616c756560881b8152509061262f5760405162461bcd60e51b81526004016107cc91906143ee565b50806001600160a01b03166338d52e0f6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561266e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126929190614b5f565b600080546001600160a01b03928316620100000262010000600160b01b031990911617905560018054929091166001600160a01b031992831617905560048054909116739cc199d4353b5fb3e6c8eebc99f5139e0d8ea06b17905550612710600555565b60606000612702612006565b90508060000361275d576127146128c3565b516001600160401b0381111561272c5761272c614492565b604051908082528060200260200182016040528015612755578160200160208202803683370190505b509392505050565b6064805460405163f91294e960e01b815273ba12222222228d8ba445958a75a0704d566bf2c8600482015273239e55f427d44c3cc793f49bfb507ebe76638a2b6024820152604481019190915290810184905273599d50a55Ae457d6d0014F71b32af2cAB05D5C969063f91294e990608401600060405180830381865af41580156127ec573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526128149190810190614e5d565b9392505050565b50919050565b6065546060908190819073599d50a55Ae457d6d0014F71b32af2cAB05D5C9690633a7e535c906001600160a01b03166128586128c3565b61286061165d565b6040518463ffffffff1660e01b815260040161287e93929190614eae565b600060405180830381865af415801561289b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611b2f9190810190614eee565b606454604051633db1bdf160e11b815260609173599d50a55Ae457d6d0014F71b32af2cAB05D5C9691637b637be2916129159173ba12222222228d8ba445958a75a0704d566bf2c89190600401614aae565b600060405180830381865af4158015612932573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107039190810190614f75565b6000808215612a075760325461296e612378565b600154604051636e5b9cc760e11b815260048101849052602481018390526001600160a01b039091166044820152909350736b2ca816F59b3d66ded56A5aBE6f186Fa30650DA9063dcb7398e90606401602060405180830381865af41580156129db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129ff91906146b1565b915050915091565b50506032546000915091565b600080600080612a37600060029054906101000a90046001600160a01b0316611f96565b9050600080612a44611c07565b91509150612a52828261388e565b600054612a6d906201000090046001600160a01b0316611f96565b9350600080612a7c8587612d6e565b9092509050612a8b82896146e0565b612a9582896146e0565b975097505050505050909192565b6000805481906201000090046001600160a01b031681858711612ac7576000612ad1565b612ad1868861499c565b9050620186a085603554612ae59190614df6565b612aef9190614c17565b811115612c95578515612b9e5760015473c989b6183E5af088FD04DB1A3C93bE69c8Ff25E09063aac2718a90849089906001600160a01b0316612b3183611f96565b612b3b908b6146e0565b6040518563ffffffff1660e01b8152600401612b5a9493929190614fa9565b602060405180830381865af4158015612b77573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b9b91906146b1565b92505b6000612ba983611f96565b9050600080612bcc600060029054906101000a90046001600160a01b0316611f2a565b6033549193509150600090612bec906001600160a01b031686858561392e565b90506000612bf982613b56565b5090507f59400c8c523464b521238ea8f50e923f2bc64663557e6afec92a97f7efe92d058282604051612c2d929190614fd3565b60405180910390a16000612c3f612378565b90506000612c4c89611f96565b9050612c58878d6146e0565b612c6282846146e0565b1015612c8957612c7281836146e0565b612c7c888e6146e0565b612c86919061499c565b9a505b50505050505050612d64565b8515612d64576000612ca683611f96565b905086811015612cc957612cbc60008888612d9e565b9097509550612d62915050565b60015473c989b6183E5af088FD04DB1A3C93bE69c8Ff25E09063aac2718a9085908a906001600160a01b0316612cff868c6146e0565b6040518563ffffffff1660e01b8152600401612d1e9493929190614fa9565b602060405180830381865af4158015612d3b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d5f91906146b1565b93505b505b5050935093915050565b60008083831115612d8a57612d83848461499c565b9150612d97565b612d94838561499c565b90505b9250929050565b600080600080612e3f604051806102200160405280600015158152602001606081526020016000815260200160008152602001600081526020016000815260200160608152602001600081526020016060815260200160008152602001600081526020016060815260200160006001600160a01b0316815260200160008152602001600081526020016060815260200160006001600160a01b031681525090565b60001988148082526000935080612e5e5750612e5b87896146e0565b15155b8015612e6957508515155b1561346057612e766128c3565b61016082018190526000546001600160a01b036201000090910481166101808401819052603354909116610200840152612eb091906134ef565b6101a0820152610180810151612ec590611f96565b6101c0820152612ed3613cce565b6020820152612ee0613d65565b6040820152612eed612006565b6060820152610200810151610180820151604051637a55caf360e01b8152736b2ca816F59b3d66ded56A5aBE6f186Fa30650DA92637a55caf392612f3392600401614952565b602060405180830381865af4158015612f50573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f7491906146b1565b60a0820152805173c989b6183E5af088FD04DB1A3C93bE69c8Ff25E09063ec0cc4fd90612faa57612fa5898b6146e0565b612fad565b60005b30846101600151856101a001518661020001518c88606001516040518863ffffffff1660e01b8152600401612fe89796959493929190615001565b600060405180830381865af4158015613005573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261302d9190810190615050565b60c0830152608082018190521561316b5761304b81608001516120b0565b6101e0820152613059612006565b8160600151613068919061499c565b608082018190526101e08201516040517faebc771af58936b05e89b0be7d3f9761480181abcd4a649fbdd01753fda16970926130a5929091614af7565b60405180910390a1736b2ca816F59b3d66ded56A5aBE6f186Fa30650DA637a9a23e5826102000151836101600151846101a001518560200151866080015187604001518860c00151896101e001516040518963ffffffff1660e01b815260040161311698979695949392919061508c565b600060405180830381865af4158015613133573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261315b919081019061510e565b60c0830152610100820152613207565b6102008101516101608201516101a083015160c0840151604051636138ea8560e01b8152736b2ca816F59b3d66ded56A5aBE6f186Fa30650DA94636138ea85946131bb9491939092600401615144565b600060405180830381865af41580156131d8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526132009190810190614e5d565b6101008201525b736b2ca816F59b3d66ded56A5aBE6f186Fa30650DA63f1f2b573826101600151836101a001518460c00151856102000151613243611ebc6118f3565b875161325a578d8f61325591906146e0565b61325c565b8e5b88610100015160346040518963ffffffff1660e01b8152600401613287989796959493929190615180565b602060405180830381865af41580156132a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132c891906146b1565b8160e0018181516132d991906146e0565b9052508615613388576101808101516001546101c083015173c989b6183E5af088FD04DB1A3C93bE69c8Ff25E09263aac2718a9290918b916001600160a01b031690613325908c6146e0565b6040518563ffffffff1660e01b81526004016133449493929190614fa9565b602060405180830381865af4158015613361573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061338591906146b1565b91505b613390612378565b6101208201526101808101516133a590611f96565b6101408201526101c08101516133bb90876146e0565b878261014001518361012001516133d291906146e0565b6133dc91906146e0565b101561342a57868161014001518261012001516133f991906146e0565b61340391906146e0565b6101c082015161341390886146e0565b61341d919061499c565b61342790846146e0565b92505b670de0b6b3a76400008160a001518260e001516134479190614df6565b6134519190614c17565b8160a001519450945050613470565b6000806000809450945094509450505b93509350935093565b6060610703613486612006565b6120b0565b6000816001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156134cb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072d9190614b5f565b8151600090815b8181101561354157836001600160a01b031685828151811061351a5761351a614b95565b60200260200101516001600160a01b03160361353957915061072d9050565b6001016134f6565b50600019949350505050565b60006135a2826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316613dd49092919063ffffffff16565b80519091501561120457808060200190518101906135c09190614e91565b6112045760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016107cc565b6136298282613deb565b610cea5760405162461bcd60e51b815260206004820152601a60248201527f496e74657266616365206973206e6f7420737570706f7274656400000000000060448201526064016107cc565b600054610100900460ff1661369c5760405162461bcd60e51b81526004016107cc90614bcc565b6001600160a01b0381166136e45760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b60448201526064016107cc565b61370e817f4c2403fdcb3cff9b705d96bf0705858e3390412670a62c8bcba611ca7e20ab8661361f565b60006001600160a01b0316816001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015613757573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061377b9190614b5f565b6001600160a01b0316036137c35760405162461bcd60e51b815260206004820152600f60248201526e5a65726f20676f7665726e616e636560881b60448201526064016107cc565b6137f281610e0e60017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c361861499c565b61382142610e0e60017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b61499c565b61385043610e0e60017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f161499c565b7f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe23671342681424360405161388393929190614bab565b60405180910390a150565b815180156112045760006138a28484613ec9565b905073c989b6183E5af088FD04DB1A3C93bE69c8Ff25E063acf741a36138c66118f3565b6001546040516001600160e01b031960e085901b1681526138f892916001600160a01b031690899087906004016151f6565b60006040518083038186803b15801561391057600080fd5b505af4158015613924573d6000803e3d6000fd5b5050505050505050565b606060008061393b614087565b9150915073c989b6183E5af088FD04DB1A3C93bE69c8Ff25E06359d0ede687878585898d6001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa15801561399c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139c09190614b5f565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156139fd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a219190614b5f565b6040518763ffffffff1660e01b8152600401613a4296959493929190615234565b600060405180830381865af4158015613a5f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052613a879190810190614e5d565b9250736b2ca816F59b3d66ded56A5aBE6f186Fa30650DA631a2221c788878787603460008c8c81518110613abd57613abd614b95565b60200260200101516001600160a01b03166001600160a01b03168152602001908152602001600020546040518663ffffffff1660e01b8152600401613b06959493929190615287565b600060405180830381865af4158015613b23573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052613b4b9190810190614e5d565b979650505050505050565b60645460405163423511a360e01b815260609160009181841c9073599d50a55Ae457d6d0014F71b32af2cAB05D5C969063423511a390613bb29073ba12222222228d8ba445958a75a0704d566bf2c89086908a906004016152d6565b600060405180830381865af4158015613bcf573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052613bf791908101906152fd565b6065546040516370a0823160e01b81529296509094506001600160a01b039081169163b6b55f25918416906370a0823190613c36903090600401614380565b602060405180830381865afa158015613c53573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613c7791906146b1565b6040518263ffffffff1660e01b8152600401613c9591815260200190565b600060405180830381600087803b158015613caf57600080fd5b505af1158015613cc3573d6000803e3d6000fd5b505050505050915091565b60645460405163464a5ef760e01b815260609173599d50a55Ae457d6d0014F71b32af2cAB05D5C969163464a5ef791613d209173ba12222222228d8ba445958a75a0704d566bf2c89190600401614aae565b600060405180830381865af4158015613d3d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107039190810190614e5d565b6000613d7360645460601c90565b6001600160a01b031663876f303b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613db0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070391906146b1565b6060613de38484600085614120565b949350505050565b60006001600160a01b038316613e325760405162461bcd60e51b815260206004820152600c60248201526b5a65726f206164647265737360a01b60448201526064016107cc565b823b6000819003613e4757600091505061072d565b6040516301ffc9a760e01b81526001600160e01b0319841660048201526001600160a01b038516906301ffc9a790602401602060405180830381865afa925050508015613eb1575060408051601f3d908101601f19168201909252613eae91810190614e91565b60015b15613ebf57915061072d9050565b5060009392505050565b60008054603354600254606093620100009093046001600160a01b039081169392736b2ca816F59b3d66ded56A5aBE6f186Fa30650DA9263ef50284f92909116908590613f146128c3565b613f1f611ebc6118f3565b60348c8c6005546040518a63ffffffff1660e01b8152600401613f4a99989796959493929190615343565b600060405180830381865af4158015613f67573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052613f8f91908101906152fd565b60015460048054603654604051631248faf160e21b81526001600160a01b03808a16948201949094526024810186905293831660448501529116606483015260848201529194509150600090819073c989b6183E5af088FD04DB1A3C93bE69c8Ff25E090634923ebc49060a4016040805180830381865af4158015614018573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061403c91906153c7565b915091507f4c300a656bfa0935e36cd55e92634bc20b2b7e0a0ebf424a2a25bfaac3a01e768786848460405161407594939291906153eb565b60405180910390a15050505092915050565b60645460405163552ad6a160e11b815260609160009173599d50a55Ae457d6d0014F71b32af2cAB05D5C969163aa55ad42916140db9173ba12222222228d8ba445958a75a0704d566bf2c891600401614aae565b600060405180830381865af41580156140f8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d4b91908101906152fd565b6060824710156141815760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084016107cc565b600080866001600160a01b0316858760405161419d9190615424565b60006040518083038185875af1925050503d80600081146141da576040519150601f19603f3d011682016040523d82523d6000602084013e6141df565b606091505b5091509150613b4b878383876060831561425a578251600003614253576001600160a01b0385163b6142535760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016107cc565b5081613de3565b613de3838381511561426f5781518083602001fd5b8060405162461bcd60e51b81526004016107cc91906143ee565b60006020828403121561429b57600080fd5b81356001600160e01b03198116811461281457600080fd5b6001600160a01b0381168114611a7a57600080fd5b600080600080608085870312156142de57600080fd5b84356142e9816142b3565b935060208501356142f9816142b3565b92506040850135614309816142b3565b91506060850135614319816142b3565b939692955090935050565b6000806040838503121561433757600080fd5b8235614342816142b3565b946020939093013593505050565b6000806040838503121561436357600080fd5b823591506020830135614375816142b3565b809150509250929050565b6001600160a01b0391909116815260200190565b6000602082840312156143a657600080fd5b8135612814816142b3565b6000602082840312156143c357600080fd5b5035919050565b60005b838110156143e55781810151838201526020016143cd565b50506000910152565b602081526000825180602084015261440d8160408501602087016143ca565b601f01601f19169190910160400192915050565b6000806020838503121561443457600080fd5b82356001600160401b038082111561444b57600080fd5b818501915085601f83011261445f57600080fd5b81358181111561446e57600080fd5b86602082850101111561448057600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156144d0576144d0614492565b604052919050565b60006001600160401b038211156144f1576144f1614492565b5060051b60200190565b600082601f83011261450c57600080fd5b8135602061452161451c836144d8565b6144a8565b82815260059290921b8401810191818101908684111561454057600080fd5b8286015b8481101561455b5780358352918301918301614544565b509695505050505050565b6000806040838503121561457957600080fd5b82356001600160401b038082111561459057600080fd5b818501915085601f8301126145a457600080fd5b813560206145b461451c836144d8565b82815260059290921b840181019181810190898411156145d357600080fd5b948201945b838610156145fa5785356145eb816142b3565b825294820194908201906145d8565b9650508601359250508082111561461057600080fd5b5061461d858286016144fb565b9150509250929050565b8015158114611a7a57600080fd5b6000806040838503121561464857600080fd5b82359150602083013561437581614627565b600081518084526020808501945080840160005b838110156146935781516001600160a01b03168752958201959082019060010161466e565b509495945050505050565b602081526000612814602083018461465a565b6000602082840312156146c357600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561072d5761072d6146ca565b60006020828403121561470557600080fd5b81516001600160401b038082111561471c57600080fd5b818401915084601f83011261473057600080fd5b81518181111561474257614742614492565b614755601f8201601f19166020016144a8565b915080825285602082850101111561476c57600080fd5b61477d8160208401602086016143ca565b50949350505050565b600181811c9082168061479a57607f821691505b60208210810361281b57634e487b7160e01b600052602260045260246000fd5b601f82111561120457600081815260208120601f850160051c810160208610156147e15750805b601f850160051c820191505b81811015614800578281556001016147ed565b505050505050565b81516001600160401b0381111561482157614821614492565b6148358161482f8454614786565b846147ba565b602080601f83116001811461486a57600084156148525750858301515b600019600386901b1c1916600185901b178555614800565b600085815260208120601f198616915b828110156148995788860151825594840194600190910190840161487a565b50858210156148b75787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60006020808352600084546148db81614786565b808487015260406001808416600081146148fc576001811461491657614944565b60ff1985168984015283151560051b890183019550614944565b896000528660002060005b8581101561493c5781548b8201860152908301908801614921565b8a0184019650505b509398975050505050505050565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039586168152602081019490945260408401929092526060830152909116608082015260a00190565b8181038181111561072d5761072d6146ca565b6001600160a01b03841681526040602082018190528101829052818360608301376000818301606090810191909152601f909201601f1916010192915050565b6001600160401b03831115614a0657614a06614492565b614a1a83614a148354614786565b836147ba565b6000601f841160018114614a4e5760008515614a365750838201355b600019600387901b1c1916600186901b178355610914565b600083815260209020601f19861690835b82811015614a7f5786850135825560209485019460019092019101614a5f565b5086821015614a9c5760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b6001600160a01b03929092168252602082015260400190565b600081518084526020808501945080840160005b8381101561469357815187529582019590820190600101614adb565b828152604060208201526000613de36040830184614ac7565b87815286602082015260e060408201526000614b2f60e083018861465a565b6001600160a01b0396871660608401529486166080830152509190931660a082015260c001919091529392505050565b600060208284031215614b7157600080fd5b8151612814816142b3565b600060018201614b8e57614b8e6146ca565b5060010190565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b039390931683526020830191909152604082015260600190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b600082614c3457634e487b7160e01b600052601260045260246000fd5b500490565b608081526000614c4c608083018761465a565b8281036020840152614c5e8187614ac7565b604084019590955250506001600160a01b039190911660609091015292915050565b6001600160a01b038616815260a060208201819052600090614ca49083018761465a565b8281036040840152614cb6818761465a565b90508281036060840152614cca8186614ac7565b9050828103608084015261236c8185614ac7565b600082601f830112614cef57600080fd5b81516020614cff61451c836144d8565b82815260059290921b84018101918181019086841115614d1e57600080fd5b8286015b8481101561455b578051614d35816142b3565b8352918301918301614d22565b600082601f830112614d5357600080fd5b81516020614d6361451c836144d8565b82815260059290921b84018101918181019086841115614d8257600080fd5b8286015b8481101561455b5780518352918301918301614d86565b60008060408385031215614db057600080fd5b82516001600160401b0380821115614dc757600080fd5b614dd386838701614cde565b93506020850151915080821115614de957600080fd5b5061461d85828601614d42565b808202811582820484141761072d5761072d6146ca565b6020815260006128146020830184614ac7565b600060018060a01b03808916835280881660208401525085604083015284606083015283608083015260c060a083015261236c60c083018461465a565b600060208284031215614e6f57600080fd5b81516001600160401b03811115614e8557600080fd5b61162e84828501614d42565b600060208284031215614ea357600080fd5b815161281481614627565b6001600160a01b0384168152606060208201819052600090614ed29083018561465a565b8281036040840152614ee4818561465a565b9695505050505050565b600080600060608486031215614f0357600080fd5b83516001600160401b0380821115614f1a57600080fd5b614f2687838801614cde565b94506020860151915080821115614f3c57600080fd5b614f4887838801614d42565b93506040860151915080821115614f5e57600080fd5b50614f6b86828701614d42565b9150509250925092565b600060208284031215614f8757600080fd5b81516001600160401b03811115614f9d57600080fd5b61162e84828501614cde565b6001600160a01b039485168152602081019390935292166040820152606081019190915260800190565b604081526000614fe66040830185614ac7565b8281036020840152614ff88185614ac7565b95945050505050565b878152600060018060a01b03808916602084015260e0604084015261502960e084018961465a565b606084019790975294909416608082015260a081019290925260c090910152509392505050565b6000806040838503121561506357600080fd5b8251915060208301516001600160401b0381111561508057600080fd5b61461d85828601614d42565b6001600160a01b0389168152610100602082018190526000906150b18382018b61465a565b905088604084015282810360608401526150cb8189614ac7565b90508660808401528560a084015282810360c08401526150eb8186614ac7565b905082810360e08401526150ff8185614ac7565b9b9a5050505050505050505050565b6000806040838503121561512157600080fd5b82516001600160401b038082111561513857600080fd5b614dd386838701614d42565b6001600160a01b03851681526080602082018190526000906151689083018661465a565b8460408401528281036060840152613b4b8185614ac7565b60006101008083526151948184018c61465a565b905089602084015282810360408401526151ae818a614ac7565b6001600160a01b0389811660608601528816608085015260a0840187905283810360c085015290506151e08186614ac7565b9150508260e08301529998505050505050505050565b6001600160a01b038581168252841660208201526080604082018190526000906152229083018561465a565b8281036060840152613b4b8185614ac7565b86815260c06020820152600061524d60c083018861465a565b828103604084015261525f8188614ac7565b6060840196909652505060808101929092526001600160a01b031660a0909101529392505050565b6001600160a01b038616815260a0602082018190526000906152ab9083018761465a565b85604084015282810360608401526152c38186614ac7565b9150508260808301529695505050505050565b60018060a01b0384168152826020820152606060408201526000614ff86060830184614ac7565b6000806040838503121561531057600080fd5b82516001600160401b0381111561532657600080fd5b61533285828601614d42565b925050602083015190509250929050565b6001600160a01b038a81168252898116602083015260408201899052610120606083018190526000916153788483018b61465a565b91508089166080850152508660a084015282810360c084015261539b818761465a565b905082810360e08401526153af8186614ac7565b915050826101008301529a9950505050505050505050565b600080604083850312156153da57600080fd5b505080516020909101519092909150565b6080815260006153fe608083018761465a565b82810360208401526154108187614ac7565b604084019590955250506060015292915050565b600082516154368184602087016143ca565b919091019291505056fea2646970667358221220fcc119c3fd2c6dbc71e5638429e85838e44225697725e8432e92e553174ae37a64736f6c63430008110033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106102ab5760003560e01c80636ffb4c8e11610172578063a3f4df7e116100d9578063c2b18aa011610092578063c2b18aa0146105f5578063cd4c81561461060a578063ceee861d1461061d578063d295ea7014610641578063de3d047c1461064a578063dee1f0e41461065d578063f77c47911461067057600080fd5b8063a3f4df7e14610566578063a6f19c84146105a2578063ab9e3eee146105b5578063b2457556146105bc578063b429afeb146105cf578063bd38837b146105e257600080fd5b8063877887821161012b57806387788782146104e757806387c7f770146104f05780638b4c770714610503578063936725ec1461052757806396b7b14e1461054b5780639d0bcca01461055e57600080fd5b80636ffb4c8e1461045857806371ee01751461046b57806373a50ef51461047457806378327438146104985780637cc96380146104b85780637efc77fa146104c057600080fd5b80634593144c1161021657806354679963116101cf57806354679963146103e75780635641ec03146103fc5780635cfc1a51146104045780636207a0cf1461040e57806363e27734146104325780636855f30e1461044557600080fd5b80634593144c1461038c5780634ad0b684146103945780634e71d92d1461039c5780634fa5d854146103a45780634fac6ccd146103c157806351e03fbe146103d457600080fd5b8063261efa1211610268578063261efa1214610331578063325a19f11461033a57806333c5b58e1461034257806338d52e0f1461034a5780633cd8045e146103705780633e0dc34e1461038357600080fd5b806301e1d114146102b057806301ffc9a7146102cb57806306552ff3146102ee5780630acd12c7146103035780630e30428d1461030b57806322b6f5e21461031e575b600080fd5b6102b8610678565b6040519081526020015b60405180910390f35b6102de6102d9366004614289565b610708565b60405190151581526020016102c2565b6103016102fc3660046142c8565b610733565b005b6102b861091b565b610301610319366004614324565b610a44565b61030161032c366004614350565b610ae8565b6102b860365481565b6102b8610b98565b6102b8610bcc565b600054610363906201000090046001600160a01b031681565b6040516102c29190614380565b600154610363906001600160a01b031681565b6102b860645481565b6102b8610c44565b6032546102b8565b610301610c74565b6103ac610cee565b604080519283526020830191909152016102c2565b6103016103cf366004614394565b610d53565b6102b86103e23660046143b1565b610e85565b6103ef611054565b6040516102c291906143ee565b6103016110e2565b600160ff1b6102b8565b6103ef60405180604001604052806005815260200164312e302e3160d81b81525081565b610301610440366004614421565b611182565b6103016104533660046143b1565b611209565b6103016104663660046143b1565b611281565b6102b860355481565b6103ef604051806040016040528060058152602001640322e332e360dc1b81525081565b6102b86104a6366004614394565b60346020526000908152604090205481565b6102b86112f9565b6103ef604051806040016040528060088152602001672130b630b731b2b960c11b81525081565b6102b860055481565b6102b86104fe366004614324565b611329565b6103ef604051806040016040528060058152602001640312e302e360dc1b81525081565b6103ef604051806040016040528060058152602001640332e302e360dc1b81525081565b610301610559366004614566565b6114b3565b610363611552565b6103ef6040518060400160405280601981526020017f42616c616e63657220426f6f737465642053747261746567790000000000000081525081565b606554610363906001600160a01b031681565b60016102de565b6102b86105ca366004614635565b611582565b6102de6105dd366004614394565b611638565b603354610363906001600160a01b031681565b6105fd61165d565b6040516102c2919061469e565b600454610363906001600160a01b031681565b6103ef604051806040016040528060058152602001640312e322e360dc1b81525081565b6102b860025481565b6103016106583660046143b1565b6117f2565b6102de61066b366004614394565b61186e565b6103636118f3565b600061068360325490565b6000546040516370a0823160e01b8152620100009091046001600160a01b0316906370a08231906106b8903090600401614380565b602060405180830381865afa1580156106d5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906106f991906146b1565b61070391906146e0565b905090565b60006001600160e01b0319821663f73147b360e01b148061072d575061072d82611923565b92915050565b600054610100900460ff16158080156107535750600054600160ff909116105b8061076d5750303b15801561076d575060005460ff166001145b6107d55760405162461bcd60e51b815260206004820152602e60248201527f496e697469616c697a61626c653a20636f6e747261637420697320616c72656160448201526d191e481a5b9a5d1a585b1a5e995960921b60648201526084015b60405180910390fd5b6000805460ff1916600117905580156107f8576000805461ff0019166101001790555b61080182611948565b61080c858585611a7d565b60405163923a3ca960e01b815273__$e2d6e18942209f9a9d99e72afc74bc8af1$__9063923a3ca990610843908590600401614380565b600060405180830381865af4158015610860573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261088891908101906146f3565b6006906108959082614808565b507f13bdeb5b5bb760c04b92d93e56c576c6805359d41a13d3cca178aa7c8526b98460066040516108c691906148c7565b60405180910390a18015610914576000805461ff0019169055604051600181527f7f26b83ff96e1f2b6a682f133852f6798a09c465da95921460cefb38474024989060200160405180910390a15b5050505050565b60015460008054604051633e53813360e11b815291926001600160a01b0390811692620100009092041690839073__$ec217c54da363a68ad871e6868efec481c$__90637ca70266906109749086908690600401614952565b602060405180830381865af4158015610991573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109b591906146b1565b905060008060006109c4611b1f565b92509250925073__$ec217c54da363a68ad871e6868efec481c$__639ad00ec2868686868b6040518663ffffffff1660e01b8152600401610a0995949392919061496c565b60006040518083038186803b158015610a2157600080fd5b505af4158015610a35573d6000803e3d6000fd5b50929998505050505050505050565b73__$8f1afe7577f9ab973017c74eca19b86f3c$__63142395ef610a666118f3565b6040516001600160e01b031960e084901b1681526001600160a01b03918216600482015290851660248201526044810184905260640160006040518083038186803b158015610ab457600080fd5b505af4158015610ac8573d6000803e3d6000fd5b5050506001600160a01b0390921660009081526034602052604090205550565b73__$ec217c54da363a68ad871e6868efec481c$__63b4339948610b0a6118f3565b6040516001600160e01b031960e084901b1681526001600160a01b03918216600482015260248101869052908416604482015260640160006040518083038186803b158015610b5857600080fd5b505af4158015610b6c573d6000803e3d6000fd5b505050600592909255600480546001600160a01b0319166001600160a01b039290921691909117905550565b6000610703610bc860017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b61499c565b5490565b600073__$ec217c54da363a68ad871e6868efec481c$__63493f6edc610bf06118f3565b6040518263ffffffff1660e01b8152600401610c0c9190614380565b60006040518083038186803b158015610c2457600080fd5b505af4158015610c38573d6000803e3d6000fd5b50505050610703611b3a565b6000610703610bc860017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f161499c565b73__$ec217c54da363a68ad871e6868efec481c$__63d19cc38a610c966118f3565b6040518263ffffffff1660e01b8152600401610cb29190614380565b60006040518083038186803b158015610cca57600080fd5b505af4158015610cde573d6000803e3d6000fd5b50505050610cea611c07565b5050565b60015460408051808201909152600a81526914d08e8811195b9a595960b21b60208201526000918291906001600160a01b03163314610d405760405162461bcd60e51b81526004016107cc91906143ee565b50610d4b6001611cc3565b915091509091565b333014610da25760405162461bcd60e51b815260206004820152601b60248201527f496e637265617365207265766973696f6e20666f7262696464656e000000000060448201526064016107cc565b6000610dd2610bc860017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd61499c565b610ddd9060016146e0565b9050610e1181610e0e60017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd61499c565b55565b610e4082610e0e60017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e461499c565b604080518281526001600160a01b03841660208201527ff27e2ef832a4eb8ed8ec553b875eecd44764cda95b1c24170e281539e0a869c8910160405180910390a15050565b60015460008054604051633e53813360e11b815291926001600160a01b0390811692620100009092041690839073__$ec217c54da363a68ad871e6868efec481c$__90637ca7026690610ede9086908690600401614952565b602060405180830381865af4158015610efb573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f1f91906146b1565b905080851115610fcb57600080610f3e610f39848961499c565b611df2565b604051631594b05b60e01b8152909850919350915073__$ec217c54da363a68ad871e6868efec481c$__90631594b05b90610f859087908790879087908c9060040161496c565b602060405180830381865af4158015610fa2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610fc691906146b1565b925050505b6040516333bbb20360e11b815260048101869052602481018290526001600160a01b0380841660448301528416606482015273__$ec217c54da363a68ad871e6868efec481c$__9063677764069060840160006040518083038186803b15801561103457600080fd5b505af4158015611048573d6000803e3d6000fd5b50505050505050919050565b6006805461106190614786565b80601f016020809104026020016040519081016040528092919081815260200182805461108d90614786565b80156110da5780601f106110af576101008083540402835291602001916110da565b820191906000526020600020905b8154815290600101906020018083116110bd57829003601f168201915b505050505081565b6110ea611e23565b73__$ec217c54da363a68ad871e6868efec481c$__63bd02068261110c6118f3565b60005460015460405160e085901b6001600160e01b03191681526001600160a01b039384166004820152620100009092048316602483015291909116604482015260640160006040518083038186803b15801561116857600080fd5b505af415801561117c573d6000803e3d6000fd5b50505050565b73__$ec217c54da363a68ad871e6868efec481c$__63eae13e766111a46118f3565b84846040518463ffffffff1660e01b81526004016111c4939291906149af565b60006040518083038186803b1580156111dc57600080fd5b505af41580156111f0573d6000803e3d6000fd5b5060069250611204915083905084836149ef565b505050565b73__$8f1afe7577f9ab973017c74eca19b86f3c$__63a0113d4861122b6118f3565b836040518363ffffffff1660e01b8152600401611249929190614aae565b60006040518083038186803b15801561126157600080fd5b505af4158015611275573d6000803e3d6000fd5b50505060369190915550565b73__$8f1afe7577f9ab973017c74eca19b86f3c$__63d2c3cf256112a36118f3565b836040518363ffffffff1660e01b81526004016112c1929190614aae565b60006040518083038186803b1580156112d957600080fd5b505af41580156112ed573d6000803e3d6000fd5b50505060359190915550565b6000610703610bc860017f22573091f17911fb166032a3d9e0554aa73d31b7b7ddea4a4dd2995650af84bd61499c565b60335460408051808201909152600a81526914d08e8811195b9a595960b21b60208201526000916001600160a01b03169033821461137a5760405162461bcd60e51b81526004016107cc91906143ee565b5060008061138786611f2a565b91509150600061139687611f96565b9050858110156113fc5760006113aa612006565b905080156113fa5760006113bd826120b0565b90507faebc771af58936b05e89b0be7d3f9761480181abcd4a649fbdd01753fda1697082826040516113f0929190614af7565b60405180910390a1505b505b73__$e930d50fb5f4f1298547dbcb2bb0591990$__6399c1fde4878486886114226118f3565b60005460405160e088901b6001600160e01b031916815261145d9695949392916201000090046001600160a01b031690603490600401614b10565b602060405180830381865af415801561147a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061149e91906146b1565b94506114a8612378565b505050505092915050565b60335460408051808201909152600a81526914d08e8811195b9a595960b21b6020820152906001600160a01b031633146115005760405162461bcd60e51b81526004016107cc91906143ee565b508151815160408051808201909152600d81526c54532d3139206c656e6774687360981b60208201529082146115495760405162461bcd60e51b81526004016107cc91906143ee565b5061117c612378565b6000610703610bc860017fbfaaa2fb63266ff27c2da975f5894955056f50419af651a81f6c5060581857e461499c565b600154600080546040516001625acc3160e01b031981529192839273__$ec217c54da363a68ad871e6868efec481c$__9263ffa533cf926115db926001600160a01b039182169262010000900490911690600401614952565b602060405180830381865af41580156115f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061161c91906146b1565b905080156116315761162e818461238c565b91505b5092915050565b60006116426118f3565b6001600160a01b0316826001600160a01b0316149050919050565b606060005b60088110156116f7576065546040516354c49fe960e01b8152600481018390526000916001600160a01b0316906354c49fe990602401602060405180830381865afa1580156116b5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906116d99190614b5f565b6001600160a01b0316146116f7576116f081614b7c565b9050611662565b806001600160401b0381111561170f5761170f614492565b604051908082528060200260200182016040528015611738578160200160208202803683370190505b50915060005b818110156117ed576065546040516354c49fe960e01b8152600481018390526001600160a01b03909116906354c49fe990602401602060405180830381865afa15801561178f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906117b39190614b5f565b8382815181106117c5576117c5614b95565b6001600160a01b03909216602092830291909101909101526117e681614b7c565b905061173e565b505090565b73__$ec217c54da363a68ad871e6868efec481c$__630568a9d56118146118f3565b600254846040518463ffffffff1660e01b815260040161183693929190614bab565b60006040518083038186803b15801561184e57600080fd5b505af4158015611862573d6000803e3d6000fd5b50505060029190915550565b6000816001600160a01b03166118826118f3565b6001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa1580156118bf573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906118e39190614b5f565b6001600160a01b03161492915050565b6000610703610bc860017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c361861499c565b60006001600160e01b0319821663c19fa56160e01b148061072d575061072d826123b3565b600054610100900460ff1661196f5760405162461bcd60e51b81526004016107cc90614bcc565b806001600160a01b03166338fff2d06040518163ffffffff1660e01b8152600401602060405180830381865afa1580156119ad573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906119d191906146b1565b60645560405163a8ea687560e01b8152733b8ca519122cdd8efb272b0d3085453404b25bd09063a8ea687590611a0b908490600401614380565b602060405180830381865afa158015611a28573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a4c9190614b5f565b606580546001600160a01b0319166001600160a01b03928316908117909155611a7a918316906000196123e8565b50565b600054610100900460ff16611aa45760405162461bcd60e51b81526004016107cc90614bcc565b611aae8383612522565b603380546001600160a01b0319166001600160a01b038316179055611ad76064620186a0614c17565b6035557fe4166dfcf23bbd3e3f764a99dc8fa740554c03c82d6019b81cf265f396f6f2fe611b096064620186a0614c17565b60405190815260200160405180910390a1505050565b6000806000611b2f600019611df2565b925092509250909192565b6000806000611b5d600060029054906101000a90046001600160a01b0316611f2a565b9150915073__$e930d50fb5f4f1298547dbcb2bb0591990$__63c9bce69083611b8c611b87612006565b6126f6565b6033546040516001600160e01b031960e086901b168152611bbf93929187916001600160a01b0390911690600401614c39565b602060405180830381865af4158015611bdc573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611c0091906146b1565b9250505090565b6060806000806000611c17612821565b603354929550909350915073__$8f1afe7577f9ab973017c74eca19b86f3c$__9063e99de4da906001600160a01b0316611c4f6128c3565b8686866040518663ffffffff1660e01b8152600401611c72959493929190614c80565b600060405180830381865af4158015611c8f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611cb79190810190614d9d565b90969095509350505050565b600080600080611cd3600161295a565b915091506000611ce1612a13565b919650945090506000611d28878015611d145750620186a085603554611d079190614df6565b611d119190614c17565b83115b611d1f576000611d21565b825b8486612aa3565b91506000905080611d75611d3c85886146e0565b6000548590611d59906201000090046001600160a01b0316611f96565b603254611d6691906146e0565b611d7091906146e0565b612d6e565b915091506040805187815260208101879052908101899052606081018890526080810183905260a081018290527f3e9abbc366dbf9fe260e2640c06eefbedd7720cf986ae553374e46b804f4ff559060c00160405180910390a1611dd982896146e0565b611de382896146e0565b97509750505050505050915091565b6000806000806000611e04600161295a565b91509150611e13868284612d9e565b5091989097509095509350505050565b6000611e2d613479565b90507f768a28cb3459382a3d2173feb2dad0235f8de680b109872da581a3aa269fe5f481604051611e5e9190614e0d565b60405180910390a1600080548190611e84906201000090046001600160a01b0316611f2a565b603354919350915073__$e930d50fb5f4f1298547dbcb2bb0591990$__906358b54f16906001600160a01b0316611ec1611ebc6118f3565b61348b565b846034600019886040518763ffffffff1660e01b8152600401611ee996959493929190614e20565b602060405180830381865af4158015611f06573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061154991906146b1565b60606000611f366128c3565b9150611f4282846134ef565b90506000198114156040518060400160405280600f81526020016e53423a2057726f6e672076616c756560881b81525090611f905760405162461bcd60e51b81526004016107cc91906143ee565b50915091565b6040516370a0823160e01b81526000906001600160a01b038316906370a0823190611fc5903090600401614380565b602060405180830381865afa158015611fe2573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072d91906146b1565b600061201460645460601c90565b6001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161203f9190614380565b602060405180830381865afa15801561205c573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061208091906146b1565b6065546040516370a0823160e01b81526001600160a01b03909116906370a08231906106b8903090600401614380565b6064546065546040516370a0823160e01b8152606092916001600160a01b03169082841c9060009082906370a08231906120ee903090600401614380565b602060405180830381865afa15801561210b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061212f91906146b1565b90506000836001600160a01b03166370a08231306040518263ffffffff1660e01b815260040161215f9190614380565b602060405180830381865afa15801561217c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906121a091906146b1565b905060008288116121b25760006121bc565b6121bc838961499c565b905080156121cf57818111156121cf5750805b801561223057604051632e1a7d4d60e01b8152600481018290526001600160a01b03861690632e1a7d4d90602401600060405180830381600087803b15801561221757600080fd5b505af115801561222b573d6000803e3d6000fd5b505050505b61223a82846146e0565b8810156122da5760405163209f6ae760e01b815273__$e2d6e18942209f9a9d99e72afc74bc8af1$__9063209f6ae7906122909073ba12222222228d8ba445958a75a0704d566bf2c8908a908690600401614bab565b600060405180830381865af41580156122ad573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526122d59190810190614e5d565b61236c565b604051634b4c46fd60e01b815273__$e2d6e18942209f9a9d99e72afc74bc8af1$__90634b4c46fd906123279073ba12222222228d8ba445958a75a0704d566bf2c8908a90600401614aae565b600060405180830381865af4158015612344573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261236c9190810190614e5d565b98975050505050505050565b6000612382611b3a565b6032819055919050565b600080600061239a8461295a565b915091506123a9858284612aa3565b5095945050505050565b60006001600160e01b0319821663b7b79fa960e01b148061072d57506301ffc9a760e01b6001600160e01b031983161461072d565b8015806124615750604051636eb1769f60e11b81526001600160a01b0384169063dd62ed3e9061241e9030908690600401614952565b602060405180830381865afa15801561243b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061245f91906146b1565b155b6124cc5760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b60648201526084016107cc565b6112048363095ea7b360e01b84846040516024016124eb929190614aae565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b03199093169290921790915261354d565b600054610100900460ff166125495760405162461bcd60e51b81526004016107cc90614bcc565b612573817fd2de0374d4479f33e63ae5ed6ca772a10463dd883a90c612050b51fab619640061361f565b61257c82613675565b60405163b429afeb60e01b81526001600160a01b0382169063b429afeb906125a8908590600401614380565b602060405180830381865afa1580156125c5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906125e99190614e91565b6040518060400160405280600f81526020016e53423a2057726f6e672076616c756560881b8152509061262f5760405162461bcd60e51b81526004016107cc91906143ee565b50806001600160a01b03166338d52e0f6040518163ffffffff1660e01b8152600401602060405180830381865afa15801561266e573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906126929190614b5f565b600080546001600160a01b03928316620100000262010000600160b01b031990911617905560018054929091166001600160a01b031992831617905560048054909116739cc199d4353b5fb3e6c8eebc99f5139e0d8ea06b17905550612710600555565b60606000612702612006565b90508060000361275d576127146128c3565b516001600160401b0381111561272c5761272c614492565b604051908082528060200260200182016040528015612755578160200160208202803683370190505b509392505050565b6064805460405163f91294e960e01b815273ba12222222228d8ba445958a75a0704d566bf2c8600482015273239e55f427d44c3cc793f49bfb507ebe76638a2b6024820152604481019190915290810184905273__$e2d6e18942209f9a9d99e72afc74bc8af1$__9063f91294e990608401600060405180830381865af41580156127ec573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526128149190810190614e5d565b9392505050565b50919050565b6065546060908190819073__$e2d6e18942209f9a9d99e72afc74bc8af1$__90633a7e535c906001600160a01b03166128586128c3565b61286061165d565b6040518463ffffffff1660e01b815260040161287e93929190614eae565b600060405180830381865af415801561289b573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052611b2f9190810190614eee565b606454604051633db1bdf160e11b815260609173__$e2d6e18942209f9a9d99e72afc74bc8af1$__91637b637be2916129159173ba12222222228d8ba445958a75a0704d566bf2c89190600401614aae565b600060405180830381865af4158015612932573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107039190810190614f75565b6000808215612a075760325461296e612378565b600154604051636e5b9cc760e11b815260048101849052602481018390526001600160a01b03909116604482015290935073__$e930d50fb5f4f1298547dbcb2bb0591990$__9063dcb7398e90606401602060405180830381865af41580156129db573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906129ff91906146b1565b915050915091565b50506032546000915091565b600080600080612a37600060029054906101000a90046001600160a01b0316611f96565b9050600080612a44611c07565b91509150612a52828261388e565b600054612a6d906201000090046001600160a01b0316611f96565b9350600080612a7c8587612d6e565b9092509050612a8b82896146e0565b612a9582896146e0565b975097505050505050909192565b6000805481906201000090046001600160a01b031681858711612ac7576000612ad1565b612ad1868861499c565b9050620186a085603554612ae59190614df6565b612aef9190614c17565b811115612c95578515612b9e5760015473__$8f1afe7577f9ab973017c74eca19b86f3c$__9063aac2718a90849089906001600160a01b0316612b3183611f96565b612b3b908b6146e0565b6040518563ffffffff1660e01b8152600401612b5a9493929190614fa9565b602060405180830381865af4158015612b77573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612b9b91906146b1565b92505b6000612ba983611f96565b9050600080612bcc600060029054906101000a90046001600160a01b0316611f2a565b6033549193509150600090612bec906001600160a01b031686858561392e565b90506000612bf982613b56565b5090507f59400c8c523464b521238ea8f50e923f2bc64663557e6afec92a97f7efe92d058282604051612c2d929190614fd3565b60405180910390a16000612c3f612378565b90506000612c4c89611f96565b9050612c58878d6146e0565b612c6282846146e0565b1015612c8957612c7281836146e0565b612c7c888e6146e0565b612c86919061499c565b9a505b50505050505050612d64565b8515612d64576000612ca683611f96565b905086811015612cc957612cbc60008888612d9e565b9097509550612d62915050565b60015473__$8f1afe7577f9ab973017c74eca19b86f3c$__9063aac2718a9085908a906001600160a01b0316612cff868c6146e0565b6040518563ffffffff1660e01b8152600401612d1e9493929190614fa9565b602060405180830381865af4158015612d3b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612d5f91906146b1565b93505b505b5050935093915050565b60008083831115612d8a57612d83848461499c565b9150612d97565b612d94838561499c565b90505b9250929050565b600080600080612e3f604051806102200160405280600015158152602001606081526020016000815260200160008152602001600081526020016000815260200160608152602001600081526020016060815260200160008152602001600081526020016060815260200160006001600160a01b0316815260200160008152602001600081526020016060815260200160006001600160a01b031681525090565b60001988148082526000935080612e5e5750612e5b87896146e0565b15155b8015612e6957508515155b1561346057612e766128c3565b61016082018190526000546001600160a01b036201000090910481166101808401819052603354909116610200840152612eb091906134ef565b6101a0820152610180810151612ec590611f96565b6101c0820152612ed3613cce565b6020820152612ee0613d65565b6040820152612eed612006565b6060820152610200810151610180820151604051637a55caf360e01b815273__$e930d50fb5f4f1298547dbcb2bb0591990$__92637a55caf392612f3392600401614952565b602060405180830381865af4158015612f50573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612f7491906146b1565b60a0820152805173__$8f1afe7577f9ab973017c74eca19b86f3c$__9063ec0cc4fd90612faa57612fa5898b6146e0565b612fad565b60005b30846101600151856101a001518661020001518c88606001516040518863ffffffff1660e01b8152600401612fe89796959493929190615001565b600060405180830381865af4158015613005573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261302d9190810190615050565b60c0830152608082018190521561316b5761304b81608001516120b0565b6101e0820152613059612006565b8160600151613068919061499c565b608082018190526101e08201516040517faebc771af58936b05e89b0be7d3f9761480181abcd4a649fbdd01753fda16970926130a5929091614af7565b60405180910390a173__$e930d50fb5f4f1298547dbcb2bb0591990$__637a9a23e5826102000151836101600151846101a001518560200151866080015187604001518860c00151896101e001516040518963ffffffff1660e01b815260040161311698979695949392919061508c565b600060405180830381865af4158015613133573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f1916820160405261315b919081019061510e565b60c0830152610100820152613207565b6102008101516101608201516101a083015160c0840151604051636138ea8560e01b815273__$e930d50fb5f4f1298547dbcb2bb0591990$__94636138ea85946131bb9491939092600401615144565b600060405180830381865af41580156131d8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526132009190810190614e5d565b6101008201525b73__$e930d50fb5f4f1298547dbcb2bb0591990$__63f1f2b573826101600151836101a001518460c00151856102000151613243611ebc6118f3565b875161325a578d8f61325591906146e0565b61325c565b8e5b88610100015160346040518963ffffffff1660e01b8152600401613287989796959493929190615180565b602060405180830381865af41580156132a4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906132c891906146b1565b8160e0018181516132d991906146e0565b9052508615613388576101808101516001546101c083015173__$8f1afe7577f9ab973017c74eca19b86f3c$__9263aac2718a9290918b916001600160a01b031690613325908c6146e0565b6040518563ffffffff1660e01b81526004016133449493929190614fa9565b602060405180830381865af4158015613361573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061338591906146b1565b91505b613390612378565b6101208201526101808101516133a590611f96565b6101408201526101c08101516133bb90876146e0565b878261014001518361012001516133d291906146e0565b6133dc91906146e0565b101561342a57868161014001518261012001516133f991906146e0565b61340391906146e0565b6101c082015161341390886146e0565b61341d919061499c565b61342790846146e0565b92505b670de0b6b3a76400008160a001518260e001516134479190614df6565b6134519190614c17565b8160a001519450945050613470565b6000806000809450945094509450505b93509350935093565b6060610703613486612006565b6120b0565b6000816001600160a01b0316634046ebae6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156134cb573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061072d9190614b5f565b8151600090815b8181101561354157836001600160a01b031685828151811061351a5761351a614b95565b60200260200101516001600160a01b03160361353957915061072d9050565b6001016134f6565b50600019949350505050565b60006135a2826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b0316613dd49092919063ffffffff16565b80519091501561120457808060200190518101906135c09190614e91565b6112045760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b60648201526084016107cc565b6136298282613deb565b610cea5760405162461bcd60e51b815260206004820152601a60248201527f496e74657266616365206973206e6f7420737570706f7274656400000000000060448201526064016107cc565b600054610100900460ff1661369c5760405162461bcd60e51b81526004016107cc90614bcc565b6001600160a01b0381166136e45760405162461bcd60e51b815260206004820152600f60248201526e2d32b9379031b7b73a3937b63632b960891b60448201526064016107cc565b61370e817f4c2403fdcb3cff9b705d96bf0705858e3390412670a62c8bcba611ca7e20ab8661361f565b60006001600160a01b0316816001600160a01b0316635aa6e6756040518163ffffffff1660e01b8152600401602060405180830381865afa158015613757573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061377b9190614b5f565b6001600160a01b0316036137c35760405162461bcd60e51b815260206004820152600f60248201526e5a65726f20676f7665726e616e636560881b60448201526064016107cc565b6137f281610e0e60017f5165972ef41194f06c5007493031d0b927c20741adcb74403b954009fd2c361861499c565b61382142610e0e60017f6f55f470bdc9cb5f04223fd822021061668e4dccb43e8727b295106dc9769c8b61499c565b61385043610e0e60017f812a673dfca07956350df10f8a654925f561d7a0da09bdbe79e653939a14d9f161499c565b7f1a2dd071001ebf6e03174e3df5b305795a4ad5d41d8fdb9ba41dbbe23671342681424360405161388393929190614bab565b60405180910390a150565b815180156112045760006138a28484613ec9565b905073__$8f1afe7577f9ab973017c74eca19b86f3c$__63acf741a36138c66118f3565b6001546040516001600160e01b031960e085901b1681526138f892916001600160a01b031690899087906004016151f6565b60006040518083038186803b15801561391057600080fd5b505af4158015613924573d6000803e3d6000fd5b5050505050505050565b606060008061393b614087565b9150915073__$8f1afe7577f9ab973017c74eca19b86f3c$__6359d0ede687878585898d6001600160a01b031663f77c47916040518163ffffffff1660e01b8152600401602060405180830381865afa15801561399c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139c09190614b5f565b6001600160a01b0316632630c12f6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156139fd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613a219190614b5f565b6040518763ffffffff1660e01b8152600401613a4296959493929190615234565b600060405180830381865af4158015613a5f573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052613a879190810190614e5d565b925073__$e930d50fb5f4f1298547dbcb2bb0591990$__631a2221c788878787603460008c8c81518110613abd57613abd614b95565b60200260200101516001600160a01b03166001600160a01b03168152602001908152602001600020546040518663ffffffff1660e01b8152600401613b06959493929190615287565b600060405180830381865af4158015613b23573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052613b4b9190810190614e5d565b979650505050505050565b60645460405163423511a360e01b815260609160009181841c9073__$e2d6e18942209f9a9d99e72afc74bc8af1$__9063423511a390613bb29073ba12222222228d8ba445958a75a0704d566bf2c89086908a906004016152d6565b600060405180830381865af4158015613bcf573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052613bf791908101906152fd565b6065546040516370a0823160e01b81529296509094506001600160a01b039081169163b6b55f25918416906370a0823190613c36903090600401614380565b602060405180830381865afa158015613c53573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613c7791906146b1565b6040518263ffffffff1660e01b8152600401613c9591815260200190565b600060405180830381600087803b158015613caf57600080fd5b505af1158015613cc3573d6000803e3d6000fd5b505050505050915091565b60645460405163464a5ef760e01b815260609173__$e2d6e18942209f9a9d99e72afc74bc8af1$__9163464a5ef791613d209173ba12222222228d8ba445958a75a0704d566bf2c89190600401614aae565b600060405180830381865af4158015613d3d573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107039190810190614e5d565b6000613d7360645460601c90565b6001600160a01b031663876f303b6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613db0573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070391906146b1565b6060613de38484600085614120565b949350505050565b60006001600160a01b038316613e325760405162461bcd60e51b815260206004820152600c60248201526b5a65726f206164647265737360a01b60448201526064016107cc565b823b6000819003613e4757600091505061072d565b6040516301ffc9a760e01b81526001600160e01b0319841660048201526001600160a01b038516906301ffc9a790602401602060405180830381865afa925050508015613eb1575060408051601f3d908101601f19168201909252613eae91810190614e91565b60015b15613ebf57915061072d9050565b5060009392505050565b60008054603354600254606093620100009093046001600160a01b03908116939273__$e930d50fb5f4f1298547dbcb2bb0591990$__9263ef50284f92909116908590613f146128c3565b613f1f611ebc6118f3565b60348c8c6005546040518a63ffffffff1660e01b8152600401613f4a99989796959493929190615343565b600060405180830381865af4158015613f67573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052613f8f91908101906152fd565b60015460048054603654604051631248faf160e21b81526001600160a01b03808a16948201949094526024810186905293831660448501529116606483015260848201529194509150600090819073__$8f1afe7577f9ab973017c74eca19b86f3c$__90634923ebc49060a4016040805180830381865af4158015614018573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061403c91906153c7565b915091507f4c300a656bfa0935e36cd55e92634bc20b2b7e0a0ebf424a2a25bfaac3a01e768786848460405161407594939291906153eb565b60405180910390a15050505092915050565b60645460405163552ad6a160e11b815260609160009173__$e2d6e18942209f9a9d99e72afc74bc8af1$__9163aa55ad42916140db9173ba12222222228d8ba445958a75a0704d566bf2c891600401614aae565b600060405180830381865af41580156140f8573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f19168201604052610d4b91908101906152fd565b6060824710156141815760405162461bcd60e51b815260206004820152602660248201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6044820152651c8818d85b1b60d21b60648201526084016107cc565b600080866001600160a01b0316858760405161419d9190615424565b60006040518083038185875af1925050503d80600081146141da576040519150601f19603f3d011682016040523d82523d6000602084013e6141df565b606091505b5091509150613b4b878383876060831561425a578251600003614253576001600160a01b0385163b6142535760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e747261637400000060448201526064016107cc565b5081613de3565b613de3838381511561426f5781518083602001fd5b8060405162461bcd60e51b81526004016107cc91906143ee565b60006020828403121561429b57600080fd5b81356001600160e01b03198116811461281457600080fd5b6001600160a01b0381168114611a7a57600080fd5b600080600080608085870312156142de57600080fd5b84356142e9816142b3565b935060208501356142f9816142b3565b92506040850135614309816142b3565b91506060850135614319816142b3565b939692955090935050565b6000806040838503121561433757600080fd5b8235614342816142b3565b946020939093013593505050565b6000806040838503121561436357600080fd5b823591506020830135614375816142b3565b809150509250929050565b6001600160a01b0391909116815260200190565b6000602082840312156143a657600080fd5b8135612814816142b3565b6000602082840312156143c357600080fd5b5035919050565b60005b838110156143e55781810151838201526020016143cd565b50506000910152565b602081526000825180602084015261440d8160408501602087016143ca565b601f01601f19169190910160400192915050565b6000806020838503121561443457600080fd5b82356001600160401b038082111561444b57600080fd5b818501915085601f83011261445f57600080fd5b81358181111561446e57600080fd5b86602082850101111561448057600080fd5b60209290920196919550909350505050565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f191681016001600160401b03811182821017156144d0576144d0614492565b604052919050565b60006001600160401b038211156144f1576144f1614492565b5060051b60200190565b600082601f83011261450c57600080fd5b8135602061452161451c836144d8565b6144a8565b82815260059290921b8401810191818101908684111561454057600080fd5b8286015b8481101561455b5780358352918301918301614544565b509695505050505050565b6000806040838503121561457957600080fd5b82356001600160401b038082111561459057600080fd5b818501915085601f8301126145a457600080fd5b813560206145b461451c836144d8565b82815260059290921b840181019181810190898411156145d357600080fd5b948201945b838610156145fa5785356145eb816142b3565b825294820194908201906145d8565b9650508601359250508082111561461057600080fd5b5061461d858286016144fb565b9150509250929050565b8015158114611a7a57600080fd5b6000806040838503121561464857600080fd5b82359150602083013561437581614627565b600081518084526020808501945080840160005b838110156146935781516001600160a01b03168752958201959082019060010161466e565b509495945050505050565b602081526000612814602083018461465a565b6000602082840312156146c357600080fd5b5051919050565b634e487b7160e01b600052601160045260246000fd5b8082018082111561072d5761072d6146ca565b60006020828403121561470557600080fd5b81516001600160401b038082111561471c57600080fd5b818401915084601f83011261473057600080fd5b81518181111561474257614742614492565b614755601f8201601f19166020016144a8565b915080825285602082850101111561476c57600080fd5b61477d8160208401602086016143ca565b50949350505050565b600181811c9082168061479a57607f821691505b60208210810361281b57634e487b7160e01b600052602260045260246000fd5b601f82111561120457600081815260208120601f850160051c810160208610156147e15750805b601f850160051c820191505b81811015614800578281556001016147ed565b505050505050565b81516001600160401b0381111561482157614821614492565b6148358161482f8454614786565b846147ba565b602080601f83116001811461486a57600084156148525750858301515b600019600386901b1c1916600185901b178555614800565b600085815260208120601f198616915b828110156148995788860151825594840194600190910190840161487a565b50858210156148b75787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b60006020808352600084546148db81614786565b808487015260406001808416600081146148fc576001811461491657614944565b60ff1985168984015283151560051b890183019550614944565b896000528660002060005b8581101561493c5781548b8201860152908301908801614921565b8a0184019650505b509398975050505050505050565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b039586168152602081019490945260408401929092526060830152909116608082015260a00190565b8181038181111561072d5761072d6146ca565b6001600160a01b03841681526040602082018190528101829052818360608301376000818301606090810191909152601f909201601f1916010192915050565b6001600160401b03831115614a0657614a06614492565b614a1a83614a148354614786565b836147ba565b6000601f841160018114614a4e5760008515614a365750838201355b600019600387901b1c1916600186901b178355610914565b600083815260209020601f19861690835b82811015614a7f5786850135825560209485019460019092019101614a5f565b5086821015614a9c5760001960f88860031b161c19848701351681555b505060018560011b0183555050505050565b6001600160a01b03929092168252602082015260400190565b600081518084526020808501945080840160005b8381101561469357815187529582019590820190600101614adb565b828152604060208201526000613de36040830184614ac7565b87815286602082015260e060408201526000614b2f60e083018861465a565b6001600160a01b0396871660608401529486166080830152509190931660a082015260c001919091529392505050565b600060208284031215614b7157600080fd5b8151612814816142b3565b600060018201614b8e57614b8e6146ca565b5060010190565b634e487b7160e01b600052603260045260246000fd5b6001600160a01b039390931683526020830191909152604082015260600190565b6020808252602b908201527f496e697469616c697a61626c653a20636f6e7472616374206973206e6f74206960408201526a6e697469616c697a696e6760a81b606082015260800190565b600082614c3457634e487b7160e01b600052601260045260246000fd5b500490565b608081526000614c4c608083018761465a565b8281036020840152614c5e8187614ac7565b604084019590955250506001600160a01b039190911660609091015292915050565b6001600160a01b038616815260a060208201819052600090614ca49083018761465a565b8281036040840152614cb6818761465a565b90508281036060840152614cca8186614ac7565b9050828103608084015261236c8185614ac7565b600082601f830112614cef57600080fd5b81516020614cff61451c836144d8565b82815260059290921b84018101918181019086841115614d1e57600080fd5b8286015b8481101561455b578051614d35816142b3565b8352918301918301614d22565b600082601f830112614d5357600080fd5b81516020614d6361451c836144d8565b82815260059290921b84018101918181019086841115614d8257600080fd5b8286015b8481101561455b5780518352918301918301614d86565b60008060408385031215614db057600080fd5b82516001600160401b0380821115614dc757600080fd5b614dd386838701614cde565b93506020850151915080821115614de957600080fd5b5061461d85828601614d42565b808202811582820484141761072d5761072d6146ca565b6020815260006128146020830184614ac7565b600060018060a01b03808916835280881660208401525085604083015284606083015283608083015260c060a083015261236c60c083018461465a565b600060208284031215614e6f57600080fd5b81516001600160401b03811115614e8557600080fd5b61162e84828501614d42565b600060208284031215614ea357600080fd5b815161281481614627565b6001600160a01b0384168152606060208201819052600090614ed29083018561465a565b8281036040840152614ee4818561465a565b9695505050505050565b600080600060608486031215614f0357600080fd5b83516001600160401b0380821115614f1a57600080fd5b614f2687838801614cde565b94506020860151915080821115614f3c57600080fd5b614f4887838801614d42565b93506040860151915080821115614f5e57600080fd5b50614f6b86828701614d42565b9150509250925092565b600060208284031215614f8757600080fd5b81516001600160401b03811115614f9d57600080fd5b61162e84828501614cde565b6001600160a01b039485168152602081019390935292166040820152606081019190915260800190565b604081526000614fe66040830185614ac7565b8281036020840152614ff88185614ac7565b95945050505050565b878152600060018060a01b03808916602084015260e0604084015261502960e084018961465a565b606084019790975294909416608082015260a081019290925260c090910152509392505050565b6000806040838503121561506357600080fd5b8251915060208301516001600160401b0381111561508057600080fd5b61461d85828601614d42565b6001600160a01b0389168152610100602082018190526000906150b18382018b61465a565b905088604084015282810360608401526150cb8189614ac7565b90508660808401528560a084015282810360c08401526150eb8186614ac7565b905082810360e08401526150ff8185614ac7565b9b9a5050505050505050505050565b6000806040838503121561512157600080fd5b82516001600160401b038082111561513857600080fd5b614dd386838701614d42565b6001600160a01b03851681526080602082018190526000906151689083018661465a565b8460408401528281036060840152613b4b8185614ac7565b60006101008083526151948184018c61465a565b905089602084015282810360408401526151ae818a614ac7565b6001600160a01b0389811660608601528816608085015260a0840187905283810360c085015290506151e08186614ac7565b9150508260e08301529998505050505050505050565b6001600160a01b038581168252841660208201526080604082018190526000906152229083018561465a565b8281036060840152613b4b8185614ac7565b86815260c06020820152600061524d60c083018861465a565b828103604084015261525f8188614ac7565b6060840196909652505060808101929092526001600160a01b031660a0909101529392505050565b6001600160a01b038616815260a0602082018190526000906152ab9083018761465a565b85604084015282810360608401526152c38186614ac7565b9150508260808301529695505050505050565b60018060a01b0384168152826020820152606060408201526000614ff86060830184614ac7565b6000806040838503121561531057600080fd5b82516001600160401b0381111561532657600080fd5b61533285828601614d42565b925050602083015190509250929050565b6001600160a01b038a81168252898116602083015260408201899052610120606083018190526000916153788483018b61465a565b91508089166080850152508660a084015282810360c084015261539b818761465a565b905082810360e08401526153af8186614ac7565b915050826101008301529a9950505050505050505050565b600080604083850312156153da57600080fd5b505080516020909101519092909150565b6080815260006153fe608083018761465a565b82810360208401526154108187614ac7565b604084019590955250506060015292915050565b600082516154368184602087016143ca565b919091019291505056fea2646970667358221220fcc119c3fd2c6dbc71e5638429e85838e44225697725e8432e92e553174ae37a64736f6c63430008110033",
  "libraries": {
    "StrategyLib": "0x3BEB969c0cd273eA1d7a39137a757Cf1c474510a",
    "ConverterStrategyBaseLib": "0x6b2ca816F59b3d66ded56A5aBE6f186Fa30650DA",
    "ConverterStrategyBaseLib2": "0xc989b6183E5af088FD04DB1A3C93bE69c8Ff25E0",
    "BalancerLogicLib": "0x599d50a55Ae457d6d0014F71b32af2cAB05D5C96"
  },
  "devdoc": {
    "author": "a17, dvpublic",
    "kind": "dev",
    "methods": {
      "claim()": {
        "details": "Manual claim rewards."
      },
      "created()": {
        "returns": {
          "_0": "Creation timestamp"
        }
      },
      "createdBlock()": {
        "returns": {
          "_0": "Creation block number"
        }
      },
      "doHardWork()": {
        "returns": {
          "earned": "Earned amount in terms of {asset}",
          "lost": "Lost amount in terms of {asset}"
        }
      },
      "emergencyExit()": {
        "details": "In case of any issue operator can withdraw all from pool."
      },
      "increaseRevision(address)": {
        "details": "Revision should be increased on each contract upgrade"
      },
      "investAll(uint256,bool)": {
        "params": {
          "updateTotalAssetsBeforeInvest_": "Recalculate total assets amount before depositing.                                       It can be false if we know exactly, that the amount is already actual."
        },
        "returns": {
          "strategyLoss": "Loss should be covered from Insurance"
        }
      },
      "isController(address)": {
        "details": "Return true if given address is controller"
      },
      "onTransferAmounts(address[],uint256[])": {
        "params": {
          "amounts_": "Amount of {asset_} that has been sent to the user's balance",
          "assets_": "Any asset sent to the balance, i.e. inside repayTheBorrow"
        }
      },
      "previousImplementation()": {
        "details": "Previous logic implementation"
      },
      "requirePayAmountBack(address,uint256)": {
        "params": {
          "amount_": "Required amount of the {theAsset_}",
          "theAsset_": "Required asset (either collateral or borrow)"
        },
        "returns": {
          "amountOut": "Amount sent to balance of TetuConverter, amountOut <= amount_"
        }
      },
      "revision()": {
        "details": "Contract upgrade counter"
      },
      "rewardTokens()": {
        "details": "Returns reward token addresses array."
      },
      "setCompoundRatio(uint256)": {
        "details": "PlatformVoter can change compound ratio for some strategies.      A strategy can implement another logic for some uniq cases."
      },
      "setReinvestThresholdPercent(uint256)": {
        "params": {
          "percent_": "New value of the percent, decimals = {REINVEST_THRESHOLD_PERCENT_DENOMINATOR}"
        }
      },
      "setStrategySpecificName(string)": {
        "details": "The name will be used for UI."
      },
      "supportsInterface(bytes4)": {
        "details": "See {IERC165-supportsInterface}."
      },
      "totalAssets()": {
        "details": "Total amount of underlying assets under control of this strategy."
      },
      "withdrawAllToSplitter()": {
        "details": "Withdraws all underlying assets to the vault",
        "returns": {
          "strategyLoss": "Loss should be covered from Insurance"
        }
      },
      "withdrawToSplitter(uint256)": {
        "details": "Withdraws some assets to the splitter",
        "returns": {
          "strategyLoss": "Loss should be covered from Insurance"
        }
      }
    },
    "title": "Delta-neutral converter strategy for Balancer boosted pools",
    "version": 1
  },
  "userdoc": {
    "events": {
      "Recycle(address[],uint256[],uint256,uint256)": {
        "notice": "Recycle was made"
      }
    },
    "kind": "user",
    "methods": {
      "CONTROLLABLE_VERSION()": {
        "notice": "Version of the contract"
      },
      "capacity()": {
        "notice": "Unlimited capacity by default"
      },
      "controller()": {
        "notice": "Return controller address saved in the contract slot"
      },
      "created()": {
        "notice": "Return creation timestamp"
      },
      "createdBlock()": {
        "notice": "Return creation block number"
      },
      "doHardWork()": {
        "notice": "Do hard work with reinvesting"
      },
      "investAll(uint256,bool)": {
        "notice": "Stakes everything the strategy holds into the reward pool. amount_ Amount transferred to the strategy balance just before calling this function"
      },
      "investedAssets()": {
        "notice": "Amount of underlying assets converted to pool assets and invested to the pool."
      },
      "isGovernance(address)": {
        "notice": "Return true if given address is setup as governance in Controller"
      },
      "isReadyToHardWork()": {
        "notice": "Is strategy ready to hard work"
      },
      "liquidationThresholds(address)": {
        "notice": "Minimum token amounts that can be liquidated"
      },
      "onTransferAmounts(address[],uint256[])": {
        "notice": "TetuConverter calls this function when it sends any amount to user's balance"
      },
      "performanceFee()": {
        "notice": "A percent of total profit that is sent to the {performanceReceiver} before compounding"
      },
      "performanceFeeRatio()": {
        "notice": "Ratio to split performance fee on toPerf + toInsurance, [0..100_000]         100_000 - send full amount toPerf, 0 - send full amount toInsurance."
      },
      "performanceReceiver()": {
        "notice": "{performanceFee}% of total profit is sent to {performanceReceiver} before compounding"
      },
      "poolId()": {
        "notice": "i.e. for \"Balancer Boosted Aave USD\": 0x48e6b98ef6329f8f0a30ebb8c7c960330d64808500000000000000000000075bi.e. for \"Balancer Boosted Tetu USD\": 0xb3d658d5b95bf04e2932370dd1ff976fe18dd66a000000000000000000000ace"
      },
      "reinvestThresholdPercent()": {
        "notice": "Percent of asset amount that can be not invested, it's allowed to just keep it on balance         decimals = {DENOMINATOR}"
      },
      "requirePayAmountBack(address,uint256)": {
        "notice": "Converters asks to send some amount back."
      },
      "setPerformanceFeeRatio(uint256)": {
        "notice": "[0..100_000], 100_000 - send full amount toPerf, 0 - send full amount toInsurance."
      },
      "setupPerformanceFee(uint256,address)": {
        "notice": "Set performance fee and receiver"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 11696,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "_initialized",
        "offset": 0,
        "slot": "0",
        "type": "t_uint8"
      },
      {
        "astId": 11699,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "_initializing",
        "offset": 1,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 16585,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "asset",
        "offset": 2,
        "slot": "0",
        "type": "t_address"
      },
      {
        "astId": 16589,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "splitter",
        "offset": 0,
        "slot": "1",
        "type": "t_address"
      },
      {
        "astId": 16593,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "compoundRatio",
        "offset": 0,
        "slot": "2",
        "type": "t_uint256"
      },
      {
        "astId": 16595,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "__deprecatedSlot1",
        "offset": 0,
        "slot": "3",
        "type": "t_uint256"
      },
      {
        "astId": 16599,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "performanceReceiver",
        "offset": 0,
        "slot": "4",
        "type": "t_address"
      },
      {
        "astId": 16603,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "performanceFee",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 16607,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "strategySpecificName",
        "offset": 0,
        "slot": "6",
        "type": "t_string_storage"
      },
      {
        "astId": 17004,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "__gap",
        "offset": 0,
        "slot": "7",
        "type": "t_array(t_uint256)43_storage"
      },
      {
        "astId": 63536,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "_investedAssets",
        "offset": 0,
        "slot": "50",
        "type": "t_uint256"
      },
      {
        "astId": 63540,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "converter",
        "offset": 0,
        "slot": "51",
        "type": "t_contract(ITetuConverter)42883"
      },
      {
        "astId": 63545,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "liquidationThresholds",
        "offset": 0,
        "slot": "52",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 63548,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "reinvestThresholdPercent",
        "offset": 0,
        "slot": "53",
        "type": "t_uint256"
      },
      {
        "astId": 63551,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "performanceFeeRatio",
        "offset": 0,
        "slot": "54",
        "type": "t_uint256"
      },
      {
        "astId": 65043,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "__gap",
        "offset": 0,
        "slot": "55",
        "type": "t_array(t_uint256)45_storage"
      },
      {
        "astId": 70250,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "poolId",
        "offset": 0,
        "slot": "100",
        "type": "t_bytes32"
      },
      {
        "astId": 70253,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "gauge",
        "offset": 0,
        "slot": "101",
        "type": "t_contract(IBalancerGauge)59404"
      },
      {
        "astId": 70682,
        "contract": "contracts/strategies/balancer/BalancerBoostedStrategy.sol:BalancerBoostedStrategy",
        "label": "__gap",
        "offset": 0,
        "slot": "102",
        "type": "t_array(t_uint256)48_storage"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_array(t_uint256)43_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[43]",
        "numberOfBytes": "1376"
      },
      "t_array(t_uint256)45_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[45]",
        "numberOfBytes": "1440"
      },
      "t_array(t_uint256)48_storage": {
        "base": "t_uint256",
        "encoding": "inplace",
        "label": "uint256[48]",
        "numberOfBytes": "1536"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_contract(IBalancerGauge)59404": {
        "encoding": "inplace",
        "label": "contract IBalancerGauge",
        "numberOfBytes": "20"
      },
      "t_contract(ITetuConverter)42883": {
        "encoding": "inplace",
        "label": "contract ITetuConverter",
        "numberOfBytes": "20"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_string_storage": {
        "encoding": "bytes",
        "label": "string",
        "numberOfBytes": "32"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      },
      "t_uint8": {
        "encoding": "inplace",
        "label": "uint8",
        "numberOfBytes": "1"
      }
    }
  }
}